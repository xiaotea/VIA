{
    "Products/CMFPlone/PloneTool.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     @security.public"
            },
            "2": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     def portal_utf8(self, str, errors='strict'):"
            },
            "3": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Transforms an string in portal encoding to utf8.\"\"\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        # Transforms an string in portal encoding to utf8."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "6": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         return utils.portal_utf8(self, str, errors)"
            },
            "7": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     @security.public"
            },
            "9": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     def utf8_portal(self, str, errors='strict'):"
            },
            "10": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Transforms an utf8 string to portal encoding.\"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        # Transforms an utf8 string to portal encoding."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "13": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         return utils.utf8_portal(self, str, errors)"
            },
            "14": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     @security.private"
            },
            "16": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 338,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "     @security.protected(View)"
            },
            "18": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 340,
                "PatchRowcode": "     def getReviewStateTitleFor(self, obj):"
            },
            "19": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Utility method that gets the workflow state title for the"
            },
            "20": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        object's review_state."
            },
            "21": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "22": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Returns None if no review_state found."
            },
            "23": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+        # Utility method that gets the workflow state title for the"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+        # object's review_state."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+        # Returns None if no review_state found."
            },
            "27": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "         wf_tool = getToolByName(self, 'portal_workflow')"
            },
            "28": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "         wfs = ()"
            },
            "29": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 346,
                "PatchRowcode": "         objstate = None"
            },
            "30": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 407,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "     @security.public"
            },
            "32": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "     def urlparse(self, url):"
            },
            "33": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Returns the pieces of url in a six-part tuple."
            },
            "34": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "35": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Since Python 2.6: urlparse now returns a ParseResult object."
            },
            "36": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        We just need the tuple form which is tuple(result)."
            },
            "37": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        # Returns the pieces of url in a six-part tuple."
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+        # Since Python 2.6: urlparse now returns a ParseResult object."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        # We just need the tuple form which is tuple(result)."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "42": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 414,
                "PatchRowcode": "         return tuple(parse.urlparse(url))"
            },
            "43": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 415,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "     @security.public"
            },
            "45": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 417,
                "PatchRowcode": "     def urlunparse(self, url_tuple):"
            },
            "46": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Puts a url back together again, in the manner that"
            },
            "47": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        urlparse breaks it."
            },
            "48": {
                "beforePatchRowNumber": 421,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        # Puts a url back together again, in the manner that"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+        # urlparse breaks it."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "52": {
                "beforePatchRowNumber": 422,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "         return parse.urlunparse(url_tuple)"
            },
            "53": {
                "beforePatchRowNumber": 423,
                "afterPatchRowNumber": 422,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 424,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "     # Enable scripts to get the string value of an exception even if the"
            },
            "55": {
                "beforePatchRowNumber": 551,
                "afterPatchRowNumber": 550,
                "PatchRowcode": " "
            },
            "56": {
                "beforePatchRowNumber": 552,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "     @security.public"
            },
            "57": {
                "beforePatchRowNumber": 553,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "     def addPortalMessage(self, message, type='info', request=None):"
            },
            "58": {
                "beforePatchRowNumber": 554,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"\\"
            },
            "59": {
                "beforePatchRowNumber": 555,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Call this once or more to add messages to be displayed at the"
            },
            "60": {
                "beforePatchRowNumber": 556,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        top of the web page."
            },
            "61": {
                "beforePatchRowNumber": 557,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "62": {
                "beforePatchRowNumber": 558,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        The arguments are:"
            },
            "63": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            message:   a string, with the text message you want to show,"
            },
            "64": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       or a HTML fragment (see type='structure' below)"
            },
            "65": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            type:      optional, defaults to 'info'. The type determines how"
            },
            "66": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       the message will be rendered, as it is used to select"
            },
            "67": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       the CSS class for the message. Predefined types are:"
            },
            "68": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       'info' - for informational messages"
            },
            "69": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       'warning' - for warning messages"
            },
            "70": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       'error' - for messages about restricted access or"
            },
            "71": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                 errors."
            },
            "72": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "73": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Portal messages are by default rendered by the global_statusmessage.pt"
            },
            "74": {
                "beforePatchRowNumber": 570,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        page template."
            },
            "75": {
                "beforePatchRowNumber": 571,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "76": {
                "beforePatchRowNumber": 572,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        It is also possible to add messages from page templates, as"
            },
            "77": {
                "beforePatchRowNumber": 573,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        long as they are processed before the portal_message macro is"
            },
            "78": {
                "beforePatchRowNumber": 574,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        called by the main template. Example:"
            },
            "79": {
                "beforePatchRowNumber": 575,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "80": {
                "beforePatchRowNumber": 576,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-          <tal:block tal:define=\"temp python:context.plone_utils.addPortalMessage('A random info message')\" />  # noqa"
            },
            "81": {
                "beforePatchRowNumber": 577,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 553,
                "PatchRowcode": "+        # Call this once or more to add messages to be displayed at the"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 554,
                "PatchRowcode": "+        # top of the web page."
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 555,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 556,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 557,
                "PatchRowcode": "+        # This might not be possible, but type=\"structure\" below sounds dangerous,"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 558,
                "PatchRowcode": "+        # although I find no support for it in code."
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 559,
                "PatchRowcode": "+"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 560,
                "PatchRowcode": "+        # The arguments are:"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 561,
                "PatchRowcode": "+        #     message:   a string, with the text message you want to show,"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 562,
                "PatchRowcode": "+        #                or a HTML fragment (see type='structure' below)"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 563,
                "PatchRowcode": "+        #     type:      optional, defaults to 'info'. The type determines how"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 564,
                "PatchRowcode": "+        #                the message will be rendered, as it is used to select"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+        #                the CSS class for the message. Predefined types are:"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 566,
                "PatchRowcode": "+        #                'info' - for informational messages"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+        #                'warning' - for warning messages"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+        #                'error' - for messages about restricted access or"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 569,
                "PatchRowcode": "+        #                          errors."
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 571,
                "PatchRowcode": "+        # Portal messages are by default rendered by the global_statusmessage.pt"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 572,
                "PatchRowcode": "+        # page template."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 573,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 574,
                "PatchRowcode": "+        # It is also possible to add messages from page templates, as"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 575,
                "PatchRowcode": "+        # long as they are processed before the portal_message macro is"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+        # called by the main template. Example:"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+        #   <tal:block tal:define=\"temp python:context.plone_utils.addPortalMessage('A random info message')\" />  # noqa"
            },
            "108": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "         if request is None:"
            },
            "109": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "             request = self.REQUEST"
            },
            "110": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "         IStatusMessage(request).add(message, type=type)"
            },
            "111": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 593,
                "PatchRowcode": " "
            },
            "112": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "     @security.public"
            },
            "113": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 595,
                "PatchRowcode": "     def browserDefault(self, obj):"
            },
            "114": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Sets default so we can return whatever we want instead of index_html."
            },
            "115": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "116": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        This method is complex, and interacts with mechanisms such as"
            },
            "117": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and"
            },
            "118": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        various mechanisms for setting the default page."
            },
            "119": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "120": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        The method returns a tuple (obj, [path]) where path is a path to"
            },
            "121": {
                "beforePatchRowNumber": 602,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        a template or other object to be acquired and displayed on the object."
            },
            "122": {
                "beforePatchRowNumber": 603,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        The path is determined as follows:"
            },
            "123": {
                "beforePatchRowNumber": 604,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "124": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        0. If we're c oming from WebDAV, make sure we don't return a contained"
            },
            "125": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            object \"default page\" ever"
            },
            "126": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        1. If there is an index_html attribute (either a contained object or"
            },
            "127": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            an explicit attribute) on the object, return that as the"
            },
            "128": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"default page\". Note that this may be used by things like"
            },
            "129": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            File and Image to return the contents of the file, for example,"
            },
            "130": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            not just content-space objects created by the user."
            },
            "131": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        2. If the object implements IBrowserDefault, query this for the"
            },
            "132": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            default page."
            },
            "133": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        3. If the object has a property default_page set and this gives a list"
            },
            "134": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            of, or single, object id, and that object is is found in the"
            },
            "135": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            folder or is the name of a skin template, return that id"
            },
            "136": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        4. If the property default_page is set in site_properties and that"
            },
            "137": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            property contains a list of ids of which one id is found in the"
            },
            "138": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            folder, return that id"
            },
            "139": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        5. If the object implements IBrowserDefault, try to get the selected"
            },
            "140": {
                "beforePatchRowNumber": 621,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            layout."
            },
            "141": {
                "beforePatchRowNumber": 622,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        6. If the type has a 'folderlisting' action and no default page is"
            },
            "142": {
                "beforePatchRowNumber": 623,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            set, use this action. This permits folders to have the default"
            },
            "143": {
                "beforePatchRowNumber": 624,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'view' action be 'string:${object_url}/' and hence default to"
            },
            "144": {
                "beforePatchRowNumber": 625,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            a default page when clicking the 'view' tab, whilst allowing the"
            },
            "145": {
                "beforePatchRowNumber": 626,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            fallback action to be specified TTW in portal_types (this action"
            },
            "146": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            is typically hidden)"
            },
            "147": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        7. If nothing else is found, fall back on the object's 'view' action."
            },
            "148": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        8. If this is not found, raise an AttributeError"
            },
            "149": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+        # Sets default so we can return whatever we want instead of index_html."
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+        # This method is complex, and interacts with mechanisms such as"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+        # IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 602,
                "PatchRowcode": "+        # various mechanisms for setting the default page."
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 603,
                "PatchRowcode": "+"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 604,
                "PatchRowcode": "+        # The method returns a tuple (obj, [path]) where path is a path to"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+        # a template or other object to be acquired and displayed on the object."
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+        # The path is determined as follows:"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+        # 0. If we're c oming from WebDAV, make sure we don't return a contained"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+        #     object \"default page\" ever"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+        # 1. If there is an index_html attribute (either a contained object or"
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 611,
                "PatchRowcode": "+        #     an explicit attribute) on the object, return that as the"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 612,
                "PatchRowcode": "+        #     \"default page\". Note that this may be used by things like"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 613,
                "PatchRowcode": "+        #     File and Image to return the contents of the file, for example,"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 614,
                "PatchRowcode": "+        #     not just content-space objects created by the user."
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+        # 2. If the object implements IBrowserDefault, query this for the"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+        #     default page."
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+        # 3. If the object has a property default_page set and this gives a list"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+        #     of, or single, object id, and that object is is found in the"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+        #     folder or is the name of a skin template, return that id"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+        # 4. If the property default_page is set in site_properties and that"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+        #     property contains a list of ids of which one id is found in the"
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+        #     folder, return that id"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+        # 5. If the object implements IBrowserDefault, try to get the selected"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+        #     layout."
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 625,
                "PatchRowcode": "+        # 6. If the type has a 'folderlisting' action and no default page is"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 626,
                "PatchRowcode": "+        #     set, use this action. This permits folders to have the default"
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 627,
                "PatchRowcode": "+        #     'view' action be 'string:${object_url}/' and hence default to"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+        #     a default page when clicking the 'view' tab, whilst allowing the"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 629,
                "PatchRowcode": "+        #     fallback action to be specified TTW in portal_types (this action"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 630,
                "PatchRowcode": "+        #     is typically hidden)"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+        # 7. If nothing else is found, fall back on the object's 'view' action."
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 632,
                "PatchRowcode": "+        # 8. If this is not found, raise an AttributeError"
            },
            "187": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 633,
                "PatchRowcode": " "
            },
            "188": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 634,
                "PatchRowcode": "         # WebDAV in Zope is odd it takes the incoming verb eg: PROPFIND"
            },
            "189": {
                "beforePatchRowNumber": 633,
                "afterPatchRowNumber": 635,
                "PatchRowcode": "         # and then requests that object, for example for: /, with verb PROPFIND"
            },
            "190": {
                "beforePatchRowNumber": 789,
                "afterPatchRowNumber": 791,
                "PatchRowcode": " "
            },
            "191": {
                "beforePatchRowNumber": 790,
                "afterPatchRowNumber": 792,
                "PatchRowcode": "     @security.public"
            },
            "192": {
                "beforePatchRowNumber": 791,
                "afterPatchRowNumber": 793,
                "PatchRowcode": "     def getOwnerName(self, obj):"
            },
            "193": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\" Returns the userid of the owner of an object.\"\"\""
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 794,
                "PatchRowcode": "+        # Returns the userid of the owner of an object."
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 795,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "196": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": 796,
                "PatchRowcode": "         mt = getToolByName(self, 'portal_membership')"
            },
            "197": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": 797,
                "PatchRowcode": "         if not mt.checkPermission(View, obj):"
            },
            "198": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": 798,
                "PatchRowcode": "             raise Unauthorized"
            },
            "199": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": 799,
                "PatchRowcode": "         return obj.getOwner().getId()"
            },
            "200": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": 800,
                "PatchRowcode": " "
            },
            "201": {
                "beforePatchRowNumber": 798,
                "afterPatchRowNumber": 801,
                "PatchRowcode": "     @security.public"
            },
            "202": {
                "beforePatchRowNumber": 799,
                "afterPatchRowNumber": 802,
                "PatchRowcode": "     def normalizeString(self, text):"
            },
            "203": {
                "beforePatchRowNumber": 800,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Normalizes a title to an id."
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 803,
                "PatchRowcode": "+        # Normalizes a title to an id."
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 804,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "206": {
                "beforePatchRowNumber": 801,
                "afterPatchRowNumber": 805,
                "PatchRowcode": " "
            },
            "207": {
                "beforePatchRowNumber": 802,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        The relaxed mode was removed in Plone 4.0. You should use either the"
            },
            "208": {
                "beforePatchRowNumber": 803,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url or file name normalizer from the plone.i18n package instead."
            },
            "209": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 806,
                "PatchRowcode": "+        # The relaxed mode was removed in Plone 4.0. You should use either the"
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 807,
                "PatchRowcode": "+        # url or file name normalizer from the plone.i18n package instead."
            },
            "211": {
                "beforePatchRowNumber": 804,
                "afterPatchRowNumber": 808,
                "PatchRowcode": " "
            },
            "212": {
                "beforePatchRowNumber": 805,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        normalizeString() converts a whole string to a normalized form that"
            },
            "213": {
                "beforePatchRowNumber": 806,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        should be safe to use as in a url, as a css id, etc."
            },
            "214": {
                "beforePatchRowNumber": 807,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 809,
                "PatchRowcode": "+        # normalizeString() converts a whole string to a normalized form that"
            },
            "216": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 810,
                "PatchRowcode": "+        # should be safe to use as in a url, as a css id, etc."
            },
            "217": {
                "beforePatchRowNumber": 808,
                "afterPatchRowNumber": 811,
                "PatchRowcode": "         return utils.normalizeString(text, context=self)"
            },
            "218": {
                "beforePatchRowNumber": 809,
                "afterPatchRowNumber": 812,
                "PatchRowcode": " "
            },
            "219": {
                "beforePatchRowNumber": 810,
                "afterPatchRowNumber": 813,
                "PatchRowcode": "     @security.public"
            },
            "220": {
                "beforePatchRowNumber": 963,
                "afterPatchRowNumber": 966,
                "PatchRowcode": " "
            },
            "221": {
                "beforePatchRowNumber": 964,
                "afterPatchRowNumber": 967,
                "PatchRowcode": "     @security.public"
            },
            "222": {
                "beforePatchRowNumber": 965,
                "afterPatchRowNumber": 968,
                "PatchRowcode": "     def getEmptyTitle(self, translated=True):"
            },
            "223": {
                "beforePatchRowNumber": 966,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Returns string to be used for objects with no title or id.\"\"\""
            },
            "224": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 969,
                "PatchRowcode": "+        # Returns string to be used for objects with no title or id."
            },
            "225": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 970,
                "PatchRowcode": "+        # Note: no docstring please, to avoid reflected XSS."
            },
            "226": {
                "beforePatchRowNumber": 967,
                "afterPatchRowNumber": 971,
                "PatchRowcode": "         return utils.getEmptyTitle(self, translated)"
            },
            "227": {
                "beforePatchRowNumber": 968,
                "afterPatchRowNumber": 972,
                "PatchRowcode": " "
            },
            "228": {
                "beforePatchRowNumber": 969,
                "afterPatchRowNumber": 973,
                "PatchRowcode": "     @security.public"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from AccessControl import ClassSecurityInfo",
            "from AccessControl import getSecurityManager",
            "from AccessControl import Unauthorized",
            "from AccessControl.requestmethod import postonly",
            "from Acquisition import aq_base",
            "from Acquisition import aq_inner",
            "from Acquisition import aq_parent",
            "from AccessControl.class_init import InitializeClass",
            "from ComputedAttribute import ComputedAttribute",
            "from DateTime import DateTime",
            "from email.utils import getaddresses",
            "from OFS.ObjectManager import bad_id",
            "from OFS.SimpleItem import SimpleItem",
            "from plone.registry.interfaces import IRegistry",
            "from Products.CMFCore.interfaces import IDublinCore",
            "from Products.CMFCore.interfaces import IMutableDublinCore",
            "from Products.CMFCore.permissions import AccessContentsInformation",
            "from Products.CMFCore.permissions import ManagePortal",
            "from Products.CMFCore.permissions import ManageUsers",
            "from Products.CMFCore.permissions import ModifyPortalContent",
            "from Products.CMFCore.permissions import View",
            "from Products.CMFCore.utils import getToolByName",
            "from Products.CMFCore.utils import UniqueObject",
            "from Products.CMFCore.WorkflowCore import WorkflowException",
            "from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault",
            "from Products.CMFPlone import utils",
            "from Products.CMFPlone.defaultpage import check_default_page_via_view",
            "from Products.CMFPlone.defaultpage import get_default_page_via_view",
            "from Products.CMFPlone.events import ReorderedEvent",
            "from Products.CMFPlone.interfaces import INonStructuralFolder",
            "from Products.CMFPlone.interfaces import IPloneTool",
            "from Products.CMFPlone.interfaces import ISearchSchema",
            "from Products.CMFPlone.interfaces import ISecuritySchema",
            "from Products.CMFPlone.interfaces import ISiteSchema",
            "from Products.CMFPlone.log import log_deprecated",
            "from Products.CMFPlone.PloneBaseTool import PloneBaseTool",
            "from Products.CMFPlone.PloneFolder import ReplaceableWrapper",
            "from Products.CMFPlone.utils import base_hasattr",
            "from Products.CMFPlone.utils import log",
            "from Products.CMFPlone.utils import log_exc",
            "from Products.CMFPlone.utils import safe_hasattr",
            "from Products.CMFPlone.utils import safe_unicode",
            "from Products.CMFPlone.utils import transaction_note",
            "from Products.statusmessages.interfaces import IStatusMessage",
            "from six.moves.urllib import parse",
            "from ZODB.POSException import ConflictError",
            "from zope.component import getUtility",
            "from zope.component import queryAdapter",
            "from zope.deprecation import deprecate",
            "from zope.event import notify",
            "from zope.interface import implementer",
            "from zope.lifecycleevent import ObjectModifiedEvent",
            "",
            "import re",
            "import sys",
            "import six",
            "import transaction",
            "",
            "",
            "_marker = utils._marker",
            "_icons = {}",
            "",
            "CEILING_DATE = DateTime(2500, 0)  # never expires",
            "FLOOR_DATE = __FLOOR_DATE = DateTime(1970, 0)  # always effective",
            "BAD_CHARS = bad_id.__self__.findall",
            "",
            "# max 63 chars per label in domains, see RFC1035",
            "EMAIL_RE = re.compile(r\"^(\\w&.%#$&'\\*+-/=?^_`{}|~]+!)*[\\w&.%#$&'\\*+-/=?^_`{}|~]+@(([0-9a-z]([0-9a-z-]*[0-9a-z])?\\.)+[a-z]{2,63}|([0-9]{1,3}\\.){3}[0-9]{1,3})$\", re.IGNORECASE)  # noqa",
            "# used to find double new line (in any variant)",
            "EMAIL_CUTOFF_RE = re.compile(r\".*[\\n\\r][\\n\\r]\")",
            "",
            "# dublic core accessor name -> metadata name",
            "METADATA_DCNAME = {",
            "    # The first two rows are handle in a special way",
            "    # 'Description'      : 'description',",
            "    # 'Subject'          : 'keywords',",
            "    'Description': 'DC.description',",
            "    'Subject': 'DC.subject',",
            "    'Creator': 'DC.creator',",
            "    'Contributors': 'DC.contributors',",
            "    'Publisher': 'DC.publisher',",
            "    'CreationDate': 'DC.date.created',",
            "    'ModificationDate': 'DC.date.modified',",
            "    'Type': 'DC.type',",
            "    'Format': 'DC.format',",
            "    'Language': 'DC.language',",
            "    'Rights': 'DC.rights',",
            "}",
            "METADATA_DC_AUTHORFIELDS = ('Creator', 'Contributors', 'Publisher')",
            "",
            "",
            "@implementer(IPloneTool)",
            "class PloneTool(PloneBaseTool, UniqueObject, SimpleItem):",
            "    \"\"\"Various utility methods.\"\"\"",
            "",
            "    id = 'plone_utils'",
            "    meta_type = 'Plone Utility Tool'",
            "    toolicon = 'skins/plone_images/site_icon.png'",
            "    security = ClassSecurityInfo()",
            "    plone_tool = 1",
            "    # Prefix for forms fields!?",
            "    field_prefix = 'field_'",
            "",
            "    @security.protected(ManageUsers)",
            "    def setMemberProperties(self, member, REQUEST=None, **properties):",
            "        pas = getToolByName(self, 'acl_users')",
            "        if safe_hasattr(member, 'getId'):",
            "            member = member.getId()",
            "        user = pas.getUserById(member)",
            "        user.setProperties(**properties)",
            "",
            "    @security.public",
            "    @deprecate(('`getSiteEncoding` is deprecated. Plone only supports UTF-8 '",
            "                'currently. This method always returns \"utf-8\"'))",
            "    def getSiteEncoding(self):",
            "        \"\"\" Get the the site encoding, which is utf-8.\"\"\"",
            "        return 'utf-8'",
            "",
            "    @security.public",
            "    def portal_utf8(self, str, errors='strict'):",
            "        \"\"\"Transforms an string in portal encoding to utf8.\"\"\"",
            "        return utils.portal_utf8(self, str, errors)",
            "",
            "    @security.public",
            "    def utf8_portal(self, str, errors='strict'):",
            "        \"\"\"Transforms an utf8 string to portal encoding.\"\"\"",
            "        return utils.utf8_portal(self, str, errors)",
            "",
            "    @security.private",
            "    def getMailHost(self):",
            "        \"\"\"Gets the MailHost.\"\"\"",
            "        return getattr(aq_parent(self), 'MailHost')",
            "",
            "    @security.public",
            "    def validateSingleNormalizedEmailAddress(self, address):",
            "        # Lower-level function to validate a single normalized email address,",
            "        # see validateEmailAddress.",
            "        if not isinstance(address, six.string_types):",
            "            return False",
            "",
            "        sub = EMAIL_CUTOFF_RE.match(address)",
            "        if sub is not None:",
            "            # Address contains two newlines (possible spammer relay attack)",
            "            return False",
            "",
            "        # sub is an empty string if the address is valid",
            "        sub = EMAIL_RE.sub('', address)",
            "        if sub == '':",
            "            return True",
            "        return False",
            "",
            "    @security.public",
            "    def validateSingleEmailAddress(self, address):",
            "        # Validate a single email address, see also validateEmailAddresses.",
            "        if not isinstance(address, six.string_types):",
            "            return False",
            "",
            "        sub = EMAIL_CUTOFF_RE.match(address)",
            "        if sub is not None:",
            "            # Address contains two newlines (spammer attack using",
            "            # \"address\\n\\nSpam message\")",
            "            return False",
            "",
            "        if len(getaddresses([address])) != 1:",
            "            # none or more than one address",
            "            return False",
            "",
            "        # Validate the address",
            "        for name, addr in getaddresses([address]):",
            "            if not self.validateSingleNormalizedEmailAddress(addr):",
            "                return False",
            "        return True",
            "",
            "    @security.public",
            "    def validateEmailAddresses(self, addresses):",
            "        # Validate a list of possibly several email addresses, see also",
            "        # validateSingleEmailAddress.",
            "        if not isinstance(addresses, six.string_types):",
            "            return False",
            "",
            "        sub = EMAIL_CUTOFF_RE.match(addresses)",
            "        if sub is not None:",
            "            # Addresses contains two newlines (spammer attack using",
            "            # \"To: list\\n\\nSpam message\")",
            "            return False",
            "",
            "        # Validate each address",
            "        for name, addr in getaddresses([addresses]):",
            "            if not self.validateSingleNormalizedEmailAddress(addr):",
            "                return False",
            "        return True",
            "",
            "    @security.public",
            "    def editMetadata(self, obj, allowDiscussion=None, title=None,",
            "                     subject=None, description=None, contributors=None,",
            "                     effective_date=None, expiration_date=None, format=None,",
            "                     language=None, rights=None, **kwargs):",
            "        # Responsible for setting metadata on a content object.",
            "        # We assume the obj implements IDublinCoreMetadata.",
            "        mt = getToolByName(self, 'portal_membership')",
            "        if not mt.checkPermission(ModifyPortalContent, obj):",
            "            # FIXME: Some scripts rely on this being string?",
            "            raise Unauthorized",
            "",
            "        REQUEST = self.REQUEST",
            "        pfx = self.field_prefix",
            "",
            "        def getfield(request, name, default=None, pfx=pfx):",
            "            return request.form.get(pfx + name, default)",
            "",
            "        def tuplify(value):",
            "            return tuple(filter(None, value))",
            "",
            "        if IDublinCore.providedBy(obj):",
            "            if title is None:",
            "                title = getfield(REQUEST, 'title')",
            "            if description is None:",
            "                description = getfield(REQUEST, 'description')",
            "            if subject is None:",
            "                subject = getfield(REQUEST, 'subject')",
            "            if subject is not None:",
            "                subject = tuplify(subject)",
            "            if contributors is None:",
            "                contributors = getfield(REQUEST, 'contributors')",
            "            if contributors is not None:",
            "                contributors = tuplify(contributors)",
            "            if effective_date is None:",
            "                effective_date = getfield(REQUEST, 'effective_date')",
            "            if effective_date == '':",
            "                effective_date = 'None'",
            "            if expiration_date is None:",
            "                expiration_date = getfield(REQUEST, 'expiration_date')",
            "            if expiration_date == '':",
            "                expiration_date = 'None'",
            "",
            "        if IMutableDublinCore.providedBy(obj):",
            "            if title is not None:",
            "                obj.setTitle(title)",
            "            if description is not None:",
            "                obj.setDescription(description)",
            "            if subject is not None:",
            "                obj.setSubject(subject)",
            "            if contributors is not None:",
            "                obj.setContributors(contributors)",
            "            if effective_date is not None:",
            "                obj.setEffectiveDate(effective_date)",
            "            if expiration_date is not None:",
            "                obj.setExpirationDate(expiration_date)",
            "            if format is not None:",
            "                obj.setFormat(format)",
            "            if language is not None:",
            "                obj.setLanguage(language)",
            "            if rights is not None:",
            "                obj.setRights(rights)",
            "            # Make the catalog aware of changes",
            "            obj.reindexObject()",
            "",
            "    def _renameObject(self, obj, id):",
            "        if not id:",
            "            REQUEST = self.REQUEST",
            "            id = REQUEST.get('id', '')",
            "            id = REQUEST.get(self.field_prefix + 'id', '')",
            "        if id != obj.getId():",
            "            parent = aq_parent(aq_inner(obj))",
            "            parent.manage_renameObject(obj.getId(), id)",
            "",
            "    def _makeTransactionNote(self, obj, msg=u''):",
            "        # TODO Why not aq_parent()?",
            "        relative_path = '/'.join(",
            "            getToolByName(self, 'portal_url').getRelativeContentPath(obj)[:-1]",
            "        )",
            "        if not msg:",
            "            msg = relative_path + '/' + obj.title_or_id() \\",
            "                + ' has been modified.'",
            "        if not transaction.get().description:",
            "            transaction_note(safe_unicode(msg))",
            "",
            "    @security.public",
            "    def contentEdit(self, obj, **kwargs):",
            "        # Encapsulates how the editing of content occurs.",
            "        try:",
            "            self.editMetadata(obj, **kwargs)",
            "        except AttributeError as msg:",
            "            log('Failure editing metadata at: %s.\\n%s\\n' %",
            "                (obj.absolute_url(), msg))",
            "        if kwargs.get('id', None) is not None:",
            "            self._renameObject(obj, id=kwargs['id'].strip())",
            "        self._makeTransactionNote(obj)",
            "",
            "    @security.public",
            "    def availableMIMETypes(self):",
            "        # Returns a map of mimetypes.",
            "        # Requires mimetype registry from Archetypes >= 1.3.",
            "        mtr = getToolByName(self, 'mimetypes_registry')",
            "        return mtr.list_mimetypes()",
            "",
            "    @security.protected(View)",
            "    def getWorkflowChainFor(self, object):",
            "        # Proxy the request for the chain to the workflow tool, as",
            "        # this method is private there.",
            "        wftool = getToolByName(self, 'portal_workflow')",
            "        wfs = ()",
            "        try:",
            "            wfs = wftool.getChainFor(object)",
            "        except ConflictError:",
            "            raise",
            "        except:",
            "            pass",
            "        return wfs",
            "",
            "    @security.protected(View)",
            "    def getIconFor(self, category, id, default=_marker, context=None):",
            "        # Get an icon for an action, from its icon_expr.",
            "        if context is None:",
            "            context = aq_parent(self)",
            "        action_chain = '%s/%s' % (category, id)",
            "        if category == 'controlpanel':",
            "            tool = getToolByName(context, 'portal_controlpanel')",
            "            actions = [ai for ai in tool.listActionInfos() if ai['id'] == id]",
            "        else:",
            "            tool = getToolByName(context, 'portal_actions')",
            "            actions = tool.listActionInfos(",
            "                action_chain=action_chain, object=context)",
            "        if len(actions) > 0:",
            "            icon = actions[0].get('icon', None)",
            "            if icon:",
            "                return icon",
            "        else:",
            "            if default is not _marker:",
            "                icon = default",
            "            else:",
            "                raise KeyError(action_chain)",
            "",
            "        return icon",
            "",
            "    @security.protected(View)",
            "    def getReviewStateTitleFor(self, obj):",
            "        \"\"\"Utility method that gets the workflow state title for the",
            "        object's review_state.",
            "",
            "        Returns None if no review_state found.",
            "        \"\"\"",
            "        wf_tool = getToolByName(self, 'portal_workflow')",
            "        wfs = ()",
            "        objstate = None",
            "        try:",
            "            objstate = wf_tool.getInfoFor(obj, 'review_state')",
            "            wfs = wf_tool.getWorkflowsFor(obj)",
            "        except WorkflowException:",
            "            pass",
            "        if wfs:",
            "            for w in wfs:",
            "                if objstate in w.states:",
            "                    return w.states[objstate].title or objstate",
            "        return None",
            "",
            "    @security.protected(ManagePortal)",
            "    def changeOwnershipOf(self, object, userid, recursive=0, REQUEST=None):",
            "        \"\"\"Changes the ownership of an object.\"\"\"",
            "        membership = getToolByName(self, 'portal_membership')",
            "        acl_users = getattr(self, 'acl_users')",
            "        user = acl_users.getUserById(userid)",
            "        if user is None:",
            "            # The user could be in the top level acl_users folder in",
            "            # the Zope root, in which case this should find him:",
            "            user = membership.getMemberById(userid)",
            "            if user is None:",
            "                raise KeyError(",
            "                    'Only retrievable users in this site can be made owners.')",
            "            # Be careful not to pass MemberData to changeOwnership",
            "            user = user.getUser()",
            "        object.changeOwnership(user, recursive)",
            "",
            "        def fixOwnerRole(object, user_id):",
            "            # Get rid of all other owners",
            "            owners = object.users_with_local_role('Owner')",
            "            for o in owners:",
            "                roles = list(object.get_local_roles_for_userid(o))",
            "                roles.remove('Owner')",
            "                if roles:",
            "                    object.manage_setLocalRoles(o, roles)",
            "                else:",
            "                    object.manage_delLocalRoles([o])",
            "            # Fix for 1750",
            "            roles = list(object.get_local_roles_for_userid(user_id))",
            "            roles.append('Owner')",
            "            object.manage_setLocalRoles(user_id, roles)",
            "",
            "        fixOwnerRole(object, user.getId())",
            "        if base_hasattr(object, 'reindexObject'):",
            "            object.reindexObject()",
            "",
            "        if recursive:",
            "            catalog_tool = getToolByName(self, 'portal_catalog')",
            "            purl = getToolByName(self, 'portal_url')",
            "            _path = purl.getRelativeContentURL(object)",
            "            subobjects = [",
            "                b.getObject()",
            "                for b in catalog_tool(path={'query': _path, 'level': 1})",
            "            ]",
            "            for obj in subobjects:",
            "                fixOwnerRole(obj, user.getId())",
            "                if base_hasattr(obj, 'reindexObject'):",
            "                    obj.reindexObject()",
            "    changeOwnershipOf = postonly(changeOwnershipOf)",
            "",
            "    @security.public",
            "    def urlparse(self, url):",
            "        \"\"\"Returns the pieces of url in a six-part tuple.",
            "",
            "        Since Python 2.6: urlparse now returns a ParseResult object.",
            "        We just need the tuple form which is tuple(result).",
            "        \"\"\"",
            "        return tuple(parse.urlparse(url))",
            "",
            "    @security.public",
            "    def urlunparse(self, url_tuple):",
            "        \"\"\"Puts a url back together again, in the manner that",
            "        urlparse breaks it.",
            "        \"\"\"",
            "        return parse.urlunparse(url_tuple)",
            "",
            "    # Enable scripts to get the string value of an exception even if the",
            "    # thrown exception is a string and not a subclass of Exception.",
            "    def exceptionString(self):",
            "        # Don't assign the traceback to s",
            "        # (otherwise will generate a circular reference)",
            "        s = sys.exc_info()[:2]",
            "        if s[0] == None:",
            "            return None",
            "        if isinstance(s[0], six.string_types):",
            "            return s[0]",
            "        return str(s[1])",
            "",
            "    # Provide a way of dumping an exception to the log even if we",
            "    # catch it and otherwise ignore it",
            "    def logException(self):",
            "        # Dumps most recent exception to the log.",
            "        log_exc()",
            "",
            "    @security.public",
            "    def createSitemap(self, context, request=None):",
            "        # Returns a sitemap navtree structure.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return utils.createSiteMap(context, request)",
            "",
            "    def _addToNavTreeResult(self, result, data):",
            "        # Adds a piece of content to the result tree.",
            "        return utils.addToNavTreeResult(result, data)",
            "",
            "    @security.protected(AccessContentsInformation)",
            "    def typesToList(self):",
            "        return utils.typesToList(self)",
            "",
            "    @security.public",
            "    def createBreadCrumbs(self, context, request=None):",
            "        # Returns a structure for the portal breadcumbs.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return utils.createBreadCrumbs(context, request)",
            "",
            "    @security.public",
            "    def good_id(self, id):",
            "        # Exposes ObjectManager's bad_id test to skin scripts.",
            "        m = bad_id(id)",
            "        if m is not None:",
            "            return 0",
            "        return 1",
            "",
            "    @security.public",
            "    def bad_chars(self, id):",
            "        # Returns a list of the Bad characters.",
            "        return BAD_CHARS(id)",
            "",
            "    @security.public",
            "    def getInheritedLocalRoles(self, context):",
            "        # Returns a tuple with the acquired local roles.",
            "        portal = getToolByName(context, 'portal_url').getPortalObject()",
            "        result = []",
            "        cont = 1",
            "        if portal != context:",
            "            parent = aq_parent(context)",
            "            while cont:",
            "                if not getattr(parent, 'acl_users', False):",
            "                    break",
            "                userroles = parent.acl_users._getLocalRolesForDisplay(parent)",
            "                for user, roles, role_type, name in userroles:",
            "                    # Find user in result",
            "                    found = 0",
            "                    for user2, roles2, type2, name2 in result:",
            "                        if user2 == user:",
            "                            # Check which roles must be added to roles2",
            "                            for role in roles:",
            "                                if role not in roles2:",
            "                                    roles2.append(role)",
            "                            found = 1",
            "                            break",
            "                    if found == 0:",
            "                        # Add it to result and make sure roles is a list so",
            "                        # we may append and not overwrite the loop variable",
            "                        result.append([user, list(roles), role_type, name])",
            "                if parent == portal:",
            "                    cont = 0",
            "                elif not self.isLocalRoleAcquired(parent):",
            "                    # Role acquired check here",
            "                    cont = 0",
            "                else:",
            "                    parent = aq_parent(parent)",
            "",
            "        # Tuplize all inner roles",
            "        for pos in range(len(result) - 1, -1, -1):",
            "            result[pos][1] = tuple(result[pos][1])",
            "            result[pos] = tuple(result[pos])",
            "",
            "        return tuple(result)",
            "",
            "    #",
            "    # The three methods used in determining what the default-page of a folder",
            "    # is. These are:",
            "    #",
            "    #   - getDefaultPage(folder)",
            "    #       : get id of contentish object that is default-page in the folder",
            "    #   - isDefaultPage(object)",
            "    #       : determine if an object is the default-page in its parent folder",
            "    #   - browserDefault(object)",
            "    #       : lookup rules for old-style content types",
            "    #",
            "",
            "    @security.public",
            "    def isDefaultPage(self, obj, request=None):",
            "        # Finds out if the given obj is the default page in its parent folder.",
            "        # Uses the lookup rules of Plone.  Lookup happens over a view, for which",
            "        # in theory a different implementation may exist.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return check_default_page_via_view(obj, request)",
            "",
            "    @security.public",
            "    def getDefaultPage(self, obj, request=None):",
            "        # Given a folderish item, find out if it has a default-page using",
            "        # the lookup rules of Plone (see Products.CMFPlone/defaultpage.py).",
            "        # Lookup happens over a view, for which in theory a different",
            "        # implementation may be used.",
            "        if request is None:",
            "            if hasattr(self, 'REQUEST'):",
            "                request = self.REQUEST",
            "        if request:",
            "            return get_default_page_via_view(obj, request)",
            "",
            "    @security.public",
            "    def addPortalMessage(self, message, type='info', request=None):",
            "        \"\"\"\\",
            "        Call this once or more to add messages to be displayed at the",
            "        top of the web page.",
            "",
            "        The arguments are:",
            "            message:   a string, with the text message you want to show,",
            "                       or a HTML fragment (see type='structure' below)",
            "            type:      optional, defaults to 'info'. The type determines how",
            "                       the message will be rendered, as it is used to select",
            "                       the CSS class for the message. Predefined types are:",
            "                       'info' - for informational messages",
            "                       'warning' - for warning messages",
            "                       'error' - for messages about restricted access or",
            "                                 errors.",
            "",
            "        Portal messages are by default rendered by the global_statusmessage.pt",
            "        page template.",
            "",
            "        It is also possible to add messages from page templates, as",
            "        long as they are processed before the portal_message macro is",
            "        called by the main template. Example:",
            "",
            "          <tal:block tal:define=\"temp python:context.plone_utils.addPortalMessage('A random info message')\" />  # noqa",
            "        \"\"\"",
            "        if request is None:",
            "            request = self.REQUEST",
            "        IStatusMessage(request).add(message, type=type)",
            "",
            "    @security.public",
            "    def showPortalMessages(self, request=None):",
            "        # Return portal status messages that will be displayed when the",
            "        # response web page is rendered. Portal status messages are by default",
            "        # rendered by the global_statusmessage.pt page template. They will be",
            "        # removed after they have been shown.",
            "        # See addPortalMessages for examples.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return IStatusMessage(request).show()",
            "",
            "    @security.public",
            "    def browserDefault(self, obj):",
            "        \"\"\"Sets default so we can return whatever we want instead of index_html.",
            "",
            "        This method is complex, and interacts with mechanisms such as",
            "        IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and",
            "        various mechanisms for setting the default page.",
            "",
            "        The method returns a tuple (obj, [path]) where path is a path to",
            "        a template or other object to be acquired and displayed on the object.",
            "        The path is determined as follows:",
            "",
            "        0. If we're c oming from WebDAV, make sure we don't return a contained",
            "            object \"default page\" ever",
            "        1. If there is an index_html attribute (either a contained object or",
            "            an explicit attribute) on the object, return that as the",
            "            \"default page\". Note that this may be used by things like",
            "            File and Image to return the contents of the file, for example,",
            "            not just content-space objects created by the user.",
            "        2. If the object implements IBrowserDefault, query this for the",
            "            default page.",
            "        3. If the object has a property default_page set and this gives a list",
            "            of, or single, object id, and that object is is found in the",
            "            folder or is the name of a skin template, return that id",
            "        4. If the property default_page is set in site_properties and that",
            "            property contains a list of ids of which one id is found in the",
            "            folder, return that id",
            "        5. If the object implements IBrowserDefault, try to get the selected",
            "            layout.",
            "        6. If the type has a 'folderlisting' action and no default page is",
            "            set, use this action. This permits folders to have the default",
            "            'view' action be 'string:${object_url}/' and hence default to",
            "            a default page when clicking the 'view' tab, whilst allowing the",
            "            fallback action to be specified TTW in portal_types (this action",
            "            is typically hidden)",
            "        7. If nothing else is found, fall back on the object's 'view' action.",
            "        8. If this is not found, raise an AttributeError",
            "        \"\"\"",
            "",
            "        # WebDAV in Zope is odd it takes the incoming verb eg: PROPFIND",
            "        # and then requests that object, for example for: /, with verb PROPFIND",
            "        # means acquire PROPFIND from the folder and call it",
            "        # its all very odd and WebDAV'y",
            "        request = getattr(self, 'REQUEST', None)",
            "        if request is not None and 'REQUEST_METHOD' in request:",
            "            if request['REQUEST_METHOD'] not in ['GET', 'POST']:",
            "                return obj, [request['REQUEST_METHOD']]",
            "        # Now back to normal",
            "",
            "        #",
            "        # 1. Get an attribute or contained object index_html",
            "        #",
            "",
            "        # Note: The base PloneFolder, as well as ATCT's ATCTOrderedFolder",
            "        # defines a method index_html() which returns a ReplaceableWrapper.",
            "        # This is needed for WebDAV to work properly, and to avoid implicit",
            "        # acquisition of index_html's, which are generally on-object only.",
            "        # For the purposes of determining a default page, we don't want to",
            "        # use this index_html(), nor the ComputedAttribute which defines it.",
            "",
            "        if not isinstance(getattr(obj, 'index_html', None),",
            "                          ReplaceableWrapper):",
            "            index_obj = getattr(aq_base(obj), 'index_html', None)",
            "            if index_obj is not None \\",
            "                    and not isinstance(index_obj, ComputedAttribute):",
            "                return obj, ['index_html']",
            "",
            "        #",
            "        # 2. Look for a default_page managed by an IBrowserDefault-implementing",
            "        #    object",
            "        #",
            "        # 3. Look for a default_page property on the object",
            "        #",
            "        # 4. Try the default sitewide default_page setting",
            "        #",
            "",
            "        if obj.isPrincipiaFolderish:",
            "            defaultPage = self.getDefaultPage(obj)",
            "            if defaultPage is not None:",
            "                if defaultPage in obj:",
            "                    return obj, [defaultPage]",
            "                # Avoid infinite recursion in the case that the page id == the",
            "                # object id",
            "                elif (",
            "                    defaultPage != obj.getId()",
            "                    and defaultPage != '/'.join(obj.getPhysicalPath())",
            "                ):",
            "                    # For the default_page property, we may get things in the",
            "                    # skin layers or with an explicit path - split this path",
            "                    # to comply with the __browser_default__() spec",
            "                    return obj, defaultPage.split('/')",
            "",
            "        # 5. If there is no default page, try IBrowserDefault.getLayout()",
            "        if IBrowserDefault.providedBy(obj):",
            "            browserDefault = obj",
            "        else:",
            "            browserDefault = queryAdapter(obj, IBrowserDefault)",
            "        if browserDefault is not None:",
            "            default_view_fallback = False",
            "            if base_hasattr(obj, 'getTypeInfo'):",
            "                default_view_fallback = obj.getTypeInfo().default_view_fallback",
            "            layout = browserDefault.getLayout(check_exists=default_view_fallback)",
            "            if layout is None:",
            "                raise AttributeError(",
            "                    \"%s has no assigned layout, perhaps it needs an FTI\" % obj)",
            "            else:",
            "                return obj, [layout]",
            "",
            "        #",
            "        # 6. If the object has a 'folderlisting' action, use this",
            "        #",
            "",
            "        # This allows folders to determine in a flexible manner how they are",
            "        # displayed when there is no default page, whilst still using",
            "        # browserDefault() to show contained objects by default on the 'view'",
            "        # action (this applies to old-style folders only, IBrowserDefault is",
            "        # managed explicitly above)",
            "",
            "        if base_hasattr(obj, 'getTypeInfo'):",
            "            try:",
            "                # XXX: This isn't quite right since it assumes the action",
            "                # starts with ${object_url}.  Should we raise an error if",
            "                # it doesn't?",
            "                act = obj.getTypeInfo().getActionInfo(",
            "                    'folder/folderlisting'",
            "                )['url'].split('/')[-1]",
            "                return obj, [act]",
            "            except ValueError:",
            "                pass",
            "",
            "            #",
            "            # 7. Fall back on the 'view' action",
            "            #",
            "",
            "            try:",
            "                # XXX: This isn't quite right since it assumes the action",
            "                # starts with ${object_url}.  Should we raise an error if",
            "                # it doesn't?",
            "                act = obj.getTypeInfo().getActionInfo(",
            "                    'object/view'",
            "                )['url'].split('/')[-1]",
            "                return obj, [act]",
            "            except ValueError:",
            "                pass",
            "",
            "        #",
            "        # 8. If we can't find this either, raise an exception",
            "        #",
            "",
            "        raise AttributeError(",
            "            \"Failed to get a default page or view_action for %s\"",
            "            % (obj.absolute_url(),)",
            "        )",
            "",
            "    @security.public",
            "    def isStructuralFolder(self, obj):",
            "        \"\"\"Checks if a given object is a \"structural folder\".",
            "",
            "        That is, a folderish item which does not explicitly implement",
            "        INonStructuralFolder to declare that it doesn't wish to be treated",
            "        as a folder by the navtree, the tab generation etc.",
            "        \"\"\"",
            "        return (",
            "            obj.isPrincipiaFolderish",
            "            and not INonStructuralFolder.providedBy(obj)",
            "        )",
            "",
            "    @security.public",
            "    def acquireLocalRoles(self, obj, status=1, REQUEST=None):",
            "        # If status is 1, allow acquisition of local roles (regular",
            "        # behaviour).",
            "        # If it's 0, prohibit it (it will allow some kind of local role",
            "        # blacklisting).",
            "        mt = getToolByName(self, 'portal_membership')",
            "        if not mt.checkPermission(ModifyPortalContent, obj):",
            "            raise Unauthorized",
            "",
            "        # Set local role status...",
            "        # set the variable (or unset it if it's defined)",
            "        if not status:",
            "            obj.__ac_local_roles_block__ = 1",
            "        else:",
            "            if getattr(obj, '__ac_local_roles_block__', None):",
            "                obj.__ac_local_roles_block__ = None",
            "",
            "        # Reindex the whole stuff.",
            "        obj.reindexObjectSecurity()",
            "    acquireLocalRoles = postonly(acquireLocalRoles)",
            "",
            "    @security.public",
            "    def isLocalRoleAcquired(self, obj):",
            "        # Returns local role acquisition blocking status.",
            "        # True if normal, false if blocked.",
            "        if getattr(obj, '__ac_local_roles_block__', None):",
            "            return False",
            "        return True",
            "",
            "    @security.public",
            "    def getOwnerName(self, obj):",
            "        \"\"\" Returns the userid of the owner of an object.\"\"\"",
            "        mt = getToolByName(self, 'portal_membership')",
            "        if not mt.checkPermission(View, obj):",
            "            raise Unauthorized",
            "        return obj.getOwner().getId()",
            "",
            "    @security.public",
            "    def normalizeString(self, text):",
            "        \"\"\"Normalizes a title to an id.",
            "",
            "        The relaxed mode was removed in Plone 4.0. You should use either the",
            "        url or file name normalizer from the plone.i18n package instead.",
            "",
            "        normalizeString() converts a whole string to a normalized form that",
            "        should be safe to use as in a url, as a css id, etc.",
            "        \"\"\"",
            "        return utils.normalizeString(text, context=self)",
            "",
            "    @security.public",
            "    def listMetaTags(self, context):",
            "        # Lists meta tags helper.",
            "        # Creates a mapping of meta tags -> values for the listMetaTags script.",
            "        result = {}",
            "        mt = getToolByName(self, 'portal_membership')",
            "",
            "        registry = getUtility(IRegistry)",
            "        site_settings = registry.forInterface(",
            "            ISiteSchema, prefix=\"plone\", check=False)",
            "",
            "        try:",
            "            use_all = site_settings.exposeDCMetaTags",
            "        except AttributeError:",
            "            use_all = False",
            "",
            "        security_settings = registry.forInterface(",
            "            ISecuritySchema, prefix='plone')",
            "        view_about = security_settings.allow_anon_views_about \\",
            "            or not mt.isAnonymousUser()",
            "",
            "        if not use_all:",
            "            metadata_names = {'Description': METADATA_DCNAME['Description']}",
            "        else:",
            "            metadata_names = METADATA_DCNAME",
            "        for accessor, key in metadata_names.items():",
            "            # check non-public properties",
            "            if not view_about and accessor in METADATA_DC_AUTHORFIELDS:",
            "                continue",
            "",
            "            # short circuit non-special cases",
            "            if not use_all and accessor not in ('Description', 'Subject'):",
            "                continue",
            "",
            "            method = getattr(aq_inner(context).aq_explicit, accessor, None)",
            "            if not callable(method):",
            "                continue",
            "",
            "            # Catch AttributeErrors raised by some AT applications",
            "            try:",
            "                value = method()",
            "            except AttributeError:",
            "                value = None",
            "",
            "            if not value:",
            "                # No data",
            "                continue",
            "            if accessor == 'Publisher' and value == 'No publisher':",
            "                # No publisher is hardcoded (TODO: still?)",
            "                continue",
            "",
            "            # Check for fullnames",
            "            if view_about and accessor in METADATA_DC_AUTHORFIELDS:",
            "                if not isinstance(value, (list, tuple)):",
            "                    value = [value]",
            "                tmp = []",
            "                for userid in value:",
            "                    member = mt.getMemberInfo(userid)",
            "                    name = userid",
            "                    if member:",
            "                        name = member['fullname'] or userid",
            "                    tmp.append(name)",
            "                value = tmp",
            "",
            "            if isinstance(value, (list, tuple)):",
            "                # convert a list to a string",
            "                value = ', '.join(value)",
            "",
            "            # Special cases",
            "            if accessor == 'Description':",
            "                result['description'] = value",
            "            elif accessor == 'Subject':",
            "                result['keywords'] = value",
            "",
            "            if use_all:",
            "                result[key] = value",
            "",
            "        if use_all:",
            "            created = context.CreationDate()",
            "",
            "            try:",
            "                effective = context.EffectiveDate()",
            "                if effective == 'None':",
            "                    effective = None",
            "                if effective:",
            "                    effective = DateTime(effective)",
            "            except AttributeError:",
            "                effective = None",
            "",
            "            try:",
            "                expires = context.ExpirationDate()",
            "                if expires == 'None':",
            "                    expires = None",
            "                if expires:",
            "                    expires = DateTime(expires)",
            "            except AttributeError:",
            "                expires = None",
            "",
            "            # Filter out DWIMish artifacts on effective / expiration dates",
            "            if effective is not None and \\",
            "               effective > FLOOR_DATE and \\",
            "               effective != created:",
            "                eff_str = effective.Date()",
            "            else:",
            "                eff_str = ''",
            "",
            "            if expires is not None and expires < CEILING_DATE:",
            "                exp_str = expires.Date()",
            "            else:",
            "                exp_str = ''",
            "",
            "            if eff_str or exp_str:",
            "                result['DC.date.valid_range'] = '%s - %s' % (eff_str, exp_str)",
            "",
            "        return result",
            "",
            "    @security.public",
            "    def getUserFriendlyTypes(self, typesList=None):",
            "        # Get a list of types which are considered \"user friendly\" for search",
            "        # and selection purposes.",
            "        #",
            "        # This is the list of types available in the portal, minus those",
            "        # defined in the types_not_searched property in site_properties, if it",
            "        # exists.",
            "        #",
            "        # If typesList is given, this is used as the base list; else all types",
            "        # from portal_types are used.",
            "        if typesList is None:",
            "            typesList = []",
            "        registry = getUtility(IRegistry)",
            "        search_settings = registry.forInterface(ISearchSchema, prefix=\"plone\")",
            "        blacklistedTypes = search_settings.types_not_searched",
            "",
            "        ttool = getToolByName(self, 'portal_types')",
            "        tool_types = ttool.keys()",
            "        if typesList:",
            "            types = [t for t in typesList if t in tool_types]",
            "        else:",
            "            types = tool_types",
            "",
            "        friendlyTypes = set(types) - set(blacklistedTypes)",
            "        return list(friendlyTypes)",
            "",
            "    @security.public",
            "    def reindexOnReorder(self, parent):",
            "        # Reindexing of \"gopip\" isn't needed any longer,",
            "        # but some extensions might need the info anyway. :(",
            "        notify(ReorderedEvent(parent))",
            "",
            "    @security.public",
            "    def isIDAutoGenerated(self, id):",
            "        # Determine if an id is autogenerated.",
            "        return utils.isIDAutoGenerated(self, id)",
            "",
            "    @security.public",
            "    def getEmptyTitle(self, translated=True):",
            "        \"\"\"Returns string to be used for objects with no title or id.\"\"\"",
            "        return utils.getEmptyTitle(self, translated)",
            "",
            "    @security.public",
            "    def pretty_title_or_id(self, obj, empty_value=_marker):",
            "        # Return the best possible title or id of an item, regardless",
            "        # of whether obj is a catalog brain or an object, but returning an",
            "        # empty title marker if the id is not set (i.e. it's auto-generated).",
            "        return utils.pretty_title_or_id(self, obj, empty_value=empty_value)",
            "",
            "    @security.public",
            "    def getMethodAliases(self, typeInfo):",
            "        # Given an FTI, return the dict of method aliases defined on that",
            "        # FTI. If there are no method aliases (i.e. this FTI doesn't support",
            "        # it), return None.",
            "        getMethodAliases = getattr(typeInfo, 'getMethodAliases', None)",
            "        if getMethodAliases is not None \\",
            "                and utils.safe_callable(getMethodAliases):",
            "            return getMethodAliases()",
            "        else:",
            "            return None",
            "",
            "    # This is public because we don't know what permissions the user",
            "    # has on the objects to be deleted.  The restrictedTraverse and",
            "    # manage_delObjects calls should handle permission checks for us.",
            "    @security.public",
            "    def deleteObjectsByPaths(self, paths, handle_errors=True, REQUEST=None):",
            "        log_deprecated(\"deleteObjectsByPaths is deprecated, you should use. \"",
            "                       \"plone.api.content.delete. This method no longer does link integrity checks\")  # noqa",
            "        failure = {}",
            "        success = []",
            "        # use the portal for traversal in case we have relative paths",
            "        portal = getToolByName(self, 'portal_url').getPortalObject()",
            "        traverse = portal.restrictedTraverse",
            "        for path in paths:",
            "            # Skip and note any errors",
            "            if handle_errors:",
            "                sp = transaction.savepoint(optimistic=True)",
            "            try:",
            "                obj = traverse(path)",
            "                obj_parent = aq_parent(aq_inner(obj))",
            "                obj_parent.manage_delObjects([obj.getId()])",
            "                success.append('%s (%s)' % (obj.getId(), path))",
            "            except ConflictError:",
            "                raise",
            "            except Exception as e:",
            "                if handle_errors:",
            "                    sp.rollback()",
            "                    failure[path] = e",
            "                    log_exc()",
            "                else:",
            "                    raise",
            "        transaction_note('Deleted %s' % (', '.join(success)))",
            "        return success, failure",
            "    deleteObjectsByPaths = postonly(deleteObjectsByPaths)",
            "",
            "    @security.public",
            "    def transitionObjectsByPaths(self, workflow_action, paths, comment='',",
            "                                 expiration_date=None, effective_date=None,",
            "                                 include_children=False, handle_errors=True,",
            "                                 REQUEST=None):",
            "        log_deprecated(\"transitionObjectsByPaths is deprecated\")",
            "        failure = {}",
            "        # use the portal for traversal in case we have relative paths",
            "        portal = getToolByName(self, 'portal_url').getPortalObject()",
            "        traverse = portal.restrictedTraverse",
            "        for path in paths:",
            "            if handle_errors:",
            "                sp = transaction.savepoint(optimistic=True)",
            "            try:",
            "                o = traverse(path, None)",
            "                if o is not None:",
            "                    o.content_status_modify(workflow_action,",
            "                                            comment,",
            "                                            effective_date=effective_date,",
            "                                            expiration_date=expiration_date)",
            "            except ConflictError:",
            "                raise",
            "            except Exception as e:",
            "                if handle_errors:",
            "                    # skip this object but continue with sub-objects.",
            "                    sp.rollback()",
            "                    failure[path] = e",
            "                else:",
            "                    raise",
            "            if getattr(o, 'isPrincipiaFolderish', None) and include_children:",
            "                subobject_paths = [\"%s/%s\" % (path, id) for id in o]",
            "                self.transitionObjectsByPaths(workflow_action, subobject_paths,",
            "                                              comment, expiration_date,",
            "                                              effective_date, include_children,",
            "                                              handle_errors)",
            "        return failure",
            "    transitionObjectsByPaths = postonly(transitionObjectsByPaths)",
            "",
            "    @security.public",
            "    def renameObjectsByPaths(self, paths, new_ids, new_titles,",
            "                             handle_errors=True, REQUEST=None):",
            "        failure = {}",
            "        success = {}",
            "        # use the portal for traversal in case we have relative paths",
            "        portal = getToolByName(self, 'portal_url').getPortalObject()",
            "        traverse = portal.restrictedTraverse",
            "        for i, path in enumerate(paths):",
            "            new_id = new_ids[i]",
            "            new_title = new_titles[i]",
            "            if handle_errors:",
            "                sp = transaction.savepoint(optimistic=True)",
            "            try:",
            "                obj = traverse(path, None)",
            "                obid = obj.getId()",
            "                title = obj.Title()",
            "                change_title = new_title and title != new_title",
            "                changed = False",
            "                if change_title:",
            "                    getSecurityManager().validate(",
            "                        obj, obj, 'setTitle', obj.setTitle",
            "                    )",
            "                    obj.setTitle(new_title)",
            "                    notify(ObjectModifiedEvent(obj))",
            "                    changed = True",
            "                if new_id and obid != new_id:",
            "                    parent = aq_parent(aq_inner(obj))",
            "                    parent.manage_renameObjects((obid,), (new_id,))",
            "                    changed = True",
            "                elif change_title:",
            "                    # the rename will have already triggered a reindex",
            "                    obj.reindexObject()",
            "                if changed:",
            "                    success[path] = (new_id, new_title)",
            "            except ConflictError:",
            "                raise",
            "            except Exception as e:",
            "                if handle_errors:",
            "                    # skip this object but continue with sub-objects.",
            "                    sp.rollback()",
            "                    failure[path] = e",
            "                else:",
            "                    raise",
            "        transaction_note('Renamed %s' % str(success.keys()))",
            "        return success, failure",
            "    renameObjectsByPaths = postonly(renameObjectsByPaths)",
            "",
            "InitializeClass(PloneTool)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from AccessControl import ClassSecurityInfo",
            "from AccessControl import getSecurityManager",
            "from AccessControl import Unauthorized",
            "from AccessControl.requestmethod import postonly",
            "from Acquisition import aq_base",
            "from Acquisition import aq_inner",
            "from Acquisition import aq_parent",
            "from AccessControl.class_init import InitializeClass",
            "from ComputedAttribute import ComputedAttribute",
            "from DateTime import DateTime",
            "from email.utils import getaddresses",
            "from OFS.ObjectManager import bad_id",
            "from OFS.SimpleItem import SimpleItem",
            "from plone.registry.interfaces import IRegistry",
            "from Products.CMFCore.interfaces import IDublinCore",
            "from Products.CMFCore.interfaces import IMutableDublinCore",
            "from Products.CMFCore.permissions import AccessContentsInformation",
            "from Products.CMFCore.permissions import ManagePortal",
            "from Products.CMFCore.permissions import ManageUsers",
            "from Products.CMFCore.permissions import ModifyPortalContent",
            "from Products.CMFCore.permissions import View",
            "from Products.CMFCore.utils import getToolByName",
            "from Products.CMFCore.utils import UniqueObject",
            "from Products.CMFCore.WorkflowCore import WorkflowException",
            "from Products.CMFDynamicViewFTI.interfaces import IBrowserDefault",
            "from Products.CMFPlone import utils",
            "from Products.CMFPlone.defaultpage import check_default_page_via_view",
            "from Products.CMFPlone.defaultpage import get_default_page_via_view",
            "from Products.CMFPlone.events import ReorderedEvent",
            "from Products.CMFPlone.interfaces import INonStructuralFolder",
            "from Products.CMFPlone.interfaces import IPloneTool",
            "from Products.CMFPlone.interfaces import ISearchSchema",
            "from Products.CMFPlone.interfaces import ISecuritySchema",
            "from Products.CMFPlone.interfaces import ISiteSchema",
            "from Products.CMFPlone.log import log_deprecated",
            "from Products.CMFPlone.PloneBaseTool import PloneBaseTool",
            "from Products.CMFPlone.PloneFolder import ReplaceableWrapper",
            "from Products.CMFPlone.utils import base_hasattr",
            "from Products.CMFPlone.utils import log",
            "from Products.CMFPlone.utils import log_exc",
            "from Products.CMFPlone.utils import safe_hasattr",
            "from Products.CMFPlone.utils import safe_unicode",
            "from Products.CMFPlone.utils import transaction_note",
            "from Products.statusmessages.interfaces import IStatusMessage",
            "from six.moves.urllib import parse",
            "from ZODB.POSException import ConflictError",
            "from zope.component import getUtility",
            "from zope.component import queryAdapter",
            "from zope.deprecation import deprecate",
            "from zope.event import notify",
            "from zope.interface import implementer",
            "from zope.lifecycleevent import ObjectModifiedEvent",
            "",
            "import re",
            "import sys",
            "import six",
            "import transaction",
            "",
            "",
            "_marker = utils._marker",
            "_icons = {}",
            "",
            "CEILING_DATE = DateTime(2500, 0)  # never expires",
            "FLOOR_DATE = __FLOOR_DATE = DateTime(1970, 0)  # always effective",
            "BAD_CHARS = bad_id.__self__.findall",
            "",
            "# max 63 chars per label in domains, see RFC1035",
            "EMAIL_RE = re.compile(r\"^(\\w&.%#$&'\\*+-/=?^_`{}|~]+!)*[\\w&.%#$&'\\*+-/=?^_`{}|~]+@(([0-9a-z]([0-9a-z-]*[0-9a-z])?\\.)+[a-z]{2,63}|([0-9]{1,3}\\.){3}[0-9]{1,3})$\", re.IGNORECASE)  # noqa",
            "# used to find double new line (in any variant)",
            "EMAIL_CUTOFF_RE = re.compile(r\".*[\\n\\r][\\n\\r]\")",
            "",
            "# dublic core accessor name -> metadata name",
            "METADATA_DCNAME = {",
            "    # The first two rows are handle in a special way",
            "    # 'Description'      : 'description',",
            "    # 'Subject'          : 'keywords',",
            "    'Description': 'DC.description',",
            "    'Subject': 'DC.subject',",
            "    'Creator': 'DC.creator',",
            "    'Contributors': 'DC.contributors',",
            "    'Publisher': 'DC.publisher',",
            "    'CreationDate': 'DC.date.created',",
            "    'ModificationDate': 'DC.date.modified',",
            "    'Type': 'DC.type',",
            "    'Format': 'DC.format',",
            "    'Language': 'DC.language',",
            "    'Rights': 'DC.rights',",
            "}",
            "METADATA_DC_AUTHORFIELDS = ('Creator', 'Contributors', 'Publisher')",
            "",
            "",
            "@implementer(IPloneTool)",
            "class PloneTool(PloneBaseTool, UniqueObject, SimpleItem):",
            "    \"\"\"Various utility methods.\"\"\"",
            "",
            "    id = 'plone_utils'",
            "    meta_type = 'Plone Utility Tool'",
            "    toolicon = 'skins/plone_images/site_icon.png'",
            "    security = ClassSecurityInfo()",
            "    plone_tool = 1",
            "    # Prefix for forms fields!?",
            "    field_prefix = 'field_'",
            "",
            "    @security.protected(ManageUsers)",
            "    def setMemberProperties(self, member, REQUEST=None, **properties):",
            "        pas = getToolByName(self, 'acl_users')",
            "        if safe_hasattr(member, 'getId'):",
            "            member = member.getId()",
            "        user = pas.getUserById(member)",
            "        user.setProperties(**properties)",
            "",
            "    @security.public",
            "    @deprecate(('`getSiteEncoding` is deprecated. Plone only supports UTF-8 '",
            "                'currently. This method always returns \"utf-8\"'))",
            "    def getSiteEncoding(self):",
            "        \"\"\" Get the the site encoding, which is utf-8.\"\"\"",
            "        return 'utf-8'",
            "",
            "    @security.public",
            "    def portal_utf8(self, str, errors='strict'):",
            "        # Transforms an string in portal encoding to utf8.",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        return utils.portal_utf8(self, str, errors)",
            "",
            "    @security.public",
            "    def utf8_portal(self, str, errors='strict'):",
            "        # Transforms an utf8 string to portal encoding.",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        return utils.utf8_portal(self, str, errors)",
            "",
            "    @security.private",
            "    def getMailHost(self):",
            "        \"\"\"Gets the MailHost.\"\"\"",
            "        return getattr(aq_parent(self), 'MailHost')",
            "",
            "    @security.public",
            "    def validateSingleNormalizedEmailAddress(self, address):",
            "        # Lower-level function to validate a single normalized email address,",
            "        # see validateEmailAddress.",
            "        if not isinstance(address, six.string_types):",
            "            return False",
            "",
            "        sub = EMAIL_CUTOFF_RE.match(address)",
            "        if sub is not None:",
            "            # Address contains two newlines (possible spammer relay attack)",
            "            return False",
            "",
            "        # sub is an empty string if the address is valid",
            "        sub = EMAIL_RE.sub('', address)",
            "        if sub == '':",
            "            return True",
            "        return False",
            "",
            "    @security.public",
            "    def validateSingleEmailAddress(self, address):",
            "        # Validate a single email address, see also validateEmailAddresses.",
            "        if not isinstance(address, six.string_types):",
            "            return False",
            "",
            "        sub = EMAIL_CUTOFF_RE.match(address)",
            "        if sub is not None:",
            "            # Address contains two newlines (spammer attack using",
            "            # \"address\\n\\nSpam message\")",
            "            return False",
            "",
            "        if len(getaddresses([address])) != 1:",
            "            # none or more than one address",
            "            return False",
            "",
            "        # Validate the address",
            "        for name, addr in getaddresses([address]):",
            "            if not self.validateSingleNormalizedEmailAddress(addr):",
            "                return False",
            "        return True",
            "",
            "    @security.public",
            "    def validateEmailAddresses(self, addresses):",
            "        # Validate a list of possibly several email addresses, see also",
            "        # validateSingleEmailAddress.",
            "        if not isinstance(addresses, six.string_types):",
            "            return False",
            "",
            "        sub = EMAIL_CUTOFF_RE.match(addresses)",
            "        if sub is not None:",
            "            # Addresses contains two newlines (spammer attack using",
            "            # \"To: list\\n\\nSpam message\")",
            "            return False",
            "",
            "        # Validate each address",
            "        for name, addr in getaddresses([addresses]):",
            "            if not self.validateSingleNormalizedEmailAddress(addr):",
            "                return False",
            "        return True",
            "",
            "    @security.public",
            "    def editMetadata(self, obj, allowDiscussion=None, title=None,",
            "                     subject=None, description=None, contributors=None,",
            "                     effective_date=None, expiration_date=None, format=None,",
            "                     language=None, rights=None, **kwargs):",
            "        # Responsible for setting metadata on a content object.",
            "        # We assume the obj implements IDublinCoreMetadata.",
            "        mt = getToolByName(self, 'portal_membership')",
            "        if not mt.checkPermission(ModifyPortalContent, obj):",
            "            # FIXME: Some scripts rely on this being string?",
            "            raise Unauthorized",
            "",
            "        REQUEST = self.REQUEST",
            "        pfx = self.field_prefix",
            "",
            "        def getfield(request, name, default=None, pfx=pfx):",
            "            return request.form.get(pfx + name, default)",
            "",
            "        def tuplify(value):",
            "            return tuple(filter(None, value))",
            "",
            "        if IDublinCore.providedBy(obj):",
            "            if title is None:",
            "                title = getfield(REQUEST, 'title')",
            "            if description is None:",
            "                description = getfield(REQUEST, 'description')",
            "            if subject is None:",
            "                subject = getfield(REQUEST, 'subject')",
            "            if subject is not None:",
            "                subject = tuplify(subject)",
            "            if contributors is None:",
            "                contributors = getfield(REQUEST, 'contributors')",
            "            if contributors is not None:",
            "                contributors = tuplify(contributors)",
            "            if effective_date is None:",
            "                effective_date = getfield(REQUEST, 'effective_date')",
            "            if effective_date == '':",
            "                effective_date = 'None'",
            "            if expiration_date is None:",
            "                expiration_date = getfield(REQUEST, 'expiration_date')",
            "            if expiration_date == '':",
            "                expiration_date = 'None'",
            "",
            "        if IMutableDublinCore.providedBy(obj):",
            "            if title is not None:",
            "                obj.setTitle(title)",
            "            if description is not None:",
            "                obj.setDescription(description)",
            "            if subject is not None:",
            "                obj.setSubject(subject)",
            "            if contributors is not None:",
            "                obj.setContributors(contributors)",
            "            if effective_date is not None:",
            "                obj.setEffectiveDate(effective_date)",
            "            if expiration_date is not None:",
            "                obj.setExpirationDate(expiration_date)",
            "            if format is not None:",
            "                obj.setFormat(format)",
            "            if language is not None:",
            "                obj.setLanguage(language)",
            "            if rights is not None:",
            "                obj.setRights(rights)",
            "            # Make the catalog aware of changes",
            "            obj.reindexObject()",
            "",
            "    def _renameObject(self, obj, id):",
            "        if not id:",
            "            REQUEST = self.REQUEST",
            "            id = REQUEST.get('id', '')",
            "            id = REQUEST.get(self.field_prefix + 'id', '')",
            "        if id != obj.getId():",
            "            parent = aq_parent(aq_inner(obj))",
            "            parent.manage_renameObject(obj.getId(), id)",
            "",
            "    def _makeTransactionNote(self, obj, msg=u''):",
            "        # TODO Why not aq_parent()?",
            "        relative_path = '/'.join(",
            "            getToolByName(self, 'portal_url').getRelativeContentPath(obj)[:-1]",
            "        )",
            "        if not msg:",
            "            msg = relative_path + '/' + obj.title_or_id() \\",
            "                + ' has been modified.'",
            "        if not transaction.get().description:",
            "            transaction_note(safe_unicode(msg))",
            "",
            "    @security.public",
            "    def contentEdit(self, obj, **kwargs):",
            "        # Encapsulates how the editing of content occurs.",
            "        try:",
            "            self.editMetadata(obj, **kwargs)",
            "        except AttributeError as msg:",
            "            log('Failure editing metadata at: %s.\\n%s\\n' %",
            "                (obj.absolute_url(), msg))",
            "        if kwargs.get('id', None) is not None:",
            "            self._renameObject(obj, id=kwargs['id'].strip())",
            "        self._makeTransactionNote(obj)",
            "",
            "    @security.public",
            "    def availableMIMETypes(self):",
            "        # Returns a map of mimetypes.",
            "        # Requires mimetype registry from Archetypes >= 1.3.",
            "        mtr = getToolByName(self, 'mimetypes_registry')",
            "        return mtr.list_mimetypes()",
            "",
            "    @security.protected(View)",
            "    def getWorkflowChainFor(self, object):",
            "        # Proxy the request for the chain to the workflow tool, as",
            "        # this method is private there.",
            "        wftool = getToolByName(self, 'portal_workflow')",
            "        wfs = ()",
            "        try:",
            "            wfs = wftool.getChainFor(object)",
            "        except ConflictError:",
            "            raise",
            "        except:",
            "            pass",
            "        return wfs",
            "",
            "    @security.protected(View)",
            "    def getIconFor(self, category, id, default=_marker, context=None):",
            "        # Get an icon for an action, from its icon_expr.",
            "        if context is None:",
            "            context = aq_parent(self)",
            "        action_chain = '%s/%s' % (category, id)",
            "        if category == 'controlpanel':",
            "            tool = getToolByName(context, 'portal_controlpanel')",
            "            actions = [ai for ai in tool.listActionInfos() if ai['id'] == id]",
            "        else:",
            "            tool = getToolByName(context, 'portal_actions')",
            "            actions = tool.listActionInfos(",
            "                action_chain=action_chain, object=context)",
            "        if len(actions) > 0:",
            "            icon = actions[0].get('icon', None)",
            "            if icon:",
            "                return icon",
            "        else:",
            "            if default is not _marker:",
            "                icon = default",
            "            else:",
            "                raise KeyError(action_chain)",
            "",
            "        return icon",
            "",
            "    @security.protected(View)",
            "    def getReviewStateTitleFor(self, obj):",
            "        # Utility method that gets the workflow state title for the",
            "        # object's review_state.",
            "        # Returns None if no review_state found.",
            "        wf_tool = getToolByName(self, 'portal_workflow')",
            "        wfs = ()",
            "        objstate = None",
            "        try:",
            "            objstate = wf_tool.getInfoFor(obj, 'review_state')",
            "            wfs = wf_tool.getWorkflowsFor(obj)",
            "        except WorkflowException:",
            "            pass",
            "        if wfs:",
            "            for w in wfs:",
            "                if objstate in w.states:",
            "                    return w.states[objstate].title or objstate",
            "        return None",
            "",
            "    @security.protected(ManagePortal)",
            "    def changeOwnershipOf(self, object, userid, recursive=0, REQUEST=None):",
            "        \"\"\"Changes the ownership of an object.\"\"\"",
            "        membership = getToolByName(self, 'portal_membership')",
            "        acl_users = getattr(self, 'acl_users')",
            "        user = acl_users.getUserById(userid)",
            "        if user is None:",
            "            # The user could be in the top level acl_users folder in",
            "            # the Zope root, in which case this should find him:",
            "            user = membership.getMemberById(userid)",
            "            if user is None:",
            "                raise KeyError(",
            "                    'Only retrievable users in this site can be made owners.')",
            "            # Be careful not to pass MemberData to changeOwnership",
            "            user = user.getUser()",
            "        object.changeOwnership(user, recursive)",
            "",
            "        def fixOwnerRole(object, user_id):",
            "            # Get rid of all other owners",
            "            owners = object.users_with_local_role('Owner')",
            "            for o in owners:",
            "                roles = list(object.get_local_roles_for_userid(o))",
            "                roles.remove('Owner')",
            "                if roles:",
            "                    object.manage_setLocalRoles(o, roles)",
            "                else:",
            "                    object.manage_delLocalRoles([o])",
            "            # Fix for 1750",
            "            roles = list(object.get_local_roles_for_userid(user_id))",
            "            roles.append('Owner')",
            "            object.manage_setLocalRoles(user_id, roles)",
            "",
            "        fixOwnerRole(object, user.getId())",
            "        if base_hasattr(object, 'reindexObject'):",
            "            object.reindexObject()",
            "",
            "        if recursive:",
            "            catalog_tool = getToolByName(self, 'portal_catalog')",
            "            purl = getToolByName(self, 'portal_url')",
            "            _path = purl.getRelativeContentURL(object)",
            "            subobjects = [",
            "                b.getObject()",
            "                for b in catalog_tool(path={'query': _path, 'level': 1})",
            "            ]",
            "            for obj in subobjects:",
            "                fixOwnerRole(obj, user.getId())",
            "                if base_hasattr(obj, 'reindexObject'):",
            "                    obj.reindexObject()",
            "    changeOwnershipOf = postonly(changeOwnershipOf)",
            "",
            "    @security.public",
            "    def urlparse(self, url):",
            "        # Returns the pieces of url in a six-part tuple.",
            "        # Since Python 2.6: urlparse now returns a ParseResult object.",
            "        # We just need the tuple form which is tuple(result).",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        return tuple(parse.urlparse(url))",
            "",
            "    @security.public",
            "    def urlunparse(self, url_tuple):",
            "        # Puts a url back together again, in the manner that",
            "        # urlparse breaks it.",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        return parse.urlunparse(url_tuple)",
            "",
            "    # Enable scripts to get the string value of an exception even if the",
            "    # thrown exception is a string and not a subclass of Exception.",
            "    def exceptionString(self):",
            "        # Don't assign the traceback to s",
            "        # (otherwise will generate a circular reference)",
            "        s = sys.exc_info()[:2]",
            "        if s[0] == None:",
            "            return None",
            "        if isinstance(s[0], six.string_types):",
            "            return s[0]",
            "        return str(s[1])",
            "",
            "    # Provide a way of dumping an exception to the log even if we",
            "    # catch it and otherwise ignore it",
            "    def logException(self):",
            "        # Dumps most recent exception to the log.",
            "        log_exc()",
            "",
            "    @security.public",
            "    def createSitemap(self, context, request=None):",
            "        # Returns a sitemap navtree structure.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return utils.createSiteMap(context, request)",
            "",
            "    def _addToNavTreeResult(self, result, data):",
            "        # Adds a piece of content to the result tree.",
            "        return utils.addToNavTreeResult(result, data)",
            "",
            "    @security.protected(AccessContentsInformation)",
            "    def typesToList(self):",
            "        return utils.typesToList(self)",
            "",
            "    @security.public",
            "    def createBreadCrumbs(self, context, request=None):",
            "        # Returns a structure for the portal breadcumbs.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return utils.createBreadCrumbs(context, request)",
            "",
            "    @security.public",
            "    def good_id(self, id):",
            "        # Exposes ObjectManager's bad_id test to skin scripts.",
            "        m = bad_id(id)",
            "        if m is not None:",
            "            return 0",
            "        return 1",
            "",
            "    @security.public",
            "    def bad_chars(self, id):",
            "        # Returns a list of the Bad characters.",
            "        return BAD_CHARS(id)",
            "",
            "    @security.public",
            "    def getInheritedLocalRoles(self, context):",
            "        # Returns a tuple with the acquired local roles.",
            "        portal = getToolByName(context, 'portal_url').getPortalObject()",
            "        result = []",
            "        cont = 1",
            "        if portal != context:",
            "            parent = aq_parent(context)",
            "            while cont:",
            "                if not getattr(parent, 'acl_users', False):",
            "                    break",
            "                userroles = parent.acl_users._getLocalRolesForDisplay(parent)",
            "                for user, roles, role_type, name in userroles:",
            "                    # Find user in result",
            "                    found = 0",
            "                    for user2, roles2, type2, name2 in result:",
            "                        if user2 == user:",
            "                            # Check which roles must be added to roles2",
            "                            for role in roles:",
            "                                if role not in roles2:",
            "                                    roles2.append(role)",
            "                            found = 1",
            "                            break",
            "                    if found == 0:",
            "                        # Add it to result and make sure roles is a list so",
            "                        # we may append and not overwrite the loop variable",
            "                        result.append([user, list(roles), role_type, name])",
            "                if parent == portal:",
            "                    cont = 0",
            "                elif not self.isLocalRoleAcquired(parent):",
            "                    # Role acquired check here",
            "                    cont = 0",
            "                else:",
            "                    parent = aq_parent(parent)",
            "",
            "        # Tuplize all inner roles",
            "        for pos in range(len(result) - 1, -1, -1):",
            "            result[pos][1] = tuple(result[pos][1])",
            "            result[pos] = tuple(result[pos])",
            "",
            "        return tuple(result)",
            "",
            "    #",
            "    # The three methods used in determining what the default-page of a folder",
            "    # is. These are:",
            "    #",
            "    #   - getDefaultPage(folder)",
            "    #       : get id of contentish object that is default-page in the folder",
            "    #   - isDefaultPage(object)",
            "    #       : determine if an object is the default-page in its parent folder",
            "    #   - browserDefault(object)",
            "    #       : lookup rules for old-style content types",
            "    #",
            "",
            "    @security.public",
            "    def isDefaultPage(self, obj, request=None):",
            "        # Finds out if the given obj is the default page in its parent folder.",
            "        # Uses the lookup rules of Plone.  Lookup happens over a view, for which",
            "        # in theory a different implementation may exist.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return check_default_page_via_view(obj, request)",
            "",
            "    @security.public",
            "    def getDefaultPage(self, obj, request=None):",
            "        # Given a folderish item, find out if it has a default-page using",
            "        # the lookup rules of Plone (see Products.CMFPlone/defaultpage.py).",
            "        # Lookup happens over a view, for which in theory a different",
            "        # implementation may be used.",
            "        if request is None:",
            "            if hasattr(self, 'REQUEST'):",
            "                request = self.REQUEST",
            "        if request:",
            "            return get_default_page_via_view(obj, request)",
            "",
            "    @security.public",
            "    def addPortalMessage(self, message, type='info', request=None):",
            "        # Call this once or more to add messages to be displayed at the",
            "        # top of the web page.",
            "",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        # This might not be possible, but type=\"structure\" below sounds dangerous,",
            "        # although I find no support for it in code.",
            "",
            "        # The arguments are:",
            "        #     message:   a string, with the text message you want to show,",
            "        #                or a HTML fragment (see type='structure' below)",
            "        #     type:      optional, defaults to 'info'. The type determines how",
            "        #                the message will be rendered, as it is used to select",
            "        #                the CSS class for the message. Predefined types are:",
            "        #                'info' - for informational messages",
            "        #                'warning' - for warning messages",
            "        #                'error' - for messages about restricted access or",
            "        #                          errors.",
            "",
            "        # Portal messages are by default rendered by the global_statusmessage.pt",
            "        # page template.",
            "",
            "        # It is also possible to add messages from page templates, as",
            "        # long as they are processed before the portal_message macro is",
            "        # called by the main template. Example:",
            "",
            "        #   <tal:block tal:define=\"temp python:context.plone_utils.addPortalMessage('A random info message')\" />  # noqa",
            "        if request is None:",
            "            request = self.REQUEST",
            "        IStatusMessage(request).add(message, type=type)",
            "",
            "    @security.public",
            "    def showPortalMessages(self, request=None):",
            "        # Return portal status messages that will be displayed when the",
            "        # response web page is rendered. Portal status messages are by default",
            "        # rendered by the global_statusmessage.pt page template. They will be",
            "        # removed after they have been shown.",
            "        # See addPortalMessages for examples.",
            "        if request is None:",
            "            request = self.REQUEST",
            "        return IStatusMessage(request).show()",
            "",
            "    @security.public",
            "    def browserDefault(self, obj):",
            "        # Sets default so we can return whatever we want instead of index_html.",
            "",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "",
            "        # This method is complex, and interacts with mechanisms such as",
            "        # IBrowserDefault (implemented in CMFDynamicViewFTI), LinguaPlone and",
            "        # various mechanisms for setting the default page.",
            "",
            "        # The method returns a tuple (obj, [path]) where path is a path to",
            "        # a template or other object to be acquired and displayed on the object.",
            "        # The path is determined as follows:",
            "",
            "        # 0. If we're c oming from WebDAV, make sure we don't return a contained",
            "        #     object \"default page\" ever",
            "        # 1. If there is an index_html attribute (either a contained object or",
            "        #     an explicit attribute) on the object, return that as the",
            "        #     \"default page\". Note that this may be used by things like",
            "        #     File and Image to return the contents of the file, for example,",
            "        #     not just content-space objects created by the user.",
            "        # 2. If the object implements IBrowserDefault, query this for the",
            "        #     default page.",
            "        # 3. If the object has a property default_page set and this gives a list",
            "        #     of, or single, object id, and that object is is found in the",
            "        #     folder or is the name of a skin template, return that id",
            "        # 4. If the property default_page is set in site_properties and that",
            "        #     property contains a list of ids of which one id is found in the",
            "        #     folder, return that id",
            "        # 5. If the object implements IBrowserDefault, try to get the selected",
            "        #     layout.",
            "        # 6. If the type has a 'folderlisting' action and no default page is",
            "        #     set, use this action. This permits folders to have the default",
            "        #     'view' action be 'string:${object_url}/' and hence default to",
            "        #     a default page when clicking the 'view' tab, whilst allowing the",
            "        #     fallback action to be specified TTW in portal_types (this action",
            "        #     is typically hidden)",
            "        # 7. If nothing else is found, fall back on the object's 'view' action.",
            "        # 8. If this is not found, raise an AttributeError",
            "",
            "        # WebDAV in Zope is odd it takes the incoming verb eg: PROPFIND",
            "        # and then requests that object, for example for: /, with verb PROPFIND",
            "        # means acquire PROPFIND from the folder and call it",
            "        # its all very odd and WebDAV'y",
            "        request = getattr(self, 'REQUEST', None)",
            "        if request is not None and 'REQUEST_METHOD' in request:",
            "            if request['REQUEST_METHOD'] not in ['GET', 'POST']:",
            "                return obj, [request['REQUEST_METHOD']]",
            "        # Now back to normal",
            "",
            "        #",
            "        # 1. Get an attribute or contained object index_html",
            "        #",
            "",
            "        # Note: The base PloneFolder, as well as ATCT's ATCTOrderedFolder",
            "        # defines a method index_html() which returns a ReplaceableWrapper.",
            "        # This is needed for WebDAV to work properly, and to avoid implicit",
            "        # acquisition of index_html's, which are generally on-object only.",
            "        # For the purposes of determining a default page, we don't want to",
            "        # use this index_html(), nor the ComputedAttribute which defines it.",
            "",
            "        if not isinstance(getattr(obj, 'index_html', None),",
            "                          ReplaceableWrapper):",
            "            index_obj = getattr(aq_base(obj), 'index_html', None)",
            "            if index_obj is not None \\",
            "                    and not isinstance(index_obj, ComputedAttribute):",
            "                return obj, ['index_html']",
            "",
            "        #",
            "        # 2. Look for a default_page managed by an IBrowserDefault-implementing",
            "        #    object",
            "        #",
            "        # 3. Look for a default_page property on the object",
            "        #",
            "        # 4. Try the default sitewide default_page setting",
            "        #",
            "",
            "        if obj.isPrincipiaFolderish:",
            "            defaultPage = self.getDefaultPage(obj)",
            "            if defaultPage is not None:",
            "                if defaultPage in obj:",
            "                    return obj, [defaultPage]",
            "                # Avoid infinite recursion in the case that the page id == the",
            "                # object id",
            "                elif (",
            "                    defaultPage != obj.getId()",
            "                    and defaultPage != '/'.join(obj.getPhysicalPath())",
            "                ):",
            "                    # For the default_page property, we may get things in the",
            "                    # skin layers or with an explicit path - split this path",
            "                    # to comply with the __browser_default__() spec",
            "                    return obj, defaultPage.split('/')",
            "",
            "        # 5. If there is no default page, try IBrowserDefault.getLayout()",
            "        if IBrowserDefault.providedBy(obj):",
            "            browserDefault = obj",
            "        else:",
            "            browserDefault = queryAdapter(obj, IBrowserDefault)",
            "        if browserDefault is not None:",
            "            default_view_fallback = False",
            "            if base_hasattr(obj, 'getTypeInfo'):",
            "                default_view_fallback = obj.getTypeInfo().default_view_fallback",
            "            layout = browserDefault.getLayout(check_exists=default_view_fallback)",
            "            if layout is None:",
            "                raise AttributeError(",
            "                    \"%s has no assigned layout, perhaps it needs an FTI\" % obj)",
            "            else:",
            "                return obj, [layout]",
            "",
            "        #",
            "        # 6. If the object has a 'folderlisting' action, use this",
            "        #",
            "",
            "        # This allows folders to determine in a flexible manner how they are",
            "        # displayed when there is no default page, whilst still using",
            "        # browserDefault() to show contained objects by default on the 'view'",
            "        # action (this applies to old-style folders only, IBrowserDefault is",
            "        # managed explicitly above)",
            "",
            "        if base_hasattr(obj, 'getTypeInfo'):",
            "            try:",
            "                # XXX: This isn't quite right since it assumes the action",
            "                # starts with ${object_url}.  Should we raise an error if",
            "                # it doesn't?",
            "                act = obj.getTypeInfo().getActionInfo(",
            "                    'folder/folderlisting'",
            "                )['url'].split('/')[-1]",
            "                return obj, [act]",
            "            except ValueError:",
            "                pass",
            "",
            "            #",
            "            # 7. Fall back on the 'view' action",
            "            #",
            "",
            "            try:",
            "                # XXX: This isn't quite right since it assumes the action",
            "                # starts with ${object_url}.  Should we raise an error if",
            "                # it doesn't?",
            "                act = obj.getTypeInfo().getActionInfo(",
            "                    'object/view'",
            "                )['url'].split('/')[-1]",
            "                return obj, [act]",
            "            except ValueError:",
            "                pass",
            "",
            "        #",
            "        # 8. If we can't find this either, raise an exception",
            "        #",
            "",
            "        raise AttributeError(",
            "            \"Failed to get a default page or view_action for %s\"",
            "            % (obj.absolute_url(),)",
            "        )",
            "",
            "    @security.public",
            "    def isStructuralFolder(self, obj):",
            "        \"\"\"Checks if a given object is a \"structural folder\".",
            "",
            "        That is, a folderish item which does not explicitly implement",
            "        INonStructuralFolder to declare that it doesn't wish to be treated",
            "        as a folder by the navtree, the tab generation etc.",
            "        \"\"\"",
            "        return (",
            "            obj.isPrincipiaFolderish",
            "            and not INonStructuralFolder.providedBy(obj)",
            "        )",
            "",
            "    @security.public",
            "    def acquireLocalRoles(self, obj, status=1, REQUEST=None):",
            "        # If status is 1, allow acquisition of local roles (regular",
            "        # behaviour).",
            "        # If it's 0, prohibit it (it will allow some kind of local role",
            "        # blacklisting).",
            "        mt = getToolByName(self, 'portal_membership')",
            "        if not mt.checkPermission(ModifyPortalContent, obj):",
            "            raise Unauthorized",
            "",
            "        # Set local role status...",
            "        # set the variable (or unset it if it's defined)",
            "        if not status:",
            "            obj.__ac_local_roles_block__ = 1",
            "        else:",
            "            if getattr(obj, '__ac_local_roles_block__', None):",
            "                obj.__ac_local_roles_block__ = None",
            "",
            "        # Reindex the whole stuff.",
            "        obj.reindexObjectSecurity()",
            "    acquireLocalRoles = postonly(acquireLocalRoles)",
            "",
            "    @security.public",
            "    def isLocalRoleAcquired(self, obj):",
            "        # Returns local role acquisition blocking status.",
            "        # True if normal, false if blocked.",
            "        if getattr(obj, '__ac_local_roles_block__', None):",
            "            return False",
            "        return True",
            "",
            "    @security.public",
            "    def getOwnerName(self, obj):",
            "        # Returns the userid of the owner of an object.",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        mt = getToolByName(self, 'portal_membership')",
            "        if not mt.checkPermission(View, obj):",
            "            raise Unauthorized",
            "        return obj.getOwner().getId()",
            "",
            "    @security.public",
            "    def normalizeString(self, text):",
            "        # Normalizes a title to an id.",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "",
            "        # The relaxed mode was removed in Plone 4.0. You should use either the",
            "        # url or file name normalizer from the plone.i18n package instead.",
            "",
            "        # normalizeString() converts a whole string to a normalized form that",
            "        # should be safe to use as in a url, as a css id, etc.",
            "        return utils.normalizeString(text, context=self)",
            "",
            "    @security.public",
            "    def listMetaTags(self, context):",
            "        # Lists meta tags helper.",
            "        # Creates a mapping of meta tags -> values for the listMetaTags script.",
            "        result = {}",
            "        mt = getToolByName(self, 'portal_membership')",
            "",
            "        registry = getUtility(IRegistry)",
            "        site_settings = registry.forInterface(",
            "            ISiteSchema, prefix=\"plone\", check=False)",
            "",
            "        try:",
            "            use_all = site_settings.exposeDCMetaTags",
            "        except AttributeError:",
            "            use_all = False",
            "",
            "        security_settings = registry.forInterface(",
            "            ISecuritySchema, prefix='plone')",
            "        view_about = security_settings.allow_anon_views_about \\",
            "            or not mt.isAnonymousUser()",
            "",
            "        if not use_all:",
            "            metadata_names = {'Description': METADATA_DCNAME['Description']}",
            "        else:",
            "            metadata_names = METADATA_DCNAME",
            "        for accessor, key in metadata_names.items():",
            "            # check non-public properties",
            "            if not view_about and accessor in METADATA_DC_AUTHORFIELDS:",
            "                continue",
            "",
            "            # short circuit non-special cases",
            "            if not use_all and accessor not in ('Description', 'Subject'):",
            "                continue",
            "",
            "            method = getattr(aq_inner(context).aq_explicit, accessor, None)",
            "            if not callable(method):",
            "                continue",
            "",
            "            # Catch AttributeErrors raised by some AT applications",
            "            try:",
            "                value = method()",
            "            except AttributeError:",
            "                value = None",
            "",
            "            if not value:",
            "                # No data",
            "                continue",
            "            if accessor == 'Publisher' and value == 'No publisher':",
            "                # No publisher is hardcoded (TODO: still?)",
            "                continue",
            "",
            "            # Check for fullnames",
            "            if view_about and accessor in METADATA_DC_AUTHORFIELDS:",
            "                if not isinstance(value, (list, tuple)):",
            "                    value = [value]",
            "                tmp = []",
            "                for userid in value:",
            "                    member = mt.getMemberInfo(userid)",
            "                    name = userid",
            "                    if member:",
            "                        name = member['fullname'] or userid",
            "                    tmp.append(name)",
            "                value = tmp",
            "",
            "            if isinstance(value, (list, tuple)):",
            "                # convert a list to a string",
            "                value = ', '.join(value)",
            "",
            "            # Special cases",
            "            if accessor == 'Description':",
            "                result['description'] = value",
            "            elif accessor == 'Subject':",
            "                result['keywords'] = value",
            "",
            "            if use_all:",
            "                result[key] = value",
            "",
            "        if use_all:",
            "            created = context.CreationDate()",
            "",
            "            try:",
            "                effective = context.EffectiveDate()",
            "                if effective == 'None':",
            "                    effective = None",
            "                if effective:",
            "                    effective = DateTime(effective)",
            "            except AttributeError:",
            "                effective = None",
            "",
            "            try:",
            "                expires = context.ExpirationDate()",
            "                if expires == 'None':",
            "                    expires = None",
            "                if expires:",
            "                    expires = DateTime(expires)",
            "            except AttributeError:",
            "                expires = None",
            "",
            "            # Filter out DWIMish artifacts on effective / expiration dates",
            "            if effective is not None and \\",
            "               effective > FLOOR_DATE and \\",
            "               effective != created:",
            "                eff_str = effective.Date()",
            "            else:",
            "                eff_str = ''",
            "",
            "            if expires is not None and expires < CEILING_DATE:",
            "                exp_str = expires.Date()",
            "            else:",
            "                exp_str = ''",
            "",
            "            if eff_str or exp_str:",
            "                result['DC.date.valid_range'] = '%s - %s' % (eff_str, exp_str)",
            "",
            "        return result",
            "",
            "    @security.public",
            "    def getUserFriendlyTypes(self, typesList=None):",
            "        # Get a list of types which are considered \"user friendly\" for search",
            "        # and selection purposes.",
            "        #",
            "        # This is the list of types available in the portal, minus those",
            "        # defined in the types_not_searched property in site_properties, if it",
            "        # exists.",
            "        #",
            "        # If typesList is given, this is used as the base list; else all types",
            "        # from portal_types are used.",
            "        if typesList is None:",
            "            typesList = []",
            "        registry = getUtility(IRegistry)",
            "        search_settings = registry.forInterface(ISearchSchema, prefix=\"plone\")",
            "        blacklistedTypes = search_settings.types_not_searched",
            "",
            "        ttool = getToolByName(self, 'portal_types')",
            "        tool_types = ttool.keys()",
            "        if typesList:",
            "            types = [t for t in typesList if t in tool_types]",
            "        else:",
            "            types = tool_types",
            "",
            "        friendlyTypes = set(types) - set(blacklistedTypes)",
            "        return list(friendlyTypes)",
            "",
            "    @security.public",
            "    def reindexOnReorder(self, parent):",
            "        # Reindexing of \"gopip\" isn't needed any longer,",
            "        # but some extensions might need the info anyway. :(",
            "        notify(ReorderedEvent(parent))",
            "",
            "    @security.public",
            "    def isIDAutoGenerated(self, id):",
            "        # Determine if an id is autogenerated.",
            "        return utils.isIDAutoGenerated(self, id)",
            "",
            "    @security.public",
            "    def getEmptyTitle(self, translated=True):",
            "        # Returns string to be used for objects with no title or id.",
            "        # Note: no docstring please, to avoid reflected XSS.",
            "        return utils.getEmptyTitle(self, translated)",
            "",
            "    @security.public",
            "    def pretty_title_or_id(self, obj, empty_value=_marker):",
            "        # Return the best possible title or id of an item, regardless",
            "        # of whether obj is a catalog brain or an object, but returning an",
            "        # empty title marker if the id is not set (i.e. it's auto-generated).",
            "        return utils.pretty_title_or_id(self, obj, empty_value=empty_value)",
            "",
            "    @security.public",
            "    def getMethodAliases(self, typeInfo):",
            "        # Given an FTI, return the dict of method aliases defined on that",
            "        # FTI. If there are no method aliases (i.e. this FTI doesn't support",
            "        # it), return None.",
            "        getMethodAliases = getattr(typeInfo, 'getMethodAliases', None)",
            "        if getMethodAliases is not None \\",
            "                and utils.safe_callable(getMethodAliases):",
            "            return getMethodAliases()",
            "        else:",
            "            return None",
            "",
            "    # This is public because we don't know what permissions the user",
            "    # has on the objects to be deleted.  The restrictedTraverse and",
            "    # manage_delObjects calls should handle permission checks for us.",
            "    @security.public",
            "    def deleteObjectsByPaths(self, paths, handle_errors=True, REQUEST=None):",
            "        log_deprecated(\"deleteObjectsByPaths is deprecated, you should use. \"",
            "                       \"plone.api.content.delete. This method no longer does link integrity checks\")  # noqa",
            "        failure = {}",
            "        success = []",
            "        # use the portal for traversal in case we have relative paths",
            "        portal = getToolByName(self, 'portal_url').getPortalObject()",
            "        traverse = portal.restrictedTraverse",
            "        for path in paths:",
            "            # Skip and note any errors",
            "            if handle_errors:",
            "                sp = transaction.savepoint(optimistic=True)",
            "            try:",
            "                obj = traverse(path)",
            "                obj_parent = aq_parent(aq_inner(obj))",
            "                obj_parent.manage_delObjects([obj.getId()])",
            "                success.append('%s (%s)' % (obj.getId(), path))",
            "            except ConflictError:",
            "                raise",
            "            except Exception as e:",
            "                if handle_errors:",
            "                    sp.rollback()",
            "                    failure[path] = e",
            "                    log_exc()",
            "                else:",
            "                    raise",
            "        transaction_note('Deleted %s' % (', '.join(success)))",
            "        return success, failure",
            "    deleteObjectsByPaths = postonly(deleteObjectsByPaths)",
            "",
            "    @security.public",
            "    def transitionObjectsByPaths(self, workflow_action, paths, comment='',",
            "                                 expiration_date=None, effective_date=None,",
            "                                 include_children=False, handle_errors=True,",
            "                                 REQUEST=None):",
            "        log_deprecated(\"transitionObjectsByPaths is deprecated\")",
            "        failure = {}",
            "        # use the portal for traversal in case we have relative paths",
            "        portal = getToolByName(self, 'portal_url').getPortalObject()",
            "        traverse = portal.restrictedTraverse",
            "        for path in paths:",
            "            if handle_errors:",
            "                sp = transaction.savepoint(optimistic=True)",
            "            try:",
            "                o = traverse(path, None)",
            "                if o is not None:",
            "                    o.content_status_modify(workflow_action,",
            "                                            comment,",
            "                                            effective_date=effective_date,",
            "                                            expiration_date=expiration_date)",
            "            except ConflictError:",
            "                raise",
            "            except Exception as e:",
            "                if handle_errors:",
            "                    # skip this object but continue with sub-objects.",
            "                    sp.rollback()",
            "                    failure[path] = e",
            "                else:",
            "                    raise",
            "            if getattr(o, 'isPrincipiaFolderish', None) and include_children:",
            "                subobject_paths = [\"%s/%s\" % (path, id) for id in o]",
            "                self.transitionObjectsByPaths(workflow_action, subobject_paths,",
            "                                              comment, expiration_date,",
            "                                              effective_date, include_children,",
            "                                              handle_errors)",
            "        return failure",
            "    transitionObjectsByPaths = postonly(transitionObjectsByPaths)",
            "",
            "    @security.public",
            "    def renameObjectsByPaths(self, paths, new_ids, new_titles,",
            "                             handle_errors=True, REQUEST=None):",
            "        failure = {}",
            "        success = {}",
            "        # use the portal for traversal in case we have relative paths",
            "        portal = getToolByName(self, 'portal_url').getPortalObject()",
            "        traverse = portal.restrictedTraverse",
            "        for i, path in enumerate(paths):",
            "            new_id = new_ids[i]",
            "            new_title = new_titles[i]",
            "            if handle_errors:",
            "                sp = transaction.savepoint(optimistic=True)",
            "            try:",
            "                obj = traverse(path, None)",
            "                obid = obj.getId()",
            "                title = obj.Title()",
            "                change_title = new_title and title != new_title",
            "                changed = False",
            "                if change_title:",
            "                    getSecurityManager().validate(",
            "                        obj, obj, 'setTitle', obj.setTitle",
            "                    )",
            "                    obj.setTitle(new_title)",
            "                    notify(ObjectModifiedEvent(obj))",
            "                    changed = True",
            "                if new_id and obid != new_id:",
            "                    parent = aq_parent(aq_inner(obj))",
            "                    parent.manage_renameObjects((obid,), (new_id,))",
            "                    changed = True",
            "                elif change_title:",
            "                    # the rename will have already triggered a reindex",
            "                    obj.reindexObject()",
            "                if changed:",
            "                    success[path] = (new_id, new_title)",
            "            except ConflictError:",
            "                raise",
            "            except Exception as e:",
            "                if handle_errors:",
            "                    # skip this object but continue with sub-objects.",
            "                    sp.rollback()",
            "                    failure[path] = e",
            "                else:",
            "                    raise",
            "        transaction_note('Renamed %s' % str(success.keys()))",
            "        return success, failure",
            "    renameObjectsByPaths = postonly(renameObjectsByPaths)",
            "",
            "InitializeClass(PloneTool)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "122": [
                "PloneTool",
                "portal_utf8"
            ],
            "127": [
                "PloneTool",
                "utf8_portal"
            ],
            "339": [
                "PloneTool",
                "getReviewStateTitleFor"
            ],
            "340": [
                "PloneTool",
                "getReviewStateTitleFor"
            ],
            "341": [
                "PloneTool",
                "getReviewStateTitleFor"
            ],
            "342": [
                "PloneTool",
                "getReviewStateTitleFor"
            ],
            "343": [
                "PloneTool",
                "getReviewStateTitleFor"
            ],
            "410": [
                "PloneTool",
                "urlparse"
            ],
            "411": [
                "PloneTool",
                "urlparse"
            ],
            "412": [
                "PloneTool",
                "urlparse"
            ],
            "413": [
                "PloneTool",
                "urlparse"
            ],
            "414": [
                "PloneTool",
                "urlparse"
            ],
            "419": [
                "PloneTool",
                "urlunparse"
            ],
            "420": [
                "PloneTool",
                "urlunparse"
            ],
            "421": [
                "PloneTool",
                "urlunparse"
            ],
            "554": [
                "PloneTool",
                "addPortalMessage"
            ],
            "555": [
                "PloneTool",
                "addPortalMessage"
            ],
            "556": [
                "PloneTool",
                "addPortalMessage"
            ],
            "557": [
                "PloneTool",
                "addPortalMessage"
            ],
            "558": [
                "PloneTool",
                "addPortalMessage"
            ],
            "559": [
                "PloneTool",
                "addPortalMessage"
            ],
            "560": [
                "PloneTool",
                "addPortalMessage"
            ],
            "561": [
                "PloneTool",
                "addPortalMessage"
            ],
            "562": [
                "PloneTool",
                "addPortalMessage"
            ],
            "563": [
                "PloneTool",
                "addPortalMessage"
            ],
            "564": [
                "PloneTool",
                "addPortalMessage"
            ],
            "565": [
                "PloneTool",
                "addPortalMessage"
            ],
            "566": [
                "PloneTool",
                "addPortalMessage"
            ],
            "567": [
                "PloneTool",
                "addPortalMessage"
            ],
            "568": [
                "PloneTool",
                "addPortalMessage"
            ],
            "569": [
                "PloneTool",
                "addPortalMessage"
            ],
            "570": [
                "PloneTool",
                "addPortalMessage"
            ],
            "571": [
                "PloneTool",
                "addPortalMessage"
            ],
            "572": [
                "PloneTool",
                "addPortalMessage"
            ],
            "573": [
                "PloneTool",
                "addPortalMessage"
            ],
            "574": [
                "PloneTool",
                "addPortalMessage"
            ],
            "575": [
                "PloneTool",
                "addPortalMessage"
            ],
            "576": [
                "PloneTool",
                "addPortalMessage"
            ],
            "577": [
                "PloneTool",
                "addPortalMessage"
            ],
            "595": [
                "PloneTool",
                "browserDefault"
            ],
            "596": [
                "PloneTool",
                "browserDefault"
            ],
            "597": [
                "PloneTool",
                "browserDefault"
            ],
            "598": [
                "PloneTool",
                "browserDefault"
            ],
            "599": [
                "PloneTool",
                "browserDefault"
            ],
            "600": [
                "PloneTool",
                "browserDefault"
            ],
            "601": [
                "PloneTool",
                "browserDefault"
            ],
            "602": [
                "PloneTool",
                "browserDefault"
            ],
            "603": [
                "PloneTool",
                "browserDefault"
            ],
            "604": [
                "PloneTool",
                "browserDefault"
            ],
            "605": [
                "PloneTool",
                "browserDefault"
            ],
            "606": [
                "PloneTool",
                "browserDefault"
            ],
            "607": [
                "PloneTool",
                "browserDefault"
            ],
            "608": [
                "PloneTool",
                "browserDefault"
            ],
            "609": [
                "PloneTool",
                "browserDefault"
            ],
            "610": [
                "PloneTool",
                "browserDefault"
            ],
            "611": [
                "PloneTool",
                "browserDefault"
            ],
            "612": [
                "PloneTool",
                "browserDefault"
            ],
            "613": [
                "PloneTool",
                "browserDefault"
            ],
            "614": [
                "PloneTool",
                "browserDefault"
            ],
            "615": [
                "PloneTool",
                "browserDefault"
            ],
            "616": [
                "PloneTool",
                "browserDefault"
            ],
            "617": [
                "PloneTool",
                "browserDefault"
            ],
            "618": [
                "PloneTool",
                "browserDefault"
            ],
            "619": [
                "PloneTool",
                "browserDefault"
            ],
            "620": [
                "PloneTool",
                "browserDefault"
            ],
            "621": [
                "PloneTool",
                "browserDefault"
            ],
            "622": [
                "PloneTool",
                "browserDefault"
            ],
            "623": [
                "PloneTool",
                "browserDefault"
            ],
            "624": [
                "PloneTool",
                "browserDefault"
            ],
            "625": [
                "PloneTool",
                "browserDefault"
            ],
            "626": [
                "PloneTool",
                "browserDefault"
            ],
            "627": [
                "PloneTool",
                "browserDefault"
            ],
            "628": [
                "PloneTool",
                "browserDefault"
            ],
            "629": [
                "PloneTool",
                "browserDefault"
            ],
            "630": [
                "PloneTool",
                "browserDefault"
            ],
            "792": [
                "PloneTool",
                "getOwnerName"
            ],
            "800": [
                "PloneTool",
                "normalizeString"
            ],
            "802": [
                "PloneTool",
                "normalizeString"
            ],
            "803": [
                "PloneTool",
                "normalizeString"
            ],
            "805": [
                "PloneTool",
                "normalizeString"
            ],
            "806": [
                "PloneTool",
                "normalizeString"
            ],
            "807": [
                "PloneTool",
                "normalizeString"
            ],
            "966": [
                "PloneTool",
                "getEmptyTitle"
            ]
        },
        "addLocation": []
    },
    "Products/CMFPlone/patches/publishing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # -*- coding: utf-8 -*-"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " # From Products.PloneHotfix20160419"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " # Plus extras for properties."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+# Plus Products.PloneHotfix20210518."
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from OFS.PropertyManager import PropertyManager"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " #from OFS.ZDOM import Document"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " #from OFS.ZDOM import Node"
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         pass"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+def delete_method_docstring(klass, method_name):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    # Delete the docstring from the class method."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    # Objects must have a docstring to be published."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    # So this avoids them getting published."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    method = getattr(klass, method_name, None)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    if method is None:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        return"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    if hasattr(method, \"im_func\"):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        # Only Python 2 has im_func."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        # Python 3 has __func__, but only on methods of instances, not classes."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        if hasattr(method.im_func, \"__doc__\"):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            del method.im_func.__doc__"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    else:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        # This would fail on Python 2 with an AttributeError:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        # \"attribute '__doc__' of 'instancemethod' objects is not writable\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        if hasattr(method, \"__doc__\"):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            del method.__doc__"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " klasses = ("
            },
            "30": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " #    Node,"
            },
            "31": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " #    Document,"
            },
            "32": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " for klass in klasses:"
            },
            "34": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     for method_name in methods:"
            },
            "35": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        method = getattr(klass, method_name, None)"
            },
            "36": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if (method is not None and hasattr(method, 'im_func') and"
            },
            "37": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                hasattr(method.im_func, '__doc__')):"
            },
            "38": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            del method.im_func.__doc__"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        delete_method_docstring(klass, method_name)"
            },
            "40": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " property_methods = ("
            },
            "42": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     'getProperty',"
            },
            "43": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " )"
            },
            "44": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " for method_name in property_methods:"
            },
            "46": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    method = getattr(PropertyManager, method_name, None)"
            },
            "47": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if (method is not None and hasattr(method, 'im_func') and"
            },
            "48": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            hasattr(method.im_func, '__doc__')):"
            },
            "49": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        del method.im_func.__doc__"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    delete_method_docstring(PropertyManager, method_name)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# From Products.PloneHotfix20160419",
            "# Plus extras for properties.",
            "from OFS.PropertyManager import PropertyManager",
            "#from OFS.ZDOM import Document",
            "#from OFS.ZDOM import Node",
            "from Products.CMFPlone.Portal import PloneSite",
            "",
            "",
            "try:",
            "    from plone.dexterity.content import Item",
            "    from plone.dexterity.content import Container",
            "except ImportError:",
            "    class Item(object):",
            "        pass",
            "",
            "    class Container(object):",
            "        pass",
            "",
            "try:",
            "    from Products.ATContentTypes.content.base import ATCTContent",
            "    from Products.ATContentTypes.content.base import ATCTBTreeFolder",
            "except ImportError:",
            "",
            "    class ATCTContent(object):",
            "        pass",
            "",
            "    class ATCTBTreeFolder(object):",
            "        pass",
            "",
            "",
            "klasses = (",
            "#    Node,",
            "#    Document,",
            "    PloneSite,",
            "    Item,",
            "    Container,",
            "    ATCTContent,",
            "    ATCTBTreeFolder",
            ")",
            "methods = (",
            "    'EffectiveDate',",
            "    'ExpirationDate',",
            "    'getAttributes',",
            "    'getChildNodes',",
            "    'getFirstChild',",
            "    'getLastChild',",
            "    'getLayout',",
            "    'getNextSibling',",
            "    'getNodeName',",
            "    'getNodeType',",
            "    'getNodeValue',",
            "    'getOwnerDocument',",
            "    'getParentNode',",
            "    'getPhysicalPath',",
            "    'getPreviousSibling',",
            "    'getTagName',",
            "    'hasChildNodes',",
            "    'Type'",
            ")",
            "",
            "for klass in klasses:",
            "    for method_name in methods:",
            "        method = getattr(klass, method_name, None)",
            "        if (method is not None and hasattr(method, 'im_func') and",
            "                hasattr(method.im_func, '__doc__')):",
            "            del method.im_func.__doc__",
            "",
            "property_methods = (",
            "    'getProperty',",
            "    'propertyValues',",
            "    'propertyItems',",
            "    'propertyMap',",
            "    'hasProperty',",
            "    'getPropertyType',",
            "    'propertyIds',",
            "    'propertyLabel',",
            "    'propertyDescription'",
            ")",
            "",
            "for method_name in property_methods:",
            "    method = getattr(PropertyManager, method_name, None)",
            "    if (method is not None and hasattr(method, 'im_func') and",
            "            hasattr(method.im_func, '__doc__')):",
            "        del method.im_func.__doc__"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# From Products.PloneHotfix20160419",
            "# Plus extras for properties.",
            "# Plus Products.PloneHotfix20210518.",
            "from OFS.PropertyManager import PropertyManager",
            "#from OFS.ZDOM import Document",
            "#from OFS.ZDOM import Node",
            "from Products.CMFPlone.Portal import PloneSite",
            "",
            "",
            "try:",
            "    from plone.dexterity.content import Item",
            "    from plone.dexterity.content import Container",
            "except ImportError:",
            "    class Item(object):",
            "        pass",
            "",
            "    class Container(object):",
            "        pass",
            "",
            "try:",
            "    from Products.ATContentTypes.content.base import ATCTContent",
            "    from Products.ATContentTypes.content.base import ATCTBTreeFolder",
            "except ImportError:",
            "",
            "    class ATCTContent(object):",
            "        pass",
            "",
            "    class ATCTBTreeFolder(object):",
            "        pass",
            "",
            "",
            "def delete_method_docstring(klass, method_name):",
            "    # Delete the docstring from the class method.",
            "    # Objects must have a docstring to be published.",
            "    # So this avoids them getting published.",
            "    method = getattr(klass, method_name, None)",
            "    if method is None:",
            "        return",
            "    if hasattr(method, \"im_func\"):",
            "        # Only Python 2 has im_func.",
            "        # Python 3 has __func__, but only on methods of instances, not classes.",
            "        if hasattr(method.im_func, \"__doc__\"):",
            "            del method.im_func.__doc__",
            "    else:",
            "        # This would fail on Python 2 with an AttributeError:",
            "        # \"attribute '__doc__' of 'instancemethod' objects is not writable\"",
            "        if hasattr(method, \"__doc__\"):",
            "            del method.__doc__",
            "",
            "",
            "klasses = (",
            "#    Node,",
            "#    Document,",
            "    PloneSite,",
            "    Item,",
            "    Container,",
            "    ATCTContent,",
            "    ATCTBTreeFolder",
            ")",
            "methods = (",
            "    'EffectiveDate',",
            "    'ExpirationDate',",
            "    'getAttributes',",
            "    'getChildNodes',",
            "    'getFirstChild',",
            "    'getLastChild',",
            "    'getLayout',",
            "    'getNextSibling',",
            "    'getNodeName',",
            "    'getNodeType',",
            "    'getNodeValue',",
            "    'getOwnerDocument',",
            "    'getParentNode',",
            "    'getPhysicalPath',",
            "    'getPreviousSibling',",
            "    'getTagName',",
            "    'hasChildNodes',",
            "    'Type'",
            ")",
            "",
            "for klass in klasses:",
            "    for method_name in methods:",
            "        delete_method_docstring(klass, method_name)",
            "",
            "property_methods = (",
            "    'getProperty',",
            "    'propertyValues',",
            "    'propertyItems',",
            "    'propertyMap',",
            "    'hasProperty',",
            "    'getPropertyType',",
            "    'propertyIds',",
            "    'propertyLabel',",
            "    'propertyDescription'",
            ")",
            "",
            "for method_name in property_methods:",
            "    delete_method_docstring(PropertyManager, method_name)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "64": [
                "method"
            ],
            "65": [],
            "66": [],
            "67": [],
            "82": [
                "method"
            ],
            "83": [],
            "84": [],
            "85": []
        },
        "addLocation": [
            "tlslite.tlsrecordlayer",
            "Products.CMFPlone.patches.publishing"
        ]
    }
}