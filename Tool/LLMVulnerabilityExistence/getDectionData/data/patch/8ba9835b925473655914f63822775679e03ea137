{
    "langchain/chains/pal/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from __future__ import annotations"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+import ast"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import warnings"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from typing import Any, Dict, List, Optional"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from langchain.schema.language_model import BaseLanguageModel"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from langchain.utilities import PythonREPL"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+class PALValidation(object):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    def __init__("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        self,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        solution_expression_name: Optional[str] = None,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        solution_expression_type: Optional[type] = None,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        allow_imports: bool = False,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        allow_command_exec: bool = False,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    ):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        \"\"\"Initialize an PALValidation instance"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        Args:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            solution_expression_name (str): Name of the expected solution expressions."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+                If passed, solution_expression_type must be passed as well"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            solution_expression_type (str): ast type of the expected solution"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+                expression. If passed, solution_expression_name must be passed as well."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            allow_imports (bool): Allow import statements"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            allow_command_exec (bool): Allow using known command execution functions."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        \"\"\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        self.solution_expression_name = solution_expression_name"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        self.solution_expression_type = solution_expression_type"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        if solution_expression_name is not None:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            if not isinstance(self.solution_expression_name, str):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                raise ValueError("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                    f\"Expected solution_expression_name to be str, \""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                    f\"instead found {type(self.solution_expression_name)}\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        if solution_expression_type is not None:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+            if ("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                self.solution_expression_type"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                and self.solution_expression_type"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            ):"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+                raise ValueError("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                    f\"Expected solution_expression_type to be one of \""
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                    f\"({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},\""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+                    f\"{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),\""
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                    f\"instead found {self.solution_expression_type}\""
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                )"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        if solution_expression_name is not None and solution_expression_type is None:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            raise TypeError("
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                \"solution_expression_name \""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                \"requires solution_expression_type to be passed as well\""
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            )"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        if solution_expression_name is None and solution_expression_type is not None:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            raise TypeError("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                \"solution_expression_type \""
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                \"requires solution_expression_name to be passed as well\""
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+            )"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        self.allow_imports = allow_imports"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        self.allow_command_exec = allow_command_exec"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "73": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " class PALChain(Chain):"
            },
            "74": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     \"\"\"Implements Program-Aided Language Models.\"\"\""
            },
            "75": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "     python_locals: Optional[Dict[str, Any]] = None"
            },
            "76": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     output_key: str = \"result\"  #: :meta private:"
            },
            "77": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     return_intermediate_steps: bool = False"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    code_validations: PALValidation = PALValidation()"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    timeout: Optional[int] = 10"
            },
            "80": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     class Config:"
            },
            "82": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         \"\"\"Configuration for this pydantic object.\"\"\""
            },
            "83": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             stop=[self.stop], callbacks=_run_manager.get_child(), **inputs"
            },
            "84": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         )"
            },
            "85": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        PALChain.validate_code(code, self.code_validations)"
            },
            "87": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)"
            },
            "88": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        res = repl.run(code + f\"\\n{self.get_answer_expr}\")"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=self.timeout)"
            },
            "90": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         output = {self.output_key: res.strip()}"
            },
            "91": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         if self.return_intermediate_steps:"
            },
            "92": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "             output[\"intermediate_steps\"] = code"
            },
            "93": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "         return output"
            },
            "94": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+    @classmethod"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    def validate_code(cls, code: str, code_validations: PALValidation) -> None:"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        try:"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+            code_tree = ast.parse(code)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        except (SyntaxError, UnicodeDecodeError):"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            raise ValueError(f\"Generated code is not valid python code: {code}\")"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        except TypeError:"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            raise ValueError("
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                f\"Generated code is expected to be a string, \""
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                f\"instead found {type(code)}\""
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            )"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        except OverflowError:"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            raise ValueError("
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+                f\"Generated code too long / complex to be parsed by ast: {code}\""
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            )"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        found_solution_expr = False"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        if code_validations.solution_expression_name is None:"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            # Skip validation if no solution_expression_name was given"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+            found_solution_expr = True"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        has_imports = False"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        top_level_nodes = list(ast.iter_child_nodes(code_tree))"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        for node in top_level_nodes:"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            if ("
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                code_validations.solution_expression_name is not None"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+                and code_validations.solution_expression_type is not None"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+            ):"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+                # Check root nodes (like func def)"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+                if ("
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+                    isinstance(node, code_validations.solution_expression_type)"
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+                    and hasattr(node, \"name\")"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                    and node.name == code_validations.solution_expression_name"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                ):"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                    found_solution_expr = True"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+                # Check assigned nodes (like answer variable)"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+                if isinstance(node, ast.Assign):"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+                    for target_node in node.targets:"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+                        if ("
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+                            isinstance("
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                                target_node, code_validations.solution_expression_type"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                            )"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                            and hasattr(target_node, \"id\")"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                            and target_node.id"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+                            == code_validations.solution_expression_name"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                        ):"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                            found_solution_expr = True"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                has_imports = True"
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        if not found_solution_expr:"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            raise ValueError("
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                f\"Generated code is missing the solution expression:\""
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                f\"{code_validations.solution_expression_name} of type:\""
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                f\"{code_validations.solution_expression_type}\""
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+            )"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        if not code_validations.allow_imports and has_imports:"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            raise ValueError(f\"Generated code has disallowed imports: {code}\")"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        if ("
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            not code_validations.allow_command_exec"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            or not code_validations.allow_imports"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        ):"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+            for node in ast.walk(code_tree):"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+                if ("
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                    (not code_validations.allow_command_exec)"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                    and isinstance(node, ast.Call)"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                    and ("
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+                        ("
            },
            "165": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+                            hasattr(node.func, \"id\")"
            },
            "166": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+                            and node.func.id in COMMAND_EXECUTION_FUNCTIONS"
            },
            "167": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+                        )"
            },
            "168": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+                        or ("
            },
            "169": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+                            isinstance(node.func, ast.Attribute)"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                            and node.func.attr in COMMAND_EXECUTION_FUNCTIONS"
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+                        )"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+                    )"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+                ):"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+                    raise ValueError("
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                        f\"Found illegal command execution function\""
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                        f\"{node.func.id} in code {code}\""
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+                    )"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+                if (not code_validations.allow_imports) and ("
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+                    isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom)"
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                ):"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+                    raise ValueError(f\"Generated code has disallowed imports: {code}\")"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+"
            },
            "184": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "     @classmethod"
            },
            "185": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "     def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:"
            },
            "186": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         \"\"\"Load PAL from math prompt.\"\"\""
            },
            "187": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        code_validations = PALValidation("
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            solution_expression_name=\"solution\","
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        )"
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+"
            },
            "193": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         return cls("
            },
            "194": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "             llm_chain=llm_chain,"
            },
            "195": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "             stop=\"\\n\\n\","
            },
            "196": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "             get_answer_expr=\"print(solution())\","
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+            code_validations=code_validations,"
            },
            "198": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "             **kwargs,"
            },
            "199": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         )"
            },
            "200": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 263,
                "PatchRowcode": " "
            },
            "201": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "     ) -> PALChain:"
            },
            "202": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "         \"\"\"Load PAL from colored object prompt.\"\"\""
            },
            "203": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)"
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        code_validations = PALValidation("
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+            solution_expression_name=\"answer\","
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+        )"
            },
            "208": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         return cls("
            },
            "209": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "             llm_chain=llm_chain,"
            },
            "210": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "             stop=\"\\n\\n\\n\","
            },
            "211": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "             get_answer_expr=\"print(answer)\","
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+            code_validations=code_validations,"
            },
            "213": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "             **kwargs,"
            },
            "214": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         )"
            },
            "215": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "As in https://arxiv.org/pdf/2211.10435.pdf.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import warnings",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import Extra, root_validator",
            "",
            "from langchain.callbacks.manager import CallbackManagerForChainRun",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.chains.pal.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain.chains.pal.math_prompt import MATH_PROMPT",
            "from langchain.schema import BasePromptTemplate",
            "from langchain.schema.language_model import BaseLanguageModel",
            "from langchain.utilities import PythonREPL",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Implements Program-Aided Language Models.\"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    llm: Optional[BaseLanguageModel] = None",
            "    \"\"\"[Deprecated]\"\"\"",
            "    prompt: BasePromptTemplate = MATH_PROMPT",
            "    \"\"\"[Deprecated]\"\"\"",
            "    stop: str = \"\\n\\n\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @root_validator(pre=True)",
            "    def raise_deprecation(cls, values: Dict) -> Dict:",
            "        if \"llm\" in values:",
            "            warnings.warn(",
            "                \"Directly instantiating an PALChain with an llm is deprecated. \"",
            "                \"Please instantiate with llm_chain argument or using the one of \"",
            "                \"the class method constructors from_math_prompt, \"",
            "                \"from_colored_object_prompt.\"",
            "            )",
            "            if \"llm_chain\" not in values and values[\"llm\"] is not None:",
            "                values[\"llm_chain\"] = LLMChain(llm=values[\"llm\"], prompt=MATH_PROMPT)",
            "        return values",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\")",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "afterPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "As in https://arxiv.org/pdf/2211.10435.pdf.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import ast",
            "import warnings",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import Extra, root_validator",
            "",
            "from langchain.callbacks.manager import CallbackManagerForChainRun",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.chains.pal.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain.chains.pal.math_prompt import MATH_PROMPT",
            "from langchain.schema import BasePromptTemplate",
            "from langchain.schema.language_model import BaseLanguageModel",
            "from langchain.utilities import PythonREPL",
            "",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]",
            "",
            "",
            "class PALValidation(object):",
            "    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef",
            "    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name",
            "",
            "    def __init__(",
            "        self,",
            "        solution_expression_name: Optional[str] = None,",
            "        solution_expression_type: Optional[type] = None,",
            "        allow_imports: bool = False,",
            "        allow_command_exec: bool = False,",
            "    ):",
            "        \"\"\"Initialize an PALValidation instance",
            "        Args:",
            "            solution_expression_name (str): Name of the expected solution expressions.",
            "                If passed, solution_expression_type must be passed as well",
            "            solution_expression_type (str): ast type of the expected solution",
            "                expression. If passed, solution_expression_name must be passed as well.",
            "                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            allow_imports (bool): Allow import statements",
            "            allow_command_exec (bool): Allow using known command execution functions.",
            "        \"\"\"",
            "        self.solution_expression_name = solution_expression_name",
            "        self.solution_expression_type = solution_expression_type",
            "",
            "        if solution_expression_name is not None:",
            "            if not isinstance(self.solution_expression_name, str):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_name to be str, \"",
            "                    f\"instead found {type(self.solution_expression_name)}\"",
            "                )",
            "        if solution_expression_type is not None:",
            "            if (",
            "                self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION",
            "                and self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            ):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_type to be one of \"",
            "                    f\"({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},\"",
            "                    f\"{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),\"",
            "                    f\"instead found {self.solution_expression_type}\"",
            "                )",
            "",
            "        if solution_expression_name is not None and solution_expression_type is None:",
            "            raise TypeError(",
            "                \"solution_expression_name \"",
            "                \"requires solution_expression_type to be passed as well\"",
            "            )",
            "        if solution_expression_name is None and solution_expression_type is not None:",
            "            raise TypeError(",
            "                \"solution_expression_type \"",
            "                \"requires solution_expression_name to be passed as well\"",
            "            )",
            "",
            "        self.allow_imports = allow_imports",
            "        self.allow_command_exec = allow_command_exec",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Implements Program-Aided Language Models.\"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    llm: Optional[BaseLanguageModel] = None",
            "    \"\"\"[Deprecated]\"\"\"",
            "    prompt: BasePromptTemplate = MATH_PROMPT",
            "    \"\"\"[Deprecated]\"\"\"",
            "    stop: str = \"\\n\\n\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    code_validations: PALValidation = PALValidation()",
            "    timeout: Optional[int] = 10",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @root_validator(pre=True)",
            "    def raise_deprecation(cls, values: Dict) -> Dict:",
            "        if \"llm\" in values:",
            "            warnings.warn(",
            "                \"Directly instantiating an PALChain with an llm is deprecated. \"",
            "                \"Please instantiate with llm_chain argument or using the one of \"",
            "                \"the class method constructors from_math_prompt, \"",
            "                \"from_colored_object_prompt.\"",
            "            )",
            "            if \"llm_chain\" not in values and values[\"llm\"] is not None:",
            "                values[\"llm_chain\"] = LLMChain(llm=values[\"llm\"], prompt=MATH_PROMPT)",
            "        return values",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=self.timeout)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: PALValidation) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, \"",
            "                f\"instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        found_solution_expr = False",
            "        if code_validations.solution_expression_name is None:",
            "            # Skip validation if no solution_expression_name was given",
            "            found_solution_expr = True",
            "",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            if (",
            "                code_validations.solution_expression_name is not None",
            "                and code_validations.solution_expression_type is not None",
            "            ):",
            "                # Check root nodes (like func def)",
            "                if (",
            "                    isinstance(node, code_validations.solution_expression_type)",
            "                    and hasattr(node, \"name\")",
            "                    and node.name == code_validations.solution_expression_name",
            "                ):",
            "                    found_solution_expr = True",
            "                # Check assigned nodes (like answer variable)",
            "                if isinstance(node, ast.Assign):",
            "                    for target_node in node.targets:",
            "                        if (",
            "                            isinstance(",
            "                                target_node, code_validations.solution_expression_type",
            "                            )",
            "                            and hasattr(target_node, \"id\")",
            "                            and target_node.id",
            "                            == code_validations.solution_expression_name",
            "                        ):",
            "                            found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression:\"",
            "                f\"{code_validations.solution_expression_name} of type:\"",
            "                f\"{code_validations.solution_expression_type}\"",
            "            )",
            "",
            "        if not code_validations.allow_imports and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if (",
            "            not code_validations.allow_command_exec",
            "            or not code_validations.allow_imports",
            "        ):",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    (not code_validations.allow_command_exec)",
            "                    and isinstance(node, ast.Call)",
            "                    and (",
            "                        (",
            "                            hasattr(node.func, \"id\")",
            "                            and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                        )",
            "                        or (",
            "                            isinstance(node.func, ast.Attribute)",
            "                            and node.func.attr in COMMAND_EXECUTION_FUNCTIONS",
            "                        )",
            "                    )",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function\"",
            "                        f\"{node.func.id} in code {code}\"",
            "                    )",
            "",
            "                if (not code_validations.allow_imports) and (",
            "                    isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom)",
            "                ):",
            "                    raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"solution\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "        )",
            "",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"answer\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "86": [
                "PALChain",
                "_call"
            ]
        },
        "addLocation": [
            "langchain.chains.pal.base.PALChain._call.output",
            "langchain.chains.pal.base.PALChain.from_math_prompt",
            "litestar.connection.request",
            "langchain.chains.pal.base.PALChain.self",
            "langchain.chains.pal.base.PALChain",
            "langchain.chains.pal.base.PALChain.from_colored_object_prompt"
        ]
    },
    "langchain/utilities/python.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import functools"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+import logging"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import multiprocessing"
            },
            "3": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import sys"
            },
            "4": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from io import StringIO"
            },
            "5": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Dict, Optional"
            },
            "6": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from pydantic import BaseModel, Field"
            },
            "8": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+logger = logging.getLogger(__name__)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+@functools.lru_cache(maxsize=None)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+def warn_once() -> None:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    # Warn that the PythonREPL"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    logger.warning(\"Python REPL can execute arbitrary code. Use with caution.\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " class PythonREPL(BaseModel):"
            },
            "19": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     \"\"\"Simulates a standalone Python REPL.\"\"\""
            },
            "20": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")"
            },
            "22": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")"
            },
            "23": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def run(self, command: str) -> str:"
            },
            "25": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Run command with own globals/locals and returns anything printed.\"\"\""
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    @classmethod"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    def worker("
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        cls,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        command: str,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        globals: Optional[Dict],"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        locals: Optional[Dict],"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        queue: multiprocessing.Queue,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    ) -> None:"
            },
            "34": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         old_stdout = sys.stdout"
            },
            "35": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         sys.stdout = mystdout = StringIO()"
            },
            "36": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         try:"
            },
            "37": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            exec(command, self.globals, self.locals)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+            exec(command, globals, locals)"
            },
            "39": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "             sys.stdout = old_stdout"
            },
            "40": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            output = mystdout.getvalue()"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            queue.put(mystdout.getvalue())"
            },
            "42": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         except Exception as e:"
            },
            "43": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "             sys.stdout = old_stdout"
            },
            "44": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            output = repr(e)"
            },
            "45": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return output"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+            queue.put(repr(e))"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    def run(self, command: str, timeout: Optional[int] = None) -> str:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        \"\"\"Run command with own globals/locals and returns anything printed."
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        Timeout after the specified number of seconds.\"\"\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        # Warn against dangers of PythonREPL"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        warn_once()"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        queue: multiprocessing.Queue = multiprocessing.Queue()"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        # Only use multiprocessing if we are enforcing a timeout"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        if timeout is not None:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            # create a Process"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            p = multiprocessing.Process("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                target=self.worker, args=(command, self.globals, self.locals, queue)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+            )"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+            # start it"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            p.start()"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            # wait for the process to finish or kill it after timeout seconds"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            p.join(timeout)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            if p.is_alive():"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+                p.terminate()"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                return \"Execution timed out\""
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        else:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            self.worker(command, self.globals, self.locals, queue)"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        # get the result from the worker function"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        return queue.get()"
            }
        },
        "frontPatchFile": [
            "import sys",
            "from io import StringIO",
            "from typing import Dict, Optional",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "",
            "class PythonREPL(BaseModel):",
            "    \"\"\"Simulates a standalone Python REPL.\"\"\"",
            "",
            "    globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")",
            "    locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")",
            "",
            "    def run(self, command: str) -> str:",
            "        \"\"\"Run command with own globals/locals and returns anything printed.\"\"\"",
            "        old_stdout = sys.stdout",
            "        sys.stdout = mystdout = StringIO()",
            "        try:",
            "            exec(command, self.globals, self.locals)",
            "            sys.stdout = old_stdout",
            "            output = mystdout.getvalue()",
            "        except Exception as e:",
            "            sys.stdout = old_stdout",
            "            output = repr(e)",
            "        return output"
        ],
        "afterPatchFile": [
            "import functools",
            "import logging",
            "import multiprocessing",
            "import sys",
            "from io import StringIO",
            "from typing import Dict, Optional",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def warn_once() -> None:",
            "    # Warn that the PythonREPL",
            "    logger.warning(\"Python REPL can execute arbitrary code. Use with caution.\")",
            "",
            "",
            "class PythonREPL(BaseModel):",
            "    \"\"\"Simulates a standalone Python REPL.\"\"\"",
            "",
            "    globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")",
            "    locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")",
            "",
            "    @classmethod",
            "    def worker(",
            "        cls,",
            "        command: str,",
            "        globals: Optional[Dict],",
            "        locals: Optional[Dict],",
            "        queue: multiprocessing.Queue,",
            "    ) -> None:",
            "        old_stdout = sys.stdout",
            "        sys.stdout = mystdout = StringIO()",
            "        try:",
            "            exec(command, globals, locals)",
            "            sys.stdout = old_stdout",
            "            queue.put(mystdout.getvalue())",
            "        except Exception as e:",
            "            sys.stdout = old_stdout",
            "            queue.put(repr(e))",
            "",
            "    def run(self, command: str, timeout: Optional[int] = None) -> str:",
            "        \"\"\"Run command with own globals/locals and returns anything printed.",
            "        Timeout after the specified number of seconds.\"\"\"",
            "",
            "        # Warn against dangers of PythonREPL",
            "        warn_once()",
            "",
            "        queue: multiprocessing.Queue = multiprocessing.Queue()",
            "",
            "        # Only use multiprocessing if we are enforcing a timeout",
            "        if timeout is not None:",
            "            # create a Process",
            "            p = multiprocessing.Process(",
            "                target=self.worker, args=(command, self.globals, self.locals, queue)",
            "            )",
            "",
            "            # start it",
            "            p.start()",
            "",
            "            # wait for the process to finish or kill it after timeout seconds",
            "            p.join(timeout)",
            "",
            "            if p.is_alive():",
            "                p.terminate()",
            "                return \"Execution timed out\"",
            "        else:",
            "            self.worker(command, self.globals, self.locals, queue)",
            "        # get the result from the worker function",
            "        return queue.get()"
        ],
        "action": [
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "14": [
                "PythonREPL",
                "run"
            ],
            "15": [
                "PythonREPL",
                "run"
            ],
            "19": [
                "PythonREPL",
                "run"
            ],
            "21": [
                "PythonREPL",
                "run"
            ],
            "24": [
                "PythonREPL",
                "run"
            ],
            "25": [
                "PythonREPL",
                "run"
            ]
        },
        "addLocation": [
            "litestar.connection.request",
            "langchain.utilities.python.PythonREPL.run"
        ]
    }
}