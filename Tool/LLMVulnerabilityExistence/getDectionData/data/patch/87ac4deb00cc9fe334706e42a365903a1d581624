{
    "core/dbt/cli/flags.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from dataclasses import dataclass"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from importlib import import_module"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from multiprocessing import get_context"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from pprint import pformat as pf"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from typing import Any, Callable, Dict, List, Optional, Set, Union"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from dbt.cli.exceptions import DbtUsageException"
            },
            "8": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from dbt.cli.resolvers import default_log_path, default_project_dir"
            },
            "9": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from dbt.cli.types import Command as CliCommand"
            },
            "10": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from dbt.config.profile import read_user_config"
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from dbt.contracts.project import UserConfig"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from dbt.config.project import read_project_flags"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from dbt.contracts.project import ProjectFlags"
            },
            "14": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from dbt.exceptions import DbtInternalError"
            },
            "15": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from dbt.deprecations import renamed_env_var"
            },
            "16": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from dbt.helper_types import WarnErrorOptions"
            },
            "17": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     \"INDIRECT_SELECTION\": \"eager\","
            },
            "18": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     \"TARGET_PATH\": None,"
            },
            "19": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     \"WARN_ERROR\": None,"
            },
            "20": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Cli args without user_config or env var option."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    # Cli args without project_flags or env var option."
            },
            "22": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     \"FULL_REFRESH\": False,"
            },
            "23": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     \"STRICT_MODE\": False,"
            },
            "24": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     \"STORE_FAILURES\": False,"
            },
            "25": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     \"\"\"Primary configuration artifact for running dbt\"\"\""
            },
            "26": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     def __init__("
            },
            "28": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self, ctx: Optional[Context] = None, user_config: Optional[UserConfig] = None"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        self, ctx: Optional[Context] = None, project_flags: Optional[ProjectFlags] = None"
            },
            "30": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     ) -> None:"
            },
            "31": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         # Set the default flags."
            },
            "32": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         for key, value in FLAGS_DEFAULTS.items():"
            },
            "33": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "                 invoked_subcommand_ctx, params_assigned_from_default, deprecated_env_vars"
            },
            "34": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "             )"
            },
            "35": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 203,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not user_config:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+        if not project_flags:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+            project_dir = getattr(self, \"PROJECT_DIR\", str(default_project_dir()))"
            },
            "39": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "             profiles_dir = getattr(self, \"PROFILES_DIR\", None)"
            },
            "40": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config = read_user_config(profiles_dir) if profiles_dir else None"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+            if profiles_dir and project_dir:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                project_flags = read_project_flags(project_dir, profiles_dir)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+            else:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                project_flags = None"
            },
            "45": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 211,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         # Add entire invocation command to flags"
            },
            "47": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         object.__setattr__(self, \"INVOCATION_COMMAND\", \"dbt \" + \" \".join(sys.argv[1:]))"
            },
            "48": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 214,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Overwrite default assignments with user config if available."
            },
            "50": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if user_config:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        if project_flags:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            # Overwrite default assignments with project flags if available."
            },
            "53": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "             param_assigned_from_default_copy = params_assigned_from_default.copy()"
            },
            "54": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             for param_assigned_from_default in params_assigned_from_default:"
            },
            "55": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user_config_param_value = getattr(user_config, param_assigned_from_default, None)"
            },
            "56": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if user_config_param_value is not None:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+                project_flags_param_value = getattr("
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+                    project_flags, param_assigned_from_default, None"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+                )"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+                if project_flags_param_value is not None:"
            },
            "61": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "                     object.__setattr__("
            },
            "62": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "                         self,"
            },
            "63": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "                         param_assigned_from_default.upper(),"
            },
            "64": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        convert_config(param_assigned_from_default, user_config_param_value),"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                        convert_config(param_assigned_from_default, project_flags_param_value),"
            },
            "66": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "                     )"
            },
            "67": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "                     param_assigned_from_default_copy.remove(param_assigned_from_default)"
            },
            "68": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             params_assigned_from_default = param_assigned_from_default_copy"
            },
            "69": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+            # Add project-level flags that are not available as CLI options / env vars"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            for ("
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                project_level_flag_name,"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+                project_level_flag_value,"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+            ) in project_flags.project_only_flags.items():"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+                object.__setattr__(self, project_level_flag_name.upper(), project_level_flag_value)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         # Set hard coded flags."
            },
            "78": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         object.__setattr__(self, \"WHICH\", invoked_subcommand_name or ctx.info_name)"
            },
            "79": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         object.__setattr__(self, \"MP_CONTEXT\", get_context(\"spawn\"))"
            },
            "80": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         # Starting in v1.5, if `log-path` is set in `dbt_project.yml`, it will raise a deprecation warning,"
            },
            "81": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         # with the possibility of removing it in a future release."
            },
            "82": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         if getattr(self, \"LOG_PATH\", None) is None:"
            },
            "83": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            project_dir = getattr(self, \"PROJECT_DIR\", default_project_dir())"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            project_dir = getattr(self, \"PROJECT_DIR\", str(default_project_dir()))"
            },
            "85": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "             version_check = getattr(self, \"VERSION_CHECK\", True)"
            },
            "86": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            object.__setattr__(self, \"LOG_PATH\", default_log_path(project_dir, version_check))"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            object.__setattr__("
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+                self, \"LOG_PATH\", default_log_path(Path(project_dir), version_check)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+            )"
            },
            "90": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 256,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         # Support console DO NOT TRACK initiative."
            },
            "92": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         if os.getenv(\"DO_NOT_TRACK\", \"\").lower() in (\"1\", \"t\", \"true\", \"y\", \"yes\"):"
            }
        },
        "frontPatchFile": [
            "import os",
            "import sys",
            "from dataclasses import dataclass",
            "from importlib import import_module",
            "from multiprocessing import get_context",
            "from pprint import pformat as pf",
            "from typing import Any, Callable, Dict, List, Optional, Set, Union",
            "",
            "from click import Context, get_current_context, Parameter",
            "from click.core import Command as ClickCommand, Group, ParameterSource",
            "from dbt.cli.exceptions import DbtUsageException",
            "from dbt.cli.resolvers import default_log_path, default_project_dir",
            "from dbt.cli.types import Command as CliCommand",
            "from dbt.config.profile import read_user_config",
            "from dbt.contracts.project import UserConfig",
            "from dbt.exceptions import DbtInternalError",
            "from dbt.deprecations import renamed_env_var",
            "from dbt.helper_types import WarnErrorOptions",
            "",
            "if os.name != \"nt\":",
            "    # https://bugs.python.org/issue41567",
            "    import multiprocessing.popen_spawn_posix  # type: ignore  # noqa: F401",
            "",
            "FLAGS_DEFAULTS = {",
            "    \"INDIRECT_SELECTION\": \"eager\",",
            "    \"TARGET_PATH\": None,",
            "    \"WARN_ERROR\": None,",
            "    # Cli args without user_config or env var option.",
            "    \"FULL_REFRESH\": False,",
            "    \"STRICT_MODE\": False,",
            "    \"STORE_FAILURES\": False,",
            "    \"INTROSPECT\": True,",
            "}",
            "",
            "DEPRECATED_PARAMS = {",
            "    \"deprecated_defer\": \"defer\",",
            "    \"deprecated_favor_state\": \"favor_state\",",
            "    \"deprecated_print\": \"print\",",
            "    \"deprecated_state\": \"state\",",
            "}",
            "",
            "",
            "WHICH_KEY = \"which\"",
            "",
            "",
            "def convert_config(config_name, config_value):",
            "    \"\"\"Convert the values from config and original set_from_args to the correct type.\"\"\"",
            "    ret = config_value",
            "    if config_name.lower() == \"warn_error_options\" and type(config_value) == dict:",
            "        ret = WarnErrorOptions(",
            "            include=config_value.get(\"include\", []), exclude=config_value.get(\"exclude\", [])",
            "        )",
            "    return ret",
            "",
            "",
            "def args_to_context(args: List[str]) -> Context:",
            "    \"\"\"Convert a list of args to a click context with proper hierarchy for dbt commands\"\"\"",
            "    from dbt.cli.main import cli",
            "",
            "    cli_ctx = cli.make_context(cli.name, args)",
            "    # Split args if they're a comma separated string.",
            "    if len(args) == 1 and \",\" in args[0]:",
            "        args = args[0].split(\",\")",
            "    sub_command_name, sub_command, args = cli.resolve_command(cli_ctx, args)",
            "    # Handle source and docs group.",
            "    if isinstance(sub_command, Group):",
            "        sub_command_name, sub_command, args = sub_command.resolve_command(cli_ctx, args)",
            "",
            "    assert isinstance(sub_command, ClickCommand)",
            "    sub_command_ctx = sub_command.make_context(sub_command_name, args)",
            "    sub_command_ctx.parent = cli_ctx",
            "    return sub_command_ctx",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Flags:",
            "    \"\"\"Primary configuration artifact for running dbt\"\"\"",
            "",
            "    def __init__(",
            "        self, ctx: Optional[Context] = None, user_config: Optional[UserConfig] = None",
            "    ) -> None:",
            "        # Set the default flags.",
            "        for key, value in FLAGS_DEFAULTS.items():",
            "            object.__setattr__(self, key, value)",
            "",
            "        if ctx is None:",
            "            ctx = get_current_context()",
            "",
            "        def _get_params_by_source(ctx: Context, source_type: ParameterSource):",
            "            \"\"\"Generates all params of a given source type.\"\"\"",
            "            yield from [",
            "                name for name, source in ctx._parameter_source.items() if source is source_type",
            "            ]",
            "            if ctx.parent:",
            "                yield from _get_params_by_source(ctx.parent, source_type)",
            "",
            "        # Ensure that any params sourced from the commandline are not present more than once.",
            "        # Click handles this exclusivity, but only at a per-subcommand level.",
            "        seen_params = []",
            "        for param in _get_params_by_source(ctx, ParameterSource.COMMANDLINE):",
            "            if param in seen_params:",
            "                raise DbtUsageException(",
            "                    f\"{param.lower()} was provided both before and after the subcommand, it can only be set either before or after.\",",
            "                )",
            "            seen_params.append(param)",
            "",
            "        def _assign_params(",
            "            ctx: Context,",
            "            params_assigned_from_default: set,",
            "            deprecated_env_vars: Dict[str, Callable],",
            "        ):",
            "            \"\"\"Recursively adds all click params to flag object\"\"\"",
            "            for param_name, param_value in ctx.params.items():",
            "                # N.B. You have to use the base MRO method (object.__setattr__) to set attributes",
            "                # when using frozen dataclasses.",
            "                # https://docs.python.org/3/library/dataclasses.html#frozen-instances",
            "",
            "                # Handle deprecated env vars while still respecting old values",
            "                # e.g. DBT_NO_PRINT -> DBT_PRINT if DBT_NO_PRINT is set, it is",
            "                # respected over DBT_PRINT or --print.",
            "                new_name: Union[str, None] = None",
            "                if param_name in DEPRECATED_PARAMS:",
            "                    # Deprecated env vars can only be set via env var.",
            "                    # We use the deprecated option in click to serialize the value",
            "                    # from the env var string.",
            "                    param_source = ctx.get_parameter_source(param_name)",
            "                    if param_source == ParameterSource.DEFAULT:",
            "                        continue",
            "                    elif param_source != ParameterSource.ENVIRONMENT:",
            "                        raise DbtUsageException(",
            "                            \"Deprecated parameters can only be set via environment variables\",",
            "                        )",
            "",
            "                    # Rename for clarity.",
            "                    dep_name = param_name",
            "                    new_name = DEPRECATED_PARAMS.get(dep_name)",
            "                    try:",
            "                        assert isinstance(new_name, str)",
            "                    except AssertionError:",
            "                        raise Exception(",
            "                            f\"No deprecated param name match in DEPRECATED_PARAMS from {dep_name} to {new_name}\"",
            "                        )",
            "",
            "                    # Find param objects for their envvar name.",
            "                    try:",
            "                        dep_param = [x for x in ctx.command.params if x.name == dep_name][0]",
            "                        new_param = [x for x in ctx.command.params if x.name == new_name][0]",
            "                    except IndexError:",
            "                        raise Exception(",
            "                            f\"No deprecated param name match in context from {dep_name} to {new_name}\"",
            "                        )",
            "",
            "                    # Remove param from defaulted set since the deprecated",
            "                    # value is not set from default, but from an env var.",
            "                    if new_name in params_assigned_from_default:",
            "                        params_assigned_from_default.remove(new_name)",
            "",
            "                    # Add the deprecation warning function to the set.",
            "                    assert isinstance(dep_param.envvar, str)",
            "                    assert isinstance(new_param.envvar, str)",
            "                    deprecated_env_vars[new_name] = renamed_env_var(",
            "                        old_name=dep_param.envvar,",
            "                        new_name=new_param.envvar,",
            "                    )",
            "",
            "                # Set the flag value.",
            "                is_duplicate = hasattr(self, param_name.upper())",
            "                is_default = ctx.get_parameter_source(param_name) == ParameterSource.DEFAULT",
            "                flag_name = (new_name or param_name).upper()",
            "",
            "                if (is_duplicate and not is_default) or not is_duplicate:",
            "                    object.__setattr__(self, flag_name, param_value)",
            "",
            "                # Track default assigned params.",
            "                if is_default:",
            "                    params_assigned_from_default.add(param_name)",
            "",
            "            if ctx.parent:",
            "                _assign_params(ctx.parent, params_assigned_from_default, deprecated_env_vars)",
            "",
            "        params_assigned_from_default = set()  # type: Set[str]",
            "        deprecated_env_vars: Dict[str, Callable] = {}",
            "        _assign_params(ctx, params_assigned_from_default, deprecated_env_vars)",
            "",
            "        # Set deprecated_env_var_warnings to be fired later after events have been init.",
            "        object.__setattr__(",
            "            self, \"deprecated_env_var_warnings\", [x for x in deprecated_env_vars.values()]",
            "        )",
            "",
            "        # Get the invoked command flags.",
            "        invoked_subcommand_name = (",
            "            ctx.invoked_subcommand if hasattr(ctx, \"invoked_subcommand\") else None",
            "        )",
            "        if invoked_subcommand_name is not None:",
            "            invoked_subcommand = getattr(import_module(\"dbt.cli.main\"), invoked_subcommand_name)",
            "            invoked_subcommand.allow_extra_args = True",
            "            invoked_subcommand.ignore_unknown_options = True",
            "            invoked_subcommand_ctx = invoked_subcommand.make_context(None, sys.argv)",
            "            _assign_params(",
            "                invoked_subcommand_ctx, params_assigned_from_default, deprecated_env_vars",
            "            )",
            "",
            "        if not user_config:",
            "            profiles_dir = getattr(self, \"PROFILES_DIR\", None)",
            "            user_config = read_user_config(profiles_dir) if profiles_dir else None",
            "",
            "        # Add entire invocation command to flags",
            "        object.__setattr__(self, \"INVOCATION_COMMAND\", \"dbt \" + \" \".join(sys.argv[1:]))",
            "",
            "        # Overwrite default assignments with user config if available.",
            "        if user_config:",
            "            param_assigned_from_default_copy = params_assigned_from_default.copy()",
            "            for param_assigned_from_default in params_assigned_from_default:",
            "                user_config_param_value = getattr(user_config, param_assigned_from_default, None)",
            "                if user_config_param_value is not None:",
            "                    object.__setattr__(",
            "                        self,",
            "                        param_assigned_from_default.upper(),",
            "                        convert_config(param_assigned_from_default, user_config_param_value),",
            "                    )",
            "                    param_assigned_from_default_copy.remove(param_assigned_from_default)",
            "            params_assigned_from_default = param_assigned_from_default_copy",
            "",
            "        # Set hard coded flags.",
            "        object.__setattr__(self, \"WHICH\", invoked_subcommand_name or ctx.info_name)",
            "        object.__setattr__(self, \"MP_CONTEXT\", get_context(\"spawn\"))",
            "",
            "        # Apply the lead/follow relationship between some parameters.",
            "        self._override_if_set(\"USE_COLORS\", \"USE_COLORS_FILE\", params_assigned_from_default)",
            "        self._override_if_set(\"LOG_LEVEL\", \"LOG_LEVEL_FILE\", params_assigned_from_default)",
            "        self._override_if_set(\"LOG_FORMAT\", \"LOG_FORMAT_FILE\", params_assigned_from_default)",
            "",
            "        # Set default LOG_PATH from PROJECT_DIR, if available.",
            "        # Starting in v1.5, if `log-path` is set in `dbt_project.yml`, it will raise a deprecation warning,",
            "        # with the possibility of removing it in a future release.",
            "        if getattr(self, \"LOG_PATH\", None) is None:",
            "            project_dir = getattr(self, \"PROJECT_DIR\", default_project_dir())",
            "            version_check = getattr(self, \"VERSION_CHECK\", True)",
            "            object.__setattr__(self, \"LOG_PATH\", default_log_path(project_dir, version_check))",
            "",
            "        # Support console DO NOT TRACK initiative.",
            "        if os.getenv(\"DO_NOT_TRACK\", \"\").lower() in (\"1\", \"t\", \"true\", \"y\", \"yes\"):",
            "            object.__setattr__(self, \"SEND_ANONYMOUS_USAGE_STATS\", False)",
            "",
            "        # Check mutual exclusivity once all flags are set.",
            "        self._assert_mutually_exclusive(",
            "            params_assigned_from_default, [\"WARN_ERROR\", \"WARN_ERROR_OPTIONS\"]",
            "        )",
            "",
            "        # Support lower cased access for legacy code.",
            "        params = set(",
            "            x for x in dir(self) if not callable(getattr(self, x)) and not x.startswith(\"__\")",
            "        )",
            "        for param in params:",
            "            object.__setattr__(self, param.lower(), getattr(self, param))",
            "",
            "    def __str__(self) -> str:",
            "        return str(pf(self.__dict__))",
            "",
            "    def _override_if_set(self, lead: str, follow: str, defaulted: Set[str]) -> None:",
            "        \"\"\"If the value of the lead parameter was set explicitly, apply the value to follow, unless follow was also set explicitly.\"\"\"",
            "        if lead.lower() not in defaulted and follow.lower() in defaulted:",
            "            object.__setattr__(self, follow.upper(), getattr(self, lead.upper(), None))",
            "",
            "    def _assert_mutually_exclusive(",
            "        self, params_assigned_from_default: Set[str], group: List[str]",
            "    ) -> None:",
            "        \"\"\"",
            "        Ensure no elements from group are simultaneously provided by a user, as inferred from params_assigned_from_default.",
            "        Raises click.UsageError if any two elements from group are simultaneously provided by a user.",
            "        \"\"\"",
            "        set_flag = None",
            "        for flag in group:",
            "            flag_set_by_user = flag.lower() not in params_assigned_from_default",
            "            if flag_set_by_user and set_flag:",
            "                raise DbtUsageException(",
            "                    f\"{flag.lower()}: not allowed with argument {set_flag.lower()}\"",
            "                )",
            "            elif flag_set_by_user:",
            "                set_flag = flag",
            "",
            "    def fire_deprecations(self):",
            "        \"\"\"Fires events for deprecated env_var usage.\"\"\"",
            "        [dep_fn() for dep_fn in self.deprecated_env_var_warnings]",
            "        # It is necessary to remove this attr from the class so it does",
            "        # not get pickled when written to disk as json.",
            "        object.__delattr__(self, \"deprecated_env_var_warnings\")",
            "",
            "    @classmethod",
            "    def from_dict(cls, command: CliCommand, args_dict: Dict[str, Any]) -> \"Flags\":",
            "        command_arg_list = command_params(command, args_dict)",
            "        ctx = args_to_context(command_arg_list)",
            "        flags = cls(ctx=ctx)",
            "        flags.fire_deprecations()",
            "        return flags",
            "",
            "",
            "CommandParams = List[str]",
            "",
            "",
            "def command_params(command: CliCommand, args_dict: Dict[str, Any]) -> CommandParams:",
            "    \"\"\"Given a command and a dict, returns a list of strings representing",
            "    the CLI params for that command. The order of this list is consistent with",
            "    which flags are expected at the parent level vs the command level.",
            "",
            "    e.g. fn(\"run\", {\"defer\": True, \"print\": False}) -> [\"--no-print\", \"run\", \"--defer\"]",
            "",
            "    The result of this function can be passed in to the args_to_context function",
            "    to produce a click context to instantiate Flags with.",
            "    \"\"\"",
            "",
            "    cmd_args = set(command_args(command))",
            "    prnt_args = set(parent_args())",
            "    default_args = set([x.lower() for x in FLAGS_DEFAULTS.keys()])",
            "",
            "    res = command.to_list()",
            "    for k, v in args_dict.items():",
            "        k = k.lower()",
            "        # if a \"which\" value exists in the args dict, it should match the command provided",
            "        if k == WHICH_KEY:",
            "            if v != command.value:",
            "                raise DbtInternalError(",
            "                    f\"Command '{command.value}' does not match value of which: '{v}'\"",
            "                )",
            "            continue",
            "",
            "        # param was assigned from defaults and should not be included",
            "        if k not in (cmd_args | prnt_args) or (",
            "            k in default_args and v == FLAGS_DEFAULTS[k.upper()]",
            "        ):",
            "            continue",
            "",
            "        # if the param is in parent args, it should come before the arg name",
            "        # e.g. [\"--print\", \"run\"] vs [\"run\", \"--print\"]",
            "        add_fn = res.append",
            "        if k in prnt_args:",
            "",
            "            def add_fn(x):",
            "                res.insert(0, x)",
            "",
            "        spinal_cased = k.replace(\"_\", \"-\")",
            "",
            "        # MultiOption flags come back as lists, but we want to pass them as space separated strings",
            "        if isinstance(v, list):",
            "            v = \" \".join(v)",
            "",
            "        if k == \"macro\" and command == CliCommand.RUN_OPERATION:",
            "            add_fn(v)",
            "        # None is a Singleton, False is a Flyweight, only one instance of each.",
            "        elif v is None or v is False:",
            "            add_fn(f\"--no-{spinal_cased}\")",
            "        elif v is True:",
            "            add_fn(f\"--{spinal_cased}\")",
            "        else:",
            "            add_fn(f\"--{spinal_cased}={v}\")",
            "",
            "    return res",
            "",
            "",
            "ArgsList = List[str]",
            "",
            "",
            "def parent_args() -> ArgsList:",
            "    \"\"\"Return a list representing the params the base click command takes.\"\"\"",
            "    from dbt.cli.main import cli",
            "",
            "    return format_params(cli.params)",
            "",
            "",
            "def command_args(command: CliCommand) -> ArgsList:",
            "    \"\"\"Given a command, return a list of strings representing the params",
            "    that command takes. This function only returns params assigned to a",
            "    specific command, not those of its parent command.",
            "",
            "    e.g. fn(\"run\") -> [\"defer\", \"favor_state\", \"exclude\", ...]",
            "    \"\"\"",
            "    import dbt.cli.main as cli",
            "",
            "    CMD_DICT: Dict[CliCommand, ClickCommand] = {",
            "        CliCommand.BUILD: cli.build,",
            "        CliCommand.CLEAN: cli.clean,",
            "        CliCommand.CLONE: cli.clone,",
            "        CliCommand.COMPILE: cli.compile,",
            "        CliCommand.DOCS_GENERATE: cli.docs_generate,",
            "        CliCommand.DOCS_SERVE: cli.docs_serve,",
            "        CliCommand.DEBUG: cli.debug,",
            "        CliCommand.DEPS: cli.deps,",
            "        CliCommand.INIT: cli.init,",
            "        CliCommand.LIST: cli.list,",
            "        CliCommand.PARSE: cli.parse,",
            "        CliCommand.RUN: cli.run,",
            "        CliCommand.RUN_OPERATION: cli.run_operation,",
            "        CliCommand.SEED: cli.seed,",
            "        CliCommand.SHOW: cli.show,",
            "        CliCommand.SNAPSHOT: cli.snapshot,",
            "        CliCommand.SOURCE_FRESHNESS: cli.freshness,",
            "        CliCommand.TEST: cli.test,",
            "        CliCommand.RETRY: cli.retry,",
            "    }",
            "    click_cmd: Optional[ClickCommand] = CMD_DICT.get(command, None)",
            "    if click_cmd is None:",
            "        raise DbtInternalError(f\"No command found for name '{command.name}'\")",
            "    return format_params(click_cmd.params)",
            "",
            "",
            "def format_params(params: List[Parameter]) -> ArgsList:",
            "    return [str(x.name) for x in params if not str(x.name).lower().startswith(\"deprecated_\")]"
        ],
        "afterPatchFile": [
            "import os",
            "import sys",
            "from dataclasses import dataclass",
            "from importlib import import_module",
            "from multiprocessing import get_context",
            "from pathlib import Path",
            "from pprint import pformat as pf",
            "from typing import Any, Callable, Dict, List, Optional, Set, Union",
            "",
            "from click import Context, get_current_context, Parameter",
            "from click.core import Command as ClickCommand, Group, ParameterSource",
            "from dbt.cli.exceptions import DbtUsageException",
            "from dbt.cli.resolvers import default_log_path, default_project_dir",
            "from dbt.cli.types import Command as CliCommand",
            "from dbt.config.project import read_project_flags",
            "from dbt.contracts.project import ProjectFlags",
            "from dbt.exceptions import DbtInternalError",
            "from dbt.deprecations import renamed_env_var",
            "from dbt.helper_types import WarnErrorOptions",
            "",
            "if os.name != \"nt\":",
            "    # https://bugs.python.org/issue41567",
            "    import multiprocessing.popen_spawn_posix  # type: ignore  # noqa: F401",
            "",
            "FLAGS_DEFAULTS = {",
            "    \"INDIRECT_SELECTION\": \"eager\",",
            "    \"TARGET_PATH\": None,",
            "    \"WARN_ERROR\": None,",
            "    # Cli args without project_flags or env var option.",
            "    \"FULL_REFRESH\": False,",
            "    \"STRICT_MODE\": False,",
            "    \"STORE_FAILURES\": False,",
            "    \"INTROSPECT\": True,",
            "}",
            "",
            "DEPRECATED_PARAMS = {",
            "    \"deprecated_defer\": \"defer\",",
            "    \"deprecated_favor_state\": \"favor_state\",",
            "    \"deprecated_print\": \"print\",",
            "    \"deprecated_state\": \"state\",",
            "}",
            "",
            "",
            "WHICH_KEY = \"which\"",
            "",
            "",
            "def convert_config(config_name, config_value):",
            "    \"\"\"Convert the values from config and original set_from_args to the correct type.\"\"\"",
            "    ret = config_value",
            "    if config_name.lower() == \"warn_error_options\" and type(config_value) == dict:",
            "        ret = WarnErrorOptions(",
            "            include=config_value.get(\"include\", []), exclude=config_value.get(\"exclude\", [])",
            "        )",
            "    return ret",
            "",
            "",
            "def args_to_context(args: List[str]) -> Context:",
            "    \"\"\"Convert a list of args to a click context with proper hierarchy for dbt commands\"\"\"",
            "    from dbt.cli.main import cli",
            "",
            "    cli_ctx = cli.make_context(cli.name, args)",
            "    # Split args if they're a comma separated string.",
            "    if len(args) == 1 and \",\" in args[0]:",
            "        args = args[0].split(\",\")",
            "    sub_command_name, sub_command, args = cli.resolve_command(cli_ctx, args)",
            "    # Handle source and docs group.",
            "    if isinstance(sub_command, Group):",
            "        sub_command_name, sub_command, args = sub_command.resolve_command(cli_ctx, args)",
            "",
            "    assert isinstance(sub_command, ClickCommand)",
            "    sub_command_ctx = sub_command.make_context(sub_command_name, args)",
            "    sub_command_ctx.parent = cli_ctx",
            "    return sub_command_ctx",
            "",
            "",
            "@dataclass(frozen=True)",
            "class Flags:",
            "    \"\"\"Primary configuration artifact for running dbt\"\"\"",
            "",
            "    def __init__(",
            "        self, ctx: Optional[Context] = None, project_flags: Optional[ProjectFlags] = None",
            "    ) -> None:",
            "        # Set the default flags.",
            "        for key, value in FLAGS_DEFAULTS.items():",
            "            object.__setattr__(self, key, value)",
            "",
            "        if ctx is None:",
            "            ctx = get_current_context()",
            "",
            "        def _get_params_by_source(ctx: Context, source_type: ParameterSource):",
            "            \"\"\"Generates all params of a given source type.\"\"\"",
            "            yield from [",
            "                name for name, source in ctx._parameter_source.items() if source is source_type",
            "            ]",
            "            if ctx.parent:",
            "                yield from _get_params_by_source(ctx.parent, source_type)",
            "",
            "        # Ensure that any params sourced from the commandline are not present more than once.",
            "        # Click handles this exclusivity, but only at a per-subcommand level.",
            "        seen_params = []",
            "        for param in _get_params_by_source(ctx, ParameterSource.COMMANDLINE):",
            "            if param in seen_params:",
            "                raise DbtUsageException(",
            "                    f\"{param.lower()} was provided both before and after the subcommand, it can only be set either before or after.\",",
            "                )",
            "            seen_params.append(param)",
            "",
            "        def _assign_params(",
            "            ctx: Context,",
            "            params_assigned_from_default: set,",
            "            deprecated_env_vars: Dict[str, Callable],",
            "        ):",
            "            \"\"\"Recursively adds all click params to flag object\"\"\"",
            "            for param_name, param_value in ctx.params.items():",
            "                # N.B. You have to use the base MRO method (object.__setattr__) to set attributes",
            "                # when using frozen dataclasses.",
            "                # https://docs.python.org/3/library/dataclasses.html#frozen-instances",
            "",
            "                # Handle deprecated env vars while still respecting old values",
            "                # e.g. DBT_NO_PRINT -> DBT_PRINT if DBT_NO_PRINT is set, it is",
            "                # respected over DBT_PRINT or --print.",
            "                new_name: Union[str, None] = None",
            "                if param_name in DEPRECATED_PARAMS:",
            "                    # Deprecated env vars can only be set via env var.",
            "                    # We use the deprecated option in click to serialize the value",
            "                    # from the env var string.",
            "                    param_source = ctx.get_parameter_source(param_name)",
            "                    if param_source == ParameterSource.DEFAULT:",
            "                        continue",
            "                    elif param_source != ParameterSource.ENVIRONMENT:",
            "                        raise DbtUsageException(",
            "                            \"Deprecated parameters can only be set via environment variables\",",
            "                        )",
            "",
            "                    # Rename for clarity.",
            "                    dep_name = param_name",
            "                    new_name = DEPRECATED_PARAMS.get(dep_name)",
            "                    try:",
            "                        assert isinstance(new_name, str)",
            "                    except AssertionError:",
            "                        raise Exception(",
            "                            f\"No deprecated param name match in DEPRECATED_PARAMS from {dep_name} to {new_name}\"",
            "                        )",
            "",
            "                    # Find param objects for their envvar name.",
            "                    try:",
            "                        dep_param = [x for x in ctx.command.params if x.name == dep_name][0]",
            "                        new_param = [x for x in ctx.command.params if x.name == new_name][0]",
            "                    except IndexError:",
            "                        raise Exception(",
            "                            f\"No deprecated param name match in context from {dep_name} to {new_name}\"",
            "                        )",
            "",
            "                    # Remove param from defaulted set since the deprecated",
            "                    # value is not set from default, but from an env var.",
            "                    if new_name in params_assigned_from_default:",
            "                        params_assigned_from_default.remove(new_name)",
            "",
            "                    # Add the deprecation warning function to the set.",
            "                    assert isinstance(dep_param.envvar, str)",
            "                    assert isinstance(new_param.envvar, str)",
            "                    deprecated_env_vars[new_name] = renamed_env_var(",
            "                        old_name=dep_param.envvar,",
            "                        new_name=new_param.envvar,",
            "                    )",
            "",
            "                # Set the flag value.",
            "                is_duplicate = hasattr(self, param_name.upper())",
            "                is_default = ctx.get_parameter_source(param_name) == ParameterSource.DEFAULT",
            "                flag_name = (new_name or param_name).upper()",
            "",
            "                if (is_duplicate and not is_default) or not is_duplicate:",
            "                    object.__setattr__(self, flag_name, param_value)",
            "",
            "                # Track default assigned params.",
            "                if is_default:",
            "                    params_assigned_from_default.add(param_name)",
            "",
            "            if ctx.parent:",
            "                _assign_params(ctx.parent, params_assigned_from_default, deprecated_env_vars)",
            "",
            "        params_assigned_from_default = set()  # type: Set[str]",
            "        deprecated_env_vars: Dict[str, Callable] = {}",
            "        _assign_params(ctx, params_assigned_from_default, deprecated_env_vars)",
            "",
            "        # Set deprecated_env_var_warnings to be fired later after events have been init.",
            "        object.__setattr__(",
            "            self, \"deprecated_env_var_warnings\", [x for x in deprecated_env_vars.values()]",
            "        )",
            "",
            "        # Get the invoked command flags.",
            "        invoked_subcommand_name = (",
            "            ctx.invoked_subcommand if hasattr(ctx, \"invoked_subcommand\") else None",
            "        )",
            "        if invoked_subcommand_name is not None:",
            "            invoked_subcommand = getattr(import_module(\"dbt.cli.main\"), invoked_subcommand_name)",
            "            invoked_subcommand.allow_extra_args = True",
            "            invoked_subcommand.ignore_unknown_options = True",
            "            invoked_subcommand_ctx = invoked_subcommand.make_context(None, sys.argv)",
            "            _assign_params(",
            "                invoked_subcommand_ctx, params_assigned_from_default, deprecated_env_vars",
            "            )",
            "",
            "        if not project_flags:",
            "            project_dir = getattr(self, \"PROJECT_DIR\", str(default_project_dir()))",
            "            profiles_dir = getattr(self, \"PROFILES_DIR\", None)",
            "            if profiles_dir and project_dir:",
            "                project_flags = read_project_flags(project_dir, profiles_dir)",
            "            else:",
            "                project_flags = None",
            "",
            "        # Add entire invocation command to flags",
            "        object.__setattr__(self, \"INVOCATION_COMMAND\", \"dbt \" + \" \".join(sys.argv[1:]))",
            "",
            "        if project_flags:",
            "            # Overwrite default assignments with project flags if available.",
            "            param_assigned_from_default_copy = params_assigned_from_default.copy()",
            "            for param_assigned_from_default in params_assigned_from_default:",
            "                project_flags_param_value = getattr(",
            "                    project_flags, param_assigned_from_default, None",
            "                )",
            "                if project_flags_param_value is not None:",
            "                    object.__setattr__(",
            "                        self,",
            "                        param_assigned_from_default.upper(),",
            "                        convert_config(param_assigned_from_default, project_flags_param_value),",
            "                    )",
            "                    param_assigned_from_default_copy.remove(param_assigned_from_default)",
            "            params_assigned_from_default = param_assigned_from_default_copy",
            "",
            "            # Add project-level flags that are not available as CLI options / env vars",
            "            for (",
            "                project_level_flag_name,",
            "                project_level_flag_value,",
            "            ) in project_flags.project_only_flags.items():",
            "                object.__setattr__(self, project_level_flag_name.upper(), project_level_flag_value)",
            "",
            "        # Set hard coded flags.",
            "        object.__setattr__(self, \"WHICH\", invoked_subcommand_name or ctx.info_name)",
            "        object.__setattr__(self, \"MP_CONTEXT\", get_context(\"spawn\"))",
            "",
            "        # Apply the lead/follow relationship between some parameters.",
            "        self._override_if_set(\"USE_COLORS\", \"USE_COLORS_FILE\", params_assigned_from_default)",
            "        self._override_if_set(\"LOG_LEVEL\", \"LOG_LEVEL_FILE\", params_assigned_from_default)",
            "        self._override_if_set(\"LOG_FORMAT\", \"LOG_FORMAT_FILE\", params_assigned_from_default)",
            "",
            "        # Set default LOG_PATH from PROJECT_DIR, if available.",
            "        # Starting in v1.5, if `log-path` is set in `dbt_project.yml`, it will raise a deprecation warning,",
            "        # with the possibility of removing it in a future release.",
            "        if getattr(self, \"LOG_PATH\", None) is None:",
            "            project_dir = getattr(self, \"PROJECT_DIR\", str(default_project_dir()))",
            "            version_check = getattr(self, \"VERSION_CHECK\", True)",
            "            object.__setattr__(",
            "                self, \"LOG_PATH\", default_log_path(Path(project_dir), version_check)",
            "            )",
            "",
            "        # Support console DO NOT TRACK initiative.",
            "        if os.getenv(\"DO_NOT_TRACK\", \"\").lower() in (\"1\", \"t\", \"true\", \"y\", \"yes\"):",
            "            object.__setattr__(self, \"SEND_ANONYMOUS_USAGE_STATS\", False)",
            "",
            "        # Check mutual exclusivity once all flags are set.",
            "        self._assert_mutually_exclusive(",
            "            params_assigned_from_default, [\"WARN_ERROR\", \"WARN_ERROR_OPTIONS\"]",
            "        )",
            "",
            "        # Support lower cased access for legacy code.",
            "        params = set(",
            "            x for x in dir(self) if not callable(getattr(self, x)) and not x.startswith(\"__\")",
            "        )",
            "        for param in params:",
            "            object.__setattr__(self, param.lower(), getattr(self, param))",
            "",
            "    def __str__(self) -> str:",
            "        return str(pf(self.__dict__))",
            "",
            "    def _override_if_set(self, lead: str, follow: str, defaulted: Set[str]) -> None:",
            "        \"\"\"If the value of the lead parameter was set explicitly, apply the value to follow, unless follow was also set explicitly.\"\"\"",
            "        if lead.lower() not in defaulted and follow.lower() in defaulted:",
            "            object.__setattr__(self, follow.upper(), getattr(self, lead.upper(), None))",
            "",
            "    def _assert_mutually_exclusive(",
            "        self, params_assigned_from_default: Set[str], group: List[str]",
            "    ) -> None:",
            "        \"\"\"",
            "        Ensure no elements from group are simultaneously provided by a user, as inferred from params_assigned_from_default.",
            "        Raises click.UsageError if any two elements from group are simultaneously provided by a user.",
            "        \"\"\"",
            "        set_flag = None",
            "        for flag in group:",
            "            flag_set_by_user = flag.lower() not in params_assigned_from_default",
            "            if flag_set_by_user and set_flag:",
            "                raise DbtUsageException(",
            "                    f\"{flag.lower()}: not allowed with argument {set_flag.lower()}\"",
            "                )",
            "            elif flag_set_by_user:",
            "                set_flag = flag",
            "",
            "    def fire_deprecations(self):",
            "        \"\"\"Fires events for deprecated env_var usage.\"\"\"",
            "        [dep_fn() for dep_fn in self.deprecated_env_var_warnings]",
            "        # It is necessary to remove this attr from the class so it does",
            "        # not get pickled when written to disk as json.",
            "        object.__delattr__(self, \"deprecated_env_var_warnings\")",
            "",
            "    @classmethod",
            "    def from_dict(cls, command: CliCommand, args_dict: Dict[str, Any]) -> \"Flags\":",
            "        command_arg_list = command_params(command, args_dict)",
            "        ctx = args_to_context(command_arg_list)",
            "        flags = cls(ctx=ctx)",
            "        flags.fire_deprecations()",
            "        return flags",
            "",
            "",
            "CommandParams = List[str]",
            "",
            "",
            "def command_params(command: CliCommand, args_dict: Dict[str, Any]) -> CommandParams:",
            "    \"\"\"Given a command and a dict, returns a list of strings representing",
            "    the CLI params for that command. The order of this list is consistent with",
            "    which flags are expected at the parent level vs the command level.",
            "",
            "    e.g. fn(\"run\", {\"defer\": True, \"print\": False}) -> [\"--no-print\", \"run\", \"--defer\"]",
            "",
            "    The result of this function can be passed in to the args_to_context function",
            "    to produce a click context to instantiate Flags with.",
            "    \"\"\"",
            "",
            "    cmd_args = set(command_args(command))",
            "    prnt_args = set(parent_args())",
            "    default_args = set([x.lower() for x in FLAGS_DEFAULTS.keys()])",
            "",
            "    res = command.to_list()",
            "    for k, v in args_dict.items():",
            "        k = k.lower()",
            "        # if a \"which\" value exists in the args dict, it should match the command provided",
            "        if k == WHICH_KEY:",
            "            if v != command.value:",
            "                raise DbtInternalError(",
            "                    f\"Command '{command.value}' does not match value of which: '{v}'\"",
            "                )",
            "            continue",
            "",
            "        # param was assigned from defaults and should not be included",
            "        if k not in (cmd_args | prnt_args) or (",
            "            k in default_args and v == FLAGS_DEFAULTS[k.upper()]",
            "        ):",
            "            continue",
            "",
            "        # if the param is in parent args, it should come before the arg name",
            "        # e.g. [\"--print\", \"run\"] vs [\"run\", \"--print\"]",
            "        add_fn = res.append",
            "        if k in prnt_args:",
            "",
            "            def add_fn(x):",
            "                res.insert(0, x)",
            "",
            "        spinal_cased = k.replace(\"_\", \"-\")",
            "",
            "        # MultiOption flags come back as lists, but we want to pass them as space separated strings",
            "        if isinstance(v, list):",
            "            v = \" \".join(v)",
            "",
            "        if k == \"macro\" and command == CliCommand.RUN_OPERATION:",
            "            add_fn(v)",
            "        # None is a Singleton, False is a Flyweight, only one instance of each.",
            "        elif v is None or v is False:",
            "            add_fn(f\"--no-{spinal_cased}\")",
            "        elif v is True:",
            "            add_fn(f\"--{spinal_cased}\")",
            "        else:",
            "            add_fn(f\"--{spinal_cased}={v}\")",
            "",
            "    return res",
            "",
            "",
            "ArgsList = List[str]",
            "",
            "",
            "def parent_args() -> ArgsList:",
            "    \"\"\"Return a list representing the params the base click command takes.\"\"\"",
            "    from dbt.cli.main import cli",
            "",
            "    return format_params(cli.params)",
            "",
            "",
            "def command_args(command: CliCommand) -> ArgsList:",
            "    \"\"\"Given a command, return a list of strings representing the params",
            "    that command takes. This function only returns params assigned to a",
            "    specific command, not those of its parent command.",
            "",
            "    e.g. fn(\"run\") -> [\"defer\", \"favor_state\", \"exclude\", ...]",
            "    \"\"\"",
            "    import dbt.cli.main as cli",
            "",
            "    CMD_DICT: Dict[CliCommand, ClickCommand] = {",
            "        CliCommand.BUILD: cli.build,",
            "        CliCommand.CLEAN: cli.clean,",
            "        CliCommand.CLONE: cli.clone,",
            "        CliCommand.COMPILE: cli.compile,",
            "        CliCommand.DOCS_GENERATE: cli.docs_generate,",
            "        CliCommand.DOCS_SERVE: cli.docs_serve,",
            "        CliCommand.DEBUG: cli.debug,",
            "        CliCommand.DEPS: cli.deps,",
            "        CliCommand.INIT: cli.init,",
            "        CliCommand.LIST: cli.list,",
            "        CliCommand.PARSE: cli.parse,",
            "        CliCommand.RUN: cli.run,",
            "        CliCommand.RUN_OPERATION: cli.run_operation,",
            "        CliCommand.SEED: cli.seed,",
            "        CliCommand.SHOW: cli.show,",
            "        CliCommand.SNAPSHOT: cli.snapshot,",
            "        CliCommand.SOURCE_FRESHNESS: cli.freshness,",
            "        CliCommand.TEST: cli.test,",
            "        CliCommand.RETRY: cli.retry,",
            "    }",
            "    click_cmd: Optional[ClickCommand] = CMD_DICT.get(command, None)",
            "    if click_cmd is None:",
            "        raise DbtInternalError(f\"No command found for name '{command.name}'\")",
            "    return format_params(click_cmd.params)",
            "",
            "",
            "def format_params(params: List[Parameter]) -> ArgsList:",
            "    return [str(x.name) for x in params if not str(x.name).lower().startswith(\"deprecated_\")]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [],
            "15": [],
            "28": [],
            "80": [
                "Flags",
                "__init__"
            ],
            "203": [
                "Flags",
                "__init__"
            ],
            "205": [
                "Flags",
                "__init__"
            ],
            "210": [
                "Flags",
                "__init__"
            ],
            "211": [
                "Flags",
                "__init__"
            ],
            "214": [
                "Flags",
                "__init__"
            ],
            "215": [
                "Flags",
                "__init__"
            ],
            "219": [
                "Flags",
                "__init__"
            ],
            "237": [
                "Flags",
                "__init__"
            ],
            "239": [
                "Flags",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "core/dbt/config/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # all these are just exports, they need \"noqa\" so flake8 will not complain."
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .profile import Profile, read_user_config  # noqa"
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from .profile import Profile  # noqa"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from .project import Project, IsFQNResource, PartialProject  # noqa"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from .runtime import RuntimeConfig  # noqa"
            }
        },
        "frontPatchFile": [
            "# all these are just exports, they need \"noqa\" so flake8 will not complain.",
            "from .profile import Profile, read_user_config  # noqa",
            "from .project import Project, IsFQNResource, PartialProject  # noqa",
            "from .runtime import RuntimeConfig  # noqa"
        ],
        "afterPatchFile": [
            "# all these are just exports, they need \"noqa\" so flake8 will not complain.",
            "from .profile import Profile  # noqa",
            "from .project import Project, IsFQNResource, PartialProject  # noqa",
            "from .runtime import RuntimeConfig  # noqa"
        ],
        "action": [
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "2": []
        },
        "addLocation": []
    },
    "core/dbt/config/profile.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from dbt.clients.system import load_file_contents"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from dbt.clients.yaml_helper import load_yaml_text"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from dbt.contracts.connection import Credentials, HasCredentials"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from dbt.contracts.project import ProfileConfig, UserConfig"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from dbt.contracts.project import ProfileConfig"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from dbt.exceptions import ("
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     CompilationError,"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     DbtProfileError,"
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " )"
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from dbt.events.types import MissingProfileTarget"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from dbt.events.functions import fire_event"
            },
            "11": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from dbt.utils import coerce_dict_str"
            },
            "12": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from .renderer import ProfileRenderer"
            },
            "14": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     return {}"
            },
            "16": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def read_user_config(directory: str) -> UserConfig:"
            },
            "19": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    try:"
            },
            "20": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        profile = read_profile(directory)"
            },
            "21": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if profile:"
            },
            "22": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config = coerce_dict_str(profile.get(\"config\", {}))"
            },
            "23": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if user_config is not None:"
            },
            "24": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                UserConfig.validate(user_config)"
            },
            "25": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return UserConfig.from_dict(user_config)"
            },
            "26": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except (DbtRuntimeError, ValidationError):"
            },
            "27": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "28": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return UserConfig()"
            },
            "29": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "30": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " # The Profile class is included in RuntimeConfig, so any attribute"
            },
            "32": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " # additions must also be set where the RuntimeConfig class is created"
            },
            "33": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " # `init=False` is a workaround for https://bugs.python.org/issue45081"
            },
            "34": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " @dataclass(init=False)"
            },
            "35": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " class Profile(HasCredentials):"
            },
            "36": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     profile_name: str"
            },
            "37": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     target_name: str"
            },
            "38": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    user_config: UserConfig"
            },
            "39": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     threads: int"
            },
            "40": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     credentials: Credentials"
            },
            "41": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     profile_env_vars: Dict[str, Any]"
            },
            "42": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         self,"
            },
            "43": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         profile_name: str,"
            },
            "44": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         target_name: str,"
            },
            "45": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_config: UserConfig,"
            },
            "46": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         threads: int,"
            },
            "47": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         credentials: Credentials,"
            },
            "48": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     ) -> None:"
            },
            "49": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         \"\"\""
            },
            "50": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         self.profile_name = profile_name"
            },
            "51": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         self.target_name = target_name"
            },
            "52": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.user_config = user_config"
            },
            "53": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         self.threads = threads"
            },
            "54": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         self.credentials = credentials"
            },
            "55": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         self.profile_env_vars = {}  # never available on init"
            },
            "56": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         result = {"
            },
            "57": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "             \"profile_name\": self.profile_name,"
            },
            "58": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             \"target_name\": self.target_name,"
            },
            "59": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            \"user_config\": self.user_config,"
            },
            "60": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "             \"threads\": self.threads,"
            },
            "61": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             \"credentials\": self.credentials,"
            },
            "62": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         }"
            },
            "63": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         if serialize_credentials:"
            },
            "64": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result[\"user_config\"] = self.user_config.to_dict(omit_none=True)"
            },
            "65": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             result[\"credentials\"] = self.credentials.to_dict(omit_none=True)"
            },
            "66": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         return result"
            },
            "67": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "68": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "                 \"name\": self.target_name,"
            },
            "69": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "                 \"target_name\": self.target_name,"
            },
            "70": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "                 \"profile_name\": self.profile_name,"
            },
            "71": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"config\": self.user_config.to_dict(omit_none=True),"
            },
            "72": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             }"
            },
            "73": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         )"
            },
            "74": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         return target"
            },
            "75": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         threads: int,"
            },
            "76": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "         profile_name: str,"
            },
            "77": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "         target_name: str,"
            },
            "78": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_config: Optional[Dict[str, Any]] = None,"
            },
            "79": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "     ) -> \"Profile\":"
            },
            "80": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         \"\"\"Create a profile from an existing set of Credentials and the"
            },
            "81": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         remaining information."
            },
            "82": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         :param threads: The number of threads to use for connections."
            },
            "83": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         :param profile_name: The profile name used for this profile."
            },
            "84": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "         :param target_name: The target name used for this profile."
            },
            "85": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param user_config: The user-level config block from the"
            },
            "86": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raw profiles, if specified."
            },
            "87": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         :raises DbtProfileError: If the profile is invalid."
            },
            "88": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         :returns: The new Profile object."
            },
            "89": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         \"\"\""
            },
            "90": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if user_config is None:"
            },
            "91": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config = {}"
            },
            "92": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        UserConfig.validate(user_config)"
            },
            "93": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_config_obj: UserConfig = UserConfig.from_dict(user_config)"
            },
            "94": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         profile = cls("
            },
            "96": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "             profile_name=profile_name,"
            },
            "97": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "             target_name=target_name,"
            },
            "98": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config=user_config_obj,"
            },
            "99": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             threads=threads,"
            },
            "100": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             credentials=credentials,"
            },
            "101": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "         )"
            },
            "102": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "         raw_profile: Dict[str, Any],"
            },
            "103": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         profile_name: str,"
            },
            "104": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "         renderer: ProfileRenderer,"
            },
            "105": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_config: Optional[Dict[str, Any]] = None,"
            },
            "106": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         target_override: Optional[str] = None,"
            },
            "107": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         threads_override: Optional[int] = None,"
            },
            "108": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "     ) -> \"Profile\":"
            },
            "109": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "             disk as yaml and its values rendered with jinja."
            },
            "110": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         :param profile_name: The profile name used."
            },
            "111": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         :param renderer: The config renderer."
            },
            "112": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param user_config: The global config for the user, if it"
            },
            "113": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            was present."
            },
            "114": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         :param target_override: The target to use, if provided on"
            },
            "115": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "             the command line."
            },
            "116": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         :param threads_override: The thread count to use, if"
            },
            "117": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "             target could not be found"
            },
            "118": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         :returns: The new Profile object."
            },
            "119": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "         \"\"\""
            },
            "120": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # user_config is not rendered."
            },
            "121": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if user_config is None:"
            },
            "122": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config = raw_profile.get(\"config\")"
            },
            "123": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "         # TODO: should it be, and the values coerced to bool?"
            },
            "124": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         target_name, profile_data = cls.render_profile("
            },
            "125": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             raw_profile, profile_name, target_override, renderer"
            },
            "126": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "             profile_name=profile_name,"
            },
            "127": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 328,
                "PatchRowcode": "             target_name=target_name,"
            },
            "128": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "             threads=threads,"
            },
            "129": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config=user_config,"
            },
            "130": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         )"
            },
            "131": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 331,
                "PatchRowcode": " "
            },
            "132": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "     @classmethod"
            },
            "133": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "         if not raw_profile:"
            },
            "134": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "             msg = f\"Profile {profile_name} in profiles.yml is empty\""
            },
            "135": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "             raise DbtProfileError(INVALID_PROFILE_MESSAGE.format(error_string=msg))"
            },
            "136": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_config = raw_profiles.get(\"config\")"
            },
            "137": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 364,
                "PatchRowcode": " "
            },
            "138": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "         return cls.from_raw_profile_info("
            },
            "139": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "             raw_profile=raw_profile,"
            },
            "140": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "             profile_name=profile_name,"
            },
            "141": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "             renderer=renderer,"
            },
            "142": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_config=user_config,"
            },
            "143": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "             target_override=target_override,"
            },
            "144": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "             threads_override=threads_override,"
            },
            "145": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "from dataclasses import dataclass",
            "from typing import Any, Dict, Optional, Tuple",
            "import os",
            "",
            "from dbt.dataclass_schema import ValidationError",
            "",
            "from dbt.flags import get_flags",
            "from dbt.clients.system import load_file_contents",
            "from dbt.clients.yaml_helper import load_yaml_text",
            "from dbt.contracts.connection import Credentials, HasCredentials",
            "from dbt.contracts.project import ProfileConfig, UserConfig",
            "from dbt.exceptions import (",
            "    CompilationError,",
            "    DbtProfileError,",
            "    DbtProjectError,",
            "    DbtValidationError,",
            "    DbtRuntimeError,",
            "    ProfileConfigError,",
            ")",
            "from dbt.events.types import MissingProfileTarget",
            "from dbt.events.functions import fire_event",
            "from dbt.utils import coerce_dict_str",
            "",
            "from .renderer import ProfileRenderer",
            "",
            "DEFAULT_THREADS = 1",
            "",
            "INVALID_PROFILE_MESSAGE = \"\"\"",
            "dbt encountered an error while trying to read your profiles.yml file.",
            "",
            "{error_string}",
            "\"\"\"",
            "",
            "",
            "def read_profile(profiles_dir: str) -> Dict[str, Any]:",
            "    path = os.path.join(profiles_dir, \"profiles.yml\")",
            "",
            "    contents = None",
            "    if os.path.isfile(path):",
            "        try:",
            "            contents = load_file_contents(path, strip=False)",
            "            yaml_content = load_yaml_text(contents)",
            "            if not yaml_content:",
            "                msg = f\"The profiles.yml file at {path} is empty\"",
            "                raise DbtProfileError(INVALID_PROFILE_MESSAGE.format(error_string=msg))",
            "            return yaml_content",
            "        except DbtValidationError as e:",
            "            msg = INVALID_PROFILE_MESSAGE.format(error_string=e)",
            "            raise DbtValidationError(msg) from e",
            "",
            "    return {}",
            "",
            "",
            "def read_user_config(directory: str) -> UserConfig:",
            "    try:",
            "        profile = read_profile(directory)",
            "        if profile:",
            "            user_config = coerce_dict_str(profile.get(\"config\", {}))",
            "            if user_config is not None:",
            "                UserConfig.validate(user_config)",
            "                return UserConfig.from_dict(user_config)",
            "    except (DbtRuntimeError, ValidationError):",
            "        pass",
            "    return UserConfig()",
            "",
            "",
            "# The Profile class is included in RuntimeConfig, so any attribute",
            "# additions must also be set where the RuntimeConfig class is created",
            "# `init=False` is a workaround for https://bugs.python.org/issue45081",
            "@dataclass(init=False)",
            "class Profile(HasCredentials):",
            "    profile_name: str",
            "    target_name: str",
            "    user_config: UserConfig",
            "    threads: int",
            "    credentials: Credentials",
            "    profile_env_vars: Dict[str, Any]",
            "",
            "    def __init__(",
            "        self,",
            "        profile_name: str,",
            "        target_name: str,",
            "        user_config: UserConfig,",
            "        threads: int,",
            "        credentials: Credentials,",
            "    ) -> None:",
            "        \"\"\"Explicitly defining `__init__` to work around bug in Python 3.9.7",
            "        https://bugs.python.org/issue45081",
            "        \"\"\"",
            "        self.profile_name = profile_name",
            "        self.target_name = target_name",
            "        self.user_config = user_config",
            "        self.threads = threads",
            "        self.credentials = credentials",
            "        self.profile_env_vars = {}  # never available on init",
            "",
            "    def to_profile_info(self, serialize_credentials: bool = False) -> Dict[str, Any]:",
            "        \"\"\"Unlike to_project_config, this dict is not a mirror of any existing",
            "        on-disk data structure. It's used when creating a new profile from an",
            "        existing one.",
            "",
            "        :param serialize_credentials bool: If True, serialize the credentials.",
            "            Otherwise, the Credentials object will be copied.",
            "        :returns dict: The serialized profile.",
            "        \"\"\"",
            "        result = {",
            "            \"profile_name\": self.profile_name,",
            "            \"target_name\": self.target_name,",
            "            \"user_config\": self.user_config,",
            "            \"threads\": self.threads,",
            "            \"credentials\": self.credentials,",
            "        }",
            "        if serialize_credentials:",
            "            result[\"user_config\"] = self.user_config.to_dict(omit_none=True)",
            "            result[\"credentials\"] = self.credentials.to_dict(omit_none=True)",
            "        return result",
            "",
            "    def to_target_dict(self) -> Dict[str, Any]:",
            "        target = dict(self.credentials.connection_info(with_aliases=True))",
            "        target.update(",
            "            {",
            "                \"type\": self.credentials.type,",
            "                \"threads\": self.threads,",
            "                \"name\": self.target_name,",
            "                \"target_name\": self.target_name,",
            "                \"profile_name\": self.profile_name,",
            "                \"config\": self.user_config.to_dict(omit_none=True),",
            "            }",
            "        )",
            "        return target",
            "",
            "    def __eq__(self, other: object) -> bool:",
            "        if not (isinstance(other, self.__class__) and isinstance(self, other.__class__)):",
            "            return NotImplemented",
            "        return self.to_profile_info() == other.to_profile_info()",
            "",
            "    def validate(self):",
            "        try:",
            "            if self.credentials:",
            "                dct = self.credentials.to_dict(omit_none=True)",
            "                self.credentials.validate(dct)",
            "            dct = self.to_profile_info(serialize_credentials=True)",
            "            ProfileConfig.validate(dct)",
            "        except ValidationError as exc:",
            "            raise ProfileConfigError(exc) from exc",
            "",
            "    @staticmethod",
            "    def _credentials_from_profile(",
            "        profile: Dict[str, Any], profile_name: str, target_name: str",
            "    ) -> Credentials:",
            "        # avoid an import cycle",
            "        from dbt.adapters.factory import load_plugin",
            "",
            "        # credentials carry their 'type' in their actual type, not their",
            "        # attributes. We do want this in order to pick our Credentials class.",
            "        if \"type\" not in profile:",
            "            raise DbtProfileError(",
            "                'required field \"type\" not found in profile {} and target {}'.format(",
            "                    profile_name, target_name",
            "                )",
            "            )",
            "",
            "        typename = profile.pop(\"type\")",
            "        try:",
            "            cls = load_plugin(typename)",
            "            data = cls.translate_aliases(profile)",
            "            cls.validate(data)",
            "            credentials = cls.from_dict(data)",
            "        except (DbtRuntimeError, ValidationError) as e:",
            "            msg = str(e) if isinstance(e, DbtRuntimeError) else e.message",
            "            raise DbtProfileError(",
            "                'Credentials in profile \"{}\", target \"{}\" invalid: {}'.format(",
            "                    profile_name, target_name, msg",
            "                )",
            "            ) from e",
            "",
            "        return credentials",
            "",
            "    @staticmethod",
            "    def pick_profile_name(",
            "        args_profile_name: Optional[str],",
            "        project_profile_name: Optional[str] = None,",
            "    ) -> str:",
            "        # TODO: Duplicating this method as direct copy of the implementation in dbt.cli.resolvers",
            "        # dbt.cli.resolvers implementation can't be used because it causes a circular dependency.",
            "        # This should be removed and use a safe default access on the Flags module when",
            "        # https://github.com/dbt-labs/dbt-core/issues/6259 is closed.",
            "        def default_profiles_dir():",
            "            from pathlib import Path",
            "",
            "            return Path.cwd() if (Path.cwd() / \"profiles.yml\").exists() else Path.home() / \".dbt\"",
            "",
            "        profile_name = project_profile_name",
            "        if args_profile_name is not None:",
            "            profile_name = args_profile_name",
            "        if profile_name is None:",
            "            NO_SUPPLIED_PROFILE_ERROR = \"\"\"\\",
            "dbt cannot run because no profile was specified for this dbt project.",
            "To specify a profile for this project, add a line like the this to",
            "your dbt_project.yml file:",
            "",
            "profile: [profile name]",
            "",
            "Here, [profile name] should be replaced with a profile name",
            "defined in your profiles.yml file. You can find profiles.yml here:",
            "",
            "{profiles_file}/profiles.yml",
            "\"\"\".format(",
            "                profiles_file=default_profiles_dir()",
            "            )",
            "            raise DbtProjectError(NO_SUPPLIED_PROFILE_ERROR)",
            "        return profile_name",
            "",
            "    @staticmethod",
            "    def _get_profile_data(",
            "        profile: Dict[str, Any], profile_name: str, target_name: str",
            "    ) -> Dict[str, Any]:",
            "        if \"outputs\" not in profile:",
            "            raise DbtProfileError(\"outputs not specified in profile '{}'\".format(profile_name))",
            "        outputs = profile[\"outputs\"]",
            "",
            "        if target_name not in outputs:",
            "            outputs = \"\\n\".join(\" - {}\".format(output) for output in outputs)",
            "            msg = (",
            "                \"The profile '{}' does not have a target named '{}'. The \"",
            "                \"valid target names for this profile are:\\n{}\".format(",
            "                    profile_name, target_name, outputs",
            "                )",
            "            )",
            "            raise DbtProfileError(msg, result_type=\"invalid_target\")",
            "        profile_data = outputs[target_name]",
            "",
            "        if not isinstance(profile_data, dict):",
            "            msg = (",
            "                f\"output '{target_name}' of profile '{profile_name}' is \"",
            "                f\"misconfigured in profiles.yml\"",
            "            )",
            "            raise DbtProfileError(msg, result_type=\"invalid_target\")",
            "",
            "        return profile_data",
            "",
            "    @classmethod",
            "    def from_credentials(",
            "        cls,",
            "        credentials: Credentials,",
            "        threads: int,",
            "        profile_name: str,",
            "        target_name: str,",
            "        user_config: Optional[Dict[str, Any]] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"Create a profile from an existing set of Credentials and the",
            "        remaining information.",
            "",
            "        :param credentials: The credentials dict for this profile.",
            "        :param threads: The number of threads to use for connections.",
            "        :param profile_name: The profile name used for this profile.",
            "        :param target_name: The target name used for this profile.",
            "        :param user_config: The user-level config block from the",
            "            raw profiles, if specified.",
            "        :raises DbtProfileError: If the profile is invalid.",
            "        :returns: The new Profile object.",
            "        \"\"\"",
            "        if user_config is None:",
            "            user_config = {}",
            "        UserConfig.validate(user_config)",
            "        user_config_obj: UserConfig = UserConfig.from_dict(user_config)",
            "",
            "        profile = cls(",
            "            profile_name=profile_name,",
            "            target_name=target_name,",
            "            user_config=user_config_obj,",
            "            threads=threads,",
            "            credentials=credentials,",
            "        )",
            "        profile.validate()",
            "        return profile",
            "",
            "    @classmethod",
            "    def render_profile(",
            "        cls,",
            "        raw_profile: Dict[str, Any],",
            "        profile_name: str,",
            "        target_override: Optional[str],",
            "        renderer: ProfileRenderer,",
            "    ) -> Tuple[str, Dict[str, Any]]:",
            "        \"\"\"This is a containment zone for the hateful way we're rendering",
            "        profiles.",
            "        \"\"\"",
            "        # rendering profiles is a bit complex. Two constraints cause trouble:",
            "        # 1) users should be able to use environment/cli variables to specify",
            "        #    the target in their profile.",
            "        # 2) Missing environment/cli variables in profiles/targets that don't",
            "        #    end up getting selected should not cause errors.",
            "        # so first we'll just render the target name, then we use that rendered",
            "        # name to extract a profile that we can render.",
            "        if target_override is not None:",
            "            target_name = target_override",
            "        elif \"target\" in raw_profile:",
            "            # render the target if it was parsed from yaml",
            "            target_name = renderer.render_value(raw_profile[\"target\"])",
            "        else:",
            "            target_name = \"default\"",
            "            fire_event(MissingProfileTarget(profile_name=profile_name, target_name=target_name))",
            "",
            "        raw_profile_data = cls._get_profile_data(raw_profile, profile_name, target_name)",
            "",
            "        try:",
            "            profile_data = renderer.render_data(raw_profile_data)",
            "        except CompilationError as exc:",
            "            raise DbtProfileError(str(exc)) from exc",
            "        return target_name, profile_data",
            "",
            "    @classmethod",
            "    def from_raw_profile_info(",
            "        cls,",
            "        raw_profile: Dict[str, Any],",
            "        profile_name: str,",
            "        renderer: ProfileRenderer,",
            "        user_config: Optional[Dict[str, Any]] = None,",
            "        target_override: Optional[str] = None,",
            "        threads_override: Optional[int] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"Create a profile from its raw profile information.",
            "",
            "         (this is an intermediate step, mostly useful for unit testing)",
            "",
            "        :param raw_profile: The profile data for a single profile, from",
            "            disk as yaml and its values rendered with jinja.",
            "        :param profile_name: The profile name used.",
            "        :param renderer: The config renderer.",
            "        :param user_config: The global config for the user, if it",
            "            was present.",
            "        :param target_override: The target to use, if provided on",
            "            the command line.",
            "        :param threads_override: The thread count to use, if",
            "            provided on the command line.",
            "        :raises DbtProfileError: If the profile is invalid or missing, or the",
            "            target could not be found",
            "        :returns: The new Profile object.",
            "        \"\"\"",
            "        # user_config is not rendered.",
            "        if user_config is None:",
            "            user_config = raw_profile.get(\"config\")",
            "        # TODO: should it be, and the values coerced to bool?",
            "        target_name, profile_data = cls.render_profile(",
            "            raw_profile, profile_name, target_override, renderer",
            "        )",
            "",
            "        # valid connections never include the number of threads, but it's",
            "        # stored on a per-connection level in the raw configs",
            "        threads = profile_data.pop(\"threads\", DEFAULT_THREADS)",
            "        if threads_override is not None:",
            "            threads = threads_override",
            "",
            "        credentials: Credentials = cls._credentials_from_profile(",
            "            profile_data, profile_name, target_name",
            "        )",
            "",
            "        return cls.from_credentials(",
            "            credentials=credentials,",
            "            profile_name=profile_name,",
            "            target_name=target_name,",
            "            threads=threads,",
            "            user_config=user_config,",
            "        )",
            "",
            "    @classmethod",
            "    def from_raw_profiles(",
            "        cls,",
            "        raw_profiles: Dict[str, Any],",
            "        profile_name: str,",
            "        renderer: ProfileRenderer,",
            "        target_override: Optional[str] = None,",
            "        threads_override: Optional[int] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"",
            "        :param raw_profiles: The profile data, from disk as yaml.",
            "        :param profile_name: The profile name to use.",
            "        :param renderer: The config renderer.",
            "        :param target_override: The target to use, if provided on the command",
            "            line.",
            "        :param threads_override: The thread count to use, if provided on the",
            "            command line.",
            "        :raises DbtProjectError: If there is no profile name specified in the",
            "            project or the command line arguments",
            "        :raises DbtProfileError: If the profile is invalid or missing, or the",
            "            target could not be found",
            "        :returns: The new Profile object.",
            "        \"\"\"",
            "        if profile_name not in raw_profiles:",
            "            raise DbtProjectError(\"Could not find profile named '{}'\".format(profile_name))",
            "",
            "        # First, we've already got our final decision on profile name, and we",
            "        # don't render keys, so we can pluck that out",
            "        raw_profile = raw_profiles[profile_name]",
            "        if not raw_profile:",
            "            msg = f\"Profile {profile_name} in profiles.yml is empty\"",
            "            raise DbtProfileError(INVALID_PROFILE_MESSAGE.format(error_string=msg))",
            "        user_config = raw_profiles.get(\"config\")",
            "",
            "        return cls.from_raw_profile_info(",
            "            raw_profile=raw_profile,",
            "            profile_name=profile_name,",
            "            renderer=renderer,",
            "            user_config=user_config,",
            "            target_override=target_override,",
            "            threads_override=threads_override,",
            "        )",
            "",
            "    @classmethod",
            "    def render(",
            "        cls,",
            "        renderer: ProfileRenderer,",
            "        project_profile_name: Optional[str],",
            "        profile_name_override: Optional[str] = None,",
            "        target_override: Optional[str] = None,",
            "        threads_override: Optional[int] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"Given the raw profiles as read from disk and the name of the desired",
            "        profile if specified, return the profile component of the runtime",
            "        config.",
            "",
            "        :param args argparse.Namespace: The arguments as parsed from the cli.",
            "        :param project_profile_name Optional[str]: The profile name, if",
            "            specified in a project.",
            "        :raises DbtProjectError: If there is no profile name specified in the",
            "            project or the command line arguments, or if the specified profile",
            "            is not found",
            "        :raises DbtProfileError: If the profile is invalid or missing, or the",
            "            target could not be found.",
            "        :returns Profile: The new Profile object.",
            "        \"\"\"",
            "        flags = get_flags()",
            "        raw_profiles = read_profile(flags.PROFILES_DIR)",
            "        profile_name = cls.pick_profile_name(profile_name_override, project_profile_name)",
            "        return cls.from_raw_profiles(",
            "            raw_profiles=raw_profiles,",
            "            profile_name=profile_name,",
            "            renderer=renderer,",
            "            target_override=target_override,",
            "            threads_override=threads_override,",
            "        )"
        ],
        "afterPatchFile": [
            "from dataclasses import dataclass",
            "from typing import Any, Dict, Optional, Tuple",
            "import os",
            "",
            "from dbt.dataclass_schema import ValidationError",
            "",
            "from dbt.flags import get_flags",
            "from dbt.clients.system import load_file_contents",
            "from dbt.clients.yaml_helper import load_yaml_text",
            "from dbt.contracts.connection import Credentials, HasCredentials",
            "from dbt.contracts.project import ProfileConfig",
            "from dbt.exceptions import (",
            "    CompilationError,",
            "    DbtProfileError,",
            "    DbtProjectError,",
            "    DbtValidationError,",
            "    DbtRuntimeError,",
            "    ProfileConfigError,",
            ")",
            "from dbt.events.types import MissingProfileTarget",
            "from dbt.events.functions import fire_event",
            "",
            "from .renderer import ProfileRenderer",
            "",
            "DEFAULT_THREADS = 1",
            "",
            "INVALID_PROFILE_MESSAGE = \"\"\"",
            "dbt encountered an error while trying to read your profiles.yml file.",
            "",
            "{error_string}",
            "\"\"\"",
            "",
            "",
            "def read_profile(profiles_dir: str) -> Dict[str, Any]:",
            "    path = os.path.join(profiles_dir, \"profiles.yml\")",
            "",
            "    contents = None",
            "    if os.path.isfile(path):",
            "        try:",
            "            contents = load_file_contents(path, strip=False)",
            "            yaml_content = load_yaml_text(contents)",
            "            if not yaml_content:",
            "                msg = f\"The profiles.yml file at {path} is empty\"",
            "                raise DbtProfileError(INVALID_PROFILE_MESSAGE.format(error_string=msg))",
            "            return yaml_content",
            "        except DbtValidationError as e:",
            "            msg = INVALID_PROFILE_MESSAGE.format(error_string=e)",
            "            raise DbtValidationError(msg) from e",
            "",
            "    return {}",
            "",
            "",
            "# The Profile class is included in RuntimeConfig, so any attribute",
            "# additions must also be set where the RuntimeConfig class is created",
            "# `init=False` is a workaround for https://bugs.python.org/issue45081",
            "@dataclass(init=False)",
            "class Profile(HasCredentials):",
            "    profile_name: str",
            "    target_name: str",
            "    threads: int",
            "    credentials: Credentials",
            "    profile_env_vars: Dict[str, Any]",
            "",
            "    def __init__(",
            "        self,",
            "        profile_name: str,",
            "        target_name: str,",
            "        threads: int,",
            "        credentials: Credentials,",
            "    ) -> None:",
            "        \"\"\"Explicitly defining `__init__` to work around bug in Python 3.9.7",
            "        https://bugs.python.org/issue45081",
            "        \"\"\"",
            "        self.profile_name = profile_name",
            "        self.target_name = target_name",
            "        self.threads = threads",
            "        self.credentials = credentials",
            "        self.profile_env_vars = {}  # never available on init",
            "",
            "    def to_profile_info(self, serialize_credentials: bool = False) -> Dict[str, Any]:",
            "        \"\"\"Unlike to_project_config, this dict is not a mirror of any existing",
            "        on-disk data structure. It's used when creating a new profile from an",
            "        existing one.",
            "",
            "        :param serialize_credentials bool: If True, serialize the credentials.",
            "            Otherwise, the Credentials object will be copied.",
            "        :returns dict: The serialized profile.",
            "        \"\"\"",
            "        result = {",
            "            \"profile_name\": self.profile_name,",
            "            \"target_name\": self.target_name,",
            "            \"threads\": self.threads,",
            "            \"credentials\": self.credentials,",
            "        }",
            "        if serialize_credentials:",
            "            result[\"credentials\"] = self.credentials.to_dict(omit_none=True)",
            "        return result",
            "",
            "    def to_target_dict(self) -> Dict[str, Any]:",
            "        target = dict(self.credentials.connection_info(with_aliases=True))",
            "        target.update(",
            "            {",
            "                \"type\": self.credentials.type,",
            "                \"threads\": self.threads,",
            "                \"name\": self.target_name,",
            "                \"target_name\": self.target_name,",
            "                \"profile_name\": self.profile_name,",
            "            }",
            "        )",
            "        return target",
            "",
            "    def __eq__(self, other: object) -> bool:",
            "        if not (isinstance(other, self.__class__) and isinstance(self, other.__class__)):",
            "            return NotImplemented",
            "        return self.to_profile_info() == other.to_profile_info()",
            "",
            "    def validate(self):",
            "        try:",
            "            if self.credentials:",
            "                dct = self.credentials.to_dict(omit_none=True)",
            "                self.credentials.validate(dct)",
            "            dct = self.to_profile_info(serialize_credentials=True)",
            "            ProfileConfig.validate(dct)",
            "        except ValidationError as exc:",
            "            raise ProfileConfigError(exc) from exc",
            "",
            "    @staticmethod",
            "    def _credentials_from_profile(",
            "        profile: Dict[str, Any], profile_name: str, target_name: str",
            "    ) -> Credentials:",
            "        # avoid an import cycle",
            "        from dbt.adapters.factory import load_plugin",
            "",
            "        # credentials carry their 'type' in their actual type, not their",
            "        # attributes. We do want this in order to pick our Credentials class.",
            "        if \"type\" not in profile:",
            "            raise DbtProfileError(",
            "                'required field \"type\" not found in profile {} and target {}'.format(",
            "                    profile_name, target_name",
            "                )",
            "            )",
            "",
            "        typename = profile.pop(\"type\")",
            "        try:",
            "            cls = load_plugin(typename)",
            "            data = cls.translate_aliases(profile)",
            "            cls.validate(data)",
            "            credentials = cls.from_dict(data)",
            "        except (DbtRuntimeError, ValidationError) as e:",
            "            msg = str(e) if isinstance(e, DbtRuntimeError) else e.message",
            "            raise DbtProfileError(",
            "                'Credentials in profile \"{}\", target \"{}\" invalid: {}'.format(",
            "                    profile_name, target_name, msg",
            "                )",
            "            ) from e",
            "",
            "        return credentials",
            "",
            "    @staticmethod",
            "    def pick_profile_name(",
            "        args_profile_name: Optional[str],",
            "        project_profile_name: Optional[str] = None,",
            "    ) -> str:",
            "        # TODO: Duplicating this method as direct copy of the implementation in dbt.cli.resolvers",
            "        # dbt.cli.resolvers implementation can't be used because it causes a circular dependency.",
            "        # This should be removed and use a safe default access on the Flags module when",
            "        # https://github.com/dbt-labs/dbt-core/issues/6259 is closed.",
            "        def default_profiles_dir():",
            "            from pathlib import Path",
            "",
            "            return Path.cwd() if (Path.cwd() / \"profiles.yml\").exists() else Path.home() / \".dbt\"",
            "",
            "        profile_name = project_profile_name",
            "        if args_profile_name is not None:",
            "            profile_name = args_profile_name",
            "        if profile_name is None:",
            "            NO_SUPPLIED_PROFILE_ERROR = \"\"\"\\",
            "dbt cannot run because no profile was specified for this dbt project.",
            "To specify a profile for this project, add a line like the this to",
            "your dbt_project.yml file:",
            "",
            "profile: [profile name]",
            "",
            "Here, [profile name] should be replaced with a profile name",
            "defined in your profiles.yml file. You can find profiles.yml here:",
            "",
            "{profiles_file}/profiles.yml",
            "\"\"\".format(",
            "                profiles_file=default_profiles_dir()",
            "            )",
            "            raise DbtProjectError(NO_SUPPLIED_PROFILE_ERROR)",
            "        return profile_name",
            "",
            "    @staticmethod",
            "    def _get_profile_data(",
            "        profile: Dict[str, Any], profile_name: str, target_name: str",
            "    ) -> Dict[str, Any]:",
            "        if \"outputs\" not in profile:",
            "            raise DbtProfileError(\"outputs not specified in profile '{}'\".format(profile_name))",
            "        outputs = profile[\"outputs\"]",
            "",
            "        if target_name not in outputs:",
            "            outputs = \"\\n\".join(\" - {}\".format(output) for output in outputs)",
            "            msg = (",
            "                \"The profile '{}' does not have a target named '{}'. The \"",
            "                \"valid target names for this profile are:\\n{}\".format(",
            "                    profile_name, target_name, outputs",
            "                )",
            "            )",
            "            raise DbtProfileError(msg, result_type=\"invalid_target\")",
            "        profile_data = outputs[target_name]",
            "",
            "        if not isinstance(profile_data, dict):",
            "            msg = (",
            "                f\"output '{target_name}' of profile '{profile_name}' is \"",
            "                f\"misconfigured in profiles.yml\"",
            "            )",
            "            raise DbtProfileError(msg, result_type=\"invalid_target\")",
            "",
            "        return profile_data",
            "",
            "    @classmethod",
            "    def from_credentials(",
            "        cls,",
            "        credentials: Credentials,",
            "        threads: int,",
            "        profile_name: str,",
            "        target_name: str,",
            "    ) -> \"Profile\":",
            "        \"\"\"Create a profile from an existing set of Credentials and the",
            "        remaining information.",
            "",
            "        :param credentials: The credentials dict for this profile.",
            "        :param threads: The number of threads to use for connections.",
            "        :param profile_name: The profile name used for this profile.",
            "        :param target_name: The target name used for this profile.",
            "        :raises DbtProfileError: If the profile is invalid.",
            "        :returns: The new Profile object.",
            "        \"\"\"",
            "",
            "        profile = cls(",
            "            profile_name=profile_name,",
            "            target_name=target_name,",
            "            threads=threads,",
            "            credentials=credentials,",
            "        )",
            "        profile.validate()",
            "        return profile",
            "",
            "    @classmethod",
            "    def render_profile(",
            "        cls,",
            "        raw_profile: Dict[str, Any],",
            "        profile_name: str,",
            "        target_override: Optional[str],",
            "        renderer: ProfileRenderer,",
            "    ) -> Tuple[str, Dict[str, Any]]:",
            "        \"\"\"This is a containment zone for the hateful way we're rendering",
            "        profiles.",
            "        \"\"\"",
            "        # rendering profiles is a bit complex. Two constraints cause trouble:",
            "        # 1) users should be able to use environment/cli variables to specify",
            "        #    the target in their profile.",
            "        # 2) Missing environment/cli variables in profiles/targets that don't",
            "        #    end up getting selected should not cause errors.",
            "        # so first we'll just render the target name, then we use that rendered",
            "        # name to extract a profile that we can render.",
            "        if target_override is not None:",
            "            target_name = target_override",
            "        elif \"target\" in raw_profile:",
            "            # render the target if it was parsed from yaml",
            "            target_name = renderer.render_value(raw_profile[\"target\"])",
            "        else:",
            "            target_name = \"default\"",
            "            fire_event(MissingProfileTarget(profile_name=profile_name, target_name=target_name))",
            "",
            "        raw_profile_data = cls._get_profile_data(raw_profile, profile_name, target_name)",
            "",
            "        try:",
            "            profile_data = renderer.render_data(raw_profile_data)",
            "        except CompilationError as exc:",
            "            raise DbtProfileError(str(exc)) from exc",
            "        return target_name, profile_data",
            "",
            "    @classmethod",
            "    def from_raw_profile_info(",
            "        cls,",
            "        raw_profile: Dict[str, Any],",
            "        profile_name: str,",
            "        renderer: ProfileRenderer,",
            "        target_override: Optional[str] = None,",
            "        threads_override: Optional[int] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"Create a profile from its raw profile information.",
            "",
            "         (this is an intermediate step, mostly useful for unit testing)",
            "",
            "        :param raw_profile: The profile data for a single profile, from",
            "            disk as yaml and its values rendered with jinja.",
            "        :param profile_name: The profile name used.",
            "        :param renderer: The config renderer.",
            "        :param target_override: The target to use, if provided on",
            "            the command line.",
            "        :param threads_override: The thread count to use, if",
            "            provided on the command line.",
            "        :raises DbtProfileError: If the profile is invalid or missing, or the",
            "            target could not be found",
            "        :returns: The new Profile object.",
            "        \"\"\"",
            "        # TODO: should it be, and the values coerced to bool?",
            "        target_name, profile_data = cls.render_profile(",
            "            raw_profile, profile_name, target_override, renderer",
            "        )",
            "",
            "        # valid connections never include the number of threads, but it's",
            "        # stored on a per-connection level in the raw configs",
            "        threads = profile_data.pop(\"threads\", DEFAULT_THREADS)",
            "        if threads_override is not None:",
            "            threads = threads_override",
            "",
            "        credentials: Credentials = cls._credentials_from_profile(",
            "            profile_data, profile_name, target_name",
            "        )",
            "",
            "        return cls.from_credentials(",
            "            credentials=credentials,",
            "            profile_name=profile_name,",
            "            target_name=target_name,",
            "            threads=threads,",
            "        )",
            "",
            "    @classmethod",
            "    def from_raw_profiles(",
            "        cls,",
            "        raw_profiles: Dict[str, Any],",
            "        profile_name: str,",
            "        renderer: ProfileRenderer,",
            "        target_override: Optional[str] = None,",
            "        threads_override: Optional[int] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"",
            "        :param raw_profiles: The profile data, from disk as yaml.",
            "        :param profile_name: The profile name to use.",
            "        :param renderer: The config renderer.",
            "        :param target_override: The target to use, if provided on the command",
            "            line.",
            "        :param threads_override: The thread count to use, if provided on the",
            "            command line.",
            "        :raises DbtProjectError: If there is no profile name specified in the",
            "            project or the command line arguments",
            "        :raises DbtProfileError: If the profile is invalid or missing, or the",
            "            target could not be found",
            "        :returns: The new Profile object.",
            "        \"\"\"",
            "        if profile_name not in raw_profiles:",
            "            raise DbtProjectError(\"Could not find profile named '{}'\".format(profile_name))",
            "",
            "        # First, we've already got our final decision on profile name, and we",
            "        # don't render keys, so we can pluck that out",
            "        raw_profile = raw_profiles[profile_name]",
            "        if not raw_profile:",
            "            msg = f\"Profile {profile_name} in profiles.yml is empty\"",
            "            raise DbtProfileError(INVALID_PROFILE_MESSAGE.format(error_string=msg))",
            "",
            "        return cls.from_raw_profile_info(",
            "            raw_profile=raw_profile,",
            "            profile_name=profile_name,",
            "            renderer=renderer,",
            "            target_override=target_override,",
            "            threads_override=threads_override,",
            "        )",
            "",
            "    @classmethod",
            "    def render(",
            "        cls,",
            "        renderer: ProfileRenderer,",
            "        project_profile_name: Optional[str],",
            "        profile_name_override: Optional[str] = None,",
            "        target_override: Optional[str] = None,",
            "        threads_override: Optional[int] = None,",
            "    ) -> \"Profile\":",
            "        \"\"\"Given the raw profiles as read from disk and the name of the desired",
            "        profile if specified, return the profile component of the runtime",
            "        config.",
            "",
            "        :param args argparse.Namespace: The arguments as parsed from the cli.",
            "        :param project_profile_name Optional[str]: The profile name, if",
            "            specified in a project.",
            "        :raises DbtProjectError: If there is no profile name specified in the",
            "            project or the command line arguments, or if the specified profile",
            "            is not found",
            "        :raises DbtProfileError: If the profile is invalid or missing, or the",
            "            target could not be found.",
            "        :returns Profile: The new Profile object.",
            "        \"\"\"",
            "        flags = get_flags()",
            "        raw_profiles = read_profile(flags.PROFILES_DIR)",
            "        profile_name = cls.pick_profile_name(profile_name_override, project_profile_name)",
            "        return cls.from_raw_profiles(",
            "            raw_profiles=raw_profiles,",
            "            profile_name=profile_name,",
            "            renderer=renderer,",
            "            target_override=target_override,",
            "            threads_override=threads_override,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "22": [],
            "54": [
                "read_user_config"
            ],
            "55": [
                "read_user_config"
            ],
            "56": [
                "read_user_config"
            ],
            "57": [
                "read_user_config"
            ],
            "58": [
                "read_user_config"
            ],
            "59": [
                "read_user_config"
            ],
            "60": [
                "read_user_config"
            ],
            "61": [
                "read_user_config"
            ],
            "62": [
                "read_user_config"
            ],
            "63": [
                "read_user_config"
            ],
            "64": [
                "read_user_config"
            ],
            "65": [],
            "66": [],
            "74": [
                "Profile"
            ],
            "83": [
                "Profile",
                "__init__"
            ],
            "92": [
                "Profile",
                "__init__"
            ],
            "109": [
                "Profile",
                "to_profile_info"
            ],
            "114": [
                "Profile",
                "to_profile_info"
            ],
            "127": [
                "Profile",
                "to_target_dict"
            ],
            "249": [
                "Profile",
                "from_credentials"
            ],
            "258": [
                "Profile",
                "from_credentials"
            ],
            "259": [
                "Profile",
                "from_credentials"
            ],
            "263": [
                "Profile",
                "from_credentials"
            ],
            "264": [
                "Profile",
                "from_credentials"
            ],
            "265": [
                "Profile",
                "from_credentials"
            ],
            "266": [
                "Profile",
                "from_credentials"
            ],
            "271": [
                "Profile",
                "from_credentials"
            ],
            "319": [
                "Profile",
                "from_raw_profile_info"
            ],
            "331": [
                "Profile",
                "from_raw_profile_info"
            ],
            "332": [
                "Profile",
                "from_raw_profile_info"
            ],
            "341": [
                "Profile",
                "from_raw_profile_info"
            ],
            "342": [
                "Profile",
                "from_raw_profile_info"
            ],
            "343": [
                "Profile",
                "from_raw_profile_info"
            ],
            "364": [
                "Profile",
                "from_raw_profile_info"
            ],
            "399": [
                "Profile",
                "from_raw_profiles"
            ],
            "405": [
                "Profile",
                "from_raw_profiles"
            ]
        },
        "addLocation": []
    }
}