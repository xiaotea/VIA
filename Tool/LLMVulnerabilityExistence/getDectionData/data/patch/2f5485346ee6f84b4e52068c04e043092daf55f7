{
    "django/contrib/sessions/backends/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         self.accessed = True"
            },
            "1": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         self.modified = True"
            },
            "2": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    def is_empty(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        \"Returns True when there is no session_key and the session is empty\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        try:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            return not bool(self._session_key) and not self._session_cache"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        except AttributeError:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            return True"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     def _get_new_session_key(self):"
            },
            "11": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "         \"Returns session key that isn't being used.\""
            },
            "12": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         while True:"
            },
            "13": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 275,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         self.clear()"
            },
            "15": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         self.delete()"
            },
            "16": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.create()"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+        self._session_key = None"
            },
            "18": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "     def cycle_key(self):"
            },
            "20": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "from datetime import datetime, timedelta",
            "import logging",
            "import string",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.crypto import get_random_string",
            "from django.utils.crypto import salted_hmac",
            "from django.utils import timezone",
            "from django.utils.encoding import force_bytes, force_text",
            "from django.utils.module_loading import import_string",
            "",
            "from django.contrib.sessions.exceptions import SuspiciousSession",
            "",
            "# session_key should not be case sensitive because some backends can store it",
            "# on case insensitive file systems.",
            "VALID_KEY_CHARS = string.ascii_lowercase + string.digits",
            "",
            "",
            "class CreateError(Exception):",
            "    \"\"\"",
            "    Used internally as a consistent exception type to catch from save (see the",
            "    docstring for SessionBase.save() for details).",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class SessionBase(object):",
            "    \"\"\"",
            "    Base class for all Session classes.",
            "    \"\"\"",
            "    TEST_COOKIE_NAME = 'testcookie'",
            "    TEST_COOKIE_VALUE = 'worked'",
            "",
            "    def __init__(self, session_key=None):",
            "        self._session_key = session_key",
            "        self.accessed = False",
            "        self.modified = False",
            "        self.serializer = import_string(settings.SESSION_SERIALIZER)",
            "",
            "    def __contains__(self, key):",
            "        return key in self._session",
            "",
            "    def __getitem__(self, key):",
            "        return self._session[key]",
            "",
            "    def __setitem__(self, key, value):",
            "        self._session[key] = value",
            "        self.modified = True",
            "",
            "    def __delitem__(self, key):",
            "        del self._session[key]",
            "        self.modified = True",
            "",
            "    def get(self, key, default=None):",
            "        return self._session.get(key, default)",
            "",
            "    def pop(self, key, *args):",
            "        self.modified = self.modified or key in self._session",
            "        return self._session.pop(key, *args)",
            "",
            "    def setdefault(self, key, value):",
            "        if key in self._session:",
            "            return self._session[key]",
            "        else:",
            "            self.modified = True",
            "            self._session[key] = value",
            "            return value",
            "",
            "    def set_test_cookie(self):",
            "        self[self.TEST_COOKIE_NAME] = self.TEST_COOKIE_VALUE",
            "",
            "    def test_cookie_worked(self):",
            "        return self.get(self.TEST_COOKIE_NAME) == self.TEST_COOKIE_VALUE",
            "",
            "    def delete_test_cookie(self):",
            "        del self[self.TEST_COOKIE_NAME]",
            "",
            "    def _hash(self, value):",
            "        key_salt = \"django.contrib.sessions\" + self.__class__.__name__",
            "        return salted_hmac(key_salt, value).hexdigest()",
            "",
            "    def encode(self, session_dict):",
            "        \"Returns the given session dictionary serialized and encoded as a string.\"",
            "        serialized = self.serializer().dumps(session_dict)",
            "        hash = self._hash(serialized)",
            "        return base64.b64encode(hash.encode() + b\":\" + serialized).decode('ascii')",
            "",
            "    def decode(self, session_data):",
            "        encoded_data = base64.b64decode(force_bytes(session_data))",
            "        try:",
            "            # could produce ValueError if there is no ':'",
            "            hash, serialized = encoded_data.split(b':', 1)",
            "            expected_hash = self._hash(serialized)",
            "            if not constant_time_compare(hash.decode(), expected_hash):",
            "                raise SuspiciousSession(\"Session data corrupted\")",
            "            else:",
            "                return self.serializer().loads(serialized)",
            "        except Exception as e:",
            "            # ValueError, SuspiciousOperation, unpickling exceptions. If any of",
            "            # these happen, just return an empty dictionary (an empty session).",
            "            if isinstance(e, SuspiciousOperation):",
            "                logger = logging.getLogger('django.security.%s' %",
            "                        e.__class__.__name__)",
            "                logger.warning(force_text(e))",
            "            return {}",
            "",
            "    def update(self, dict_):",
            "        self._session.update(dict_)",
            "        self.modified = True",
            "",
            "    def has_key(self, key):",
            "        return key in self._session",
            "",
            "    def keys(self):",
            "        return self._session.keys()",
            "",
            "    def values(self):",
            "        return self._session.values()",
            "",
            "    def items(self):",
            "        return self._session.items()",
            "",
            "    def iterkeys(self):",
            "        return self._session.iterkeys()",
            "",
            "    def itervalues(self):",
            "        return self._session.itervalues()",
            "",
            "    def iteritems(self):",
            "        return self._session.iteritems()",
            "",
            "    def clear(self):",
            "        # To avoid unnecessary persistent storage accesses, we set up the",
            "        # internals directly (loading data wastes time, since we are going to",
            "        # set it to an empty dict anyway).",
            "        self._session_cache = {}",
            "        self.accessed = True",
            "        self.modified = True",
            "",
            "    def _get_new_session_key(self):",
            "        \"Returns session key that isn't being used.\"",
            "        while True:",
            "            session_key = get_random_string(32, VALID_KEY_CHARS)",
            "            if not self.exists(session_key):",
            "                break",
            "        return session_key",
            "",
            "    def _get_or_create_session_key(self):",
            "        if self._session_key is None:",
            "            self._session_key = self._get_new_session_key()",
            "        return self._session_key",
            "",
            "    def _get_session_key(self):",
            "        return self._session_key",
            "",
            "    session_key = property(_get_session_key)",
            "",
            "    def _get_session(self, no_load=False):",
            "        \"\"\"",
            "        Lazily loads session from storage (unless \"no_load\" is True, when only",
            "        an empty dict is stored) and stores it in the current instance.",
            "        \"\"\"",
            "        self.accessed = True",
            "        try:",
            "            return self._session_cache",
            "        except AttributeError:",
            "            if self.session_key is None or no_load:",
            "                self._session_cache = {}",
            "            else:",
            "                self._session_cache = self.load()",
            "        return self._session_cache",
            "",
            "    _session = property(_get_session)",
            "",
            "    def get_expiry_age(self, **kwargs):",
            "        \"\"\"Get the number of seconds until the session expires.",
            "",
            "        Optionally, this function accepts `modification` and `expiry` keyword",
            "        arguments specifying the modification and expiry of the session.",
            "        \"\"\"",
            "        try:",
            "            modification = kwargs['modification']",
            "        except KeyError:",
            "            modification = timezone.now()",
            "        # Make the difference between \"expiry=None passed in kwargs\" and",
            "        # \"expiry not passed in kwargs\", in order to guarantee not to trigger",
            "        # self.load() when expiry is provided.",
            "        try:",
            "            expiry = kwargs['expiry']",
            "        except KeyError:",
            "            expiry = self.get('_session_expiry')",
            "",
            "        if not expiry:   # Checks both None and 0 cases",
            "            return settings.SESSION_COOKIE_AGE",
            "        if not isinstance(expiry, datetime):",
            "            return expiry",
            "        delta = expiry - modification",
            "        return delta.days * 86400 + delta.seconds",
            "",
            "    def get_expiry_date(self, **kwargs):",
            "        \"\"\"Get session the expiry date (as a datetime object).",
            "",
            "        Optionally, this function accepts `modification` and `expiry` keyword",
            "        arguments specifying the modification and expiry of the session.",
            "        \"\"\"",
            "        try:",
            "            modification = kwargs['modification']",
            "        except KeyError:",
            "            modification = timezone.now()",
            "        # Same comment as in get_expiry_age",
            "        try:",
            "            expiry = kwargs['expiry']",
            "        except KeyError:",
            "            expiry = self.get('_session_expiry')",
            "",
            "        if isinstance(expiry, datetime):",
            "            return expiry",
            "        if not expiry:   # Checks both None and 0 cases",
            "            expiry = settings.SESSION_COOKIE_AGE",
            "        return modification + timedelta(seconds=expiry)",
            "",
            "    def set_expiry(self, value):",
            "        \"\"\"",
            "        Sets a custom expiration for the session. ``value`` can be an integer,",
            "        a Python ``datetime`` or ``timedelta`` object or ``None``.",
            "",
            "        If ``value`` is an integer, the session will expire after that many",
            "        seconds of inactivity. If set to ``0`` then the session will expire on",
            "        browser close.",
            "",
            "        If ``value`` is a ``datetime`` or ``timedelta`` object, the session",
            "        will expire at that specific future time.",
            "",
            "        If ``value`` is ``None``, the session uses the global session expiry",
            "        policy.",
            "        \"\"\"",
            "        if value is None:",
            "            # Remove any custom expiration for this session.",
            "            try:",
            "                del self['_session_expiry']",
            "            except KeyError:",
            "                pass",
            "            return",
            "        if isinstance(value, timedelta):",
            "            value = timezone.now() + value",
            "        self['_session_expiry'] = value",
            "",
            "    def get_expire_at_browser_close(self):",
            "        \"\"\"",
            "        Returns ``True`` if the session is set to expire when the browser",
            "        closes, and ``False`` if there's an expiry date. Use",
            "        ``get_expiry_date()`` or ``get_expiry_age()`` to find the actual expiry",
            "        date/age, if there is one.",
            "        \"\"\"",
            "        if self.get('_session_expiry') is None:",
            "            return settings.SESSION_EXPIRE_AT_BROWSER_CLOSE",
            "        return self.get('_session_expiry') == 0",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete()",
            "        self.create()",
            "",
            "    def cycle_key(self):",
            "        \"\"\"",
            "        Creates a new session key, whilst retaining the current session data.",
            "        \"\"\"",
            "        data = self._session_cache",
            "        key = self.session_key",
            "        self.create()",
            "        self._session_cache = data",
            "        self.delete(key)",
            "",
            "    # Methods that child classes must implement.",
            "",
            "    def exists(self, session_key):",
            "        \"\"\"",
            "        Returns True if the given session_key already exists.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide an exists() method')",
            "",
            "    def create(self):",
            "        \"\"\"",
            "        Creates a new session instance. Guaranteed to create a new object with",
            "        a unique key and will have saved the result once (with empty data)",
            "        before the method returns.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a create() method')",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the session data. If 'must_create' is True, a new session object",
            "        is created (otherwise a CreateError exception is raised). Otherwise,",
            "        save() can update an existing object with the same key.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a save() method')",
            "",
            "    def delete(self, session_key=None):",
            "        \"\"\"",
            "        Deletes the session data under this key. If the key is None, the",
            "        current session key value is used.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a delete() method')",
            "",
            "    def load(self):",
            "        \"\"\"",
            "        Loads the session data and returns a dictionary.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a load() method')",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        \"\"\"",
            "        Remove expired sessions from the session store.",
            "",
            "        If this operation isn't possible on a given backend, it should raise",
            "        NotImplementedError. If it isn't necessary, because the backend has",
            "        a built-in expiration mechanism, it should be a no-op.",
            "        \"\"\"",
            "        raise NotImplementedError('This backend does not support clear_expired().')"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import base64",
            "from datetime import datetime, timedelta",
            "import logging",
            "import string",
            "",
            "from django.conf import settings",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils.crypto import constant_time_compare",
            "from django.utils.crypto import get_random_string",
            "from django.utils.crypto import salted_hmac",
            "from django.utils import timezone",
            "from django.utils.encoding import force_bytes, force_text",
            "from django.utils.module_loading import import_string",
            "",
            "from django.contrib.sessions.exceptions import SuspiciousSession",
            "",
            "# session_key should not be case sensitive because some backends can store it",
            "# on case insensitive file systems.",
            "VALID_KEY_CHARS = string.ascii_lowercase + string.digits",
            "",
            "",
            "class CreateError(Exception):",
            "    \"\"\"",
            "    Used internally as a consistent exception type to catch from save (see the",
            "    docstring for SessionBase.save() for details).",
            "    \"\"\"",
            "    pass",
            "",
            "",
            "class SessionBase(object):",
            "    \"\"\"",
            "    Base class for all Session classes.",
            "    \"\"\"",
            "    TEST_COOKIE_NAME = 'testcookie'",
            "    TEST_COOKIE_VALUE = 'worked'",
            "",
            "    def __init__(self, session_key=None):",
            "        self._session_key = session_key",
            "        self.accessed = False",
            "        self.modified = False",
            "        self.serializer = import_string(settings.SESSION_SERIALIZER)",
            "",
            "    def __contains__(self, key):",
            "        return key in self._session",
            "",
            "    def __getitem__(self, key):",
            "        return self._session[key]",
            "",
            "    def __setitem__(self, key, value):",
            "        self._session[key] = value",
            "        self.modified = True",
            "",
            "    def __delitem__(self, key):",
            "        del self._session[key]",
            "        self.modified = True",
            "",
            "    def get(self, key, default=None):",
            "        return self._session.get(key, default)",
            "",
            "    def pop(self, key, *args):",
            "        self.modified = self.modified or key in self._session",
            "        return self._session.pop(key, *args)",
            "",
            "    def setdefault(self, key, value):",
            "        if key in self._session:",
            "            return self._session[key]",
            "        else:",
            "            self.modified = True",
            "            self._session[key] = value",
            "            return value",
            "",
            "    def set_test_cookie(self):",
            "        self[self.TEST_COOKIE_NAME] = self.TEST_COOKIE_VALUE",
            "",
            "    def test_cookie_worked(self):",
            "        return self.get(self.TEST_COOKIE_NAME) == self.TEST_COOKIE_VALUE",
            "",
            "    def delete_test_cookie(self):",
            "        del self[self.TEST_COOKIE_NAME]",
            "",
            "    def _hash(self, value):",
            "        key_salt = \"django.contrib.sessions\" + self.__class__.__name__",
            "        return salted_hmac(key_salt, value).hexdigest()",
            "",
            "    def encode(self, session_dict):",
            "        \"Returns the given session dictionary serialized and encoded as a string.\"",
            "        serialized = self.serializer().dumps(session_dict)",
            "        hash = self._hash(serialized)",
            "        return base64.b64encode(hash.encode() + b\":\" + serialized).decode('ascii')",
            "",
            "    def decode(self, session_data):",
            "        encoded_data = base64.b64decode(force_bytes(session_data))",
            "        try:",
            "            # could produce ValueError if there is no ':'",
            "            hash, serialized = encoded_data.split(b':', 1)",
            "            expected_hash = self._hash(serialized)",
            "            if not constant_time_compare(hash.decode(), expected_hash):",
            "                raise SuspiciousSession(\"Session data corrupted\")",
            "            else:",
            "                return self.serializer().loads(serialized)",
            "        except Exception as e:",
            "            # ValueError, SuspiciousOperation, unpickling exceptions. If any of",
            "            # these happen, just return an empty dictionary (an empty session).",
            "            if isinstance(e, SuspiciousOperation):",
            "                logger = logging.getLogger('django.security.%s' %",
            "                        e.__class__.__name__)",
            "                logger.warning(force_text(e))",
            "            return {}",
            "",
            "    def update(self, dict_):",
            "        self._session.update(dict_)",
            "        self.modified = True",
            "",
            "    def has_key(self, key):",
            "        return key in self._session",
            "",
            "    def keys(self):",
            "        return self._session.keys()",
            "",
            "    def values(self):",
            "        return self._session.values()",
            "",
            "    def items(self):",
            "        return self._session.items()",
            "",
            "    def iterkeys(self):",
            "        return self._session.iterkeys()",
            "",
            "    def itervalues(self):",
            "        return self._session.itervalues()",
            "",
            "    def iteritems(self):",
            "        return self._session.iteritems()",
            "",
            "    def clear(self):",
            "        # To avoid unnecessary persistent storage accesses, we set up the",
            "        # internals directly (loading data wastes time, since we are going to",
            "        # set it to an empty dict anyway).",
            "        self._session_cache = {}",
            "        self.accessed = True",
            "        self.modified = True",
            "",
            "    def is_empty(self):",
            "        \"Returns True when there is no session_key and the session is empty\"",
            "        try:",
            "            return not bool(self._session_key) and not self._session_cache",
            "        except AttributeError:",
            "            return True",
            "",
            "    def _get_new_session_key(self):",
            "        \"Returns session key that isn't being used.\"",
            "        while True:",
            "            session_key = get_random_string(32, VALID_KEY_CHARS)",
            "            if not self.exists(session_key):",
            "                break",
            "        return session_key",
            "",
            "    def _get_or_create_session_key(self):",
            "        if self._session_key is None:",
            "            self._session_key = self._get_new_session_key()",
            "        return self._session_key",
            "",
            "    def _get_session_key(self):",
            "        return self._session_key",
            "",
            "    session_key = property(_get_session_key)",
            "",
            "    def _get_session(self, no_load=False):",
            "        \"\"\"",
            "        Lazily loads session from storage (unless \"no_load\" is True, when only",
            "        an empty dict is stored) and stores it in the current instance.",
            "        \"\"\"",
            "        self.accessed = True",
            "        try:",
            "            return self._session_cache",
            "        except AttributeError:",
            "            if self.session_key is None or no_load:",
            "                self._session_cache = {}",
            "            else:",
            "                self._session_cache = self.load()",
            "        return self._session_cache",
            "",
            "    _session = property(_get_session)",
            "",
            "    def get_expiry_age(self, **kwargs):",
            "        \"\"\"Get the number of seconds until the session expires.",
            "",
            "        Optionally, this function accepts `modification` and `expiry` keyword",
            "        arguments specifying the modification and expiry of the session.",
            "        \"\"\"",
            "        try:",
            "            modification = kwargs['modification']",
            "        except KeyError:",
            "            modification = timezone.now()",
            "        # Make the difference between \"expiry=None passed in kwargs\" and",
            "        # \"expiry not passed in kwargs\", in order to guarantee not to trigger",
            "        # self.load() when expiry is provided.",
            "        try:",
            "            expiry = kwargs['expiry']",
            "        except KeyError:",
            "            expiry = self.get('_session_expiry')",
            "",
            "        if not expiry:   # Checks both None and 0 cases",
            "            return settings.SESSION_COOKIE_AGE",
            "        if not isinstance(expiry, datetime):",
            "            return expiry",
            "        delta = expiry - modification",
            "        return delta.days * 86400 + delta.seconds",
            "",
            "    def get_expiry_date(self, **kwargs):",
            "        \"\"\"Get session the expiry date (as a datetime object).",
            "",
            "        Optionally, this function accepts `modification` and `expiry` keyword",
            "        arguments specifying the modification and expiry of the session.",
            "        \"\"\"",
            "        try:",
            "            modification = kwargs['modification']",
            "        except KeyError:",
            "            modification = timezone.now()",
            "        # Same comment as in get_expiry_age",
            "        try:",
            "            expiry = kwargs['expiry']",
            "        except KeyError:",
            "            expiry = self.get('_session_expiry')",
            "",
            "        if isinstance(expiry, datetime):",
            "            return expiry",
            "        if not expiry:   # Checks both None and 0 cases",
            "            expiry = settings.SESSION_COOKIE_AGE",
            "        return modification + timedelta(seconds=expiry)",
            "",
            "    def set_expiry(self, value):",
            "        \"\"\"",
            "        Sets a custom expiration for the session. ``value`` can be an integer,",
            "        a Python ``datetime`` or ``timedelta`` object or ``None``.",
            "",
            "        If ``value`` is an integer, the session will expire after that many",
            "        seconds of inactivity. If set to ``0`` then the session will expire on",
            "        browser close.",
            "",
            "        If ``value`` is a ``datetime`` or ``timedelta`` object, the session",
            "        will expire at that specific future time.",
            "",
            "        If ``value`` is ``None``, the session uses the global session expiry",
            "        policy.",
            "        \"\"\"",
            "        if value is None:",
            "            # Remove any custom expiration for this session.",
            "            try:",
            "                del self['_session_expiry']",
            "            except KeyError:",
            "                pass",
            "            return",
            "        if isinstance(value, timedelta):",
            "            value = timezone.now() + value",
            "        self['_session_expiry'] = value",
            "",
            "    def get_expire_at_browser_close(self):",
            "        \"\"\"",
            "        Returns ``True`` if the session is set to expire when the browser",
            "        closes, and ``False`` if there's an expiry date. Use",
            "        ``get_expiry_date()`` or ``get_expiry_age()`` to find the actual expiry",
            "        date/age, if there is one.",
            "        \"\"\"",
            "        if self.get('_session_expiry') is None:",
            "            return settings.SESSION_EXPIRE_AT_BROWSER_CLOSE",
            "        return self.get('_session_expiry') == 0",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete()",
            "        self._session_key = None",
            "",
            "    def cycle_key(self):",
            "        \"\"\"",
            "        Creates a new session key, whilst retaining the current session data.",
            "        \"\"\"",
            "        data = self._session_cache",
            "        key = self.session_key",
            "        self.create()",
            "        self._session_cache = data",
            "        self.delete(key)",
            "",
            "    # Methods that child classes must implement.",
            "",
            "    def exists(self, session_key):",
            "        \"\"\"",
            "        Returns True if the given session_key already exists.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide an exists() method')",
            "",
            "    def create(self):",
            "        \"\"\"",
            "        Creates a new session instance. Guaranteed to create a new object with",
            "        a unique key and will have saved the result once (with empty data)",
            "        before the method returns.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a create() method')",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the session data. If 'must_create' is True, a new session object",
            "        is created (otherwise a CreateError exception is raised). Otherwise,",
            "        save() can update an existing object with the same key.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a save() method')",
            "",
            "    def delete(self, session_key=None):",
            "        \"\"\"",
            "        Deletes the session data under this key. If the key is None, the",
            "        current session key value is used.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a delete() method')",
            "",
            "    def load(self):",
            "        \"\"\"",
            "        Loads the session data and returns a dictionary.",
            "        \"\"\"",
            "        raise NotImplementedError('subclasses of SessionBase must provide a load() method')",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        \"\"\"",
            "        Remove expired sessions from the session store.",
            "",
            "        If this operation isn't possible on a given backend, it should raise",
            "        NotImplementedError. If it isn't necessary, because the backend has",
            "        a built-in expiration mechanism, it should be a no-op.",
            "        \"\"\"",
            "        raise NotImplementedError('This backend does not support clear_expired().')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "271": [
                "SessionBase",
                "flush"
            ]
        },
        "addLocation": [
            "django.contrib.sessions.backends.base.SessionBase.self",
            "mechanicalsoup.form"
        ]
    },
    "django/contrib/sessions/backends/cached_db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         self.clear()"
            },
            "2": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.delete(self.session_key)"
            },
            "3": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " # At bottom to avoid circular import"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "import logging",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import caches",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "",
            "        if data is None:",
            "            # Duplicate DBStore.load, because we need to keep track",
            "            # of the expiry date to set it properly in the cache.",
            "            try:",
            "                s = Session.objects.get(",
            "                    session_key=self.session_key,",
            "                    expire_date__gt=timezone.now()",
            "                )",
            "                data = self.decode(s.session_data)",
            "                self._cache.set(self.cache_key, data,",
            "                    self.get_expiry_age(expiry=s.expire_date))",
            "            except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "                if isinstance(e, SuspiciousOperation):",
            "                    logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "                    logger.warning(force_text(e))",
            "                self._session_key = None",
            "                data = {}",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if session_key and (KEY_PREFIX + session_key) in self._cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        self._cache.set(self.cache_key, self._session, self.get_expiry_age())",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self.create()",
            "",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "import logging",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import caches",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "",
            "        if data is None:",
            "            # Duplicate DBStore.load, because we need to keep track",
            "            # of the expiry date to set it properly in the cache.",
            "            try:",
            "                s = Session.objects.get(",
            "                    session_key=self.session_key,",
            "                    expire_date__gt=timezone.now()",
            "                )",
            "                data = self.decode(s.session_data)",
            "                self._cache.set(self.cache_key, data,",
            "                    self.get_expiry_age(expiry=s.expire_date))",
            "            except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "                if isinstance(e, SuspiciousOperation):",
            "                    logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "                    logger.warning(force_text(e))",
            "                self._session_key = None",
            "                data = {}",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if session_key and (KEY_PREFIX + session_key) in self._cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        self._cache.set(self.cache_key, self._session, self.get_expiry_age())",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self._session_key = None",
            "",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "82": [
                "SessionStore",
                "flush"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/middleware.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     def process_response(self, request, response):"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "         \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "         If request.session was modified, or if the configuration is to save the"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        session every time, save the changes and set a session cookie."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+        session every time, save the changes and set a session cookie or delete"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+        the session cookie if the session has been emptied."
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         try:"
            },
            "8": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "             accessed = request.session.accessed"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "             modified = request.session.modified"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+            empty = request.session.is_empty()"
            },
            "11": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         except AttributeError:"
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             pass"
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         else:"
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if accessed:"
            },
            "15": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                patch_vary_headers(response, ('Cookie',))"
            },
            "16": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if modified or settings.SESSION_SAVE_EVERY_REQUEST:"
            },
            "17": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if request.session.get_expire_at_browser_close():"
            },
            "18": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    max_age = None"
            },
            "19": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    expires = None"
            },
            "20": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                else:"
            },
            "21": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    max_age = request.session.get_expiry_age()"
            },
            "22": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    expires_time = time.time() + max_age"
            },
            "23": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    expires = cookie_date(expires_time)"
            },
            "24": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Save the session data and refresh the client cookie."
            },
            "25": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # Skip session save for 500 responses, refs #3881."
            },
            "26": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if response.status_code != 500:"
            },
            "27": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    request.session.save()"
            },
            "28": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    response.set_cookie(settings.SESSION_COOKIE_NAME,"
            },
            "29": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            request.session.session_key, max_age=max_age,"
            },
            "30": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,"
            },
            "31": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            path=settings.SESSION_COOKIE_PATH,"
            },
            "32": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            secure=settings.SESSION_COOKIE_SECURE or None,"
            },
            "33": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            httponly=settings.SESSION_COOKIE_HTTPONLY or None)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+            # First check if we need to delete this cookie."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+            # The session should be deleted only if the session is entirely empty"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+            if settings.SESSION_COOKIE_NAME in request.COOKIES and empty:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+                response.delete_cookie(settings.SESSION_COOKIE_NAME,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+                    domain=settings.SESSION_COOKIE_DOMAIN)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+            else:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+                if accessed:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+                    patch_vary_headers(response, ('Cookie',))"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+                if (modified or settings.SESSION_SAVE_EVERY_REQUEST) and not empty:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+                    if request.session.get_expire_at_browser_close():"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+                        max_age = None"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+                        expires = None"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+                    else:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+                        max_age = request.session.get_expiry_age()"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                        expires_time = time.time() + max_age"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                        expires = cookie_date(expires_time)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                    # Save the session data and refresh the client cookie."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+                    # Skip session save for 500 responses, refs #3881."
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                    if response.status_code != 500:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                        request.session.save()"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+                        response.set_cookie(settings.SESSION_COOKIE_NAME,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                                request.session.session_key, max_age=max_age,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                                expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                                path=settings.SESSION_COOKIE_PATH,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                                secure=settings.SESSION_COOKIE_SECURE or None,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+                                httponly=settings.SESSION_COOKIE_HTTPONLY or None)"
            },
            "60": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         return response"
            }
        },
        "frontPatchFile": [
            "from importlib import import_module",
            "import time",
            "",
            "from django.conf import settings",
            "from django.utils.cache import patch_vary_headers",
            "from django.utils.http import cookie_date",
            "",
            "",
            "class SessionMiddleware(object):",
            "    def __init__(self):",
            "        engine = import_module(settings.SESSION_ENGINE)",
            "        self.SessionStore = engine.SessionStore",
            "",
            "    def process_request(self, request):",
            "        session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None)",
            "        request.session = self.SessionStore(session_key)",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        If request.session was modified, or if the configuration is to save the",
            "        session every time, save the changes and set a session cookie.",
            "        \"\"\"",
            "        try:",
            "            accessed = request.session.accessed",
            "            modified = request.session.modified",
            "        except AttributeError:",
            "            pass",
            "        else:",
            "            if accessed:",
            "                patch_vary_headers(response, ('Cookie',))",
            "            if modified or settings.SESSION_SAVE_EVERY_REQUEST:",
            "                if request.session.get_expire_at_browser_close():",
            "                    max_age = None",
            "                    expires = None",
            "                else:",
            "                    max_age = request.session.get_expiry_age()",
            "                    expires_time = time.time() + max_age",
            "                    expires = cookie_date(expires_time)",
            "                # Save the session data and refresh the client cookie.",
            "                # Skip session save for 500 responses, refs #3881.",
            "                if response.status_code != 500:",
            "                    request.session.save()",
            "                    response.set_cookie(settings.SESSION_COOKIE_NAME,",
            "                            request.session.session_key, max_age=max_age,",
            "                            expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,",
            "                            path=settings.SESSION_COOKIE_PATH,",
            "                            secure=settings.SESSION_COOKIE_SECURE or None,",
            "                            httponly=settings.SESSION_COOKIE_HTTPONLY or None)",
            "        return response"
        ],
        "afterPatchFile": [
            "from importlib import import_module",
            "import time",
            "",
            "from django.conf import settings",
            "from django.utils.cache import patch_vary_headers",
            "from django.utils.http import cookie_date",
            "",
            "",
            "class SessionMiddleware(object):",
            "    def __init__(self):",
            "        engine = import_module(settings.SESSION_ENGINE)",
            "        self.SessionStore = engine.SessionStore",
            "",
            "    def process_request(self, request):",
            "        session_key = request.COOKIES.get(settings.SESSION_COOKIE_NAME, None)",
            "        request.session = self.SessionStore(session_key)",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        If request.session was modified, or if the configuration is to save the",
            "        session every time, save the changes and set a session cookie or delete",
            "        the session cookie if the session has been emptied.",
            "        \"\"\"",
            "        try:",
            "            accessed = request.session.accessed",
            "            modified = request.session.modified",
            "            empty = request.session.is_empty()",
            "        except AttributeError:",
            "            pass",
            "        else:",
            "            # First check if we need to delete this cookie.",
            "            # The session should be deleted only if the session is entirely empty",
            "            if settings.SESSION_COOKIE_NAME in request.COOKIES and empty:",
            "                response.delete_cookie(settings.SESSION_COOKIE_NAME,",
            "                    domain=settings.SESSION_COOKIE_DOMAIN)",
            "            else:",
            "                if accessed:",
            "                    patch_vary_headers(response, ('Cookie',))",
            "                if (modified or settings.SESSION_SAVE_EVERY_REQUEST) and not empty:",
            "                    if request.session.get_expire_at_browser_close():",
            "                        max_age = None",
            "                        expires = None",
            "                    else:",
            "                        max_age = request.session.get_expiry_age()",
            "                        expires_time = time.time() + max_age",
            "                        expires = cookie_date(expires_time)",
            "                    # Save the session data and refresh the client cookie.",
            "                    # Skip session save for 500 responses, refs #3881.",
            "                    if response.status_code != 500:",
            "                        request.session.save()",
            "                        response.set_cookie(settings.SESSION_COOKIE_NAME,",
            "                                request.session.session_key, max_age=max_age,",
            "                                expires=expires, domain=settings.SESSION_COOKIE_DOMAIN,",
            "                                path=settings.SESSION_COOKIE_PATH,",
            "                                secure=settings.SESSION_COOKIE_SECURE or None,",
            "                                httponly=settings.SESSION_COOKIE_HTTPONLY or None)",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [
                "SessionMiddleware",
                "process_response"
            ],
            "29": [
                "SessionMiddleware",
                "process_response"
            ],
            "30": [
                "SessionMiddleware",
                "process_response"
            ],
            "31": [
                "SessionMiddleware",
                "process_response"
            ],
            "32": [
                "SessionMiddleware",
                "process_response"
            ],
            "33": [
                "SessionMiddleware",
                "process_response"
            ],
            "34": [
                "SessionMiddleware",
                "process_response"
            ],
            "35": [
                "SessionMiddleware",
                "process_response"
            ],
            "36": [
                "SessionMiddleware",
                "process_response"
            ],
            "37": [
                "SessionMiddleware",
                "process_response"
            ],
            "38": [
                "SessionMiddleware",
                "process_response"
            ],
            "39": [
                "SessionMiddleware",
                "process_response"
            ],
            "40": [
                "SessionMiddleware",
                "process_response"
            ],
            "41": [
                "SessionMiddleware",
                "process_response"
            ],
            "42": [
                "SessionMiddleware",
                "process_response"
            ],
            "43": [
                "SessionMiddleware",
                "process_response"
            ],
            "44": [
                "SessionMiddleware",
                "process_response"
            ],
            "45": [
                "SessionMiddleware",
                "process_response"
            ],
            "46": [
                "SessionMiddleware",
                "process_response"
            ],
            "47": [
                "SessionMiddleware",
                "process_response"
            ],
            "48": [
                "SessionMiddleware",
                "process_response"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/tests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         self.session.flush()"
            },
            "1": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         self.assertFalse(self.session.exists(prev_key))"
            },
            "2": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         self.assertNotEqual(self.session.session_key, prev_key)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        self.assertIsNone(self.session.session_key)"
            },
            "4": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         self.assertTrue(self.session.modified)"
            },
            "5": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         self.assertTrue(self.session.accessed)"
            },
            "6": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 590,
                "PatchRowcode": "         # Check that the value wasn't saved above."
            },
            "8": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": 591,
                "PatchRowcode": "         self.assertNotIn('hello', request.session.load())"
            },
            "9": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 592,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 593,
                "PatchRowcode": "+    def test_session_delete_on_end(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 594,
                "PatchRowcode": "+        request = RequestFactory().get('/')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 595,
                "PatchRowcode": "+        response = HttpResponse('Session test')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+        middleware = SessionMiddleware()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+        # Before deleting, there has to be an existing cookie"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+        # Simulate a request that ends the session"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 602,
                "PatchRowcode": "+        middleware.process_request(request)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 603,
                "PatchRowcode": "+        request.session.flush()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 604,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+        # Handle the response through the middleware"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+        response = middleware.process_response(request, response)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+        # Check that the cookie was deleted, not recreated."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+        # A deleted cookie header looks like:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+        #  Set-Cookie: sessionid=; expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 611,
                "PatchRowcode": "+        self.assertEqual("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 612,
                "PatchRowcode": "+            'Set-Cookie: {0}=; expires=Thu, 01-Jan-1970 00:00:00 GMT; '"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 613,
                "PatchRowcode": "+            'Max-Age=0; Path=/'.format(settings.SESSION_COOKIE_NAME),"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 614,
                "PatchRowcode": "+            str(response.cookies[settings.SESSION_COOKIE_NAME])"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+        )"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+    @override_settings(SESSION_COOKIE_DOMAIN='.example.local')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+    def test_session_delete_on_end_with_custom_domain(self):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+        request = RequestFactory().get('/')"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+        response = HttpResponse('Session test')"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+        middleware = SessionMiddleware()"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+        # Before deleting, there has to be an existing cookie"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 625,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 626,
                "PatchRowcode": "+        # Simulate a request that ends the session"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 627,
                "PatchRowcode": "+        middleware.process_request(request)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 628,
                "PatchRowcode": "+        request.session.flush()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 629,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 630,
                "PatchRowcode": "+        # Handle the response through the middleware"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 631,
                "PatchRowcode": "+        response = middleware.process_response(request, response)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 632,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 633,
                "PatchRowcode": "+        # Check that the cookie was deleted, not recreated."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 634,
                "PatchRowcode": "+        # A deleted cookie header with a custom domain looks like:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 635,
                "PatchRowcode": "+        #  Set-Cookie: sessionid=; Domain=.example.local;"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 636,
                "PatchRowcode": "+        #              expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 637,
                "PatchRowcode": "+        self.assertEqual("
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 638,
                "PatchRowcode": "+            'Set-Cookie: {}=; Domain=.example.local; expires=Thu, '"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 639,
                "PatchRowcode": "+            '01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/'.format("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 640,
                "PatchRowcode": "+                settings.SESSION_COOKIE_NAME,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 641,
                "PatchRowcode": "+            ),"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 642,
                "PatchRowcode": "+            str(response.cookies[settings.SESSION_COOKIE_NAME])"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 643,
                "PatchRowcode": "+        )"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 644,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 645,
                "PatchRowcode": "+    def test_flush_empty_without_session_cookie_doesnt_set_cookie(self):"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 646,
                "PatchRowcode": "+        request = RequestFactory().get('/')"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 647,
                "PatchRowcode": "+        response = HttpResponse('Session test')"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 648,
                "PatchRowcode": "+        middleware = SessionMiddleware()"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 649,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 650,
                "PatchRowcode": "+        # Simulate a request that ends the session"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 651,
                "PatchRowcode": "+        middleware.process_request(request)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 652,
                "PatchRowcode": "+        request.session.flush()"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 653,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 654,
                "PatchRowcode": "+        # Handle the response through the middleware"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 655,
                "PatchRowcode": "+        response = middleware.process_response(request, response)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 656,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 657,
                "PatchRowcode": "+        # A cookie should not be set."
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 658,
                "PatchRowcode": "+        self.assertEqual(response.cookies, {})"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 659,
                "PatchRowcode": "+        # The session is accessed so \"Vary: Cookie\" should be set."
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 660,
                "PatchRowcode": "+        self.assertEqual(response['Vary'], 'Cookie')"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+"
            },
            "79": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 662,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 663,
                "PatchRowcode": " class CookieSessionTests(SessionTestsMixin, TestCase):"
            },
            "81": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 664,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import base64",
            "from datetime import timedelta",
            "import os",
            "import shutil",
            "import string",
            "import tempfile",
            "import unittest",
            "import warnings",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DatabaseSession",
            "from django.contrib.sessions.backends.cache import SessionStore as CacheSession",
            "from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession",
            "from django.contrib.sessions.backends.file import SessionStore as FileSession",
            "from django.contrib.sessions.backends.signed_cookies import SessionStore as CookieSession",
            "from django.contrib.sessions.models import Session",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "from django.core.cache import caches",
            "from django.core.cache.backends.base import InvalidCacheBackendError",
            "from django.core import management",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.http import HttpResponse",
            "from django.test import TestCase, RequestFactory, override_settings",
            "from django.test.utils import patch_logger",
            "from django.utils import six",
            "from django.utils import timezone",
            "from django.utils.six.moves import http_cookies",
            "",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "",
            "",
            "class SessionTestsMixin(object):",
            "    # This does not inherit from TestCase to avoid any tests being run with this",
            "    # class, which wouldn't work, and to allow different TestCase subclasses to",
            "    # be used.",
            "",
            "    backend = None  # subclasses must specify",
            "",
            "    def setUp(self):",
            "        self.session = self.backend()",
            "",
            "    def tearDown(self):",
            "        # NB: be careful to delete any sessions created; stale sessions fill up",
            "        # the /tmp (with some backends) and eventually overwhelm it after lots",
            "        # of runs (think buildbots)",
            "        self.session.delete()",
            "",
            "    def test_new_session(self):",
            "        self.assertFalse(self.session.modified)",
            "        self.assertFalse(self.session.accessed)",
            "",
            "    def test_get_empty(self):",
            "        self.assertEqual(self.session.get('cat'), None)",
            "",
            "    def test_store(self):",
            "        self.session['cat'] = \"dog\"",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.pop('cat'), 'dog')",
            "",
            "    def test_pop(self):",
            "        self.session['some key'] = 'exists'",
            "        # Need to reset these to pretend we haven't accessed it:",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "        self.assertEqual(self.session.pop('some key'), 'exists')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('some key'), None)",
            "",
            "    def test_pop_default(self):",
            "        self.assertEqual(self.session.pop('some key', 'does not exist'),",
            "                         'does not exist')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_setdefault(self):",
            "        self.assertEqual(self.session.setdefault('foo', 'bar'), 'bar')",
            "        self.assertEqual(self.session.setdefault('foo', 'baz'), 'bar')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_update(self):",
            "        self.session.update({'update key': 1})",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('update key', None), 1)",
            "",
            "    def test_has_key(self):",
            "        self.session['some key'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertIn('some key', self.session)",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_values(self):",
            "        self.assertEqual(list(self.session.values()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.session['some key'] = 1",
            "        self.assertEqual(list(self.session.values()), [1])",
            "",
            "    def test_iterkeys(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iterkeys(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), ['x'])",
            "",
            "    def test_itervalues(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.itervalues(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [1])",
            "",
            "    def test_iteritems(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iteritems(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [('x', 1)])",
            "",
            "    def test_clear(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertEqual(list(self.session.items()), [('x', 1)])",
            "        self.session.clear()",
            "        self.assertEqual(list(self.session.items()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_save(self):",
            "        if (hasattr(self.session, '_cache') and 'DummyCache' in",
            "                settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND']):",
            "            raise unittest.SkipTest(\"Session saving tests require a real cache backend\")",
            "        self.session.save()",
            "        self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_delete(self):",
            "        self.session.save()",
            "        self.session.delete(self.session.session_key)",
            "        self.assertFalse(self.session.exists(self.session.session_key))",
            "",
            "    def test_flush(self):",
            "        self.session['foo'] = 'bar'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        self.session.flush()",
            "        self.assertFalse(self.session.exists(prev_key))",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertTrue(self.session.accessed)",
            "",
            "    def test_cycle(self):",
            "        self.session['a'], self.session['b'] = 'c', 'd'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        prev_data = list(self.session.items())",
            "        self.session.cycle_key()",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertEqual(list(self.session.items()), prev_data)",
            "",
            "    def test_save_doesnt_clear_data(self):",
            "        self.session['a'] = 'b'",
            "        self.session.save()",
            "        self.assertEqual(self.session['a'], 'b')",
            "",
            "    def test_invalid_key(self):",
            "        # Submitting an invalid session key (either by guessing, or if the db has",
            "        # removed the key) results in a new key being generated.",
            "        try:",
            "            session = self.backend('1')",
            "            try:",
            "                session.save()",
            "            except AttributeError:",
            "                self.fail(\"The session object did not save properly.  Middleware may be saving cache items without namespaces.\")",
            "            self.assertNotEqual(session.session_key, '1')",
            "            self.assertEqual(session.get('cat'), None)",
            "            session.delete()",
            "        finally:",
            "            # Some backends leave a stale cache entry for the invalid",
            "            # session key; make sure that entry is manually deleted",
            "            session.delete('1')",
            "",
            "    def test_session_key_is_read_only(self):",
            "        def set_session_key(session):",
            "            session.session_key = session._get_new_session_key()",
            "        self.assertRaises(AttributeError, set_session_key, self.session)",
            "",
            "    # Custom session expiry",
            "    def test_default_expiry(self):",
            "        # A normal session has a max age equal to settings",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "        # So does a custom session with an idle expiration time of 0 (but it'll",
            "        # expire at browser close)",
            "        self.session.set_expiry(0)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_custom_expiry_seconds(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(10)",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_timedelta(self):",
            "        modification = timezone.now()",
            "",
            "        # Mock timezone.now, because set_expiry calls it on this code path.",
            "        original_now = timezone.now",
            "        try:",
            "            timezone.now = lambda: modification",
            "            self.session.set_expiry(timedelta(seconds=10))",
            "        finally:",
            "            timezone.now = original_now",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_datetime(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(modification + timedelta(seconds=10))",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_reset(self):",
            "        self.session.set_expiry(None)",
            "        self.session.set_expiry(10)",
            "        self.session.set_expiry(None)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_get_expire_at_browser_close(self):",
            "        # Tests get_expire_at_browser_close with different settings and different",
            "        # set_expiry calls",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "    def test_decode(self):",
            "        # Ensure we can decode what we encode",
            "        data = {'a test key': 'a test value'}",
            "        encoded = self.session.encode(data)",
            "        self.assertEqual(self.session.decode(encoded), data)",
            "",
            "    def test_decode_failure_logged_to_security(self):",
            "        bad_encode = base64.b64encode(b'flaskdj:alkdjf')",
            "        with patch_logger('django.security.SuspiciousSession', 'warning') as calls:",
            "            self.assertEqual({}, self.session.decode(bad_encode))",
            "            # check that the failed decode is logged",
            "            self.assertEqual(len(calls), 1)",
            "            self.assertTrue('corrupted' in calls[0])",
            "",
            "    def test_actual_expiry(self):",
            "        # this doesn't work with JSONSerializer (serializing timedelta)",
            "        with override_settings(SESSION_SERIALIZER='django.contrib.sessions.serializers.PickleSerializer'):",
            "            self.session = self.backend()  # reinitialize after overriding settings",
            "",
            "            # Regression test for #19200",
            "            old_session_key = None",
            "            new_session_key = None",
            "            try:",
            "                self.session['foo'] = 'bar'",
            "                self.session.set_expiry(-timedelta(seconds=10))",
            "                self.session.save()",
            "                old_session_key = self.session.session_key",
            "                # With an expiry date in the past, the session expires instantly.",
            "                new_session = self.backend(self.session.session_key)",
            "                new_session_key = new_session.session_key",
            "                self.assertNotIn('foo', new_session)",
            "            finally:",
            "                self.session.delete(old_session_key)",
            "                self.session.delete(new_session_key)",
            "",
            "    def test_session_load_does_not_create_record(self):",
            "        \"\"\"",
            "        Loading an unknown session key does not create a session record.",
            "",
            "        Creating session records on load is a DOS vulnerability.",
            "        \"\"\"",
            "        if self.backend is CookieSession:",
            "            raise unittest.SkipTest(\"Cookie backend doesn't have an external store to create records in.\")",
            "        session = self.backend('someunknownkey')",
            "        session.load()",
            "",
            "        self.assertFalse(session.exists(session.session_key))",
            "        # provided unknown key was cycled, not reused",
            "        self.assertNotEqual(session.session_key, 'someunknownkey')",
            "",
            "",
            "class DatabaseSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = DatabaseSession",
            "",
            "    def test_session_get_decoded(self):",
            "        \"\"\"",
            "        Test we can use Session.get_decoded to retrieve data stored",
            "        in normal way",
            "        \"\"\"",
            "        self.session['x'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "",
            "        self.assertEqual(s.get_decoded(), {'x': 1})",
            "",
            "    def test_sessionmanager_save(self):",
            "        \"\"\"",
            "        Test SessionManager.save method",
            "        \"\"\"",
            "        # Create a session",
            "        self.session['y'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "        # Change it",
            "        Session.objects.save(s.session_key, {'y': 2}, s.expire_date)",
            "        # Clear cache, so that it will be retrieved from DB",
            "        del self.session._session_cache",
            "        self.assertEqual(self.session['y'], 2)",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.db\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        self.assertEqual(0, Session.objects.count())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the database before clearsessions...",
            "        self.assertEqual(2, Session.objects.count())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, Session.objects.count())",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class DatabaseSessionWithTimeZoneTests(DatabaseSessionTests):",
            "    pass",
            "",
            "",
            "class CacheDBSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CacheDBSession",
            "",
            "    @unittest.skipIf('DummyCache' in",
            "        settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND'],",
            "        \"Session saving tests require a real cache backend\")",
            "    def test_exists_searches_cache_first(self):",
            "        self.session.save()",
            "        with self.assertNumQueries(0):",
            "            self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    @override_settings(SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # 21000 - CacheDB backend should respect SESSION_CACHE_ALIAS.",
            "        self.assertRaises(InvalidCacheBackendError, self.backend)",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class CacheDBSessionWithTimeZoneTests(CacheDBSessionTests):",
            "    pass",
            "",
            "",
            "# Don't need DB flushing for these tests, so can use unittest.TestCase as base class",
            "class FileSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = FileSession",
            "",
            "    def setUp(self):",
            "        # Do file session tests in an isolated directory, and kill it after we're done.",
            "        self.original_session_file_path = settings.SESSION_FILE_PATH",
            "        self.temp_session_store = settings.SESSION_FILE_PATH = tempfile.mkdtemp()",
            "        # Reset the file session backend's internal caches",
            "        if hasattr(self.backend, '_storage_path'):",
            "            del self.backend._storage_path",
            "        super(FileSessionTests, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(FileSessionTests, self).tearDown()",
            "        settings.SESSION_FILE_PATH = self.original_session_file_path",
            "        shutil.rmtree(self.temp_session_store)",
            "",
            "    @override_settings(",
            "        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")",
            "    def test_configuration_check(self):",
            "        del self.backend._storage_path",
            "        # Make sure the file backend checks for a good storage dir",
            "        self.assertRaises(ImproperlyConfigured, self.backend)",
            "",
            "    def test_invalid_key_backslash(self):",
            "        # Ensure we don't allow directory-traversal.",
            "        # This is tested directly on _key_to_file, as load() will swallow",
            "        # a SuspiciousOperation in the same way as an IOError - by creating",
            "        # a new session, making it unclear whether the slashes were detected.",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a\\\\b\\\\c\")",
            "",
            "    def test_invalid_key_forwardslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a/b/c\")",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.file\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        storage_path = self.backend._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        def count_sessions():",
            "            return len([session_file for session_file in os.listdir(storage_path)",
            "                if session_file.startswith(file_prefix)])",
            "",
            "        self.assertEqual(0, count_sessions())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the filesystem before clearsessions...",
            "        self.assertEqual(2, count_sessions())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, count_sessions())",
            "",
            "",
            "class CacheSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = CacheSession",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    def test_default_cache(self):",
            "        self.session.save()",
            "        self.assertNotEqual(caches['default'].get(self.session.cache_key), None)",
            "",
            "    @override_settings(CACHES={",
            "        'default': {",
            "            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',",
            "        },",
            "        'sessions': {",
            "            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',",
            "            'LOCATION': 'session',",
            "        },",
            "    }, SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # Re-initialize the session backend to make use of overridden settings.",
            "        self.session = self.backend()",
            "",
            "        self.session.save()",
            "        self.assertEqual(caches['default'].get(self.session.cache_key), None)",
            "        self.assertNotEqual(caches['sessions'].get(self.session.cache_key), None)",
            "",
            "",
            "class SessionMiddlewareTests(unittest.TestCase):",
            "",
            "    @override_settings(SESSION_COOKIE_SECURE=True)",
            "    def test_secure_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['secure'])",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=True)",
            "    def test_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "        self.assertIn(http_cookies.Morsel._reserved['httponly'],",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=False)",
            "    def test_no_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertFalse(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "",
            "        self.assertNotIn(http_cookies.Morsel._reserved['httponly'],",
            "                         str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    def test_session_save_on_500(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Horrible error')",
            "        response.status_code = 500",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the value wasn't saved above.",
            "        self.assertNotIn('hello', request.session.load())",
            "",
            "",
            "class CookieSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CookieSession",
            "",
            "    def test_save(self):",
            "        \"\"\"",
            "        This test tested exists() in the other session backends, but that",
            "        doesn't make sense for us.",
            "        \"\"\"",
            "        pass",
            "",
            "    def test_cycle(self):",
            "        \"\"\"",
            "        This test tested cycle_key() which would create a new session",
            "        key for the same session data. But we can't invalidate previously",
            "        signed cookies (other than letting them expire naturally) so",
            "        testing for this behavior is meaningless.",
            "        \"\"\"",
            "        pass",
            "",
            "    @unittest.expectedFailure",
            "    def test_actual_expiry(self):",
            "        # The cookie backend doesn't handle non-default expiry dates, see #19201",
            "        super(CookieSessionTests, self).test_actual_expiry()"
        ],
        "afterPatchFile": [
            "import base64",
            "from datetime import timedelta",
            "import os",
            "import shutil",
            "import string",
            "import tempfile",
            "import unittest",
            "import warnings",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DatabaseSession",
            "from django.contrib.sessions.backends.cache import SessionStore as CacheSession",
            "from django.contrib.sessions.backends.cached_db import SessionStore as CacheDBSession",
            "from django.contrib.sessions.backends.file import SessionStore as FileSession",
            "from django.contrib.sessions.backends.signed_cookies import SessionStore as CookieSession",
            "from django.contrib.sessions.models import Session",
            "from django.contrib.sessions.middleware import SessionMiddleware",
            "from django.core.cache import caches",
            "from django.core.cache.backends.base import InvalidCacheBackendError",
            "from django.core import management",
            "from django.core.exceptions import ImproperlyConfigured",
            "from django.http import HttpResponse",
            "from django.test import TestCase, RequestFactory, override_settings",
            "from django.test.utils import patch_logger",
            "from django.utils import six",
            "from django.utils import timezone",
            "from django.utils.six.moves import http_cookies",
            "",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "",
            "",
            "class SessionTestsMixin(object):",
            "    # This does not inherit from TestCase to avoid any tests being run with this",
            "    # class, which wouldn't work, and to allow different TestCase subclasses to",
            "    # be used.",
            "",
            "    backend = None  # subclasses must specify",
            "",
            "    def setUp(self):",
            "        self.session = self.backend()",
            "",
            "    def tearDown(self):",
            "        # NB: be careful to delete any sessions created; stale sessions fill up",
            "        # the /tmp (with some backends) and eventually overwhelm it after lots",
            "        # of runs (think buildbots)",
            "        self.session.delete()",
            "",
            "    def test_new_session(self):",
            "        self.assertFalse(self.session.modified)",
            "        self.assertFalse(self.session.accessed)",
            "",
            "    def test_get_empty(self):",
            "        self.assertEqual(self.session.get('cat'), None)",
            "",
            "    def test_store(self):",
            "        self.session['cat'] = \"dog\"",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.pop('cat'), 'dog')",
            "",
            "    def test_pop(self):",
            "        self.session['some key'] = 'exists'",
            "        # Need to reset these to pretend we haven't accessed it:",
            "        self.accessed = False",
            "        self.modified = False",
            "",
            "        self.assertEqual(self.session.pop('some key'), 'exists')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('some key'), None)",
            "",
            "    def test_pop_default(self):",
            "        self.assertEqual(self.session.pop('some key', 'does not exist'),",
            "                         'does not exist')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_setdefault(self):",
            "        self.assertEqual(self.session.setdefault('foo', 'bar'), 'bar')",
            "        self.assertEqual(self.session.setdefault('foo', 'baz'), 'bar')",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_update(self):",
            "        self.session.update({'update key': 1})",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertEqual(self.session.get('update key', None), 1)",
            "",
            "    def test_has_key(self):",
            "        self.session['some key'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertIn('some key', self.session)",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "",
            "    def test_values(self):",
            "        self.assertEqual(list(self.session.values()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.session['some key'] = 1",
            "        self.assertEqual(list(self.session.values()), [1])",
            "",
            "    def test_iterkeys(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iterkeys(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), ['x'])",
            "",
            "    def test_itervalues(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.itervalues(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [1])",
            "",
            "    def test_iteritems(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        i = six.iteritems(self.session)",
            "        self.assertTrue(hasattr(i, '__iter__'))",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertFalse(self.session.modified)",
            "        self.assertEqual(list(i), [('x', 1)])",
            "",
            "    def test_clear(self):",
            "        self.session['x'] = 1",
            "        self.session.modified = False",
            "        self.session.accessed = False",
            "        self.assertEqual(list(self.session.items()), [('x', 1)])",
            "        self.session.clear()",
            "        self.assertEqual(list(self.session.items()), [])",
            "        self.assertTrue(self.session.accessed)",
            "        self.assertTrue(self.session.modified)",
            "",
            "    def test_save(self):",
            "        if (hasattr(self.session, '_cache') and 'DummyCache' in",
            "                settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND']):",
            "            raise unittest.SkipTest(\"Session saving tests require a real cache backend\")",
            "        self.session.save()",
            "        self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_delete(self):",
            "        self.session.save()",
            "        self.session.delete(self.session.session_key)",
            "        self.assertFalse(self.session.exists(self.session.session_key))",
            "",
            "    def test_flush(self):",
            "        self.session['foo'] = 'bar'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        self.session.flush()",
            "        self.assertFalse(self.session.exists(prev_key))",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertIsNone(self.session.session_key)",
            "        self.assertTrue(self.session.modified)",
            "        self.assertTrue(self.session.accessed)",
            "",
            "    def test_cycle(self):",
            "        self.session['a'], self.session['b'] = 'c', 'd'",
            "        self.session.save()",
            "        prev_key = self.session.session_key",
            "        prev_data = list(self.session.items())",
            "        self.session.cycle_key()",
            "        self.assertNotEqual(self.session.session_key, prev_key)",
            "        self.assertEqual(list(self.session.items()), prev_data)",
            "",
            "    def test_save_doesnt_clear_data(self):",
            "        self.session['a'] = 'b'",
            "        self.session.save()",
            "        self.assertEqual(self.session['a'], 'b')",
            "",
            "    def test_invalid_key(self):",
            "        # Submitting an invalid session key (either by guessing, or if the db has",
            "        # removed the key) results in a new key being generated.",
            "        try:",
            "            session = self.backend('1')",
            "            try:",
            "                session.save()",
            "            except AttributeError:",
            "                self.fail(\"The session object did not save properly.  Middleware may be saving cache items without namespaces.\")",
            "            self.assertNotEqual(session.session_key, '1')",
            "            self.assertEqual(session.get('cat'), None)",
            "            session.delete()",
            "        finally:",
            "            # Some backends leave a stale cache entry for the invalid",
            "            # session key; make sure that entry is manually deleted",
            "            session.delete('1')",
            "",
            "    def test_session_key_is_read_only(self):",
            "        def set_session_key(session):",
            "            session.session_key = session._get_new_session_key()",
            "        self.assertRaises(AttributeError, set_session_key, self.session)",
            "",
            "    # Custom session expiry",
            "    def test_default_expiry(self):",
            "        # A normal session has a max age equal to settings",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "        # So does a custom session with an idle expiration time of 0 (but it'll",
            "        # expire at browser close)",
            "        self.session.set_expiry(0)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_custom_expiry_seconds(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(10)",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_timedelta(self):",
            "        modification = timezone.now()",
            "",
            "        # Mock timezone.now, because set_expiry calls it on this code path.",
            "        original_now = timezone.now",
            "        try:",
            "            timezone.now = lambda: modification",
            "            self.session.set_expiry(timedelta(seconds=10))",
            "        finally:",
            "            timezone.now = original_now",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_datetime(self):",
            "        modification = timezone.now()",
            "",
            "        self.session.set_expiry(modification + timedelta(seconds=10))",
            "",
            "        date = self.session.get_expiry_date(modification=modification)",
            "        self.assertEqual(date, modification + timedelta(seconds=10))",
            "",
            "        age = self.session.get_expiry_age(modification=modification)",
            "        self.assertEqual(age, 10)",
            "",
            "    def test_custom_expiry_reset(self):",
            "        self.session.set_expiry(None)",
            "        self.session.set_expiry(10)",
            "        self.session.set_expiry(None)",
            "        self.assertEqual(self.session.get_expiry_age(), settings.SESSION_COOKIE_AGE)",
            "",
            "    def test_get_expire_at_browser_close(self):",
            "        # Tests get_expire_at_browser_close with different settings and different",
            "        # set_expiry calls",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=False):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "        with override_settings(SESSION_EXPIRE_AT_BROWSER_CLOSE=True):",
            "            self.session.set_expiry(10)",
            "            self.assertFalse(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(0)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "            self.session.set_expiry(None)",
            "            self.assertTrue(self.session.get_expire_at_browser_close())",
            "",
            "    def test_decode(self):",
            "        # Ensure we can decode what we encode",
            "        data = {'a test key': 'a test value'}",
            "        encoded = self.session.encode(data)",
            "        self.assertEqual(self.session.decode(encoded), data)",
            "",
            "    def test_decode_failure_logged_to_security(self):",
            "        bad_encode = base64.b64encode(b'flaskdj:alkdjf')",
            "        with patch_logger('django.security.SuspiciousSession', 'warning') as calls:",
            "            self.assertEqual({}, self.session.decode(bad_encode))",
            "            # check that the failed decode is logged",
            "            self.assertEqual(len(calls), 1)",
            "            self.assertTrue('corrupted' in calls[0])",
            "",
            "    def test_actual_expiry(self):",
            "        # this doesn't work with JSONSerializer (serializing timedelta)",
            "        with override_settings(SESSION_SERIALIZER='django.contrib.sessions.serializers.PickleSerializer'):",
            "            self.session = self.backend()  # reinitialize after overriding settings",
            "",
            "            # Regression test for #19200",
            "            old_session_key = None",
            "            new_session_key = None",
            "            try:",
            "                self.session['foo'] = 'bar'",
            "                self.session.set_expiry(-timedelta(seconds=10))",
            "                self.session.save()",
            "                old_session_key = self.session.session_key",
            "                # With an expiry date in the past, the session expires instantly.",
            "                new_session = self.backend(self.session.session_key)",
            "                new_session_key = new_session.session_key",
            "                self.assertNotIn('foo', new_session)",
            "            finally:",
            "                self.session.delete(old_session_key)",
            "                self.session.delete(new_session_key)",
            "",
            "    def test_session_load_does_not_create_record(self):",
            "        \"\"\"",
            "        Loading an unknown session key does not create a session record.",
            "",
            "        Creating session records on load is a DOS vulnerability.",
            "        \"\"\"",
            "        if self.backend is CookieSession:",
            "            raise unittest.SkipTest(\"Cookie backend doesn't have an external store to create records in.\")",
            "        session = self.backend('someunknownkey')",
            "        session.load()",
            "",
            "        self.assertFalse(session.exists(session.session_key))",
            "        # provided unknown key was cycled, not reused",
            "        self.assertNotEqual(session.session_key, 'someunknownkey')",
            "",
            "",
            "class DatabaseSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = DatabaseSession",
            "",
            "    def test_session_get_decoded(self):",
            "        \"\"\"",
            "        Test we can use Session.get_decoded to retrieve data stored",
            "        in normal way",
            "        \"\"\"",
            "        self.session['x'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "",
            "        self.assertEqual(s.get_decoded(), {'x': 1})",
            "",
            "    def test_sessionmanager_save(self):",
            "        \"\"\"",
            "        Test SessionManager.save method",
            "        \"\"\"",
            "        # Create a session",
            "        self.session['y'] = 1",
            "        self.session.save()",
            "",
            "        s = Session.objects.get(session_key=self.session.session_key)",
            "        # Change it",
            "        Session.objects.save(s.session_key, {'y': 2}, s.expire_date)",
            "        # Clear cache, so that it will be retrieved from DB",
            "        del self.session._session_cache",
            "        self.assertEqual(self.session['y'], 2)",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.db\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        self.assertEqual(0, Session.objects.count())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the database before clearsessions...",
            "        self.assertEqual(2, Session.objects.count())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, Session.objects.count())",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class DatabaseSessionWithTimeZoneTests(DatabaseSessionTests):",
            "    pass",
            "",
            "",
            "class CacheDBSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CacheDBSession",
            "",
            "    @unittest.skipIf('DummyCache' in",
            "        settings.CACHES[settings.SESSION_CACHE_ALIAS]['BACKEND'],",
            "        \"Session saving tests require a real cache backend\")",
            "    def test_exists_searches_cache_first(self):",
            "        self.session.save()",
            "        with self.assertNumQueries(0):",
            "            self.assertTrue(self.session.exists(self.session.session_key))",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    @override_settings(SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # 21000 - CacheDB backend should respect SESSION_CACHE_ALIAS.",
            "        self.assertRaises(InvalidCacheBackendError, self.backend)",
            "",
            "",
            "@override_settings(USE_TZ=True)",
            "class CacheDBSessionWithTimeZoneTests(CacheDBSessionTests):",
            "    pass",
            "",
            "",
            "# Don't need DB flushing for these tests, so can use unittest.TestCase as base class",
            "class FileSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = FileSession",
            "",
            "    def setUp(self):",
            "        # Do file session tests in an isolated directory, and kill it after we're done.",
            "        self.original_session_file_path = settings.SESSION_FILE_PATH",
            "        self.temp_session_store = settings.SESSION_FILE_PATH = tempfile.mkdtemp()",
            "        # Reset the file session backend's internal caches",
            "        if hasattr(self.backend, '_storage_path'):",
            "            del self.backend._storage_path",
            "        super(FileSessionTests, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(FileSessionTests, self).tearDown()",
            "        settings.SESSION_FILE_PATH = self.original_session_file_path",
            "        shutil.rmtree(self.temp_session_store)",
            "",
            "    @override_settings(",
            "        SESSION_FILE_PATH=\"/if/this/directory/exists/you/have/a/weird/computer\")",
            "    def test_configuration_check(self):",
            "        del self.backend._storage_path",
            "        # Make sure the file backend checks for a good storage dir",
            "        self.assertRaises(ImproperlyConfigured, self.backend)",
            "",
            "    def test_invalid_key_backslash(self):",
            "        # Ensure we don't allow directory-traversal.",
            "        # This is tested directly on _key_to_file, as load() will swallow",
            "        # a SuspiciousOperation in the same way as an IOError - by creating",
            "        # a new session, making it unclear whether the slashes were detected.",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a\\\\b\\\\c\")",
            "",
            "    def test_invalid_key_forwardslash(self):",
            "        # Ensure we don't allow directory-traversal",
            "        self.assertRaises(InvalidSessionKey,",
            "                          self.backend()._key_to_file, \"a/b/c\")",
            "",
            "    @override_settings(SESSION_ENGINE=\"django.contrib.sessions.backends.file\")",
            "    def test_clearsessions_command(self):",
            "        \"\"\"",
            "        Test clearsessions command for clearing expired sessions.",
            "        \"\"\"",
            "        storage_path = self.backend._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        def count_sessions():",
            "            return len([session_file for session_file in os.listdir(storage_path)",
            "                if session_file.startswith(file_prefix)])",
            "",
            "        self.assertEqual(0, count_sessions())",
            "",
            "        # One object in the future",
            "        self.session['foo'] = 'bar'",
            "        self.session.set_expiry(3600)",
            "        self.session.save()",
            "",
            "        # One object in the past",
            "        other_session = self.backend()",
            "        other_session['foo'] = 'bar'",
            "        other_session.set_expiry(-3600)",
            "        other_session.save()",
            "",
            "        # Two sessions are in the filesystem before clearsessions...",
            "        self.assertEqual(2, count_sessions())",
            "        management.call_command('clearsessions')",
            "        # ... and one is deleted.",
            "        self.assertEqual(1, count_sessions())",
            "",
            "",
            "class CacheSessionTests(SessionTestsMixin, unittest.TestCase):",
            "",
            "    backend = CacheSession",
            "",
            "    def test_load_overlong_key(self):",
            "        # Some backends might issue a warning",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter(\"ignore\")",
            "            self.session._session_key = (string.ascii_letters + string.digits) * 20",
            "            self.assertEqual(self.session.load(), {})",
            "",
            "    def test_default_cache(self):",
            "        self.session.save()",
            "        self.assertNotEqual(caches['default'].get(self.session.cache_key), None)",
            "",
            "    @override_settings(CACHES={",
            "        'default': {",
            "            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',",
            "        },",
            "        'sessions': {",
            "            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',",
            "            'LOCATION': 'session',",
            "        },",
            "    }, SESSION_CACHE_ALIAS='sessions')",
            "    def test_non_default_cache(self):",
            "        # Re-initialize the session backend to make use of overridden settings.",
            "        self.session = self.backend()",
            "",
            "        self.session.save()",
            "        self.assertEqual(caches['default'].get(self.session.cache_key), None)",
            "        self.assertNotEqual(caches['sessions'].get(self.session.cache_key), None)",
            "",
            "",
            "class SessionMiddlewareTests(unittest.TestCase):",
            "",
            "    @override_settings(SESSION_COOKIE_SECURE=True)",
            "    def test_secure_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['secure'])",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=True)",
            "    def test_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertTrue(",
            "            response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "        self.assertIn(http_cookies.Morsel._reserved['httponly'],",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    @override_settings(SESSION_COOKIE_HTTPONLY=False)",
            "    def test_no_httponly_session_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "        self.assertFalse(response.cookies[settings.SESSION_COOKIE_NAME]['httponly'])",
            "",
            "        self.assertNotIn(http_cookies.Morsel._reserved['httponly'],",
            "                         str(response.cookies[settings.SESSION_COOKIE_NAME]))",
            "",
            "    def test_session_save_on_500(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Horrible error')",
            "        response.status_code = 500",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request the modifies the session",
            "        middleware.process_request(request)",
            "        request.session['hello'] = 'world'",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the value wasn't saved above.",
            "        self.assertNotIn('hello', request.session.load())",
            "",
            "    def test_session_delete_on_end(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Before deleting, there has to be an existing cookie",
            "        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'",
            "",
            "        # Simulate a request that ends the session",
            "        middleware.process_request(request)",
            "        request.session.flush()",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the cookie was deleted, not recreated.",
            "        # A deleted cookie header looks like:",
            "        #  Set-Cookie: sessionid=; expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/",
            "        self.assertEqual(",
            "            'Set-Cookie: {0}=; expires=Thu, 01-Jan-1970 00:00:00 GMT; '",
            "            'Max-Age=0; Path=/'.format(settings.SESSION_COOKIE_NAME),",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME])",
            "        )",
            "",
            "    @override_settings(SESSION_COOKIE_DOMAIN='.example.local')",
            "    def test_session_delete_on_end_with_custom_domain(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Before deleting, there has to be an existing cookie",
            "        request.COOKIES[settings.SESSION_COOKIE_NAME] = 'abc'",
            "",
            "        # Simulate a request that ends the session",
            "        middleware.process_request(request)",
            "        request.session.flush()",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # Check that the cookie was deleted, not recreated.",
            "        # A deleted cookie header with a custom domain looks like:",
            "        #  Set-Cookie: sessionid=; Domain=.example.local;",
            "        #              expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/",
            "        self.assertEqual(",
            "            'Set-Cookie: {}=; Domain=.example.local; expires=Thu, '",
            "            '01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/'.format(",
            "                settings.SESSION_COOKIE_NAME,",
            "            ),",
            "            str(response.cookies[settings.SESSION_COOKIE_NAME])",
            "        )",
            "",
            "    def test_flush_empty_without_session_cookie_doesnt_set_cookie(self):",
            "        request = RequestFactory().get('/')",
            "        response = HttpResponse('Session test')",
            "        middleware = SessionMiddleware()",
            "",
            "        # Simulate a request that ends the session",
            "        middleware.process_request(request)",
            "        request.session.flush()",
            "",
            "        # Handle the response through the middleware",
            "        response = middleware.process_response(request, response)",
            "",
            "        # A cookie should not be set.",
            "        self.assertEqual(response.cookies, {})",
            "        # The session is accessed so \"Vary: Cookie\" should be set.",
            "        self.assertEqual(response['Vary'], 'Cookie')",
            "",
            "",
            "class CookieSessionTests(SessionTestsMixin, TestCase):",
            "",
            "    backend = CookieSession",
            "",
            "    def test_save(self):",
            "        \"\"\"",
            "        This test tested exists() in the other session backends, but that",
            "        doesn't make sense for us.",
            "        \"\"\"",
            "        pass",
            "",
            "    def test_cycle(self):",
            "        \"\"\"",
            "        This test tested cycle_key() which would create a new session",
            "        key for the same session data. But we can't invalidate previously",
            "        signed cookies (other than letting them expire naturally) so",
            "        testing for this behavior is meaningless.",
            "        \"\"\"",
            "        pass",
            "",
            "    @unittest.expectedFailure",
            "    def test_actual_expiry(self):",
            "        # The cookie backend doesn't handle non-default expiry dates, see #19201",
            "        super(CookieSessionTests, self).test_actual_expiry()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "django.contrib.sessions.tests.SessionMiddlewareTests.self",
            "mechanicalsoup.form"
        ]
    }
}