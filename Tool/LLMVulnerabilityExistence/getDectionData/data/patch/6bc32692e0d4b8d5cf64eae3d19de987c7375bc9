{
    "src/AccessControl/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " # This has to happen early so things get initialized properly"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from AccessControl.Implementation import setImplementation"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from AccessControl.safe_formatter import safe_format"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from AccessControl.safe_formatter import safe_format_map"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from AccessControl.SecurityInfo import ACCESS_NONE"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from AccessControl.SecurityInfo import ACCESS_PRIVATE"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from AccessControl.SecurityInfo import ACCESS_PUBLIC"
            },
            "7": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " # That one needs special handling to avoid access to attributes."
            },
            "8": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " rules = {m: True for m in dir(str) if not m.startswith('_')}"
            },
            "9": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " rules['format'] = safe_format"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+rules['format_map'] = safe_format_map"
            },
            "11": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " allow_type(str, rules)"
            },
            "12": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " zodbupdate_decode_dict = {"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "# This has to happen early so things get initialized properly",
            "from AccessControl.Implementation import setImplementation",
            "from AccessControl.safe_formatter import safe_format",
            "from AccessControl.SecurityInfo import ACCESS_NONE",
            "from AccessControl.SecurityInfo import ACCESS_PRIVATE",
            "from AccessControl.SecurityInfo import ACCESS_PUBLIC",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from AccessControl.SecurityInfo import ModuleSecurityInfo",
            "from AccessControl.SecurityInfo import allow_class",
            "from AccessControl.SecurityInfo import allow_module",
            "from AccessControl.SecurityInfo import secureModule",
            "from AccessControl.SecurityManagement import getSecurityManager",
            "from AccessControl.SecurityManagement import setSecurityPolicy",
            "from AccessControl.SimpleObjectPolicies import allow_type",
            "from AccessControl.unauthorized import Unauthorized",
            "from AccessControl.ZopeGuards import full_write_guard",
            "from AccessControl.ZopeGuards import get_safe_globals",
            "from AccessControl.ZopeGuards import safe_builtins",
            "",
            "",
            "ModuleSecurityInfo('AccessControl').declarePublic('getSecurityManager')  # NOQA",
            "",
            "# allow imports of utility_builtins",
            "",
            "for name in ('string', 'math', 'random', 'sets'):",
            "    ModuleSecurityInfo(name).setDefaultAccess('allow')",
            "",
            "ModuleSecurityInfo('DateTime').declarePublic('DateTime')  # NOQA: D001",
            "",
            "# We want to allow all methods on string type except \"format\".",
            "# That one needs special handling to avoid access to attributes.",
            "rules = {m: True for m in dir(str) if not m.startswith('_')}",
            "rules['format'] = safe_format",
            "allow_type(str, rules)",
            "",
            "zodbupdate_decode_dict = {",
            "    'AccessControl.users User name': 'utf-8',",
            "    'AccessControl.users User __': 'utf-8',",
            "}"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "# This has to happen early so things get initialized properly",
            "from AccessControl.Implementation import setImplementation",
            "from AccessControl.safe_formatter import safe_format",
            "from AccessControl.safe_formatter import safe_format_map",
            "from AccessControl.SecurityInfo import ACCESS_NONE",
            "from AccessControl.SecurityInfo import ACCESS_PRIVATE",
            "from AccessControl.SecurityInfo import ACCESS_PUBLIC",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from AccessControl.SecurityInfo import ModuleSecurityInfo",
            "from AccessControl.SecurityInfo import allow_class",
            "from AccessControl.SecurityInfo import allow_module",
            "from AccessControl.SecurityInfo import secureModule",
            "from AccessControl.SecurityManagement import getSecurityManager",
            "from AccessControl.SecurityManagement import setSecurityPolicy",
            "from AccessControl.SimpleObjectPolicies import allow_type",
            "from AccessControl.unauthorized import Unauthorized",
            "from AccessControl.ZopeGuards import full_write_guard",
            "from AccessControl.ZopeGuards import get_safe_globals",
            "from AccessControl.ZopeGuards import safe_builtins",
            "",
            "",
            "ModuleSecurityInfo('AccessControl').declarePublic('getSecurityManager')  # NOQA",
            "",
            "# allow imports of utility_builtins",
            "",
            "for name in ('string', 'math', 'random', 'sets'):",
            "    ModuleSecurityInfo(name).setDefaultAccess('allow')",
            "",
            "ModuleSecurityInfo('DateTime').declarePublic('DateTime')  # NOQA: D001",
            "",
            "# We want to allow all methods on string type except \"format\".",
            "# That one needs special handling to avoid access to attributes.",
            "rules = {m: True for m in dir(str) if not m.startswith('_')}",
            "rules['format'] = safe_format",
            "rules['format_map'] = safe_format_map",
            "allow_type(str, rules)",
            "",
            "zodbupdate_decode_dict = {",
            "    'AccessControl.users User name': 'utf-8',",
            "    'AccessControl.users User __': 'utf-8',",
            "}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "src/AccessControl/safe_formatter.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         kwargs = _MagicFormatMapping(args, kwargs)"
            },
            "1": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         return self.vformat(self.value, args, kwargs)"
            },
            "2": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    def safe_format_map(self, kw):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        kwargs = _MagicFormatMapping((), kw)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        return self.vformat(self.value, (), kwargs)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " def safe_format(inst, method):"
            },
            "9": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "     \"\"\"Use our SafeFormatter that uses guarded_getattr for attribute access.\"\"\""
            },
            "10": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     return SafeFormatter(inst).safe_format"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+def safe_format_map(inst, method):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    return SafeFormatter(inst).safe_format_map"
            }
        },
        "frontPatchFile": [
            "import string",
            "from collections.abc import Mapping",
            "",
            "import _string",
            "",
            "from AccessControl.ZopeGuards import guarded_getattr",
            "from AccessControl.ZopeGuards import guarded_getitem",
            "",
            "",
            "def formatter_field_name_split(field_name):",
            "    return _string.formatter_field_name_split(field_name)",
            "",
            "",
            "class _MagicFormatMapping(Mapping):",
            "    \"\"\"Pulled from Jinja2.",
            "",
            "    This class implements a dummy wrapper to fix a bug in the Python",
            "    standard library for string formatting.",
            "",
            "    See http://bugs.python.org/issue13598 for information about why",
            "    this is necessary.",
            "    \"\"\"",
            "",
            "    def __init__(self, args, kwargs):",
            "        self._args = args",
            "        self._kwargs = kwargs",
            "        self._last_index = 0",
            "",
            "    def __getitem__(self, key):",
            "        if key == '':",
            "            idx = self._last_index",
            "            self._last_index += 1",
            "            try:",
            "                return self._args[idx]",
            "            except LookupError:",
            "                pass",
            "            key = str(idx)",
            "        return self._kwargs[key]",
            "",
            "    def __iter__(self):",
            "        return iter(self._kwargs)",
            "",
            "    def __len__(self):",
            "        return len(self._kwargs)",
            "",
            "",
            "class SafeFormatter(string.Formatter):",
            "    \"\"\"Formatter using guarded access.\"\"\"",
            "",
            "    def __init__(self, value):",
            "        self.value = value",
            "        super().__init__()",
            "",
            "    def get_field(self, field_name, args, kwargs):",
            "        \"\"\"Get the field value using guarded methods.\"\"\"",
            "        first, rest = formatter_field_name_split(field_name)",
            "",
            "        obj = self.get_value(first, args, kwargs)",
            "",
            "        # loop through the rest of the field_name, doing",
            "        #  getattr or getitem as needed",
            "        for is_attr, i in rest:",
            "            if is_attr:",
            "                obj = guarded_getattr(obj, i)",
            "            else:",
            "                obj = guarded_getitem(obj, i)",
            "",
            "        return obj, first",
            "",
            "    def safe_format(self, *args, **kwargs):",
            "        \"\"\"Safe variant of `format` method.\"\"\"",
            "        kwargs = _MagicFormatMapping(args, kwargs)",
            "        return self.vformat(self.value, args, kwargs)",
            "",
            "",
            "def safe_format(inst, method):",
            "    \"\"\"Use our SafeFormatter that uses guarded_getattr for attribute access.\"\"\"",
            "    return SafeFormatter(inst).safe_format"
        ],
        "afterPatchFile": [
            "import string",
            "from collections.abc import Mapping",
            "",
            "import _string",
            "",
            "from AccessControl.ZopeGuards import guarded_getattr",
            "from AccessControl.ZopeGuards import guarded_getitem",
            "",
            "",
            "def formatter_field_name_split(field_name):",
            "    return _string.formatter_field_name_split(field_name)",
            "",
            "",
            "class _MagicFormatMapping(Mapping):",
            "    \"\"\"Pulled from Jinja2.",
            "",
            "    This class implements a dummy wrapper to fix a bug in the Python",
            "    standard library for string formatting.",
            "",
            "    See http://bugs.python.org/issue13598 for information about why",
            "    this is necessary.",
            "    \"\"\"",
            "",
            "    def __init__(self, args, kwargs):",
            "        self._args = args",
            "        self._kwargs = kwargs",
            "        self._last_index = 0",
            "",
            "    def __getitem__(self, key):",
            "        if key == '':",
            "            idx = self._last_index",
            "            self._last_index += 1",
            "            try:",
            "                return self._args[idx]",
            "            except LookupError:",
            "                pass",
            "            key = str(idx)",
            "        return self._kwargs[key]",
            "",
            "    def __iter__(self):",
            "        return iter(self._kwargs)",
            "",
            "    def __len__(self):",
            "        return len(self._kwargs)",
            "",
            "",
            "class SafeFormatter(string.Formatter):",
            "    \"\"\"Formatter using guarded access.\"\"\"",
            "",
            "    def __init__(self, value):",
            "        self.value = value",
            "        super().__init__()",
            "",
            "    def get_field(self, field_name, args, kwargs):",
            "        \"\"\"Get the field value using guarded methods.\"\"\"",
            "        first, rest = formatter_field_name_split(field_name)",
            "",
            "        obj = self.get_value(first, args, kwargs)",
            "",
            "        # loop through the rest of the field_name, doing",
            "        #  getattr or getitem as needed",
            "        for is_attr, i in rest:",
            "            if is_attr:",
            "                obj = guarded_getattr(obj, i)",
            "            else:",
            "                obj = guarded_getitem(obj, i)",
            "",
            "        return obj, first",
            "",
            "    def safe_format(self, *args, **kwargs):",
            "        \"\"\"Safe variant of `format` method.\"\"\"",
            "        kwargs = _MagicFormatMapping(args, kwargs)",
            "        return self.vformat(self.value, args, kwargs)",
            "",
            "    def safe_format_map(self, kw):",
            "        kwargs = _MagicFormatMapping((), kw)",
            "        return self.vformat(self.value, (), kwargs)",
            "",
            "",
            "def safe_format(inst, method):",
            "    \"\"\"Use our SafeFormatter that uses guarded_getattr for attribute access.\"\"\"",
            "    return SafeFormatter(inst).safe_format",
            "",
            "",
            "def safe_format_map(inst, method):",
            "    return SafeFormatter(inst).safe_format_map"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create"
        ]
    },
    "src/AccessControl/tests/test_safe_formatter.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         self.assertRaises(Unauthorized,"
            },
            "1": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "                           SafeFormatter('{0[1]}').safe_format,"
            },
            "2": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "                           folder)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+    def test_format_map(self):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        from AccessControl.safe_formatter import SafeFormatter"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        # Accessing basic Python types in a basic Python list is fine."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        foo = list(['bar'])"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+        self.assertEqual(SafeFormatter('{foo[0]}')"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                         .safe_format_map(dict(foo=foo)),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                         'bar')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        # But for non-basic items or non-basic lists, we want run checks."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        folder = self._create_folder_with_mixed_contents()"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        # We can get the public items just fine:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        self.assertEqual(SafeFormatter('{foo[0]}')"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+                         .safe_format_map(dict(foo=folder)),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+                         '<Item public1>')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        self.assertEqual(SafeFormatter('{foo[2]}')"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+                         .safe_format_map(dict(foo=folder)),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+                         '<Item public2>')"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        # But not the private item:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        self.assertRaises(Unauthorized,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                          SafeFormatter('{foo[1]}').safe_format_map,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                          dict(foo=folder))"
            }
        },
        "frontPatchFile": [
            "import unittest",
            "",
            "from persistent import Persistent",
            "from zExceptions import Unauthorized",
            "",
            "",
            "SliceType = type(slice(0))",
            "",
            "",
            "class Item(Persistent):",
            "",
            "    def __init__(self, id, private=False):",
            "        self.id = id",
            "        if private:",
            "            self.__roles__ = ['Manager']",
            "        else:",
            "            self.__roles__ = ['Anonymous']",
            "",
            "    def __repr__(self):",
            "        return f'<Item {self.id}>'",
            "",
            "",
            "class Folder(Persistent):",
            "",
            "    def __init__(self, id):",
            "        self.id = id",
            "        self.item_dict = {}",
            "        self.item_list = []",
            "",
            "    def addItem(self, name, private=False):",
            "        item = Item(name, private)",
            "        # add as attribute for testing attribute access:",
            "        setattr(self, name, item)",
            "        # add in dict for testing named item access:",
            "        self.item_dict[name] = item",
            "        # add in list for testing numeric item access:",
            "        self.item_list.append(item)",
            "",
            "    def __getitem__(self, key):",
            "        # key can be a slice.",
            "        if isinstance(key, SliceType):",
            "            return self.item_list[key]",
            "        # Is this numeric (integer) access or string access?",
            "        if isinstance(key, int):",
            "            return self.item_list[key]",
            "        return self.item_dict[key]",
            "",
            "",
            "class FormatterTest(unittest.TestCase):",
            "    \"\"\"Test SafeFormatter and SafeStr.",
            "",
            "    There are some integration tests in Zope2 itself.",
            "    \"\"\"",
            "",
            "    def _create_folder_with_mixed_contents(self):",
            "        \"\"\"Create a folder with mixed public and private contents.\"\"\"",
            "        folder = Folder('folder')",
            "        folder.addItem('public1')",
            "        folder.addItem('private', private=True)",
            "        folder.addItem('public2')",
            "        return folder",
            "",
            "    def test_positional_argument_regression(self):",
            "        \"\"\"Testing fix of http://bugs.python.org/issue13598 issue.\"\"\"",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "        self.assertEqual(",
            "            SafeFormatter('{} {}').safe_format('foo', 'bar'),  # NOQA: P103",
            "            'foo bar')",
            "        self.assertEqual(SafeFormatter('{0} {1}').safe_format('foo', 'bar'),",
            "                         'foo bar')",
            "        self.assertEqual(SafeFormatter('{1} {0}').safe_format('foo', 'bar'),",
            "                         'bar foo')",
            "",
            "    def test_prevents_bad_string_formatting_attribute(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python attributes on a basic Python type is fine.",
            "        formatted = SafeFormatter('{0.upper}').safe_format('foo')",
            "        self.assertTrue(formatted.startswith('<built-in method upper'))",
            "        # unless the name is protected",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.__class__}').safe_format, 'foo')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.private}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_unicode_formatting_attribute(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python attributes on a basic Python type is fine.",
            "        formatted = SafeFormatter('{0.upper}').safe_format('foo')",
            "        self.assertTrue(formatted.startswith('<built-in method upper'))",
            "        # unless the name is protected",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.__class__}').safe_format, 'foo')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.private}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_string_formatting_item(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python dict is fine.",
            "        foo = {'bar': 'Can you see me?'}",
            "        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),",
            "                         'Can you see me?')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[private]}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_unicode_formatting_item(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python dict is fine.",
            "        foo = {'bar': 'Can you see me?'}",
            "        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),",
            "                         'Can you see me?')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[private]}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_string_formatting_key(self):",
            "        from persistent.list import PersistentList",
            "",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "        from AccessControl.ZopeGuards import guarded_getitem",
            "",
            "        # Accessing basic Python types in a basic Python list is fine.",
            "        foo = list(['bar'])",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),",
            "                         'bar')",
            "        self.assertEqual(guarded_getitem(foo, 0), 'bar')",
            "        # For basic Python types in a non-basic list, we guard the access.",
            "        foo = PersistentList(foo)",
            "        self.assertRaises(Unauthorized, guarded_getitem, foo, 0)",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[0]}').safe_format, foo)",
            "        # though we could allow access if we want:",
            "        foo.__allow_access_to_unprotected_subobjects__ = 1",
            "        self.assertEqual(guarded_getitem(foo, 0), 'bar')",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),",
            "                         'bar')",
            "        # For non-basic items we want run checks too.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[1]}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_unicode_formatting_key(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python list is fine.",
            "        foo = list(['bar'])",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),",
            "                         'bar')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[1]}').safe_format,",
            "                          folder)"
        ],
        "afterPatchFile": [
            "import unittest",
            "",
            "from persistent import Persistent",
            "from zExceptions import Unauthorized",
            "",
            "",
            "SliceType = type(slice(0))",
            "",
            "",
            "class Item(Persistent):",
            "",
            "    def __init__(self, id, private=False):",
            "        self.id = id",
            "        if private:",
            "            self.__roles__ = ['Manager']",
            "        else:",
            "            self.__roles__ = ['Anonymous']",
            "",
            "    def __repr__(self):",
            "        return f'<Item {self.id}>'",
            "",
            "",
            "class Folder(Persistent):",
            "",
            "    def __init__(self, id):",
            "        self.id = id",
            "        self.item_dict = {}",
            "        self.item_list = []",
            "",
            "    def addItem(self, name, private=False):",
            "        item = Item(name, private)",
            "        # add as attribute for testing attribute access:",
            "        setattr(self, name, item)",
            "        # add in dict for testing named item access:",
            "        self.item_dict[name] = item",
            "        # add in list for testing numeric item access:",
            "        self.item_list.append(item)",
            "",
            "    def __getitem__(self, key):",
            "        # key can be a slice.",
            "        if isinstance(key, SliceType):",
            "            return self.item_list[key]",
            "        # Is this numeric (integer) access or string access?",
            "        if isinstance(key, int):",
            "            return self.item_list[key]",
            "        return self.item_dict[key]",
            "",
            "",
            "class FormatterTest(unittest.TestCase):",
            "    \"\"\"Test SafeFormatter and SafeStr.",
            "",
            "    There are some integration tests in Zope2 itself.",
            "    \"\"\"",
            "",
            "    def _create_folder_with_mixed_contents(self):",
            "        \"\"\"Create a folder with mixed public and private contents.\"\"\"",
            "        folder = Folder('folder')",
            "        folder.addItem('public1')",
            "        folder.addItem('private', private=True)",
            "        folder.addItem('public2')",
            "        return folder",
            "",
            "    def test_positional_argument_regression(self):",
            "        \"\"\"Testing fix of http://bugs.python.org/issue13598 issue.\"\"\"",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "        self.assertEqual(",
            "            SafeFormatter('{} {}').safe_format('foo', 'bar'),  # NOQA: P103",
            "            'foo bar')",
            "        self.assertEqual(SafeFormatter('{0} {1}').safe_format('foo', 'bar'),",
            "                         'foo bar')",
            "        self.assertEqual(SafeFormatter('{1} {0}').safe_format('foo', 'bar'),",
            "                         'bar foo')",
            "",
            "    def test_prevents_bad_string_formatting_attribute(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python attributes on a basic Python type is fine.",
            "        formatted = SafeFormatter('{0.upper}').safe_format('foo')",
            "        self.assertTrue(formatted.startswith('<built-in method upper'))",
            "        # unless the name is protected",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.__class__}').safe_format, 'foo')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.private}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_unicode_formatting_attribute(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python attributes on a basic Python type is fine.",
            "        formatted = SafeFormatter('{0.upper}').safe_format('foo')",
            "        self.assertTrue(formatted.startswith('<built-in method upper'))",
            "        # unless the name is protected",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.__class__}').safe_format, 'foo')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0.public1}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0.public2}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0.private}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_string_formatting_item(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python dict is fine.",
            "        foo = {'bar': 'Can you see me?'}",
            "        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),",
            "                         'Can you see me?')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[private]}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_unicode_formatting_item(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python dict is fine.",
            "        foo = {'bar': 'Can you see me?'}",
            "        self.assertEqual(SafeFormatter('{0[bar]}').safe_format(foo),",
            "                         'Can you see me?')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[public1]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[public2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[private]}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_string_formatting_key(self):",
            "        from persistent.list import PersistentList",
            "",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "        from AccessControl.ZopeGuards import guarded_getitem",
            "",
            "        # Accessing basic Python types in a basic Python list is fine.",
            "        foo = list(['bar'])",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),",
            "                         'bar')",
            "        self.assertEqual(guarded_getitem(foo, 0), 'bar')",
            "        # For basic Python types in a non-basic list, we guard the access.",
            "        foo = PersistentList(foo)",
            "        self.assertRaises(Unauthorized, guarded_getitem, foo, 0)",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[0]}').safe_format, foo)",
            "        # though we could allow access if we want:",
            "        foo.__allow_access_to_unprotected_subobjects__ = 1",
            "        self.assertEqual(guarded_getitem(foo, 0), 'bar')",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),",
            "                         'bar')",
            "        # For non-basic items we want run checks too.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[1]}').safe_format,",
            "                          folder)",
            "",
            "    def test_prevents_bad_unicode_formatting_key(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python list is fine.",
            "        foo = list(['bar'])",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(foo),",
            "                         'bar')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{0[0]}').safe_format(folder),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{0[2]}').safe_format(folder),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{0[1]}').safe_format,",
            "                          folder)",
            "",
            "    def test_format_map(self):",
            "        from AccessControl.safe_formatter import SafeFormatter",
            "",
            "        # Accessing basic Python types in a basic Python list is fine.",
            "        foo = list(['bar'])",
            "        self.assertEqual(SafeFormatter('{foo[0]}')",
            "                         .safe_format_map(dict(foo=foo)),",
            "                         'bar')",
            "        # But for non-basic items or non-basic lists, we want run checks.",
            "        folder = self._create_folder_with_mixed_contents()",
            "        # We can get the public items just fine:",
            "        self.assertEqual(SafeFormatter('{foo[0]}')",
            "                         .safe_format_map(dict(foo=folder)),",
            "                         '<Item public1>')",
            "        self.assertEqual(SafeFormatter('{foo[2]}')",
            "                         .safe_format_map(dict(foo=folder)),",
            "                         '<Item public2>')",
            "        # But not the private item:",
            "        self.assertRaises(Unauthorized,",
            "                          SafeFormatter('{foo[1]}').safe_format_map,",
            "                          dict(foo=folder))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create",
            "src.AccessControl.tests.test_safe_formatter.FormatterTest.self"
        ]
    }
}