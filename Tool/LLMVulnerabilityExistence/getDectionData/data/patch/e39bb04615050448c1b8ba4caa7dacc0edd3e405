{
    "examples/fsqlalchemy1/tests/test_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " def create_fake_role(role_cls, name, permissions=None):"
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     if permissions:"
            },
            "3": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        permissions = \",\".join([p.strip() for p in permissions.split(\",\")])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        permissions = \",\".join(p.strip() for p in permissions.split(\",\"))"
            },
            "5": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     return role_cls(name=name, permissions=permissions)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2019 by J. Christopher Wagner (jwag). All rights reserved.",
            "",
            "",
            "class WrapApp:",
            "    def __init__(self, app, user_cls=None, role_cls=None, mocks=None):",
            "        \"\"\"Used to help create a app test fixture - with optionally passing in mocks\"\"\"",
            "        self.app = app",
            "        self.user_cls = user_cls",
            "        self.role_cls = role_cls",
            "        self.test_client = app.test_client()",
            "        self.mocks = mocks",
            "",
            "",
            "def set_current_user(app, user):",
            "    \"\"\"Set up so that when request is received,",
            "    the token will cause 'user' to be made the current_user",
            "    \"\"\"",
            "",
            "    def token_cb(request):",
            "        if request.headers.get(\"Authentication-Token\") == \"token\":",
            "            return user",
            "        return app.security.login_manager.anonymous_user()",
            "",
            "    app.security.login_manager.request_loader(token_cb)",
            "",
            "",
            "def create_fake_user(user_cls, email=\"unittest@me.com\", userid=1, roles=None):",
            "    \"\"\"Create fake user optionally with roles\"\"\"",
            "    user = user_cls()",
            "    user.email = email",
            "    user.id = userid",
            "    user.password = \"mypassword\"",
            "    user.active = True",
            "    if roles:",
            "        if isinstance(roles, list):",
            "            user.roles = roles",
            "        else:",
            "            user.roles = [roles]",
            "    return user",
            "",
            "",
            "def create_fake_role(role_cls, name, permissions=None):",
            "    if permissions:",
            "        permissions = \",\".join([p.strip() for p in permissions.split(\",\")])",
            "    return role_cls(name=name, permissions=permissions)"
        ],
        "afterPatchFile": [
            "# Copyright 2019 by J. Christopher Wagner (jwag). All rights reserved.",
            "",
            "",
            "class WrapApp:",
            "    def __init__(self, app, user_cls=None, role_cls=None, mocks=None):",
            "        \"\"\"Used to help create a app test fixture - with optionally passing in mocks\"\"\"",
            "        self.app = app",
            "        self.user_cls = user_cls",
            "        self.role_cls = role_cls",
            "        self.test_client = app.test_client()",
            "        self.mocks = mocks",
            "",
            "",
            "def set_current_user(app, user):",
            "    \"\"\"Set up so that when request is received,",
            "    the token will cause 'user' to be made the current_user",
            "    \"\"\"",
            "",
            "    def token_cb(request):",
            "        if request.headers.get(\"Authentication-Token\") == \"token\":",
            "            return user",
            "        return app.security.login_manager.anonymous_user()",
            "",
            "    app.security.login_manager.request_loader(token_cb)",
            "",
            "",
            "def create_fake_user(user_cls, email=\"unittest@me.com\", userid=1, roles=None):",
            "    \"\"\"Create fake user optionally with roles\"\"\"",
            "    user = user_cls()",
            "    user.email = email",
            "    user.id = userid",
            "    user.password = \"mypassword\"",
            "    user.active = True",
            "    if roles:",
            "        if isinstance(roles, list):",
            "            user.roles = roles",
            "        else:",
            "            user.roles = [roles]",
            "    return user",
            "",
            "",
            "def create_fake_role(role_cls, name, permissions=None):",
            "    if permissions:",
            "        permissions = \",\".join(p.strip() for p in permissions.split(\",\"))",
            "    return role_cls(name=name, permissions=permissions)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "44": [
                "create_fake_role"
            ]
        },
        "addLocation": []
    },
    "flask_security/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": "     :copyright: (c) 2012 by Matt Wright."
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     :copyright: (c) 2017 by CERN."
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     :copyright: (c) 2017 by ETH Zurich, Swiss Data Science Center."
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag)."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+    :copyright: (c) 2019-2021 by J. Christopher Wagner (jwag)."
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     :license: MIT, see LICENSE for more details."
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " \"\"\""
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from datetime import datetime, timedelta"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+import re"
            },
            "10": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import warnings"
            },
            "11": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import pkg_resources"
            },
            "13": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     \"REDIRECT_HOST\": None,"
            },
            "14": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     \"REDIRECT_BEHAVIOR\": None,"
            },
            "15": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     \"REDIRECT_ALLOW_SUBDOMAINS\": False,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    \"REDIRECT_VALIDATE_MODE\": None,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    \"REDIRECT_VALIDATE_RE\": r\"^/{4,}|\\\\{3,}|[\\s\\000-\\037][/\\\\]{2,}\","
            },
            "18": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "     \"FORGOT_PASSWORD_TEMPLATE\": \"security/forgot_password.html\","
            },
            "19": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     \"LOGIN_USER_TEMPLATE\": \"security/login_user.html\","
            },
            "20": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     \"REGISTER_USER_TEMPLATE\": \"security/register_user.html\","
            },
            "21": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 596,
                "PatchRowcode": "             _unauthz_handler=default_unauthz_handler,"
            },
            "22": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 597,
                "PatchRowcode": "         )"
            },
            "23": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 598,
                "PatchRowcode": "     )"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+    if \"redirect_validate_re\" in kwargs:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+        kwargs[\"_redirect_validate_re\"] = re.compile(kwargs[\"redirect_validate_re\"])"
            },
            "26": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 601,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": 602,
                "PatchRowcode": "     if \"login_manager\" not in kwargs:"
            },
            "28": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 603,
                "PatchRowcode": "         kwargs[\"login_manager\"] = _get_login_manager(app, anonymous_user)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "    flask_security.core",
            "    ~~~~~~~~~~~~~~~~~~~",
            "",
            "    Flask-Security core module",
            "",
            "    :copyright: (c) 2012 by Matt Wright.",
            "    :copyright: (c) 2017 by CERN.",
            "    :copyright: (c) 2017 by ETH Zurich, Swiss Data Science Center.",
            "    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "",
            "from datetime import datetime, timedelta",
            "import warnings",
            "",
            "import pkg_resources",
            "from flask import _request_ctx_stack, current_app, render_template",
            "from flask_login import AnonymousUserMixin, LoginManager",
            "from flask_login import UserMixin as BaseUserMixin",
            "from flask_login import current_user",
            "from flask_principal import Identity, Principal, RoleNeed, UserNeed, identity_loaded",
            "from itsdangerous import URLSafeTimedSerializer",
            "from passlib.context import CryptContext",
            "from werkzeug.datastructures import ImmutableList",
            "from werkzeug.local import LocalProxy",
            "",
            "from .babel import get_i18n_domain, have_babel",
            "from .decorators import (",
            "    default_reauthn_handler,",
            "    default_unauthn_handler,",
            "    default_unauthz_handler,",
            ")",
            "from .forms import (",
            "    ChangePasswordForm,",
            "    ConfirmRegisterForm,",
            "    ForgotPasswordForm,",
            "    LoginForm,",
            "    PasswordlessLoginForm,",
            "    RegisterForm,",
            "    ResetPasswordForm,",
            "    SendConfirmationForm,",
            "    TwoFactorVerifyCodeForm,",
            "    TwoFactorSetupForm,",
            "    TwoFactorRescueForm,",
            "    VerifyForm,",
            ")",
            "from .mail_util import MailUtil",
            "from .password_util import PasswordUtil",
            "from .phone_util import PhoneUtil",
            "from .twofactor import tf_send_security_token",
            "from .unified_signin import (",
            "    UnifiedSigninForm,",
            "    UnifiedSigninSetupForm,",
            "    UnifiedSigninSetupValidateForm,",
            "    UnifiedVerifyForm,",
            "    us_send_security_token,",
            ")",
            "from .totp import Totp",
            "from .utils import _",
            "from .utils import config_value as cv",
            "from .utils import (",
            "    FsJsonEncoder,",
            "    FsPermNeed,",
            "    csrf_cookie_handler,",
            "    default_want_json,",
            "    get_config,",
            "    get_identity_attribute,",
            "    get_identity_attributes,",
            "    get_message,",
            "    localize_callback,",
            "    set_request_attr,",
            "    uia_email_mapper,",
            "    url_for_security,",
            "    verify_and_update_password,",
            ")",
            "from .views import create_blueprint, default_render_json",
            "",
            "# Convenient references",
            "_security = LocalProxy(lambda: current_app.extensions[\"security\"])",
            "_datastore = LocalProxy(lambda: _security.datastore)",
            "",
            "# List of authentication mechanisms supported.",
            "AUTHN_MECHANISMS = (\"basic\", \"session\", \"token\")",
            "",
            "",
            "#: Default Flask-Security configuration",
            "_default_config = {",
            "    \"BLUEPRINT_NAME\": \"security\",",
            "    \"CLI_ROLES_NAME\": \"roles\",",
            "    \"CLI_USERS_NAME\": \"users\",",
            "    \"URL_PREFIX\": None,",
            "    \"SUBDOMAIN\": None,",
            "    \"FLASH_MESSAGES\": True,",
            "    \"I18N_DOMAIN\": \"flask_security\",",
            "    \"I18N_DIRNAME\": pkg_resources.resource_filename(\"flask_security\", \"translations\"),",
            "    \"EMAIL_VALIDATOR_ARGS\": None,",
            "    \"PASSWORD_HASH\": \"bcrypt\",",
            "    \"PASSWORD_SALT\": None,",
            "    \"PASSWORD_SINGLE_HASH\": {",
            "        \"django_argon2\",",
            "        \"django_bcrypt_sha256\",",
            "        \"django_pbkdf2_sha256\",",
            "        \"django_pbkdf2_sha1\",",
            "        \"django_bcrypt\",",
            "        \"django_salted_md5\",",
            "        \"django_salted_sha1\",",
            "        \"django_des_crypt\",",
            "        \"plaintext\",",
            "    },",
            "    \"PASSWORD_SCHEMES\": [",
            "        \"bcrypt\",",
            "        \"argon2\",",
            "        \"des_crypt\",",
            "        \"pbkdf2_sha256\",",
            "        \"pbkdf2_sha512\",",
            "        \"sha256_crypt\",",
            "        \"sha512_crypt\",",
            "        # And always last one...",
            "        \"plaintext\",",
            "    ],",
            "    \"PASSWORD_HASH_OPTIONS\": {},  # Deprecated at passlib 1.7",
            "    \"PASSWORD_HASH_PASSLIB_OPTIONS\": {",
            "        \"argon2__rounds\": 10  # 1.7.1 default is 2.",
            "    },  # >= 1.7.1 method to pass options.",
            "    \"PASSWORD_LENGTH_MIN\": 8,",
            "    \"PASSWORD_COMPLEXITY_CHECKER\": None,",
            "    \"PASSWORD_CHECK_BREACHED\": False,",
            "    \"PASSWORD_BREACHED_COUNT\": 1,",
            "    \"PASSWORD_NORMALIZE_FORM\": \"NFKD\",",
            "    \"DEPRECATED_PASSWORD_SCHEMES\": [\"auto\"],",
            "    \"LOGIN_URL\": \"/login\",",
            "    \"LOGOUT_URL\": \"/logout\",",
            "    \"REGISTER_URL\": \"/register\",",
            "    \"RESET_URL\": \"/reset\",",
            "    \"CHANGE_URL\": \"/change\",",
            "    \"CONFIRM_URL\": \"/confirm\",",
            "    \"VERIFY_URL\": \"/verify\",",
            "    \"TWO_FACTOR_SETUP_URL\": \"/tf-setup\",",
            "    \"TWO_FACTOR_TOKEN_VALIDATION_URL\": \"/tf-validate\",",
            "    \"TWO_FACTOR_RESCUE_URL\": \"/tf-rescue\",",
            "    \"LOGOUT_METHODS\": [\"GET\", \"POST\"],",
            "    \"POST_LOGIN_VIEW\": \"/\",",
            "    \"POST_LOGOUT_VIEW\": \"/\",",
            "    \"CONFIRM_ERROR_VIEW\": None,",
            "    \"POST_REGISTER_VIEW\": None,",
            "    \"POST_CONFIRM_VIEW\": None,",
            "    \"POST_RESET_VIEW\": None,",
            "    \"POST_CHANGE_VIEW\": None,",
            "    \"POST_VERIFY_VIEW\": None,",
            "    \"UNAUTHORIZED_VIEW\": None,",
            "    \"RESET_ERROR_VIEW\": None,",
            "    \"RESET_VIEW\": None,",
            "    \"LOGIN_ERROR_VIEW\": None,",
            "    \"REQUIRES_CONFIRMATION_ERROR_VIEW\": None,",
            "    \"REDIRECT_HOST\": None,",
            "    \"REDIRECT_BEHAVIOR\": None,",
            "    \"REDIRECT_ALLOW_SUBDOMAINS\": False,",
            "    \"FORGOT_PASSWORD_TEMPLATE\": \"security/forgot_password.html\",",
            "    \"LOGIN_USER_TEMPLATE\": \"security/login_user.html\",",
            "    \"REGISTER_USER_TEMPLATE\": \"security/register_user.html\",",
            "    \"RESET_PASSWORD_TEMPLATE\": \"security/reset_password.html\",",
            "    \"CHANGE_PASSWORD_TEMPLATE\": \"security/change_password.html\",",
            "    \"SEND_CONFIRMATION_TEMPLATE\": \"security/send_confirmation.html\",",
            "    \"SEND_LOGIN_TEMPLATE\": \"security/send_login.html\",",
            "    \"VERIFY_TEMPLATE\": \"security/verify.html\",",
            "    \"TWO_FACTOR_VERIFY_CODE_TEMPLATE\": \"security/two_factor_verify_code.html\",",
            "    \"TWO_FACTOR_SETUP_TEMPLATE\": \"security/two_factor_setup.html\",",
            "    \"CONFIRMABLE\": False,",
            "    \"REGISTERABLE\": False,",
            "    \"RECOVERABLE\": False,",
            "    \"TRACKABLE\": False,",
            "    \"PASSWORDLESS\": False,",
            "    \"CHANGEABLE\": False,",
            "    \"TWO_FACTOR\": False,",
            "    \"SEND_REGISTER_EMAIL\": True,",
            "    \"SEND_PASSWORD_CHANGE_EMAIL\": True,",
            "    \"SEND_PASSWORD_RESET_EMAIL\": True,",
            "    \"SEND_PASSWORD_RESET_NOTICE_EMAIL\": True,",
            "    \"LOGIN_WITHIN\": \"1 days\",",
            "    \"TWO_FACTOR_AUTHENTICATOR_VALIDITY\": 120,",
            "    \"TWO_FACTOR_MAIL_VALIDITY\": 300,",
            "    \"TWO_FACTOR_SMS_VALIDITY\": 120,",
            "    \"TWO_FACTOR_ALWAYS_VALIDATE\": True,",
            "    \"TWO_FACTOR_LOGIN_VALIDITY\": \"30 days\",",
            "    \"TWO_FACTOR_VALIDITY_SALT\": \"tf-validity-salt\",",
            "    \"TWO_FACTOR_VALIDITY_COOKIE\": {",
            "        \"httponly\": True,",
            "        \"secure\": False,",
            "        \"samesite\": None,",
            "    },",
            "    \"CONFIRM_EMAIL_WITHIN\": \"5 days\",",
            "    \"RESET_PASSWORD_WITHIN\": \"5 days\",",
            "    \"LOGIN_WITHOUT_CONFIRMATION\": False,",
            "    \"AUTO_LOGIN_AFTER_CONFIRM\": True,",
            "    \"EMAIL_SENDER\": LocalProxy(",
            "        lambda: current_app.config.get(\"MAIL_DEFAULT_SENDER\", \"no-reply@localhost\")",
            "    ),",
            "    \"TWO_FACTOR_RESCUE_MAIL\": \"no-reply@localhost\",",
            "    \"TOKEN_AUTHENTICATION_KEY\": \"auth_token\",",
            "    \"TOKEN_AUTHENTICATION_HEADER\": \"Authentication-Token\",",
            "    \"TOKEN_MAX_AGE\": None,",
            "    \"CONFIRM_SALT\": \"confirm-salt\",",
            "    \"RESET_SALT\": \"reset-salt\",",
            "    \"LOGIN_SALT\": \"login-salt\",",
            "    \"CHANGE_SALT\": \"change-salt\",",
            "    \"REMEMBER_SALT\": \"remember-salt\",",
            "    \"DEFAULT_REMEMBER_ME\": False,",
            "    \"DEFAULT_HTTP_AUTH_REALM\": _(\"Login Required\"),",
            "    \"EMAIL_SUBJECT_REGISTER\": _(\"Welcome\"),",
            "    \"EMAIL_SUBJECT_CONFIRM\": _(\"Please confirm your email\"),",
            "    \"EMAIL_SUBJECT_PASSWORDLESS\": _(\"Login instructions\"),",
            "    \"EMAIL_SUBJECT_PASSWORD_NOTICE\": _(\"Your password has been reset\"),",
            "    \"EMAIL_SUBJECT_PASSWORD_CHANGE_NOTICE\": _(\"Your password has been changed\"),",
            "    \"EMAIL_SUBJECT_PASSWORD_RESET\": _(\"Password reset instructions\"),",
            "    \"EMAIL_PLAINTEXT\": True,",
            "    \"EMAIL_HTML\": True,",
            "    \"EMAIL_SUBJECT_TWO_FACTOR\": _(\"Two-factor Login\"),",
            "    \"EMAIL_SUBJECT_TWO_FACTOR_RESCUE\": _(\"Two-factor Rescue\"),",
            "    \"USER_IDENTITY_ATTRIBUTES\": [",
            "        {\"email\": {\"mapper\": uia_email_mapper, \"case_insensitive\": True}}",
            "    ],",
            "    \"PHONE_REGION_DEFAULT\": \"US\",",
            "    \"FRESHNESS\": timedelta(hours=24),",
            "    \"FRESHNESS_GRACE_PERIOD\": timedelta(hours=1),",
            "    \"API_ENABLED_METHODS\": [\"session\", \"token\"],",
            "    \"HASHING_SCHEMES\": [\"sha256_crypt\", \"hex_md5\"],",
            "    \"DEPRECATED_HASHING_SCHEMES\": [\"hex_md5\"],",
            "    \"DATETIME_FACTORY\": datetime.utcnow,",
            "    \"TOTP_SECRETS\": None,",
            "    \"TOTP_ISSUER\": None,",
            "    \"SMS_SERVICE\": \"Dummy\",",
            "    \"SMS_SERVICE_CONFIG\": {",
            "        \"ACCOUNT_SID\": None,",
            "        \"AUTH_TOKEN\": None,",
            "        \"PHONE_NUMBER\": None,",
            "    },",
            "    \"TWO_FACTOR_REQUIRED\": False,",
            "    \"TWO_FACTOR_SECRET\": None,  # Deprecated - use TOTP_SECRETS",
            "    \"TWO_FACTOR_ENABLED_METHODS\": [\"email\", \"authenticator\", \"sms\"],",
            "    \"TWO_FACTOR_URI_SERVICE_NAME\": \"service_name\",  # Deprecated - use TOTP_ISSUER",
            "    \"TWO_FACTOR_SMS_SERVICE\": \"Dummy\",  # Deprecated - use SMS_SERVICE",
            "    \"TWO_FACTOR_SMS_SERVICE_CONFIG\": {  # Deprecated - use SMS_SERVICE_CONFIG",
            "        \"ACCOUNT_SID\": None,",
            "        \"AUTH_TOKEN\": None,",
            "        \"PHONE_NUMBER\": None,",
            "    },",
            "    \"UNIFIED_SIGNIN\": False,",
            "    \"US_SETUP_SALT\": \"us-setup-salt\",",
            "    \"US_SIGNIN_URL\": \"/us-signin\",",
            "    \"US_SIGNIN_SEND_CODE_URL\": \"/us-signin/send-code\",",
            "    \"US_SETUP_URL\": \"/us-setup\",",
            "    \"US_VERIFY_URL\": \"/us-verify\",",
            "    \"US_VERIFY_SEND_CODE_URL\": \"/us-verify/send-code\",",
            "    \"US_VERIFY_LINK_URL\": \"/us-verify-link\",",
            "    \"US_POST_SETUP_VIEW\": None,",
            "    \"US_SIGNIN_TEMPLATE\": \"security/us_signin.html\",",
            "    \"US_SETUP_TEMPLATE\": \"security/us_setup.html\",",
            "    \"US_VERIFY_TEMPLATE\": \"security/us_verify.html\",",
            "    \"US_ENABLED_METHODS\": [\"password\", \"email\", \"authenticator\", \"sms\"],",
            "    \"US_MFA_REQUIRED\": [\"password\", \"email\"],",
            "    \"US_TOKEN_VALIDITY\": 120,",
            "    \"US_EMAIL_SUBJECT\": _(\"Verification Code\"),",
            "    \"US_SETUP_WITHIN\": \"30 minutes\",",
            "    \"US_SIGNIN_REPLACES_LOGIN\": False,",
            "    \"CSRF_PROTECT_MECHANISMS\": AUTHN_MECHANISMS,",
            "    \"CSRF_IGNORE_UNAUTH_ENDPOINTS\": False,",
            "    \"CSRF_COOKIE\": {\"key\": None},",
            "    \"CSRF_HEADER\": \"X-XSRF-Token\",",
            "    \"CSRF_COOKIE_REFRESH_EACH_REQUEST\": False,",
            "    \"BACKWARDS_COMPAT_UNAUTHN\": False,",
            "    \"BACKWARDS_COMPAT_AUTH_TOKEN\": False,",
            "    \"JOIN_USER_ROLES\": True,",
            "}",
            "",
            "#: Default Flask-Security messages",
            "_default_messages = {",
            "    \"API_ERROR\": (_(\"Input not appropriate for requested API\"), \"error\"),",
            "    \"UNAUTHORIZED\": (_(\"You do not have permission to view this resource.\"), \"error\"),",
            "    \"UNAUTHENTICATED\": (",
            "        _(\"You are not authenticated. Please supply the correct credentials.\"),",
            "        \"error\",",
            "    ),",
            "    \"REAUTHENTICATION_REQUIRED\": (",
            "        _(\"You must re-authenticate to access this endpoint\"),",
            "        \"error\",",
            "    ),",
            "    \"CONFIRM_REGISTRATION\": (",
            "        _(\"Thank you. Confirmation instructions have been sent to %(email)s.\"),",
            "        \"success\",",
            "    ),",
            "    \"EMAIL_CONFIRMED\": (_(\"Thank you. Your email has been confirmed.\"), \"success\"),",
            "    \"ALREADY_CONFIRMED\": (_(\"Your email has already been confirmed.\"), \"info\"),",
            "    \"INVALID_CONFIRMATION_TOKEN\": (_(\"Invalid confirmation token.\"), \"error\"),",
            "    \"EMAIL_ALREADY_ASSOCIATED\": (",
            "        _(\"%(email)s is already associated with an account.\"),",
            "        \"error\",",
            "    ),",
            "    \"IDENTITY_ALREADY_ASSOCIATED\": (",
            "        _(",
            "            \"Identity attribute '%(attr)s' with value '%(value)s' is already\"",
            "            \" associated with an account.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"PASSWORD_MISMATCH\": (_(\"Password does not match\"), \"error\"),",
            "    \"RETYPE_PASSWORD_MISMATCH\": (_(\"Passwords do not match\"), \"error\"),",
            "    \"INVALID_REDIRECT\": (_(\"Redirections outside the domain are forbidden\"), \"error\"),",
            "    \"PASSWORD_RESET_REQUEST\": (",
            "        _(\"Instructions to reset your password have been sent to %(email)s.\"),",
            "        \"info\",",
            "    ),",
            "    \"PASSWORD_RESET_EXPIRED\": (",
            "        _(",
            "            \"You did not reset your password within %(within)s. \"",
            "            \"New instructions have been sent to %(email)s.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"INVALID_RESET_PASSWORD_TOKEN\": (_(\"Invalid reset password token.\"), \"error\"),",
            "    \"CONFIRMATION_REQUIRED\": (_(\"Email requires confirmation.\"), \"error\"),",
            "    \"CONFIRMATION_REQUEST\": (",
            "        _(\"Confirmation instructions have been sent to %(email)s.\"),",
            "        \"info\",",
            "    ),",
            "    \"CONFIRMATION_EXPIRED\": (",
            "        _(",
            "            \"You did not confirm your email within %(within)s. \"",
            "            \"New instructions to confirm your email have been sent \"",
            "            \"to %(email)s.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"LOGIN_EXPIRED\": (",
            "        _(",
            "            \"You did not login within %(within)s. New instructions to login \"",
            "            \"have been sent to %(email)s.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"LOGIN_EMAIL_SENT\": (",
            "        _(\"Instructions to login have been sent to %(email)s.\"),",
            "        \"success\",",
            "    ),",
            "    \"INVALID_LOGIN_TOKEN\": (_(\"Invalid login token.\"), \"error\"),",
            "    \"DISABLED_ACCOUNT\": (_(\"Account is disabled.\"), \"error\"),",
            "    \"EMAIL_NOT_PROVIDED\": (_(\"Email not provided\"), \"error\"),",
            "    \"INVALID_EMAIL_ADDRESS\": (_(\"Invalid email address\"), \"error\"),",
            "    \"INVALID_CODE\": (_(\"Invalid code\"), \"error\"),",
            "    \"PASSWORD_NOT_PROVIDED\": (_(\"Password not provided\"), \"error\"),",
            "    \"PASSWORD_NOT_SET\": (_(\"No password is set for this user\"), \"error\"),",
            "    \"PASSWORD_INVALID_LENGTH\": (",
            "        _(\"Password must be at least %(length)s characters\"),",
            "        \"error\",",
            "    ),",
            "    \"PASSWORD_TOO_SIMPLE\": (_(\"Password not complex enough\"), \"error\"),",
            "    \"PASSWORD_BREACHED\": (_(\"Password on breached list\"), \"error\"),",
            "    \"PASSWORD_BREACHED_SITE_ERROR\": (",
            "        _(\"Failed to contact breached passwords site\"),",
            "        \"error\",",
            "    ),",
            "    \"PHONE_INVALID\": (_(\"Phone number not valid e.g. missing country code\"), \"error\"),",
            "    \"USER_DOES_NOT_EXIST\": (_(\"Specified user does not exist\"), \"error\"),",
            "    \"INVALID_PASSWORD\": (_(\"Invalid password\"), \"error\"),",
            "    \"INVALID_PASSWORD_CODE\": (_(\"Password or code submitted is not valid\"), \"error\"),",
            "    \"PASSWORDLESS_LOGIN_SUCCESSFUL\": (_(\"You have successfully logged in.\"), \"success\"),",
            "    \"FORGOT_PASSWORD\": (_(\"Forgot password?\"), \"info\"),",
            "    \"PASSWORD_RESET\": (",
            "        _(",
            "            \"You successfully reset your password and you have been logged in \"",
            "            \"automatically.\"",
            "        ),",
            "        \"success\",",
            "    ),",
            "    \"PASSWORD_IS_THE_SAME\": (",
            "        _(\"Your new password must be different than your previous password.\"),",
            "        \"error\",",
            "    ),",
            "    \"PASSWORD_CHANGE\": (_(\"You successfully changed your password.\"), \"success\"),",
            "    \"LOGIN\": (_(\"Please log in to access this page.\"), \"info\"),",
            "    \"REFRESH\": (_(\"Please reauthenticate to access this page.\"), \"info\"),",
            "    \"REAUTHENTICATION_SUCCESSFUL\": (_(\"Reauthentication successful\"), \"info\"),",
            "    \"ANONYMOUS_USER_REQUIRED\": (",
            "        _(\"You can only access this endpoint when not logged in.\"),",
            "        \"error\",",
            "    ),",
            "    \"FAILED_TO_SEND_CODE\": (_(\"Failed to send code. Please try again later\"), \"error\"),",
            "    \"TWO_FACTOR_INVALID_TOKEN\": (_(\"Invalid Token\"), \"error\"),",
            "    \"TWO_FACTOR_LOGIN_SUCCESSFUL\": (_(\"Your token has been confirmed\"), \"success\"),",
            "    \"TWO_FACTOR_CHANGE_METHOD_SUCCESSFUL\": (",
            "        _(\"You successfully changed your two-factor method.\"),",
            "        \"success\",",
            "    ),",
            "    \"TWO_FACTOR_PERMISSION_DENIED\": (",
            "        _(\"You currently do not have permissions to access this page\"),",
            "        \"error\",",
            "    ),",
            "    \"TWO_FACTOR_METHOD_NOT_AVAILABLE\": (_(\"Marked method is not valid\"), \"error\"),",
            "    \"TWO_FACTOR_DISABLED\": (",
            "        _(\"You successfully disabled two factor authorization.\"),",
            "        \"success\",",
            "    ),",
            "    \"US_METHOD_NOT_AVAILABLE\": (_(\"Requested method is not valid\"), \"error\"),",
            "    \"US_SETUP_EXPIRED\": (",
            "        _(\"Setup must be completed within %(within)s. Please start over.\"),",
            "        \"error\",",
            "    ),",
            "    \"US_SETUP_SUCCESSFUL\": (_(\"Unified sign in setup successful\"), \"info\"),",
            "    \"US_SPECIFY_IDENTITY\": (_(\"You must specify a valid identity to sign in\"), \"error\"),",
            "    \"USE_CODE\": (_(\"Use this code to sign in: %(code)s.\"), \"info\"),",
            "}",
            "",
            "_default_forms = {",
            "    \"login_form\": LoginForm,",
            "    \"verify_form\": VerifyForm,",
            "    \"confirm_register_form\": ConfirmRegisterForm,",
            "    \"register_form\": RegisterForm,",
            "    \"forgot_password_form\": ForgotPasswordForm,",
            "    \"reset_password_form\": ResetPasswordForm,",
            "    \"change_password_form\": ChangePasswordForm,",
            "    \"send_confirmation_form\": SendConfirmationForm,",
            "    \"passwordless_login_form\": PasswordlessLoginForm,",
            "    \"two_factor_verify_code_form\": TwoFactorVerifyCodeForm,",
            "    \"two_factor_setup_form\": TwoFactorSetupForm,",
            "    \"two_factor_rescue_form\": TwoFactorRescueForm,",
            "    \"us_signin_form\": UnifiedSigninForm,",
            "    \"us_setup_form\": UnifiedSigninSetupForm,",
            "    \"us_setup_validate_form\": UnifiedSigninSetupValidateForm,",
            "    \"us_verify_form\": UnifiedVerifyForm,",
            "}",
            "",
            "",
            "def _user_loader(user_id):",
            "    \"\"\"Load based on fs_uniquifier (alternative_id).\"\"\"",
            "    user = _security.datastore.find_user(fs_uniquifier=str(user_id))",
            "    if user and user.active:",
            "        set_request_attr(\"fs_authn_via\", \"session\")",
            "        return user",
            "    return None",
            "",
            "",
            "def _request_loader(request):",
            "    # Short-circuit if we have already been called and verified.",
            "    # This can happen since Flask-Login will call us (if no session) and our own",
            "    # decorator @auth_token_required can call us.",
            "    # N.B. we don't call current_user here since that in fact might try and LOAD",
            "    # a user - which would call us again.",
            "    if all(hasattr(_request_ctx_stack.top, k) for k in [\"fs_authn_via\", \"user\"]):",
            "        if _request_ctx_stack.top.fs_authn_via == \"token\":",
            "            return _request_ctx_stack.top.user",
            "",
            "    header_key = _security.token_authentication_header",
            "    args_key = _security.token_authentication_key",
            "    header_token = request.headers.get(header_key, None)",
            "    token = request.args.get(args_key, header_token)",
            "    if request.is_json:",
            "        data = request.get_json(silent=True) or {}",
            "        if isinstance(data, dict):",
            "            token = data.get(args_key, token)",
            "",
            "    try:",
            "        data = _security.remember_token_serializer.loads(",
            "            token, max_age=_security.token_max_age",
            "        )",
            "",
            "        # Version 3.x generated tokens that map to data with 3 elements,",
            "        # and fs_uniquifier was on last element.",
            "        # Version 4.0.0 generates tokens that map to data with only 1 element,",
            "        # which maps to fs_uniquifier.",
            "        # Here we compute uniquifier_index so that we can pick up correct index for",
            "        # matching fs_uniquifier in version 4.0.0 even if token was created with",
            "        # version 3.x",
            "        uniquifier_index = 0 if len(data) == 1 else 2",
            "",
            "        if hasattr(_security.datastore.user_model, \"fs_token_uniquifier\"):",
            "            user = _security.datastore.find_user(",
            "                fs_token_uniquifier=data[uniquifier_index]",
            "            )",
            "        else:",
            "            user = _security.datastore.find_user(fs_uniquifier=data[uniquifier_index])",
            "        if not user.active:",
            "            user = None",
            "    except Exception:",
            "        user = None",
            "",
            "    if user and user.verify_auth_token(data):",
            "        set_request_attr(\"fs_authn_via\", \"token\")",
            "        return user",
            "",
            "    return _security.login_manager.anonymous_user()",
            "",
            "",
            "def _identity_loader():",
            "    if not isinstance(current_user._get_current_object(), AnonymousUserMixin):",
            "        identity = Identity(current_user.fs_uniquifier)",
            "        return identity",
            "",
            "",
            "def _on_identity_loaded(sender, identity):",
            "    if hasattr(current_user, \"fs_uniquifier\"):",
            "        identity.provides.add(UserNeed(current_user.fs_uniquifier))",
            "",
            "    for role in getattr(current_user, \"roles\", []):",
            "        identity.provides.add(RoleNeed(role.name))",
            "        for fsperm in role.get_permissions():",
            "            identity.provides.add(FsPermNeed(fsperm))",
            "",
            "    identity.user = current_user",
            "",
            "",
            "def _get_login_manager(app, anonymous_user):",
            "    lm = LoginManager()",
            "    lm.anonymous_user = anonymous_user or AnonymousUser",
            "    lm.localize_callback = localize_callback",
            "    lm.login_view = \"%s.login\" % cv(\"BLUEPRINT_NAME\", app=app)",
            "    lm.user_loader(_user_loader)",
            "    lm.request_loader(_request_loader)",
            "",
            "    if cv(\"FLASH_MESSAGES\", app=app):",
            "        lm.login_message, lm.login_message_category = cv(\"MSG_LOGIN\", app=app)",
            "        lm.needs_refresh_message, lm.needs_refresh_message_category = cv(",
            "            \"MSG_REFRESH\", app=app",
            "        )",
            "    else:",
            "        lm.login_message = None",
            "        lm.needs_refresh_message = None",
            "",
            "    lm.init_app(app)",
            "    return lm",
            "",
            "",
            "def _get_principal(app):",
            "    p = Principal(app, use_sessions=False)",
            "    p.identity_loader(_identity_loader)",
            "    return p",
            "",
            "",
            "def _get_pwd_context(app):",
            "    pw_hash = cv(\"PASSWORD_HASH\", app=app)",
            "    schemes = cv(\"PASSWORD_SCHEMES\", app=app)",
            "    deprecated = cv(\"DEPRECATED_PASSWORD_SCHEMES\", app=app)",
            "    if pw_hash not in schemes:",
            "        allowed = \", \".join(schemes[:-1]) + \" and \" + schemes[-1]",
            "        raise ValueError(",
            "            \"Invalid password hashing scheme %r. Allowed values are %s\"",
            "            % (pw_hash, allowed)",
            "        )",
            "    cc = CryptContext(",
            "        schemes=schemes,",
            "        default=pw_hash,",
            "        deprecated=deprecated,",
            "        **cv(\"PASSWORD_HASH_PASSLIB_OPTIONS\", app=app),",
            "    )",
            "    return cc",
            "",
            "",
            "def _get_hashing_context(app):",
            "    schemes = cv(\"HASHING_SCHEMES\", app=app)",
            "    deprecated = cv(\"DEPRECATED_HASHING_SCHEMES\", app=app)",
            "    return CryptContext(schemes=schemes, deprecated=deprecated)",
            "",
            "",
            "def _get_serializer(app, name):",
            "    secret_key = app.config.get(\"SECRET_KEY\")",
            "    salt = app.config.get(\"SECURITY_%s_SALT\" % name.upper())",
            "    return URLSafeTimedSerializer(secret_key=secret_key, salt=salt)",
            "",
            "",
            "def _get_state(app, datastore, anonymous_user=None, **kwargs):",
            "    for key, value in get_config(app).items():",
            "        kwargs[key.lower()] = value",
            "",
            "    kwargs.update(",
            "        dict(",
            "            app=app,",
            "            datastore=datastore,",
            "            principal=_get_principal(app),",
            "            pwd_context=_get_pwd_context(app),",
            "            hashing_context=_get_hashing_context(app),",
            "            i18n_domain=get_i18n_domain(app),",
            "            remember_token_serializer=_get_serializer(app, \"remember\"),",
            "            login_serializer=_get_serializer(app, \"login\"),",
            "            reset_serializer=_get_serializer(app, \"reset\"),",
            "            confirm_serializer=_get_serializer(app, \"confirm\"),",
            "            us_setup_serializer=_get_serializer(app, \"us_setup\"),",
            "            tf_validity_serializer=_get_serializer(app, \"two_factor_validity\"),",
            "            _context_processors={},",
            "            _unauthorized_callback=None,",
            "            _render_json=default_render_json,",
            "            _want_json=default_want_json,",
            "            _unauthn_handler=default_unauthn_handler,",
            "            _reauthn_handler=default_reauthn_handler,",
            "            _unauthz_handler=default_unauthz_handler,",
            "        )",
            "    )",
            "",
            "    if \"login_manager\" not in kwargs:",
            "        kwargs[\"login_manager\"] = _get_login_manager(app, anonymous_user)",
            "",
            "    for key, value in _default_forms.items():",
            "        if key not in kwargs or not kwargs[key]:",
            "            kwargs[key] = value",
            "",
            "    return _SecurityState(**kwargs)",
            "",
            "",
            "def _context_processor():",
            "    return dict(url_for_security=url_for_security, security=_security)",
            "",
            "",
            "class RoleMixin:",
            "    \"\"\"Mixin for `Role` model definitions\"\"\"",
            "",
            "    def __eq__(self, other):",
            "        return self.name == other or self.name == getattr(other, \"name\", None)",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    def __hash__(self):",
            "        return hash(self.name)",
            "",
            "    def get_permissions(self):",
            "        \"\"\"",
            "        Return set of permissions associated with role.",
            "",
            "        Supports permissions being a comma separated string, an iterable, or a set",
            "        based on how the underlying DB model was built.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        if hasattr(self, \"permissions\") and self.permissions:",
            "            if isinstance(self.permissions, set):",
            "                return self.permissions",
            "            elif isinstance(self.permissions, list):",
            "                return set(self.permissions)",
            "            else:",
            "                # Assume this is a comma separated list",
            "                return set(self.permissions.split(\",\"))",
            "        return set()",
            "",
            "    def add_permissions(self, permissions):",
            "        \"\"\"",
            "        Add one or more permissions to role.",
            "",
            "        :param permissions: a set, list, or single string.",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        .. deprecated:: 3.4.4",
            "            Use :meth:`.UserDatastore.add_permissions_to_role`",
            "        \"\"\"",
            "        if hasattr(self, \"permissions\"):",
            "            current_perms = self.get_permissions()",
            "            if isinstance(permissions, set):",
            "                perms = permissions",
            "            elif isinstance(permissions, list):",
            "                perms = set(permissions)",
            "            else:",
            "                perms = {permissions}",
            "            self.permissions = \",\".join(current_perms.union(perms))",
            "        else:  # pragma: no cover",
            "            raise NotImplementedError(\"Role model doesn't have permissions\")",
            "",
            "    def remove_permissions(self, permissions):",
            "        \"\"\"",
            "        Remove one or more permissions from role.",
            "",
            "        :param permissions: a set, list, or single string.",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        .. deprecated:: 3.4.4",
            "            Use :meth:`.UserDatastore.remove_permissions_from_role`",
            "        \"\"\"",
            "        if hasattr(self, \"permissions\"):",
            "            current_perms = self.get_permissions()",
            "            if isinstance(permissions, set):",
            "                perms = permissions",
            "            elif isinstance(permissions, list):",
            "                perms = set(permissions)",
            "            else:",
            "                perms = {permissions}",
            "            self.permissions = \",\".join(current_perms.difference(perms))",
            "        else:  # pragma: no cover",
            "            raise NotImplementedError(\"Role model doesn't have permissions\")",
            "",
            "",
            "class UserMixin(BaseUserMixin):",
            "    \"\"\"Mixin for `User` model definitions\"\"\"",
            "",
            "    def get_id(self):",
            "        \"\"\"Returns the user identification attribute. 'Alternative-token' for",
            "        Flask-Login. This is always ``fs_uniquifier``.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        return str(self.fs_uniquifier)",
            "",
            "    @property",
            "    def is_active(self):",
            "        \"\"\"Returns `True` if the user is active.\"\"\"",
            "        return self.active",
            "",
            "    def get_auth_token(self):",
            "        \"\"\"Constructs the user's authentication token.",
            "",
            "        :raises ValueError: If ``fs_token_uniquifier`` is part of model but not set.",
            "",
            "        Optionally use a separate uniquifier so that changing password doesn't",
            "        invalidate auth tokens.",
            "",
            "        This data MUST be securely signed using the ``remember_token_serializer``",
            "",
            "        .. versionchanged:: 4.0.0",
            "            If user model has ``fs_token_uniquifier`` - use that (raise ValueError",
            "            if not set). Otherwise fallback to using ``fs_uniqifier``.",
            "        \"\"\"",
            "",
            "        if hasattr(self, \"fs_token_uniquifier\"):",
            "            if not self.fs_token_uniquifier:",
            "                raise ValueError()",
            "            data = [str(self.fs_token_uniquifier)]",
            "        else:",
            "            data = [str(self.fs_uniquifier)]",
            "        return _security.remember_token_serializer.dumps(data)",
            "",
            "    def verify_auth_token(self, data):",
            "        \"\"\"",
            "        Perform additional verification of contents of auth token.",
            "        Prior to this being called the token has been validated (via signing)",
            "        and has not expired.",
            "",
            "        :param data: the data as formulated by :meth:`get_auth_token`",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        .. versionchanged:: 4.0.0",
            "            If user model has ``fs_token_uniquifier`` - use that otherwise",
            "            use ``fs_uniquifier``.",
            "        \"\"\"",
            "",
            "        # Version 3.x generated tokens that map to data with 3 elements,",
            "        # and fs_uniquifier was on last element.",
            "        # Version 4.0.0 generates tokens that map to data with only 1 element,",
            "        # which maps to fs_uniquifier.",
            "        # Here we compute uniquifier_index so that we can pick up correct index for",
            "        # matching fs_uniquifier in version 4.0.0 even if token was created with",
            "        # version 3.x",
            "        uniquifier_index = 0 if len(data) == 1 else 2",
            "",
            "        if hasattr(self, \"fs_token_uniquifier\"):",
            "            return data[uniquifier_index] == self.fs_token_uniquifier",
            "",
            "        return data[uniquifier_index] == self.fs_uniquifier",
            "",
            "    def has_role(self, role):",
            "        \"\"\"Returns `True` if the user identifies with the specified role.",
            "",
            "        :param role: A role name or `Role` instance\"\"\"",
            "        if isinstance(role, str):",
            "            return role in (role.name for role in self.roles)",
            "        else:",
            "            return role in self.roles",
            "",
            "    def has_permission(self, permission):",
            "        \"\"\"",
            "        Returns `True` if user has this permission (via a role it has).",
            "",
            "        :param permission: permission string name",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        \"\"\"",
            "        for role in self.roles:",
            "            if permission in role.get_permissions():",
            "                return True",
            "        return False",
            "",
            "    def get_security_payload(self):",
            "        \"\"\"Serialize user object as response payload.",
            "        Override this to return any/all of the user object in JSON responses.",
            "        Return a dict.",
            "        \"\"\"",
            "        return {}",
            "",
            "    def get_redirect_qparams(self, existing=None):",
            "        \"\"\"Return user info that will be added to redirect query params.",
            "",
            "        :param existing: A dict that will be updated.",
            "        :return: A dict whose keys will be query params and values will be query values.",
            "",
            "        .. versionadded:: 3.2.0",
            "",
            "        .. versionchanged:: 4.0.0",
            "            Add 'identity' using UserMixin.calc_username() - email is optional.",
            "        \"\"\"",
            "        if not existing:",
            "            existing = {}",
            "        if hasattr(self, \"email\"):",
            "            existing.update({\"email\": self.email})",
            "        existing.update({\"identity\": self.calc_username()})",
            "        return existing",
            "",
            "    def verify_and_update_password(self, password):",
            "        \"\"\"Returns ``True`` if the password is valid for the specified user.",
            "",
            "        Additionally, the hashed password in the database is updated if the",
            "        hashing algorithm happens to have changed.",
            "",
            "        N.B. you MUST call DB commit if you are using a session-based datastore",
            "        (such as SqlAlchemy) since the user instance might have been altered",
            "        (i.e. ``app.security.datastore.commit()``).",
            "        This is usually handled in the view.",
            "",
            "        :param password: A plaintext password to verify",
            "",
            "        .. versionadded:: 3.2.0",
            "        \"\"\"",
            "        return verify_and_update_password(password, self)",
            "",
            "    def calc_username(self):",
            "        \"\"\"Come up with the best 'username' based on how the app",
            "        is configured (via :py:data:`SECURITY_USER_IDENTITY_ATTRIBUTES`).",
            "        Returns the first non-null match (and converts to string).",
            "        In theory this should NEVER be the empty string unless the user",
            "        record isn't actually valid.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        cusername = None",
            "        for attr in get_identity_attributes():",
            "            cusername = getattr(self, attr, None)",
            "            if cusername is not None and len(str(cusername)) > 0:",
            "                break",
            "        return str(cusername) if cusername is not None else \"\"",
            "",
            "    def us_send_security_token(self, method, **kwargs):",
            "        \"\"\"Generate and send the security code for unified sign in.",
            "",
            "        :param method: The method in which the code will be sent",
            "        :param kwargs: Opaque parameters that are subject to change at any time",
            "        :return: None if successful, error message if not.",
            "",
            "        This is a wrapper around :meth:`us_send_security_token`",
            "        that can be overridden to manage any errors.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        try:",
            "            us_send_security_token(self, method, **kwargs)",
            "        except Exception:",
            "            return get_message(\"FAILED_TO_SEND_CODE\")[0]",
            "        return None",
            "",
            "    def tf_send_security_token(self, method, **kwargs):",
            "        \"\"\"Generate and send the security code for two-factor.",
            "",
            "        :param method: The method in which the code will be sent",
            "        :param kwargs: Opaque parameters that are subject to change at any time",
            "        :return: None if successful, error message if not.",
            "",
            "        This is a wrapper around :meth:`tf_send_security_token`",
            "        that can be overridden to manage any errors.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        try:",
            "            tf_send_security_token(self, method, **kwargs)",
            "        except Exception:",
            "            return get_message(\"FAILED_TO_SEND_CODE\")[0]",
            "        return None",
            "",
            "",
            "class AnonymousUser(AnonymousUserMixin):",
            "    \"\"\"AnonymousUser definition\"\"\"",
            "",
            "    def __init__(self):",
            "        self.roles = ImmutableList()",
            "",
            "    def has_role(self, *args):",
            "        \"\"\"Returns `False`\"\"\"",
            "        return False",
            "",
            "",
            "class _SecurityState:",
            "    def __init__(self, **kwargs):",
            "        for key, value in kwargs.items():",
            "            setattr(self, key.lower(), value)",
            "",
            "    def _add_ctx_processor(self, endpoint, fn):",
            "        group = self._context_processors.setdefault(endpoint, [])",
            "        fn not in group and group.append(fn)",
            "",
            "    def _run_ctx_processor(self, endpoint):",
            "        rv = {}",
            "        for g in [None, endpoint]:",
            "            for fn in self._context_processors.setdefault(g, []):",
            "                rv.update(fn())",
            "        return rv",
            "",
            "    def context_processor(self, fn):",
            "        self._add_ctx_processor(None, fn)",
            "",
            "    def forgot_password_context_processor(self, fn):",
            "        self._add_ctx_processor(\"forgot_password\", fn)",
            "",
            "    def login_context_processor(self, fn):",
            "        self._add_ctx_processor(\"login\", fn)",
            "",
            "    def register_context_processor(self, fn):",
            "        self._add_ctx_processor(\"register\", fn)",
            "",
            "    def reset_password_context_processor(self, fn):",
            "        self._add_ctx_processor(\"reset_password\", fn)",
            "",
            "    def change_password_context_processor(self, fn):",
            "        self._add_ctx_processor(\"change_password\", fn)",
            "",
            "    def send_confirmation_context_processor(self, fn):",
            "        self._add_ctx_processor(\"send_confirmation\", fn)",
            "",
            "    def send_login_context_processor(self, fn):",
            "        self._add_ctx_processor(\"send_login\", fn)",
            "",
            "    def verify_context_processor(self, fn):",
            "        self._add_ctx_processor(\"verify\", fn)",
            "",
            "    def mail_context_processor(self, fn):",
            "        self._add_ctx_processor(\"mail\", fn)",
            "",
            "    def tf_setup_context_processor(self, fn):",
            "        self._add_ctx_processor(\"tf_setup\", fn)",
            "",
            "    def tf_token_validation_context_processor(self, fn):",
            "        self._add_ctx_processor(\"tf_token_validation\", fn)",
            "",
            "    def us_signin_context_processor(self, fn):",
            "        self._add_ctx_processor(\"us_signin\", fn)",
            "",
            "    def us_setup_context_processor(self, fn):",
            "        self._add_ctx_processor(\"us_setup\", fn)",
            "",
            "    def us_verify_context_processor(self, fn):",
            "        self._add_ctx_processor(\"us_verify\", fn)",
            "",
            "    def unauthorized_handler(self, fn):",
            "        warnings.warn(",
            "            \"'unauthorized_handler' has been replaced with\"",
            "            \" 'unauthz_handler' and 'unauthn_handler'\",",
            "            DeprecationWarning,",
            "        )",
            "        self._unauthorized_callback = fn",
            "",
            "    def totp_factory(self, tf):",
            "        self._totp_factory = tf",
            "",
            "    def render_json(self, fn):",
            "        self._render_json = fn",
            "",
            "    def want_json(self, fn):",
            "        self._want_json = fn",
            "",
            "    def unauthz_handler(self, cb):",
            "        self._unauthz_handler = cb",
            "",
            "    def unauthn_handler(self, cb):",
            "        self._unauthn_handler = cb",
            "",
            "    def reauthn_handler(self, cb):",
            "        self._reauthn_handler = cb",
            "",
            "",
            "class Security:",
            "    \"\"\"The :class:`Security` class initializes the Flask-Security extension.",
            "",
            "    :param app: The application.",
            "    :param datastore: An instance of a user datastore.",
            "    :param register_blueprint: to register the Security blueprint or not.",
            "    :param login_form: set form for the login view",
            "    :param verify_form: set form for re-authentication due to freshness check",
            "    :param register_form: set form for the register view when",
            "            *SECURITY_CONFIRMABLE* is false",
            "    :param confirm_register_form: set form for the register view when",
            "            *SECURITY_CONFIRMABLE* is true",
            "    :param forgot_password_form: set form for the forgot password view",
            "    :param reset_password_form: set form for the reset password view",
            "    :param change_password_form: set form for the change password view",
            "    :param send_confirmation_form: set form for the send confirmation view",
            "    :param passwordless_login_form: set form for the passwordless login view",
            "    :param two_factor_setup_form: set form for the 2FA setup view",
            "    :param two_factor_verify_code_form: set form the the 2FA verify code view",
            "    :param two_factor_rescue_form: set form for the 2FA rescue view",
            "    :param us_signin_form: set form for the unified sign in view",
            "    :param us_setup_form: set form for the unified sign in setup view",
            "    :param us_setup_validate_form: set form for the unified sign in setup validate view",
            "    :param us_verify_form: set form for re-authenticating due to freshness check",
            "    :param anonymous_user: class to use for anonymous user",
            "    :param render_template: function to use to render templates. The default is Flask's",
            "     render_template() function.",
            "    :param json_encoder_cls: Class to use as blueprint.json_encoder.",
            "     Defaults to :class:`FsJsonEncoder`",
            "    :param totp_cls: Class to use as TOTP factory. Defaults to :class:`Totp`",
            "    :param phone_util_cls: Class to use for phone number utilities.",
            "     Defaults to :class:`PhoneUtil`",
            "    :param mail_util_cls: Class to use for sending emails. Defaults to :class:`MailUtil`",
            "    :param password_util_cls: Class to use for password normalization/validation.",
            "     Defaults to :class:`PasswordUtil`",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``verify_form`` added as part of freshness/re-authentication",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``us_signin_form``, ``us_setup_form``, ``us_setup_validate_form``, and",
            "        ``us_verify_form`` added as part of the :ref:`unified-sign-in` feature.",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``totp_cls`` added to enable applications to implement replay protection - see",
            "        :py:class:`Totp`.",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``phone_util_cls`` added to allow different phone number",
            "         parsing implementations - see :py:class:`PhoneUtil`",
            "",
            "    .. versionadded:: 4.0.0",
            "        ``mail_util_cls`` added to isolate mailing handling.",
            "        ``password_util_cls`` added to encapsulate password validation/normalization.",
            "",
            "    .. deprecated:: 4.0.0",
            "        ``send_mail`` and ``send_mail_task``. Replaced with ``mail_util_cls``.",
            "        ``two_factor_verify_password_form`` removed.",
            "        ``password_validator`` removed in favor of the new ``password_util_cls``.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, app=None, datastore=None, register_blueprint=True, **kwargs):",
            "",
            "        self.app = app",
            "        self._datastore = datastore",
            "        self._register_blueprint = register_blueprint",
            "        self._kwargs = kwargs",
            "",
            "        self._state = None  # set by init_app",
            "        if app is not None and datastore is not None:",
            "            self._state = self.init_app(",
            "                app, datastore, register_blueprint=register_blueprint, **kwargs",
            "            )",
            "",
            "    def init_app(self, app, datastore=None, register_blueprint=None, **kwargs):",
            "        \"\"\"Initializes the Flask-Security extension for the specified",
            "        application and datastore implementation.",
            "",
            "        :param app: The application.",
            "        :param datastore: An instance of a user datastore.",
            "        :param register_blueprint: to register the Security blueprint or not.",
            "        \"\"\"",
            "        self.app = app",
            "",
            "        if datastore is None:",
            "            datastore = self._datastore",
            "",
            "        if register_blueprint is None:",
            "            register_blueprint = self._register_blueprint",
            "",
            "        for key, value in self._kwargs.items():",
            "            kwargs.setdefault(key, value)",
            "",
            "        if \"render_template\" not in kwargs:",
            "            kwargs.setdefault(\"render_template\", self.render_template)",
            "        if \"json_encoder_cls\" not in kwargs:",
            "            kwargs.setdefault(\"json_encoder_cls\", FsJsonEncoder)",
            "        if \"totp_cls\" not in kwargs:",
            "            kwargs.setdefault(\"totp_cls\", Totp)",
            "        if \"phone_util_cls\" not in kwargs:",
            "            kwargs.setdefault(\"phone_util_cls\", PhoneUtil)",
            "        if \"mail_util_cls\" not in kwargs:",
            "            kwargs.setdefault(\"mail_util_cls\", MailUtil)",
            "        if \"password_util_cls\" not in kwargs:",
            "            kwargs.setdefault(\"password_util_cls\", PasswordUtil)",
            "",
            "        # default post redirects to APPLICATION_ROOT, which itself defaults to \"/\"",
            "        app.config.setdefault(",
            "            \"SECURITY_POST_LOGIN_VIEW\", app.config.get(\"APPLICATION_ROOT\", \"/\")",
            "        )",
            "        app.config.setdefault(",
            "            \"SECURITY_POST_LOGOUT_VIEW\", app.config.get(\"APPLICATION_ROOT\", \"/\")",
            "        )",
            "",
            "        for key, value in _default_config.items():",
            "            app.config.setdefault(\"SECURITY_\" + key, value)",
            "",
            "        for key, value in _default_messages.items():",
            "            app.config.setdefault(\"SECURITY_MSG_\" + key, value)",
            "",
            "        identity_loaded.connect_via(app)(_on_identity_loaded)",
            "",
            "        self._state = state = _get_state(app, datastore, **kwargs)",
            "        if hasattr(datastore, \"user_model\") and not hasattr(",
            "            datastore.user_model, \"fs_uniquifier\"",
            "        ):  # pragma: no cover",
            "            raise ValueError(\"User model must contain fs_uniquifier as of 4.0.0\")",
            "",
            "        if register_blueprint:",
            "            bp = create_blueprint(",
            "                app, state, __name__, json_encoder=kwargs[\"json_encoder_cls\"]",
            "            )",
            "            app.register_blueprint(bp)",
            "            app.context_processor(_context_processor)",
            "",
            "        @app.before_first_request",
            "        def _register_i18n():",
            "            # This is only not registered if Flask-Babel isn't installed...",
            "            if \"_\" not in app.jinja_env.globals:",
            "                current_app.jinja_env.globals[\"_\"] = state.i18n_domain.gettext",
            "            # Register so other packages can reference our translations.",
            "            current_app.jinja_env.globals[\"_fsdomain\"] = state.i18n_domain.gettext",
            "",
            "        @app.before_first_request",
            "        def _csrf_init():",
            "            # various config checks - some of these are opinionated in that there",
            "            # could be a reason for some of these combinations - but in general",
            "            # they cause strange behavior.",
            "            # WTF_CSRF_ENABLED defaults to True if not set in Flask-WTF",
            "            if not current_app.config.get(\"WTF_CSRF_ENABLED\", True):",
            "                return",
            "            csrf = current_app.extensions.get(\"csrf\", None)",
            "",
            "            # If they don't want ALL mechanisms protected, then they must",
            "            # set WTF_CSRF_CHECK_DEFAULT=False so that our decorators get control.",
            "            if cv(\"CSRF_PROTECT_MECHANISMS\") != AUTHN_MECHANISMS:",
            "                if not csrf:",
            "                    # This isn't good.",
            "                    raise ValueError(",
            "                        \"CSRF_PROTECT_MECHANISMS defined but\"",
            "                        \" CsrfProtect not part of application\"",
            "                    )",
            "                if current_app.config.get(\"WTF_CSRF_CHECK_DEFAULT\", True):",
            "                    raise ValueError(",
            "                        \"WTF_CSRF_CHECK_DEFAULT must be set to False if\"",
            "                        \" CSRF_PROTECT_MECHANISMS is set\"",
            "                    )",
            "            # We don't get control unless they turn off WTF_CSRF_CHECK_DEFAULT if",
            "            # they have enabled global CSRFProtect.",
            "            if (",
            "                cv(\"CSRF_IGNORE_UNAUTH_ENDPOINTS\")",
            "                and csrf",
            "                and current_app.config.get(\"WTF_CSRF_CHECK_DEFAULT\", False)",
            "            ):",
            "                raise ValueError(",
            "                    \"To ignore unauth endpoints you must set WTF_CSRF_CHECK_DEFAULT\"",
            "                    \" to False\"",
            "                )",
            "",
            "            csrf_cookie = cv(\"CSRF_COOKIE\")",
            "            if csrf_cookie and csrf_cookie[\"key\"] and not csrf:",
            "                # Common use case is for cookie value to be used as contents for header",
            "                # which is only looked at when CsrfProtect is initialized.",
            "                # Yes, this is opinionated - they can always get CSRF token via:",
            "                # 'get /login'",
            "                raise ValueError(",
            "                    \"CSRF_COOKIE defined however CsrfProtect not part of application\"",
            "                )",
            "",
            "            if csrf:",
            "                csrf.exempt(\"flask_security.views.logout\")",
            "            if csrf_cookie and csrf_cookie[\"key\"]:",
            "                current_app.after_request(csrf_cookie_handler)",
            "                # Add configured header to WTF_CSRF_HEADERS",
            "                current_app.config[\"WTF_CSRF_HEADERS\"].append(cv(\"CSRF_HEADER\"))",
            "",
            "        @app.before_first_request",
            "        def check_babel():",
            "            # Verify that if Flask-Babel or Flask-BabelEx is installed",
            "            # it has been initialized",
            "            if have_babel() and \"babel\" not in app.extensions:",
            "                raise ValueError(",
            "                    \"Flask-Babel or Flask-BabelEx is installed but not initialized\"",
            "                )",
            "",
            "        state._phone_util = state.phone_util_cls(app)",
            "        state._mail_util = state.mail_util_cls(app)",
            "        state._password_util = state.password_util_cls(app)",
            "",
            "        app.extensions[\"security\"] = state",
            "",
            "        if hasattr(app, \"cli\"):",
            "            from .cli import users, roles",
            "",
            "            if state.cli_users_name:",
            "                app.cli.add_command(users, state.cli_users_name)",
            "            if state.cli_roles_name:",
            "                app.cli.add_command(roles, state.cli_roles_name)",
            "",
            "        # Migrate from TWO_FACTOR config to generic config.",
            "        for newc, oldc in [",
            "            (\"SECURITY_SMS_SERVICE\", \"SECURITY_TWO_FACTOR_SMS_SERVICE\"),",
            "            (\"SECURITY_SMS_SERVICE_CONFIG\", \"SECURITY_TWO_FACTOR_SMS_SERVICE_CONFIG\"),",
            "            (\"SECURITY_TOTP_SECRETS\", \"SECURITY_TWO_FACTOR_SECRET\"),",
            "            (\"SECURITY_TOTP_ISSUER\", \"SECURITY_TWO_FACTOR_URI_SERVICE_NAME\"),",
            "        ]:",
            "            if not app.config.get(newc, None):",
            "                app.config[newc] = app.config.get(oldc, None)",
            "",
            "        # Check for pre-4.0 SECURITY_USER_IDENTITY_ATTRIBUTES format",
            "        for uia in cv(\"USER_IDENTITY_ATTRIBUTES\", app=app):  # pragma: no cover",
            "            if not isinstance(uia, dict):",
            "                raise ValueError(",
            "                    \"SECURITY_USER_IDENTITY_ATTRIBUTES changed semantics\"",
            "                    \" in 4.0 - please see release notes.\"",
            "                )",
            "            if len(list(uia.keys())) != 1:",
            "                raise ValueError(",
            "                    \"Each element in SECURITY_USER_IDENTITY_ATTRIBUTES\"",
            "                    \" must have one and only one key.\"",
            "                )",
            "",
            "        # Two factor configuration checks and setup",
            "        multi_factor = False",
            "        if cv(\"UNIFIED_SIGNIN\", app=app):",
            "            multi_factor = True",
            "            if len(cv(\"US_ENABLED_METHODS\", app=app)) < 1:",
            "                raise ValueError(\"Must configure some US_ENABLED_METHODS\")",
            "            if \"sms\" in cv(",
            "                \"US_ENABLED_METHODS\", app=app",
            "            ) and not get_identity_attribute(\"us_phone_number\", app=app):",
            "                warnings.warn(",
            "                    \"'sms' was enabled in SECURITY_US_ENABLED_METHODS;\"",
            "                    \" however 'us_phone_number' not configured in\"",
            "                    \" SECURITY_USER_IDENTITY_ATTRIBUTES\"",
            "                )",
            "        if cv(\"TWO_FACTOR\", app=app):",
            "            multi_factor = True",
            "            if len(cv(\"TWO_FACTOR_ENABLED_METHODS\", app=app)) < 1:",
            "                raise ValueError(\"Must configure some TWO_FACTOR_ENABLED_METHODS\")",
            "",
            "        if multi_factor:",
            "            # cryptography is used to encrypt TOTP secrets",
            "            self._check_modules(\"cryptography\", \"TWO_FACTOR or UNIFIED_SIGNIN\")",
            "",
            "            need_qrcode = (",
            "                cv(\"UNIFIED_SIGNIN\", app=app)",
            "                and \"authenticator\" in cv(\"US_ENABLED_METHODS\", app=app)",
            "            ) or (",
            "                cv(\"TWO_FACTOR\", app=app)",
            "                and \"authenticator\" in cv(\"TWO_FACTOR_ENABLED_METHODS\", app=app)",
            "            )",
            "            if need_qrcode:",
            "                self._check_modules(\"pyqrcode\", \"TWO_FACTOR or UNIFIED_SIGNIN\")",
            "",
            "            need_sms = (",
            "                cv(\"UNIFIED_SIGNIN\", app=app)",
            "                and \"sms\" in cv(\"US_ENABLED_METHODS\", app=app)",
            "            ) or (",
            "                cv(\"TWO_FACTOR\", app=app)",
            "                and \"sms\" in cv(\"TWO_FACTOR_ENABLED_METHODS\", app=app)",
            "            )",
            "            if need_sms:",
            "                sms_service = cv(\"SMS_SERVICE\", app=app)",
            "                if sms_service == \"Twilio\":  # pragma: no cover",
            "                    self._check_modules(\"twilio\", \"SMS\")",
            "                if state.phone_util_cls == PhoneUtil:",
            "                    self._check_modules(\"phonenumbers\", \"SMS\")",
            "",
            "            secrets = cv(\"TOTP_SECRETS\", app=app)",
            "            issuer = cv(\"TOTP_ISSUER\", app=app)",
            "            if not secrets or not issuer:",
            "                raise ValueError(\"Both TOTP_SECRETS and TOTP_ISSUER must be set\")",
            "            state.totp_factory(state.totp_cls(secrets, issuer))",
            "",
            "        if cv(\"PASSWORD_COMPLEXITY_CHECKER\", app=app) == \"zxcvbn\":",
            "            self._check_modules(\"zxcvbn\", \"PASSWORD_COMPLEXITY_CHECKER\")",
            "        return state",
            "",
            "    def _check_modules(self, module, config_name):  # pragma: no cover",
            "        from importlib.util import find_spec",
            "",
            "        module_exists = find_spec(module)",
            "        if not module_exists:",
            "            raise ValueError(f\"{module} is required for {config_name}\")",
            "",
            "        return module_exists",
            "",
            "    def render_template(self, *args, **kwargs):",
            "        return render_template(*args, **kwargs)",
            "",
            "    def render_json(self, cb):",
            "        \"\"\"Callback to render response payload as JSON.",
            "",
            "        :param cb: Callback function with",
            "         signature (payload, code, headers=None, user=None)",
            "",
            "            :payload: A dict. Please see the formal API spec for details.",
            "            :code: Http status code",
            "            :headers: Headers object",
            "            :user: the UserDatastore object (or None). Note that this is usually",
            "                           the same as current_user - but not always.",
            "",
            "        The default implementation simply returns::",
            "",
            "                headers[\"Content-Type\"] = \"application/json\"",
            "                payload = dict(meta=dict(code=code), response=payload)",
            "                return make_response(jsonify(payload), code, headers)",
            "",
            "        .. important::",
            "            Be aware the Flask's ``jsonify`` method will first look to see if a",
            "            ``json_encoder`` has been set on the blueprint corresponding to the current",
            "            request. If not then it looks for a ``json_encoder`` registered on the app;",
            "            and finally uses Flask's default JSONEncoder class. Flask-Security registers",
            "            :func:`FsJsonEncoder` as its blueprint json_encoder.",
            "",
            "",
            "        This can be used by applications to unify all their JSON API responses.",
            "        This is called in a request context and should return a Response or something",
            "        Flask can create a Response from.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._render_json = cb",
            "",
            "    def want_json(self, fn):",
            "        \"\"\"Function that returns True if response should be JSON (based on the request)",
            "",
            "        :param fn: Function with the following signature (request)",
            "",
            "            :request: Werkzueg/Flask request",
            "",
            "        The default implementation returns True if either the Content-Type is",
            "        \"application/json\" or the best Accept header value is \"application/json\".",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._want_json = fn",
            "",
            "    def unauthz_handler(self, cb):",
            "        \"\"\"",
            "        Callback for failed authorization.",
            "        This is called by the :func:`roles_required`, :func:`roles_accepted`,",
            "        :func:`permissions_required`, or :func:`permissions_accepted`",
            "        if a role or permission is missing.",
            "",
            "        :param cb: Callback function with signature (func, params)",
            "",
            "            :func: the decorator function (e.g. roles_required)",
            "            :params: list of what (if any) was passed to the decorator.",
            "",
            "        Should return a Response or something Flask can create a Response from.",
            "        Can raise an exception if it is handled as part of",
            "        flask.errorhandler(<exception>)",
            "",
            "        With the passed parameters the application could deliver a concise error",
            "        message.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._unauthz_handler = cb",
            "",
            "    def unauthn_handler(self, cb):",
            "        \"\"\"",
            "        Callback for failed authentication.",
            "        This is called by :func:`auth_required`, :func:`auth_token_required`",
            "        or :func:`http_auth_required` if authentication fails.",
            "",
            "        :param cb: Callback function with signature (mechanisms, headers=None)",
            "",
            "            :mechanisms: List of which authentication mechanisms were tried",
            "            :headers: dict of headers to return",
            "",
            "        Should return a Response or something Flask can create a Response from.",
            "        Can raise an exception if it is handled as part of",
            "        ``flask.errorhandler(<exception>)``",
            "",
            "        The default implementation will return a 401 response if the request was JSON,",
            "        otherwise lets ``flask_login.login_manager.unauthorized()`` handle redirects.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._unauthn_handler = cb",
            "",
            "    def reauthn_handler(self, cb):",
            "        \"\"\"",
            "        Callback when endpoint required a fresh authentication.",
            "        This is called by :func:`auth_required`.",
            "",
            "        :param cb: Callback function with signature (within, grace)",
            "",
            "            :within: timedelta that endpoint required fresh authentication within.",
            "            :grace: timedelta of grace period that endpoint allowed.",
            "",
            "        Should return a Response or something Flask can create a Response from.",
            "        Can raise an exception if it is handled as part of",
            "        ``flask.errorhandler(<exception>)``",
            "",
            "        The default implementation will return a 401 response if the request was JSON,",
            "        otherwise will redirect to :py:data:`SECURITY_US_VERIFY_URL`",
            "        (if :py:data:`SECURITY_UNIFIED_SIGNIN` is enabled)",
            "        else to :py:data:`SECURITY_VERIFY_URL`.",
            "        If both of those are None it sends an ``abort(401)``.",
            "",
            "        See :meth:`flask_security.auth_required` for details about freshness checking.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        self._state._reauthn_handler = cb",
            "",
            "    def __getattr__(self, name):",
            "        return getattr(self._state, name, None)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "    flask_security.core",
            "    ~~~~~~~~~~~~~~~~~~~",
            "",
            "    Flask-Security core module",
            "",
            "    :copyright: (c) 2012 by Matt Wright.",
            "    :copyright: (c) 2017 by CERN.",
            "    :copyright: (c) 2017 by ETH Zurich, Swiss Data Science Center.",
            "    :copyright: (c) 2019-2021 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "",
            "from datetime import datetime, timedelta",
            "import re",
            "import warnings",
            "",
            "import pkg_resources",
            "from flask import _request_ctx_stack, current_app, render_template",
            "from flask_login import AnonymousUserMixin, LoginManager",
            "from flask_login import UserMixin as BaseUserMixin",
            "from flask_login import current_user",
            "from flask_principal import Identity, Principal, RoleNeed, UserNeed, identity_loaded",
            "from itsdangerous import URLSafeTimedSerializer",
            "from passlib.context import CryptContext",
            "from werkzeug.datastructures import ImmutableList",
            "from werkzeug.local import LocalProxy",
            "",
            "from .babel import get_i18n_domain, have_babel",
            "from .decorators import (",
            "    default_reauthn_handler,",
            "    default_unauthn_handler,",
            "    default_unauthz_handler,",
            ")",
            "from .forms import (",
            "    ChangePasswordForm,",
            "    ConfirmRegisterForm,",
            "    ForgotPasswordForm,",
            "    LoginForm,",
            "    PasswordlessLoginForm,",
            "    RegisterForm,",
            "    ResetPasswordForm,",
            "    SendConfirmationForm,",
            "    TwoFactorVerifyCodeForm,",
            "    TwoFactorSetupForm,",
            "    TwoFactorRescueForm,",
            "    VerifyForm,",
            ")",
            "from .mail_util import MailUtil",
            "from .password_util import PasswordUtil",
            "from .phone_util import PhoneUtil",
            "from .twofactor import tf_send_security_token",
            "from .unified_signin import (",
            "    UnifiedSigninForm,",
            "    UnifiedSigninSetupForm,",
            "    UnifiedSigninSetupValidateForm,",
            "    UnifiedVerifyForm,",
            "    us_send_security_token,",
            ")",
            "from .totp import Totp",
            "from .utils import _",
            "from .utils import config_value as cv",
            "from .utils import (",
            "    FsJsonEncoder,",
            "    FsPermNeed,",
            "    csrf_cookie_handler,",
            "    default_want_json,",
            "    get_config,",
            "    get_identity_attribute,",
            "    get_identity_attributes,",
            "    get_message,",
            "    localize_callback,",
            "    set_request_attr,",
            "    uia_email_mapper,",
            "    url_for_security,",
            "    verify_and_update_password,",
            ")",
            "from .views import create_blueprint, default_render_json",
            "",
            "# Convenient references",
            "_security = LocalProxy(lambda: current_app.extensions[\"security\"])",
            "_datastore = LocalProxy(lambda: _security.datastore)",
            "",
            "# List of authentication mechanisms supported.",
            "AUTHN_MECHANISMS = (\"basic\", \"session\", \"token\")",
            "",
            "",
            "#: Default Flask-Security configuration",
            "_default_config = {",
            "    \"BLUEPRINT_NAME\": \"security\",",
            "    \"CLI_ROLES_NAME\": \"roles\",",
            "    \"CLI_USERS_NAME\": \"users\",",
            "    \"URL_PREFIX\": None,",
            "    \"SUBDOMAIN\": None,",
            "    \"FLASH_MESSAGES\": True,",
            "    \"I18N_DOMAIN\": \"flask_security\",",
            "    \"I18N_DIRNAME\": pkg_resources.resource_filename(\"flask_security\", \"translations\"),",
            "    \"EMAIL_VALIDATOR_ARGS\": None,",
            "    \"PASSWORD_HASH\": \"bcrypt\",",
            "    \"PASSWORD_SALT\": None,",
            "    \"PASSWORD_SINGLE_HASH\": {",
            "        \"django_argon2\",",
            "        \"django_bcrypt_sha256\",",
            "        \"django_pbkdf2_sha256\",",
            "        \"django_pbkdf2_sha1\",",
            "        \"django_bcrypt\",",
            "        \"django_salted_md5\",",
            "        \"django_salted_sha1\",",
            "        \"django_des_crypt\",",
            "        \"plaintext\",",
            "    },",
            "    \"PASSWORD_SCHEMES\": [",
            "        \"bcrypt\",",
            "        \"argon2\",",
            "        \"des_crypt\",",
            "        \"pbkdf2_sha256\",",
            "        \"pbkdf2_sha512\",",
            "        \"sha256_crypt\",",
            "        \"sha512_crypt\",",
            "        # And always last one...",
            "        \"plaintext\",",
            "    ],",
            "    \"PASSWORD_HASH_OPTIONS\": {},  # Deprecated at passlib 1.7",
            "    \"PASSWORD_HASH_PASSLIB_OPTIONS\": {",
            "        \"argon2__rounds\": 10  # 1.7.1 default is 2.",
            "    },  # >= 1.7.1 method to pass options.",
            "    \"PASSWORD_LENGTH_MIN\": 8,",
            "    \"PASSWORD_COMPLEXITY_CHECKER\": None,",
            "    \"PASSWORD_CHECK_BREACHED\": False,",
            "    \"PASSWORD_BREACHED_COUNT\": 1,",
            "    \"PASSWORD_NORMALIZE_FORM\": \"NFKD\",",
            "    \"DEPRECATED_PASSWORD_SCHEMES\": [\"auto\"],",
            "    \"LOGIN_URL\": \"/login\",",
            "    \"LOGOUT_URL\": \"/logout\",",
            "    \"REGISTER_URL\": \"/register\",",
            "    \"RESET_URL\": \"/reset\",",
            "    \"CHANGE_URL\": \"/change\",",
            "    \"CONFIRM_URL\": \"/confirm\",",
            "    \"VERIFY_URL\": \"/verify\",",
            "    \"TWO_FACTOR_SETUP_URL\": \"/tf-setup\",",
            "    \"TWO_FACTOR_TOKEN_VALIDATION_URL\": \"/tf-validate\",",
            "    \"TWO_FACTOR_RESCUE_URL\": \"/tf-rescue\",",
            "    \"LOGOUT_METHODS\": [\"GET\", \"POST\"],",
            "    \"POST_LOGIN_VIEW\": \"/\",",
            "    \"POST_LOGOUT_VIEW\": \"/\",",
            "    \"CONFIRM_ERROR_VIEW\": None,",
            "    \"POST_REGISTER_VIEW\": None,",
            "    \"POST_CONFIRM_VIEW\": None,",
            "    \"POST_RESET_VIEW\": None,",
            "    \"POST_CHANGE_VIEW\": None,",
            "    \"POST_VERIFY_VIEW\": None,",
            "    \"UNAUTHORIZED_VIEW\": None,",
            "    \"RESET_ERROR_VIEW\": None,",
            "    \"RESET_VIEW\": None,",
            "    \"LOGIN_ERROR_VIEW\": None,",
            "    \"REQUIRES_CONFIRMATION_ERROR_VIEW\": None,",
            "    \"REDIRECT_HOST\": None,",
            "    \"REDIRECT_BEHAVIOR\": None,",
            "    \"REDIRECT_ALLOW_SUBDOMAINS\": False,",
            "    \"REDIRECT_VALIDATE_MODE\": None,",
            "    \"REDIRECT_VALIDATE_RE\": r\"^/{4,}|\\\\{3,}|[\\s\\000-\\037][/\\\\]{2,}\",",
            "    \"FORGOT_PASSWORD_TEMPLATE\": \"security/forgot_password.html\",",
            "    \"LOGIN_USER_TEMPLATE\": \"security/login_user.html\",",
            "    \"REGISTER_USER_TEMPLATE\": \"security/register_user.html\",",
            "    \"RESET_PASSWORD_TEMPLATE\": \"security/reset_password.html\",",
            "    \"CHANGE_PASSWORD_TEMPLATE\": \"security/change_password.html\",",
            "    \"SEND_CONFIRMATION_TEMPLATE\": \"security/send_confirmation.html\",",
            "    \"SEND_LOGIN_TEMPLATE\": \"security/send_login.html\",",
            "    \"VERIFY_TEMPLATE\": \"security/verify.html\",",
            "    \"TWO_FACTOR_VERIFY_CODE_TEMPLATE\": \"security/two_factor_verify_code.html\",",
            "    \"TWO_FACTOR_SETUP_TEMPLATE\": \"security/two_factor_setup.html\",",
            "    \"CONFIRMABLE\": False,",
            "    \"REGISTERABLE\": False,",
            "    \"RECOVERABLE\": False,",
            "    \"TRACKABLE\": False,",
            "    \"PASSWORDLESS\": False,",
            "    \"CHANGEABLE\": False,",
            "    \"TWO_FACTOR\": False,",
            "    \"SEND_REGISTER_EMAIL\": True,",
            "    \"SEND_PASSWORD_CHANGE_EMAIL\": True,",
            "    \"SEND_PASSWORD_RESET_EMAIL\": True,",
            "    \"SEND_PASSWORD_RESET_NOTICE_EMAIL\": True,",
            "    \"LOGIN_WITHIN\": \"1 days\",",
            "    \"TWO_FACTOR_AUTHENTICATOR_VALIDITY\": 120,",
            "    \"TWO_FACTOR_MAIL_VALIDITY\": 300,",
            "    \"TWO_FACTOR_SMS_VALIDITY\": 120,",
            "    \"TWO_FACTOR_ALWAYS_VALIDATE\": True,",
            "    \"TWO_FACTOR_LOGIN_VALIDITY\": \"30 days\",",
            "    \"TWO_FACTOR_VALIDITY_SALT\": \"tf-validity-salt\",",
            "    \"TWO_FACTOR_VALIDITY_COOKIE\": {",
            "        \"httponly\": True,",
            "        \"secure\": False,",
            "        \"samesite\": None,",
            "    },",
            "    \"CONFIRM_EMAIL_WITHIN\": \"5 days\",",
            "    \"RESET_PASSWORD_WITHIN\": \"5 days\",",
            "    \"LOGIN_WITHOUT_CONFIRMATION\": False,",
            "    \"AUTO_LOGIN_AFTER_CONFIRM\": True,",
            "    \"EMAIL_SENDER\": LocalProxy(",
            "        lambda: current_app.config.get(\"MAIL_DEFAULT_SENDER\", \"no-reply@localhost\")",
            "    ),",
            "    \"TWO_FACTOR_RESCUE_MAIL\": \"no-reply@localhost\",",
            "    \"TOKEN_AUTHENTICATION_KEY\": \"auth_token\",",
            "    \"TOKEN_AUTHENTICATION_HEADER\": \"Authentication-Token\",",
            "    \"TOKEN_MAX_AGE\": None,",
            "    \"CONFIRM_SALT\": \"confirm-salt\",",
            "    \"RESET_SALT\": \"reset-salt\",",
            "    \"LOGIN_SALT\": \"login-salt\",",
            "    \"CHANGE_SALT\": \"change-salt\",",
            "    \"REMEMBER_SALT\": \"remember-salt\",",
            "    \"DEFAULT_REMEMBER_ME\": False,",
            "    \"DEFAULT_HTTP_AUTH_REALM\": _(\"Login Required\"),",
            "    \"EMAIL_SUBJECT_REGISTER\": _(\"Welcome\"),",
            "    \"EMAIL_SUBJECT_CONFIRM\": _(\"Please confirm your email\"),",
            "    \"EMAIL_SUBJECT_PASSWORDLESS\": _(\"Login instructions\"),",
            "    \"EMAIL_SUBJECT_PASSWORD_NOTICE\": _(\"Your password has been reset\"),",
            "    \"EMAIL_SUBJECT_PASSWORD_CHANGE_NOTICE\": _(\"Your password has been changed\"),",
            "    \"EMAIL_SUBJECT_PASSWORD_RESET\": _(\"Password reset instructions\"),",
            "    \"EMAIL_PLAINTEXT\": True,",
            "    \"EMAIL_HTML\": True,",
            "    \"EMAIL_SUBJECT_TWO_FACTOR\": _(\"Two-factor Login\"),",
            "    \"EMAIL_SUBJECT_TWO_FACTOR_RESCUE\": _(\"Two-factor Rescue\"),",
            "    \"USER_IDENTITY_ATTRIBUTES\": [",
            "        {\"email\": {\"mapper\": uia_email_mapper, \"case_insensitive\": True}}",
            "    ],",
            "    \"PHONE_REGION_DEFAULT\": \"US\",",
            "    \"FRESHNESS\": timedelta(hours=24),",
            "    \"FRESHNESS_GRACE_PERIOD\": timedelta(hours=1),",
            "    \"API_ENABLED_METHODS\": [\"session\", \"token\"],",
            "    \"HASHING_SCHEMES\": [\"sha256_crypt\", \"hex_md5\"],",
            "    \"DEPRECATED_HASHING_SCHEMES\": [\"hex_md5\"],",
            "    \"DATETIME_FACTORY\": datetime.utcnow,",
            "    \"TOTP_SECRETS\": None,",
            "    \"TOTP_ISSUER\": None,",
            "    \"SMS_SERVICE\": \"Dummy\",",
            "    \"SMS_SERVICE_CONFIG\": {",
            "        \"ACCOUNT_SID\": None,",
            "        \"AUTH_TOKEN\": None,",
            "        \"PHONE_NUMBER\": None,",
            "    },",
            "    \"TWO_FACTOR_REQUIRED\": False,",
            "    \"TWO_FACTOR_SECRET\": None,  # Deprecated - use TOTP_SECRETS",
            "    \"TWO_FACTOR_ENABLED_METHODS\": [\"email\", \"authenticator\", \"sms\"],",
            "    \"TWO_FACTOR_URI_SERVICE_NAME\": \"service_name\",  # Deprecated - use TOTP_ISSUER",
            "    \"TWO_FACTOR_SMS_SERVICE\": \"Dummy\",  # Deprecated - use SMS_SERVICE",
            "    \"TWO_FACTOR_SMS_SERVICE_CONFIG\": {  # Deprecated - use SMS_SERVICE_CONFIG",
            "        \"ACCOUNT_SID\": None,",
            "        \"AUTH_TOKEN\": None,",
            "        \"PHONE_NUMBER\": None,",
            "    },",
            "    \"UNIFIED_SIGNIN\": False,",
            "    \"US_SETUP_SALT\": \"us-setup-salt\",",
            "    \"US_SIGNIN_URL\": \"/us-signin\",",
            "    \"US_SIGNIN_SEND_CODE_URL\": \"/us-signin/send-code\",",
            "    \"US_SETUP_URL\": \"/us-setup\",",
            "    \"US_VERIFY_URL\": \"/us-verify\",",
            "    \"US_VERIFY_SEND_CODE_URL\": \"/us-verify/send-code\",",
            "    \"US_VERIFY_LINK_URL\": \"/us-verify-link\",",
            "    \"US_POST_SETUP_VIEW\": None,",
            "    \"US_SIGNIN_TEMPLATE\": \"security/us_signin.html\",",
            "    \"US_SETUP_TEMPLATE\": \"security/us_setup.html\",",
            "    \"US_VERIFY_TEMPLATE\": \"security/us_verify.html\",",
            "    \"US_ENABLED_METHODS\": [\"password\", \"email\", \"authenticator\", \"sms\"],",
            "    \"US_MFA_REQUIRED\": [\"password\", \"email\"],",
            "    \"US_TOKEN_VALIDITY\": 120,",
            "    \"US_EMAIL_SUBJECT\": _(\"Verification Code\"),",
            "    \"US_SETUP_WITHIN\": \"30 minutes\",",
            "    \"US_SIGNIN_REPLACES_LOGIN\": False,",
            "    \"CSRF_PROTECT_MECHANISMS\": AUTHN_MECHANISMS,",
            "    \"CSRF_IGNORE_UNAUTH_ENDPOINTS\": False,",
            "    \"CSRF_COOKIE\": {\"key\": None},",
            "    \"CSRF_HEADER\": \"X-XSRF-Token\",",
            "    \"CSRF_COOKIE_REFRESH_EACH_REQUEST\": False,",
            "    \"BACKWARDS_COMPAT_UNAUTHN\": False,",
            "    \"BACKWARDS_COMPAT_AUTH_TOKEN\": False,",
            "    \"JOIN_USER_ROLES\": True,",
            "}",
            "",
            "#: Default Flask-Security messages",
            "_default_messages = {",
            "    \"API_ERROR\": (_(\"Input not appropriate for requested API\"), \"error\"),",
            "    \"UNAUTHORIZED\": (_(\"You do not have permission to view this resource.\"), \"error\"),",
            "    \"UNAUTHENTICATED\": (",
            "        _(\"You are not authenticated. Please supply the correct credentials.\"),",
            "        \"error\",",
            "    ),",
            "    \"REAUTHENTICATION_REQUIRED\": (",
            "        _(\"You must re-authenticate to access this endpoint\"),",
            "        \"error\",",
            "    ),",
            "    \"CONFIRM_REGISTRATION\": (",
            "        _(\"Thank you. Confirmation instructions have been sent to %(email)s.\"),",
            "        \"success\",",
            "    ),",
            "    \"EMAIL_CONFIRMED\": (_(\"Thank you. Your email has been confirmed.\"), \"success\"),",
            "    \"ALREADY_CONFIRMED\": (_(\"Your email has already been confirmed.\"), \"info\"),",
            "    \"INVALID_CONFIRMATION_TOKEN\": (_(\"Invalid confirmation token.\"), \"error\"),",
            "    \"EMAIL_ALREADY_ASSOCIATED\": (",
            "        _(\"%(email)s is already associated with an account.\"),",
            "        \"error\",",
            "    ),",
            "    \"IDENTITY_ALREADY_ASSOCIATED\": (",
            "        _(",
            "            \"Identity attribute '%(attr)s' with value '%(value)s' is already\"",
            "            \" associated with an account.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"PASSWORD_MISMATCH\": (_(\"Password does not match\"), \"error\"),",
            "    \"RETYPE_PASSWORD_MISMATCH\": (_(\"Passwords do not match\"), \"error\"),",
            "    \"INVALID_REDIRECT\": (_(\"Redirections outside the domain are forbidden\"), \"error\"),",
            "    \"PASSWORD_RESET_REQUEST\": (",
            "        _(\"Instructions to reset your password have been sent to %(email)s.\"),",
            "        \"info\",",
            "    ),",
            "    \"PASSWORD_RESET_EXPIRED\": (",
            "        _(",
            "            \"You did not reset your password within %(within)s. \"",
            "            \"New instructions have been sent to %(email)s.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"INVALID_RESET_PASSWORD_TOKEN\": (_(\"Invalid reset password token.\"), \"error\"),",
            "    \"CONFIRMATION_REQUIRED\": (_(\"Email requires confirmation.\"), \"error\"),",
            "    \"CONFIRMATION_REQUEST\": (",
            "        _(\"Confirmation instructions have been sent to %(email)s.\"),",
            "        \"info\",",
            "    ),",
            "    \"CONFIRMATION_EXPIRED\": (",
            "        _(",
            "            \"You did not confirm your email within %(within)s. \"",
            "            \"New instructions to confirm your email have been sent \"",
            "            \"to %(email)s.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"LOGIN_EXPIRED\": (",
            "        _(",
            "            \"You did not login within %(within)s. New instructions to login \"",
            "            \"have been sent to %(email)s.\"",
            "        ),",
            "        \"error\",",
            "    ),",
            "    \"LOGIN_EMAIL_SENT\": (",
            "        _(\"Instructions to login have been sent to %(email)s.\"),",
            "        \"success\",",
            "    ),",
            "    \"INVALID_LOGIN_TOKEN\": (_(\"Invalid login token.\"), \"error\"),",
            "    \"DISABLED_ACCOUNT\": (_(\"Account is disabled.\"), \"error\"),",
            "    \"EMAIL_NOT_PROVIDED\": (_(\"Email not provided\"), \"error\"),",
            "    \"INVALID_EMAIL_ADDRESS\": (_(\"Invalid email address\"), \"error\"),",
            "    \"INVALID_CODE\": (_(\"Invalid code\"), \"error\"),",
            "    \"PASSWORD_NOT_PROVIDED\": (_(\"Password not provided\"), \"error\"),",
            "    \"PASSWORD_NOT_SET\": (_(\"No password is set for this user\"), \"error\"),",
            "    \"PASSWORD_INVALID_LENGTH\": (",
            "        _(\"Password must be at least %(length)s characters\"),",
            "        \"error\",",
            "    ),",
            "    \"PASSWORD_TOO_SIMPLE\": (_(\"Password not complex enough\"), \"error\"),",
            "    \"PASSWORD_BREACHED\": (_(\"Password on breached list\"), \"error\"),",
            "    \"PASSWORD_BREACHED_SITE_ERROR\": (",
            "        _(\"Failed to contact breached passwords site\"),",
            "        \"error\",",
            "    ),",
            "    \"PHONE_INVALID\": (_(\"Phone number not valid e.g. missing country code\"), \"error\"),",
            "    \"USER_DOES_NOT_EXIST\": (_(\"Specified user does not exist\"), \"error\"),",
            "    \"INVALID_PASSWORD\": (_(\"Invalid password\"), \"error\"),",
            "    \"INVALID_PASSWORD_CODE\": (_(\"Password or code submitted is not valid\"), \"error\"),",
            "    \"PASSWORDLESS_LOGIN_SUCCESSFUL\": (_(\"You have successfully logged in.\"), \"success\"),",
            "    \"FORGOT_PASSWORD\": (_(\"Forgot password?\"), \"info\"),",
            "    \"PASSWORD_RESET\": (",
            "        _(",
            "            \"You successfully reset your password and you have been logged in \"",
            "            \"automatically.\"",
            "        ),",
            "        \"success\",",
            "    ),",
            "    \"PASSWORD_IS_THE_SAME\": (",
            "        _(\"Your new password must be different than your previous password.\"),",
            "        \"error\",",
            "    ),",
            "    \"PASSWORD_CHANGE\": (_(\"You successfully changed your password.\"), \"success\"),",
            "    \"LOGIN\": (_(\"Please log in to access this page.\"), \"info\"),",
            "    \"REFRESH\": (_(\"Please reauthenticate to access this page.\"), \"info\"),",
            "    \"REAUTHENTICATION_SUCCESSFUL\": (_(\"Reauthentication successful\"), \"info\"),",
            "    \"ANONYMOUS_USER_REQUIRED\": (",
            "        _(\"You can only access this endpoint when not logged in.\"),",
            "        \"error\",",
            "    ),",
            "    \"FAILED_TO_SEND_CODE\": (_(\"Failed to send code. Please try again later\"), \"error\"),",
            "    \"TWO_FACTOR_INVALID_TOKEN\": (_(\"Invalid Token\"), \"error\"),",
            "    \"TWO_FACTOR_LOGIN_SUCCESSFUL\": (_(\"Your token has been confirmed\"), \"success\"),",
            "    \"TWO_FACTOR_CHANGE_METHOD_SUCCESSFUL\": (",
            "        _(\"You successfully changed your two-factor method.\"),",
            "        \"success\",",
            "    ),",
            "    \"TWO_FACTOR_PERMISSION_DENIED\": (",
            "        _(\"You currently do not have permissions to access this page\"),",
            "        \"error\",",
            "    ),",
            "    \"TWO_FACTOR_METHOD_NOT_AVAILABLE\": (_(\"Marked method is not valid\"), \"error\"),",
            "    \"TWO_FACTOR_DISABLED\": (",
            "        _(\"You successfully disabled two factor authorization.\"),",
            "        \"success\",",
            "    ),",
            "    \"US_METHOD_NOT_AVAILABLE\": (_(\"Requested method is not valid\"), \"error\"),",
            "    \"US_SETUP_EXPIRED\": (",
            "        _(\"Setup must be completed within %(within)s. Please start over.\"),",
            "        \"error\",",
            "    ),",
            "    \"US_SETUP_SUCCESSFUL\": (_(\"Unified sign in setup successful\"), \"info\"),",
            "    \"US_SPECIFY_IDENTITY\": (_(\"You must specify a valid identity to sign in\"), \"error\"),",
            "    \"USE_CODE\": (_(\"Use this code to sign in: %(code)s.\"), \"info\"),",
            "}",
            "",
            "_default_forms = {",
            "    \"login_form\": LoginForm,",
            "    \"verify_form\": VerifyForm,",
            "    \"confirm_register_form\": ConfirmRegisterForm,",
            "    \"register_form\": RegisterForm,",
            "    \"forgot_password_form\": ForgotPasswordForm,",
            "    \"reset_password_form\": ResetPasswordForm,",
            "    \"change_password_form\": ChangePasswordForm,",
            "    \"send_confirmation_form\": SendConfirmationForm,",
            "    \"passwordless_login_form\": PasswordlessLoginForm,",
            "    \"two_factor_verify_code_form\": TwoFactorVerifyCodeForm,",
            "    \"two_factor_setup_form\": TwoFactorSetupForm,",
            "    \"two_factor_rescue_form\": TwoFactorRescueForm,",
            "    \"us_signin_form\": UnifiedSigninForm,",
            "    \"us_setup_form\": UnifiedSigninSetupForm,",
            "    \"us_setup_validate_form\": UnifiedSigninSetupValidateForm,",
            "    \"us_verify_form\": UnifiedVerifyForm,",
            "}",
            "",
            "",
            "def _user_loader(user_id):",
            "    \"\"\"Load based on fs_uniquifier (alternative_id).\"\"\"",
            "    user = _security.datastore.find_user(fs_uniquifier=str(user_id))",
            "    if user and user.active:",
            "        set_request_attr(\"fs_authn_via\", \"session\")",
            "        return user",
            "    return None",
            "",
            "",
            "def _request_loader(request):",
            "    # Short-circuit if we have already been called and verified.",
            "    # This can happen since Flask-Login will call us (if no session) and our own",
            "    # decorator @auth_token_required can call us.",
            "    # N.B. we don't call current_user here since that in fact might try and LOAD",
            "    # a user - which would call us again.",
            "    if all(hasattr(_request_ctx_stack.top, k) for k in [\"fs_authn_via\", \"user\"]):",
            "        if _request_ctx_stack.top.fs_authn_via == \"token\":",
            "            return _request_ctx_stack.top.user",
            "",
            "    header_key = _security.token_authentication_header",
            "    args_key = _security.token_authentication_key",
            "    header_token = request.headers.get(header_key, None)",
            "    token = request.args.get(args_key, header_token)",
            "    if request.is_json:",
            "        data = request.get_json(silent=True) or {}",
            "        if isinstance(data, dict):",
            "            token = data.get(args_key, token)",
            "",
            "    try:",
            "        data = _security.remember_token_serializer.loads(",
            "            token, max_age=_security.token_max_age",
            "        )",
            "",
            "        # Version 3.x generated tokens that map to data with 3 elements,",
            "        # and fs_uniquifier was on last element.",
            "        # Version 4.0.0 generates tokens that map to data with only 1 element,",
            "        # which maps to fs_uniquifier.",
            "        # Here we compute uniquifier_index so that we can pick up correct index for",
            "        # matching fs_uniquifier in version 4.0.0 even if token was created with",
            "        # version 3.x",
            "        uniquifier_index = 0 if len(data) == 1 else 2",
            "",
            "        if hasattr(_security.datastore.user_model, \"fs_token_uniquifier\"):",
            "            user = _security.datastore.find_user(",
            "                fs_token_uniquifier=data[uniquifier_index]",
            "            )",
            "        else:",
            "            user = _security.datastore.find_user(fs_uniquifier=data[uniquifier_index])",
            "        if not user.active:",
            "            user = None",
            "    except Exception:",
            "        user = None",
            "",
            "    if user and user.verify_auth_token(data):",
            "        set_request_attr(\"fs_authn_via\", \"token\")",
            "        return user",
            "",
            "    return _security.login_manager.anonymous_user()",
            "",
            "",
            "def _identity_loader():",
            "    if not isinstance(current_user._get_current_object(), AnonymousUserMixin):",
            "        identity = Identity(current_user.fs_uniquifier)",
            "        return identity",
            "",
            "",
            "def _on_identity_loaded(sender, identity):",
            "    if hasattr(current_user, \"fs_uniquifier\"):",
            "        identity.provides.add(UserNeed(current_user.fs_uniquifier))",
            "",
            "    for role in getattr(current_user, \"roles\", []):",
            "        identity.provides.add(RoleNeed(role.name))",
            "        for fsperm in role.get_permissions():",
            "            identity.provides.add(FsPermNeed(fsperm))",
            "",
            "    identity.user = current_user",
            "",
            "",
            "def _get_login_manager(app, anonymous_user):",
            "    lm = LoginManager()",
            "    lm.anonymous_user = anonymous_user or AnonymousUser",
            "    lm.localize_callback = localize_callback",
            "    lm.login_view = \"%s.login\" % cv(\"BLUEPRINT_NAME\", app=app)",
            "    lm.user_loader(_user_loader)",
            "    lm.request_loader(_request_loader)",
            "",
            "    if cv(\"FLASH_MESSAGES\", app=app):",
            "        lm.login_message, lm.login_message_category = cv(\"MSG_LOGIN\", app=app)",
            "        lm.needs_refresh_message, lm.needs_refresh_message_category = cv(",
            "            \"MSG_REFRESH\", app=app",
            "        )",
            "    else:",
            "        lm.login_message = None",
            "        lm.needs_refresh_message = None",
            "",
            "    lm.init_app(app)",
            "    return lm",
            "",
            "",
            "def _get_principal(app):",
            "    p = Principal(app, use_sessions=False)",
            "    p.identity_loader(_identity_loader)",
            "    return p",
            "",
            "",
            "def _get_pwd_context(app):",
            "    pw_hash = cv(\"PASSWORD_HASH\", app=app)",
            "    schemes = cv(\"PASSWORD_SCHEMES\", app=app)",
            "    deprecated = cv(\"DEPRECATED_PASSWORD_SCHEMES\", app=app)",
            "    if pw_hash not in schemes:",
            "        allowed = \", \".join(schemes[:-1]) + \" and \" + schemes[-1]",
            "        raise ValueError(",
            "            \"Invalid password hashing scheme %r. Allowed values are %s\"",
            "            % (pw_hash, allowed)",
            "        )",
            "    cc = CryptContext(",
            "        schemes=schemes,",
            "        default=pw_hash,",
            "        deprecated=deprecated,",
            "        **cv(\"PASSWORD_HASH_PASSLIB_OPTIONS\", app=app),",
            "    )",
            "    return cc",
            "",
            "",
            "def _get_hashing_context(app):",
            "    schemes = cv(\"HASHING_SCHEMES\", app=app)",
            "    deprecated = cv(\"DEPRECATED_HASHING_SCHEMES\", app=app)",
            "    return CryptContext(schemes=schemes, deprecated=deprecated)",
            "",
            "",
            "def _get_serializer(app, name):",
            "    secret_key = app.config.get(\"SECRET_KEY\")",
            "    salt = app.config.get(\"SECURITY_%s_SALT\" % name.upper())",
            "    return URLSafeTimedSerializer(secret_key=secret_key, salt=salt)",
            "",
            "",
            "def _get_state(app, datastore, anonymous_user=None, **kwargs):",
            "    for key, value in get_config(app).items():",
            "        kwargs[key.lower()] = value",
            "",
            "    kwargs.update(",
            "        dict(",
            "            app=app,",
            "            datastore=datastore,",
            "            principal=_get_principal(app),",
            "            pwd_context=_get_pwd_context(app),",
            "            hashing_context=_get_hashing_context(app),",
            "            i18n_domain=get_i18n_domain(app),",
            "            remember_token_serializer=_get_serializer(app, \"remember\"),",
            "            login_serializer=_get_serializer(app, \"login\"),",
            "            reset_serializer=_get_serializer(app, \"reset\"),",
            "            confirm_serializer=_get_serializer(app, \"confirm\"),",
            "            us_setup_serializer=_get_serializer(app, \"us_setup\"),",
            "            tf_validity_serializer=_get_serializer(app, \"two_factor_validity\"),",
            "            _context_processors={},",
            "            _unauthorized_callback=None,",
            "            _render_json=default_render_json,",
            "            _want_json=default_want_json,",
            "            _unauthn_handler=default_unauthn_handler,",
            "            _reauthn_handler=default_reauthn_handler,",
            "            _unauthz_handler=default_unauthz_handler,",
            "        )",
            "    )",
            "    if \"redirect_validate_re\" in kwargs:",
            "        kwargs[\"_redirect_validate_re\"] = re.compile(kwargs[\"redirect_validate_re\"])",
            "",
            "    if \"login_manager\" not in kwargs:",
            "        kwargs[\"login_manager\"] = _get_login_manager(app, anonymous_user)",
            "",
            "    for key, value in _default_forms.items():",
            "        if key not in kwargs or not kwargs[key]:",
            "            kwargs[key] = value",
            "",
            "    return _SecurityState(**kwargs)",
            "",
            "",
            "def _context_processor():",
            "    return dict(url_for_security=url_for_security, security=_security)",
            "",
            "",
            "class RoleMixin:",
            "    \"\"\"Mixin for `Role` model definitions\"\"\"",
            "",
            "    def __eq__(self, other):",
            "        return self.name == other or self.name == getattr(other, \"name\", None)",
            "",
            "    def __ne__(self, other):",
            "        return not self.__eq__(other)",
            "",
            "    def __hash__(self):",
            "        return hash(self.name)",
            "",
            "    def get_permissions(self):",
            "        \"\"\"",
            "        Return set of permissions associated with role.",
            "",
            "        Supports permissions being a comma separated string, an iterable, or a set",
            "        based on how the underlying DB model was built.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        if hasattr(self, \"permissions\") and self.permissions:",
            "            if isinstance(self.permissions, set):",
            "                return self.permissions",
            "            elif isinstance(self.permissions, list):",
            "                return set(self.permissions)",
            "            else:",
            "                # Assume this is a comma separated list",
            "                return set(self.permissions.split(\",\"))",
            "        return set()",
            "",
            "    def add_permissions(self, permissions):",
            "        \"\"\"",
            "        Add one or more permissions to role.",
            "",
            "        :param permissions: a set, list, or single string.",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        .. deprecated:: 3.4.4",
            "            Use :meth:`.UserDatastore.add_permissions_to_role`",
            "        \"\"\"",
            "        if hasattr(self, \"permissions\"):",
            "            current_perms = self.get_permissions()",
            "            if isinstance(permissions, set):",
            "                perms = permissions",
            "            elif isinstance(permissions, list):",
            "                perms = set(permissions)",
            "            else:",
            "                perms = {permissions}",
            "            self.permissions = \",\".join(current_perms.union(perms))",
            "        else:  # pragma: no cover",
            "            raise NotImplementedError(\"Role model doesn't have permissions\")",
            "",
            "    def remove_permissions(self, permissions):",
            "        \"\"\"",
            "        Remove one or more permissions from role.",
            "",
            "        :param permissions: a set, list, or single string.",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        .. deprecated:: 3.4.4",
            "            Use :meth:`.UserDatastore.remove_permissions_from_role`",
            "        \"\"\"",
            "        if hasattr(self, \"permissions\"):",
            "            current_perms = self.get_permissions()",
            "            if isinstance(permissions, set):",
            "                perms = permissions",
            "            elif isinstance(permissions, list):",
            "                perms = set(permissions)",
            "            else:",
            "                perms = {permissions}",
            "            self.permissions = \",\".join(current_perms.difference(perms))",
            "        else:  # pragma: no cover",
            "            raise NotImplementedError(\"Role model doesn't have permissions\")",
            "",
            "",
            "class UserMixin(BaseUserMixin):",
            "    \"\"\"Mixin for `User` model definitions\"\"\"",
            "",
            "    def get_id(self):",
            "        \"\"\"Returns the user identification attribute. 'Alternative-token' for",
            "        Flask-Login. This is always ``fs_uniquifier``.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        return str(self.fs_uniquifier)",
            "",
            "    @property",
            "    def is_active(self):",
            "        \"\"\"Returns `True` if the user is active.\"\"\"",
            "        return self.active",
            "",
            "    def get_auth_token(self):",
            "        \"\"\"Constructs the user's authentication token.",
            "",
            "        :raises ValueError: If ``fs_token_uniquifier`` is part of model but not set.",
            "",
            "        Optionally use a separate uniquifier so that changing password doesn't",
            "        invalidate auth tokens.",
            "",
            "        This data MUST be securely signed using the ``remember_token_serializer``",
            "",
            "        .. versionchanged:: 4.0.0",
            "            If user model has ``fs_token_uniquifier`` - use that (raise ValueError",
            "            if not set). Otherwise fallback to using ``fs_uniqifier``.",
            "        \"\"\"",
            "",
            "        if hasattr(self, \"fs_token_uniquifier\"):",
            "            if not self.fs_token_uniquifier:",
            "                raise ValueError()",
            "            data = [str(self.fs_token_uniquifier)]",
            "        else:",
            "            data = [str(self.fs_uniquifier)]",
            "        return _security.remember_token_serializer.dumps(data)",
            "",
            "    def verify_auth_token(self, data):",
            "        \"\"\"",
            "        Perform additional verification of contents of auth token.",
            "        Prior to this being called the token has been validated (via signing)",
            "        and has not expired.",
            "",
            "        :param data: the data as formulated by :meth:`get_auth_token`",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        .. versionchanged:: 4.0.0",
            "            If user model has ``fs_token_uniquifier`` - use that otherwise",
            "            use ``fs_uniquifier``.",
            "        \"\"\"",
            "",
            "        # Version 3.x generated tokens that map to data with 3 elements,",
            "        # and fs_uniquifier was on last element.",
            "        # Version 4.0.0 generates tokens that map to data with only 1 element,",
            "        # which maps to fs_uniquifier.",
            "        # Here we compute uniquifier_index so that we can pick up correct index for",
            "        # matching fs_uniquifier in version 4.0.0 even if token was created with",
            "        # version 3.x",
            "        uniquifier_index = 0 if len(data) == 1 else 2",
            "",
            "        if hasattr(self, \"fs_token_uniquifier\"):",
            "            return data[uniquifier_index] == self.fs_token_uniquifier",
            "",
            "        return data[uniquifier_index] == self.fs_uniquifier",
            "",
            "    def has_role(self, role):",
            "        \"\"\"Returns `True` if the user identifies with the specified role.",
            "",
            "        :param role: A role name or `Role` instance\"\"\"",
            "        if isinstance(role, str):",
            "            return role in (role.name for role in self.roles)",
            "        else:",
            "            return role in self.roles",
            "",
            "    def has_permission(self, permission):",
            "        \"\"\"",
            "        Returns `True` if user has this permission (via a role it has).",
            "",
            "        :param permission: permission string name",
            "",
            "        .. versionadded:: 3.3.0",
            "",
            "        \"\"\"",
            "        for role in self.roles:",
            "            if permission in role.get_permissions():",
            "                return True",
            "        return False",
            "",
            "    def get_security_payload(self):",
            "        \"\"\"Serialize user object as response payload.",
            "        Override this to return any/all of the user object in JSON responses.",
            "        Return a dict.",
            "        \"\"\"",
            "        return {}",
            "",
            "    def get_redirect_qparams(self, existing=None):",
            "        \"\"\"Return user info that will be added to redirect query params.",
            "",
            "        :param existing: A dict that will be updated.",
            "        :return: A dict whose keys will be query params and values will be query values.",
            "",
            "        .. versionadded:: 3.2.0",
            "",
            "        .. versionchanged:: 4.0.0",
            "            Add 'identity' using UserMixin.calc_username() - email is optional.",
            "        \"\"\"",
            "        if not existing:",
            "            existing = {}",
            "        if hasattr(self, \"email\"):",
            "            existing.update({\"email\": self.email})",
            "        existing.update({\"identity\": self.calc_username()})",
            "        return existing",
            "",
            "    def verify_and_update_password(self, password):",
            "        \"\"\"Returns ``True`` if the password is valid for the specified user.",
            "",
            "        Additionally, the hashed password in the database is updated if the",
            "        hashing algorithm happens to have changed.",
            "",
            "        N.B. you MUST call DB commit if you are using a session-based datastore",
            "        (such as SqlAlchemy) since the user instance might have been altered",
            "        (i.e. ``app.security.datastore.commit()``).",
            "        This is usually handled in the view.",
            "",
            "        :param password: A plaintext password to verify",
            "",
            "        .. versionadded:: 3.2.0",
            "        \"\"\"",
            "        return verify_and_update_password(password, self)",
            "",
            "    def calc_username(self):",
            "        \"\"\"Come up with the best 'username' based on how the app",
            "        is configured (via :py:data:`SECURITY_USER_IDENTITY_ATTRIBUTES`).",
            "        Returns the first non-null match (and converts to string).",
            "        In theory this should NEVER be the empty string unless the user",
            "        record isn't actually valid.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        cusername = None",
            "        for attr in get_identity_attributes():",
            "            cusername = getattr(self, attr, None)",
            "            if cusername is not None and len(str(cusername)) > 0:",
            "                break",
            "        return str(cusername) if cusername is not None else \"\"",
            "",
            "    def us_send_security_token(self, method, **kwargs):",
            "        \"\"\"Generate and send the security code for unified sign in.",
            "",
            "        :param method: The method in which the code will be sent",
            "        :param kwargs: Opaque parameters that are subject to change at any time",
            "        :return: None if successful, error message if not.",
            "",
            "        This is a wrapper around :meth:`us_send_security_token`",
            "        that can be overridden to manage any errors.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        try:",
            "            us_send_security_token(self, method, **kwargs)",
            "        except Exception:",
            "            return get_message(\"FAILED_TO_SEND_CODE\")[0]",
            "        return None",
            "",
            "    def tf_send_security_token(self, method, **kwargs):",
            "        \"\"\"Generate and send the security code for two-factor.",
            "",
            "        :param method: The method in which the code will be sent",
            "        :param kwargs: Opaque parameters that are subject to change at any time",
            "        :return: None if successful, error message if not.",
            "",
            "        This is a wrapper around :meth:`tf_send_security_token`",
            "        that can be overridden to manage any errors.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        try:",
            "            tf_send_security_token(self, method, **kwargs)",
            "        except Exception:",
            "            return get_message(\"FAILED_TO_SEND_CODE\")[0]",
            "        return None",
            "",
            "",
            "class AnonymousUser(AnonymousUserMixin):",
            "    \"\"\"AnonymousUser definition\"\"\"",
            "",
            "    def __init__(self):",
            "        self.roles = ImmutableList()",
            "",
            "    def has_role(self, *args):",
            "        \"\"\"Returns `False`\"\"\"",
            "        return False",
            "",
            "",
            "class _SecurityState:",
            "    def __init__(self, **kwargs):",
            "        for key, value in kwargs.items():",
            "            setattr(self, key.lower(), value)",
            "",
            "    def _add_ctx_processor(self, endpoint, fn):",
            "        group = self._context_processors.setdefault(endpoint, [])",
            "        fn not in group and group.append(fn)",
            "",
            "    def _run_ctx_processor(self, endpoint):",
            "        rv = {}",
            "        for g in [None, endpoint]:",
            "            for fn in self._context_processors.setdefault(g, []):",
            "                rv.update(fn())",
            "        return rv",
            "",
            "    def context_processor(self, fn):",
            "        self._add_ctx_processor(None, fn)",
            "",
            "    def forgot_password_context_processor(self, fn):",
            "        self._add_ctx_processor(\"forgot_password\", fn)",
            "",
            "    def login_context_processor(self, fn):",
            "        self._add_ctx_processor(\"login\", fn)",
            "",
            "    def register_context_processor(self, fn):",
            "        self._add_ctx_processor(\"register\", fn)",
            "",
            "    def reset_password_context_processor(self, fn):",
            "        self._add_ctx_processor(\"reset_password\", fn)",
            "",
            "    def change_password_context_processor(self, fn):",
            "        self._add_ctx_processor(\"change_password\", fn)",
            "",
            "    def send_confirmation_context_processor(self, fn):",
            "        self._add_ctx_processor(\"send_confirmation\", fn)",
            "",
            "    def send_login_context_processor(self, fn):",
            "        self._add_ctx_processor(\"send_login\", fn)",
            "",
            "    def verify_context_processor(self, fn):",
            "        self._add_ctx_processor(\"verify\", fn)",
            "",
            "    def mail_context_processor(self, fn):",
            "        self._add_ctx_processor(\"mail\", fn)",
            "",
            "    def tf_setup_context_processor(self, fn):",
            "        self._add_ctx_processor(\"tf_setup\", fn)",
            "",
            "    def tf_token_validation_context_processor(self, fn):",
            "        self._add_ctx_processor(\"tf_token_validation\", fn)",
            "",
            "    def us_signin_context_processor(self, fn):",
            "        self._add_ctx_processor(\"us_signin\", fn)",
            "",
            "    def us_setup_context_processor(self, fn):",
            "        self._add_ctx_processor(\"us_setup\", fn)",
            "",
            "    def us_verify_context_processor(self, fn):",
            "        self._add_ctx_processor(\"us_verify\", fn)",
            "",
            "    def unauthorized_handler(self, fn):",
            "        warnings.warn(",
            "            \"'unauthorized_handler' has been replaced with\"",
            "            \" 'unauthz_handler' and 'unauthn_handler'\",",
            "            DeprecationWarning,",
            "        )",
            "        self._unauthorized_callback = fn",
            "",
            "    def totp_factory(self, tf):",
            "        self._totp_factory = tf",
            "",
            "    def render_json(self, fn):",
            "        self._render_json = fn",
            "",
            "    def want_json(self, fn):",
            "        self._want_json = fn",
            "",
            "    def unauthz_handler(self, cb):",
            "        self._unauthz_handler = cb",
            "",
            "    def unauthn_handler(self, cb):",
            "        self._unauthn_handler = cb",
            "",
            "    def reauthn_handler(self, cb):",
            "        self._reauthn_handler = cb",
            "",
            "",
            "class Security:",
            "    \"\"\"The :class:`Security` class initializes the Flask-Security extension.",
            "",
            "    :param app: The application.",
            "    :param datastore: An instance of a user datastore.",
            "    :param register_blueprint: to register the Security blueprint or not.",
            "    :param login_form: set form for the login view",
            "    :param verify_form: set form for re-authentication due to freshness check",
            "    :param register_form: set form for the register view when",
            "            *SECURITY_CONFIRMABLE* is false",
            "    :param confirm_register_form: set form for the register view when",
            "            *SECURITY_CONFIRMABLE* is true",
            "    :param forgot_password_form: set form for the forgot password view",
            "    :param reset_password_form: set form for the reset password view",
            "    :param change_password_form: set form for the change password view",
            "    :param send_confirmation_form: set form for the send confirmation view",
            "    :param passwordless_login_form: set form for the passwordless login view",
            "    :param two_factor_setup_form: set form for the 2FA setup view",
            "    :param two_factor_verify_code_form: set form the the 2FA verify code view",
            "    :param two_factor_rescue_form: set form for the 2FA rescue view",
            "    :param us_signin_form: set form for the unified sign in view",
            "    :param us_setup_form: set form for the unified sign in setup view",
            "    :param us_setup_validate_form: set form for the unified sign in setup validate view",
            "    :param us_verify_form: set form for re-authenticating due to freshness check",
            "    :param anonymous_user: class to use for anonymous user",
            "    :param render_template: function to use to render templates. The default is Flask's",
            "     render_template() function.",
            "    :param json_encoder_cls: Class to use as blueprint.json_encoder.",
            "     Defaults to :class:`FsJsonEncoder`",
            "    :param totp_cls: Class to use as TOTP factory. Defaults to :class:`Totp`",
            "    :param phone_util_cls: Class to use for phone number utilities.",
            "     Defaults to :class:`PhoneUtil`",
            "    :param mail_util_cls: Class to use for sending emails. Defaults to :class:`MailUtil`",
            "    :param password_util_cls: Class to use for password normalization/validation.",
            "     Defaults to :class:`PasswordUtil`",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``verify_form`` added as part of freshness/re-authentication",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``us_signin_form``, ``us_setup_form``, ``us_setup_validate_form``, and",
            "        ``us_verify_form`` added as part of the :ref:`unified-sign-in` feature.",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``totp_cls`` added to enable applications to implement replay protection - see",
            "        :py:class:`Totp`.",
            "",
            "    .. versionadded:: 3.4.0",
            "        ``phone_util_cls`` added to allow different phone number",
            "         parsing implementations - see :py:class:`PhoneUtil`",
            "",
            "    .. versionadded:: 4.0.0",
            "        ``mail_util_cls`` added to isolate mailing handling.",
            "        ``password_util_cls`` added to encapsulate password validation/normalization.",
            "",
            "    .. deprecated:: 4.0.0",
            "        ``send_mail`` and ``send_mail_task``. Replaced with ``mail_util_cls``.",
            "        ``two_factor_verify_password_form`` removed.",
            "        ``password_validator`` removed in favor of the new ``password_util_cls``.",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, app=None, datastore=None, register_blueprint=True, **kwargs):",
            "",
            "        self.app = app",
            "        self._datastore = datastore",
            "        self._register_blueprint = register_blueprint",
            "        self._kwargs = kwargs",
            "",
            "        self._state = None  # set by init_app",
            "        if app is not None and datastore is not None:",
            "            self._state = self.init_app(",
            "                app, datastore, register_blueprint=register_blueprint, **kwargs",
            "            )",
            "",
            "    def init_app(self, app, datastore=None, register_blueprint=None, **kwargs):",
            "        \"\"\"Initializes the Flask-Security extension for the specified",
            "        application and datastore implementation.",
            "",
            "        :param app: The application.",
            "        :param datastore: An instance of a user datastore.",
            "        :param register_blueprint: to register the Security blueprint or not.",
            "        \"\"\"",
            "        self.app = app",
            "",
            "        if datastore is None:",
            "            datastore = self._datastore",
            "",
            "        if register_blueprint is None:",
            "            register_blueprint = self._register_blueprint",
            "",
            "        for key, value in self._kwargs.items():",
            "            kwargs.setdefault(key, value)",
            "",
            "        if \"render_template\" not in kwargs:",
            "            kwargs.setdefault(\"render_template\", self.render_template)",
            "        if \"json_encoder_cls\" not in kwargs:",
            "            kwargs.setdefault(\"json_encoder_cls\", FsJsonEncoder)",
            "        if \"totp_cls\" not in kwargs:",
            "            kwargs.setdefault(\"totp_cls\", Totp)",
            "        if \"phone_util_cls\" not in kwargs:",
            "            kwargs.setdefault(\"phone_util_cls\", PhoneUtil)",
            "        if \"mail_util_cls\" not in kwargs:",
            "            kwargs.setdefault(\"mail_util_cls\", MailUtil)",
            "        if \"password_util_cls\" not in kwargs:",
            "            kwargs.setdefault(\"password_util_cls\", PasswordUtil)",
            "",
            "        # default post redirects to APPLICATION_ROOT, which itself defaults to \"/\"",
            "        app.config.setdefault(",
            "            \"SECURITY_POST_LOGIN_VIEW\", app.config.get(\"APPLICATION_ROOT\", \"/\")",
            "        )",
            "        app.config.setdefault(",
            "            \"SECURITY_POST_LOGOUT_VIEW\", app.config.get(\"APPLICATION_ROOT\", \"/\")",
            "        )",
            "",
            "        for key, value in _default_config.items():",
            "            app.config.setdefault(\"SECURITY_\" + key, value)",
            "",
            "        for key, value in _default_messages.items():",
            "            app.config.setdefault(\"SECURITY_MSG_\" + key, value)",
            "",
            "        identity_loaded.connect_via(app)(_on_identity_loaded)",
            "",
            "        self._state = state = _get_state(app, datastore, **kwargs)",
            "        if hasattr(datastore, \"user_model\") and not hasattr(",
            "            datastore.user_model, \"fs_uniquifier\"",
            "        ):  # pragma: no cover",
            "            raise ValueError(\"User model must contain fs_uniquifier as of 4.0.0\")",
            "",
            "        if register_blueprint:",
            "            bp = create_blueprint(",
            "                app, state, __name__, json_encoder=kwargs[\"json_encoder_cls\"]",
            "            )",
            "            app.register_blueprint(bp)",
            "            app.context_processor(_context_processor)",
            "",
            "        @app.before_first_request",
            "        def _register_i18n():",
            "            # This is only not registered if Flask-Babel isn't installed...",
            "            if \"_\" not in app.jinja_env.globals:",
            "                current_app.jinja_env.globals[\"_\"] = state.i18n_domain.gettext",
            "            # Register so other packages can reference our translations.",
            "            current_app.jinja_env.globals[\"_fsdomain\"] = state.i18n_domain.gettext",
            "",
            "        @app.before_first_request",
            "        def _csrf_init():",
            "            # various config checks - some of these are opinionated in that there",
            "            # could be a reason for some of these combinations - but in general",
            "            # they cause strange behavior.",
            "            # WTF_CSRF_ENABLED defaults to True if not set in Flask-WTF",
            "            if not current_app.config.get(\"WTF_CSRF_ENABLED\", True):",
            "                return",
            "            csrf = current_app.extensions.get(\"csrf\", None)",
            "",
            "            # If they don't want ALL mechanisms protected, then they must",
            "            # set WTF_CSRF_CHECK_DEFAULT=False so that our decorators get control.",
            "            if cv(\"CSRF_PROTECT_MECHANISMS\") != AUTHN_MECHANISMS:",
            "                if not csrf:",
            "                    # This isn't good.",
            "                    raise ValueError(",
            "                        \"CSRF_PROTECT_MECHANISMS defined but\"",
            "                        \" CsrfProtect not part of application\"",
            "                    )",
            "                if current_app.config.get(\"WTF_CSRF_CHECK_DEFAULT\", True):",
            "                    raise ValueError(",
            "                        \"WTF_CSRF_CHECK_DEFAULT must be set to False if\"",
            "                        \" CSRF_PROTECT_MECHANISMS is set\"",
            "                    )",
            "            # We don't get control unless they turn off WTF_CSRF_CHECK_DEFAULT if",
            "            # they have enabled global CSRFProtect.",
            "            if (",
            "                cv(\"CSRF_IGNORE_UNAUTH_ENDPOINTS\")",
            "                and csrf",
            "                and current_app.config.get(\"WTF_CSRF_CHECK_DEFAULT\", False)",
            "            ):",
            "                raise ValueError(",
            "                    \"To ignore unauth endpoints you must set WTF_CSRF_CHECK_DEFAULT\"",
            "                    \" to False\"",
            "                )",
            "",
            "            csrf_cookie = cv(\"CSRF_COOKIE\")",
            "            if csrf_cookie and csrf_cookie[\"key\"] and not csrf:",
            "                # Common use case is for cookie value to be used as contents for header",
            "                # which is only looked at when CsrfProtect is initialized.",
            "                # Yes, this is opinionated - they can always get CSRF token via:",
            "                # 'get /login'",
            "                raise ValueError(",
            "                    \"CSRF_COOKIE defined however CsrfProtect not part of application\"",
            "                )",
            "",
            "            if csrf:",
            "                csrf.exempt(\"flask_security.views.logout\")",
            "            if csrf_cookie and csrf_cookie[\"key\"]:",
            "                current_app.after_request(csrf_cookie_handler)",
            "                # Add configured header to WTF_CSRF_HEADERS",
            "                current_app.config[\"WTF_CSRF_HEADERS\"].append(cv(\"CSRF_HEADER\"))",
            "",
            "        @app.before_first_request",
            "        def check_babel():",
            "            # Verify that if Flask-Babel or Flask-BabelEx is installed",
            "            # it has been initialized",
            "            if have_babel() and \"babel\" not in app.extensions:",
            "                raise ValueError(",
            "                    \"Flask-Babel or Flask-BabelEx is installed but not initialized\"",
            "                )",
            "",
            "        state._phone_util = state.phone_util_cls(app)",
            "        state._mail_util = state.mail_util_cls(app)",
            "        state._password_util = state.password_util_cls(app)",
            "",
            "        app.extensions[\"security\"] = state",
            "",
            "        if hasattr(app, \"cli\"):",
            "            from .cli import users, roles",
            "",
            "            if state.cli_users_name:",
            "                app.cli.add_command(users, state.cli_users_name)",
            "            if state.cli_roles_name:",
            "                app.cli.add_command(roles, state.cli_roles_name)",
            "",
            "        # Migrate from TWO_FACTOR config to generic config.",
            "        for newc, oldc in [",
            "            (\"SECURITY_SMS_SERVICE\", \"SECURITY_TWO_FACTOR_SMS_SERVICE\"),",
            "            (\"SECURITY_SMS_SERVICE_CONFIG\", \"SECURITY_TWO_FACTOR_SMS_SERVICE_CONFIG\"),",
            "            (\"SECURITY_TOTP_SECRETS\", \"SECURITY_TWO_FACTOR_SECRET\"),",
            "            (\"SECURITY_TOTP_ISSUER\", \"SECURITY_TWO_FACTOR_URI_SERVICE_NAME\"),",
            "        ]:",
            "            if not app.config.get(newc, None):",
            "                app.config[newc] = app.config.get(oldc, None)",
            "",
            "        # Check for pre-4.0 SECURITY_USER_IDENTITY_ATTRIBUTES format",
            "        for uia in cv(\"USER_IDENTITY_ATTRIBUTES\", app=app):  # pragma: no cover",
            "            if not isinstance(uia, dict):",
            "                raise ValueError(",
            "                    \"SECURITY_USER_IDENTITY_ATTRIBUTES changed semantics\"",
            "                    \" in 4.0 - please see release notes.\"",
            "                )",
            "            if len(list(uia.keys())) != 1:",
            "                raise ValueError(",
            "                    \"Each element in SECURITY_USER_IDENTITY_ATTRIBUTES\"",
            "                    \" must have one and only one key.\"",
            "                )",
            "",
            "        # Two factor configuration checks and setup",
            "        multi_factor = False",
            "        if cv(\"UNIFIED_SIGNIN\", app=app):",
            "            multi_factor = True",
            "            if len(cv(\"US_ENABLED_METHODS\", app=app)) < 1:",
            "                raise ValueError(\"Must configure some US_ENABLED_METHODS\")",
            "            if \"sms\" in cv(",
            "                \"US_ENABLED_METHODS\", app=app",
            "            ) and not get_identity_attribute(\"us_phone_number\", app=app):",
            "                warnings.warn(",
            "                    \"'sms' was enabled in SECURITY_US_ENABLED_METHODS;\"",
            "                    \" however 'us_phone_number' not configured in\"",
            "                    \" SECURITY_USER_IDENTITY_ATTRIBUTES\"",
            "                )",
            "        if cv(\"TWO_FACTOR\", app=app):",
            "            multi_factor = True",
            "            if len(cv(\"TWO_FACTOR_ENABLED_METHODS\", app=app)) < 1:",
            "                raise ValueError(\"Must configure some TWO_FACTOR_ENABLED_METHODS\")",
            "",
            "        if multi_factor:",
            "            # cryptography is used to encrypt TOTP secrets",
            "            self._check_modules(\"cryptography\", \"TWO_FACTOR or UNIFIED_SIGNIN\")",
            "",
            "            need_qrcode = (",
            "                cv(\"UNIFIED_SIGNIN\", app=app)",
            "                and \"authenticator\" in cv(\"US_ENABLED_METHODS\", app=app)",
            "            ) or (",
            "                cv(\"TWO_FACTOR\", app=app)",
            "                and \"authenticator\" in cv(\"TWO_FACTOR_ENABLED_METHODS\", app=app)",
            "            )",
            "            if need_qrcode:",
            "                self._check_modules(\"pyqrcode\", \"TWO_FACTOR or UNIFIED_SIGNIN\")",
            "",
            "            need_sms = (",
            "                cv(\"UNIFIED_SIGNIN\", app=app)",
            "                and \"sms\" in cv(\"US_ENABLED_METHODS\", app=app)",
            "            ) or (",
            "                cv(\"TWO_FACTOR\", app=app)",
            "                and \"sms\" in cv(\"TWO_FACTOR_ENABLED_METHODS\", app=app)",
            "            )",
            "            if need_sms:",
            "                sms_service = cv(\"SMS_SERVICE\", app=app)",
            "                if sms_service == \"Twilio\":  # pragma: no cover",
            "                    self._check_modules(\"twilio\", \"SMS\")",
            "                if state.phone_util_cls == PhoneUtil:",
            "                    self._check_modules(\"phonenumbers\", \"SMS\")",
            "",
            "            secrets = cv(\"TOTP_SECRETS\", app=app)",
            "            issuer = cv(\"TOTP_ISSUER\", app=app)",
            "            if not secrets or not issuer:",
            "                raise ValueError(\"Both TOTP_SECRETS and TOTP_ISSUER must be set\")",
            "            state.totp_factory(state.totp_cls(secrets, issuer))",
            "",
            "        if cv(\"PASSWORD_COMPLEXITY_CHECKER\", app=app) == \"zxcvbn\":",
            "            self._check_modules(\"zxcvbn\", \"PASSWORD_COMPLEXITY_CHECKER\")",
            "        return state",
            "",
            "    def _check_modules(self, module, config_name):  # pragma: no cover",
            "        from importlib.util import find_spec",
            "",
            "        module_exists = find_spec(module)",
            "        if not module_exists:",
            "            raise ValueError(f\"{module} is required for {config_name}\")",
            "",
            "        return module_exists",
            "",
            "    def render_template(self, *args, **kwargs):",
            "        return render_template(*args, **kwargs)",
            "",
            "    def render_json(self, cb):",
            "        \"\"\"Callback to render response payload as JSON.",
            "",
            "        :param cb: Callback function with",
            "         signature (payload, code, headers=None, user=None)",
            "",
            "            :payload: A dict. Please see the formal API spec for details.",
            "            :code: Http status code",
            "            :headers: Headers object",
            "            :user: the UserDatastore object (or None). Note that this is usually",
            "                           the same as current_user - but not always.",
            "",
            "        The default implementation simply returns::",
            "",
            "                headers[\"Content-Type\"] = \"application/json\"",
            "                payload = dict(meta=dict(code=code), response=payload)",
            "                return make_response(jsonify(payload), code, headers)",
            "",
            "        .. important::",
            "            Be aware the Flask's ``jsonify`` method will first look to see if a",
            "            ``json_encoder`` has been set on the blueprint corresponding to the current",
            "            request. If not then it looks for a ``json_encoder`` registered on the app;",
            "            and finally uses Flask's default JSONEncoder class. Flask-Security registers",
            "            :func:`FsJsonEncoder` as its blueprint json_encoder.",
            "",
            "",
            "        This can be used by applications to unify all their JSON API responses.",
            "        This is called in a request context and should return a Response or something",
            "        Flask can create a Response from.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._render_json = cb",
            "",
            "    def want_json(self, fn):",
            "        \"\"\"Function that returns True if response should be JSON (based on the request)",
            "",
            "        :param fn: Function with the following signature (request)",
            "",
            "            :request: Werkzueg/Flask request",
            "",
            "        The default implementation returns True if either the Content-Type is",
            "        \"application/json\" or the best Accept header value is \"application/json\".",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._want_json = fn",
            "",
            "    def unauthz_handler(self, cb):",
            "        \"\"\"",
            "        Callback for failed authorization.",
            "        This is called by the :func:`roles_required`, :func:`roles_accepted`,",
            "        :func:`permissions_required`, or :func:`permissions_accepted`",
            "        if a role or permission is missing.",
            "",
            "        :param cb: Callback function with signature (func, params)",
            "",
            "            :func: the decorator function (e.g. roles_required)",
            "            :params: list of what (if any) was passed to the decorator.",
            "",
            "        Should return a Response or something Flask can create a Response from.",
            "        Can raise an exception if it is handled as part of",
            "        flask.errorhandler(<exception>)",
            "",
            "        With the passed parameters the application could deliver a concise error",
            "        message.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._unauthz_handler = cb",
            "",
            "    def unauthn_handler(self, cb):",
            "        \"\"\"",
            "        Callback for failed authentication.",
            "        This is called by :func:`auth_required`, :func:`auth_token_required`",
            "        or :func:`http_auth_required` if authentication fails.",
            "",
            "        :param cb: Callback function with signature (mechanisms, headers=None)",
            "",
            "            :mechanisms: List of which authentication mechanisms were tried",
            "            :headers: dict of headers to return",
            "",
            "        Should return a Response or something Flask can create a Response from.",
            "        Can raise an exception if it is handled as part of",
            "        ``flask.errorhandler(<exception>)``",
            "",
            "        The default implementation will return a 401 response if the request was JSON,",
            "        otherwise lets ``flask_login.login_manager.unauthorized()`` handle redirects.",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        self._state._unauthn_handler = cb",
            "",
            "    def reauthn_handler(self, cb):",
            "        \"\"\"",
            "        Callback when endpoint required a fresh authentication.",
            "        This is called by :func:`auth_required`.",
            "",
            "        :param cb: Callback function with signature (within, grace)",
            "",
            "            :within: timedelta that endpoint required fresh authentication within.",
            "            :grace: timedelta of grace period that endpoint allowed.",
            "",
            "        Should return a Response or something Flask can create a Response from.",
            "        Can raise an exception if it is handled as part of",
            "        ``flask.errorhandler(<exception>)``",
            "",
            "        The default implementation will return a 401 response if the request was JSON,",
            "        otherwise will redirect to :py:data:`SECURITY_US_VERIFY_URL`",
            "        (if :py:data:`SECURITY_UNIFIED_SIGNIN` is enabled)",
            "        else to :py:data:`SECURITY_VERIFY_URL`.",
            "        If both of those are None it sends an ``abort(401)``.",
            "",
            "        See :meth:`flask_security.auth_required` for details about freshness checking.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        self._state._reauthn_handler = cb",
            "",
            "    def __getattr__(self, name):",
            "        return getattr(self._state, name, None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": []
        },
        "addLocation": []
    },
    "flask_security/datastore.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 319,
                "PatchRowcode": "                 perms = \",\".join(perms)"
            },
            "1": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "             elif isinstance(perms, str):"
            },
            "2": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "                 # squash spaces."
            },
            "3": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                perms = \",\".join([p.strip() for p in perms.split(\",\")])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+                perms = \",\".join(p.strip() for p in perms.split(\",\"))"
            },
            "5": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 323,
                "PatchRowcode": "             kwargs[\"permissions\"] = perms"
            },
            "6": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 324,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         role = self.role_model(**kwargs)"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "    flask_security.datastore",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    This module contains an user datastore classes.",
            "",
            "    :copyright: (c) 2012 by Matt Wright.",
            "    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "import json",
            "import uuid",
            "",
            "from .utils import config_value",
            "",
            "",
            "class Datastore:",
            "    def __init__(self, db):",
            "        self.db = db",
            "",
            "    def commit(self):",
            "        pass",
            "",
            "    def put(self, model):",
            "        raise NotImplementedError",
            "",
            "    def delete(self, model):",
            "        raise NotImplementedError",
            "",
            "",
            "class SQLAlchemyDatastore(Datastore):",
            "    def commit(self):",
            "        self.db.session.commit()",
            "",
            "    def put(self, model):",
            "        self.db.session.add(model)",
            "        return model",
            "",
            "    def delete(self, model):",
            "        self.db.session.delete(model)",
            "",
            "",
            "class MongoEngineDatastore(Datastore):",
            "    def put(self, model):",
            "        model.save()",
            "        return model",
            "",
            "    def delete(self, model):",
            "        model.delete()",
            "",
            "",
            "class PeeweeDatastore(Datastore):",
            "    def put(self, model):",
            "        model.save()",
            "        return model",
            "",
            "    def delete(self, model):",
            "        model.delete_instance(recursive=True)",
            "",
            "",
            "def with_pony_session(f):",
            "    from functools import wraps",
            "",
            "    @wraps(f)",
            "    def decorator(*args, **kwargs):",
            "        from pony.orm import db_session",
            "        from pony.orm.core import local",
            "        from flask import (",
            "            after_this_request,",
            "            current_app,",
            "            has_app_context,",
            "            has_request_context,",
            "        )",
            "        from flask.signals import appcontext_popped",
            "",
            "        register = local.db_context_counter == 0",
            "        if register and (has_app_context() or has_request_context()):",
            "            db_session.__enter__()",
            "",
            "        result = f(*args, **kwargs)",
            "",
            "        if register:",
            "            if has_request_context():",
            "",
            "                @after_this_request",
            "                def pop(request):",
            "                    db_session.__exit__()",
            "                    return request",
            "",
            "            elif has_app_context():",
            "",
            "                @appcontext_popped.connect_via(current_app._get_current_object())",
            "                def pop(sender, *args, **kwargs):",
            "                    while local.db_context_counter:",
            "                        db_session.__exit__()",
            "",
            "            else:",
            "                raise RuntimeError(\"Needs app or request context\")",
            "        return result",
            "",
            "    return decorator",
            "",
            "",
            "class PonyDatastore(Datastore):",
            "    def commit(self):",
            "        self.db.commit()",
            "",
            "    @with_pony_session",
            "    def put(self, model):",
            "        return model",
            "",
            "    @with_pony_session",
            "    def delete(self, model):",
            "        model.delete()",
            "",
            "",
            "class UserDatastore:",
            "    \"\"\"Abstracted user datastore.",
            "",
            "    :param user_model: A user model class definition",
            "    :param role_model: A role model class definition",
            "",
            "    .. important::",
            "        For mutating operations, the user/role will be added to the",
            "        datastore (by calling self.put(<object>). If the datastore is session based",
            "        (such as for SQLAlchemyDatastore) it is up to caller to actually",
            "        commit the transaction by calling datastore.commit().",
            "    \"\"\"",
            "",
            "    def __init__(self, user_model, role_model):",
            "        self.user_model = user_model",
            "        self.role_model = role_model",
            "",
            "    def _prepare_role_modify_args(self, role):",
            "        if isinstance(role, str):",
            "            role = self.find_role(role)",
            "        return role",
            "",
            "    def _prepare_create_user_args(self, **kwargs):",
            "        kwargs.setdefault(\"active\", True)",
            "        roles = kwargs.get(\"roles\", [])",
            "        for i, role in enumerate(roles):",
            "            rn = role.name if isinstance(role, self.role_model) else role",
            "            # see if the role exists",
            "            roles[i] = self.find_role(rn)",
            "        kwargs[\"roles\"] = roles",
            "        kwargs.setdefault(\"fs_uniquifier\", uuid.uuid4().hex)",
            "        if hasattr(self.user_model, \"fs_token_uniquifier\"):",
            "            kwargs.setdefault(\"fs_token_uniquifier\", uuid.uuid4().hex)",
            "",
            "        return kwargs",
            "",
            "    def find_user(self, *args, **kwargs):",
            "        \"\"\"Returns a user matching the provided parameters.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_role(self, *args, **kwargs):",
            "        \"\"\"Returns a role matching the provided name.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_role_to_user(self, user, role):",
            "        \"\"\"Adds a role to a user.",
            "",
            "        :param user: The user to manipulate. Can be an User object or email",
            "        :param role: The role to add to the user. Can be a Role object or",
            "            string role name",
            "        :return: True is role was added, False if role already existed.",
            "        \"\"\"",
            "        role = self._prepare_role_modify_args(role)",
            "        if role not in user.roles:",
            "            user.roles.append(role)",
            "            self.put(user)",
            "            return True",
            "        return False",
            "",
            "    def remove_role_from_user(self, user, role):",
            "        \"\"\"Removes a role from a user.",
            "",
            "        :param user: The user to manipulate. Can be an User object or email",
            "        :param role: The role to remove from the user. Can be a Role object or",
            "            string role name",
            "        :return: True if role was removed, False if role doesn't exist or user didn't",
            "            have role.",
            "        \"\"\"",
            "        rv = False",
            "        role = self._prepare_role_modify_args(role)",
            "        if role in user.roles:",
            "            rv = True",
            "            user.roles.remove(role)",
            "            self.put(user)",
            "        return rv",
            "",
            "    def add_permissions_to_role(self, role, permissions):",
            "        \"\"\"Add one or more permissions to role.",
            "",
            "        :param role: The role to modify. Can be a Role object or",
            "            string role name",
            "        :param permissions: a set, list, or single string.",
            "        :return: True if permissions added, False if role doesn't exist.",
            "",
            "        Caller must commit to DB.",
            "",
            "        .. versionadded:: 4.0.0",
            "        \"\"\"",
            "",
            "        rv = False",
            "        role = self._prepare_role_modify_args(role)",
            "        if role:",
            "            rv = True",
            "            role.add_permissions(permissions)",
            "            self.put(role)",
            "        return rv",
            "",
            "    def remove_permissions_from_role(self, role, permissions):",
            "        \"\"\"Remove one or more permissions from a role.",
            "",
            "        :param role: The role to modify. Can be a Role object or",
            "            string role name",
            "        :param permissions: a set, list, or single string.",
            "        :return: True if permissions removed, False if role doesn't exist.",
            "",
            "        Caller must commit to DB.",
            "",
            "        .. versionadded:: 4.0.0",
            "        \"\"\"",
            "",
            "        rv = False",
            "        role = self._prepare_role_modify_args(role)",
            "        if role:",
            "            rv = True",
            "            role.remove_permissions(permissions)",
            "            self.put(role)",
            "        return rv",
            "",
            "    def toggle_active(self, user):",
            "        \"\"\"Toggles a user's active status. Always returns True.\"\"\"",
            "        user.active = not user.active",
            "        self.put(user)",
            "        return True",
            "",
            "    def deactivate_user(self, user):",
            "        \"\"\"Deactivates a specified user. Returns `True` if a change was made.",
            "",
            "        This will immediately disallow access to all endpoints that require",
            "        authentication either via session or tokens.",
            "        The user will not be able to log in again.",
            "",
            "        :param user: The user to deactivate",
            "        \"\"\"",
            "        if user.active:",
            "            user.active = False",
            "            self.put(user)",
            "            return True",
            "        return False",
            "",
            "    def activate_user(self, user):",
            "        \"\"\"Activates a specified user. Returns `True` if a change was made.",
            "",
            "        :param user: The user to activate",
            "        \"\"\"",
            "        if not user.active:",
            "            user.active = True",
            "            self.put(user)",
            "            return True",
            "        return False",
            "",
            "    def set_uniquifier(self, user, uniquifier=None):",
            "        \"\"\"Set user's Flask-Security identity key.",
            "        This will immediately render outstanding auth tokens,",
            "        session cookies and remember cookies invalid.",
            "",
            "        :param user: User to modify",
            "        :param uniquifier: Unique value - if none then uuid.uuid4().hex is used",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        if not uniquifier:",
            "            uniquifier = uuid.uuid4().hex",
            "        user.fs_uniquifier = uniquifier",
            "        self.put(user)",
            "",
            "    def set_token_uniquifier(self, user, uniquifier=None):",
            "        \"\"\"Set user's auth token identity key.",
            "        This will immediately render outstanding auth tokens invalid.",
            "",
            "        :param user: User to modify",
            "        :param uniquifier: Unique value - if none then uuid.uuid4().hex is used",
            "",
            "        This method is a no-op if the user model doesn't contain the attribute",
            "        ``fs_token_uniquifier``",
            "",
            "        .. versionadded:: 4.0.0",
            "        \"\"\"",
            "        if not uniquifier:",
            "            uniquifier = uuid.uuid4().hex",
            "        if hasattr(user, \"fs_token_uniquifier\"):",
            "            user.fs_token_uniquifier = uniquifier",
            "            self.put(user)",
            "",
            "    def create_role(self, **kwargs):",
            "        \"\"\"",
            "        Creates and returns a new role from the given parameters.",
            "        Supported params (depending on RoleModel):",
            "",
            "        :kwparam name: Role name",
            "        :kwparam permissions: a comma delimited list of permissions, a set or a list.",
            "            These are user-defined strings that correspond to strings used with",
            "            @permissions_required()",
            "",
            "            .. versionadded:: 3.3.0",
            "",
            "        \"\"\"",
            "",
            "        # By default we just use raw DB model create - for permissions we want to",
            "        # be nicer and allow sending in a list or set or comma separated string.",
            "        if \"permissions\" in kwargs and hasattr(self.role_model, \"permissions\"):",
            "            perms = kwargs[\"permissions\"]",
            "            if isinstance(perms, list) or isinstance(perms, set):",
            "                perms = \",\".join(perms)",
            "            elif isinstance(perms, str):",
            "                # squash spaces.",
            "                perms = \",\".join([p.strip() for p in perms.split(\",\")])",
            "            kwargs[\"permissions\"] = perms",
            "",
            "        role = self.role_model(**kwargs)",
            "        return self.put(role)",
            "",
            "    def find_or_create_role(self, name, **kwargs):",
            "        \"\"\"Returns a role matching the given name or creates it with any",
            "        additionally provided parameters.",
            "        \"\"\"",
            "        kwargs[\"name\"] = name",
            "        return self.find_role(name) or self.create_role(**kwargs)",
            "",
            "    def create_user(self, **kwargs):",
            "        \"\"\"Creates and returns a new user from the given parameters.",
            "",
            "        :kwparam email: required.",
            "        :kwparam password:  Hashed password.",
            "        :kwparam roles: list of roles to be added to user.",
            "            Can be Role objects or strings",
            "",
            "        Any other element of the User data model may be supplied as well.",
            "",
            "        .. note::",
            "            No normalization is done on email - it is assumed the caller has already",
            "            done that.",
            "",
            "            Best practice is::",
            "",
            "                try:",
            "                    enorm = app.security._mail_util.validate(email)",
            "                except ValueError:",
            "",
            "        .. note::",
            "            The roles kwparam is modified as part of the call - it will, if necessary",
            "            be converted from names to role instances.",
            "",
            "        .. danger::",
            "           Be aware that whatever `password` is passed in will",
            "           be stored directly in the DB. Do NOT pass in a plaintext password!",
            "           Best practice is to pass in ``hash_password(plaintext_password)``.",
            "",
            "           Furthermore, no validation nor normalization is done on the password",
            "           (e.g for minimum length).",
            "",
            "           Best practice is::",
            "",
            "            pbad, pnorm = app.security._password_util.validate(password, True)",
            "",
            "           Look for `pbad` being None. Pass the normalized password `pnorm` to this",
            "           method.",
            "",
            "        The new user's ``active`` property will be set to ``True``",
            "        unless explicitly set to ``False`` in `kwargs` (e.g. active = False)",
            "        \"\"\"",
            "        kwargs = self._prepare_create_user_args(**kwargs)",
            "        user = self.user_model(**kwargs)",
            "        return self.put(user)",
            "",
            "    def delete_user(self, user):",
            "        \"\"\"Deletes the specified user.",
            "",
            "        :param user: The user to delete",
            "        \"\"\"",
            "        self.delete(user)",
            "",
            "    def reset_user_access(self, user):",
            "        \"\"\"",
            "        Use this method to reset user authentication methods in the case of compromise.",
            "        This will:",
            "",
            "            * reset fs_uniquifier - which causes session cookie, remember cookie, auth",
            "              tokens to be unusable",
            "            * reset fs_token_uniquifier (if present) - cause auth tokens to be unusable",
            "            * remove all unified signin TOTP secrets so those can't be used",
            "            * remove all two-factor secrets so those can't be used",
            "",
            "        Note that if using unified sign in and allow 'email' as a way to receive a code;",
            "        if the email is compromised - login is still possible. To handle this - it",
            "        is better to deactivate the user.",
            "",
            "        Note - this method isn't used directly by Flask-Security - it is provided",
            "        as a helper for an application's administrative needs.",
            "",
            "        Remember to call commit on DB if needed.",
            "",
            "        .. versionadded:: 3.4.1",
            "        \"\"\"",
            "        self.set_uniquifier(user)",
            "        self.set_token_uniquifier(user)",
            "        if hasattr(user, \"us_totp_secrets\"):",
            "            self.us_reset(user)",
            "        if hasattr(user, \"tf_primary_method\"):",
            "            self.tf_reset(user)",
            "",
            "    def tf_set(self, user, primary_method, totp_secret=None, phone=None):",
            "        \"\"\"Set two-factor info into user record.",
            "        This carefully only changes things if different.",
            "",
            "        If totp_secret isn't provided - existing one won't be changed.",
            "        If phone isn't provided, the existing phone number won't be changed.",
            "",
            "        This could be called from an application to apiori setup a user for two factor",
            "        without the user having to go through the setup process.",
            "",
            "        To get a totp_secret - use ``app.security._totp_factory.generate_totp_secret()``",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "",
            "        changed = False",
            "        if user.tf_primary_method != primary_method:",
            "            user.tf_primary_method = primary_method",
            "            changed = True",
            "        if totp_secret and user.tf_totp_secret != totp_secret:",
            "            user.tf_totp_secret = totp_secret",
            "            changed = True",
            "        if phone and user.tf_phone_number != phone:",
            "            user.tf_phone_number = phone",
            "            changed = True",
            "        if changed:",
            "            self.put(user)",
            "",
            "    def tf_reset(self, user):",
            "        \"\"\"Disable two-factor auth for user",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "        user.tf_primary_method = None",
            "        user.tf_totp_secret = None",
            "        user.tf_phone_number = None",
            "        self.put(user)",
            "",
            "    def us_get_totp_secrets(self, user):",
            "        \"\"\"Return totp secrets.",
            "        These are json encoded in the DB.",
            "",
            "        Returns a dict with methods as keys and secrets as values.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        if not user.us_totp_secrets:",
            "            return {}",
            "        return json.loads(user.us_totp_secrets)",
            "",
            "    def us_put_totp_secrets(self, user, secrets):",
            "        \"\"\"Save secrets. Assume to be a dict (or None)",
            "        with keys as methods, and values as (encrypted) secrets.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        user.us_totp_secrets = json.dumps(secrets) if secrets else None",
            "        self.put(user)",
            "",
            "    def us_set(self, user, method, totp_secret=None, phone=None):",
            "        \"\"\"Set unified sign in info into user record.",
            "",
            "        If totp_secret isn't provided - existing one won't be changed.",
            "        If phone isn't provided, the existing phone number won't be changed.",
            "",
            "        This could be called from an application to apiori setup a user for unified",
            "        sign in without the user having to go through the setup process.",
            "",
            "        To get a totp_secret - use ``app.security._totp_factory.generate_totp_secret()``",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "",
            "        if totp_secret:",
            "            totp_secrets = self.us_get_totp_secrets(user)",
            "            totp_secrets[method] = totp_secret",
            "            self.us_put_totp_secrets(user, totp_secrets)",
            "        if phone and user.us_phone_number != phone:",
            "            user.us_phone_number = phone",
            "            self.put(user)",
            "",
            "    def us_reset(self, user):",
            "        \"\"\"Disable unified sign in for user.",
            "        Be aware that if \"email\" is an allowed way to receive codes, they",
            "        will still work (as totp secrets are generated on the fly).",
            "        This will disable authenticator app and SMS.",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "        user.us_totp_secrets = None",
            "        user.us_phone_number = None",
            "        self.put(user)",
            "",
            "",
            "class SQLAlchemyUserDatastore(SQLAlchemyDatastore, UserDatastore):",
            "    \"\"\"A SQLAlchemy datastore implementation for Flask-Security that assumes the",
            "    use of the Flask-SQLAlchemy extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model):",
            "        SQLAlchemyDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        from sqlalchemy import func as alchemyFn",
            "",
            "        query = self.user_model.query",
            "        if config_value(\"JOIN_USER_ROLES\") and hasattr(self.user_model, \"roles\"):",
            "            from sqlalchemy.orm import joinedload",
            "",
            "            query = query.options(joinedload(\"roles\"))",
            "",
            "        if case_insensitive:",
            "            # While it is of course possible to pass in multiple keys to filter on",
            "            # that isn't the normal use case. If caller asks for case_insensitive",
            "            # AND gives multiple keys - throw an error.",
            "            if len(kwargs) > 1:",
            "                raise ValueError(\"Case insensitive option only supports single key\")",
            "            attr, identifier = kwargs.popitem()",
            "            subquery = alchemyFn.lower(",
            "                getattr(self.user_model, attr)",
            "            ) == alchemyFn.lower(identifier)",
            "            return query.filter(subquery).first()",
            "        else:",
            "            return query.filter_by(**kwargs).first()",
            "",
            "    def find_role(self, role):",
            "        return self.role_model.query.filter_by(name=role).first()",
            "",
            "",
            "class SQLAlchemySessionUserDatastore(SQLAlchemyUserDatastore, SQLAlchemyDatastore):",
            "    \"\"\"A SQLAlchemy datastore implementation for Flask-Security that assumes the",
            "    use of the flask_sqlalchemy_session extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, session, user_model, role_model):",
            "        class PretendFlaskSQLAlchemyDb:",
            "            \"\"\"This is a pretend db object, so we can just pass in a session.\"\"\"",
            "",
            "            def __init__(self, session):",
            "                self.session = session",
            "",
            "        SQLAlchemyUserDatastore.__init__(",
            "            self, PretendFlaskSQLAlchemyDb(session), user_model, role_model",
            "        )",
            "",
            "    def commit(self):",
            "        super().commit()",
            "",
            "",
            "class MongoEngineUserDatastore(MongoEngineDatastore, UserDatastore):",
            "    \"\"\"A MongoEngine datastore implementation for Flask-Security that assumes",
            "    the use of the Flask-MongoEngine extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model):",
            "        MongoEngineDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        from mongoengine.queryset.visitor import Q, QCombination",
            "        from mongoengine.errors import ValidationError",
            "",
            "        try:",
            "            if case_insensitive:",
            "                # While it is of course possible to pass in multiple keys to filter on",
            "                # that isn't the normal use case. If caller asks for case_insensitive",
            "                # AND gives multiple keys - throw an error.",
            "                if len(kwargs) > 1:",
            "                    raise ValueError(\"Case insensitive option only supports single key\")",
            "                attr, identifier = kwargs.popitem()",
            "                query = {f\"{attr}__iexact\": identifier}",
            "                return self.user_model.objects(**query).first()",
            "            else:",
            "                queries = map(lambda i: Q(**{i[0]: i[1]}), kwargs.items())",
            "                query = QCombination(QCombination.AND, queries)",
            "                return self.user_model.objects(query).first()",
            "        except ValidationError:  # pragma: no cover",
            "            return None",
            "",
            "    def find_role(self, role):",
            "        return self.role_model.objects(name=role).first()",
            "",
            "",
            "class PeeweeUserDatastore(PeeweeDatastore, UserDatastore):",
            "    \"\"\"A PeeweeD datastore implementation for Flask-Security that assumes the",
            "    use of Peewee Flask utils.",
            "",
            "    :param user_model: A user model class definition",
            "    :param role_model: A role model class definition",
            "    :param role_link: A model implementing the many-to-many user-role relation",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model, role_link):",
            "        PeeweeDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "        self.UserRole = role_link",
            "",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        from peewee import fn as peeweeFn",
            "",
            "        try:",
            "            if case_insensitive:",
            "                # While it is of course possible to pass in multiple keys to filter on",
            "                # that isn't the normal use case. If caller asks for case_insensitive",
            "                # AND gives multiple keys - throw an error.",
            "                if len(kwargs) > 1:",
            "                    raise ValueError(\"Case insensitive option only supports single key\")",
            "                attr, identifier = kwargs.popitem()",
            "                return self.user_model.get(",
            "                    peeweeFn.lower(getattr(self.user_model, attr))",
            "                    == peeweeFn.lower(identifier)",
            "                )",
            "            else:",
            "                return self.user_model.filter(**kwargs).get()",
            "        except self.user_model.DoesNotExist:",
            "            return None",
            "",
            "    def find_role(self, role):",
            "        try:",
            "            return self.role_model.filter(name=role).get()",
            "        except self.role_model.DoesNotExist:",
            "            return None",
            "",
            "    def create_user(self, **kwargs):",
            "        \"\"\"Creates and returns a new user from the given parameters.\"\"\"",
            "        roles = kwargs.pop(\"roles\", [])",
            "        user = self.user_model(**self._prepare_create_user_args(**kwargs))",
            "        user = self.put(user)",
            "        for role in roles:",
            "            self.add_role_to_user(user, role)",
            "        self.put(user)",
            "        return user",
            "",
            "    def add_role_to_user(self, user, role):",
            "        \"\"\"Adds a role to a user.",
            "",
            "        :param user: The user to manipulate",
            "        :param role: The role to add to the user",
            "        \"\"\"",
            "        role = self._prepare_role_modify_args(role)",
            "        result = self.UserRole.select().where(",
            "            self.UserRole.user == user.id, self.UserRole.role == role.id",
            "        )",
            "        if result.count():",
            "            return False",
            "        else:",
            "            self.put(self.UserRole.create(user=user.id, role=role.id))",
            "            return True",
            "",
            "    def remove_role_from_user(self, user, role):",
            "        \"\"\"Removes a role from a user.",
            "",
            "        :param user: The user to manipulate",
            "        :param role: The role to remove from the user",
            "        \"\"\"",
            "        role = self._prepare_role_modify_args(role)",
            "        result = self.UserRole.select().where(",
            "            self.UserRole.user == user, self.UserRole.role == role",
            "        )",
            "        if result.count():",
            "            query = self.UserRole.delete().where(",
            "                self.UserRole.user == user, self.UserRole.role == role",
            "            )",
            "            query.execute()",
            "            return True",
            "        else:",
            "            return False",
            "",
            "",
            "class PonyUserDatastore(PonyDatastore, UserDatastore):",
            "    \"\"\"A Pony ORM datastore implementation for Flask-Security.",
            "",
            "    Code primarily from https://github.com/ET-CS but taken over after",
            "    being abandoned.",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model):",
            "        PonyDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "",
            "    @with_pony_session",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        if case_insensitive:",
            "            # While it is of course possible to pass in multiple keys to filter on",
            "            # that isn't the normal use case. If caller asks for case_insensitive",
            "            # AND gives multiple keys - throw an error.",
            "            if len(kwargs) > 1:",
            "                raise ValueError(\"Case insensitive option only supports single key\")",
            "            # TODO - implement case insensitive look ups.",
            "",
            "        return self.user_model.get(**kwargs)",
            "",
            "    @with_pony_session",
            "    def find_role(self, role):",
            "        return self.role_model.get(name=role)",
            "",
            "    @with_pony_session",
            "    def add_role_to_user(self, *args, **kwargs):",
            "        return super().add_role_to_user(*args, **kwargs)",
            "",
            "    @with_pony_session",
            "    def create_user(self, **kwargs):",
            "        return super().create_user(**kwargs)",
            "",
            "    @with_pony_session",
            "    def create_role(self, **kwargs):",
            "        return super().create_role(**kwargs)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "    flask_security.datastore",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    This module contains an user datastore classes.",
            "",
            "    :copyright: (c) 2012 by Matt Wright.",
            "    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "import json",
            "import uuid",
            "",
            "from .utils import config_value",
            "",
            "",
            "class Datastore:",
            "    def __init__(self, db):",
            "        self.db = db",
            "",
            "    def commit(self):",
            "        pass",
            "",
            "    def put(self, model):",
            "        raise NotImplementedError",
            "",
            "    def delete(self, model):",
            "        raise NotImplementedError",
            "",
            "",
            "class SQLAlchemyDatastore(Datastore):",
            "    def commit(self):",
            "        self.db.session.commit()",
            "",
            "    def put(self, model):",
            "        self.db.session.add(model)",
            "        return model",
            "",
            "    def delete(self, model):",
            "        self.db.session.delete(model)",
            "",
            "",
            "class MongoEngineDatastore(Datastore):",
            "    def put(self, model):",
            "        model.save()",
            "        return model",
            "",
            "    def delete(self, model):",
            "        model.delete()",
            "",
            "",
            "class PeeweeDatastore(Datastore):",
            "    def put(self, model):",
            "        model.save()",
            "        return model",
            "",
            "    def delete(self, model):",
            "        model.delete_instance(recursive=True)",
            "",
            "",
            "def with_pony_session(f):",
            "    from functools import wraps",
            "",
            "    @wraps(f)",
            "    def decorator(*args, **kwargs):",
            "        from pony.orm import db_session",
            "        from pony.orm.core import local",
            "        from flask import (",
            "            after_this_request,",
            "            current_app,",
            "            has_app_context,",
            "            has_request_context,",
            "        )",
            "        from flask.signals import appcontext_popped",
            "",
            "        register = local.db_context_counter == 0",
            "        if register and (has_app_context() or has_request_context()):",
            "            db_session.__enter__()",
            "",
            "        result = f(*args, **kwargs)",
            "",
            "        if register:",
            "            if has_request_context():",
            "",
            "                @after_this_request",
            "                def pop(request):",
            "                    db_session.__exit__()",
            "                    return request",
            "",
            "            elif has_app_context():",
            "",
            "                @appcontext_popped.connect_via(current_app._get_current_object())",
            "                def pop(sender, *args, **kwargs):",
            "                    while local.db_context_counter:",
            "                        db_session.__exit__()",
            "",
            "            else:",
            "                raise RuntimeError(\"Needs app or request context\")",
            "        return result",
            "",
            "    return decorator",
            "",
            "",
            "class PonyDatastore(Datastore):",
            "    def commit(self):",
            "        self.db.commit()",
            "",
            "    @with_pony_session",
            "    def put(self, model):",
            "        return model",
            "",
            "    @with_pony_session",
            "    def delete(self, model):",
            "        model.delete()",
            "",
            "",
            "class UserDatastore:",
            "    \"\"\"Abstracted user datastore.",
            "",
            "    :param user_model: A user model class definition",
            "    :param role_model: A role model class definition",
            "",
            "    .. important::",
            "        For mutating operations, the user/role will be added to the",
            "        datastore (by calling self.put(<object>). If the datastore is session based",
            "        (such as for SQLAlchemyDatastore) it is up to caller to actually",
            "        commit the transaction by calling datastore.commit().",
            "    \"\"\"",
            "",
            "    def __init__(self, user_model, role_model):",
            "        self.user_model = user_model",
            "        self.role_model = role_model",
            "",
            "    def _prepare_role_modify_args(self, role):",
            "        if isinstance(role, str):",
            "            role = self.find_role(role)",
            "        return role",
            "",
            "    def _prepare_create_user_args(self, **kwargs):",
            "        kwargs.setdefault(\"active\", True)",
            "        roles = kwargs.get(\"roles\", [])",
            "        for i, role in enumerate(roles):",
            "            rn = role.name if isinstance(role, self.role_model) else role",
            "            # see if the role exists",
            "            roles[i] = self.find_role(rn)",
            "        kwargs[\"roles\"] = roles",
            "        kwargs.setdefault(\"fs_uniquifier\", uuid.uuid4().hex)",
            "        if hasattr(self.user_model, \"fs_token_uniquifier\"):",
            "            kwargs.setdefault(\"fs_token_uniquifier\", uuid.uuid4().hex)",
            "",
            "        return kwargs",
            "",
            "    def find_user(self, *args, **kwargs):",
            "        \"\"\"Returns a user matching the provided parameters.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def find_role(self, *args, **kwargs):",
            "        \"\"\"Returns a role matching the provided name.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def add_role_to_user(self, user, role):",
            "        \"\"\"Adds a role to a user.",
            "",
            "        :param user: The user to manipulate. Can be an User object or email",
            "        :param role: The role to add to the user. Can be a Role object or",
            "            string role name",
            "        :return: True is role was added, False if role already existed.",
            "        \"\"\"",
            "        role = self._prepare_role_modify_args(role)",
            "        if role not in user.roles:",
            "            user.roles.append(role)",
            "            self.put(user)",
            "            return True",
            "        return False",
            "",
            "    def remove_role_from_user(self, user, role):",
            "        \"\"\"Removes a role from a user.",
            "",
            "        :param user: The user to manipulate. Can be an User object or email",
            "        :param role: The role to remove from the user. Can be a Role object or",
            "            string role name",
            "        :return: True if role was removed, False if role doesn't exist or user didn't",
            "            have role.",
            "        \"\"\"",
            "        rv = False",
            "        role = self._prepare_role_modify_args(role)",
            "        if role in user.roles:",
            "            rv = True",
            "            user.roles.remove(role)",
            "            self.put(user)",
            "        return rv",
            "",
            "    def add_permissions_to_role(self, role, permissions):",
            "        \"\"\"Add one or more permissions to role.",
            "",
            "        :param role: The role to modify. Can be a Role object or",
            "            string role name",
            "        :param permissions: a set, list, or single string.",
            "        :return: True if permissions added, False if role doesn't exist.",
            "",
            "        Caller must commit to DB.",
            "",
            "        .. versionadded:: 4.0.0",
            "        \"\"\"",
            "",
            "        rv = False",
            "        role = self._prepare_role_modify_args(role)",
            "        if role:",
            "            rv = True",
            "            role.add_permissions(permissions)",
            "            self.put(role)",
            "        return rv",
            "",
            "    def remove_permissions_from_role(self, role, permissions):",
            "        \"\"\"Remove one or more permissions from a role.",
            "",
            "        :param role: The role to modify. Can be a Role object or",
            "            string role name",
            "        :param permissions: a set, list, or single string.",
            "        :return: True if permissions removed, False if role doesn't exist.",
            "",
            "        Caller must commit to DB.",
            "",
            "        .. versionadded:: 4.0.0",
            "        \"\"\"",
            "",
            "        rv = False",
            "        role = self._prepare_role_modify_args(role)",
            "        if role:",
            "            rv = True",
            "            role.remove_permissions(permissions)",
            "            self.put(role)",
            "        return rv",
            "",
            "    def toggle_active(self, user):",
            "        \"\"\"Toggles a user's active status. Always returns True.\"\"\"",
            "        user.active = not user.active",
            "        self.put(user)",
            "        return True",
            "",
            "    def deactivate_user(self, user):",
            "        \"\"\"Deactivates a specified user. Returns `True` if a change was made.",
            "",
            "        This will immediately disallow access to all endpoints that require",
            "        authentication either via session or tokens.",
            "        The user will not be able to log in again.",
            "",
            "        :param user: The user to deactivate",
            "        \"\"\"",
            "        if user.active:",
            "            user.active = False",
            "            self.put(user)",
            "            return True",
            "        return False",
            "",
            "    def activate_user(self, user):",
            "        \"\"\"Activates a specified user. Returns `True` if a change was made.",
            "",
            "        :param user: The user to activate",
            "        \"\"\"",
            "        if not user.active:",
            "            user.active = True",
            "            self.put(user)",
            "            return True",
            "        return False",
            "",
            "    def set_uniquifier(self, user, uniquifier=None):",
            "        \"\"\"Set user's Flask-Security identity key.",
            "        This will immediately render outstanding auth tokens,",
            "        session cookies and remember cookies invalid.",
            "",
            "        :param user: User to modify",
            "        :param uniquifier: Unique value - if none then uuid.uuid4().hex is used",
            "",
            "        .. versionadded:: 3.3.0",
            "        \"\"\"",
            "        if not uniquifier:",
            "            uniquifier = uuid.uuid4().hex",
            "        user.fs_uniquifier = uniquifier",
            "        self.put(user)",
            "",
            "    def set_token_uniquifier(self, user, uniquifier=None):",
            "        \"\"\"Set user's auth token identity key.",
            "        This will immediately render outstanding auth tokens invalid.",
            "",
            "        :param user: User to modify",
            "        :param uniquifier: Unique value - if none then uuid.uuid4().hex is used",
            "",
            "        This method is a no-op if the user model doesn't contain the attribute",
            "        ``fs_token_uniquifier``",
            "",
            "        .. versionadded:: 4.0.0",
            "        \"\"\"",
            "        if not uniquifier:",
            "            uniquifier = uuid.uuid4().hex",
            "        if hasattr(user, \"fs_token_uniquifier\"):",
            "            user.fs_token_uniquifier = uniquifier",
            "            self.put(user)",
            "",
            "    def create_role(self, **kwargs):",
            "        \"\"\"",
            "        Creates and returns a new role from the given parameters.",
            "        Supported params (depending on RoleModel):",
            "",
            "        :kwparam name: Role name",
            "        :kwparam permissions: a comma delimited list of permissions, a set or a list.",
            "            These are user-defined strings that correspond to strings used with",
            "            @permissions_required()",
            "",
            "            .. versionadded:: 3.3.0",
            "",
            "        \"\"\"",
            "",
            "        # By default we just use raw DB model create - for permissions we want to",
            "        # be nicer and allow sending in a list or set or comma separated string.",
            "        if \"permissions\" in kwargs and hasattr(self.role_model, \"permissions\"):",
            "            perms = kwargs[\"permissions\"]",
            "            if isinstance(perms, list) or isinstance(perms, set):",
            "                perms = \",\".join(perms)",
            "            elif isinstance(perms, str):",
            "                # squash spaces.",
            "                perms = \",\".join(p.strip() for p in perms.split(\",\"))",
            "            kwargs[\"permissions\"] = perms",
            "",
            "        role = self.role_model(**kwargs)",
            "        return self.put(role)",
            "",
            "    def find_or_create_role(self, name, **kwargs):",
            "        \"\"\"Returns a role matching the given name or creates it with any",
            "        additionally provided parameters.",
            "        \"\"\"",
            "        kwargs[\"name\"] = name",
            "        return self.find_role(name) or self.create_role(**kwargs)",
            "",
            "    def create_user(self, **kwargs):",
            "        \"\"\"Creates and returns a new user from the given parameters.",
            "",
            "        :kwparam email: required.",
            "        :kwparam password:  Hashed password.",
            "        :kwparam roles: list of roles to be added to user.",
            "            Can be Role objects or strings",
            "",
            "        Any other element of the User data model may be supplied as well.",
            "",
            "        .. note::",
            "            No normalization is done on email - it is assumed the caller has already",
            "            done that.",
            "",
            "            Best practice is::",
            "",
            "                try:",
            "                    enorm = app.security._mail_util.validate(email)",
            "                except ValueError:",
            "",
            "        .. note::",
            "            The roles kwparam is modified as part of the call - it will, if necessary",
            "            be converted from names to role instances.",
            "",
            "        .. danger::",
            "           Be aware that whatever `password` is passed in will",
            "           be stored directly in the DB. Do NOT pass in a plaintext password!",
            "           Best practice is to pass in ``hash_password(plaintext_password)``.",
            "",
            "           Furthermore, no validation nor normalization is done on the password",
            "           (e.g for minimum length).",
            "",
            "           Best practice is::",
            "",
            "            pbad, pnorm = app.security._password_util.validate(password, True)",
            "",
            "           Look for `pbad` being None. Pass the normalized password `pnorm` to this",
            "           method.",
            "",
            "        The new user's ``active`` property will be set to ``True``",
            "        unless explicitly set to ``False`` in `kwargs` (e.g. active = False)",
            "        \"\"\"",
            "        kwargs = self._prepare_create_user_args(**kwargs)",
            "        user = self.user_model(**kwargs)",
            "        return self.put(user)",
            "",
            "    def delete_user(self, user):",
            "        \"\"\"Deletes the specified user.",
            "",
            "        :param user: The user to delete",
            "        \"\"\"",
            "        self.delete(user)",
            "",
            "    def reset_user_access(self, user):",
            "        \"\"\"",
            "        Use this method to reset user authentication methods in the case of compromise.",
            "        This will:",
            "",
            "            * reset fs_uniquifier - which causes session cookie, remember cookie, auth",
            "              tokens to be unusable",
            "            * reset fs_token_uniquifier (if present) - cause auth tokens to be unusable",
            "            * remove all unified signin TOTP secrets so those can't be used",
            "            * remove all two-factor secrets so those can't be used",
            "",
            "        Note that if using unified sign in and allow 'email' as a way to receive a code;",
            "        if the email is compromised - login is still possible. To handle this - it",
            "        is better to deactivate the user.",
            "",
            "        Note - this method isn't used directly by Flask-Security - it is provided",
            "        as a helper for an application's administrative needs.",
            "",
            "        Remember to call commit on DB if needed.",
            "",
            "        .. versionadded:: 3.4.1",
            "        \"\"\"",
            "        self.set_uniquifier(user)",
            "        self.set_token_uniquifier(user)",
            "        if hasattr(user, \"us_totp_secrets\"):",
            "            self.us_reset(user)",
            "        if hasattr(user, \"tf_primary_method\"):",
            "            self.tf_reset(user)",
            "",
            "    def tf_set(self, user, primary_method, totp_secret=None, phone=None):",
            "        \"\"\"Set two-factor info into user record.",
            "        This carefully only changes things if different.",
            "",
            "        If totp_secret isn't provided - existing one won't be changed.",
            "        If phone isn't provided, the existing phone number won't be changed.",
            "",
            "        This could be called from an application to apiori setup a user for two factor",
            "        without the user having to go through the setup process.",
            "",
            "        To get a totp_secret - use ``app.security._totp_factory.generate_totp_secret()``",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "",
            "        changed = False",
            "        if user.tf_primary_method != primary_method:",
            "            user.tf_primary_method = primary_method",
            "            changed = True",
            "        if totp_secret and user.tf_totp_secret != totp_secret:",
            "            user.tf_totp_secret = totp_secret",
            "            changed = True",
            "        if phone and user.tf_phone_number != phone:",
            "            user.tf_phone_number = phone",
            "            changed = True",
            "        if changed:",
            "            self.put(user)",
            "",
            "    def tf_reset(self, user):",
            "        \"\"\"Disable two-factor auth for user",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "        user.tf_primary_method = None",
            "        user.tf_totp_secret = None",
            "        user.tf_phone_number = None",
            "        self.put(user)",
            "",
            "    def us_get_totp_secrets(self, user):",
            "        \"\"\"Return totp secrets.",
            "        These are json encoded in the DB.",
            "",
            "        Returns a dict with methods as keys and secrets as values.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        if not user.us_totp_secrets:",
            "            return {}",
            "        return json.loads(user.us_totp_secrets)",
            "",
            "    def us_put_totp_secrets(self, user, secrets):",
            "        \"\"\"Save secrets. Assume to be a dict (or None)",
            "        with keys as methods, and values as (encrypted) secrets.",
            "",
            "        .. versionadded:: 3.4.0",
            "        \"\"\"",
            "        user.us_totp_secrets = json.dumps(secrets) if secrets else None",
            "        self.put(user)",
            "",
            "    def us_set(self, user, method, totp_secret=None, phone=None):",
            "        \"\"\"Set unified sign in info into user record.",
            "",
            "        If totp_secret isn't provided - existing one won't be changed.",
            "        If phone isn't provided, the existing phone number won't be changed.",
            "",
            "        This could be called from an application to apiori setup a user for unified",
            "        sign in without the user having to go through the setup process.",
            "",
            "        To get a totp_secret - use ``app.security._totp_factory.generate_totp_secret()``",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "",
            "        if totp_secret:",
            "            totp_secrets = self.us_get_totp_secrets(user)",
            "            totp_secrets[method] = totp_secret",
            "            self.us_put_totp_secrets(user, totp_secrets)",
            "        if phone and user.us_phone_number != phone:",
            "            user.us_phone_number = phone",
            "            self.put(user)",
            "",
            "    def us_reset(self, user):",
            "        \"\"\"Disable unified sign in for user.",
            "        Be aware that if \"email\" is an allowed way to receive codes, they",
            "        will still work (as totp secrets are generated on the fly).",
            "        This will disable authenticator app and SMS.",
            "",
            "        .. versionadded: 3.4.1",
            "        \"\"\"",
            "        user.us_totp_secrets = None",
            "        user.us_phone_number = None",
            "        self.put(user)",
            "",
            "",
            "class SQLAlchemyUserDatastore(SQLAlchemyDatastore, UserDatastore):",
            "    \"\"\"A SQLAlchemy datastore implementation for Flask-Security that assumes the",
            "    use of the Flask-SQLAlchemy extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model):",
            "        SQLAlchemyDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        from sqlalchemy import func as alchemyFn",
            "",
            "        query = self.user_model.query",
            "        if config_value(\"JOIN_USER_ROLES\") and hasattr(self.user_model, \"roles\"):",
            "            from sqlalchemy.orm import joinedload",
            "",
            "            query = query.options(joinedload(\"roles\"))",
            "",
            "        if case_insensitive:",
            "            # While it is of course possible to pass in multiple keys to filter on",
            "            # that isn't the normal use case. If caller asks for case_insensitive",
            "            # AND gives multiple keys - throw an error.",
            "            if len(kwargs) > 1:",
            "                raise ValueError(\"Case insensitive option only supports single key\")",
            "            attr, identifier = kwargs.popitem()",
            "            subquery = alchemyFn.lower(",
            "                getattr(self.user_model, attr)",
            "            ) == alchemyFn.lower(identifier)",
            "            return query.filter(subquery).first()",
            "        else:",
            "            return query.filter_by(**kwargs).first()",
            "",
            "    def find_role(self, role):",
            "        return self.role_model.query.filter_by(name=role).first()",
            "",
            "",
            "class SQLAlchemySessionUserDatastore(SQLAlchemyUserDatastore, SQLAlchemyDatastore):",
            "    \"\"\"A SQLAlchemy datastore implementation for Flask-Security that assumes the",
            "    use of the flask_sqlalchemy_session extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, session, user_model, role_model):",
            "        class PretendFlaskSQLAlchemyDb:",
            "            \"\"\"This is a pretend db object, so we can just pass in a session.\"\"\"",
            "",
            "            def __init__(self, session):",
            "                self.session = session",
            "",
            "        SQLAlchemyUserDatastore.__init__(",
            "            self, PretendFlaskSQLAlchemyDb(session), user_model, role_model",
            "        )",
            "",
            "    def commit(self):",
            "        super().commit()",
            "",
            "",
            "class MongoEngineUserDatastore(MongoEngineDatastore, UserDatastore):",
            "    \"\"\"A MongoEngine datastore implementation for Flask-Security that assumes",
            "    the use of the Flask-MongoEngine extension.",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model):",
            "        MongoEngineDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        from mongoengine.queryset.visitor import Q, QCombination",
            "        from mongoengine.errors import ValidationError",
            "",
            "        try:",
            "            if case_insensitive:",
            "                # While it is of course possible to pass in multiple keys to filter on",
            "                # that isn't the normal use case. If caller asks for case_insensitive",
            "                # AND gives multiple keys - throw an error.",
            "                if len(kwargs) > 1:",
            "                    raise ValueError(\"Case insensitive option only supports single key\")",
            "                attr, identifier = kwargs.popitem()",
            "                query = {f\"{attr}__iexact\": identifier}",
            "                return self.user_model.objects(**query).first()",
            "            else:",
            "                queries = map(lambda i: Q(**{i[0]: i[1]}), kwargs.items())",
            "                query = QCombination(QCombination.AND, queries)",
            "                return self.user_model.objects(query).first()",
            "        except ValidationError:  # pragma: no cover",
            "            return None",
            "",
            "    def find_role(self, role):",
            "        return self.role_model.objects(name=role).first()",
            "",
            "",
            "class PeeweeUserDatastore(PeeweeDatastore, UserDatastore):",
            "    \"\"\"A PeeweeD datastore implementation for Flask-Security that assumes the",
            "    use of Peewee Flask utils.",
            "",
            "    :param user_model: A user model class definition",
            "    :param role_model: A role model class definition",
            "    :param role_link: A model implementing the many-to-many user-role relation",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model, role_link):",
            "        PeeweeDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "        self.UserRole = role_link",
            "",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        from peewee import fn as peeweeFn",
            "",
            "        try:",
            "            if case_insensitive:",
            "                # While it is of course possible to pass in multiple keys to filter on",
            "                # that isn't the normal use case. If caller asks for case_insensitive",
            "                # AND gives multiple keys - throw an error.",
            "                if len(kwargs) > 1:",
            "                    raise ValueError(\"Case insensitive option only supports single key\")",
            "                attr, identifier = kwargs.popitem()",
            "                return self.user_model.get(",
            "                    peeweeFn.lower(getattr(self.user_model, attr))",
            "                    == peeweeFn.lower(identifier)",
            "                )",
            "            else:",
            "                return self.user_model.filter(**kwargs).get()",
            "        except self.user_model.DoesNotExist:",
            "            return None",
            "",
            "    def find_role(self, role):",
            "        try:",
            "            return self.role_model.filter(name=role).get()",
            "        except self.role_model.DoesNotExist:",
            "            return None",
            "",
            "    def create_user(self, **kwargs):",
            "        \"\"\"Creates and returns a new user from the given parameters.\"\"\"",
            "        roles = kwargs.pop(\"roles\", [])",
            "        user = self.user_model(**self._prepare_create_user_args(**kwargs))",
            "        user = self.put(user)",
            "        for role in roles:",
            "            self.add_role_to_user(user, role)",
            "        self.put(user)",
            "        return user",
            "",
            "    def add_role_to_user(self, user, role):",
            "        \"\"\"Adds a role to a user.",
            "",
            "        :param user: The user to manipulate",
            "        :param role: The role to add to the user",
            "        \"\"\"",
            "        role = self._prepare_role_modify_args(role)",
            "        result = self.UserRole.select().where(",
            "            self.UserRole.user == user.id, self.UserRole.role == role.id",
            "        )",
            "        if result.count():",
            "            return False",
            "        else:",
            "            self.put(self.UserRole.create(user=user.id, role=role.id))",
            "            return True",
            "",
            "    def remove_role_from_user(self, user, role):",
            "        \"\"\"Removes a role from a user.",
            "",
            "        :param user: The user to manipulate",
            "        :param role: The role to remove from the user",
            "        \"\"\"",
            "        role = self._prepare_role_modify_args(role)",
            "        result = self.UserRole.select().where(",
            "            self.UserRole.user == user, self.UserRole.role == role",
            "        )",
            "        if result.count():",
            "            query = self.UserRole.delete().where(",
            "                self.UserRole.user == user, self.UserRole.role == role",
            "            )",
            "            query.execute()",
            "            return True",
            "        else:",
            "            return False",
            "",
            "",
            "class PonyUserDatastore(PonyDatastore, UserDatastore):",
            "    \"\"\"A Pony ORM datastore implementation for Flask-Security.",
            "",
            "    Code primarily from https://github.com/ET-CS but taken over after",
            "    being abandoned.",
            "    \"\"\"",
            "",
            "    def __init__(self, db, user_model, role_model):",
            "        PonyDatastore.__init__(self, db)",
            "        UserDatastore.__init__(self, user_model, role_model)",
            "",
            "    @with_pony_session",
            "    def find_user(self, case_insensitive=False, **kwargs):",
            "        if case_insensitive:",
            "            # While it is of course possible to pass in multiple keys to filter on",
            "            # that isn't the normal use case. If caller asks for case_insensitive",
            "            # AND gives multiple keys - throw an error.",
            "            if len(kwargs) > 1:",
            "                raise ValueError(\"Case insensitive option only supports single key\")",
            "            # TODO - implement case insensitive look ups.",
            "",
            "        return self.user_model.get(**kwargs)",
            "",
            "    @with_pony_session",
            "    def find_role(self, role):",
            "        return self.role_model.get(name=role)",
            "",
            "    @with_pony_session",
            "    def add_role_to_user(self, *args, **kwargs):",
            "        return super().add_role_to_user(*args, **kwargs)",
            "",
            "    @with_pony_session",
            "    def create_user(self, **kwargs):",
            "        return super().create_user(**kwargs)",
            "",
            "    @with_pony_session",
            "    def create_role(self, **kwargs):",
            "        return super().create_role(**kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "322": [
                "UserDatastore",
                "create_role"
            ]
        },
        "addLocation": []
    },
    "flask_security/decorators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 504,
                "afterPatchRowNumber": 504,
                "PatchRowcode": "     def wrapper(fn):"
            },
            "1": {
                "beforePatchRowNumber": 505,
                "afterPatchRowNumber": 505,
                "PatchRowcode": "         @wraps(fn)"
            },
            "2": {
                "beforePatchRowNumber": 506,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "         def decorated_view(*args, **kwargs):"
            },
            "3": {
                "beforePatchRowNumber": 507,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            perm = Permission(*[RoleNeed(role) for role in roles])"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+            perm = Permission(*(RoleNeed(role) for role in roles))"
            },
            "5": {
                "beforePatchRowNumber": 508,
                "afterPatchRowNumber": 508,
                "PatchRowcode": "             if perm.can():"
            },
            "6": {
                "beforePatchRowNumber": 509,
                "afterPatchRowNumber": 509,
                "PatchRowcode": "                 return fn(*args, **kwargs)"
            },
            "7": {
                "beforePatchRowNumber": 510,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "             if _security._unauthorized_callback:"
            },
            "8": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": 578,
                "PatchRowcode": "     def wrapper(fn):"
            },
            "9": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": 579,
                "PatchRowcode": "         @wraps(fn)"
            },
            "10": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": 580,
                "PatchRowcode": "         def decorated_view(*args, **kwargs):"
            },
            "11": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            perm = Permission(*[FsPermNeed(fsperm) for fsperm in fsperms])"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 581,
                "PatchRowcode": "+            perm = Permission(*(FsPermNeed(fsperm) for fsperm in fsperms))"
            },
            "13": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "             if perm.can():"
            },
            "14": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": 583,
                "PatchRowcode": "                 return fn(*args, **kwargs)"
            },
            "15": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": 584,
                "PatchRowcode": "             if _security._unauthorized_callback:"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "    flask_security.decorators",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Flask-Security decorators module",
            "",
            "    :copyright: (c) 2012-2019 by Matt Wright.",
            "    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "",
            "from collections import namedtuple",
            "import datetime",
            "from functools import wraps",
            "",
            "from flask import Response, _request_ctx_stack, abort, current_app, g, redirect, request",
            "from flask_login import current_user, login_required  # noqa: F401",
            "from flask_principal import Identity, Permission, RoleNeed, identity_changed",
            "from flask_wtf.csrf import CSRFError",
            "from werkzeug.local import LocalProxy",
            "from werkzeug.routing import BuildError",
            "",
            "from .utils import (",
            "    FsPermNeed,",
            "    config_value,",
            "    do_flash,",
            "    find_user,",
            "    get_message,",
            "    get_url,",
            "    check_and_update_authn_fresh,",
            "    json_error_response,",
            "    set_request_attr,",
            ")",
            "",
            "# Convenient references",
            "_security = LocalProxy(lambda: current_app.extensions[\"security\"])",
            "",
            "_csrf = LocalProxy(lambda: current_app.extensions[\"csrf\"])",
            "",
            "BasicAuth = namedtuple(\"BasicAuth\", \"username, password\")",
            "",
            "# NOTE: this is here for backwards compatibility, it is deprecated and",
            "# to be removed in 4.0",
            "_default_unauthenticated_html = \"\"\"",
            "    <h1>Unauthorized</h1>",
            "    <p>The server could not verify that you are authorized to access the URL",
            "    requested. You either supplied the wrong credentials (e.g. a bad password),",
            "    or your browser doesn't understand how to supply the credentials required.",
            "    </p>",
            "    \"\"\"",
            "",
            "",
            "def _get_unauthenticated_response(text=None, headers=None):",
            "    text = text or _default_unauthenticated_html",
            "    headers = headers or {}",
            "    return Response(text, 401, headers)",
            "",
            "",
            "def _get_unauthorized_response(text=None, headers=None):  # pragma: no cover",
            "    # People called this - even though it isn't public - no harm in keeping it.",
            "    return _get_unauthenticated_response(text, headers)",
            "",
            "",
            "def default_unauthn_handler(mechanisms, headers=None):",
            "    \"\"\"Default callback for failures to authenticate",
            "",
            "    If caller wants JSON - return 401.",
            "    If caller wants BasicAuth - return 401 (the WWW-Authenticate header is set).",
            "    Otherwise - assume caller is html and redirect if possible to a login view.",
            "    We let Flask-Login handle this.",
            "",
            "    \"\"\"",
            "    headers = headers or {}",
            "    msg = get_message(\"UNAUTHENTICATED\")[0]",
            "",
            "    if config_value(\"BACKWARDS_COMPAT_UNAUTHN\"):",
            "        return _get_unauthenticated_response(headers=headers)",
            "    if _security._want_json(request):",
            "        payload = json_error_response(errors=msg)",
            "        return _security._render_json(payload, 401, headers, None)",
            "",
            "    # Basic-Auth is often used to provide a browser based login form and then the",
            "    # browser will always add the BasicAuth credentials. For that to work we need to",
            "    # return 401 and not redirect to our login view.",
            "    if \"WWW-Authenticate\" in headers:",
            "        return Response(msg, 401, headers)",
            "    return _security.login_manager.unauthorized()",
            "",
            "",
            "def default_reauthn_handler(within, grace):",
            "    \"\"\"Default callback for 'freshness' related authn failures.",
            "",
            "    If caller wants JSON - return 401",
            "    Otherwise - assume caller is html and redirect if possible to configured view.",
            "",
            "    \"\"\"",
            "    m, c = get_message(\"REAUTHENTICATION_REQUIRED\")",
            "",
            "    if _security._want_json(request):",
            "        is_us = config_value(\"UNIFIED_SIGNIN\")",
            "        payload = json_error_response(errors=m)",
            "        payload[\"reauth_required\"] = True",
            "        payload[\"unified_signin_enabled\"] = is_us",
            "        return _security._render_json(payload, 401, None, None)",
            "",
            "    if config_value(\"UNIFIED_SIGNIN\"):",
            "        view = _security.us_verify_url",
            "    else:",
            "        view = _security.verify_url",
            "    if view:",
            "        do_flash(m, c)",
            "        redirect_url = get_url(view, qparams={\"next\": request.url})",
            "        return redirect(redirect_url)",
            "    abort(401)",
            "",
            "",
            "def default_unauthz_handler(func, params):",
            "    unauthz_message, unauthz_message_type = get_message(\"UNAUTHORIZED\")",
            "    if _security._want_json(request):",
            "        payload = json_error_response(errors=unauthz_message)",
            "        return _security._render_json(payload, 403, None, None)",
            "    view = config_value(\"UNAUTHORIZED_VIEW\")",
            "    if view:",
            "        if callable(view):",
            "            view = view()",
            "        else:",
            "            try:",
            "                view = get_url(view)",
            "            except BuildError:",
            "                view = None",
            "        do_flash(unauthz_message, unauthz_message_type)",
            "        redirect_to = \"/\"",
            "        if request.referrer and not request.referrer.split(\"?\")[0].endswith(",
            "            request.path",
            "        ):",
            "            redirect_to = request.referrer",
            "",
            "        return redirect(view or redirect_to)",
            "    abort(403)",
            "",
            "",
            "def _check_token():",
            "    # N.B. this isn't great Flask-Login 0.5.0 made this protected",
            "    # Issue https://github.com/maxcountryman/flask-login/issues/471",
            "    # was filed to restore public access. We want to call this via",
            "    # login_manager in case someone has overridden the login_manager which we",
            "    # allow.",
            "    if hasattr(_security.login_manager, \"request_callback\"):",
            "        # Pre 0.5.0",
            "        user = _security.login_manager.request_callback(request)",
            "    else:",
            "        user = _security.login_manager._request_callback(request)",
            "",
            "    if user and user.is_authenticated:",
            "        app = current_app._get_current_object()",
            "        _request_ctx_stack.top.user = user",
            "        identity_changed.send(app, identity=Identity(user.fs_uniquifier))",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def _check_http_auth():",
            "    auth = request.authorization or BasicAuth(username=None, password=None)",
            "    if not auth.username:",
            "        return False",
            "    user = find_user(auth.username)",
            "    if user and not user.active:",
            "        return False",
            "",
            "    if user and user.verify_and_update_password(auth.password):",
            "        _security.datastore.commit()",
            "        app = current_app._get_current_object()",
            "        _request_ctx_stack.top.user = user",
            "        identity_changed.send(app, identity=Identity(user.fs_uniquifier))",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def handle_csrf(method):",
            "    \"\"\"Invoke CSRF protection based on authentication method.",
            "",
            "    Usually this is called as part of a decorator, but if that isn't",
            "    appropriate, endpoint code can call this directly.",
            "",
            "    If CSRF protection is appropriate, this will call flask_wtf::protect() which",
            "    will raise a ValidationError on CSRF failure.",
            "",
            "    This routine does nothing if any of these are true:",
            "",
            "        #) *WTF_CSRF_ENABLED* is set to False",
            "",
            "        #) the Flask-WTF CSRF module hasn't been initialized",
            "",
            "        #) csrfProtect already checked and accepted the token",
            "",
            "    If the passed in method is not in *SECURITY_CSRF_PROTECT_MECHANISMS* then not only",
            "    will no CSRF code be run, but a flag in the current context ``fs_ignore_csrf``",
            "    will be set so that downstream code knows to ignore any CSRF checks.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "    if (",
            "        not current_app.config.get(\"WTF_CSRF_ENABLED\", False)",
            "        or not current_app.extensions.get(\"csrf\", None)",
            "        or g.get(\"csrf_valid\", False)",
            "    ):",
            "        return",
            "",
            "    if config_value(\"CSRF_PROTECT_MECHANISMS\"):",
            "        if method in config_value(\"CSRF_PROTECT_MECHANISMS\"):",
            "            _csrf.protect()",
            "        else:",
            "            _request_ctx_stack.top.fs_ignore_csrf = True",
            "",
            "",
            "def http_auth_required(realm):",
            "    \"\"\"Decorator that protects endpoints using Basic HTTP authentication.",
            "",
            "    :param realm: optional realm name",
            "",
            "    If authentication fails, then a 401 with the 'WWW-Authenticate' header set will be",
            "    returned.",
            "",
            "    Once authenticated, if so configured, CSRF protection will be tested.",
            "    \"\"\"",
            "",
            "    def decorator(fn):",
            "        @wraps(fn)",
            "        def wrapper(*args, **kwargs):",
            "            if _check_http_auth():",
            "                handle_csrf(\"basic\")",
            "                set_request_attr(\"fs_authn_via\", \"basic\")",
            "                return fn(*args, **kwargs)",
            "            if _security._unauthorized_callback:",
            "                return _security._unauthorized_callback()",
            "            else:",
            "                r = _security.default_http_auth_realm if callable(realm) else realm",
            "                h = {\"WWW-Authenticate\": 'Basic realm=\"%s\"' % r}",
            "                return _security._unauthn_handler([\"basic\"], headers=h)",
            "",
            "        return wrapper",
            "",
            "    if callable(realm):",
            "        return decorator(realm)",
            "    return decorator",
            "",
            "",
            "def auth_token_required(fn):",
            "    \"\"\"Decorator that protects endpoints using token authentication. The token",
            "    should be added to the request by the client by using a query string",
            "    variable with a name equal to the configuration value of",
            "    *SECURITY_TOKEN_AUTHENTICATION_KEY* or in a request header named that of",
            "    the configuration value of *SECURITY_TOKEN_AUTHENTICATION_HEADER*",
            "",
            "    Once authenticated, if so configured, CSRF protection will be tested.",
            "    \"\"\"",
            "",
            "    @wraps(fn)",
            "    def decorated(*args, **kwargs):",
            "        if _check_token():",
            "            handle_csrf(\"token\")",
            "            set_request_attr(\"fs_authn_via\", \"token\")",
            "            return fn(*args, **kwargs)",
            "        if _security._unauthorized_callback:",
            "            return _security._unauthorized_callback()",
            "        else:",
            "            return _security._unauthn_handler([\"token\"])",
            "",
            "    return decorated",
            "",
            "",
            "def auth_required(*auth_methods, **kwargs):",
            "    \"\"\"",
            "    Decorator that protects endpoints through multiple mechanisms",
            "    Example::",
            "",
            "        @app.route('/dashboard')",
            "        @auth_required('token', 'session')",
            "        def dashboard():",
            "            return 'Dashboard'",
            "",
            "    :param auth_methods: Specified mechanisms (token, basic, session). If not specified",
            "        then all current available mechanisms (except \"basic\") will be tried. A callable",
            "        can also be passed (useful if you need app/request context). The callable",
            "        must return a list.",
            "    :kwparam within: Add 'freshness' check to authentication. Is either an int",
            "        specifying # of minutes, or a callable that returns a timedelta. For timedeltas,",
            "        timedelta.total_seconds() is used for the calculations:",
            "",
            "            - If > 0, then the caller must have authenticated within the time specified",
            "              (as measured using the session cookie).",
            "            - If 0 and not within the grace period (see below) the caller will",
            "              always be redirected to re-authenticate.",
            "            - If < 0 (the default) no freshness check is performed.",
            "",
            "        Note that Basic Auth, by definition, is always 'fresh' and will never result in",
            "        a redirect/error.",
            "    :kwparam grace: Add a grace period for freshness checks. As above, either an int",
            "        or a callable returning a timedelta. If not specified then",
            "        :py:data:`SECURITY_FRESHNESS_GRACE_PERIOD` is used. The grace period allows",
            "        callers to complete the required operations w/o being prompted again.",
            "        See :meth:`flask_security.check_and_update_authn_fresh` for details.",
            "",
            "    Note that regardless of order specified - they will be tried in the following",
            "    order: token, session, basic.",
            "",
            "    The first mechanism that succeeds is used, following that, depending on",
            "    configuration, CSRF protection will be tested.",
            "",
            "    On authentication failure `.Security.unauthorized_callback` (deprecated)",
            "    or :meth:`.Security.unauthn_handler` will be called.",
            "",
            "    As a side effect, upon successful authentication, the request global",
            "     ``fs_authn_via`` will be set to the method (\"basic\", \"token\", \"session\")",
            "",
            "    .. note::",
            "        If \"basic\" is specified in addition to other methods, then if authentication",
            "        fails, a 401 with the \"WWW-Authenticate\" header will be returned - rather than",
            "        being redirected to the login view.",
            "",
            "    .. versionchanged:: 3.3.0",
            "       If ``auth_methods`` isn't specified, then all will be tried. Authentication",
            "       mechanisms will always be tried in order of ``token``, ``session``, ``basic``",
            "       regardless of how they are specified in the ``auth_methods`` parameter.",
            "",
            "    .. versionchanged:: 3.4.0",
            "        Added ``within`` and ``grace`` parameters to enforce a freshness check.",
            "",
            "    .. versionchanged:: 3.4.4",
            "        If ``auth_methods`` isn't specified try all mechanisms EXCEPT ``basic``.",
            "",
            "    .. versionchanged:: 4.0.0",
            "        auth_methods can be passed as a callable.",
            "",
            "    \"\"\"",
            "",
            "    login_mechanisms = {",
            "        \"token\": lambda: _check_token(),",
            "        \"session\": lambda: current_user.is_authenticated,",
            "        \"basic\": lambda: _check_http_auth(),",
            "    }",
            "    mechanisms_order = [\"token\", \"session\", \"basic\"]",
            "    auth_methods_arg = auth_methods",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **dkwargs):",
            "            # 2.7 doesn't support keyword args after *args....",
            "            within = kwargs.get(\"within\", -1)",
            "            if callable(within):",
            "                within = within()",
            "            else:",
            "                within = datetime.timedelta(minutes=within)",
            "            grace = kwargs.get(\"grace\", None)",
            "            if grace is None:",
            "                grace = config_value(\"FRESHNESS_GRACE_PERIOD\")",
            "            elif callable(grace):",
            "                grace = grace()",
            "            else:",
            "                grace = datetime.timedelta(minutes=grace)",
            "",
            "            if not auth_methods_arg:",
            "                auth_methods = {\"session\", \"token\"}",
            "            else:",
            "                auth_methods = []",
            "                for am in auth_methods_arg:",
            "                    if callable(am):",
            "                        auth_methods.extend(am())",
            "                    else:",
            "                        auth_methods.append(am)",
            "",
            "            h = {}",
            "            if \"basic\" in auth_methods:",
            "                r = _security.default_http_auth_realm",
            "                h[\"WWW-Authenticate\"] = 'Basic realm=\"%s\"' % r",
            "            mechanisms = [",
            "                (method, login_mechanisms.get(method))",
            "                for method in mechanisms_order",
            "                if method in auth_methods",
            "            ]",
            "            for method, mechanism in mechanisms:",
            "                if mechanism and mechanism():",
            "                    # successfully authenticated. Basic auth is by definition 'fresh'.",
            "                    # Note that using token auth is ok - but caller still has to pass",
            "                    # in a session cookie...",
            "                    if not check_and_update_authn_fresh(within, grace, method):",
            "                        return _security._reauthn_handler(within, grace)",
            "                    handle_csrf(method)",
            "                    set_request_attr(\"fs_authn_via\", method)",
            "                    return fn(*args, **dkwargs)",
            "            if _security._unauthorized_callback:",
            "                return _security._unauthorized_callback()",
            "            else:",
            "                return _security._unauthn_handler(auth_methods, headers=h)",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def unauth_csrf(fall_through=False):",
            "    \"\"\"Decorator for endpoints that don't need authentication",
            "    but do want CSRF checks (available via Header rather than just form).",
            "    This is required when setting *WTF_CSRF_CHECK_DEFAULT* = **False** since in that",
            "    case, without this decorator, the form validation will attempt to do the CSRF",
            "    check, and that will fail since the csrf-token is in the header (for pure JSON",
            "    requests).",
            "",
            "    This decorator does nothing unless Flask-WTF::CSRFProtect has been initialized.",
            "",
            "    This decorator does nothing if *WTF_CSRF_ENABLED* == **False**.",
            "",
            "    This decorator will always require CSRF if the caller is authenticated.",
            "",
            "    This decorator will suppress CSRF if caller isn't authenticated and has set the",
            "    *SECURITY_CSRF_IGNORE_UNAUTH_ENDPOINTS* config variable.",
            "",
            "    :param fall_through: if set to True, then if CSRF fails here - simply keep going.",
            "        This is appropriate if underlying view is form based and once the form is",
            "        instantiated, the csrf_token will be available.",
            "        Note that this can mask some errors such as 'The CSRF session token is missing.'",
            "        meaning that the caller didn't send a session cookie and instead the caller",
            "        might get a 'The CSRF token is missing.' error.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated(*args, **kwargs):",
            "            if not current_app.config.get(",
            "                \"WTF_CSRF_ENABLED\", False",
            "            ) or not current_app.extensions.get(\"csrf\", None):",
            "                return fn(*args, **kwargs)",
            "",
            "            if (",
            "                config_value(\"CSRF_IGNORE_UNAUTH_ENDPOINTS\")",
            "                and not current_user.is_authenticated",
            "            ):",
            "                _request_ctx_stack.top.fs_ignore_csrf = True",
            "            else:",
            "                try:",
            "                    _csrf.protect()",
            "                except CSRFError:",
            "                    if not fall_through:",
            "                        raise",
            "",
            "            return fn(*args, **kwargs)",
            "",
            "        return decorated",
            "",
            "    return wrapper",
            "",
            "",
            "def roles_required(*roles):",
            "    \"\"\"Decorator which specifies that a user must have all the specified roles.",
            "    Example::",
            "",
            "        @app.route('/dashboard')",
            "        @roles_required('admin', 'editor')",
            "        def dashboard():",
            "            return 'Dashboard'",
            "",
            "    The current user must have both the `admin` role and `editor` role in order",
            "    to view the page.",
            "",
            "    :param roles: The required roles.",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perms = [Permission(RoleNeed(role)) for role in roles]",
            "            for perm in perms:",
            "                if not perm.can():",
            "                    if _security._unauthorized_callback:",
            "                        # Backwards compat - deprecated",
            "                        return _security._unauthorized_callback()",
            "                    return _security._unauthz_handler(roles_required, list(roles))",
            "            return fn(*args, **kwargs)",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def roles_accepted(*roles):",
            "    \"\"\"Decorator which specifies that a user must have at least one of the",
            "    specified roles. Example::",
            "",
            "        @app.route('/create_post')",
            "        @roles_accepted('editor', 'author')",
            "        def create_post():",
            "            return 'Create Post'",
            "",
            "    The current user must have either the `editor` role or `author` role in",
            "    order to view the page.",
            "",
            "    :param roles: The possible roles.",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perm = Permission(*[RoleNeed(role) for role in roles])",
            "            if perm.can():",
            "                return fn(*args, **kwargs)",
            "            if _security._unauthorized_callback:",
            "                # Backwards compat - deprecated",
            "                return _security._unauthorized_callback()",
            "            return _security._unauthz_handler(roles_accepted, list(roles))",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def permissions_required(*fsperms):",
            "    \"\"\"Decorator which specifies that a user must have all the specified permissions.",
            "    Example::",
            "",
            "        @app.route('/dashboard')",
            "        @permissions_required('admin-write', 'editor-write')",
            "        def dashboard():",
            "            return 'Dashboard'",
            "",
            "    The current user must have BOTH permissions (via the roles it has)",
            "    to view the page.",
            "",
            "    N.B. Don't confuse these permissions with flask-principle Permission()!",
            "",
            "    :param fsperms: The required permissions.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perms = [Permission(FsPermNeed(fsperm)) for fsperm in fsperms]",
            "            for perm in perms:",
            "                if not perm.can():",
            "                    if _security._unauthorized_callback:",
            "                        # Backwards compat - deprecated",
            "                        return _security._unauthorized_callback()",
            "                    return _security._unauthz_handler(",
            "                        permissions_required, list(fsperms)",
            "                    )",
            "",
            "            return fn(*args, **kwargs)",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def permissions_accepted(*fsperms):",
            "    \"\"\"Decorator which specifies that a user must have at least one of the",
            "    specified permissions. Example::",
            "",
            "        @app.route('/create_post')",
            "        @permissions_accepted('editor-write', 'author-wrote')",
            "        def create_post():",
            "            return 'Create Post'",
            "",
            "    The current user must have one of the permissions (via the roles it has)",
            "    to view the page.",
            "",
            "    N.B. Don't confuse these permissions with flask-principle Permission()!",
            "",
            "    :param fsperms: The possible permissions.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perm = Permission(*[FsPermNeed(fsperm) for fsperm in fsperms])",
            "            if perm.can():",
            "                return fn(*args, **kwargs)",
            "            if _security._unauthorized_callback:",
            "                # Backwards compat - deprecated",
            "                return _security._unauthorized_callback()",
            "            return _security._unauthz_handler(permissions_accepted, list(fsperms))",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def anonymous_user_required(f):",
            "    \"\"\"Decorator which requires that caller NOT be logged in.",
            "    If a logged in user accesses an endpoint protected with this decorator",
            "    they will be redirected to the *SECURITY_POST_LOGIN_VIEW*.",
            "    If the caller requests a JSON response, a 400 will be returned.",
            "",
            "    .. versionchanged:: 3.3.0",
            "        Support for JSON response was added.",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def wrapper(*args, **kwargs):",
            "        if current_user.is_authenticated:",
            "            if _security._want_json(request):",
            "                payload = json_error_response(",
            "                    errors=get_message(\"ANONYMOUS_USER_REQUIRED\")[0]",
            "                )",
            "                return _security._render_json(payload, 400, None, None)",
            "            else:",
            "                return redirect(get_url(_security.post_login_view))",
            "        return f(*args, **kwargs)",
            "",
            "    return wrapper"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "    flask_security.decorators",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Flask-Security decorators module",
            "",
            "    :copyright: (c) 2012-2019 by Matt Wright.",
            "    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "",
            "from collections import namedtuple",
            "import datetime",
            "from functools import wraps",
            "",
            "from flask import Response, _request_ctx_stack, abort, current_app, g, redirect, request",
            "from flask_login import current_user, login_required  # noqa: F401",
            "from flask_principal import Identity, Permission, RoleNeed, identity_changed",
            "from flask_wtf.csrf import CSRFError",
            "from werkzeug.local import LocalProxy",
            "from werkzeug.routing import BuildError",
            "",
            "from .utils import (",
            "    FsPermNeed,",
            "    config_value,",
            "    do_flash,",
            "    find_user,",
            "    get_message,",
            "    get_url,",
            "    check_and_update_authn_fresh,",
            "    json_error_response,",
            "    set_request_attr,",
            ")",
            "",
            "# Convenient references",
            "_security = LocalProxy(lambda: current_app.extensions[\"security\"])",
            "",
            "_csrf = LocalProxy(lambda: current_app.extensions[\"csrf\"])",
            "",
            "BasicAuth = namedtuple(\"BasicAuth\", \"username, password\")",
            "",
            "# NOTE: this is here for backwards compatibility, it is deprecated and",
            "# to be removed in 4.0",
            "_default_unauthenticated_html = \"\"\"",
            "    <h1>Unauthorized</h1>",
            "    <p>The server could not verify that you are authorized to access the URL",
            "    requested. You either supplied the wrong credentials (e.g. a bad password),",
            "    or your browser doesn't understand how to supply the credentials required.",
            "    </p>",
            "    \"\"\"",
            "",
            "",
            "def _get_unauthenticated_response(text=None, headers=None):",
            "    text = text or _default_unauthenticated_html",
            "    headers = headers or {}",
            "    return Response(text, 401, headers)",
            "",
            "",
            "def _get_unauthorized_response(text=None, headers=None):  # pragma: no cover",
            "    # People called this - even though it isn't public - no harm in keeping it.",
            "    return _get_unauthenticated_response(text, headers)",
            "",
            "",
            "def default_unauthn_handler(mechanisms, headers=None):",
            "    \"\"\"Default callback for failures to authenticate",
            "",
            "    If caller wants JSON - return 401.",
            "    If caller wants BasicAuth - return 401 (the WWW-Authenticate header is set).",
            "    Otherwise - assume caller is html and redirect if possible to a login view.",
            "    We let Flask-Login handle this.",
            "",
            "    \"\"\"",
            "    headers = headers or {}",
            "    msg = get_message(\"UNAUTHENTICATED\")[0]",
            "",
            "    if config_value(\"BACKWARDS_COMPAT_UNAUTHN\"):",
            "        return _get_unauthenticated_response(headers=headers)",
            "    if _security._want_json(request):",
            "        payload = json_error_response(errors=msg)",
            "        return _security._render_json(payload, 401, headers, None)",
            "",
            "    # Basic-Auth is often used to provide a browser based login form and then the",
            "    # browser will always add the BasicAuth credentials. For that to work we need to",
            "    # return 401 and not redirect to our login view.",
            "    if \"WWW-Authenticate\" in headers:",
            "        return Response(msg, 401, headers)",
            "    return _security.login_manager.unauthorized()",
            "",
            "",
            "def default_reauthn_handler(within, grace):",
            "    \"\"\"Default callback for 'freshness' related authn failures.",
            "",
            "    If caller wants JSON - return 401",
            "    Otherwise - assume caller is html and redirect if possible to configured view.",
            "",
            "    \"\"\"",
            "    m, c = get_message(\"REAUTHENTICATION_REQUIRED\")",
            "",
            "    if _security._want_json(request):",
            "        is_us = config_value(\"UNIFIED_SIGNIN\")",
            "        payload = json_error_response(errors=m)",
            "        payload[\"reauth_required\"] = True",
            "        payload[\"unified_signin_enabled\"] = is_us",
            "        return _security._render_json(payload, 401, None, None)",
            "",
            "    if config_value(\"UNIFIED_SIGNIN\"):",
            "        view = _security.us_verify_url",
            "    else:",
            "        view = _security.verify_url",
            "    if view:",
            "        do_flash(m, c)",
            "        redirect_url = get_url(view, qparams={\"next\": request.url})",
            "        return redirect(redirect_url)",
            "    abort(401)",
            "",
            "",
            "def default_unauthz_handler(func, params):",
            "    unauthz_message, unauthz_message_type = get_message(\"UNAUTHORIZED\")",
            "    if _security._want_json(request):",
            "        payload = json_error_response(errors=unauthz_message)",
            "        return _security._render_json(payload, 403, None, None)",
            "    view = config_value(\"UNAUTHORIZED_VIEW\")",
            "    if view:",
            "        if callable(view):",
            "            view = view()",
            "        else:",
            "            try:",
            "                view = get_url(view)",
            "            except BuildError:",
            "                view = None",
            "        do_flash(unauthz_message, unauthz_message_type)",
            "        redirect_to = \"/\"",
            "        if request.referrer and not request.referrer.split(\"?\")[0].endswith(",
            "            request.path",
            "        ):",
            "            redirect_to = request.referrer",
            "",
            "        return redirect(view or redirect_to)",
            "    abort(403)",
            "",
            "",
            "def _check_token():",
            "    # N.B. this isn't great Flask-Login 0.5.0 made this protected",
            "    # Issue https://github.com/maxcountryman/flask-login/issues/471",
            "    # was filed to restore public access. We want to call this via",
            "    # login_manager in case someone has overridden the login_manager which we",
            "    # allow.",
            "    if hasattr(_security.login_manager, \"request_callback\"):",
            "        # Pre 0.5.0",
            "        user = _security.login_manager.request_callback(request)",
            "    else:",
            "        user = _security.login_manager._request_callback(request)",
            "",
            "    if user and user.is_authenticated:",
            "        app = current_app._get_current_object()",
            "        _request_ctx_stack.top.user = user",
            "        identity_changed.send(app, identity=Identity(user.fs_uniquifier))",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def _check_http_auth():",
            "    auth = request.authorization or BasicAuth(username=None, password=None)",
            "    if not auth.username:",
            "        return False",
            "    user = find_user(auth.username)",
            "    if user and not user.active:",
            "        return False",
            "",
            "    if user and user.verify_and_update_password(auth.password):",
            "        _security.datastore.commit()",
            "        app = current_app._get_current_object()",
            "        _request_ctx_stack.top.user = user",
            "        identity_changed.send(app, identity=Identity(user.fs_uniquifier))",
            "        return True",
            "",
            "    return False",
            "",
            "",
            "def handle_csrf(method):",
            "    \"\"\"Invoke CSRF protection based on authentication method.",
            "",
            "    Usually this is called as part of a decorator, but if that isn't",
            "    appropriate, endpoint code can call this directly.",
            "",
            "    If CSRF protection is appropriate, this will call flask_wtf::protect() which",
            "    will raise a ValidationError on CSRF failure.",
            "",
            "    This routine does nothing if any of these are true:",
            "",
            "        #) *WTF_CSRF_ENABLED* is set to False",
            "",
            "        #) the Flask-WTF CSRF module hasn't been initialized",
            "",
            "        #) csrfProtect already checked and accepted the token",
            "",
            "    If the passed in method is not in *SECURITY_CSRF_PROTECT_MECHANISMS* then not only",
            "    will no CSRF code be run, but a flag in the current context ``fs_ignore_csrf``",
            "    will be set so that downstream code knows to ignore any CSRF checks.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "    if (",
            "        not current_app.config.get(\"WTF_CSRF_ENABLED\", False)",
            "        or not current_app.extensions.get(\"csrf\", None)",
            "        or g.get(\"csrf_valid\", False)",
            "    ):",
            "        return",
            "",
            "    if config_value(\"CSRF_PROTECT_MECHANISMS\"):",
            "        if method in config_value(\"CSRF_PROTECT_MECHANISMS\"):",
            "            _csrf.protect()",
            "        else:",
            "            _request_ctx_stack.top.fs_ignore_csrf = True",
            "",
            "",
            "def http_auth_required(realm):",
            "    \"\"\"Decorator that protects endpoints using Basic HTTP authentication.",
            "",
            "    :param realm: optional realm name",
            "",
            "    If authentication fails, then a 401 with the 'WWW-Authenticate' header set will be",
            "    returned.",
            "",
            "    Once authenticated, if so configured, CSRF protection will be tested.",
            "    \"\"\"",
            "",
            "    def decorator(fn):",
            "        @wraps(fn)",
            "        def wrapper(*args, **kwargs):",
            "            if _check_http_auth():",
            "                handle_csrf(\"basic\")",
            "                set_request_attr(\"fs_authn_via\", \"basic\")",
            "                return fn(*args, **kwargs)",
            "            if _security._unauthorized_callback:",
            "                return _security._unauthorized_callback()",
            "            else:",
            "                r = _security.default_http_auth_realm if callable(realm) else realm",
            "                h = {\"WWW-Authenticate\": 'Basic realm=\"%s\"' % r}",
            "                return _security._unauthn_handler([\"basic\"], headers=h)",
            "",
            "        return wrapper",
            "",
            "    if callable(realm):",
            "        return decorator(realm)",
            "    return decorator",
            "",
            "",
            "def auth_token_required(fn):",
            "    \"\"\"Decorator that protects endpoints using token authentication. The token",
            "    should be added to the request by the client by using a query string",
            "    variable with a name equal to the configuration value of",
            "    *SECURITY_TOKEN_AUTHENTICATION_KEY* or in a request header named that of",
            "    the configuration value of *SECURITY_TOKEN_AUTHENTICATION_HEADER*",
            "",
            "    Once authenticated, if so configured, CSRF protection will be tested.",
            "    \"\"\"",
            "",
            "    @wraps(fn)",
            "    def decorated(*args, **kwargs):",
            "        if _check_token():",
            "            handle_csrf(\"token\")",
            "            set_request_attr(\"fs_authn_via\", \"token\")",
            "            return fn(*args, **kwargs)",
            "        if _security._unauthorized_callback:",
            "            return _security._unauthorized_callback()",
            "        else:",
            "            return _security._unauthn_handler([\"token\"])",
            "",
            "    return decorated",
            "",
            "",
            "def auth_required(*auth_methods, **kwargs):",
            "    \"\"\"",
            "    Decorator that protects endpoints through multiple mechanisms",
            "    Example::",
            "",
            "        @app.route('/dashboard')",
            "        @auth_required('token', 'session')",
            "        def dashboard():",
            "            return 'Dashboard'",
            "",
            "    :param auth_methods: Specified mechanisms (token, basic, session). If not specified",
            "        then all current available mechanisms (except \"basic\") will be tried. A callable",
            "        can also be passed (useful if you need app/request context). The callable",
            "        must return a list.",
            "    :kwparam within: Add 'freshness' check to authentication. Is either an int",
            "        specifying # of minutes, or a callable that returns a timedelta. For timedeltas,",
            "        timedelta.total_seconds() is used for the calculations:",
            "",
            "            - If > 0, then the caller must have authenticated within the time specified",
            "              (as measured using the session cookie).",
            "            - If 0 and not within the grace period (see below) the caller will",
            "              always be redirected to re-authenticate.",
            "            - If < 0 (the default) no freshness check is performed.",
            "",
            "        Note that Basic Auth, by definition, is always 'fresh' and will never result in",
            "        a redirect/error.",
            "    :kwparam grace: Add a grace period for freshness checks. As above, either an int",
            "        or a callable returning a timedelta. If not specified then",
            "        :py:data:`SECURITY_FRESHNESS_GRACE_PERIOD` is used. The grace period allows",
            "        callers to complete the required operations w/o being prompted again.",
            "        See :meth:`flask_security.check_and_update_authn_fresh` for details.",
            "",
            "    Note that regardless of order specified - they will be tried in the following",
            "    order: token, session, basic.",
            "",
            "    The first mechanism that succeeds is used, following that, depending on",
            "    configuration, CSRF protection will be tested.",
            "",
            "    On authentication failure `.Security.unauthorized_callback` (deprecated)",
            "    or :meth:`.Security.unauthn_handler` will be called.",
            "",
            "    As a side effect, upon successful authentication, the request global",
            "     ``fs_authn_via`` will be set to the method (\"basic\", \"token\", \"session\")",
            "",
            "    .. note::",
            "        If \"basic\" is specified in addition to other methods, then if authentication",
            "        fails, a 401 with the \"WWW-Authenticate\" header will be returned - rather than",
            "        being redirected to the login view.",
            "",
            "    .. versionchanged:: 3.3.0",
            "       If ``auth_methods`` isn't specified, then all will be tried. Authentication",
            "       mechanisms will always be tried in order of ``token``, ``session``, ``basic``",
            "       regardless of how they are specified in the ``auth_methods`` parameter.",
            "",
            "    .. versionchanged:: 3.4.0",
            "        Added ``within`` and ``grace`` parameters to enforce a freshness check.",
            "",
            "    .. versionchanged:: 3.4.4",
            "        If ``auth_methods`` isn't specified try all mechanisms EXCEPT ``basic``.",
            "",
            "    .. versionchanged:: 4.0.0",
            "        auth_methods can be passed as a callable.",
            "",
            "    \"\"\"",
            "",
            "    login_mechanisms = {",
            "        \"token\": lambda: _check_token(),",
            "        \"session\": lambda: current_user.is_authenticated,",
            "        \"basic\": lambda: _check_http_auth(),",
            "    }",
            "    mechanisms_order = [\"token\", \"session\", \"basic\"]",
            "    auth_methods_arg = auth_methods",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **dkwargs):",
            "            # 2.7 doesn't support keyword args after *args....",
            "            within = kwargs.get(\"within\", -1)",
            "            if callable(within):",
            "                within = within()",
            "            else:",
            "                within = datetime.timedelta(minutes=within)",
            "            grace = kwargs.get(\"grace\", None)",
            "            if grace is None:",
            "                grace = config_value(\"FRESHNESS_GRACE_PERIOD\")",
            "            elif callable(grace):",
            "                grace = grace()",
            "            else:",
            "                grace = datetime.timedelta(minutes=grace)",
            "",
            "            if not auth_methods_arg:",
            "                auth_methods = {\"session\", \"token\"}",
            "            else:",
            "                auth_methods = []",
            "                for am in auth_methods_arg:",
            "                    if callable(am):",
            "                        auth_methods.extend(am())",
            "                    else:",
            "                        auth_methods.append(am)",
            "",
            "            h = {}",
            "            if \"basic\" in auth_methods:",
            "                r = _security.default_http_auth_realm",
            "                h[\"WWW-Authenticate\"] = 'Basic realm=\"%s\"' % r",
            "            mechanisms = [",
            "                (method, login_mechanisms.get(method))",
            "                for method in mechanisms_order",
            "                if method in auth_methods",
            "            ]",
            "            for method, mechanism in mechanisms:",
            "                if mechanism and mechanism():",
            "                    # successfully authenticated. Basic auth is by definition 'fresh'.",
            "                    # Note that using token auth is ok - but caller still has to pass",
            "                    # in a session cookie...",
            "                    if not check_and_update_authn_fresh(within, grace, method):",
            "                        return _security._reauthn_handler(within, grace)",
            "                    handle_csrf(method)",
            "                    set_request_attr(\"fs_authn_via\", method)",
            "                    return fn(*args, **dkwargs)",
            "            if _security._unauthorized_callback:",
            "                return _security._unauthorized_callback()",
            "            else:",
            "                return _security._unauthn_handler(auth_methods, headers=h)",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def unauth_csrf(fall_through=False):",
            "    \"\"\"Decorator for endpoints that don't need authentication",
            "    but do want CSRF checks (available via Header rather than just form).",
            "    This is required when setting *WTF_CSRF_CHECK_DEFAULT* = **False** since in that",
            "    case, without this decorator, the form validation will attempt to do the CSRF",
            "    check, and that will fail since the csrf-token is in the header (for pure JSON",
            "    requests).",
            "",
            "    This decorator does nothing unless Flask-WTF::CSRFProtect has been initialized.",
            "",
            "    This decorator does nothing if *WTF_CSRF_ENABLED* == **False**.",
            "",
            "    This decorator will always require CSRF if the caller is authenticated.",
            "",
            "    This decorator will suppress CSRF if caller isn't authenticated and has set the",
            "    *SECURITY_CSRF_IGNORE_UNAUTH_ENDPOINTS* config variable.",
            "",
            "    :param fall_through: if set to True, then if CSRF fails here - simply keep going.",
            "        This is appropriate if underlying view is form based and once the form is",
            "        instantiated, the csrf_token will be available.",
            "        Note that this can mask some errors such as 'The CSRF session token is missing.'",
            "        meaning that the caller didn't send a session cookie and instead the caller",
            "        might get a 'The CSRF token is missing.' error.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated(*args, **kwargs):",
            "            if not current_app.config.get(",
            "                \"WTF_CSRF_ENABLED\", False",
            "            ) or not current_app.extensions.get(\"csrf\", None):",
            "                return fn(*args, **kwargs)",
            "",
            "            if (",
            "                config_value(\"CSRF_IGNORE_UNAUTH_ENDPOINTS\")",
            "                and not current_user.is_authenticated",
            "            ):",
            "                _request_ctx_stack.top.fs_ignore_csrf = True",
            "            else:",
            "                try:",
            "                    _csrf.protect()",
            "                except CSRFError:",
            "                    if not fall_through:",
            "                        raise",
            "",
            "            return fn(*args, **kwargs)",
            "",
            "        return decorated",
            "",
            "    return wrapper",
            "",
            "",
            "def roles_required(*roles):",
            "    \"\"\"Decorator which specifies that a user must have all the specified roles.",
            "    Example::",
            "",
            "        @app.route('/dashboard')",
            "        @roles_required('admin', 'editor')",
            "        def dashboard():",
            "            return 'Dashboard'",
            "",
            "    The current user must have both the `admin` role and `editor` role in order",
            "    to view the page.",
            "",
            "    :param roles: The required roles.",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perms = [Permission(RoleNeed(role)) for role in roles]",
            "            for perm in perms:",
            "                if not perm.can():",
            "                    if _security._unauthorized_callback:",
            "                        # Backwards compat - deprecated",
            "                        return _security._unauthorized_callback()",
            "                    return _security._unauthz_handler(roles_required, list(roles))",
            "            return fn(*args, **kwargs)",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def roles_accepted(*roles):",
            "    \"\"\"Decorator which specifies that a user must have at least one of the",
            "    specified roles. Example::",
            "",
            "        @app.route('/create_post')",
            "        @roles_accepted('editor', 'author')",
            "        def create_post():",
            "            return 'Create Post'",
            "",
            "    The current user must have either the `editor` role or `author` role in",
            "    order to view the page.",
            "",
            "    :param roles: The possible roles.",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perm = Permission(*(RoleNeed(role) for role in roles))",
            "            if perm.can():",
            "                return fn(*args, **kwargs)",
            "            if _security._unauthorized_callback:",
            "                # Backwards compat - deprecated",
            "                return _security._unauthorized_callback()",
            "            return _security._unauthz_handler(roles_accepted, list(roles))",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def permissions_required(*fsperms):",
            "    \"\"\"Decorator which specifies that a user must have all the specified permissions.",
            "    Example::",
            "",
            "        @app.route('/dashboard')",
            "        @permissions_required('admin-write', 'editor-write')",
            "        def dashboard():",
            "            return 'Dashboard'",
            "",
            "    The current user must have BOTH permissions (via the roles it has)",
            "    to view the page.",
            "",
            "    N.B. Don't confuse these permissions with flask-principle Permission()!",
            "",
            "    :param fsperms: The required permissions.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perms = [Permission(FsPermNeed(fsperm)) for fsperm in fsperms]",
            "            for perm in perms:",
            "                if not perm.can():",
            "                    if _security._unauthorized_callback:",
            "                        # Backwards compat - deprecated",
            "                        return _security._unauthorized_callback()",
            "                    return _security._unauthz_handler(",
            "                        permissions_required, list(fsperms)",
            "                    )",
            "",
            "            return fn(*args, **kwargs)",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def permissions_accepted(*fsperms):",
            "    \"\"\"Decorator which specifies that a user must have at least one of the",
            "    specified permissions. Example::",
            "",
            "        @app.route('/create_post')",
            "        @permissions_accepted('editor-write', 'author-wrote')",
            "        def create_post():",
            "            return 'Create Post'",
            "",
            "    The current user must have one of the permissions (via the roles it has)",
            "    to view the page.",
            "",
            "    N.B. Don't confuse these permissions with flask-principle Permission()!",
            "",
            "    :param fsperms: The possible permissions.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def wrapper(fn):",
            "        @wraps(fn)",
            "        def decorated_view(*args, **kwargs):",
            "            perm = Permission(*(FsPermNeed(fsperm) for fsperm in fsperms))",
            "            if perm.can():",
            "                return fn(*args, **kwargs)",
            "            if _security._unauthorized_callback:",
            "                # Backwards compat - deprecated",
            "                return _security._unauthorized_callback()",
            "            return _security._unauthz_handler(permissions_accepted, list(fsperms))",
            "",
            "        return decorated_view",
            "",
            "    return wrapper",
            "",
            "",
            "def anonymous_user_required(f):",
            "    \"\"\"Decorator which requires that caller NOT be logged in.",
            "    If a logged in user accesses an endpoint protected with this decorator",
            "    they will be redirected to the *SECURITY_POST_LOGIN_VIEW*.",
            "    If the caller requests a JSON response, a 400 will be returned.",
            "",
            "    .. versionchanged:: 3.3.0",
            "        Support for JSON response was added.",
            "    \"\"\"",
            "",
            "    @wraps(f)",
            "    def wrapper(*args, **kwargs):",
            "        if current_user.is_authenticated:",
            "            if _security._want_json(request):",
            "                payload = json_error_response(",
            "                    errors=get_message(\"ANONYMOUS_USER_REQUIRED\")[0]",
            "                )",
            "                return _security._render_json(payload, 400, None, None)",
            "            else:",
            "                return redirect(get_url(_security.post_login_view))",
            "        return f(*args, **kwargs)",
            "",
            "    return wrapper"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "507": [
                "roles_accepted",
                "wrapper",
                "decorated_view"
            ],
            "581": [
                "permissions_accepted",
                "wrapper",
                "decorated_view"
            ]
        },
        "addLocation": []
    },
    "flask_security/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": 498,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 499,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 500,
                "PatchRowcode": " def validate_redirect_url(url):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+    \"\"\"Validate that the URL for redirect is relative."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 502,
                "PatchRowcode": "+    Allowing an absolute redirect is a security issue - a so-called open-redirect."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 503,
                "PatchRowcode": "+    Note that by default Werkzeug will always take this URL and make it relative"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+    when setting the Location header - but that behavior can be overridden."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 505,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+    The complexity here is that urlsplit() does pretty well, but browsers even today"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+    May 2021 are very lenient in what they accept as URLs - for example:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+        next=\\\\\\\\github.com"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+        next=%5C%5C%5Cgithub.com"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+        next=/////github.com"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+        next=%20\\\\\\\\github.com"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 512,
                "PatchRowcode": "+        next=%20///github.com"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+        next=%20//github.com"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 514,
                "PatchRowcode": "+        next=%19////github.com - i.e. browser will strip control chars"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 515,
                "PatchRowcode": "+        next=%E2%80%8A///github.com - doesn't redirect! That is a unicode thin space."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 516,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 517,
                "PatchRowcode": "+    All will result in a null netloc and scheme from urlsplit - however many browsers"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+    will gladly strip off uninteresting characters and convert backslashes to forward"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 519,
                "PatchRowcode": "+    slashes - and the cases above will actually cause a redirect to github.com"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 520,
                "PatchRowcode": "+    Sigh."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 521,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 522,
                "PatchRowcode": "+    Some articles claim that a relative url has to start with a '/' - but that isn't"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 523,
                "PatchRowcode": "+    strictly true. From: https://datatracker.ietf.org/doc/html/rfc3986#section-5"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 524,
                "PatchRowcode": "+    a relative path can start with a \"//\", \"/\", a non-colon, or be empty. So it seems"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 525,
                "PatchRowcode": "+    that all the above URLs are valid."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 526,
                "PatchRowcode": "+    By the time we get the URL, it has been unencoded - so we can't really determine"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 527,
                "PatchRowcode": "+    if it is 'valid' since it appears that '/'s can appear in the URL if escaped."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 528,
                "PatchRowcode": "+    \"\"\""
            },
            "31": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": 529,
                "PatchRowcode": "     if url is None or url.strip() == \"\":"
            },
            "32": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 530,
                "PatchRowcode": "         return False"
            },
            "33": {
                "beforePatchRowNumber": 503,
                "afterPatchRowNumber": 531,
                "PatchRowcode": "     url_next = urlsplit(url)"
            },
            "34": {
                "beforePatchRowNumber": 515,
                "afterPatchRowNumber": 543,
                "PatchRowcode": "             return True"
            },
            "35": {
                "beforePatchRowNumber": 516,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "         else:"
            },
            "36": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 545,
                "PatchRowcode": "             return False"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 546,
                "PatchRowcode": "+    if config_value(\"REDIRECT_VALIDATE_MODE\") == \"regex\":"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 547,
                "PatchRowcode": "+        matcher = _security._redirect_validate_re.match(url)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+        return matcher is None"
            },
            "40": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 549,
                "PatchRowcode": "     return True"
            },
            "41": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 550,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": 551,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "    flask_security.utils",
            "    ~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Flask-Security utils module",
            "",
            "    :copyright: (c) 2012-2019 by Matt Wright.",
            "    :copyright: (c) 2019-2021 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "import abc",
            "import base64",
            "import datetime",
            "from functools import partial",
            "import hashlib",
            "import hmac",
            "import time",
            "from typing import Dict, List",
            "import warnings",
            "from datetime import timedelta",
            "from urllib.parse import parse_qsl, parse_qs, urlsplit, urlunsplit, urlencode",
            "import urllib.request",
            "import urllib.error",
            "",
            "from flask import (",
            "    _request_ctx_stack,",
            "    after_this_request,",
            "    current_app,",
            "    flash,",
            "    g,",
            "    request,",
            "    session,",
            "    url_for,",
            ")",
            "from flask.json import JSONEncoder",
            "from flask_login import login_user as _login_user",
            "from flask_login import logout_user as _logout_user",
            "from flask_login import current_user",
            "from flask_login import COOKIE_NAME as REMEMBER_COOKIE_NAME",
            "from flask_principal import AnonymousIdentity, Identity, identity_changed, Need",
            "from flask_wtf import csrf",
            "from wtforms import ValidationError",
            "from itsdangerous import BadSignature, SignatureExpired",
            "from werkzeug.local import LocalProxy",
            "from werkzeug.datastructures import MultiDict",
            "",
            "from .quart_compat import best, get_quart_status",
            "from .signals import user_authenticated",
            "",
            "# Convenient references",
            "_security = LocalProxy(lambda: current_app.extensions[\"security\"])",
            "",
            "_datastore = LocalProxy(lambda: _security.datastore)",
            "",
            "_pwd_context = LocalProxy(lambda: _security.pwd_context)",
            "",
            "_hashing_context = LocalProxy(lambda: _security.hashing_context)",
            "",
            "localize_callback = LocalProxy(lambda: _security.i18n_domain.gettext)",
            "",
            "FsPermNeed = partial(Need, \"fsperm\")",
            "FsPermNeed.__doc__ = \"\"\"A need with the method preset to `\"fsperm\"`.\"\"\"",
            "",
            "",
            "def _(translate):",
            "    \"\"\"Identity function to mark strings for translation.\"\"\"",
            "    return translate",
            "",
            "",
            "def get_request_attr(name):",
            "    \"\"\"Retrieve a request local attribute.",
            "",
            "    Currently public attributes are:",
            "",
            "    **fs_authn_via**",
            "        will be set to the authentication mechanism (session, token, basic)",
            "        that the current request was authenticated with.",
            "",
            "    Returns None if attribute doesn't exist.",
            "",
            "    .. versionadded:: 4.0.0",
            "    \"\"\"",
            "    return getattr(_request_ctx_stack.top, name, None)",
            "",
            "",
            "def set_request_attr(name, value):",
            "    return setattr(_request_ctx_stack.top, name, value)",
            "",
            "",
            "\"\"\"",
            "Most view functions that modify the DB will call ``after_this_request(view_commit)``",
            "Quart compatibility needs an async version",
            "\"\"\"",
            "if get_quart_status():  # pragma: no cover",
            "",
            "    async def view_commit(response=None):",
            "        _datastore.commit()",
            "        return response",
            "",
            "",
            "else:",
            "",
            "    def view_commit(response=None):",
            "        _datastore.commit()",
            "        return response",
            "",
            "",
            "def find_csrf_field_name():",
            "    \"\"\"",
            "    We need to clear it on logout (since that isn't being done by Flask-WTF).",
            "    The field name is configurable withing Flask-WTF as well as being",
            "    overridable.",
            "    We take the field name from the login_form as set by the configuration.",
            "    \"\"\"",
            "    form = _security.login_form(MultiDict([]))",
            "    if hasattr(form.meta, \"csrf_field_name\"):",
            "        return form.meta.csrf_field_name",
            "    return None",
            "",
            "",
            "def login_user(user, remember=None, authn_via=None):",
            "    \"\"\"Perform the login routine.",
            "",
            "    If *SECURITY_TRACKABLE* is used, make sure you commit changes after this",
            "    request (i.e. ``app.security.datastore.commit()``).",
            "",
            "    :param user: The user to login",
            "    :param remember: Flag specifying if the remember cookie should be set.",
            "                     Defaults to ``False``",
            "    :param authn_via: A list of strings denoting which mechanism(s) the user",
            "        authenticated with.",
            "        These should be one or more of [\"password\", \"sms\", \"authenticator\", \"email\"] or",
            "        other 'auto-login' mechanisms.",
            "    \"\"\"",
            "",
            "    if remember is None:",
            "        remember = config_value(\"DEFAULT_REMEMBER_ME\")",
            "",
            "    if not _login_user(user, remember):  # pragma: no cover",
            "        return False",
            "",
            "    if _security.trackable:",
            "        remote_addr = request.remote_addr or None  # make sure it is None",
            "",
            "        old_current_login, new_current_login = (",
            "            user.current_login_at,",
            "            _security.datetime_factory(),",
            "        )",
            "        old_current_ip, new_current_ip = user.current_login_ip, remote_addr",
            "",
            "        user.last_login_at = old_current_login or new_current_login",
            "        user.current_login_at = new_current_login",
            "        user.last_login_ip = old_current_ip",
            "        user.current_login_ip = new_current_ip",
            "        user.login_count = user.login_count + 1 if user.login_count else 1",
            "",
            "        _datastore.put(user)",
            "",
            "    session[\"fs_cc\"] = \"set\"  # CSRF cookie",
            "    session[\"fs_paa\"] = time.time()  # Primary authentication at - timestamp",
            "",
            "    identity_changed.send(",
            "        current_app._get_current_object(), identity=Identity(user.fs_uniquifier)",
            "    )",
            "",
            "    user_authenticated.send(",
            "        current_app._get_current_object(), user=user, authn_via=authn_via",
            "    )",
            "    return True",
            "",
            "",
            "def logout_user():",
            "    \"\"\"Logs out the current user.",
            "",
            "    This will also clean up the remember me cookie if it exists.",
            "",
            "    This sends an ``identity_changed`` signal to note that the current",
            "    identity is now the `AnonymousIdentity`",
            "    \"\"\"",
            "",
            "    for key in (\"identity.name\", \"identity.auth_type\", \"fs_paa\", \"fs_gexp\"):",
            "        session.pop(key, None)",
            "",
            "    # Clear csrf token between sessions.",
            "    # Ideally this would be handled by Flask-WTF but...",
            "    # We don't clear entire session since Flask-Login seems to like having it.",
            "    csrf_field_name = find_csrf_field_name()",
            "    if csrf_field_name:",
            "        session.pop(csrf_field_name, None)",
            "        # Flask-WTF 'caches' csrf_token - and only set the session if not already",
            "        # in 'g'. Be sure to clear both. This affects at least /confirm",
            "        g.pop(csrf_field_name, None)",
            "    session[\"fs_cc\"] = \"clear\"",
            "    identity_changed.send(",
            "        current_app._get_current_object(), identity=AnonymousIdentity()",
            "    )",
            "    _logout_user()",
            "",
            "",
            "def check_and_update_authn_fresh(within, grace, method=None):",
            "    \"\"\"Check if user authenticated within specified time and update grace period.",
            "",
            "    :param within: A timedelta specifying the maximum time in the past that the caller",
            "                  authenticated that is still considered 'fresh'.",
            "    :param grace: A timedelta that, if the current session is considered 'fresh'",
            "                  will set a grace period for which freshness won't be checked.",
            "                  The intent here is that the caller shouldn't get part-way though",
            "                  a set of operations and suddenly be required to authenticate again.",
            "    :param method: Optional - if set and == \"basic\" then will always return True.",
            "                  (since basic-auth sends username/password on every request)",
            "",
            "    If within.total_seconds() is negative, will always return True (always 'fresh').",
            "    This effectively just disables this entire mechanism.",
            "",
            "    If \"fs_gexp\" is in the session and the current timestamp is less than that,",
            "    return True and extend grace time (i.e. set fs_gexp to current time + grace).",
            "",
            "    If not within the grace period, and within.total_seconds() is 0,",
            "    return False (not fresh).",
            "",
            "    Be aware that for this to work, sessions and therefore session cookies",
            "    must be functioning and being sent as part of the request. If the required",
            "    state isn't in the session cookie then return False (not 'fresh').",
            "",
            "    .. warning::",
            "        Be sure the caller is already authenticated PRIOR to calling this method.",
            "",
            "    .. versionadded:: 3.4.0",
            "",
            "    .. versionchanged:: 4.0.0",
            "        Added `method` parameter.",
            "    \"\"\"",
            "",
            "    if method == \"basic\":",
            "        return True",
            "",
            "    if within.total_seconds() < 0:",
            "        # this means 'always fresh'",
            "        return True",
            "",
            "    if \"fs_paa\" not in session:",
            "        # No session, you can't play.",
            "        return False",
            "",
            "    now = datetime.datetime.utcnow()",
            "    new_exp = now + grace",
            "    grace_ts = int(new_exp.timestamp())",
            "",
            "    fs_gexp = session.get(\"fs_gexp\", None)",
            "    if fs_gexp:",
            "        if now.timestamp() < fs_gexp:",
            "            # Within grace period - extend it and we're good.",
            "            session[\"fs_gexp\"] = grace_ts",
            "            return True",
            "",
            "    # Special case 0 - return False always, but set grace period.",
            "    if within.total_seconds() == 0:",
            "        session[\"fs_gexp\"] = grace_ts",
            "        return False",
            "",
            "    authn_time = datetime.datetime.utcfromtimestamp(session[\"fs_paa\"])",
            "    # allow for some time drift where it's possible authn_time is in the future",
            "    # but lets be cautious and not allow arbitrary future times",
            "    delta = now - authn_time",
            "    if within > delta > -within:",
            "        session[\"fs_gexp\"] = grace_ts",
            "        return True",
            "    return False",
            "",
            "",
            "def get_hmac(password):",
            "    \"\"\"Returns a Base64 encoded HMAC+SHA512 of the password signed with",
            "    the salt specified by *SECURITY_PASSWORD_SALT*.",
            "",
            "    :param password: The password to sign",
            "    \"\"\"",
            "    salt = _security.password_salt",
            "",
            "    if salt is None:",
            "        raise RuntimeError(",
            "            \"The configuration value `SECURITY_PASSWORD_SALT` must \"",
            "            \"not be None when the value of `SECURITY_PASSWORD_HASH` is \"",
            "            'set to \"%s\"' % _security.password_hash",
            "        )",
            "",
            "    h = hmac.new(encode_string(salt), encode_string(password), hashlib.sha512)",
            "    return base64.b64encode(h.digest())",
            "",
            "",
            "def verify_password(password, password_hash):",
            "    \"\"\"Returns ``True`` if the password matches the supplied hash.",
            "",
            "    :param password: A plaintext password to verify",
            "    :param password_hash: The expected hash value of the password",
            "                          (usually from your database)",
            "",
            "    .. note::",
            "        Make sure that the password passed in has already been normalized.",
            "    \"\"\"",
            "    if use_double_hash(password_hash):",
            "        password = get_hmac(password)",
            "",
            "    return _pwd_context.verify(password, password_hash)",
            "",
            "",
            "def verify_and_update_password(password, user):",
            "    \"\"\"Returns ``True`` if the password is valid for the specified user.",
            "",
            "    Additionally, the hashed password in the database is updated if the",
            "    hashing algorithm happens to have changed.",
            "",
            "    N.B. you MUST call DB commit if you are using a session-based datastore",
            "    (such as SqlAlchemy) since the user instance might have been altered",
            "    (i.e. ``app.security.datastore.commit()``).",
            "    This is usually handled in the view.",
            "",
            "    :param password: A plaintext password to verify",
            "    :param user: The user to verify against",
            "",
            "    .. tip::",
            "        This should not be called directly - rather use",
            "        :meth:`.UserMixin.verify_and_update_password`",
            "",
            "    \"\"\"",
            "    if use_double_hash(user.password):",
            "        verified = _pwd_context.verify(get_hmac(password), user.password)",
            "    else:",
            "        # Try with original password.",
            "        verified = _pwd_context.verify(password, user.password)",
            "",
            "    if verified and _pwd_context.needs_update(user.password):",
            "        user.password = hash_password(password)",
            "        _datastore.put(user)",
            "    return verified",
            "",
            "",
            "def encrypt_password(password):  # pragma: no cover",
            "    \"\"\"Encrypt the specified plaintext password.",
            "",
            "    It uses the configured encryption options.",
            "",
            "    .. deprecated:: 2.0.2",
            "       Use :func:`hash_password` instead.",
            "",
            "    :param password: The plaintext password to encrypt",
            "    \"\"\"",
            "    warnings.warn(",
            "        \"Please use hash_password instead of encrypt_password.\", DeprecationWarning",
            "    )",
            "    return hash_password(password)",
            "",
            "",
            "def hash_password(password):",
            "    \"\"\"Hash the specified plaintext password.",
            "",
            "    Unless the hash algorithm (as specified by `SECURITY_PASSWORD_HASH`) is listed in",
            "    the configuration variable `SECURITY_PASSWORD_SINGLE_HASH`,",
            "    perform a double hash - first create an HMAC from the plaintext password",
            "    and the value of `SECURITY_PASSWORD_SALT`,",
            "    then use the configured hashing algorithm.",
            "    This satisfies OWASP/ASVS section 2.4.5: 'provide additional",
            "    iteration of a key derivation'.",
            "",
            "    .. versionadded:: 2.0.2",
            "",
            "    :param password: The plaintext password to hash",
            "    \"\"\"",
            "    if use_double_hash():",
            "        password = get_hmac(password).decode(\"ascii\")",
            "",
            "    # Passing in options as part of hash is deprecated in passlib 1.7",
            "    # and new algorithms like argon2 don't even support it.",
            "    return _pwd_context.hash(",
            "        password,",
            "        **config_value(\"PASSWORD_HASH_OPTIONS\", default={}).get(",
            "            _security.password_hash, {}",
            "        ),",
            "    )",
            "",
            "",
            "def encode_string(string):",
            "    \"\"\"Encodes a string to bytes, if it isn't already.",
            "",
            "    :param string: The string to encode\"\"\"",
            "",
            "    if isinstance(string, str):",
            "        string = string.encode(\"utf-8\")",
            "    return string",
            "",
            "",
            "def hash_data(data):",
            "    return _hashing_context.hash(encode_string(data))",
            "",
            "",
            "def verify_hash(hashed_data, compare_data):",
            "    return _hashing_context.verify(encode_string(compare_data), hashed_data)",
            "",
            "",
            "def suppress_form_csrf():",
            "    \"\"\"",
            "    Return meta contents if we should suppress form from attempting to validate CSRF.",
            "",
            "    If app doesn't want CSRF for unauth endpoints then check if caller is authenticated",
            "    or not (many endpoints can be called either way).",
            "    \"\"\"",
            "    if get_request_attr(\"fs_ignore_csrf\"):",
            "        # This is the case where CsrfProtect was already called (e.g. @auth_required)",
            "        return {\"csrf\": False}",
            "    if (",
            "        config_value(\"CSRF_IGNORE_UNAUTH_ENDPOINTS\")",
            "        and not current_user.is_authenticated",
            "    ):",
            "        return {\"csrf\": False}",
            "    return {}",
            "",
            "",
            "def do_flash(message, category=None):",
            "    \"\"\"Flash a message depending on if the `FLASH_MESSAGES` configuration",
            "    value is set.",
            "",
            "    :param message: The flash message",
            "    :param category: The flash message category",
            "    \"\"\"",
            "    if config_value(\"FLASH_MESSAGES\"):",
            "        flash(message, category)",
            "",
            "",
            "def get_url(endpoint_or_url, qparams=None):",
            "    \"\"\"Returns a URL if a valid endpoint is found. Otherwise, returns the",
            "    provided value.",
            "",
            "    :param endpoint_or_url: The endpoint name or URL to default to",
            "    :param qparams: additional query params to add to end of url",
            "    :return: URL",
            "    \"\"\"",
            "    try:",
            "        return transform_url(url_for(endpoint_or_url), qparams)",
            "    except Exception:",
            "        # This is an external URL (no endpoint defined in app)",
            "        # For (mostly) testing - allow changing/adding the url - for example",
            "        # add a different host:port for cases where the UI is running",
            "        # separately.",
            "        if _security.redirect_host:",
            "            url = transform_url(",
            "                endpoint_or_url, qparams, netloc=_security.redirect_host",
            "            )",
            "        else:",
            "            url = transform_url(endpoint_or_url, qparams)",
            "",
            "        return url",
            "",
            "",
            "def slash_url_suffix(url, suffix):",
            "    \"\"\"Adds a slash either to the beginning or the end of a suffix",
            "    (which is to be appended to a URL), depending on whether or not",
            "    the URL ends with a slash.\"\"\"",
            "",
            "    return url.endswith(\"/\") and (\"%s/\" % suffix) or (\"/%s\" % suffix)",
            "",
            "",
            "def transform_url(url, qparams=None, **kwargs):",
            "    \"\"\"Modify url",
            "",
            "    :param url: url to transform (can be relative)",
            "    :param qparams: additional query params to add to end of url",
            "    :param kwargs: pieces of URL to modify - e.g. netloc=localhost:8000",
            "    :return: Modified URL",
            "",
            "    .. versionadded:: 3.2.0",
            "    \"\"\"",
            "    if not url:",
            "        return url",
            "    link_parse = urlsplit(url)",
            "    if qparams:",
            "        current_query = dict(parse_qsl(link_parse.query))",
            "        current_query.update(qparams)",
            "        link_parse = link_parse._replace(query=urlencode(current_query))",
            "    return urlunsplit(link_parse._replace(**kwargs))",
            "",
            "",
            "def get_security_endpoint_name(endpoint):",
            "    return f\"{_security.blueprint_name}.{endpoint}\"",
            "",
            "",
            "def url_for_security(endpoint, **values):",
            "    \"\"\"Return a URL for the security blueprint",
            "",
            "    :param endpoint: the endpoint of the URL (name of the function)",
            "    :param values: the variable arguments of the URL rule",
            "    :param _external: if set to `True`, an absolute URL is generated. Server",
            "      address can be changed via `SERVER_NAME` configuration variable which",
            "      defaults to `localhost`.",
            "    :param _anchor: if provided this is added as anchor to the URL.",
            "    :param _method: if provided this explicitly specifies an HTTP method.",
            "    \"\"\"",
            "    endpoint = get_security_endpoint_name(endpoint)",
            "    return url_for(endpoint, **values)",
            "",
            "",
            "def validate_redirect_url(url):",
            "    if url is None or url.strip() == \"\":",
            "        return False",
            "    url_next = urlsplit(url)",
            "    url_base = urlsplit(request.host_url)",
            "    if (url_next.netloc or url_next.scheme) and url_next.netloc != url_base.netloc:",
            "        base_domain = current_app.config.get(\"SERVER_NAME\")",
            "        if (",
            "            config_value(\"REDIRECT_ALLOW_SUBDOMAINS\")",
            "            and base_domain",
            "            and (",
            "                url_next.netloc == base_domain",
            "                or url_next.netloc.endswith(f\".{base_domain}\")",
            "            )",
            "        ):",
            "            return True",
            "        else:",
            "            return False",
            "    return True",
            "",
            "",
            "def get_post_action_redirect(config_key, declared=None):",
            "    urls = [",
            "        get_url(request.args.get(\"next\", None)),",
            "        get_url(request.form.get(\"next\", None)),",
            "        find_redirect(config_key),",
            "    ]",
            "    if declared:",
            "        urls.insert(0, declared)",
            "    for url in urls:",
            "        if validate_redirect_url(url):",
            "            return url",
            "",
            "",
            "def get_post_login_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_LOGIN_VIEW\", declared)",
            "",
            "",
            "def get_post_register_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_REGISTER_VIEW\", declared)",
            "",
            "",
            "def get_post_logout_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_LOGOUT_VIEW\", declared)",
            "",
            "",
            "def get_post_verify_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_VERIFY_VIEW\", declared)",
            "",
            "",
            "def find_redirect(key):",
            "    \"\"\"Returns the URL to redirect to after a user logs in successfully.",
            "",
            "    :param key: The session or application configuration key to search for",
            "    \"\"\"",
            "    rv = (",
            "        get_url(session.pop(key.lower(), None))",
            "        or get_url(current_app.config[key.upper()] or None)",
            "        or current_app.config.get(\"APPLICATION_ROOT\", \"/\")",
            "    )",
            "    return rv",
            "",
            "",
            "def propagate_next(url):",
            "    # return either URL or, if URL already has a ?next=xx, return that.",
            "    url_next = urlsplit(url)",
            "    qparams = parse_qs(url_next.query)",
            "    if \"next\" in qparams:",
            "        return qparams[\"next\"][0]",
            "    return url",
            "",
            "",
            "def get_config(app):",
            "    \"\"\"Conveniently get the security configuration for the specified",
            "    application without the annoying 'SECURITY_' prefix.",
            "",
            "    :param app: The application to inspect",
            "    \"\"\"",
            "    items = app.config.items()",
            "    prefix = \"SECURITY_\"",
            "",
            "    def strip_prefix(tup):",
            "        return tup[0].replace(\"SECURITY_\", \"\"), tup[1]",
            "",
            "    return dict([strip_prefix(i) for i in items if i[0].startswith(prefix)])",
            "",
            "",
            "def get_message(key, **kwargs):",
            "    rv = config_value(\"MSG_\" + key)",
            "    return localize_callback(rv[0], **kwargs), rv[1]",
            "",
            "",
            "def config_value(key, app=None, default=None):",
            "    \"\"\"Get a Flask-Security configuration value.",
            "",
            "    :param key: The configuration key without the prefix `SECURITY_`",
            "    :param app: An optional specific application to inspect. Defaults to",
            "                Flask's `current_app`",
            "    :param default: An optional default value if the value is not set",
            "    \"\"\"",
            "    app = app or current_app",
            "    # protect against spelling mistakes",
            "    config = get_config(app)",
            "    if key.upper() not in config:",
            "        raise ValueError(f\"Key {key} doesn't exist\")",
            "    return config.get(key.upper(), default)",
            "",
            "",
            "def get_max_age(key, app=None):",
            "    td = get_within_delta(key + \"_WITHIN\", app)",
            "    return td.seconds + td.days * 24 * 3600",
            "",
            "",
            "def get_within_delta(key, app=None):",
            "    \"\"\"Get a timedelta object from the application configuration following",
            "    the internal convention of::",
            "",
            "        <Amount of Units> <Type of Units>",
            "",
            "    Examples of valid config values::",
            "",
            "        5 days",
            "        10 minutes",
            "",
            "    :param key: The config value key without the `SECURITY_` prefix",
            "    :param app: Optional application to inspect. Defaults to Flask's",
            "                `current_app`",
            "    \"\"\"",
            "    txt = config_value(key, app=app)",
            "    values = txt.split()",
            "    return timedelta(**{values[1]: int(values[0])})",
            "",
            "",
            "def send_mail(subject, recipient, template, **context):",
            "    \"\"\"Send an email.",
            "",
            "    :param subject: Email subject",
            "    :param recipient: Email recipient",
            "    :param template: The name of the email template",
            "    :param context: The context to render the template with",
            "",
            "    This formats the email and passes it off to :class:`.MailUtil` to actually send the",
            "    message.",
            "    \"\"\"",
            "",
            "    context.setdefault(\"security\", _security)",
            "    context.update(_security._run_ctx_processor(\"mail\"))",
            "",
            "    body = None",
            "    html = None",
            "    ctx = (\"security/email\", template)",
            "    if config_value(\"EMAIL_PLAINTEXT\"):",
            "        body = _security.render_template(\"%s/%s.txt\" % ctx, **context)",
            "    if config_value(\"EMAIL_HTML\"):",
            "        html = _security.render_template(\"%s/%s.html\" % ctx, **context)",
            "",
            "    subject = localize_callback(subject)",
            "",
            "    sender = _security.email_sender",
            "    if isinstance(sender, LocalProxy):",
            "        sender = sender._get_current_object()",
            "",
            "    _security._mail_util.send_mail(",
            "        template, subject, recipient, str(sender), body, html, context.get(\"user\", None)",
            "    )",
            "",
            "",
            "def get_token_status(token, serializer, max_age=None, return_data=False):",
            "    \"\"\"Get the status of a token.",
            "",
            "    :param token: The token to check",
            "    :param serializer: The name of the serializer. Can be one of the",
            "                       following: ``confirm``, ``login``, ``reset``",
            "    :param max_age: The name of the max age config option. Can be one of",
            "                    the following: ``CONFIRM_EMAIL``, ``LOGIN``,",
            "                    ``RESET_PASSWORD``",
            "    \"\"\"",
            "    serializer = getattr(_security, serializer + \"_serializer\")",
            "    max_age = get_max_age(max_age)",
            "    user, data = None, None",
            "    expired, invalid = False, False",
            "",
            "    try:",
            "        data = serializer.loads(token, max_age=max_age)",
            "    except SignatureExpired:",
            "        d, data = serializer.loads_unsafe(token)",
            "        expired = True",
            "    except (BadSignature, TypeError, ValueError):",
            "        invalid = True",
            "",
            "    if data:",
            "        user = _datastore.find_user(fs_uniquifier=data[0])",
            "",
            "    expired = expired and (user is not None)",
            "",
            "    if return_data:",
            "        return expired, invalid, user, data",
            "    else:",
            "        return expired, invalid, user",
            "",
            "",
            "def check_and_get_token_status(token, serializer, within=None):",
            "    \"\"\"Get the status of a token and return data.",
            "",
            "    :param token: The token to check",
            "    :param serializer: The name of the serializer. Can be one of the",
            "                       following: ``confirm``, ``login``, ``reset``, ``us_setup``",
            "                       ``remember``, ``two_factor_validity``",
            "    :param within: max age - passed as a timedelta",
            "",
            "    :return: a tuple of (expired, invalid, data)",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "    serializer = getattr(_security, serializer + \"_serializer\")",
            "    max_age = within.total_seconds()",
            "    data = None",
            "    expired, invalid = False, False",
            "",
            "    try:",
            "        data = serializer.loads(token, max_age=max_age)",
            "    except SignatureExpired:",
            "        d, data = serializer.loads_unsafe(token)",
            "        expired = True",
            "    except (BadSignature, TypeError, ValueError):",
            "        invalid = True",
            "",
            "    return expired, invalid, data",
            "",
            "",
            "def get_identity_attributes(app=None) -> List:",
            "    # Return list of keys of identity attributes",
            "    # Is it possible to not have any?",
            "    app = app or current_app",
            "    iattrs = app.config[\"SECURITY_USER_IDENTITY_ATTRIBUTES\"]",
            "    if iattrs:",
            "        return [[*f][0] for f in iattrs]",
            "    return []",
            "",
            "",
            "def get_identity_attribute(attr, app=None) -> Dict:",
            "    \"\"\"Given an user_identity_attribute, return the defining dict.",
            "    A bit annoying since USER_IDENTITY_ATTRIBUTES is a list of dict",
            "    where each dict has just one key.",
            "    \"\"\"",
            "    app = app or current_app",
            "    iattrs = app.config[\"SECURITY_USER_IDENTITY_ATTRIBUTES\"]",
            "    if iattrs:",
            "        details = [",
            "            mapping[attr] for mapping in iattrs if list(mapping.keys())[0] == attr",
            "        ]",
            "        if details:",
            "            return details[0]",
            "    return {}",
            "",
            "",
            "def find_user(identity):",
            "    \"\"\"",
            "    Validate identity - we go in order to figure out which user attribute the",
            "    request gave us. Note that we give up on the first 'match' even if that",
            "    doesn't yield a user. Why?",
            "    \"\"\"",
            "    for mapping in config_value(\"USER_IDENTITY_ATTRIBUTES\"):",
            "        attr = list(mapping.keys())[0]",
            "        details = mapping[attr]",
            "        idata = details[\"mapper\"](identity)",
            "        if idata:",
            "            user = _datastore.find_user(",
            "                case_insensitive=details.get(\"case_insensitive\", False), **{attr: idata}",
            "            )",
            "            return user",
            "    return None",
            "",
            "",
            "def uia_phone_mapper(identity):",
            "    \"\"\"Used to match identity as a phone number. This is a simple proxy",
            "    to :py:class:`PhoneUtil`",
            "",
            "    See :py:data:`SECURITY_USER_IDENTITY_ATTRIBUTES`.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "    ph = _security._phone_util.get_canonical_form(identity)",
            "    return ph",
            "",
            "",
            "def uia_email_mapper(identity):",
            "    \"\"\"Used to match identity as an email.",
            "",
            "    See :py:data:`SECURITY_USER_IDENTITY_ATTRIBUTES`.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "",
            "    try:",
            "        return _security._mail_util.normalize(identity)",
            "    except ValueError:",
            "        return None",
            "",
            "",
            "def use_double_hash(password_hash=None):",
            "    \"\"\"Return a bool indicating whether a password should be hashed twice.\"\"\"",
            "    # Default to plaintext for backward compatibility with",
            "    # SECURITY_PASSWORD_SINGLE_HASH = False",
            "    single_hash = config_value(\"PASSWORD_SINGLE_HASH\") or {\"plaintext\"}",
            "",
            "    if password_hash is None:",
            "        scheme = _security.password_hash",
            "    else:",
            "        scheme = _pwd_context.identify(password_hash)",
            "",
            "    return not (single_hash is True or scheme in single_hash)",
            "",
            "",
            "def csrf_cookie_handler(response):",
            "    \"\"\"Called at end of every request.",
            "    Uses session to track state (set/clear)",
            "",
            "    Ideally we just need to set this once - however by default",
            "    Flask-WTF has a time-out on these tokens governed by *WTF_CSRF_TIME_LIMIT*.",
            "    While we could set that to None - and OWASP implies this is fine - that might",
            "    not be agreeable to everyone.",
            "    So as a basic usability hack - we check if it is expired and re-generate so at least",
            "    the user doesn't have to log out and back in (just refresh).",
            "    We also support a *CSRF_COOKIE_REFRESH_EACH_REQUEST* analogous to Flask's",
            "    *SESSION_REFRESH_EACH_REQUEST*",
            "",
            "    It is of course removed on logout/session end.",
            "    Other info on web suggests replacing on every POST and accepting up to 'age' ago.",
            "    \"\"\"",
            "    csrf_cookie = config_value(\"CSRF_COOKIE\")",
            "    if not csrf_cookie or not csrf_cookie[\"key\"]:",
            "        return response",
            "",
            "    op = session.get(\"fs_cc\", None)",
            "    if not op:",
            "        remember_cookie_name = current_app.config.get(",
            "            \"REMEMBER_COOKIE_NAME\", REMEMBER_COOKIE_NAME",
            "        )",
            "        has_remember_cookie = (",
            "            remember_cookie_name in request.cookies",
            "            and session.get(\"remember\") != \"clear\"",
            "        )",
            "        # Set cookie if successfully logged in with flask_login's remember cookie",
            "        if has_remember_cookie and current_user.is_authenticated:",
            "            op = \"set\"",
            "        else:",
            "            return response",
            "",
            "    if op == \"clear\":",
            "        response.delete_cookie(",
            "            csrf_cookie[\"key\"],",
            "            path=csrf_cookie.get(\"path\", \"/\"),",
            "            domain=csrf_cookie.get(\"domain\", None),",
            "        )",
            "        session.pop(\"fs_cc\")",
            "        return response",
            "",
            "    # Send a cookie if any of:",
            "    # 1) CSRF_COOKIE_REFRESH_EACH_REQUEST is true",
            "    # 2) fs_cc == \"set\" - this is on first login",
            "    # 3) existing cookie has expired",
            "    send = False",
            "    if op == \"set\":",
            "        send = True",
            "        session[\"fs_cc\"] = \"sent\"",
            "    elif config_value(\"CSRF_COOKIE_REFRESH_EACH_REQUEST\"):",
            "        send = True",
            "    elif current_app.config[\"WTF_CSRF_TIME_LIMIT\"]:",
            "        current_cookie = request.cookies.get(csrf_cookie[\"key\"], None)",
            "        if current_cookie:",
            "            # Lets make sure it isn't expired if app doesn't set TIME_LIMIT to None.",
            "            try:",
            "                csrf.validate_csrf(current_cookie)",
            "            except ValidationError:",
            "                send = True",
            "",
            "    if send:",
            "        kwargs = {k: v for k, v in csrf_cookie.items()}",
            "        kwargs.pop(\"key\")",
            "        kwargs[\"value\"] = csrf.generate_csrf()",
            "        response.set_cookie(csrf_cookie[\"key\"], **kwargs)",
            "    return response",
            "",
            "",
            "def base_render_json(",
            "    form,",
            "    include_user=True,",
            "    include_auth_token=False,",
            "    additional=None,",
            "    error_status_code=400,",
            "):",
            "    \"\"\"",
            "    This method is called by all views that return JSON responses.",
            "    This fills in the response and then calls :meth:`.Security.render_json`",
            "    which can be overridden by the app.",
            "    \"\"\"",
            "    has_errors = len(form.errors) > 0",
            "",
            "    user = form.user if hasattr(form, \"user\") else None",
            "    if has_errors:",
            "        code = error_status_code",
            "        payload = json_error_response(errors=form.errors)",
            "    else:",
            "        code = 200",
            "        payload = dict()",
            "        if user:",
            "            # This allows anonymous GETs via JSON",
            "            if include_user:",
            "                payload[\"user\"] = user.get_security_payload()",
            "",
            "            if include_auth_token:",
            "                # view willing to return auth_token - check behavior config",
            "                if (",
            "                    config_value(\"BACKWARDS_COMPAT_AUTH_TOKEN\")",
            "                    or \"include_auth_token\" in request.args",
            "                ):",
            "                    try:",
            "                        token = user.get_auth_token()",
            "                    except ValueError:",
            "                        # application has fs_token_uniquifier attribute but it",
            "                        # hasn't been initialized. Since we are in a request context",
            "                        # we can do that here.",
            "                        _datastore.set_token_uniquifier(user)",
            "                        after_this_request(view_commit)",
            "                        token = user.get_auth_token()",
            "                    payload[\"user\"][\"authentication_token\"] = token",
            "",
            "        # Return csrf_token on each JSON response - just as every form",
            "        # has it rendered.",
            "        payload[\"csrf_token\"] = csrf.generate_csrf()",
            "        if additional:",
            "            payload.update(additional)",
            "",
            "    return _security._render_json(payload, code, headers=None, user=user)",
            "",
            "",
            "def default_want_json(req):",
            "    \"\"\"Return True if response should be in json",
            "    N.B. do not call this directly - use security.want_json()",
            "",
            "    :param req: Flask/Werkzeug Request",
            "    \"\"\"",
            "    if req.is_json:",
            "        return True",
            "    # TODO should this handle json sub-types?",
            "    accept_mimetypes = req.accept_mimetypes",
            "    if not hasattr(req.accept_mimetypes, \"best\"):  # pragma: no cover",
            "        # Alright. we dont have the best property, lets add it ourselves.",
            "        # This is for quart compatibility",
            "        accept_mimetypes.best = best",
            "    if accept_mimetypes.best == \"application/json\":",
            "        return True",
            "    return False",
            "",
            "",
            "def json_error_response(errors):",
            "    \"\"\"Helper to create an error response that adheres to the openapi spec.\"\"\"",
            "    if isinstance(errors, str):",
            "        # When the errors is a string, use the response/error/message format",
            "        response_json = dict(error=errors)",
            "    elif isinstance(errors, dict):",
            "        # When the errors is a dict, use the DefaultJsonErrorResponse",
            "        # (response/errors/name/messages) format",
            "        response_json = dict(errors=errors)",
            "    else:",
            "        raise TypeError(\"The errors argument should be either a str or dict.\")",
            "",
            "    return response_json",
            "",
            "",
            "class FsJsonEncoder(JSONEncoder):",
            "    \"\"\"Flask-Security JSON encoder.",
            "    Extends Flask's JSONencoder to handle lazy-text.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def default(self, obj):",
            "        from .babel import is_lazy_string",
            "",
            "        if is_lazy_string(obj):",
            "            return str(obj)",
            "        else:",
            "            return JSONEncoder.default(self, obj)",
            "",
            "",
            "class SmsSenderBaseClass(metaclass=abc.ABCMeta):",
            "    def __init__(self):",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def send_sms(self, from_number, to_number, msg):  # pragma: no cover",
            "        \"\"\"Abstract method for sending sms messages",
            "",
            "        .. versionadded:: 3.2.0",
            "        \"\"\"",
            "        return",
            "",
            "",
            "class DummySmsSender(SmsSenderBaseClass):",
            "    def send_sms(self, from_number, to_number, msg):  # pragma: no cover",
            "        \"\"\"Do nothing.\"\"\"",
            "        return",
            "",
            "",
            "class SmsSenderFactory:",
            "    senders = {\"Dummy\": DummySmsSender}",
            "",
            "    @classmethod",
            "    def createSender(cls, name, *args, **kwargs):",
            "        \"\"\"Initialize an SMS sender.",
            "",
            "        :param name: Name as registered in SmsSenderFactory:senders (e.g. 'Twilio')",
            "",
            "        .. versionadded:: 3.2.0",
            "        \"\"\"",
            "        return cls.senders[name](*args, **kwargs)",
            "",
            "",
            "try:  # pragma: no cover",
            "    from twilio.rest import Client",
            "",
            "    class TwilioSmsSender(SmsSenderBaseClass):",
            "        def __init__(self):",
            "            self.account_sid = config_value(\"SMS_SERVICE_CONFIG\")[\"ACCOUNT_SID\"]",
            "            self.auth_token = config_value(\"SMS_SERVICE_CONFIG\")[\"AUTH_TOKEN\"]",
            "",
            "        def send_sms(self, from_number, to_number, msg):",
            "            \"\"\"Send message via twilio account.\"\"\"",
            "            client = Client(self.account_sid, self.auth_token)",
            "            client.messages.create(to=to_number, from_=from_number, body=msg)",
            "",
            "    SmsSenderFactory.senders[\"Twilio\"] = TwilioSmsSender",
            "except Exception:",
            "    pass",
            "",
            "",
            "def password_length_validator(password):",
            "    \"\"\"Test password for length.",
            "",
            "    :param password: Plain text password to check",
            "",
            "    :return: ``None`` if password conforms to length requirements,",
            "     a list of error/suggestions if not.",
            "",
            "    .. versionadded:: 3.4.0",
            "",
            "    \"\"\"",
            "    if len(password) < config_value(\"PASSWORD_LENGTH_MIN\") or len(password) > 128:",
            "        return [",
            "            get_message(",
            "                \"PASSWORD_INVALID_LENGTH\", length=config_value(\"PASSWORD_LENGTH_MIN\")",
            "            )[0]",
            "        ]",
            "    return None",
            "",
            "",
            "def password_complexity_validator(password, is_register, **kwargs):",
            "    \"\"\"Test password for complexity.",
            "",
            "    Currently just supports 'zxcvbn'.",
            "",
            "    :param password: Plain text password to check",
            "    :param is_register: if True then kwargs are arbitrary additional info. (e.g.",
            "        info from a registration form). If False, must be a SINGLE key \"user\" that",
            "        corresponds to the current_user. All string values will be extracted and",
            "        sent to the complexity checker.",
            "    :param kwargs:",
            "",
            "    :return: ``None`` if password is complex enough, a list of error/suggestions if not.",
            "        Be aware that zxcvbn does not (easily) provide a way to localize messages.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "",
            "    if config_value(\"PASSWORD_COMPLEXITY_CHECKER\") == \"zxcvbn\":",
            "        import zxcvbn",
            "",
            "        user_info = []",
            "        if not is_register:",
            "            for v in kwargs[\"user\"].__dict__.values():",
            "                if v and isinstance(v, str):",
            "                    user_info.append(v)",
            "        else:",
            "            # This is usually all register form values that are in the user_model",
            "            if kwargs:",
            "                user_info = kwargs.values()",
            "        results = zxcvbn.zxcvbn(password, user_inputs=user_info)",
            "        if results[\"score\"] > 2:",
            "            # Good or Strong",
            "            return None",
            "        # Should we return suggestions? Default forms don't really know what to do.",
            "        if results[\"feedback\"][\"warning\"]:",
            "            # Note that these come from zxcvbn and",
            "            # aren't localizable via Flask-Security",
            "            return [results[\"feedback\"][\"warning\"]]",
            "        return [get_message(\"PASSWORD_TOO_SIMPLE\")[0]]",
            "    else:",
            "        return None",
            "",
            "",
            "def password_breached_validator(password):",
            "    \"\"\"Check if password on breached list.",
            "    Does nothing unless :py:data:`SECURITY_PASSWORD_CHECK_BREACHED` is set.",
            "    If password is found on the breached list, return an error if the count is",
            "    greater than or equal to :py:data:`SECURITY_PASSWORD_BREACHED_COUNT`.",
            "    Uses :meth:`pwned`.",
            "",
            "    :param password: Plain text password to check",
            "",
            "    :return: ``None`` if password passes breached tests, else a list of error messages.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "    pwn = config_value(\"PASSWORD_CHECK_BREACHED\")",
            "    if pwn:",
            "        try:",
            "            cnt = pwned(password)",
            "            if cnt >= config_value(\"PASSWORD_BREACHED_COUNT\"):",
            "                return [get_message(\"PASSWORD_BREACHED\")[0]]",
            "        except Exception:",
            "            if pwn == \"strict\":",
            "                return [get_message(\"PASSWORD_BREACHED_SITE_ERROR\")[0]]",
            "    return None",
            "",
            "",
            "def pwned(password):",
            "    \"\"\"",
            "    Check password against pwnedpasswords API using k-Anonymity.",
            "    https://haveibeenpwned.com/API/v3",
            "",
            "    :return: Count of password in DB (0 means hasn't been compromised)",
            "",
            "    Can raise HTTPError",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "",
            "    def convert_password_tuple(value):",
            "        hash_suffix, count = value.split(\":\")",
            "        return hash_suffix, int(count)",
            "",
            "    sha1 = hashlib.sha1(password.encode(\"utf8\")).hexdigest()",
            "",
            "    req = urllib.request.Request(",
            "        url=f\"https://api.pwnedpasswords.com/range/{sha1[:5].upper()}\",",
            "        headers={\"User-Agent\": \"Flask-Security (Python)\"},",
            "    )",
            "    # Might raise HTTPError",
            "    with urllib.request.urlopen(req) as f:",
            "        response = f.read()",
            "",
            "    raw = response.decode(\"utf-8-sig\")",
            "",
            "    entries = dict(map(convert_password_tuple, raw.upper().split(\"\\r\\n\")))",
            "    return entries.get(sha1[5:].upper(), 0)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "    flask_security.utils",
            "    ~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Flask-Security utils module",
            "",
            "    :copyright: (c) 2012-2019 by Matt Wright.",
            "    :copyright: (c) 2019-2021 by J. Christopher Wagner (jwag).",
            "    :license: MIT, see LICENSE for more details.",
            "\"\"\"",
            "import abc",
            "import base64",
            "import datetime",
            "from functools import partial",
            "import hashlib",
            "import hmac",
            "import time",
            "from typing import Dict, List",
            "import warnings",
            "from datetime import timedelta",
            "from urllib.parse import parse_qsl, parse_qs, urlsplit, urlunsplit, urlencode",
            "import urllib.request",
            "import urllib.error",
            "",
            "from flask import (",
            "    _request_ctx_stack,",
            "    after_this_request,",
            "    current_app,",
            "    flash,",
            "    g,",
            "    request,",
            "    session,",
            "    url_for,",
            ")",
            "from flask.json import JSONEncoder",
            "from flask_login import login_user as _login_user",
            "from flask_login import logout_user as _logout_user",
            "from flask_login import current_user",
            "from flask_login import COOKIE_NAME as REMEMBER_COOKIE_NAME",
            "from flask_principal import AnonymousIdentity, Identity, identity_changed, Need",
            "from flask_wtf import csrf",
            "from wtforms import ValidationError",
            "from itsdangerous import BadSignature, SignatureExpired",
            "from werkzeug.local import LocalProxy",
            "from werkzeug.datastructures import MultiDict",
            "",
            "from .quart_compat import best, get_quart_status",
            "from .signals import user_authenticated",
            "",
            "# Convenient references",
            "_security = LocalProxy(lambda: current_app.extensions[\"security\"])",
            "",
            "_datastore = LocalProxy(lambda: _security.datastore)",
            "",
            "_pwd_context = LocalProxy(lambda: _security.pwd_context)",
            "",
            "_hashing_context = LocalProxy(lambda: _security.hashing_context)",
            "",
            "localize_callback = LocalProxy(lambda: _security.i18n_domain.gettext)",
            "",
            "FsPermNeed = partial(Need, \"fsperm\")",
            "FsPermNeed.__doc__ = \"\"\"A need with the method preset to `\"fsperm\"`.\"\"\"",
            "",
            "",
            "def _(translate):",
            "    \"\"\"Identity function to mark strings for translation.\"\"\"",
            "    return translate",
            "",
            "",
            "def get_request_attr(name):",
            "    \"\"\"Retrieve a request local attribute.",
            "",
            "    Currently public attributes are:",
            "",
            "    **fs_authn_via**",
            "        will be set to the authentication mechanism (session, token, basic)",
            "        that the current request was authenticated with.",
            "",
            "    Returns None if attribute doesn't exist.",
            "",
            "    .. versionadded:: 4.0.0",
            "    \"\"\"",
            "    return getattr(_request_ctx_stack.top, name, None)",
            "",
            "",
            "def set_request_attr(name, value):",
            "    return setattr(_request_ctx_stack.top, name, value)",
            "",
            "",
            "\"\"\"",
            "Most view functions that modify the DB will call ``after_this_request(view_commit)``",
            "Quart compatibility needs an async version",
            "\"\"\"",
            "if get_quart_status():  # pragma: no cover",
            "",
            "    async def view_commit(response=None):",
            "        _datastore.commit()",
            "        return response",
            "",
            "",
            "else:",
            "",
            "    def view_commit(response=None):",
            "        _datastore.commit()",
            "        return response",
            "",
            "",
            "def find_csrf_field_name():",
            "    \"\"\"",
            "    We need to clear it on logout (since that isn't being done by Flask-WTF).",
            "    The field name is configurable withing Flask-WTF as well as being",
            "    overridable.",
            "    We take the field name from the login_form as set by the configuration.",
            "    \"\"\"",
            "    form = _security.login_form(MultiDict([]))",
            "    if hasattr(form.meta, \"csrf_field_name\"):",
            "        return form.meta.csrf_field_name",
            "    return None",
            "",
            "",
            "def login_user(user, remember=None, authn_via=None):",
            "    \"\"\"Perform the login routine.",
            "",
            "    If *SECURITY_TRACKABLE* is used, make sure you commit changes after this",
            "    request (i.e. ``app.security.datastore.commit()``).",
            "",
            "    :param user: The user to login",
            "    :param remember: Flag specifying if the remember cookie should be set.",
            "                     Defaults to ``False``",
            "    :param authn_via: A list of strings denoting which mechanism(s) the user",
            "        authenticated with.",
            "        These should be one or more of [\"password\", \"sms\", \"authenticator\", \"email\"] or",
            "        other 'auto-login' mechanisms.",
            "    \"\"\"",
            "",
            "    if remember is None:",
            "        remember = config_value(\"DEFAULT_REMEMBER_ME\")",
            "",
            "    if not _login_user(user, remember):  # pragma: no cover",
            "        return False",
            "",
            "    if _security.trackable:",
            "        remote_addr = request.remote_addr or None  # make sure it is None",
            "",
            "        old_current_login, new_current_login = (",
            "            user.current_login_at,",
            "            _security.datetime_factory(),",
            "        )",
            "        old_current_ip, new_current_ip = user.current_login_ip, remote_addr",
            "",
            "        user.last_login_at = old_current_login or new_current_login",
            "        user.current_login_at = new_current_login",
            "        user.last_login_ip = old_current_ip",
            "        user.current_login_ip = new_current_ip",
            "        user.login_count = user.login_count + 1 if user.login_count else 1",
            "",
            "        _datastore.put(user)",
            "",
            "    session[\"fs_cc\"] = \"set\"  # CSRF cookie",
            "    session[\"fs_paa\"] = time.time()  # Primary authentication at - timestamp",
            "",
            "    identity_changed.send(",
            "        current_app._get_current_object(), identity=Identity(user.fs_uniquifier)",
            "    )",
            "",
            "    user_authenticated.send(",
            "        current_app._get_current_object(), user=user, authn_via=authn_via",
            "    )",
            "    return True",
            "",
            "",
            "def logout_user():",
            "    \"\"\"Logs out the current user.",
            "",
            "    This will also clean up the remember me cookie if it exists.",
            "",
            "    This sends an ``identity_changed`` signal to note that the current",
            "    identity is now the `AnonymousIdentity`",
            "    \"\"\"",
            "",
            "    for key in (\"identity.name\", \"identity.auth_type\", \"fs_paa\", \"fs_gexp\"):",
            "        session.pop(key, None)",
            "",
            "    # Clear csrf token between sessions.",
            "    # Ideally this would be handled by Flask-WTF but...",
            "    # We don't clear entire session since Flask-Login seems to like having it.",
            "    csrf_field_name = find_csrf_field_name()",
            "    if csrf_field_name:",
            "        session.pop(csrf_field_name, None)",
            "        # Flask-WTF 'caches' csrf_token - and only set the session if not already",
            "        # in 'g'. Be sure to clear both. This affects at least /confirm",
            "        g.pop(csrf_field_name, None)",
            "    session[\"fs_cc\"] = \"clear\"",
            "    identity_changed.send(",
            "        current_app._get_current_object(), identity=AnonymousIdentity()",
            "    )",
            "    _logout_user()",
            "",
            "",
            "def check_and_update_authn_fresh(within, grace, method=None):",
            "    \"\"\"Check if user authenticated within specified time and update grace period.",
            "",
            "    :param within: A timedelta specifying the maximum time in the past that the caller",
            "                  authenticated that is still considered 'fresh'.",
            "    :param grace: A timedelta that, if the current session is considered 'fresh'",
            "                  will set a grace period for which freshness won't be checked.",
            "                  The intent here is that the caller shouldn't get part-way though",
            "                  a set of operations and suddenly be required to authenticate again.",
            "    :param method: Optional - if set and == \"basic\" then will always return True.",
            "                  (since basic-auth sends username/password on every request)",
            "",
            "    If within.total_seconds() is negative, will always return True (always 'fresh').",
            "    This effectively just disables this entire mechanism.",
            "",
            "    If \"fs_gexp\" is in the session and the current timestamp is less than that,",
            "    return True and extend grace time (i.e. set fs_gexp to current time + grace).",
            "",
            "    If not within the grace period, and within.total_seconds() is 0,",
            "    return False (not fresh).",
            "",
            "    Be aware that for this to work, sessions and therefore session cookies",
            "    must be functioning and being sent as part of the request. If the required",
            "    state isn't in the session cookie then return False (not 'fresh').",
            "",
            "    .. warning::",
            "        Be sure the caller is already authenticated PRIOR to calling this method.",
            "",
            "    .. versionadded:: 3.4.0",
            "",
            "    .. versionchanged:: 4.0.0",
            "        Added `method` parameter.",
            "    \"\"\"",
            "",
            "    if method == \"basic\":",
            "        return True",
            "",
            "    if within.total_seconds() < 0:",
            "        # this means 'always fresh'",
            "        return True",
            "",
            "    if \"fs_paa\" not in session:",
            "        # No session, you can't play.",
            "        return False",
            "",
            "    now = datetime.datetime.utcnow()",
            "    new_exp = now + grace",
            "    grace_ts = int(new_exp.timestamp())",
            "",
            "    fs_gexp = session.get(\"fs_gexp\", None)",
            "    if fs_gexp:",
            "        if now.timestamp() < fs_gexp:",
            "            # Within grace period - extend it and we're good.",
            "            session[\"fs_gexp\"] = grace_ts",
            "            return True",
            "",
            "    # Special case 0 - return False always, but set grace period.",
            "    if within.total_seconds() == 0:",
            "        session[\"fs_gexp\"] = grace_ts",
            "        return False",
            "",
            "    authn_time = datetime.datetime.utcfromtimestamp(session[\"fs_paa\"])",
            "    # allow for some time drift where it's possible authn_time is in the future",
            "    # but lets be cautious and not allow arbitrary future times",
            "    delta = now - authn_time",
            "    if within > delta > -within:",
            "        session[\"fs_gexp\"] = grace_ts",
            "        return True",
            "    return False",
            "",
            "",
            "def get_hmac(password):",
            "    \"\"\"Returns a Base64 encoded HMAC+SHA512 of the password signed with",
            "    the salt specified by *SECURITY_PASSWORD_SALT*.",
            "",
            "    :param password: The password to sign",
            "    \"\"\"",
            "    salt = _security.password_salt",
            "",
            "    if salt is None:",
            "        raise RuntimeError(",
            "            \"The configuration value `SECURITY_PASSWORD_SALT` must \"",
            "            \"not be None when the value of `SECURITY_PASSWORD_HASH` is \"",
            "            'set to \"%s\"' % _security.password_hash",
            "        )",
            "",
            "    h = hmac.new(encode_string(salt), encode_string(password), hashlib.sha512)",
            "    return base64.b64encode(h.digest())",
            "",
            "",
            "def verify_password(password, password_hash):",
            "    \"\"\"Returns ``True`` if the password matches the supplied hash.",
            "",
            "    :param password: A plaintext password to verify",
            "    :param password_hash: The expected hash value of the password",
            "                          (usually from your database)",
            "",
            "    .. note::",
            "        Make sure that the password passed in has already been normalized.",
            "    \"\"\"",
            "    if use_double_hash(password_hash):",
            "        password = get_hmac(password)",
            "",
            "    return _pwd_context.verify(password, password_hash)",
            "",
            "",
            "def verify_and_update_password(password, user):",
            "    \"\"\"Returns ``True`` if the password is valid for the specified user.",
            "",
            "    Additionally, the hashed password in the database is updated if the",
            "    hashing algorithm happens to have changed.",
            "",
            "    N.B. you MUST call DB commit if you are using a session-based datastore",
            "    (such as SqlAlchemy) since the user instance might have been altered",
            "    (i.e. ``app.security.datastore.commit()``).",
            "    This is usually handled in the view.",
            "",
            "    :param password: A plaintext password to verify",
            "    :param user: The user to verify against",
            "",
            "    .. tip::",
            "        This should not be called directly - rather use",
            "        :meth:`.UserMixin.verify_and_update_password`",
            "",
            "    \"\"\"",
            "    if use_double_hash(user.password):",
            "        verified = _pwd_context.verify(get_hmac(password), user.password)",
            "    else:",
            "        # Try with original password.",
            "        verified = _pwd_context.verify(password, user.password)",
            "",
            "    if verified and _pwd_context.needs_update(user.password):",
            "        user.password = hash_password(password)",
            "        _datastore.put(user)",
            "    return verified",
            "",
            "",
            "def encrypt_password(password):  # pragma: no cover",
            "    \"\"\"Encrypt the specified plaintext password.",
            "",
            "    It uses the configured encryption options.",
            "",
            "    .. deprecated:: 2.0.2",
            "       Use :func:`hash_password` instead.",
            "",
            "    :param password: The plaintext password to encrypt",
            "    \"\"\"",
            "    warnings.warn(",
            "        \"Please use hash_password instead of encrypt_password.\", DeprecationWarning",
            "    )",
            "    return hash_password(password)",
            "",
            "",
            "def hash_password(password):",
            "    \"\"\"Hash the specified plaintext password.",
            "",
            "    Unless the hash algorithm (as specified by `SECURITY_PASSWORD_HASH`) is listed in",
            "    the configuration variable `SECURITY_PASSWORD_SINGLE_HASH`,",
            "    perform a double hash - first create an HMAC from the plaintext password",
            "    and the value of `SECURITY_PASSWORD_SALT`,",
            "    then use the configured hashing algorithm.",
            "    This satisfies OWASP/ASVS section 2.4.5: 'provide additional",
            "    iteration of a key derivation'.",
            "",
            "    .. versionadded:: 2.0.2",
            "",
            "    :param password: The plaintext password to hash",
            "    \"\"\"",
            "    if use_double_hash():",
            "        password = get_hmac(password).decode(\"ascii\")",
            "",
            "    # Passing in options as part of hash is deprecated in passlib 1.7",
            "    # and new algorithms like argon2 don't even support it.",
            "    return _pwd_context.hash(",
            "        password,",
            "        **config_value(\"PASSWORD_HASH_OPTIONS\", default={}).get(",
            "            _security.password_hash, {}",
            "        ),",
            "    )",
            "",
            "",
            "def encode_string(string):",
            "    \"\"\"Encodes a string to bytes, if it isn't already.",
            "",
            "    :param string: The string to encode\"\"\"",
            "",
            "    if isinstance(string, str):",
            "        string = string.encode(\"utf-8\")",
            "    return string",
            "",
            "",
            "def hash_data(data):",
            "    return _hashing_context.hash(encode_string(data))",
            "",
            "",
            "def verify_hash(hashed_data, compare_data):",
            "    return _hashing_context.verify(encode_string(compare_data), hashed_data)",
            "",
            "",
            "def suppress_form_csrf():",
            "    \"\"\"",
            "    Return meta contents if we should suppress form from attempting to validate CSRF.",
            "",
            "    If app doesn't want CSRF for unauth endpoints then check if caller is authenticated",
            "    or not (many endpoints can be called either way).",
            "    \"\"\"",
            "    if get_request_attr(\"fs_ignore_csrf\"):",
            "        # This is the case where CsrfProtect was already called (e.g. @auth_required)",
            "        return {\"csrf\": False}",
            "    if (",
            "        config_value(\"CSRF_IGNORE_UNAUTH_ENDPOINTS\")",
            "        and not current_user.is_authenticated",
            "    ):",
            "        return {\"csrf\": False}",
            "    return {}",
            "",
            "",
            "def do_flash(message, category=None):",
            "    \"\"\"Flash a message depending on if the `FLASH_MESSAGES` configuration",
            "    value is set.",
            "",
            "    :param message: The flash message",
            "    :param category: The flash message category",
            "    \"\"\"",
            "    if config_value(\"FLASH_MESSAGES\"):",
            "        flash(message, category)",
            "",
            "",
            "def get_url(endpoint_or_url, qparams=None):",
            "    \"\"\"Returns a URL if a valid endpoint is found. Otherwise, returns the",
            "    provided value.",
            "",
            "    :param endpoint_or_url: The endpoint name or URL to default to",
            "    :param qparams: additional query params to add to end of url",
            "    :return: URL",
            "    \"\"\"",
            "    try:",
            "        return transform_url(url_for(endpoint_or_url), qparams)",
            "    except Exception:",
            "        # This is an external URL (no endpoint defined in app)",
            "        # For (mostly) testing - allow changing/adding the url - for example",
            "        # add a different host:port for cases where the UI is running",
            "        # separately.",
            "        if _security.redirect_host:",
            "            url = transform_url(",
            "                endpoint_or_url, qparams, netloc=_security.redirect_host",
            "            )",
            "        else:",
            "            url = transform_url(endpoint_or_url, qparams)",
            "",
            "        return url",
            "",
            "",
            "def slash_url_suffix(url, suffix):",
            "    \"\"\"Adds a slash either to the beginning or the end of a suffix",
            "    (which is to be appended to a URL), depending on whether or not",
            "    the URL ends with a slash.\"\"\"",
            "",
            "    return url.endswith(\"/\") and (\"%s/\" % suffix) or (\"/%s\" % suffix)",
            "",
            "",
            "def transform_url(url, qparams=None, **kwargs):",
            "    \"\"\"Modify url",
            "",
            "    :param url: url to transform (can be relative)",
            "    :param qparams: additional query params to add to end of url",
            "    :param kwargs: pieces of URL to modify - e.g. netloc=localhost:8000",
            "    :return: Modified URL",
            "",
            "    .. versionadded:: 3.2.0",
            "    \"\"\"",
            "    if not url:",
            "        return url",
            "    link_parse = urlsplit(url)",
            "    if qparams:",
            "        current_query = dict(parse_qsl(link_parse.query))",
            "        current_query.update(qparams)",
            "        link_parse = link_parse._replace(query=urlencode(current_query))",
            "    return urlunsplit(link_parse._replace(**kwargs))",
            "",
            "",
            "def get_security_endpoint_name(endpoint):",
            "    return f\"{_security.blueprint_name}.{endpoint}\"",
            "",
            "",
            "def url_for_security(endpoint, **values):",
            "    \"\"\"Return a URL for the security blueprint",
            "",
            "    :param endpoint: the endpoint of the URL (name of the function)",
            "    :param values: the variable arguments of the URL rule",
            "    :param _external: if set to `True`, an absolute URL is generated. Server",
            "      address can be changed via `SERVER_NAME` configuration variable which",
            "      defaults to `localhost`.",
            "    :param _anchor: if provided this is added as anchor to the URL.",
            "    :param _method: if provided this explicitly specifies an HTTP method.",
            "    \"\"\"",
            "    endpoint = get_security_endpoint_name(endpoint)",
            "    return url_for(endpoint, **values)",
            "",
            "",
            "def validate_redirect_url(url):",
            "    \"\"\"Validate that the URL for redirect is relative.",
            "    Allowing an absolute redirect is a security issue - a so-called open-redirect.",
            "    Note that by default Werkzeug will always take this URL and make it relative",
            "    when setting the Location header - but that behavior can be overridden.",
            "",
            "    The complexity here is that urlsplit() does pretty well, but browsers even today",
            "    May 2021 are very lenient in what they accept as URLs - for example:",
            "        next=\\\\\\\\github.com",
            "        next=%5C%5C%5Cgithub.com",
            "        next=/////github.com",
            "        next=%20\\\\\\\\github.com",
            "        next=%20///github.com",
            "        next=%20//github.com",
            "        next=%19////github.com - i.e. browser will strip control chars",
            "        next=%E2%80%8A///github.com - doesn't redirect! That is a unicode thin space.",
            "",
            "    All will result in a null netloc and scheme from urlsplit - however many browsers",
            "    will gladly strip off uninteresting characters and convert backslashes to forward",
            "    slashes - and the cases above will actually cause a redirect to github.com",
            "    Sigh.",
            "",
            "    Some articles claim that a relative url has to start with a '/' - but that isn't",
            "    strictly true. From: https://datatracker.ietf.org/doc/html/rfc3986#section-5",
            "    a relative path can start with a \"//\", \"/\", a non-colon, or be empty. So it seems",
            "    that all the above URLs are valid.",
            "    By the time we get the URL, it has been unencoded - so we can't really determine",
            "    if it is 'valid' since it appears that '/'s can appear in the URL if escaped.",
            "    \"\"\"",
            "    if url is None or url.strip() == \"\":",
            "        return False",
            "    url_next = urlsplit(url)",
            "    url_base = urlsplit(request.host_url)",
            "    if (url_next.netloc or url_next.scheme) and url_next.netloc != url_base.netloc:",
            "        base_domain = current_app.config.get(\"SERVER_NAME\")",
            "        if (",
            "            config_value(\"REDIRECT_ALLOW_SUBDOMAINS\")",
            "            and base_domain",
            "            and (",
            "                url_next.netloc == base_domain",
            "                or url_next.netloc.endswith(f\".{base_domain}\")",
            "            )",
            "        ):",
            "            return True",
            "        else:",
            "            return False",
            "    if config_value(\"REDIRECT_VALIDATE_MODE\") == \"regex\":",
            "        matcher = _security._redirect_validate_re.match(url)",
            "        return matcher is None",
            "    return True",
            "",
            "",
            "def get_post_action_redirect(config_key, declared=None):",
            "    urls = [",
            "        get_url(request.args.get(\"next\", None)),",
            "        get_url(request.form.get(\"next\", None)),",
            "        find_redirect(config_key),",
            "    ]",
            "    if declared:",
            "        urls.insert(0, declared)",
            "    for url in urls:",
            "        if validate_redirect_url(url):",
            "            return url",
            "",
            "",
            "def get_post_login_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_LOGIN_VIEW\", declared)",
            "",
            "",
            "def get_post_register_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_REGISTER_VIEW\", declared)",
            "",
            "",
            "def get_post_logout_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_LOGOUT_VIEW\", declared)",
            "",
            "",
            "def get_post_verify_redirect(declared=None):",
            "    return get_post_action_redirect(\"SECURITY_POST_VERIFY_VIEW\", declared)",
            "",
            "",
            "def find_redirect(key):",
            "    \"\"\"Returns the URL to redirect to after a user logs in successfully.",
            "",
            "    :param key: The session or application configuration key to search for",
            "    \"\"\"",
            "    rv = (",
            "        get_url(session.pop(key.lower(), None))",
            "        or get_url(current_app.config[key.upper()] or None)",
            "        or current_app.config.get(\"APPLICATION_ROOT\", \"/\")",
            "    )",
            "    return rv",
            "",
            "",
            "def propagate_next(url):",
            "    # return either URL or, if URL already has a ?next=xx, return that.",
            "    url_next = urlsplit(url)",
            "    qparams = parse_qs(url_next.query)",
            "    if \"next\" in qparams:",
            "        return qparams[\"next\"][0]",
            "    return url",
            "",
            "",
            "def get_config(app):",
            "    \"\"\"Conveniently get the security configuration for the specified",
            "    application without the annoying 'SECURITY_' prefix.",
            "",
            "    :param app: The application to inspect",
            "    \"\"\"",
            "    items = app.config.items()",
            "    prefix = \"SECURITY_\"",
            "",
            "    def strip_prefix(tup):",
            "        return tup[0].replace(\"SECURITY_\", \"\"), tup[1]",
            "",
            "    return dict([strip_prefix(i) for i in items if i[0].startswith(prefix)])",
            "",
            "",
            "def get_message(key, **kwargs):",
            "    rv = config_value(\"MSG_\" + key)",
            "    return localize_callback(rv[0], **kwargs), rv[1]",
            "",
            "",
            "def config_value(key, app=None, default=None):",
            "    \"\"\"Get a Flask-Security configuration value.",
            "",
            "    :param key: The configuration key without the prefix `SECURITY_`",
            "    :param app: An optional specific application to inspect. Defaults to",
            "                Flask's `current_app`",
            "    :param default: An optional default value if the value is not set",
            "    \"\"\"",
            "    app = app or current_app",
            "    # protect against spelling mistakes",
            "    config = get_config(app)",
            "    if key.upper() not in config:",
            "        raise ValueError(f\"Key {key} doesn't exist\")",
            "    return config.get(key.upper(), default)",
            "",
            "",
            "def get_max_age(key, app=None):",
            "    td = get_within_delta(key + \"_WITHIN\", app)",
            "    return td.seconds + td.days * 24 * 3600",
            "",
            "",
            "def get_within_delta(key, app=None):",
            "    \"\"\"Get a timedelta object from the application configuration following",
            "    the internal convention of::",
            "",
            "        <Amount of Units> <Type of Units>",
            "",
            "    Examples of valid config values::",
            "",
            "        5 days",
            "        10 minutes",
            "",
            "    :param key: The config value key without the `SECURITY_` prefix",
            "    :param app: Optional application to inspect. Defaults to Flask's",
            "                `current_app`",
            "    \"\"\"",
            "    txt = config_value(key, app=app)",
            "    values = txt.split()",
            "    return timedelta(**{values[1]: int(values[0])})",
            "",
            "",
            "def send_mail(subject, recipient, template, **context):",
            "    \"\"\"Send an email.",
            "",
            "    :param subject: Email subject",
            "    :param recipient: Email recipient",
            "    :param template: The name of the email template",
            "    :param context: The context to render the template with",
            "",
            "    This formats the email and passes it off to :class:`.MailUtil` to actually send the",
            "    message.",
            "    \"\"\"",
            "",
            "    context.setdefault(\"security\", _security)",
            "    context.update(_security._run_ctx_processor(\"mail\"))",
            "",
            "    body = None",
            "    html = None",
            "    ctx = (\"security/email\", template)",
            "    if config_value(\"EMAIL_PLAINTEXT\"):",
            "        body = _security.render_template(\"%s/%s.txt\" % ctx, **context)",
            "    if config_value(\"EMAIL_HTML\"):",
            "        html = _security.render_template(\"%s/%s.html\" % ctx, **context)",
            "",
            "    subject = localize_callback(subject)",
            "",
            "    sender = _security.email_sender",
            "    if isinstance(sender, LocalProxy):",
            "        sender = sender._get_current_object()",
            "",
            "    _security._mail_util.send_mail(",
            "        template, subject, recipient, str(sender), body, html, context.get(\"user\", None)",
            "    )",
            "",
            "",
            "def get_token_status(token, serializer, max_age=None, return_data=False):",
            "    \"\"\"Get the status of a token.",
            "",
            "    :param token: The token to check",
            "    :param serializer: The name of the serializer. Can be one of the",
            "                       following: ``confirm``, ``login``, ``reset``",
            "    :param max_age: The name of the max age config option. Can be one of",
            "                    the following: ``CONFIRM_EMAIL``, ``LOGIN``,",
            "                    ``RESET_PASSWORD``",
            "    \"\"\"",
            "    serializer = getattr(_security, serializer + \"_serializer\")",
            "    max_age = get_max_age(max_age)",
            "    user, data = None, None",
            "    expired, invalid = False, False",
            "",
            "    try:",
            "        data = serializer.loads(token, max_age=max_age)",
            "    except SignatureExpired:",
            "        d, data = serializer.loads_unsafe(token)",
            "        expired = True",
            "    except (BadSignature, TypeError, ValueError):",
            "        invalid = True",
            "",
            "    if data:",
            "        user = _datastore.find_user(fs_uniquifier=data[0])",
            "",
            "    expired = expired and (user is not None)",
            "",
            "    if return_data:",
            "        return expired, invalid, user, data",
            "    else:",
            "        return expired, invalid, user",
            "",
            "",
            "def check_and_get_token_status(token, serializer, within=None):",
            "    \"\"\"Get the status of a token and return data.",
            "",
            "    :param token: The token to check",
            "    :param serializer: The name of the serializer. Can be one of the",
            "                       following: ``confirm``, ``login``, ``reset``, ``us_setup``",
            "                       ``remember``, ``two_factor_validity``",
            "    :param within: max age - passed as a timedelta",
            "",
            "    :return: a tuple of (expired, invalid, data)",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "    serializer = getattr(_security, serializer + \"_serializer\")",
            "    max_age = within.total_seconds()",
            "    data = None",
            "    expired, invalid = False, False",
            "",
            "    try:",
            "        data = serializer.loads(token, max_age=max_age)",
            "    except SignatureExpired:",
            "        d, data = serializer.loads_unsafe(token)",
            "        expired = True",
            "    except (BadSignature, TypeError, ValueError):",
            "        invalid = True",
            "",
            "    return expired, invalid, data",
            "",
            "",
            "def get_identity_attributes(app=None) -> List:",
            "    # Return list of keys of identity attributes",
            "    # Is it possible to not have any?",
            "    app = app or current_app",
            "    iattrs = app.config[\"SECURITY_USER_IDENTITY_ATTRIBUTES\"]",
            "    if iattrs:",
            "        return [[*f][0] for f in iattrs]",
            "    return []",
            "",
            "",
            "def get_identity_attribute(attr, app=None) -> Dict:",
            "    \"\"\"Given an user_identity_attribute, return the defining dict.",
            "    A bit annoying since USER_IDENTITY_ATTRIBUTES is a list of dict",
            "    where each dict has just one key.",
            "    \"\"\"",
            "    app = app or current_app",
            "    iattrs = app.config[\"SECURITY_USER_IDENTITY_ATTRIBUTES\"]",
            "    if iattrs:",
            "        details = [",
            "            mapping[attr] for mapping in iattrs if list(mapping.keys())[0] == attr",
            "        ]",
            "        if details:",
            "            return details[0]",
            "    return {}",
            "",
            "",
            "def find_user(identity):",
            "    \"\"\"",
            "    Validate identity - we go in order to figure out which user attribute the",
            "    request gave us. Note that we give up on the first 'match' even if that",
            "    doesn't yield a user. Why?",
            "    \"\"\"",
            "    for mapping in config_value(\"USER_IDENTITY_ATTRIBUTES\"):",
            "        attr = list(mapping.keys())[0]",
            "        details = mapping[attr]",
            "        idata = details[\"mapper\"](identity)",
            "        if idata:",
            "            user = _datastore.find_user(",
            "                case_insensitive=details.get(\"case_insensitive\", False), **{attr: idata}",
            "            )",
            "            return user",
            "    return None",
            "",
            "",
            "def uia_phone_mapper(identity):",
            "    \"\"\"Used to match identity as a phone number. This is a simple proxy",
            "    to :py:class:`PhoneUtil`",
            "",
            "    See :py:data:`SECURITY_USER_IDENTITY_ATTRIBUTES`.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "    ph = _security._phone_util.get_canonical_form(identity)",
            "    return ph",
            "",
            "",
            "def uia_email_mapper(identity):",
            "    \"\"\"Used to match identity as an email.",
            "",
            "    See :py:data:`SECURITY_USER_IDENTITY_ATTRIBUTES`.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "",
            "    try:",
            "        return _security._mail_util.normalize(identity)",
            "    except ValueError:",
            "        return None",
            "",
            "",
            "def use_double_hash(password_hash=None):",
            "    \"\"\"Return a bool indicating whether a password should be hashed twice.\"\"\"",
            "    # Default to plaintext for backward compatibility with",
            "    # SECURITY_PASSWORD_SINGLE_HASH = False",
            "    single_hash = config_value(\"PASSWORD_SINGLE_HASH\") or {\"plaintext\"}",
            "",
            "    if password_hash is None:",
            "        scheme = _security.password_hash",
            "    else:",
            "        scheme = _pwd_context.identify(password_hash)",
            "",
            "    return not (single_hash is True or scheme in single_hash)",
            "",
            "",
            "def csrf_cookie_handler(response):",
            "    \"\"\"Called at end of every request.",
            "    Uses session to track state (set/clear)",
            "",
            "    Ideally we just need to set this once - however by default",
            "    Flask-WTF has a time-out on these tokens governed by *WTF_CSRF_TIME_LIMIT*.",
            "    While we could set that to None - and OWASP implies this is fine - that might",
            "    not be agreeable to everyone.",
            "    So as a basic usability hack - we check if it is expired and re-generate so at least",
            "    the user doesn't have to log out and back in (just refresh).",
            "    We also support a *CSRF_COOKIE_REFRESH_EACH_REQUEST* analogous to Flask's",
            "    *SESSION_REFRESH_EACH_REQUEST*",
            "",
            "    It is of course removed on logout/session end.",
            "    Other info on web suggests replacing on every POST and accepting up to 'age' ago.",
            "    \"\"\"",
            "    csrf_cookie = config_value(\"CSRF_COOKIE\")",
            "    if not csrf_cookie or not csrf_cookie[\"key\"]:",
            "        return response",
            "",
            "    op = session.get(\"fs_cc\", None)",
            "    if not op:",
            "        remember_cookie_name = current_app.config.get(",
            "            \"REMEMBER_COOKIE_NAME\", REMEMBER_COOKIE_NAME",
            "        )",
            "        has_remember_cookie = (",
            "            remember_cookie_name in request.cookies",
            "            and session.get(\"remember\") != \"clear\"",
            "        )",
            "        # Set cookie if successfully logged in with flask_login's remember cookie",
            "        if has_remember_cookie and current_user.is_authenticated:",
            "            op = \"set\"",
            "        else:",
            "            return response",
            "",
            "    if op == \"clear\":",
            "        response.delete_cookie(",
            "            csrf_cookie[\"key\"],",
            "            path=csrf_cookie.get(\"path\", \"/\"),",
            "            domain=csrf_cookie.get(\"domain\", None),",
            "        )",
            "        session.pop(\"fs_cc\")",
            "        return response",
            "",
            "    # Send a cookie if any of:",
            "    # 1) CSRF_COOKIE_REFRESH_EACH_REQUEST is true",
            "    # 2) fs_cc == \"set\" - this is on first login",
            "    # 3) existing cookie has expired",
            "    send = False",
            "    if op == \"set\":",
            "        send = True",
            "        session[\"fs_cc\"] = \"sent\"",
            "    elif config_value(\"CSRF_COOKIE_REFRESH_EACH_REQUEST\"):",
            "        send = True",
            "    elif current_app.config[\"WTF_CSRF_TIME_LIMIT\"]:",
            "        current_cookie = request.cookies.get(csrf_cookie[\"key\"], None)",
            "        if current_cookie:",
            "            # Lets make sure it isn't expired if app doesn't set TIME_LIMIT to None.",
            "            try:",
            "                csrf.validate_csrf(current_cookie)",
            "            except ValidationError:",
            "                send = True",
            "",
            "    if send:",
            "        kwargs = {k: v for k, v in csrf_cookie.items()}",
            "        kwargs.pop(\"key\")",
            "        kwargs[\"value\"] = csrf.generate_csrf()",
            "        response.set_cookie(csrf_cookie[\"key\"], **kwargs)",
            "    return response",
            "",
            "",
            "def base_render_json(",
            "    form,",
            "    include_user=True,",
            "    include_auth_token=False,",
            "    additional=None,",
            "    error_status_code=400,",
            "):",
            "    \"\"\"",
            "    This method is called by all views that return JSON responses.",
            "    This fills in the response and then calls :meth:`.Security.render_json`",
            "    which can be overridden by the app.",
            "    \"\"\"",
            "    has_errors = len(form.errors) > 0",
            "",
            "    user = form.user if hasattr(form, \"user\") else None",
            "    if has_errors:",
            "        code = error_status_code",
            "        payload = json_error_response(errors=form.errors)",
            "    else:",
            "        code = 200",
            "        payload = dict()",
            "        if user:",
            "            # This allows anonymous GETs via JSON",
            "            if include_user:",
            "                payload[\"user\"] = user.get_security_payload()",
            "",
            "            if include_auth_token:",
            "                # view willing to return auth_token - check behavior config",
            "                if (",
            "                    config_value(\"BACKWARDS_COMPAT_AUTH_TOKEN\")",
            "                    or \"include_auth_token\" in request.args",
            "                ):",
            "                    try:",
            "                        token = user.get_auth_token()",
            "                    except ValueError:",
            "                        # application has fs_token_uniquifier attribute but it",
            "                        # hasn't been initialized. Since we are in a request context",
            "                        # we can do that here.",
            "                        _datastore.set_token_uniquifier(user)",
            "                        after_this_request(view_commit)",
            "                        token = user.get_auth_token()",
            "                    payload[\"user\"][\"authentication_token\"] = token",
            "",
            "        # Return csrf_token on each JSON response - just as every form",
            "        # has it rendered.",
            "        payload[\"csrf_token\"] = csrf.generate_csrf()",
            "        if additional:",
            "            payload.update(additional)",
            "",
            "    return _security._render_json(payload, code, headers=None, user=user)",
            "",
            "",
            "def default_want_json(req):",
            "    \"\"\"Return True if response should be in json",
            "    N.B. do not call this directly - use security.want_json()",
            "",
            "    :param req: Flask/Werkzeug Request",
            "    \"\"\"",
            "    if req.is_json:",
            "        return True",
            "    # TODO should this handle json sub-types?",
            "    accept_mimetypes = req.accept_mimetypes",
            "    if not hasattr(req.accept_mimetypes, \"best\"):  # pragma: no cover",
            "        # Alright. we dont have the best property, lets add it ourselves.",
            "        # This is for quart compatibility",
            "        accept_mimetypes.best = best",
            "    if accept_mimetypes.best == \"application/json\":",
            "        return True",
            "    return False",
            "",
            "",
            "def json_error_response(errors):",
            "    \"\"\"Helper to create an error response that adheres to the openapi spec.\"\"\"",
            "    if isinstance(errors, str):",
            "        # When the errors is a string, use the response/error/message format",
            "        response_json = dict(error=errors)",
            "    elif isinstance(errors, dict):",
            "        # When the errors is a dict, use the DefaultJsonErrorResponse",
            "        # (response/errors/name/messages) format",
            "        response_json = dict(errors=errors)",
            "    else:",
            "        raise TypeError(\"The errors argument should be either a str or dict.\")",
            "",
            "    return response_json",
            "",
            "",
            "class FsJsonEncoder(JSONEncoder):",
            "    \"\"\"Flask-Security JSON encoder.",
            "    Extends Flask's JSONencoder to handle lazy-text.",
            "",
            "    .. versionadded:: 3.3.0",
            "    \"\"\"",
            "",
            "    def default(self, obj):",
            "        from .babel import is_lazy_string",
            "",
            "        if is_lazy_string(obj):",
            "            return str(obj)",
            "        else:",
            "            return JSONEncoder.default(self, obj)",
            "",
            "",
            "class SmsSenderBaseClass(metaclass=abc.ABCMeta):",
            "    def __init__(self):",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def send_sms(self, from_number, to_number, msg):  # pragma: no cover",
            "        \"\"\"Abstract method for sending sms messages",
            "",
            "        .. versionadded:: 3.2.0",
            "        \"\"\"",
            "        return",
            "",
            "",
            "class DummySmsSender(SmsSenderBaseClass):",
            "    def send_sms(self, from_number, to_number, msg):  # pragma: no cover",
            "        \"\"\"Do nothing.\"\"\"",
            "        return",
            "",
            "",
            "class SmsSenderFactory:",
            "    senders = {\"Dummy\": DummySmsSender}",
            "",
            "    @classmethod",
            "    def createSender(cls, name, *args, **kwargs):",
            "        \"\"\"Initialize an SMS sender.",
            "",
            "        :param name: Name as registered in SmsSenderFactory:senders (e.g. 'Twilio')",
            "",
            "        .. versionadded:: 3.2.0",
            "        \"\"\"",
            "        return cls.senders[name](*args, **kwargs)",
            "",
            "",
            "try:  # pragma: no cover",
            "    from twilio.rest import Client",
            "",
            "    class TwilioSmsSender(SmsSenderBaseClass):",
            "        def __init__(self):",
            "            self.account_sid = config_value(\"SMS_SERVICE_CONFIG\")[\"ACCOUNT_SID\"]",
            "            self.auth_token = config_value(\"SMS_SERVICE_CONFIG\")[\"AUTH_TOKEN\"]",
            "",
            "        def send_sms(self, from_number, to_number, msg):",
            "            \"\"\"Send message via twilio account.\"\"\"",
            "            client = Client(self.account_sid, self.auth_token)",
            "            client.messages.create(to=to_number, from_=from_number, body=msg)",
            "",
            "    SmsSenderFactory.senders[\"Twilio\"] = TwilioSmsSender",
            "except Exception:",
            "    pass",
            "",
            "",
            "def password_length_validator(password):",
            "    \"\"\"Test password for length.",
            "",
            "    :param password: Plain text password to check",
            "",
            "    :return: ``None`` if password conforms to length requirements,",
            "     a list of error/suggestions if not.",
            "",
            "    .. versionadded:: 3.4.0",
            "",
            "    \"\"\"",
            "    if len(password) < config_value(\"PASSWORD_LENGTH_MIN\") or len(password) > 128:",
            "        return [",
            "            get_message(",
            "                \"PASSWORD_INVALID_LENGTH\", length=config_value(\"PASSWORD_LENGTH_MIN\")",
            "            )[0]",
            "        ]",
            "    return None",
            "",
            "",
            "def password_complexity_validator(password, is_register, **kwargs):",
            "    \"\"\"Test password for complexity.",
            "",
            "    Currently just supports 'zxcvbn'.",
            "",
            "    :param password: Plain text password to check",
            "    :param is_register: if True then kwargs are arbitrary additional info. (e.g.",
            "        info from a registration form). If False, must be a SINGLE key \"user\" that",
            "        corresponds to the current_user. All string values will be extracted and",
            "        sent to the complexity checker.",
            "    :param kwargs:",
            "",
            "    :return: ``None`` if password is complex enough, a list of error/suggestions if not.",
            "        Be aware that zxcvbn does not (easily) provide a way to localize messages.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "",
            "    if config_value(\"PASSWORD_COMPLEXITY_CHECKER\") == \"zxcvbn\":",
            "        import zxcvbn",
            "",
            "        user_info = []",
            "        if not is_register:",
            "            for v in kwargs[\"user\"].__dict__.values():",
            "                if v and isinstance(v, str):",
            "                    user_info.append(v)",
            "        else:",
            "            # This is usually all register form values that are in the user_model",
            "            if kwargs:",
            "                user_info = kwargs.values()",
            "        results = zxcvbn.zxcvbn(password, user_inputs=user_info)",
            "        if results[\"score\"] > 2:",
            "            # Good or Strong",
            "            return None",
            "        # Should we return suggestions? Default forms don't really know what to do.",
            "        if results[\"feedback\"][\"warning\"]:",
            "            # Note that these come from zxcvbn and",
            "            # aren't localizable via Flask-Security",
            "            return [results[\"feedback\"][\"warning\"]]",
            "        return [get_message(\"PASSWORD_TOO_SIMPLE\")[0]]",
            "    else:",
            "        return None",
            "",
            "",
            "def password_breached_validator(password):",
            "    \"\"\"Check if password on breached list.",
            "    Does nothing unless :py:data:`SECURITY_PASSWORD_CHECK_BREACHED` is set.",
            "    If password is found on the breached list, return an error if the count is",
            "    greater than or equal to :py:data:`SECURITY_PASSWORD_BREACHED_COUNT`.",
            "    Uses :meth:`pwned`.",
            "",
            "    :param password: Plain text password to check",
            "",
            "    :return: ``None`` if password passes breached tests, else a list of error messages.",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "    pwn = config_value(\"PASSWORD_CHECK_BREACHED\")",
            "    if pwn:",
            "        try:",
            "            cnt = pwned(password)",
            "            if cnt >= config_value(\"PASSWORD_BREACHED_COUNT\"):",
            "                return [get_message(\"PASSWORD_BREACHED\")[0]]",
            "        except Exception:",
            "            if pwn == \"strict\":",
            "                return [get_message(\"PASSWORD_BREACHED_SITE_ERROR\")[0]]",
            "    return None",
            "",
            "",
            "def pwned(password):",
            "    \"\"\"",
            "    Check password against pwnedpasswords API using k-Anonymity.",
            "    https://haveibeenpwned.com/API/v3",
            "",
            "    :return: Count of password in DB (0 means hasn't been compromised)",
            "",
            "    Can raise HTTPError",
            "",
            "    .. versionadded:: 3.4.0",
            "    \"\"\"",
            "",
            "    def convert_password_tuple(value):",
            "        hash_suffix, count = value.split(\":\")",
            "        return hash_suffix, int(count)",
            "",
            "    sha1 = hashlib.sha1(password.encode(\"utf8\")).hexdigest()",
            "",
            "    req = urllib.request.Request(",
            "        url=f\"https://api.pwnedpasswords.com/range/{sha1[:5].upper()}\",",
            "        headers={\"User-Agent\": \"Flask-Security (Python)\"},",
            "    )",
            "    # Might raise HTTPError",
            "    with urllib.request.urlopen(req) as f:",
            "        response = f.read()",
            "",
            "    raw = response.decode(\"utf-8-sig\")",
            "",
            "    entries = dict(map(convert_password_tuple, raw.upper().split(\"\\r\\n\")))",
            "    return entries.get(sha1[5:].upper(), 0)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "flask_security.core",
            "flask_security.utils.get_post_action_redirect"
        ]
    }
}