{
    "src/Products/PageTemplates/Expressions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import OFS.interfaces"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from AccessControl import safe_builtins"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from AccessControl.SecurityManagement import getSecurityManager"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from Acquisition import aq_base"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from MultiMapping import MultiMapping"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from zExceptions import NotFound"
            },
            "7": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     necessary (bobo-awareness)."
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     request = getattr(econtext, 'request', None)"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    validate = getSecurityManager().validate"
            },
            "11": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     path_items = list(path_items)"
            },
            "12": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     path_items.reverse()"
            },
            "13": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     while path_items:"
            },
            "15": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         name = path_items.pop()"
            },
            "16": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if name == '_':"
            },
            "18": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            warnings.warn('Traversing to the name `_` is deprecated '"
            },
            "19": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                          'and will be removed in Zope 6.',"
            },
            "20": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                          DeprecationWarning)"
            },
            "21": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif name.startswith('_'):"
            },
            "22": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise NotFound(name)"
            },
            "23": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "24": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         if OFS.interfaces.ITraversable.providedBy(object):"
            },
            "25": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             object = object.restrictedTraverse(name)"
            },
            "26": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         else:"
            },
            "27": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            object = traversePathElement(object, name, path_items,"
            },
            "28": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                         request=request)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            found = traversePathElement(object, name, path_items,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                                        request=request)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            # Special backwards compatibility exception for the name ``_``,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            # which was often used for translation message factories."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            # Allow and continue traversal."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+            if name == '_':"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+                warnings.warn('Traversing to the name `_` is deprecated '"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                              'and will be removed in Zope 6.',"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                              DeprecationWarning)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                object = found"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                continue"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            # All other names starting with ``_`` are disallowed."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            # This emulates what restrictedTraverse does."
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            if name.startswith('_'):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                raise NotFound(name)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            # traversePathElement doesn't apply any Zope security policy,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            # so we validate access explicitly here."
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            try:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+                validate(object, object, name, found)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                object = found"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            except Unauthorized:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+                # Convert Unauthorized to prevent information disclosures"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                raise NotFound(name)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     return object"
            },
            "57": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Page Template Expression Engine",
            "",
            "Page Template-specific implementation of TALES, with handlers",
            "for Python expressions, string literals, and paths.",
            "\"\"\"",
            "",
            "import logging",
            "import warnings",
            "",
            "import OFS.interfaces",
            "from AccessControl import safe_builtins",
            "from Acquisition import aq_base",
            "from MultiMapping import MultiMapping",
            "from zExceptions import NotFound",
            "from zExceptions import Unauthorized",
            "from zope.component import queryUtility",
            "from zope.contentprovider.tales import TALESProviderExpression",
            "from zope.i18n import translate",
            "from zope.interface import implementer",
            "from zope.pagetemplate.engine import ZopeEngine as Z3Engine",
            "from zope.proxy import removeAllProxies",
            "from zope.tales.expressions import DeferExpr",
            "from zope.tales.expressions import LazyExpr",
            "from zope.tales.expressions import NotExpr",
            "from zope.tales.expressions import PathExpr",
            "from zope.tales.expressions import StringExpr",
            "from zope.tales.expressions import SubPathExpr",
            "from zope.tales.expressions import Undefs",
            "from zope.tales.pythonexpr import PythonExpr",
            "from zope.tales.tales import Context",
            "from zope.tales.tales import ErrorInfo as BaseErrorInfo",
            "from zope.tales.tales import Iterator",
            "from zope.traversing.adapters import traversePathElement",
            "from zope.traversing.interfaces import ITraversable",
            "",
            "from . import ZRPythonExpr",
            "from .interfaces import IUnicodeEncodingConflictResolver",
            "from .interfaces import IZopeAwareEngine",
            "",
            "",
            "SecureModuleImporter = ZRPythonExpr._SecureModuleImporter()",
            "",
            "LOG = logging.getLogger('Expressions')",
            "",
            "# In Zope 2 traversal semantics, NotFound or Unauthorized (the Zope 2",
            "# versions) indicate that traversal has failed.  By default, zope.tales'",
            "# engine doesn't recognize them as such which is why we extend its",
            "# list here and make sure our implementation of the TALES",
            "# Path Expression uses them",
            "ZopeUndefs = Undefs + (NotFound, Unauthorized)",
            "",
            "",
            "def boboAwareZopeTraverse(object, path_items, econtext):",
            "    \"\"\"Traverses a sequence of names, first trying attributes then items.",
            "",
            "    This uses zope.traversing path traversal where possible and interacts",
            "    correctly with objects providing OFS.interface.ITraversable when",
            "    necessary (bobo-awareness).",
            "    \"\"\"",
            "    request = getattr(econtext, 'request', None)",
            "    path_items = list(path_items)",
            "    path_items.reverse()",
            "",
            "    while path_items:",
            "        name = path_items.pop()",
            "",
            "        if name == '_':",
            "            warnings.warn('Traversing to the name `_` is deprecated '",
            "                          'and will be removed in Zope 6.',",
            "                          DeprecationWarning)",
            "        elif name.startswith('_'):",
            "            raise NotFound(name)",
            "",
            "        if OFS.interfaces.ITraversable.providedBy(object):",
            "            object = object.restrictedTraverse(name)",
            "        else:",
            "            object = traversePathElement(object, name, path_items,",
            "                                         request=request)",
            "    return object",
            "",
            "",
            "def trustedBoboAwareZopeTraverse(object, path_items, econtext):",
            "    \"\"\"Traverses a sequence of names, first trying attributes then items.",
            "",
            "    This uses zope.traversing path traversal where possible and interacts",
            "    correctly with objects providing OFS.interface.ITraversable when",
            "    necessary (bobo-awareness).",
            "    \"\"\"",
            "    request = getattr(econtext, 'request', None)",
            "    path_items = list(path_items)",
            "    path_items.reverse()",
            "",
            "    while path_items:",
            "        name = path_items.pop()",
            "        if OFS.interfaces.ITraversable.providedBy(object):",
            "            object = object.unrestrictedTraverse(name)",
            "        else:",
            "            object = traversePathElement(object, name, path_items,",
            "                                         request=request)",
            "    return object",
            "",
            "",
            "def render(ob, ns):",
            "    \"\"\"Calls the object, possibly a document template, or just returns",
            "    it if not callable.  (From DT_Util.py)",
            "    \"\"\"",
            "    if hasattr(ob, '__render_with_namespace__'):",
            "        ob = ZRPythonExpr.call_with_ns(ob.__render_with_namespace__, ns)",
            "    else:",
            "        # items might be acquisition wrapped",
            "        base = aq_base(ob)",
            "        # item might be proxied (e.g. modules might have a deprecation",
            "        # proxy)",
            "        base = removeAllProxies(base)",
            "        if callable(base):",
            "            try:",
            "                if getattr(base, 'isDocTemp', 0):",
            "                    ob = ZRPythonExpr.call_with_ns(ob, ns, 2)",
            "                else:",
            "                    ob = ob()",
            "            except NotImplementedError:",
            "                pass",
            "    return ob",
            "",
            "",
            "class _CombinedMapping:",
            "    \"\"\"Minimal auxiliary class to combine several mappings.",
            "",
            "    Earlier mappings take precedence.",
            "    \"\"\"",
            "    def __init__(self, *ms):",
            "        self.mappings = ms",
            "",
            "    def get(self, key, default):",
            "        for m in self.mappings:",
            "            value = m.get(key, self)",
            "            if value is not self:",
            "                return value",
            "        return default",
            "",
            "",
            "class UntrustedSubPathExpr(SubPathExpr):",
            "    ALLOWED_BUILTINS = safe_builtins",
            "",
            "",
            "class TrustedSubPathExpr(SubPathExpr):",
            "    # we allow both Python's builtins (we are trusted)",
            "    # as well as ``safe_builtins`` (because it may contain extensions)",
            "    # Python's builtins take precedence, because those of",
            "    # ``safe_builtins`` may have special restrictions for",
            "    # the use in an untrusted context",
            "    ALLOWED_BUILTINS = _CombinedMapping(",
            "        __builtins__,",
            "        safe_builtins)",
            "",
            "",
            "class ZopePathExpr(PathExpr):",
            "",
            "    _TRAVERSER = staticmethod(boboAwareZopeTraverse)",
            "    SUBEXPR_FACTORY = UntrustedSubPathExpr",
            "",
            "    def __init__(self, name, expr, engine):",
            "        if not expr.strip():",
            "            expr = 'nothing'",
            "        super().__init__(name, expr, engine, self._TRAVERSER)",
            "",
            "    # override this to support different call metrics (see bottom of",
            "    # method) and Zope 2's traversal exceptions (ZopeUndefs instead of",
            "    # Undefs)",
            "    def _eval(self, econtext):",
            "        for expr in self._subexprs[:-1]:",
            "            # Try all but the last subexpression, skipping undefined ones.",
            "            try:",
            "                ob = expr(econtext)",
            "            except ZopeUndefs:  # use Zope 2 expression types",
            "                pass",
            "            else:",
            "                break",
            "        else:",
            "            # On the last subexpression allow exceptions through.",
            "            ob = self._subexprs[-1](econtext)",
            "            if self._hybrid:",
            "                return ob",
            "",
            "        if self._name == 'nocall':",
            "            return ob",
            "",
            "        # this is where we are different from our super class:",
            "        return render(ob, econtext.vars)",
            "",
            "    # override this to support Zope 2's traversal exceptions",
            "    # (ZopeUndefs instead of Undefs)",
            "    def _exists(self, econtext):",
            "        for expr in self._subexprs:",
            "            try:",
            "                expr(econtext)",
            "            except ZopeUndefs:  # use Zope 2 expression types",
            "                pass",
            "            else:",
            "                return 1",
            "        return 0",
            "",
            "",
            "class TrustedZopePathExpr(ZopePathExpr):",
            "    _TRAVERSER = staticmethod(trustedBoboAwareZopeTraverse)",
            "    SUBEXPR_FACTORY = TrustedSubPathExpr",
            "",
            "",
            "class SafeMapping(MultiMapping):",
            "    \"\"\"Mapping with security declarations and limited method exposure.",
            "",
            "    Since it subclasses MultiMapping, this class can be used to wrap",
            "    one or more mapping objects.  Restricted Python code will not be",
            "    able to mutate the SafeMapping or the wrapped mappings, but will be",
            "    able to read any value.",
            "    \"\"\"",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "    push = pop = None",
            "",
            "    _push = MultiMapping.push",
            "    _pop = MultiMapping.pop",
            "",
            "",
            "class ZopeContext(Context):",
            "",
            "    def __init__(self, engine, contexts):",
            "        super().__init__(engine, contexts)",
            "        # wrap the top-level 'repeat' variable, as it is visible to",
            "        # restricted code",
            "        self.setContext('repeat', SafeMapping(self.repeat_vars))",
            "        # regenerate the first scope and the scope stack after messing",
            "        # with the global context",
            "        self.vars = vars = contexts.copy()",
            "        self._vars_stack = [vars]",
            "",
            "    def translate(self, msgid, domain=None, mapping=None, default=None):",
            "        context = self.contexts.get('request')",
            "        return translate(",
            "            msgid, domain=domain, mapping=mapping,",
            "            context=context, default=default)",
            "",
            "    def evaluateBoolean(self, expr):",
            "        value = self.evaluate(expr)",
            "        # here we override the normal zope.tales behaviour. zope.tales",
            "        # doesn't care about the default in a boolean expression,",
            "        # while we do (Zope 2 legacy, see the",
            "        # BooleanAttributesAndDefault.html test case)",
            "        if value is self.getDefault():",
            "            return value",
            "        return bool(value)",
            "",
            "    def evaluateStructure(self, expr):",
            "        \"\"\" customized version in order to get rid of unicode",
            "            errors for all and ever",
            "        \"\"\"",
            "        text = super().evaluateStructure(expr)",
            "        return self._handleText(text, expr)",
            "",
            "    def evaluateText(self, expr):",
            "        \"\"\" customized version in order to get rid of unicode",
            "            errors for all and ever",
            "        \"\"\"",
            "        text = self.evaluate(expr)",
            "        return self._handleText(text, expr)",
            "",
            "    def _handleText(self, text, expr):",
            "",
            "        if text is self.getDefault() or text is None:",
            "            # XXX: should be unicode???",
            "            return text",
            "",
            "        if isinstance(text, str):",
            "            # we love unicode, nothing to do",
            "            return text",
            "",
            "        elif isinstance(text, bytes):",
            "            # bahh...non-unicode string..we need to convert it to unicode",
            "",
            "            # catch ComponentLookupError in order to make tests shut-up.",
            "            # This should not be a problem since it won't change the old",
            "            # default behavior",
            "",
            "            resolver = queryUtility(IUnicodeEncodingConflictResolver)",
            "            if resolver is None:",
            "                return text.decode('ascii')",
            "",
            "            try:",
            "                return resolver.resolve(",
            "                    self.contexts.get('context'), text, expr)",
            "            except UnicodeDecodeError as e:",
            "                LOG.error(\"UnicodeDecodeError detected for expression \\\"%s\\\"\\n\"",
            "                          \"Resolver class: %s\\n\"",
            "                          \"Exception text: %s\\n\"",
            "                          \"Template: %s\\n\"",
            "                          \"Rendered text: %r\" %",
            "                          (expr, resolver.__class__, e,",
            "                           self.contexts['template'].absolute_url(1), text))",
            "                raise",
            "        else:",
            "            # This is a weird culprit ...calling text_type() on non-string",
            "            # objects",
            "            return str(text)",
            "",
            "    def createErrorInfo(self, err, position):",
            "        # Override, returning an object accessible to untrusted code.",
            "        # See: https://bugs.launchpad.net/zope2/+bug/174705",
            "        return ErrorInfo(err, position)",
            "",
            "    def evaluateCode(self, lang, code):",
            "        \"\"\" See ITALExpressionEngine.",
            "",
            "        o This method is a fossil:  nobody actually calls it, but the",
            "          interface requires it.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class ErrorInfo(BaseErrorInfo):",
            "    \"\"\"Information about an exception passed to an on-error handler.",
            "    \"\"\"",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "",
            "",
            "# Whether an engine is Zope aware does not depend on the class",
            "# but how it is configured - especially, that is uses a Zope aware",
            "# `PathExpr` implementation.",
            "# Nevertheless, we mark the class as \"Zope aware\" for simplicity",
            "# assuming that users of the class use a proper `PathExpr`",
            "@implementer(IZopeAwareEngine)",
            "class ZopeEngine(Z3Engine):",
            "",
            "    _create_context = ZopeContext",
            "",
            "",
            "class ZopeIterator(Iterator):",
            "",
            "    # allow iterator API to be accessed from (restricted) Python TALES",
            "    # expressions",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "",
            "    # The things below used to be attributes in",
            "    # ZTUtils.Iterator.Iterator, however in zope.tales.tales.Iterator",
            "    # they're methods.  We need BBB on the Python level so we redefine",
            "    # them as properties here.  Eventually, we would like to get rid",
            "    # of them, though, so that we won't have to maintain yet another",
            "    # iterator class somewhere.",
            "",
            "    @property",
            "    def index(self):",
            "        return super().index()",
            "",
            "    @property",
            "    def start(self):",
            "        return super().start()",
            "",
            "    @property",
            "    def end(self):",
            "        return super().end()",
            "",
            "    @property",
            "    def item(self):",
            "        return super().item()",
            "",
            "    # 'first' and 'last' are Zope 2 enhancements to the TALES iterator",
            "    # spec.",
            "    def first(self, name=None):",
            "        if self.start:",
            "            return True",
            "        return not self.same_part(name, self._last_item, self.item)",
            "",
            "    def last(self, name=None):",
            "        if self.end:",
            "            return True",
            "        return not self.same_part(name, self.item, self._next)",
            "",
            "    def same_part(self, name, ob1, ob2):",
            "        if name is None:",
            "            return ob1 == ob2",
            "        no = object()",
            "        return getattr(ob1, name, no) == getattr(ob2, name, no) is not no",
            "",
            "    # 'first' needs to have access to the last item in the loop",
            "    def __next__(self):",
            "        if self._nextIndex > 0:",
            "            self._last_item = self.item",
            "        return super().__next__()",
            "",
            "    def next(self):",
            "        if self._nextIndex > 0:",
            "            self._last_item = self.item",
            "        return super().next()",
            "",
            "",
            "@implementer(ITraversable)",
            "class PathIterator(ZopeIterator):",
            "    \"\"\"A TALES Iterator with the ability to use first() and last() on",
            "    subpaths of elements.\"\"\"",
            "",
            "    def traverse(self, name, furtherPath):",
            "        if name in ('first', 'last'):",
            "            method = getattr(self, name)",
            "            # it's important that 'name' becomes a copy because we'll",
            "            # clear out 'furtherPath'",
            "            name = furtherPath[:]",
            "            if not name:",
            "                name = None",
            "            # make sure that traversal ends here with us",
            "            furtherPath[:] = []",
            "            return method(name)",
            "        return getattr(self, name)",
            "",
            "    def same_part(self, name, ob1, ob2):",
            "        if name is None:",
            "            return ob1 == ob2",
            "        if isinstance(name, str):",
            "            name = name.split('/')",
            "        elif isinstance(name, bytes):",
            "            name = name.split(b'/')",
            "        try:",
            "            ob1 = boboAwareZopeTraverse(ob1, name, None)",
            "            ob2 = boboAwareZopeTraverse(ob2, name, None)",
            "        except ZopeUndefs:",
            "            return False",
            "        return ob1 == ob2",
            "",
            "",
            "class UnicodeAwareStringExpr(StringExpr):",
            "",
            "    def __call__(self, econtext):",
            "        vvals = []",
            "        if isinstance(self._expr, str):",
            "            # coerce values through the Unicode Conflict Resolver",
            "            evaluate = econtext.evaluateText",
            "        else:",
            "            evaluate = econtext.evaluate",
            "        for var in self._vars:",
            "            v = evaluate(var)",
            "            vvals.append(v)",
            "        return self._expr % tuple(vvals)",
            "",
            "",
            "def createZopeEngine(zpe=ZopePathExpr, untrusted=True):",
            "    e = ZopeEngine()",
            "    e.iteratorFactory = PathIterator",
            "    for pt in zpe._default_type_names:",
            "        e.registerType(pt, zpe)",
            "    e.registerType('string', UnicodeAwareStringExpr)",
            "    e.registerType('python', ZRPythonExpr.PythonExpr)",
            "    e.registerType('not', NotExpr)",
            "    e.registerType('defer', DeferExpr)",
            "    e.registerType('lazy', LazyExpr)",
            "    e.registerType('provider', TALESProviderExpression)",
            "    e.registerBaseName('modules', SecureModuleImporter)",
            "    e.untrusted = untrusted",
            "    return e",
            "",
            "",
            "def createTrustedZopeEngine():",
            "    # same as createZopeEngine, but use non-restricted Python",
            "    # expression evaluator",
            "    # still uses the ``SecureModuleImporter``",
            "    e = createZopeEngine(TrustedZopePathExpr, untrusted=False)",
            "    e.types['python'] = PythonExpr",
            "    return e",
            "",
            "",
            "_engine = createZopeEngine()",
            "",
            "",
            "def getEngine():",
            "    return _engine",
            "",
            "",
            "_trusted_engine = createTrustedZopeEngine()",
            "",
            "",
            "def getTrustedEngine():",
            "    return _trusted_engine"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "\"\"\"Page Template Expression Engine",
            "",
            "Page Template-specific implementation of TALES, with handlers",
            "for Python expressions, string literals, and paths.",
            "\"\"\"",
            "",
            "import logging",
            "import warnings",
            "",
            "import OFS.interfaces",
            "from AccessControl import safe_builtins",
            "from AccessControl.SecurityManagement import getSecurityManager",
            "from Acquisition import aq_base",
            "from MultiMapping import MultiMapping",
            "from zExceptions import NotFound",
            "from zExceptions import Unauthorized",
            "from zope.component import queryUtility",
            "from zope.contentprovider.tales import TALESProviderExpression",
            "from zope.i18n import translate",
            "from zope.interface import implementer",
            "from zope.pagetemplate.engine import ZopeEngine as Z3Engine",
            "from zope.proxy import removeAllProxies",
            "from zope.tales.expressions import DeferExpr",
            "from zope.tales.expressions import LazyExpr",
            "from zope.tales.expressions import NotExpr",
            "from zope.tales.expressions import PathExpr",
            "from zope.tales.expressions import StringExpr",
            "from zope.tales.expressions import SubPathExpr",
            "from zope.tales.expressions import Undefs",
            "from zope.tales.pythonexpr import PythonExpr",
            "from zope.tales.tales import Context",
            "from zope.tales.tales import ErrorInfo as BaseErrorInfo",
            "from zope.tales.tales import Iterator",
            "from zope.traversing.adapters import traversePathElement",
            "from zope.traversing.interfaces import ITraversable",
            "",
            "from . import ZRPythonExpr",
            "from .interfaces import IUnicodeEncodingConflictResolver",
            "from .interfaces import IZopeAwareEngine",
            "",
            "",
            "SecureModuleImporter = ZRPythonExpr._SecureModuleImporter()",
            "",
            "LOG = logging.getLogger('Expressions')",
            "",
            "# In Zope 2 traversal semantics, NotFound or Unauthorized (the Zope 2",
            "# versions) indicate that traversal has failed.  By default, zope.tales'",
            "# engine doesn't recognize them as such which is why we extend its",
            "# list here and make sure our implementation of the TALES",
            "# Path Expression uses them",
            "ZopeUndefs = Undefs + (NotFound, Unauthorized)",
            "",
            "",
            "def boboAwareZopeTraverse(object, path_items, econtext):",
            "    \"\"\"Traverses a sequence of names, first trying attributes then items.",
            "",
            "    This uses zope.traversing path traversal where possible and interacts",
            "    correctly with objects providing OFS.interface.ITraversable when",
            "    necessary (bobo-awareness).",
            "    \"\"\"",
            "    request = getattr(econtext, 'request', None)",
            "    validate = getSecurityManager().validate",
            "    path_items = list(path_items)",
            "    path_items.reverse()",
            "",
            "    while path_items:",
            "        name = path_items.pop()",
            "",
            "        if OFS.interfaces.ITraversable.providedBy(object):",
            "            object = object.restrictedTraverse(name)",
            "        else:",
            "            found = traversePathElement(object, name, path_items,",
            "                                        request=request)",
            "",
            "            # Special backwards compatibility exception for the name ``_``,",
            "            # which was often used for translation message factories.",
            "            # Allow and continue traversal.",
            "            if name == '_':",
            "                warnings.warn('Traversing to the name `_` is deprecated '",
            "                              'and will be removed in Zope 6.',",
            "                              DeprecationWarning)",
            "                object = found",
            "                continue",
            "",
            "            # All other names starting with ``_`` are disallowed.",
            "            # This emulates what restrictedTraverse does.",
            "            if name.startswith('_'):",
            "                raise NotFound(name)",
            "",
            "            # traversePathElement doesn't apply any Zope security policy,",
            "            # so we validate access explicitly here.",
            "            try:",
            "                validate(object, object, name, found)",
            "                object = found",
            "            except Unauthorized:",
            "                # Convert Unauthorized to prevent information disclosures",
            "                raise NotFound(name)",
            "",
            "    return object",
            "",
            "",
            "def trustedBoboAwareZopeTraverse(object, path_items, econtext):",
            "    \"\"\"Traverses a sequence of names, first trying attributes then items.",
            "",
            "    This uses zope.traversing path traversal where possible and interacts",
            "    correctly with objects providing OFS.interface.ITraversable when",
            "    necessary (bobo-awareness).",
            "    \"\"\"",
            "    request = getattr(econtext, 'request', None)",
            "    path_items = list(path_items)",
            "    path_items.reverse()",
            "",
            "    while path_items:",
            "        name = path_items.pop()",
            "        if OFS.interfaces.ITraversable.providedBy(object):",
            "            object = object.unrestrictedTraverse(name)",
            "        else:",
            "            object = traversePathElement(object, name, path_items,",
            "                                         request=request)",
            "    return object",
            "",
            "",
            "def render(ob, ns):",
            "    \"\"\"Calls the object, possibly a document template, or just returns",
            "    it if not callable.  (From DT_Util.py)",
            "    \"\"\"",
            "    if hasattr(ob, '__render_with_namespace__'):",
            "        ob = ZRPythonExpr.call_with_ns(ob.__render_with_namespace__, ns)",
            "    else:",
            "        # items might be acquisition wrapped",
            "        base = aq_base(ob)",
            "        # item might be proxied (e.g. modules might have a deprecation",
            "        # proxy)",
            "        base = removeAllProxies(base)",
            "        if callable(base):",
            "            try:",
            "                if getattr(base, 'isDocTemp', 0):",
            "                    ob = ZRPythonExpr.call_with_ns(ob, ns, 2)",
            "                else:",
            "                    ob = ob()",
            "            except NotImplementedError:",
            "                pass",
            "    return ob",
            "",
            "",
            "class _CombinedMapping:",
            "    \"\"\"Minimal auxiliary class to combine several mappings.",
            "",
            "    Earlier mappings take precedence.",
            "    \"\"\"",
            "    def __init__(self, *ms):",
            "        self.mappings = ms",
            "",
            "    def get(self, key, default):",
            "        for m in self.mappings:",
            "            value = m.get(key, self)",
            "            if value is not self:",
            "                return value",
            "        return default",
            "",
            "",
            "class UntrustedSubPathExpr(SubPathExpr):",
            "    ALLOWED_BUILTINS = safe_builtins",
            "",
            "",
            "class TrustedSubPathExpr(SubPathExpr):",
            "    # we allow both Python's builtins (we are trusted)",
            "    # as well as ``safe_builtins`` (because it may contain extensions)",
            "    # Python's builtins take precedence, because those of",
            "    # ``safe_builtins`` may have special restrictions for",
            "    # the use in an untrusted context",
            "    ALLOWED_BUILTINS = _CombinedMapping(",
            "        __builtins__,",
            "        safe_builtins)",
            "",
            "",
            "class ZopePathExpr(PathExpr):",
            "",
            "    _TRAVERSER = staticmethod(boboAwareZopeTraverse)",
            "    SUBEXPR_FACTORY = UntrustedSubPathExpr",
            "",
            "    def __init__(self, name, expr, engine):",
            "        if not expr.strip():",
            "            expr = 'nothing'",
            "        super().__init__(name, expr, engine, self._TRAVERSER)",
            "",
            "    # override this to support different call metrics (see bottom of",
            "    # method) and Zope 2's traversal exceptions (ZopeUndefs instead of",
            "    # Undefs)",
            "    def _eval(self, econtext):",
            "        for expr in self._subexprs[:-1]:",
            "            # Try all but the last subexpression, skipping undefined ones.",
            "            try:",
            "                ob = expr(econtext)",
            "            except ZopeUndefs:  # use Zope 2 expression types",
            "                pass",
            "            else:",
            "                break",
            "        else:",
            "            # On the last subexpression allow exceptions through.",
            "            ob = self._subexprs[-1](econtext)",
            "            if self._hybrid:",
            "                return ob",
            "",
            "        if self._name == 'nocall':",
            "            return ob",
            "",
            "        # this is where we are different from our super class:",
            "        return render(ob, econtext.vars)",
            "",
            "    # override this to support Zope 2's traversal exceptions",
            "    # (ZopeUndefs instead of Undefs)",
            "    def _exists(self, econtext):",
            "        for expr in self._subexprs:",
            "            try:",
            "                expr(econtext)",
            "            except ZopeUndefs:  # use Zope 2 expression types",
            "                pass",
            "            else:",
            "                return 1",
            "        return 0",
            "",
            "",
            "class TrustedZopePathExpr(ZopePathExpr):",
            "    _TRAVERSER = staticmethod(trustedBoboAwareZopeTraverse)",
            "    SUBEXPR_FACTORY = TrustedSubPathExpr",
            "",
            "",
            "class SafeMapping(MultiMapping):",
            "    \"\"\"Mapping with security declarations and limited method exposure.",
            "",
            "    Since it subclasses MultiMapping, this class can be used to wrap",
            "    one or more mapping objects.  Restricted Python code will not be",
            "    able to mutate the SafeMapping or the wrapped mappings, but will be",
            "    able to read any value.",
            "    \"\"\"",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "    push = pop = None",
            "",
            "    _push = MultiMapping.push",
            "    _pop = MultiMapping.pop",
            "",
            "",
            "class ZopeContext(Context):",
            "",
            "    def __init__(self, engine, contexts):",
            "        super().__init__(engine, contexts)",
            "        # wrap the top-level 'repeat' variable, as it is visible to",
            "        # restricted code",
            "        self.setContext('repeat', SafeMapping(self.repeat_vars))",
            "        # regenerate the first scope and the scope stack after messing",
            "        # with the global context",
            "        self.vars = vars = contexts.copy()",
            "        self._vars_stack = [vars]",
            "",
            "    def translate(self, msgid, domain=None, mapping=None, default=None):",
            "        context = self.contexts.get('request')",
            "        return translate(",
            "            msgid, domain=domain, mapping=mapping,",
            "            context=context, default=default)",
            "",
            "    def evaluateBoolean(self, expr):",
            "        value = self.evaluate(expr)",
            "        # here we override the normal zope.tales behaviour. zope.tales",
            "        # doesn't care about the default in a boolean expression,",
            "        # while we do (Zope 2 legacy, see the",
            "        # BooleanAttributesAndDefault.html test case)",
            "        if value is self.getDefault():",
            "            return value",
            "        return bool(value)",
            "",
            "    def evaluateStructure(self, expr):",
            "        \"\"\" customized version in order to get rid of unicode",
            "            errors for all and ever",
            "        \"\"\"",
            "        text = super().evaluateStructure(expr)",
            "        return self._handleText(text, expr)",
            "",
            "    def evaluateText(self, expr):",
            "        \"\"\" customized version in order to get rid of unicode",
            "            errors for all and ever",
            "        \"\"\"",
            "        text = self.evaluate(expr)",
            "        return self._handleText(text, expr)",
            "",
            "    def _handleText(self, text, expr):",
            "",
            "        if text is self.getDefault() or text is None:",
            "            # XXX: should be unicode???",
            "            return text",
            "",
            "        if isinstance(text, str):",
            "            # we love unicode, nothing to do",
            "            return text",
            "",
            "        elif isinstance(text, bytes):",
            "            # bahh...non-unicode string..we need to convert it to unicode",
            "",
            "            # catch ComponentLookupError in order to make tests shut-up.",
            "            # This should not be a problem since it won't change the old",
            "            # default behavior",
            "",
            "            resolver = queryUtility(IUnicodeEncodingConflictResolver)",
            "            if resolver is None:",
            "                return text.decode('ascii')",
            "",
            "            try:",
            "                return resolver.resolve(",
            "                    self.contexts.get('context'), text, expr)",
            "            except UnicodeDecodeError as e:",
            "                LOG.error(\"UnicodeDecodeError detected for expression \\\"%s\\\"\\n\"",
            "                          \"Resolver class: %s\\n\"",
            "                          \"Exception text: %s\\n\"",
            "                          \"Template: %s\\n\"",
            "                          \"Rendered text: %r\" %",
            "                          (expr, resolver.__class__, e,",
            "                           self.contexts['template'].absolute_url(1), text))",
            "                raise",
            "        else:",
            "            # This is a weird culprit ...calling text_type() on non-string",
            "            # objects",
            "            return str(text)",
            "",
            "    def createErrorInfo(self, err, position):",
            "        # Override, returning an object accessible to untrusted code.",
            "        # See: https://bugs.launchpad.net/zope2/+bug/174705",
            "        return ErrorInfo(err, position)",
            "",
            "    def evaluateCode(self, lang, code):",
            "        \"\"\" See ITALExpressionEngine.",
            "",
            "        o This method is a fossil:  nobody actually calls it, but the",
            "          interface requires it.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class ErrorInfo(BaseErrorInfo):",
            "    \"\"\"Information about an exception passed to an on-error handler.",
            "    \"\"\"",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "",
            "",
            "# Whether an engine is Zope aware does not depend on the class",
            "# but how it is configured - especially, that is uses a Zope aware",
            "# `PathExpr` implementation.",
            "# Nevertheless, we mark the class as \"Zope aware\" for simplicity",
            "# assuming that users of the class use a proper `PathExpr`",
            "@implementer(IZopeAwareEngine)",
            "class ZopeEngine(Z3Engine):",
            "",
            "    _create_context = ZopeContext",
            "",
            "",
            "class ZopeIterator(Iterator):",
            "",
            "    # allow iterator API to be accessed from (restricted) Python TALES",
            "    # expressions",
            "    __allow_access_to_unprotected_subobjects__ = True",
            "",
            "    # The things below used to be attributes in",
            "    # ZTUtils.Iterator.Iterator, however in zope.tales.tales.Iterator",
            "    # they're methods.  We need BBB on the Python level so we redefine",
            "    # them as properties here.  Eventually, we would like to get rid",
            "    # of them, though, so that we won't have to maintain yet another",
            "    # iterator class somewhere.",
            "",
            "    @property",
            "    def index(self):",
            "        return super().index()",
            "",
            "    @property",
            "    def start(self):",
            "        return super().start()",
            "",
            "    @property",
            "    def end(self):",
            "        return super().end()",
            "",
            "    @property",
            "    def item(self):",
            "        return super().item()",
            "",
            "    # 'first' and 'last' are Zope 2 enhancements to the TALES iterator",
            "    # spec.",
            "    def first(self, name=None):",
            "        if self.start:",
            "            return True",
            "        return not self.same_part(name, self._last_item, self.item)",
            "",
            "    def last(self, name=None):",
            "        if self.end:",
            "            return True",
            "        return not self.same_part(name, self.item, self._next)",
            "",
            "    def same_part(self, name, ob1, ob2):",
            "        if name is None:",
            "            return ob1 == ob2",
            "        no = object()",
            "        return getattr(ob1, name, no) == getattr(ob2, name, no) is not no",
            "",
            "    # 'first' needs to have access to the last item in the loop",
            "    def __next__(self):",
            "        if self._nextIndex > 0:",
            "            self._last_item = self.item",
            "        return super().__next__()",
            "",
            "    def next(self):",
            "        if self._nextIndex > 0:",
            "            self._last_item = self.item",
            "        return super().next()",
            "",
            "",
            "@implementer(ITraversable)",
            "class PathIterator(ZopeIterator):",
            "    \"\"\"A TALES Iterator with the ability to use first() and last() on",
            "    subpaths of elements.\"\"\"",
            "",
            "    def traverse(self, name, furtherPath):",
            "        if name in ('first', 'last'):",
            "            method = getattr(self, name)",
            "            # it's important that 'name' becomes a copy because we'll",
            "            # clear out 'furtherPath'",
            "            name = furtherPath[:]",
            "            if not name:",
            "                name = None",
            "            # make sure that traversal ends here with us",
            "            furtherPath[:] = []",
            "            return method(name)",
            "        return getattr(self, name)",
            "",
            "    def same_part(self, name, ob1, ob2):",
            "        if name is None:",
            "            return ob1 == ob2",
            "        if isinstance(name, str):",
            "            name = name.split('/')",
            "        elif isinstance(name, bytes):",
            "            name = name.split(b'/')",
            "        try:",
            "            ob1 = boboAwareZopeTraverse(ob1, name, None)",
            "            ob2 = boboAwareZopeTraverse(ob2, name, None)",
            "        except ZopeUndefs:",
            "            return False",
            "        return ob1 == ob2",
            "",
            "",
            "class UnicodeAwareStringExpr(StringExpr):",
            "",
            "    def __call__(self, econtext):",
            "        vvals = []",
            "        if isinstance(self._expr, str):",
            "            # coerce values through the Unicode Conflict Resolver",
            "            evaluate = econtext.evaluateText",
            "        else:",
            "            evaluate = econtext.evaluate",
            "        for var in self._vars:",
            "            v = evaluate(var)",
            "            vvals.append(v)",
            "        return self._expr % tuple(vvals)",
            "",
            "",
            "def createZopeEngine(zpe=ZopePathExpr, untrusted=True):",
            "    e = ZopeEngine()",
            "    e.iteratorFactory = PathIterator",
            "    for pt in zpe._default_type_names:",
            "        e.registerType(pt, zpe)",
            "    e.registerType('string', UnicodeAwareStringExpr)",
            "    e.registerType('python', ZRPythonExpr.PythonExpr)",
            "    e.registerType('not', NotExpr)",
            "    e.registerType('defer', DeferExpr)",
            "    e.registerType('lazy', LazyExpr)",
            "    e.registerType('provider', TALESProviderExpression)",
            "    e.registerBaseName('modules', SecureModuleImporter)",
            "    e.untrusted = untrusted",
            "    return e",
            "",
            "",
            "def createTrustedZopeEngine():",
            "    # same as createZopeEngine, but use non-restricted Python",
            "    # expression evaluator",
            "    # still uses the ``SecureModuleImporter``",
            "    e = createZopeEngine(TrustedZopePathExpr, untrusted=False)",
            "    e.types['python'] = PythonExpr",
            "    return e",
            "",
            "",
            "_engine = createZopeEngine()",
            "",
            "",
            "def getEngine():",
            "    return _engine",
            "",
            "",
            "_trusted_engine = createTrustedZopeEngine()",
            "",
            "",
            "def getTrustedEngine():",
            "    return _trusted_engine"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "79": [
                "boboAwareZopeTraverse"
            ],
            "80": [
                "boboAwareZopeTraverse"
            ],
            "81": [
                "boboAwareZopeTraverse"
            ],
            "82": [
                "boboAwareZopeTraverse"
            ],
            "83": [
                "boboAwareZopeTraverse"
            ],
            "84": [
                "boboAwareZopeTraverse"
            ],
            "85": [
                "boboAwareZopeTraverse"
            ],
            "89": [
                "boboAwareZopeTraverse"
            ],
            "90": [
                "boboAwareZopeTraverse"
            ]
        },
        "addLocation": [
            "src.Products.PageTemplates.Expressions.PathIterator.same_part",
            "lib.ansible.module_utils.basic"
        ]
    },
    "src/Products/PageTemplates/expression.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from chameleon.tales import NotExpr"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from chameleon.tales import StringExpr"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+from AccessControl.SecurityManagement import getSecurityManager"
            },
            "4": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from AccessControl.ZopeGuards import guarded_apply"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from AccessControl.ZopeGuards import guarded_getattr"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from AccessControl.ZopeGuards import guarded_getitem"
            },
            "7": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     def traverse(cls, base, request, path_items):"
            },
            "8": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         \"\"\"See ``zope.app.pagetemplate.engine``.\"\"\""
            },
            "9": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        validate = getSecurityManager().validate"
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         path_items = list(path_items)"
            },
            "12": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         path_items.reverse()"
            },
            "13": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         while path_items:"
            },
            "15": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             name = path_items.pop()"
            },
            "16": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if name == '_':"
            },
            "18": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                warnings.warn('Traversing to the name `_` is deprecated '"
            },
            "19": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                              'and will be removed in Zope 6.',"
            },
            "20": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                              DeprecationWarning)"
            },
            "21": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif name.startswith('_'):"
            },
            "22": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise NotFound(name)"
            },
            "23": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "24": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "             if ITraversable.providedBy(base):"
            },
            "25": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "                 base = getattr(base, cls.traverse_method)(name)"
            },
            "26": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "             else:"
            },
            "27": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                base = traversePathElement(base, name, path_items,"
            },
            "28": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                           request=request)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                found = traversePathElement(base, name, path_items,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                                            request=request)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                # If traverse_method is something other than"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                # ``restrictedTraverse`` then traversal is assumed to be"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                # unrestricted. This emulates ``unrestrictedTraverse``"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                if cls.traverse_method != 'restrictedTraverse':"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                    base = found"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                    continue"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+                # Special backwards compatibility exception for the name ``_``,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+                # which was often used for translation message factories."
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                # Allow and continue traversal."
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+                if name == '_':"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                    warnings.warn('Traversing to the name `_` is deprecated '"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                                  'and will be removed in Zope 6.',"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                                  DeprecationWarning)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                    base = found"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                    continue"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+                # All other names starting with ``_`` are disallowed."
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                # This emulates what restrictedTraverse does."
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                if name.startswith('_'):"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                    raise NotFound(name)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                # traversePathElement doesn't apply any Zope security policy,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                # so we validate access explicitly here."
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                try:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+                    validate(base, base, name, found)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+                    base = found"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+                except Unauthorized:"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+                    # Convert Unauthorized to prevent information disclosures"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+                    raise NotFound(name)"
            },
            "62": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         return base"
            },
            "64": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 106,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"``chameleon.tales`` expressions.\"\"\"",
            "",
            "import warnings",
            "from ast import NodeTransformer",
            "from ast import parse",
            "",
            "from chameleon.astutil import Static",
            "from chameleon.astutil import Symbol",
            "from chameleon.codegen import template",
            "from chameleon.tales import NotExpr",
            "from chameleon.tales import StringExpr",
            "",
            "from AccessControl.ZopeGuards import guarded_apply",
            "from AccessControl.ZopeGuards import guarded_getattr",
            "from AccessControl.ZopeGuards import guarded_getitem",
            "from AccessControl.ZopeGuards import guarded_iter",
            "from AccessControl.ZopeGuards import protected_inplacevar",
            "from OFS.interfaces import ITraversable",
            "from RestrictedPython import RestrictingNodeTransformer",
            "from RestrictedPython.Utilities import utility_builtins",
            "from z3c.pt import expressions",
            "from zExceptions import NotFound",
            "from zExceptions import Unauthorized",
            "from zope.interface import implementer",
            "from zope.tales.tales import ExpressionEngine",
            "from zope.traversing.adapters import traversePathElement",
            "from zope.traversing.interfaces import TraversalError",
            "",
            "from .Expressions import render",
            "from .interfaces import IZopeAwareEngine",
            "",
            "",
            "_marker = object()",
            "",
            "zope2_exceptions = (",
            "    AttributeError,",
            "    LookupError,",
            "    NameError,",
            "    TypeError,",
            "    ValueError,",
            "    NotFound,",
            "    Unauthorized,",
            "    TraversalError,",
            ")",
            "",
            "",
            "def static(obj):",
            "    return Static(template(\"obj\", obj=Symbol(obj), mode=\"eval\"))",
            "",
            "",
            "class BoboAwareZopeTraverse:",
            "    traverse_method = 'restrictedTraverse'",
            "",
            "    __slots__ = ()",
            "",
            "    @classmethod",
            "    def traverse(cls, base, request, path_items):",
            "        \"\"\"See ``zope.app.pagetemplate.engine``.\"\"\"",
            "",
            "        path_items = list(path_items)",
            "        path_items.reverse()",
            "",
            "        while path_items:",
            "            name = path_items.pop()",
            "",
            "            if name == '_':",
            "                warnings.warn('Traversing to the name `_` is deprecated '",
            "                              'and will be removed in Zope 6.',",
            "                              DeprecationWarning)",
            "            elif name.startswith('_'):",
            "                raise NotFound(name)",
            "",
            "            if ITraversable.providedBy(base):",
            "                base = getattr(base, cls.traverse_method)(name)",
            "            else:",
            "                base = traversePathElement(base, name, path_items,",
            "                                           request=request)",
            "",
            "        return base",
            "",
            "    def __call__(self, base, econtext, call, path_items):",
            "        request = econtext.get('request')",
            "",
            "        if path_items:",
            "            base = self.traverse(base, request, path_items)",
            "",
            "        if call is False:",
            "            return base",
            "",
            "        if getattr(base, '__call__', _marker) is not _marker or \\",
            "           callable(base):",
            "            base = render(base, econtext)",
            "",
            "        return base",
            "",
            "",
            "class TrustedBoboAwareZopeTraverse(BoboAwareZopeTraverse):",
            "    traverse_method = 'unrestrictedTraverse'",
            "",
            "    __slots__ = ()",
            "",
            "    def __call__(self, base, econtext, call, path_items):",
            "        request = econtext.get('request')",
            "",
            "        base = self.traverse(base, request, path_items)",
            "",
            "        if call is False:",
            "            return base",
            "",
            "        if getattr(base, '__call__', _marker) is not _marker or \\",
            "           isinstance(base, type):",
            "            return base()",
            "",
            "        return base",
            "",
            "",
            "class PathExpr(expressions.PathExpr):",
            "    exceptions = zope2_exceptions",
            "",
            "    traverser = Static(template(",
            "        \"cls()\", cls=Symbol(BoboAwareZopeTraverse), mode=\"eval\"",
            "    ))",
            "",
            "",
            "class TrustedPathExpr(PathExpr):",
            "    traverser = Static(template(",
            "        \"cls()\", cls=Symbol(TrustedBoboAwareZopeTraverse), mode=\"eval\"",
            "    ))",
            "",
            "",
            "class NocallExpr(expressions.NocallExpr, PathExpr):",
            "    pass",
            "",
            "",
            "class ExistsExpr(expressions.ExistsExpr):",
            "    exceptions = zope2_exceptions",
            "",
            "",
            "class RestrictionTransform(NodeTransformer):",
            "    secured = {",
            "        '_getattr_': guarded_getattr,",
            "        '_getitem_': guarded_getitem,",
            "        '_apply_': guarded_apply,",
            "        '_getiter_': guarded_iter,",
            "        '_inplacevar_': protected_inplacevar,",
            "    }",
            "",
            "    def visit_Name(self, node):",
            "        value = self.secured.get(node.id)",
            "        if value is not None:",
            "            return Symbol(value)",
            "",
            "        return node",
            "",
            "",
            "class UntrustedPythonExpr(expressions.PythonExpr):",
            "    restricted_python_transformer = RestrictingNodeTransformer()",
            "    page_templates_expression_transformer = RestrictionTransform()",
            "",
            "    # Make copy of parent expression builtins",
            "    builtins = expressions.PythonExpr.builtins.copy()",
            "",
            "    # Update builtins with Restricted Python utility builtins",
            "    builtins.update({",
            "        name: static(builtin) for (name, builtin) in utility_builtins.items()",
            "    })",
            "",
            "    def parse(self, string):",
            "        encoded = string.encode('utf-8')",
            "        node = parse(encoded, mode='eval')",
            "",
            "        # Run Node Transformation from RestrictedPython:",
            "        self.restricted_python_transformer.visit(node)",
            "",
            "        # Run PageTemplate.expression RestrictedPython Transform:",
            "        self.page_templates_expression_transformer.visit(node)",
            "",
            "        return node",
            "",
            "",
            "# Whether an engine is Zope aware does not depend on the class",
            "# but how it is configured - especially, that is uses a Zope aware",
            "# `PathExpr` implementation.",
            "# Nevertheless, we mark the class as \"Zope aware\" for simplicity",
            "# assuming that users of the class use a proper `PathExpr`",
            "@implementer(IZopeAwareEngine)",
            "class ChameleonEngine(ExpressionEngine):",
            "    \"\"\"Expression engine for ``chameleon.tales``.",
            "",
            "    Only partially implemented: its ``compile`` is currently unusable",
            "    \"\"\"",
            "    def compile(self, expression):",
            "        raise NotImplementedError()",
            "",
            "",
            "types = dict(",
            "    python=UntrustedPythonExpr,",
            "    string=StringExpr,",
            "    not_=NotExpr,",
            "    exists=ExistsExpr,",
            "    path=PathExpr,",
            "    provider=expressions.ProviderExpr,",
            "    nocall=NocallExpr)",
            "",
            "",
            "def createChameleonEngine(types=types, untrusted=True, **overrides):",
            "    e = ChameleonEngine()",
            "",
            "    def norm(k):",
            "        return k[:-1] if k.endswith(\"_\") else k",
            "",
            "    e.untrusted = untrusted",
            "    ts = e.types",
            "    for k, v in types.items():",
            "        k = norm(k)",
            "        e.registerType(k, v)",
            "    for k, v in overrides.items():",
            "        k = norm(k)",
            "        if k in ts:",
            "            del ts[k]",
            "        e.registerType(k, v)",
            "    return e",
            "",
            "",
            "def createTrustedChameleonEngine(**overrides):",
            "    ovr = dict(python=expressions.PythonExpr, path=TrustedPathExpr)",
            "    ovr.update(overrides)",
            "    return createChameleonEngine(untrusted=False, **ovr)",
            "",
            "",
            "_engine = createChameleonEngine()",
            "",
            "",
            "def getEngine():",
            "    return _engine",
            "",
            "",
            "_trusted_engine = createTrustedChameleonEngine()",
            "",
            "",
            "def getTrustedEngine():",
            "    return _trusted_engine"
        ],
        "afterPatchFile": [
            "\"\"\"``chameleon.tales`` expressions.\"\"\"",
            "",
            "import warnings",
            "from ast import NodeTransformer",
            "from ast import parse",
            "",
            "from chameleon.astutil import Static",
            "from chameleon.astutil import Symbol",
            "from chameleon.codegen import template",
            "from chameleon.tales import NotExpr",
            "from chameleon.tales import StringExpr",
            "",
            "from AccessControl.SecurityManagement import getSecurityManager",
            "from AccessControl.ZopeGuards import guarded_apply",
            "from AccessControl.ZopeGuards import guarded_getattr",
            "from AccessControl.ZopeGuards import guarded_getitem",
            "from AccessControl.ZopeGuards import guarded_iter",
            "from AccessControl.ZopeGuards import protected_inplacevar",
            "from OFS.interfaces import ITraversable",
            "from RestrictedPython import RestrictingNodeTransformer",
            "from RestrictedPython.Utilities import utility_builtins",
            "from z3c.pt import expressions",
            "from zExceptions import NotFound",
            "from zExceptions import Unauthorized",
            "from zope.interface import implementer",
            "from zope.tales.tales import ExpressionEngine",
            "from zope.traversing.adapters import traversePathElement",
            "from zope.traversing.interfaces import TraversalError",
            "",
            "from .Expressions import render",
            "from .interfaces import IZopeAwareEngine",
            "",
            "",
            "_marker = object()",
            "",
            "zope2_exceptions = (",
            "    AttributeError,",
            "    LookupError,",
            "    NameError,",
            "    TypeError,",
            "    ValueError,",
            "    NotFound,",
            "    Unauthorized,",
            "    TraversalError,",
            ")",
            "",
            "",
            "def static(obj):",
            "    return Static(template(\"obj\", obj=Symbol(obj), mode=\"eval\"))",
            "",
            "",
            "class BoboAwareZopeTraverse:",
            "    traverse_method = 'restrictedTraverse'",
            "",
            "    __slots__ = ()",
            "",
            "    @classmethod",
            "    def traverse(cls, base, request, path_items):",
            "        \"\"\"See ``zope.app.pagetemplate.engine``.\"\"\"",
            "",
            "        validate = getSecurityManager().validate",
            "        path_items = list(path_items)",
            "        path_items.reverse()",
            "",
            "        while path_items:",
            "            name = path_items.pop()",
            "",
            "            if ITraversable.providedBy(base):",
            "                base = getattr(base, cls.traverse_method)(name)",
            "            else:",
            "                found = traversePathElement(base, name, path_items,",
            "                                            request=request)",
            "",
            "                # If traverse_method is something other than",
            "                # ``restrictedTraverse`` then traversal is assumed to be",
            "                # unrestricted. This emulates ``unrestrictedTraverse``",
            "                if cls.traverse_method != 'restrictedTraverse':",
            "                    base = found",
            "                    continue",
            "",
            "                # Special backwards compatibility exception for the name ``_``,",
            "                # which was often used for translation message factories.",
            "                # Allow and continue traversal.",
            "                if name == '_':",
            "                    warnings.warn('Traversing to the name `_` is deprecated '",
            "                                  'and will be removed in Zope 6.',",
            "                                  DeprecationWarning)",
            "                    base = found",
            "                    continue",
            "",
            "                # All other names starting with ``_`` are disallowed.",
            "                # This emulates what restrictedTraverse does.",
            "                if name.startswith('_'):",
            "                    raise NotFound(name)",
            "",
            "                # traversePathElement doesn't apply any Zope security policy,",
            "                # so we validate access explicitly here.",
            "                try:",
            "                    validate(base, base, name, found)",
            "                    base = found",
            "                except Unauthorized:",
            "                    # Convert Unauthorized to prevent information disclosures",
            "                    raise NotFound(name)",
            "",
            "        return base",
            "",
            "    def __call__(self, base, econtext, call, path_items):",
            "        request = econtext.get('request')",
            "",
            "        if path_items:",
            "            base = self.traverse(base, request, path_items)",
            "",
            "        if call is False:",
            "            return base",
            "",
            "        if getattr(base, '__call__', _marker) is not _marker or \\",
            "           callable(base):",
            "            base = render(base, econtext)",
            "",
            "        return base",
            "",
            "",
            "class TrustedBoboAwareZopeTraverse(BoboAwareZopeTraverse):",
            "    traverse_method = 'unrestrictedTraverse'",
            "",
            "    __slots__ = ()",
            "",
            "    def __call__(self, base, econtext, call, path_items):",
            "        request = econtext.get('request')",
            "",
            "        base = self.traverse(base, request, path_items)",
            "",
            "        if call is False:",
            "            return base",
            "",
            "        if getattr(base, '__call__', _marker) is not _marker or \\",
            "           isinstance(base, type):",
            "            return base()",
            "",
            "        return base",
            "",
            "",
            "class PathExpr(expressions.PathExpr):",
            "    exceptions = zope2_exceptions",
            "",
            "    traverser = Static(template(",
            "        \"cls()\", cls=Symbol(BoboAwareZopeTraverse), mode=\"eval\"",
            "    ))",
            "",
            "",
            "class TrustedPathExpr(PathExpr):",
            "    traverser = Static(template(",
            "        \"cls()\", cls=Symbol(TrustedBoboAwareZopeTraverse), mode=\"eval\"",
            "    ))",
            "",
            "",
            "class NocallExpr(expressions.NocallExpr, PathExpr):",
            "    pass",
            "",
            "",
            "class ExistsExpr(expressions.ExistsExpr):",
            "    exceptions = zope2_exceptions",
            "",
            "",
            "class RestrictionTransform(NodeTransformer):",
            "    secured = {",
            "        '_getattr_': guarded_getattr,",
            "        '_getitem_': guarded_getitem,",
            "        '_apply_': guarded_apply,",
            "        '_getiter_': guarded_iter,",
            "        '_inplacevar_': protected_inplacevar,",
            "    }",
            "",
            "    def visit_Name(self, node):",
            "        value = self.secured.get(node.id)",
            "        if value is not None:",
            "            return Symbol(value)",
            "",
            "        return node",
            "",
            "",
            "class UntrustedPythonExpr(expressions.PythonExpr):",
            "    restricted_python_transformer = RestrictingNodeTransformer()",
            "    page_templates_expression_transformer = RestrictionTransform()",
            "",
            "    # Make copy of parent expression builtins",
            "    builtins = expressions.PythonExpr.builtins.copy()",
            "",
            "    # Update builtins with Restricted Python utility builtins",
            "    builtins.update({",
            "        name: static(builtin) for (name, builtin) in utility_builtins.items()",
            "    })",
            "",
            "    def parse(self, string):",
            "        encoded = string.encode('utf-8')",
            "        node = parse(encoded, mode='eval')",
            "",
            "        # Run Node Transformation from RestrictedPython:",
            "        self.restricted_python_transformer.visit(node)",
            "",
            "        # Run PageTemplate.expression RestrictedPython Transform:",
            "        self.page_templates_expression_transformer.visit(node)",
            "",
            "        return node",
            "",
            "",
            "# Whether an engine is Zope aware does not depend on the class",
            "# but how it is configured - especially, that is uses a Zope aware",
            "# `PathExpr` implementation.",
            "# Nevertheless, we mark the class as \"Zope aware\" for simplicity",
            "# assuming that users of the class use a proper `PathExpr`",
            "@implementer(IZopeAwareEngine)",
            "class ChameleonEngine(ExpressionEngine):",
            "    \"\"\"Expression engine for ``chameleon.tales``.",
            "",
            "    Only partially implemented: its ``compile`` is currently unusable",
            "    \"\"\"",
            "    def compile(self, expression):",
            "        raise NotImplementedError()",
            "",
            "",
            "types = dict(",
            "    python=UntrustedPythonExpr,",
            "    string=StringExpr,",
            "    not_=NotExpr,",
            "    exists=ExistsExpr,",
            "    path=PathExpr,",
            "    provider=expressions.ProviderExpr,",
            "    nocall=NocallExpr)",
            "",
            "",
            "def createChameleonEngine(types=types, untrusted=True, **overrides):",
            "    e = ChameleonEngine()",
            "",
            "    def norm(k):",
            "        return k[:-1] if k.endswith(\"_\") else k",
            "",
            "    e.untrusted = untrusted",
            "    ts = e.types",
            "    for k, v in types.items():",
            "        k = norm(k)",
            "        e.registerType(k, v)",
            "    for k, v in overrides.items():",
            "        k = norm(k)",
            "        if k in ts:",
            "            del ts[k]",
            "        e.registerType(k, v)",
            "    return e",
            "",
            "",
            "def createTrustedChameleonEngine(**overrides):",
            "    ovr = dict(python=expressions.PythonExpr, path=TrustedPathExpr)",
            "    ovr.update(overrides)",
            "    return createChameleonEngine(untrusted=False, **ovr)",
            "",
            "",
            "_engine = createChameleonEngine()",
            "",
            "",
            "def getEngine():",
            "    return _engine",
            "",
            "",
            "_trusted_engine = createTrustedChameleonEngine()",
            "",
            "",
            "def getTrustedEngine():",
            "    return _trusted_engine"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "66": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "67": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "68": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "69": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "70": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "71": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "72": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "76": [
                "BoboAwareZopeTraverse",
                "traverse"
            ],
            "77": [
                "BoboAwareZopeTraverse",
                "traverse"
            ]
        },
        "addLocation": [
            "lib.ansible.module_utils.basic",
            "src.Products.PageTemplates.expression.TrustedBoboAwareZopeTraverse.__call__",
            "src.Products.PageTemplates.expression.BoboAwareZopeTraverse.__call__"
        ]
    },
    "src/Products/PageTemplates/tests/testExpressions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from AccessControl import safe_builtins"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from zExceptions import NotFound"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from zope.component.testing import PlacelessSetup"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from zope.location.interfaces import LocationError"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " class EngineTestsBase(PlacelessSetup):"
            },
            "7": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         with self.assertRaises(NotFound):"
            },
            "8": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             ec.evaluate(\"context/__class__\")"
            },
            "9": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with self.assertRaises(NotFound):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+        with self.assertRaises((NotFound, LocationError)):"
            },
            "12": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "             ec.evaluate(\"nocall: random/_itertools/repeat\")"
            },
            "13": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 239,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with self.assertRaises(NotFound):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+        with self.assertRaises((NotFound, LocationError)):"
            },
            "16": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "             ec.evaluate(\"random/_itertools/repeat/foobar\")"
            },
            "17": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 242,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import unittest",
            "import warnings",
            "",
            "from AccessControl import safe_builtins",
            "from zExceptions import NotFound",
            "from zope.component.testing import PlacelessSetup",
            "",
            "",
            "class EngineTestsBase(PlacelessSetup):",
            "",
            "    def setUp(self):",
            "        from zope.component import provideAdapter",
            "        from zope.traversing.adapters import DefaultTraversable",
            "        PlacelessSetup.setUp(self)",
            "        provideAdapter(DefaultTraversable, (None,))",
            "",
            "    def tearDown(self):",
            "        PlacelessSetup.tearDown(self)",
            "",
            "    def _makeEngine(self):",
            "        # subclasses must override",
            "        raise NotImplementedError",
            "",
            "    def _makeContext(self, bindings=None):",
            "",
            "        class Dummy:",
            "            __allow_access_to_unprotected_subobjects__ = 1",
            "",
            "            def __call__(self):",
            "                return 'dummy'",
            "",
            "        class DummyDocumentTemplate:",
            "            __allow_access_to_unprotected_subobjects__ = 1",
            "            isDocTemp = True",
            "",
            "            def __call__(self, client=None, REQUEST={}, RESPONSE=None, **kw):",
            "                return 'dummy'",
            "",
            "            def absolute_url(self, relative=0):",
            "                url = 'dummy'",
            "                if not relative:",
            "                    url = \"http://server/\" + url",
            "                return url",
            "",
            "        _DEFAULT_BINDINGS = dict(",
            "            one=1,",
            "            d={'one': 1, 'b': 'b', '': 'blank', '_': 'under'},",
            "            blank='',",
            "            dummy=Dummy(),",
            "            dummy2=DummyDocumentTemplate(),",
            "            eightbit=b'\\xe4\\xfc\\xf6',",
            "            # ZopeContext needs 'context' and 'template' keys for unicode",
            "            # conflict resolution",
            "            context=Dummy(),",
            "            template=DummyDocumentTemplate(),",
            "        )",
            "",
            "        if bindings is None:",
            "            bindings = _DEFAULT_BINDINGS",
            "        return self._makeEngine().getContext(bindings)",
            "",
            "    def test_compile(self):",
            "        # Test expression compilation",
            "        e = self._makeEngine()",
            "        for p in ('x', 'x/y', 'x/y/z'):",
            "            e.compile(p)",
            "        e.compile('path:a|b|c/d/e')",
            "        e.compile('string:Fred')",
            "        e.compile('string:A$B')",
            "        e.compile('string:a ${x/y} b ${y/z} c')",
            "        e.compile('python: 2 + 2')",
            "        e.compile('python: 2 \\n+\\n 2\\n')",
            "",
            "    def test_evaluate_simple_path_binding(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('one'), 1)",
            "",
            "    def test_evaluate_simple_path_dict_key_int_value(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('d/one'), 1)",
            "",
            "    def test_evaluate_simple_path_dict_key_string_value(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('d/b'), 'b')",
            "",
            "    def test_evaluate_with_render_simple_callable(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('dummy'), 'dummy')",
            "",
            "    def test_evaluate_with_unimplemented_call(self):",
            "        class Dummy:",
            "            def __call__(self):",
            "                raise NotImplementedError()",
            "",
            "        dummy = Dummy()",
            "        ec = self._makeContext(bindings={'dummy': dummy})",
            "        self.assertIs(ec.evaluate('dummy'), dummy)",
            "",
            "    def test_evaluate_with_render_DTML_template(self):",
            "        # http://www.zope.org/Collectors/Zope/2232",
            "        # DTML templates could not be called from a Page Template",
            "        # due to an ImportError",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('dummy2'), 'dummy')",
            "",
            "    def test_evaluate_alternative_first_missing(self):",
            "        ec = self._makeContext()",
            "        self.assertTrue(ec.evaluate('x | nothing') is None)",
            "",
            "    def test_evaluate_dict_key_as_underscore(self):",
            "        # Traversing to the name `_` will raise a DeprecationWarning",
            "        # because it will go away in Zope 6.",
            "        ec = self._makeContext()",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter('ignore')",
            "            self.assertEqual(ec.evaluate('d/_'), 'under')",
            "",
            "    def test_evaluate_dict_with_key_from_expansion(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('d/?blank'), 'blank')",
            "",
            "    def test_hybrid_with_python_expression_int_value(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | python:1+1'), 2)",
            "",
            "    def test_hybrid_with_python_expression_type_value_not_called(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | python:int'), int)",
            "",
            "    def test_hybrid_with_string_expression(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | string:x'), 'x')",
            "",
            "    def test_hybrid_with_string_expression_and_expansion(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | string:$one'), '1')",
            "",
            "    def test_hybrid_with_compound_expression_int_value(self):",
            "        ec = self._makeContext()",
            "        self.assertTrue(ec.evaluate('x | not:exists:x'))",
            "",
            "    def test_access_iterator_from_python_expression(self):",
            "        ec = self._makeContext()",
            "        ec.beginScope()",
            "        ec.setRepeat('loop', \"python:[1,2,3]\")",
            "        self.assertTrue(ec.evaluate(\"python:repeat['loop'].odd()\"))",
            "        ec.endScope()",
            "",
            "    def test_defer_expression_returns_wrapper(self):",
            "        from zope.tales.expressions import DeferWrapper",
            "        ec = self._makeContext()",
            "        defer = ec.evaluate('defer: b')",
            "        self.assertIsInstance(defer, DeferWrapper)",
            "",
            "    def test_lazy_expression_returns_wrapper(self):",
            "        from zope.tales.expressions import LazyWrapper",
            "        ec = self._makeContext()",
            "        lazy = ec.evaluate('lazy: b')",
            "        self.assertIsInstance(lazy, LazyWrapper)",
            "",
            "    def test_empty_path_expression_explicit(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('path:'), None)",
            "",
            "    def test_empty_path_expression_explicit_with_trailing_whitespace(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('path:  '), None)",
            "",
            "    def test_empty_path_expression_implicit(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate(''), None)",
            "",
            "    def test_empty_path_expression_implicit_with_trailing_whitespace(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('  \\n'), None)",
            "",
            "    def test_unicode(self):",
            "        # All our string expressions are unicode now",
            "        eng = self._makeEngine()",
            "        ec = self._makeContext()",
            "        # XXX: can't do ec.evaluate(u'string:x') directly because ZopeContext",
            "        # only bothers compiling true strings, not unicode strings",
            "        result = ec.evaluate(eng.compile('string:x'))",
            "        self.assertEqual(result, 'x')",
            "        self.assertIsInstance(result, str)",
            "",
            "    def test_mixed(self):",
            "        # 8-bit strings in unicode string expressions cause UnicodeDecodeErrors",
            "        eng = self._makeEngine()",
            "        ec = self._makeContext()",
            "        expr = eng.compile('string:$eightbit')",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          ec.evaluate, expr)",
            "        # But registering an appropriate IUnicodeEncodingConflictResolver",
            "        # should fix it",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            StrictUnicodeEncodingConflictResolver",
            "        from zope.component import provideUtility",
            "        provideUtility(StrictUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        self.assertEqual(ec.evaluate(expr), '\u00e4\u00fc\u00f6')",
            "",
            "    def test_builtin_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate('True'), True)",
            "        self.assertIs(ec.evaluate('False'), False)",
            "        self.assertIs(ec.evaluate('nocall: test'), safe_builtins[\"test\"])",
            "",
            "",
            "class UntrustedEngineTests(EngineTestsBase, unittest.TestCase):",
            "",
            "    def _makeEngine(self):",
            "        from Products.PageTemplates.Expressions import createZopeEngine",
            "        return createZopeEngine()",
            "",
            "    # XXX:  add tests that show security checks being enforced",
            "",
            "    def test_open_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        with self.assertRaises(KeyError):",
            "            ec.evaluate(\"nocall:open\")",
            "",
            "    def test_list_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate('nocall: list'), safe_builtins[\"list\"])",
            "",
            "    def test_underscore_traversal(self):",
            "        # Prevent traversal to names starting with an underscore (_)",
            "        ec = self._makeContext()",
            "",
            "        with self.assertRaises(NotFound):",
            "            ec.evaluate(\"context/__class__\")",
            "",
            "        with self.assertRaises(NotFound):",
            "            ec.evaluate(\"nocall: random/_itertools/repeat\")",
            "",
            "        with self.assertRaises(NotFound):",
            "            ec.evaluate(\"random/_itertools/repeat/foobar\")",
            "",
            "",
            "class TrustedEngineTests(EngineTestsBase, unittest.TestCase):",
            "",
            "    def _makeEngine(self):",
            "        from Products.PageTemplates.Expressions import createTrustedZopeEngine",
            "        return createTrustedZopeEngine()",
            "",
            "    # XXX:  add tests that show security checks *not* being enforced",
            "",
            "    def test_open_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate(\"nocall:open\"), open)",
            "",
            "    def test_list_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate('nocall: list'), list)",
            "",
            "",
            "class UnicodeEncodingConflictResolverTests(PlacelessSetup, unittest.TestCase):",
            "",
            "    def testDefaultResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            DefaultUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(DefaultUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          resolver.resolve, None, b'\\xe4\\xfc\\xf6', None)",
            "",
            "    def testStrictResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            StrictUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(StrictUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        text = '\\xe4\\xfc\\xe4'",
            "        self.assertEqual(resolver.resolve(None, text, None), text)",
            "",
            "    def testIgnoringResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            IgnoringUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(IgnoringUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        self.assertEqual(resolver.resolve(None, b'\\xe4\\xfc\\xf6', None), '')",
            "",
            "    def testReplacingResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            ReplacingUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(ReplacingUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        self.assertEqual(resolver.resolve(None, b'\\xe4\\xfc\\xf6', None),",
            "                         '\\ufffd\\ufffd\\ufffd')",
            "",
            "",
            "class ZopeContextTests(unittest.TestCase):",
            "",
            "    def _getTargetClass(self):",
            "        from Products.PageTemplates.Expressions import ZopeContext",
            "        return ZopeContext",
            "",
            "    def _makeOne(self, engine=None, contexts=None):",
            "        if engine is None:",
            "            engine = self._makeEngine()",
            "        if contexts is None:",
            "            contexts = {}",
            "        return self._getTargetClass()(engine, contexts)",
            "",
            "    def _makeEngine(self):",
            "        class DummyEngine:",
            "            pass",
            "        return DummyEngine()",
            "",
            "    def test_class_conforms_to_ITALExpressionEngine(self):",
            "        from zope.interface.verify import verifyClass",
            "        from zope.tal.interfaces import ITALExpressionEngine",
            "        verifyClass(ITALExpressionEngine, self._getTargetClass())",
            "",
            "    def test_instance_conforms_to_ITALExpressionEngine(self):",
            "        from zope.interface.verify import verifyObject",
            "        from zope.tal.interfaces import ITALExpressionEngine",
            "        verifyObject(ITALExpressionEngine, self._makeOne())",
            "",
            "    def test_createErrorInfo_returns_unrestricted_object(self):",
            "        # See: https://bugs.launchpad.net/zope2/+bug/174705",
            "        context = self._makeOne()",
            "        info = context.createErrorInfo(AttributeError('nonesuch'), (12, 3))",
            "        self.assertTrue(info.type is AttributeError)",
            "        self.assertEqual(info.__allow_access_to_unprotected_subobjects__, 1)"
        ],
        "afterPatchFile": [
            "import unittest",
            "import warnings",
            "",
            "from AccessControl import safe_builtins",
            "from zExceptions import NotFound",
            "from zope.component.testing import PlacelessSetup",
            "from zope.location.interfaces import LocationError",
            "",
            "",
            "class EngineTestsBase(PlacelessSetup):",
            "",
            "    def setUp(self):",
            "        from zope.component import provideAdapter",
            "        from zope.traversing.adapters import DefaultTraversable",
            "        PlacelessSetup.setUp(self)",
            "        provideAdapter(DefaultTraversable, (None,))",
            "",
            "    def tearDown(self):",
            "        PlacelessSetup.tearDown(self)",
            "",
            "    def _makeEngine(self):",
            "        # subclasses must override",
            "        raise NotImplementedError",
            "",
            "    def _makeContext(self, bindings=None):",
            "",
            "        class Dummy:",
            "            __allow_access_to_unprotected_subobjects__ = 1",
            "",
            "            def __call__(self):",
            "                return 'dummy'",
            "",
            "        class DummyDocumentTemplate:",
            "            __allow_access_to_unprotected_subobjects__ = 1",
            "            isDocTemp = True",
            "",
            "            def __call__(self, client=None, REQUEST={}, RESPONSE=None, **kw):",
            "                return 'dummy'",
            "",
            "            def absolute_url(self, relative=0):",
            "                url = 'dummy'",
            "                if not relative:",
            "                    url = \"http://server/\" + url",
            "                return url",
            "",
            "        _DEFAULT_BINDINGS = dict(",
            "            one=1,",
            "            d={'one': 1, 'b': 'b', '': 'blank', '_': 'under'},",
            "            blank='',",
            "            dummy=Dummy(),",
            "            dummy2=DummyDocumentTemplate(),",
            "            eightbit=b'\\xe4\\xfc\\xf6',",
            "            # ZopeContext needs 'context' and 'template' keys for unicode",
            "            # conflict resolution",
            "            context=Dummy(),",
            "            template=DummyDocumentTemplate(),",
            "        )",
            "",
            "        if bindings is None:",
            "            bindings = _DEFAULT_BINDINGS",
            "        return self._makeEngine().getContext(bindings)",
            "",
            "    def test_compile(self):",
            "        # Test expression compilation",
            "        e = self._makeEngine()",
            "        for p in ('x', 'x/y', 'x/y/z'):",
            "            e.compile(p)",
            "        e.compile('path:a|b|c/d/e')",
            "        e.compile('string:Fred')",
            "        e.compile('string:A$B')",
            "        e.compile('string:a ${x/y} b ${y/z} c')",
            "        e.compile('python: 2 + 2')",
            "        e.compile('python: 2 \\n+\\n 2\\n')",
            "",
            "    def test_evaluate_simple_path_binding(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('one'), 1)",
            "",
            "    def test_evaluate_simple_path_dict_key_int_value(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('d/one'), 1)",
            "",
            "    def test_evaluate_simple_path_dict_key_string_value(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('d/b'), 'b')",
            "",
            "    def test_evaluate_with_render_simple_callable(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('dummy'), 'dummy')",
            "",
            "    def test_evaluate_with_unimplemented_call(self):",
            "        class Dummy:",
            "            def __call__(self):",
            "                raise NotImplementedError()",
            "",
            "        dummy = Dummy()",
            "        ec = self._makeContext(bindings={'dummy': dummy})",
            "        self.assertIs(ec.evaluate('dummy'), dummy)",
            "",
            "    def test_evaluate_with_render_DTML_template(self):",
            "        # http://www.zope.org/Collectors/Zope/2232",
            "        # DTML templates could not be called from a Page Template",
            "        # due to an ImportError",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('dummy2'), 'dummy')",
            "",
            "    def test_evaluate_alternative_first_missing(self):",
            "        ec = self._makeContext()",
            "        self.assertTrue(ec.evaluate('x | nothing') is None)",
            "",
            "    def test_evaluate_dict_key_as_underscore(self):",
            "        # Traversing to the name `_` will raise a DeprecationWarning",
            "        # because it will go away in Zope 6.",
            "        ec = self._makeContext()",
            "        with warnings.catch_warnings():",
            "            warnings.simplefilter('ignore')",
            "            self.assertEqual(ec.evaluate('d/_'), 'under')",
            "",
            "    def test_evaluate_dict_with_key_from_expansion(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('d/?blank'), 'blank')",
            "",
            "    def test_hybrid_with_python_expression_int_value(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | python:1+1'), 2)",
            "",
            "    def test_hybrid_with_python_expression_type_value_not_called(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | python:int'), int)",
            "",
            "    def test_hybrid_with_string_expression(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | string:x'), 'x')",
            "",
            "    def test_hybrid_with_string_expression_and_expansion(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('x | string:$one'), '1')",
            "",
            "    def test_hybrid_with_compound_expression_int_value(self):",
            "        ec = self._makeContext()",
            "        self.assertTrue(ec.evaluate('x | not:exists:x'))",
            "",
            "    def test_access_iterator_from_python_expression(self):",
            "        ec = self._makeContext()",
            "        ec.beginScope()",
            "        ec.setRepeat('loop', \"python:[1,2,3]\")",
            "        self.assertTrue(ec.evaluate(\"python:repeat['loop'].odd()\"))",
            "        ec.endScope()",
            "",
            "    def test_defer_expression_returns_wrapper(self):",
            "        from zope.tales.expressions import DeferWrapper",
            "        ec = self._makeContext()",
            "        defer = ec.evaluate('defer: b')",
            "        self.assertIsInstance(defer, DeferWrapper)",
            "",
            "    def test_lazy_expression_returns_wrapper(self):",
            "        from zope.tales.expressions import LazyWrapper",
            "        ec = self._makeContext()",
            "        lazy = ec.evaluate('lazy: b')",
            "        self.assertIsInstance(lazy, LazyWrapper)",
            "",
            "    def test_empty_path_expression_explicit(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('path:'), None)",
            "",
            "    def test_empty_path_expression_explicit_with_trailing_whitespace(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('path:  '), None)",
            "",
            "    def test_empty_path_expression_implicit(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate(''), None)",
            "",
            "    def test_empty_path_expression_implicit_with_trailing_whitespace(self):",
            "        ec = self._makeContext()",
            "        self.assertEqual(ec.evaluate('  \\n'), None)",
            "",
            "    def test_unicode(self):",
            "        # All our string expressions are unicode now",
            "        eng = self._makeEngine()",
            "        ec = self._makeContext()",
            "        # XXX: can't do ec.evaluate(u'string:x') directly because ZopeContext",
            "        # only bothers compiling true strings, not unicode strings",
            "        result = ec.evaluate(eng.compile('string:x'))",
            "        self.assertEqual(result, 'x')",
            "        self.assertIsInstance(result, str)",
            "",
            "    def test_mixed(self):",
            "        # 8-bit strings in unicode string expressions cause UnicodeDecodeErrors",
            "        eng = self._makeEngine()",
            "        ec = self._makeContext()",
            "        expr = eng.compile('string:$eightbit')",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          ec.evaluate, expr)",
            "        # But registering an appropriate IUnicodeEncodingConflictResolver",
            "        # should fix it",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            StrictUnicodeEncodingConflictResolver",
            "        from zope.component import provideUtility",
            "        provideUtility(StrictUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        self.assertEqual(ec.evaluate(expr), '\u00e4\u00fc\u00f6')",
            "",
            "    def test_builtin_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate('True'), True)",
            "        self.assertIs(ec.evaluate('False'), False)",
            "        self.assertIs(ec.evaluate('nocall: test'), safe_builtins[\"test\"])",
            "",
            "",
            "class UntrustedEngineTests(EngineTestsBase, unittest.TestCase):",
            "",
            "    def _makeEngine(self):",
            "        from Products.PageTemplates.Expressions import createZopeEngine",
            "        return createZopeEngine()",
            "",
            "    # XXX:  add tests that show security checks being enforced",
            "",
            "    def test_open_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        with self.assertRaises(KeyError):",
            "            ec.evaluate(\"nocall:open\")",
            "",
            "    def test_list_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate('nocall: list'), safe_builtins[\"list\"])",
            "",
            "    def test_underscore_traversal(self):",
            "        # Prevent traversal to names starting with an underscore (_)",
            "        ec = self._makeContext()",
            "",
            "        with self.assertRaises(NotFound):",
            "            ec.evaluate(\"context/__class__\")",
            "",
            "        with self.assertRaises((NotFound, LocationError)):",
            "            ec.evaluate(\"nocall: random/_itertools/repeat\")",
            "",
            "        with self.assertRaises((NotFound, LocationError)):",
            "            ec.evaluate(\"random/_itertools/repeat/foobar\")",
            "",
            "",
            "class TrustedEngineTests(EngineTestsBase, unittest.TestCase):",
            "",
            "    def _makeEngine(self):",
            "        from Products.PageTemplates.Expressions import createTrustedZopeEngine",
            "        return createTrustedZopeEngine()",
            "",
            "    # XXX:  add tests that show security checks *not* being enforced",
            "",
            "    def test_open_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate(\"nocall:open\"), open)",
            "",
            "    def test_list_in_path_expr(self):",
            "        ec = self._makeContext()",
            "        self.assertIs(ec.evaluate('nocall: list'), list)",
            "",
            "",
            "class UnicodeEncodingConflictResolverTests(PlacelessSetup, unittest.TestCase):",
            "",
            "    def testDefaultResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            DefaultUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(DefaultUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        self.assertRaises(UnicodeDecodeError,",
            "                          resolver.resolve, None, b'\\xe4\\xfc\\xf6', None)",
            "",
            "    def testStrictResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            StrictUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(StrictUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        text = '\\xe4\\xfc\\xe4'",
            "        self.assertEqual(resolver.resolve(None, text, None), text)",
            "",
            "    def testIgnoringResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            IgnoringUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(IgnoringUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        self.assertEqual(resolver.resolve(None, b'\\xe4\\xfc\\xf6', None), '')",
            "",
            "    def testReplacingResolver(self):",
            "        from Products.PageTemplates.interfaces import \\",
            "            IUnicodeEncodingConflictResolver",
            "        from Products.PageTemplates.unicodeconflictresolver import \\",
            "            ReplacingUnicodeEncodingConflictResolver",
            "        from zope.component import getUtility",
            "        from zope.component import provideUtility",
            "        provideUtility(ReplacingUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "        resolver = getUtility(IUnicodeEncodingConflictResolver)",
            "        self.assertEqual(resolver.resolve(None, b'\\xe4\\xfc\\xf6', None),",
            "                         '\\ufffd\\ufffd\\ufffd')",
            "",
            "",
            "class ZopeContextTests(unittest.TestCase):",
            "",
            "    def _getTargetClass(self):",
            "        from Products.PageTemplates.Expressions import ZopeContext",
            "        return ZopeContext",
            "",
            "    def _makeOne(self, engine=None, contexts=None):",
            "        if engine is None:",
            "            engine = self._makeEngine()",
            "        if contexts is None:",
            "            contexts = {}",
            "        return self._getTargetClass()(engine, contexts)",
            "",
            "    def _makeEngine(self):",
            "        class DummyEngine:",
            "            pass",
            "        return DummyEngine()",
            "",
            "    def test_class_conforms_to_ITALExpressionEngine(self):",
            "        from zope.interface.verify import verifyClass",
            "        from zope.tal.interfaces import ITALExpressionEngine",
            "        verifyClass(ITALExpressionEngine, self._getTargetClass())",
            "",
            "    def test_instance_conforms_to_ITALExpressionEngine(self):",
            "        from zope.interface.verify import verifyObject",
            "        from zope.tal.interfaces import ITALExpressionEngine",
            "        verifyObject(ITALExpressionEngine, self._makeOne())",
            "",
            "    def test_createErrorInfo_returns_unrestricted_object(self):",
            "        # See: https://bugs.launchpad.net/zope2/+bug/174705",
            "        context = self._makeOne()",
            "        info = context.createErrorInfo(AttributeError('nonesuch'), (12, 3))",
            "        self.assertTrue(info.type is AttributeError)",
            "        self.assertEqual(info.__allow_access_to_unprotected_subobjects__, 1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "236": [
                "UntrustedEngineTests",
                "test_underscore_traversal"
            ],
            "239": [
                "UntrustedEngineTests",
                "test_underscore_traversal"
            ]
        },
        "addLocation": []
    },
    "src/Products/PageTemplates/tests/testHTMLTests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     DefaultUnicodeEncodingConflictResolver"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from Products.PageTemplates.unicodeconflictresolver import \\"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     PreferredCharsetResolver"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate"
            },
            "4": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from zExceptions import NotFound"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from zope.component import provideUtility"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from zope.location.interfaces import LocationError"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from zope.traversing.adapters import DefaultTraversable"
            },
            "8": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from .util import useChameleonEngine"
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     pass"
            },
            "11": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+class AqZopePageTemplate(Implicit, ZopePageTemplate):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    pass"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " class Folder(util.Base):"
            },
            "18": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     pass"
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         self.folder = f = Folder()"
            },
            "21": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         f.laf = AqPageTemplate()"
            },
            "22": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         f.t = AqPageTemplate()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        f.z = AqZopePageTemplate('testing')"
            },
            "24": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         self.policy = UnitTestSecurityPolicy()"
            },
            "25": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         self.oldPolicy = SecurityManager.setSecurityPolicy(self.policy)"
            },
            "26": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         noSecurityManager()  # Use the new policy."
            },
            "27": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "             t()"
            },
            "28": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         t.write('<p tal:define=\"p nocall: random/_itertools/repeat\"/>')"
            },
            "30": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with self.assertRaises(NotFound):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        with self.assertRaises((NotFound, LocationError)):"
            },
            "32": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "             t()"
            },
            "33": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         t.write('<p tal:content=\"random/_itertools/repeat/foobar\"/>')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+        with self.assertRaises((NotFound, LocationError)):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+            t()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    def test_module_traversal(self):"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+        t = self.folder.z"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        # Need to reset to the standard security policy so AccessControl"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+        # checks are actually performed. The test setup initializes"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        # a policy that circumvents those checks."
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        SecurityManager.setSecurityPolicy(self.oldPolicy)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        noSecurityManager()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        # The getSecurityManager function is explicitly allowed"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        content = ('<p tal:define=\"a nocall:%s\"'"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+                   '   tal:content=\"python: a().getUser().getUserName()\"/>')"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        t.write(content % 'modules/AccessControl/getSecurityManager')"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+        self.assertEqual(t(), '<p>Anonymous User</p>')"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+        # Anything else should be unreachable and raise NotFound:"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        # Direct access through AccessControl"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+        t.write('<p tal:define=\"a nocall:modules/AccessControl/users\"/>')"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        with self.assertRaises(NotFound):"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+            t()"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+        # Indirect access through an intermediary variable"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        content = ('<p tal:define=\"mod nocall:modules/AccessControl;'"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+                   '               must_fail nocall:mod/users\"/>')"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+        t.write(content)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        with self.assertRaises(NotFound):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            t()"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+        # Indirect access through an intermediary variable and a dictionary"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+        content = ('<p tal:define=\"mod nocall:modules/AccessControl;'"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+                   '               a_dict python: {\\'unsafe\\': mod};'"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+                   '               must_fail nocall: a_dict/unsafe/users\"/>')"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+        t.write(content)"
            },
            "71": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "         with self.assertRaises(NotFound):"
            },
            "72": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "             t()"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "import unittest",
            "",
            "from chameleon.exc import ExpressionError",
            "",
            "import zope.component.testing",
            "from AccessControl import SecurityManager",
            "from AccessControl.SecurityManagement import noSecurityManager",
            "from Acquisition import Implicit",
            "from Products.PageTemplates.interfaces import IUnicodeEncodingConflictResolver",
            "from Products.PageTemplates.PageTemplate import PageTemplate",
            "from Products.PageTemplates.tests import util",
            "from Products.PageTemplates.unicodeconflictresolver import \\",
            "    DefaultUnicodeEncodingConflictResolver",
            "from Products.PageTemplates.unicodeconflictresolver import \\",
            "    PreferredCharsetResolver",
            "from zExceptions import NotFound",
            "from zope.component import provideUtility",
            "from zope.traversing.adapters import DefaultTraversable",
            "",
            "from .util import useChameleonEngine",
            "",
            "",
            "class AqPageTemplate(Implicit, PageTemplate):",
            "    pass",
            "",
            "",
            "class Folder(util.Base):",
            "    pass",
            "",
            "",
            "class UnitTestSecurityPolicy:",
            "    \"\"\"",
            "        Stub out the existing security policy for unit testing purposes.",
            "    \"\"\"",
            "    # Standard SecurityPolicy interface",
            "    def validate(self,",
            "                 accessed=None,",
            "                 container=None,",
            "                 name=None,",
            "                 value=None,",
            "                 context=None,",
            "                 roles=None,",
            "                 *args, **kw):",
            "        return 1",
            "",
            "    def checkPermission(self, permission, object, context):",
            "        return 1",
            "",
            "",
            "class HTMLTests(zope.component.testing.PlacelessSetup, unittest.TestCase):",
            "    PREFIX = None",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        useChameleonEngine()",
            "        zope.component.provideAdapter(DefaultTraversable, (None,))",
            "",
            "        provideUtility(DefaultUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "",
            "        self.folder = f = Folder()",
            "        f.laf = AqPageTemplate()",
            "        f.t = AqPageTemplate()",
            "        self.policy = UnitTestSecurityPolicy()",
            "        self.oldPolicy = SecurityManager.setSecurityPolicy(self.policy)",
            "        noSecurityManager()  # Use the new policy.",
            "",
            "    def tearDown(self):",
            "        super().tearDown()",
            "        SecurityManager.setSecurityPolicy(self.oldPolicy)",
            "        noSecurityManager()  # Reset to old policy.",
            "",
            "    def assert_expected(self, t, fname, *args, **kwargs):",
            "        t.write(util.read_input(fname))",
            "        assert not t._v_errors, 'Template errors: %s' % t._v_errors",
            "        if self.PREFIX is not None \\",
            "                and util.exists_output(self.PREFIX + fname):",
            "            fname = self.PREFIX + fname",
            "        expect = util.read_output(fname)",
            "        out = t(*args, **kwargs)",
            "        util.check_html(expect, out)",
            "",
            "    def assert_expected_unicode(self, t, fname, *args, **kwargs):",
            "        t.write(util.read_input(fname))",
            "        assert not t._v_errors, 'Template errors: %s' % t._v_errors",
            "        expect = util.read_output(fname)",
            "        if not isinstance(expect, str):",
            "            expect = str(expect, 'utf-8')",
            "        out = t(*args, **kwargs)",
            "        util.check_html(expect, out)",
            "",
            "    def getProducts(self):",
            "        return [",
            "            {'description': 'This is the tee for those who LOVE Zope. '",
            "             'Show your heart on your tee.',",
            "             'price': 12.99, 'image': 'smlatee.jpg'",
            "             },",
            "            {'description': 'This is the tee for Jim Fulton. '",
            "             'He\\'s the Zope Pope!',",
            "             'price': 11.99, 'image': 'smpztee.jpg'",
            "             },",
            "        ]",
            "",
            "    def test_1(self):",
            "        self.assert_expected(self.folder.laf, 'TeeShopLAF.html')",
            "",
            "    def test_2(self):",
            "        self.folder.laf.write(util.read_input('TeeShopLAF.html'))",
            "",
            "        self.assert_expected(self.folder.t, 'TeeShop2.html',",
            "                             getProducts=self.getProducts)",
            "",
            "    def test_3(self):",
            "        self.folder.laf.write(util.read_input('TeeShopLAF.html'))",
            "",
            "        self.assert_expected(self.folder.t, 'TeeShop1.html',",
            "                             getProducts=self.getProducts)",
            "",
            "    def testSimpleLoop(self):",
            "        self.assert_expected(self.folder.t, 'Loop1.html')",
            "",
            "    def testFancyLoop(self):",
            "        self.assert_expected(self.folder.t, 'Loop2.html')",
            "",
            "    def testGlobalsShadowLocals(self):",
            "        self.assert_expected(self.folder.t, 'GlobalsShadowLocals.html')",
            "",
            "    def testStringExpressions(self):",
            "        self.assert_expected(self.folder.t, 'StringExpression.html')",
            "",
            "    def testReplaceWithNothing(self):",
            "        self.assert_expected(self.folder.t, 'CheckNothing.html')",
            "",
            "    def testWithXMLHeader(self):",
            "        self.assert_expected(self.folder.t, 'CheckWithXMLHeader.html')",
            "",
            "    def testNotExpression(self):",
            "        self.assert_expected(self.folder.t, 'CheckNotExpression.html')",
            "",
            "    def testPathNothing(self):",
            "        self.assert_expected(self.folder.t, 'CheckPathNothing.html')",
            "",
            "    def testPathAlt(self):",
            "        self.assert_expected(self.folder.t, 'CheckPathAlt.html')",
            "",
            "    def testPathTraverse(self):",
            "        # need to perform this test with a \"real\" folder",
            "        from OFS.Folder import Folder",
            "        f = self.folder",
            "        self.folder = Folder()",
            "        self.folder.t, self.folder.laf = f.t, f.laf",
            "        self.folder.laf.write('ok')",
            "        self.assert_expected(self.folder.t, 'CheckPathTraverse.html')",
            "",
            "    def testBatchIteration(self):",
            "        self.assert_expected(self.folder.t, 'CheckBatchIteration.html')",
            "",
            "    def testUnicodeInserts(self):",
            "        self.assert_expected_unicode(self.folder.t, 'CheckUnicodeInserts.html')",
            "",
            "    def testI18nTranslate(self):",
            "        self.assert_expected(self.folder.t, 'CheckI18nTranslate.html')",
            "",
            "    def testImportOldStyleClass(self):",
            "        self.assert_expected(self.folder.t, 'CheckImportOldStyleClass.html')",
            "",
            "    def testRepeatVariable(self):",
            "        self.assert_expected(self.folder.t, 'RepeatVariable.html')",
            "",
            "    def testBooleanAttributes(self):",
            "        # Test rendering an attribute that should be empty or left out",
            "        # if the value is non-True",
            "        self.assert_expected(self.folder.t, 'BooleanAttributes.html')",
            "",
            "    def testBooleanAttributesAndDefault(self):",
            "        # Zope 2.9 and below support the semantics that an HTML",
            "        # \"boolean\" attribute (e.g. 'selected', 'disabled', etc.) can",
            "        # be used together with 'default'.",
            "        self.assert_expected(self.folder.t, 'BooleanAttributesAndDefault.html')",
            "",
            "    def testInterpolationInContent(self):",
            "        # the chameleon template engine supports ``${path}``",
            "        # interpolations not only as part of ``string`` expressions",
            "        # but globally",
            "        self.assert_expected(self.folder.t, 'InterpolationInContent.html')",
            "",
            "    def testBadExpression(self):",
            "        t = self.folder.t",
            "        t.write(\"<p tal:define='p a//b' />\")",
            "        with self.assertRaises(ExpressionError):",
            "            t()",
            "",
            "    def testPathAlternativesWithSpaces(self):",
            "        self.assert_expected(self.folder.t, 'PathAlternativesWithSpaces.html')",
            "",
            "    def testDefaultKeywordHandling(self):",
            "        self.assert_expected(self.folder.t, 'Default.html')",
            "",
            "    def testSwitch(self):",
            "        self.assert_expected(self.folder.t, 'switch.html')",
            "",
            "    def test_unicode_conflict_resolution(self):",
            "        # override with the more \"demanding\" resolver",
            "        provideUtility(PreferredCharsetResolver)",
            "        t = PageTemplate()",
            "        self.assert_expected(t, 'UnicodeResolution.html')",
            "",
            "    def test_underscore_traversal(self):",
            "        t = self.folder.t",
            "",
            "        t.write('<p tal:define=\"p context/__class__\" />')",
            "        with self.assertRaises(NotFound):",
            "            t()",
            "",
            "        t.write('<p tal:define=\"p nocall: random/_itertools/repeat\"/>')",
            "        with self.assertRaises(NotFound):",
            "            t()",
            "",
            "        t.write('<p tal:content=\"random/_itertools/repeat/foobar\"/>')",
            "        with self.assertRaises(NotFound):",
            "            t()"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2002 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE",
            "#",
            "##############################################################################",
            "",
            "import unittest",
            "",
            "from chameleon.exc import ExpressionError",
            "",
            "import zope.component.testing",
            "from AccessControl import SecurityManager",
            "from AccessControl.SecurityManagement import noSecurityManager",
            "from Acquisition import Implicit",
            "from Products.PageTemplates.interfaces import IUnicodeEncodingConflictResolver",
            "from Products.PageTemplates.PageTemplate import PageTemplate",
            "from Products.PageTemplates.tests import util",
            "from Products.PageTemplates.unicodeconflictresolver import \\",
            "    DefaultUnicodeEncodingConflictResolver",
            "from Products.PageTemplates.unicodeconflictresolver import \\",
            "    PreferredCharsetResolver",
            "from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate",
            "from zExceptions import NotFound",
            "from zope.component import provideUtility",
            "from zope.location.interfaces import LocationError",
            "from zope.traversing.adapters import DefaultTraversable",
            "",
            "from .util import useChameleonEngine",
            "",
            "",
            "class AqPageTemplate(Implicit, PageTemplate):",
            "    pass",
            "",
            "",
            "class AqZopePageTemplate(Implicit, ZopePageTemplate):",
            "    pass",
            "",
            "",
            "class Folder(util.Base):",
            "    pass",
            "",
            "",
            "class UnitTestSecurityPolicy:",
            "    \"\"\"",
            "        Stub out the existing security policy for unit testing purposes.",
            "    \"\"\"",
            "    # Standard SecurityPolicy interface",
            "    def validate(self,",
            "                 accessed=None,",
            "                 container=None,",
            "                 name=None,",
            "                 value=None,",
            "                 context=None,",
            "                 roles=None,",
            "                 *args, **kw):",
            "        return 1",
            "",
            "    def checkPermission(self, permission, object, context):",
            "        return 1",
            "",
            "",
            "class HTMLTests(zope.component.testing.PlacelessSetup, unittest.TestCase):",
            "    PREFIX = None",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        useChameleonEngine()",
            "        zope.component.provideAdapter(DefaultTraversable, (None,))",
            "",
            "        provideUtility(DefaultUnicodeEncodingConflictResolver,",
            "                       IUnicodeEncodingConflictResolver)",
            "",
            "        self.folder = f = Folder()",
            "        f.laf = AqPageTemplate()",
            "        f.t = AqPageTemplate()",
            "        f.z = AqZopePageTemplate('testing')",
            "        self.policy = UnitTestSecurityPolicy()",
            "        self.oldPolicy = SecurityManager.setSecurityPolicy(self.policy)",
            "        noSecurityManager()  # Use the new policy.",
            "",
            "    def tearDown(self):",
            "        super().tearDown()",
            "        SecurityManager.setSecurityPolicy(self.oldPolicy)",
            "        noSecurityManager()  # Reset to old policy.",
            "",
            "    def assert_expected(self, t, fname, *args, **kwargs):",
            "        t.write(util.read_input(fname))",
            "        assert not t._v_errors, 'Template errors: %s' % t._v_errors",
            "        if self.PREFIX is not None \\",
            "                and util.exists_output(self.PREFIX + fname):",
            "            fname = self.PREFIX + fname",
            "        expect = util.read_output(fname)",
            "        out = t(*args, **kwargs)",
            "        util.check_html(expect, out)",
            "",
            "    def assert_expected_unicode(self, t, fname, *args, **kwargs):",
            "        t.write(util.read_input(fname))",
            "        assert not t._v_errors, 'Template errors: %s' % t._v_errors",
            "        expect = util.read_output(fname)",
            "        if not isinstance(expect, str):",
            "            expect = str(expect, 'utf-8')",
            "        out = t(*args, **kwargs)",
            "        util.check_html(expect, out)",
            "",
            "    def getProducts(self):",
            "        return [",
            "            {'description': 'This is the tee for those who LOVE Zope. '",
            "             'Show your heart on your tee.',",
            "             'price': 12.99, 'image': 'smlatee.jpg'",
            "             },",
            "            {'description': 'This is the tee for Jim Fulton. '",
            "             'He\\'s the Zope Pope!',",
            "             'price': 11.99, 'image': 'smpztee.jpg'",
            "             },",
            "        ]",
            "",
            "    def test_1(self):",
            "        self.assert_expected(self.folder.laf, 'TeeShopLAF.html')",
            "",
            "    def test_2(self):",
            "        self.folder.laf.write(util.read_input('TeeShopLAF.html'))",
            "",
            "        self.assert_expected(self.folder.t, 'TeeShop2.html',",
            "                             getProducts=self.getProducts)",
            "",
            "    def test_3(self):",
            "        self.folder.laf.write(util.read_input('TeeShopLAF.html'))",
            "",
            "        self.assert_expected(self.folder.t, 'TeeShop1.html',",
            "                             getProducts=self.getProducts)",
            "",
            "    def testSimpleLoop(self):",
            "        self.assert_expected(self.folder.t, 'Loop1.html')",
            "",
            "    def testFancyLoop(self):",
            "        self.assert_expected(self.folder.t, 'Loop2.html')",
            "",
            "    def testGlobalsShadowLocals(self):",
            "        self.assert_expected(self.folder.t, 'GlobalsShadowLocals.html')",
            "",
            "    def testStringExpressions(self):",
            "        self.assert_expected(self.folder.t, 'StringExpression.html')",
            "",
            "    def testReplaceWithNothing(self):",
            "        self.assert_expected(self.folder.t, 'CheckNothing.html')",
            "",
            "    def testWithXMLHeader(self):",
            "        self.assert_expected(self.folder.t, 'CheckWithXMLHeader.html')",
            "",
            "    def testNotExpression(self):",
            "        self.assert_expected(self.folder.t, 'CheckNotExpression.html')",
            "",
            "    def testPathNothing(self):",
            "        self.assert_expected(self.folder.t, 'CheckPathNothing.html')",
            "",
            "    def testPathAlt(self):",
            "        self.assert_expected(self.folder.t, 'CheckPathAlt.html')",
            "",
            "    def testPathTraverse(self):",
            "        # need to perform this test with a \"real\" folder",
            "        from OFS.Folder import Folder",
            "        f = self.folder",
            "        self.folder = Folder()",
            "        self.folder.t, self.folder.laf = f.t, f.laf",
            "        self.folder.laf.write('ok')",
            "        self.assert_expected(self.folder.t, 'CheckPathTraverse.html')",
            "",
            "    def testBatchIteration(self):",
            "        self.assert_expected(self.folder.t, 'CheckBatchIteration.html')",
            "",
            "    def testUnicodeInserts(self):",
            "        self.assert_expected_unicode(self.folder.t, 'CheckUnicodeInserts.html')",
            "",
            "    def testI18nTranslate(self):",
            "        self.assert_expected(self.folder.t, 'CheckI18nTranslate.html')",
            "",
            "    def testImportOldStyleClass(self):",
            "        self.assert_expected(self.folder.t, 'CheckImportOldStyleClass.html')",
            "",
            "    def testRepeatVariable(self):",
            "        self.assert_expected(self.folder.t, 'RepeatVariable.html')",
            "",
            "    def testBooleanAttributes(self):",
            "        # Test rendering an attribute that should be empty or left out",
            "        # if the value is non-True",
            "        self.assert_expected(self.folder.t, 'BooleanAttributes.html')",
            "",
            "    def testBooleanAttributesAndDefault(self):",
            "        # Zope 2.9 and below support the semantics that an HTML",
            "        # \"boolean\" attribute (e.g. 'selected', 'disabled', etc.) can",
            "        # be used together with 'default'.",
            "        self.assert_expected(self.folder.t, 'BooleanAttributesAndDefault.html')",
            "",
            "    def testInterpolationInContent(self):",
            "        # the chameleon template engine supports ``${path}``",
            "        # interpolations not only as part of ``string`` expressions",
            "        # but globally",
            "        self.assert_expected(self.folder.t, 'InterpolationInContent.html')",
            "",
            "    def testBadExpression(self):",
            "        t = self.folder.t",
            "        t.write(\"<p tal:define='p a//b' />\")",
            "        with self.assertRaises(ExpressionError):",
            "            t()",
            "",
            "    def testPathAlternativesWithSpaces(self):",
            "        self.assert_expected(self.folder.t, 'PathAlternativesWithSpaces.html')",
            "",
            "    def testDefaultKeywordHandling(self):",
            "        self.assert_expected(self.folder.t, 'Default.html')",
            "",
            "    def testSwitch(self):",
            "        self.assert_expected(self.folder.t, 'switch.html')",
            "",
            "    def test_unicode_conflict_resolution(self):",
            "        # override with the more \"demanding\" resolver",
            "        provideUtility(PreferredCharsetResolver)",
            "        t = PageTemplate()",
            "        self.assert_expected(t, 'UnicodeResolution.html')",
            "",
            "    def test_underscore_traversal(self):",
            "        t = self.folder.t",
            "",
            "        t.write('<p tal:define=\"p context/__class__\" />')",
            "        with self.assertRaises(NotFound):",
            "            t()",
            "",
            "        t.write('<p tal:define=\"p nocall: random/_itertools/repeat\"/>')",
            "        with self.assertRaises((NotFound, LocationError)):",
            "            t()",
            "",
            "        t.write('<p tal:content=\"random/_itertools/repeat/foobar\"/>')",
            "        with self.assertRaises((NotFound, LocationError)):",
            "            t()",
            "",
            "    def test_module_traversal(self):",
            "        t = self.folder.z",
            "",
            "        # Need to reset to the standard security policy so AccessControl",
            "        # checks are actually performed. The test setup initializes",
            "        # a policy that circumvents those checks.",
            "        SecurityManager.setSecurityPolicy(self.oldPolicy)",
            "        noSecurityManager()",
            "",
            "        # The getSecurityManager function is explicitly allowed",
            "        content = ('<p tal:define=\"a nocall:%s\"'",
            "                   '   tal:content=\"python: a().getUser().getUserName()\"/>')",
            "        t.write(content % 'modules/AccessControl/getSecurityManager')",
            "        self.assertEqual(t(), '<p>Anonymous User</p>')",
            "",
            "        # Anything else should be unreachable and raise NotFound:",
            "        # Direct access through AccessControl",
            "        t.write('<p tal:define=\"a nocall:modules/AccessControl/users\"/>')",
            "        with self.assertRaises(NotFound):",
            "            t()",
            "",
            "        # Indirect access through an intermediary variable",
            "        content = ('<p tal:define=\"mod nocall:modules/AccessControl;'",
            "                   '               must_fail nocall:mod/users\"/>')",
            "        t.write(content)",
            "        with self.assertRaises(NotFound):",
            "            t()",
            "",
            "        # Indirect access through an intermediary variable and a dictionary",
            "        content = ('<p tal:define=\"mod nocall:modules/AccessControl;'",
            "                   '               a_dict python: {\\'unsafe\\': mod};'",
            "                   '               must_fail nocall: a_dict/unsafe/users\"/>')",
            "        t.write(content)",
            "        with self.assertRaises(NotFound):",
            "            t()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "229": [
                "HTMLTests",
                "test_underscore_traversal"
            ]
        },
        "addLocation": [
            "lib.ansible.module_utils.basic"
        ]
    }
}