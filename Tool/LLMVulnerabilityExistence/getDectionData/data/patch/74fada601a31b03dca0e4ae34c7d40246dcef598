{
    "src/webargs/bottleparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     def parse_form(self, req, name, field):"
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         \"\"\"Pull a form value from the request.\"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        # For consistency with other parsers' behavior, don't attempt to"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        #  parse if content-type is mismatched."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        #  TODO: Make this check more specific"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        if core.is_json(req.content_type):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            return core.missing"
            },
            "8": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "         return core.get_value(req.forms, name, field)"
            },
            "9": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def parse_json(self, req, name, field):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Bottle request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    from bottle import route, run",
            "    from marshmallow import fields",
            "    from webargs.bottleparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "    @route('/', method='GET', apply=use_args(hello_args))",
            "    def index(args):",
            "        return 'Hello ' + args['name']",
            "",
            "    if __name__ == '__main__':",
            "        run(debug=True)",
            "\"\"\"",
            "import bottle",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "class BottleParser(core.Parser):",
            "    \"\"\"Bottle.py request argument parser.\"\"\"",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.query, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        return core.get_value(req.forms, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            try:",
            "                self._cache[\"json\"] = json_data = req.json",
            "            except AttributeError:",
            "                return core.missing",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "            except UnicodeDecodeError as e:",
            "                return self.handle_invalid_json_error(e, req)",
            "",
            "            if json_data is None:",
            "                return core.missing",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull a value from the cookiejar.\"\"\"",
            "        return req.get_cookie(name)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        return core.get_value(req.files, name, field)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current request with a",
            "        400 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        raise bottle.HTTPError(",
            "            status=status_code,",
            "            body=error.messages,",
            "            headers=error_headers,",
            "            exception=error,",
            "        )",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        raise bottle.HTTPError(",
            "            status=400, body={\"json\": [\"Invalid JSON body.\"]}, exception=error",
            "        )",
            "",
            "    def get_default_request(self):",
            "        \"\"\"Override to use bottle's thread-local request object by default.\"\"\"",
            "        return bottle.request",
            "",
            "",
            "parser = BottleParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Bottle request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    from bottle import route, run",
            "    from marshmallow import fields",
            "    from webargs.bottleparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "    @route('/', method='GET', apply=use_args(hello_args))",
            "    def index(args):",
            "        return 'Hello ' + args['name']",
            "",
            "    if __name__ == '__main__':",
            "        run(debug=True)",
            "\"\"\"",
            "import bottle",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "class BottleParser(core.Parser):",
            "    \"\"\"Bottle.py request argument parser.\"\"\"",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.query, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        # For consistency with other parsers' behavior, don't attempt to",
            "        #  parse if content-type is mismatched.",
            "        #  TODO: Make this check more specific",
            "        if core.is_json(req.content_type):",
            "            return core.missing",
            "        return core.get_value(req.forms, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            try:",
            "                self._cache[\"json\"] = json_data = req.json",
            "            except AttributeError:",
            "                return core.missing",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "            except UnicodeDecodeError as e:",
            "                return self.handle_invalid_json_error(e, req)",
            "",
            "            if json_data is None:",
            "                return core.missing",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull a value from the cookiejar.\"\"\"",
            "        return req.get_cookie(name)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        return core.get_value(req.files, name, field)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current request with a",
            "        400 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        raise bottle.HTTPError(",
            "            status=status_code,",
            "            body=error.messages,",
            "            headers=error_headers,",
            "            exception=error,",
            "        )",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        raise bottle.HTTPError(",
            "            status=400, body={\"json\": [\"Invalid JSON body.\"]}, exception=error",
            "        )",
            "",
            "    def get_default_request(self):",
            "        \"\"\"Override to use bottle's thread-local request object by default.\"\"\"",
            "        return bottle.request",
            "",
            "",
            "parser = BottleParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.compute.test_compute_mgr.ComputeManagerMigrationTestCase.test_live_migration_abort_not_supported"
        ]
    },
    "src/webargs/djangoparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         \"\"\"Pull a json value from the request body.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         json_data = self._cache.get(\"json\")"
            },
            "2": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         if json_data is None:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            if not core.is_json(req.content_type):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+                return core.missing"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             try:"
            },
            "7": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 self._cache[\"json\"] = json_data = core.parse_json(req.body)"
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             except AttributeError:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Django request argument parsing.",
            "",
            "Example usage: ::",
            "",
            "    from django.views.generic import View",
            "    from django.http import HttpResponse",
            "    from marshmallow import fields",
            "    from webargs.djangoparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    class MyView(View):",
            "",
            "        @use_args(hello_args)",
            "        def get(self, args, request):",
            "            return HttpResponse('Hello ' + args['name'])",
            "\"\"\"",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "class DjangoParser(core.Parser):",
            "    \"\"\"Django request argument parser.",
            "",
            "    .. warning::",
            "",
            "        :class:`DjangoParser` does not override",
            "        :meth:`handle_error <webargs.core.Parser.handle_error>`, so your Django",
            "        views are responsible for catching any :exc:`ValidationErrors` raised by",
            "        the parser and returning the appropriate `HTTPResponse`.",
            "    \"\"\"",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull the querystring value from the request.\"\"\"",
            "        return core.get_value(req.GET, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull the form value from the request.\"\"\"",
            "        return core.get_value(req.POST, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request body.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(req.body)",
            "            except AttributeError:",
            "                return core.missing",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull the value from the cookiejar.\"\"\"",
            "        return core.get_value(req.COOKIES, name, field)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        raise NotImplementedError(",
            "            \"Header parsing not supported by {0}\".format(self.__class__.__name__)",
            "        )",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        return core.get_value(req.FILES, name, field)",
            "",
            "    def get_request_from_view_args(self, view, args, kwargs):",
            "        # The first argument is either `self` or `request`",
            "        try:  # self.request",
            "            return args[0].request",
            "        except AttributeError:  # first arg is request",
            "            return args[0]",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        raise error",
            "",
            "",
            "parser = DjangoParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Django request argument parsing.",
            "",
            "Example usage: ::",
            "",
            "    from django.views.generic import View",
            "    from django.http import HttpResponse",
            "    from marshmallow import fields",
            "    from webargs.djangoparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    class MyView(View):",
            "",
            "        @use_args(hello_args)",
            "        def get(self, args, request):",
            "            return HttpResponse('Hello ' + args['name'])",
            "\"\"\"",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "class DjangoParser(core.Parser):",
            "    \"\"\"Django request argument parser.",
            "",
            "    .. warning::",
            "",
            "        :class:`DjangoParser` does not override",
            "        :meth:`handle_error <webargs.core.Parser.handle_error>`, so your Django",
            "        views are responsible for catching any :exc:`ValidationErrors` raised by",
            "        the parser and returning the appropriate `HTTPResponse`.",
            "    \"\"\"",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull the querystring value from the request.\"\"\"",
            "        return core.get_value(req.GET, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull the form value from the request.\"\"\"",
            "        return core.get_value(req.POST, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request body.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            if not core.is_json(req.content_type):",
            "                return core.missing",
            "",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(req.body)",
            "            except AttributeError:",
            "                return core.missing",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull the value from the cookiejar.\"\"\"",
            "        return core.get_value(req.COOKIES, name, field)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        raise NotImplementedError(",
            "            \"Header parsing not supported by {0}\".format(self.__class__.__name__)",
            "        )",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        return core.get_value(req.FILES, name, field)",
            "",
            "    def get_request_from_view_args(self, view, args, kwargs):",
            "        # The first argument is either `self` or `request`",
            "        try:  # self.request",
            "            return args[0].request",
            "        except AttributeError:  # first arg is request",
            "            return args[0]",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        raise error",
            "",
            "",
            "parser = DjangoParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.compute.test_compute_mgr.ComputeManagerMigrationTestCase.test_live_migration_abort_not_supported"
        ]
    },
    "src/webargs/flaskparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         \"\"\"Pull a json value from the request.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         json_data = self._cache.get(\"json\")"
            },
            "2": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         if json_data is None:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            if not is_json_request(req):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                return core.missing"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "             # We decode the json manually here instead of"
            },
            "7": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "             # using req.get_json() so that we can handle"
            },
            "8": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             # JSONDecodeErrors consistently"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Flask request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    from flask import Flask",
            "",
            "    from webargs import fields",
            "    from webargs.flaskparser import use_args",
            "",
            "    app = Flask(__name__)",
            "",
            "    hello_args = {",
            "        'name': fields.Str(required=True)",
            "    }",
            "",
            "    @app.route('/')",
            "    @use_args(hello_args)",
            "    def index(args):",
            "        return 'Hello ' + args['name']",
            "\"\"\"",
            "import flask",
            "from werkzeug.exceptions import HTTPException",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "def abort(http_status_code, exc=None, **kwargs):",
            "    \"\"\"Raise a HTTPException for the given http_status_code. Attach any keyword",
            "    arguments to the exception for later processing.",
            "",
            "    From Flask-Restful. See NOTICE file for license information.",
            "    \"\"\"",
            "    try:",
            "        flask.abort(http_status_code)",
            "    except HTTPException as err:",
            "        err.data = kwargs",
            "        err.exc = exc",
            "        raise err",
            "",
            "",
            "def is_json_request(req):",
            "    return core.is_json(req.mimetype)",
            "",
            "",
            "class FlaskParser(core.Parser):",
            "    \"\"\"Flask request argument parser.\"\"\"",
            "",
            "    __location_map__ = dict(",
            "        view_args=\"parse_view_args\",",
            "        path=\"parse_view_args\",",
            "        **core.Parser.__location_map__",
            "    )",
            "",
            "    def parse_view_args(self, req, name, field):",
            "        \"\"\"Pull a value from the request's ``view_args``.\"\"\"",
            "        return core.get_value(req.view_args, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            # We decode the json manually here instead of",
            "            # using req.get_json() so that we can handle",
            "            # JSONDecodeErrors consistently",
            "            data = req.get_data(cache=True)",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(data)",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.args, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        try:",
            "            return core.get_value(req.form, name, field)",
            "        except AttributeError:",
            "            pass",
            "        return core.missing",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull a value from the cookiejar.\"\"\"",
            "        return core.get_value(req.cookies, name, field)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        return core.get_value(req.files, name, field)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current HTTP request and",
            "        responds with a 422 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        abort(",
            "            status_code,",
            "            exc=error,",
            "            messages=error.messages,",
            "            schema=schema,",
            "            headers=error_headers,",
            "        )",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        abort(400, exc=error, messages={\"json\": [\"Invalid JSON body.\"]})",
            "",
            "    def get_default_request(self):",
            "        \"\"\"Override to use Flask's thread-local request objec by default\"\"\"",
            "        return flask.request",
            "",
            "",
            "parser = FlaskParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Flask request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    from flask import Flask",
            "",
            "    from webargs import fields",
            "    from webargs.flaskparser import use_args",
            "",
            "    app = Flask(__name__)",
            "",
            "    hello_args = {",
            "        'name': fields.Str(required=True)",
            "    }",
            "",
            "    @app.route('/')",
            "    @use_args(hello_args)",
            "    def index(args):",
            "        return 'Hello ' + args['name']",
            "\"\"\"",
            "import flask",
            "from werkzeug.exceptions import HTTPException",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "def abort(http_status_code, exc=None, **kwargs):",
            "    \"\"\"Raise a HTTPException for the given http_status_code. Attach any keyword",
            "    arguments to the exception for later processing.",
            "",
            "    From Flask-Restful. See NOTICE file for license information.",
            "    \"\"\"",
            "    try:",
            "        flask.abort(http_status_code)",
            "    except HTTPException as err:",
            "        err.data = kwargs",
            "        err.exc = exc",
            "        raise err",
            "",
            "",
            "def is_json_request(req):",
            "    return core.is_json(req.mimetype)",
            "",
            "",
            "class FlaskParser(core.Parser):",
            "    \"\"\"Flask request argument parser.\"\"\"",
            "",
            "    __location_map__ = dict(",
            "        view_args=\"parse_view_args\",",
            "        path=\"parse_view_args\",",
            "        **core.Parser.__location_map__",
            "    )",
            "",
            "    def parse_view_args(self, req, name, field):",
            "        \"\"\"Pull a value from the request's ``view_args``.\"\"\"",
            "        return core.get_value(req.view_args, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            if not is_json_request(req):",
            "                return core.missing",
            "",
            "            # We decode the json manually here instead of",
            "            # using req.get_json() so that we can handle",
            "            # JSONDecodeErrors consistently",
            "            data = req.get_data(cache=True)",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(data)",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.args, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        try:",
            "            return core.get_value(req.form, name, field)",
            "        except AttributeError:",
            "            pass",
            "        return core.missing",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull a value from the cookiejar.\"\"\"",
            "        return core.get_value(req.cookies, name, field)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        return core.get_value(req.files, name, field)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current HTTP request and",
            "        responds with a 422 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        abort(",
            "            status_code,",
            "            exc=error,",
            "            messages=error.messages,",
            "            schema=schema,",
            "            headers=error_headers,",
            "        )",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        abort(400, exc=error, messages={\"json\": [\"Invalid JSON body.\"]})",
            "",
            "    def get_default_request(self):",
            "        \"\"\"Override to use Flask's thread-local request objec by default\"\"\"",
            "        return flask.request",
            "",
            "",
            "parser = FlaskParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.compute.test_compute_mgr.ComputeManagerMigrationTestCase.test_live_migration_abort_not_supported"
        ]
    },
    "src/webargs/pyramidparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         \"\"\"Pull a json value from the request.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         json_data = self._cache.get(\"json\")"
            },
            "2": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         if json_data is None:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            if not core.is_json(req.content_type):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                return core.missing"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             try:"
            },
            "7": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "                 self._cache[\"json\"] = json_data = core.parse_json(req.body, req.charset)"
            },
            "8": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "             except json.JSONDecodeError as e:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Pyramid request argument parsing.",
            "",
            "Example usage: ::",
            "",
            "    from wsgiref.simple_server import make_server",
            "    from pyramid.config import Configurator",
            "    from pyramid.response import Response",
            "    from marshmallow import fields",
            "    from webargs.pyramidparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    @use_args(hello_args)",
            "    def hello_world(request, args):",
            "        return Response('Hello ' + args['name'])",
            "",
            "    if __name__ == '__main__':",
            "        config = Configurator()",
            "        config.add_route('hello', '/')",
            "        config.add_view(hello_world, route_name='hello')",
            "        app = config.make_wsgi_app()",
            "        server = make_server('0.0.0.0', 6543, app)",
            "        server.serve_forever()",
            "\"\"\"",
            "import collections",
            "import functools",
            "",
            "from webob.multidict import MultiDict",
            "from pyramid.httpexceptions import exception_response",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "from webargs.compat import text_type",
            "",
            "",
            "class PyramidParser(core.Parser):",
            "    \"\"\"Pyramid request argument parser.\"\"\"",
            "",
            "    __location_map__ = dict(",
            "        matchdict=\"parse_matchdict\",",
            "        path=\"parse_matchdict\",",
            "        **core.Parser.__location_map__",
            "    )",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.GET, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        return core.get_value(req.POST, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(req.body, req.charset)",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "            if json_data is None:",
            "                return core.missing",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull the value from the cookiejar.\"\"\"",
            "        return core.get_value(req.cookies, name, field)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))",
            "        return core.get_value(MultiDict(files), name, field)",
            "",
            "    def parse_matchdict(self, req, name, field):",
            "        \"\"\"Pull a value from the request's `matchdict`.\"\"\"",
            "        return core.get_value(req.matchdict, name, field)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current HTTP request and",
            "        responds with a 400 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        response = exception_response(",
            "            status_code,",
            "            detail=text_type(error),",
            "            headers=error_headers,",
            "            content_type=\"application/json\",",
            "        )",
            "        body = json.dumps(error.messages)",
            "        response.body = body.encode(\"utf-8\") if isinstance(body, text_type) else body",
            "        raise response",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        messages = {\"json\": [\"Invalid JSON body.\"]}",
            "        response = exception_response(",
            "            400, detail=text_type(messages), content_type=\"application/json\"",
            "        )",
            "        body = json.dumps(messages)",
            "        response.body = body.encode(\"utf-8\") if isinstance(body, text_type) else body",
            "        raise response",
            "",
            "    def use_args(",
            "        self,",
            "        argmap,",
            "        req=None,",
            "        locations=core.Parser.DEFAULT_LOCATIONS,",
            "        as_kwargs=False,",
            "        validate=None,",
            "        error_status_code=None,",
            "        error_headers=None,",
            "    ):",
            "        \"\"\"Decorator that injects parsed arguments into a view callable.",
            "        Supports the *Class-based View* pattern where `request` is saved as an instance",
            "        attribute on a view class.",
            "",
            "        :param dict argmap: Either a `marshmallow.Schema`, a `dict`",
            "            of argname -> `marshmallow.fields.Field` pairs, or a callable",
            "            which accepts a request and returns a `marshmallow.Schema`.",
            "        :param req: The request object to parse. Pulled off of the view by default.",
            "        :param tuple locations: Where on the request to search for values.",
            "        :param bool as_kwargs: Whether to insert arguments as keyword arguments.",
            "        :param callable validate: Validation function that receives the dictionary",
            "            of parsed arguments. If the function returns ``False``, the parser",
            "            will raise a :exc:`ValidationError`.",
            "        :param int error_status_code: Status code passed to error handler functions when",
            "            a `ValidationError` is raised.",
            "        :param dict error_headers: Headers passed to error handler functions when a",
            "            a `ValidationError` is raised.",
            "        \"\"\"",
            "        locations = locations or self.locations",
            "        # Optimization: If argmap is passed as a dictionary, we only need",
            "        # to generate a Schema once",
            "        if isinstance(argmap, collections.Mapping):",
            "            argmap = core.dict2schema(argmap, self.schema_class)()",
            "",
            "        def decorator(func):",
            "            @functools.wraps(func)",
            "            def wrapper(obj, *args, **kwargs):",
            "                # The first argument is either `self` or `request`",
            "                try:  # get self.request",
            "                    request = req or obj.request",
            "                except AttributeError:  # first arg is request",
            "                    request = obj",
            "                # NOTE: At this point, argmap may be a Schema, callable, or dict",
            "                parsed_args = self.parse(",
            "                    argmap,",
            "                    req=request,",
            "                    locations=locations,",
            "                    validate=validate,",
            "                    error_status_code=error_status_code,",
            "                    error_headers=error_headers,",
            "                )",
            "                if as_kwargs:",
            "                    kwargs.update(parsed_args)",
            "                    return func(obj, *args, **kwargs)",
            "                else:",
            "                    return func(obj, parsed_args, *args, **kwargs)",
            "",
            "            wrapper.__wrapped__ = func",
            "            return wrapper",
            "",
            "        return decorator",
            "",
            "",
            "parser = PyramidParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Pyramid request argument parsing.",
            "",
            "Example usage: ::",
            "",
            "    from wsgiref.simple_server import make_server",
            "    from pyramid.config import Configurator",
            "    from pyramid.response import Response",
            "    from marshmallow import fields",
            "    from webargs.pyramidparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    @use_args(hello_args)",
            "    def hello_world(request, args):",
            "        return Response('Hello ' + args['name'])",
            "",
            "    if __name__ == '__main__':",
            "        config = Configurator()",
            "        config.add_route('hello', '/')",
            "        config.add_view(hello_world, route_name='hello')",
            "        app = config.make_wsgi_app()",
            "        server = make_server('0.0.0.0', 6543, app)",
            "        server.serve_forever()",
            "\"\"\"",
            "import collections",
            "import functools",
            "",
            "from webob.multidict import MultiDict",
            "from pyramid.httpexceptions import exception_response",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "from webargs.compat import text_type",
            "",
            "",
            "class PyramidParser(core.Parser):",
            "    \"\"\"Pyramid request argument parser.\"\"\"",
            "",
            "    __location_map__ = dict(",
            "        matchdict=\"parse_matchdict\",",
            "        path=\"parse_matchdict\",",
            "        **core.Parser.__location_map__",
            "    )",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.GET, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        return core.get_value(req.POST, name, field)",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            if not core.is_json(req.content_type):",
            "                return core.missing",
            "",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(req.body, req.charset)",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    return self.handle_invalid_json_error(e, req)",
            "            if json_data is None:",
            "                return core.missing",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull the value from the cookiejar.\"\"\"",
            "        return core.get_value(req.cookies, name, field)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))",
            "        return core.get_value(MultiDict(files), name, field)",
            "",
            "    def parse_matchdict(self, req, name, field):",
            "        \"\"\"Pull a value from the request's `matchdict`.\"\"\"",
            "        return core.get_value(req.matchdict, name, field)",
            "",
            "    def handle_error(self, error, req, schema, error_status_code, error_headers):",
            "        \"\"\"Handles errors during parsing. Aborts the current HTTP request and",
            "        responds with a 400 error.",
            "        \"\"\"",
            "        status_code = error_status_code or self.DEFAULT_VALIDATION_STATUS",
            "        response = exception_response(",
            "            status_code,",
            "            detail=text_type(error),",
            "            headers=error_headers,",
            "            content_type=\"application/json\",",
            "        )",
            "        body = json.dumps(error.messages)",
            "        response.body = body.encode(\"utf-8\") if isinstance(body, text_type) else body",
            "        raise response",
            "",
            "    def handle_invalid_json_error(self, error, req, *args, **kwargs):",
            "        messages = {\"json\": [\"Invalid JSON body.\"]}",
            "        response = exception_response(",
            "            400, detail=text_type(messages), content_type=\"application/json\"",
            "        )",
            "        body = json.dumps(messages)",
            "        response.body = body.encode(\"utf-8\") if isinstance(body, text_type) else body",
            "        raise response",
            "",
            "    def use_args(",
            "        self,",
            "        argmap,",
            "        req=None,",
            "        locations=core.Parser.DEFAULT_LOCATIONS,",
            "        as_kwargs=False,",
            "        validate=None,",
            "        error_status_code=None,",
            "        error_headers=None,",
            "    ):",
            "        \"\"\"Decorator that injects parsed arguments into a view callable.",
            "        Supports the *Class-based View* pattern where `request` is saved as an instance",
            "        attribute on a view class.",
            "",
            "        :param dict argmap: Either a `marshmallow.Schema`, a `dict`",
            "            of argname -> `marshmallow.fields.Field` pairs, or a callable",
            "            which accepts a request and returns a `marshmallow.Schema`.",
            "        :param req: The request object to parse. Pulled off of the view by default.",
            "        :param tuple locations: Where on the request to search for values.",
            "        :param bool as_kwargs: Whether to insert arguments as keyword arguments.",
            "        :param callable validate: Validation function that receives the dictionary",
            "            of parsed arguments. If the function returns ``False``, the parser",
            "            will raise a :exc:`ValidationError`.",
            "        :param int error_status_code: Status code passed to error handler functions when",
            "            a `ValidationError` is raised.",
            "        :param dict error_headers: Headers passed to error handler functions when a",
            "            a `ValidationError` is raised.",
            "        \"\"\"",
            "        locations = locations or self.locations",
            "        # Optimization: If argmap is passed as a dictionary, we only need",
            "        # to generate a Schema once",
            "        if isinstance(argmap, collections.Mapping):",
            "            argmap = core.dict2schema(argmap, self.schema_class)()",
            "",
            "        def decorator(func):",
            "            @functools.wraps(func)",
            "            def wrapper(obj, *args, **kwargs):",
            "                # The first argument is either `self` or `request`",
            "                try:  # get self.request",
            "                    request = req or obj.request",
            "                except AttributeError:  # first arg is request",
            "                    request = obj",
            "                # NOTE: At this point, argmap may be a Schema, callable, or dict",
            "                parsed_args = self.parse(",
            "                    argmap,",
            "                    req=request,",
            "                    locations=locations,",
            "                    validate=validate,",
            "                    error_status_code=error_status_code,",
            "                    error_headers=error_headers,",
            "                )",
            "                if as_kwargs:",
            "                    kwargs.update(parsed_args)",
            "                    return func(obj, *args, **kwargs)",
            "                else:",
            "                    return func(obj, parsed_args, *args, **kwargs)",
            "",
            "            wrapper.__wrapped__ = func",
            "            return wrapper",
            "",
            "        return decorator",
            "",
            "",
            "parser = PyramidParser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.compute.test_compute_mgr.ComputeManagerMigrationTestCase.test_live_migration_abort_not_supported"
        ]
    },
    "src/webargs/testing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "         )"
            },
            "1": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "         assert res.status_code == 400"
            },
            "2": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         assert res.json == {\"json\": [\"Invalid JSON body.\"]}"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    @pytest.mark.parametrize("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        (\"path\", \"payload\", \"content_type\"),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        ["
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            ("
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                \"/echo_json\","
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                json.dumps({\"name\": \"foo\"}),"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+                \"application/x-www-form-urlencoded\","
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+            ),"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+            (\"/echo_form\", {\"name\": \"foo\"}, \"application/json\"),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        ],"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+    )"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+    def test_content_type_mismatch(self, testapp, path, payload, content_type):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+        res = testapp.post(path, payload, headers={\"Content-Type\": content_type})"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+        assert res.json == {\"name\": \"World\"}"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Utilities for testing. Includes a base test class",
            "for testing parsers.",
            "",
            ".. warning::",
            "",
            "    Methods and functions in this module may change without",
            "    warning and without a major version change.",
            "\"\"\"",
            "import pytest",
            "import webtest",
            "",
            "from webargs.core import json",
            "",
            "",
            "class CommonTestCase(object):",
            "    \"\"\"Base test class that defines test methods for common functionality across all",
            "    parsers. Subclasses must define `create_app`, which returns a WSGI-like app.",
            "    \"\"\"",
            "",
            "    def create_app(self):",
            "        \"\"\"Return a WSGI app\"\"\"",
            "        raise NotImplementedError(\"Must define create_app()\")",
            "",
            "    def create_testapp(self, app):",
            "        return webtest.TestApp(app)",
            "",
            "    def before_create_app(self):",
            "        pass",
            "",
            "    def after_create_app(self):",
            "        pass",
            "",
            "    @pytest.fixture(scope=\"class\")",
            "    def testapp(self):",
            "        self.before_create_app()",
            "        yield self.create_testapp(self.create_app())",
            "        self.after_create_app()",
            "",
            "    def test_parse_querystring_args(self, testapp):",
            "        assert testapp.get(\"/echo?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_parse_querystring_with_query_location_specified(self, testapp):",
            "        assert testapp.get(\"/echo_query?name=Steve\").json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_form(self, testapp):",
            "        assert testapp.post(\"/echo\", {\"name\": \"Joe\"}).json == {\"name\": \"Joe\"}",
            "",
            "    def test_parse_json(self, testapp):",
            "        assert testapp.post_json(\"/echo\", {\"name\": \"Fred\"}).json == {\"name\": \"Fred\"}",
            "",
            "    def test_parse_querystring_default(self, testapp):",
            "        assert testapp.get(\"/echo\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_default(self, testapp):",
            "        assert testapp.post_json(\"/echo\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_with_charset(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_json_with_vendor_media_type(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/vnd.api+json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_json_ignores_extra_data(self, testapp):",
            "        assert testapp.post_json(\"/echo\", {\"extra\": \"data\"}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_blank(self, testapp):",
            "        assert testapp.post_json(\"/echo\", None).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_ignore_unexpected_int(self, testapp):",
            "        assert testapp.post_json(\"/echo\", 1).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_ignore_unexpected_list(self, testapp):",
            "        assert testapp.post_json(\"/echo\", [{\"extra\": \"data\"}]).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_many_schema_invalid_input(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_many_schema\", [{\"name\": \"a\"}], expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_many_schema(self, testapp):",
            "        res = testapp.post_json(\"/echo_many_schema\", [{\"name\": \"Steve\"}]).json",
            "        assert res == [{\"name\": \"Steve\"}]",
            "",
            "    def test_parse_json_many_schema_ignore_malformed_data(self, testapp):",
            "        assert testapp.post_json(\"/echo_many_schema\", {\"extra\": \"data\"}).json == []",
            "",
            "    def test_parsing_form_default(self, testapp):",
            "        assert testapp.post(\"/echo\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_querystring_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert testapp.get(\"/echo_multi?name=steve&name=Loria\").json == expected",
            "",
            "    def test_parse_form_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert (",
            "            testapp.post(\"/echo_multi\", {\"name\": [\"steve\", \"Loria\"]}).json == expected",
            "        )",
            "",
            "    def test_parse_json_list(self, testapp):",
            "        expected = {\"name\": [\"Steve\"]}",
            "        assert testapp.post_json(\"/echo_multi\", {\"name\": \"Steve\"}).json == expected",
            "",
            "    def test_parse_json_with_nonascii_chars(self, testapp):",
            "        text = u\"\u00f8\u02c6\u0192\u00a3\u00ba\u00ba\u2206\u0192\u02c6\u2206\"",
            "        assert testapp.post_json(\"/echo\", {\"name\": text}).json == {\"name\": text}",
            "",
            "    # https://github.com/marshmallow-code/webargs/issues/427",
            "    def test_parse_json_with_nonutf8_chars(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            b\"\\xfe\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}",
            "",
            "    def test_validation_error_returns_422_response(self, testapp):",
            "        res = testapp.post(\"/echo\", {\"name\": \"b\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_user_validation_error_returns_422_response_by_default(self, testapp):",
            "        res = testapp.post_json(\"/error\", {\"text\": \"foo\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_use_args_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_args?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_args_with_path_param(self, testapp):",
            "        url = \"/echo_use_args_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_use_args_with_validation(self, testapp):",
            "        result = testapp.post(\"/echo_use_args_validated\", {\"value\": 43})",
            "        assert result.status_code == 200",
            "        result = testapp.post(",
            "            \"/echo_use_args_validated\", {\"value\": 41}, expect_errors=True",
            "        )",
            "        assert result.status_code == 422",
            "",
            "    def test_use_kwargs_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_kwargs?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_kwargs_with_path_param(self, testapp):",
            "        url = \"/echo_use_kwargs_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_parsing_headers(self, testapp):",
            "        res = testapp.get(\"/echo_headers\", headers={\"name\": \"Fred\"})",
            "        assert res.json == {\"name\": \"Fred\"}",
            "",
            "    def test_parsing_cookies(self, testapp):",
            "        testapp.set_cookie(\"name\", \"Steve\")",
            "        res = testapp.get(\"/echo_cookie\")",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_nested_json(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_nested\", {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "        )",
            "        assert res.json == {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "",
            "    def test_parse_nested_many_json(self, testapp):",
            "        in_data = {\"users\": [{\"id\": 1, \"name\": \"foo\"}, {\"id\": 2, \"name\": \"bar\"}]}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == in_data",
            "",
            "    # Regression test for https://github.com/marshmallow-code/webargs/issues/120",
            "    def test_parse_nested_many_missing(self, testapp):",
            "        in_data = {}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == {}",
            "",
            "    def test_parse_json_if_no_json(self, testapp):",
            "        res = testapp.post(\"/echo\")",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    def test_parse_files(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_file\", {\"myfile\": webtest.Upload(\"README.rst\", b\"data\")}",
            "        )",
            "        assert res.json == {\"myfile\": \"data\"}",
            "",
            "    # https://github.com/sloria/webargs/pull/297",
            "    def test_empty_json(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            \"\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "        )",
            "        assert res.status_code == 200",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    # https://github.com/sloria/webargs/issues/329",
            "    def test_invalid_json(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            '{\"foo\": \"bar\", }',",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Utilities for testing. Includes a base test class",
            "for testing parsers.",
            "",
            ".. warning::",
            "",
            "    Methods and functions in this module may change without",
            "    warning and without a major version change.",
            "\"\"\"",
            "import pytest",
            "import webtest",
            "",
            "from webargs.core import json",
            "",
            "",
            "class CommonTestCase(object):",
            "    \"\"\"Base test class that defines test methods for common functionality across all",
            "    parsers. Subclasses must define `create_app`, which returns a WSGI-like app.",
            "    \"\"\"",
            "",
            "    def create_app(self):",
            "        \"\"\"Return a WSGI app\"\"\"",
            "        raise NotImplementedError(\"Must define create_app()\")",
            "",
            "    def create_testapp(self, app):",
            "        return webtest.TestApp(app)",
            "",
            "    def before_create_app(self):",
            "        pass",
            "",
            "    def after_create_app(self):",
            "        pass",
            "",
            "    @pytest.fixture(scope=\"class\")",
            "    def testapp(self):",
            "        self.before_create_app()",
            "        yield self.create_testapp(self.create_app())",
            "        self.after_create_app()",
            "",
            "    def test_parse_querystring_args(self, testapp):",
            "        assert testapp.get(\"/echo?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_parse_querystring_with_query_location_specified(self, testapp):",
            "        assert testapp.get(\"/echo_query?name=Steve\").json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_form(self, testapp):",
            "        assert testapp.post(\"/echo\", {\"name\": \"Joe\"}).json == {\"name\": \"Joe\"}",
            "",
            "    def test_parse_json(self, testapp):",
            "        assert testapp.post_json(\"/echo\", {\"name\": \"Fred\"}).json == {\"name\": \"Fred\"}",
            "",
            "    def test_parse_querystring_default(self, testapp):",
            "        assert testapp.get(\"/echo\").json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_default(self, testapp):",
            "        assert testapp.post_json(\"/echo\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_with_charset(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_json_with_vendor_media_type(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            json.dumps({\"name\": \"Steve\"}),",
            "            content_type=\"application/vnd.api+json;charset=UTF-8\",",
            "        )",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_json_ignores_extra_data(self, testapp):",
            "        assert testapp.post_json(\"/echo\", {\"extra\": \"data\"}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_blank(self, testapp):",
            "        assert testapp.post_json(\"/echo\", None).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_ignore_unexpected_int(self, testapp):",
            "        assert testapp.post_json(\"/echo\", 1).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_ignore_unexpected_list(self, testapp):",
            "        assert testapp.post_json(\"/echo\", [{\"extra\": \"data\"}]).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_json_many_schema_invalid_input(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_many_schema\", [{\"name\": \"a\"}], expect_errors=True",
            "        )",
            "        assert res.status_code == 422",
            "",
            "    def test_parse_json_many_schema(self, testapp):",
            "        res = testapp.post_json(\"/echo_many_schema\", [{\"name\": \"Steve\"}]).json",
            "        assert res == [{\"name\": \"Steve\"}]",
            "",
            "    def test_parse_json_many_schema_ignore_malformed_data(self, testapp):",
            "        assert testapp.post_json(\"/echo_many_schema\", {\"extra\": \"data\"}).json == []",
            "",
            "    def test_parsing_form_default(self, testapp):",
            "        assert testapp.post(\"/echo\", {}).json == {\"name\": \"World\"}",
            "",
            "    def test_parse_querystring_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert testapp.get(\"/echo_multi?name=steve&name=Loria\").json == expected",
            "",
            "    def test_parse_form_multiple(self, testapp):",
            "        expected = {\"name\": [\"steve\", \"Loria\"]}",
            "        assert (",
            "            testapp.post(\"/echo_multi\", {\"name\": [\"steve\", \"Loria\"]}).json == expected",
            "        )",
            "",
            "    def test_parse_json_list(self, testapp):",
            "        expected = {\"name\": [\"Steve\"]}",
            "        assert testapp.post_json(\"/echo_multi\", {\"name\": \"Steve\"}).json == expected",
            "",
            "    def test_parse_json_with_nonascii_chars(self, testapp):",
            "        text = u\"\u00f8\u02c6\u0192\u00a3\u00ba\u00ba\u2206\u0192\u02c6\u2206\"",
            "        assert testapp.post_json(\"/echo\", {\"name\": text}).json == {\"name\": text}",
            "",
            "    # https://github.com/marshmallow-code/webargs/issues/427",
            "    def test_parse_json_with_nonutf8_chars(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            b\"\\xfe\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}",
            "",
            "    def test_validation_error_returns_422_response(self, testapp):",
            "        res = testapp.post(\"/echo\", {\"name\": \"b\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_user_validation_error_returns_422_response_by_default(self, testapp):",
            "        res = testapp.post_json(\"/error\", {\"text\": \"foo\"}, expect_errors=True)",
            "        assert res.status_code == 422",
            "",
            "    def test_use_args_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_args?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_args_with_path_param(self, testapp):",
            "        url = \"/echo_use_args_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_use_args_with_validation(self, testapp):",
            "        result = testapp.post(\"/echo_use_args_validated\", {\"value\": 43})",
            "        assert result.status_code == 200",
            "        result = testapp.post(",
            "            \"/echo_use_args_validated\", {\"value\": 41}, expect_errors=True",
            "        )",
            "        assert result.status_code == 422",
            "",
            "    def test_use_kwargs_decorator(self, testapp):",
            "        assert testapp.get(\"/echo_use_kwargs?name=Fred\").json == {\"name\": \"Fred\"}",
            "",
            "    def test_use_kwargs_with_path_param(self, testapp):",
            "        url = \"/echo_use_kwargs_with_path_param/foo\"",
            "        res = testapp.get(url + \"?value=42\")",
            "        assert res.json == {\"value\": 42}",
            "",
            "    def test_parsing_headers(self, testapp):",
            "        res = testapp.get(\"/echo_headers\", headers={\"name\": \"Fred\"})",
            "        assert res.json == {\"name\": \"Fred\"}",
            "",
            "    def test_parsing_cookies(self, testapp):",
            "        testapp.set_cookie(\"name\", \"Steve\")",
            "        res = testapp.get(\"/echo_cookie\")",
            "        assert res.json == {\"name\": \"Steve\"}",
            "",
            "    def test_parse_nested_json(self, testapp):",
            "        res = testapp.post_json(",
            "            \"/echo_nested\", {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "        )",
            "        assert res.json == {\"name\": {\"first\": \"Steve\", \"last\": \"Loria\"}}",
            "",
            "    def test_parse_nested_many_json(self, testapp):",
            "        in_data = {\"users\": [{\"id\": 1, \"name\": \"foo\"}, {\"id\": 2, \"name\": \"bar\"}]}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == in_data",
            "",
            "    # Regression test for https://github.com/marshmallow-code/webargs/issues/120",
            "    def test_parse_nested_many_missing(self, testapp):",
            "        in_data = {}",
            "        res = testapp.post_json(\"/echo_nested_many\", in_data)",
            "        assert res.json == {}",
            "",
            "    def test_parse_json_if_no_json(self, testapp):",
            "        res = testapp.post(\"/echo\")",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    def test_parse_files(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo_file\", {\"myfile\": webtest.Upload(\"README.rst\", b\"data\")}",
            "        )",
            "        assert res.json == {\"myfile\": \"data\"}",
            "",
            "    # https://github.com/sloria/webargs/pull/297",
            "    def test_empty_json(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            \"\",",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "        )",
            "        assert res.status_code == 200",
            "        assert res.json == {\"name\": \"World\"}",
            "",
            "    # https://github.com/sloria/webargs/issues/329",
            "    def test_invalid_json(self, testapp):",
            "        res = testapp.post(",
            "            \"/echo\",",
            "            '{\"foo\": \"bar\", }',",
            "            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},",
            "            expect_errors=True,",
            "        )",
            "        assert res.status_code == 400",
            "        assert res.json == {\"json\": [\"Invalid JSON body.\"]}",
            "",
            "    @pytest.mark.parametrize(",
            "        (\"path\", \"payload\", \"content_type\"),",
            "        [",
            "            (",
            "                \"/echo_json\",",
            "                json.dumps({\"name\": \"foo\"}),",
            "                \"application/x-www-form-urlencoded\",",
            "            ),",
            "            (\"/echo_form\", {\"name\": \"foo\"}, \"application/json\"),",
            "        ],",
            "    )",
            "    def test_content_type_mismatch(self, testapp, path, payload, content_type):",
            "        res = testapp.post(path, payload, headers={\"Content-Type\": content_type})",
            "        assert res.json == {\"name\": \"World\"}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.compute.test_compute_mgr.ComputeManagerMigrationTestCase.test_live_migration_abort_not_supported",
            "src.webargs.testing.CommonTestCase.self"
        ]
    },
    "src/webargs/webapp2parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         \"\"\"Pull a json value from the request.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         json_data = self._cache.get(\"json\")"
            },
            "2": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         if json_data is None:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            if not core.is_json(req.content_type):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                return core.missing"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             try:"
            },
            "7": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "                 self._cache[\"json\"] = json_data = core.parse_json(req.body)"
            },
            "8": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             except json.JSONDecodeError as e:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Webapp2 request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    import webapp2",
            "",
            "    from marshmallow import fields",
            "    from webargs.webobparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    class MainPage(webapp2.RequestHandler):",
            "",
            "        @use_args(hello_args)",
            "        def get_args(self, args):",
            "            self.response.write('Hello, {name}!'.format(name=args['name']))",
            "",
            "        @use_kwargs(hello_args)",
            "        def get_kwargs(self, name=None):",
            "            self.response.write('Hello, {name}!'.format(name=name))",
            "",
            "    app = webapp2.WSGIApplication([",
            "        webapp2.Route(r'/hello', MainPage, handler_method='get_args'),",
            "        webapp2.Route(r'/hello_dict', MainPage, handler_method='get_kwargs'),",
            "    ], debug=True)",
            "\"\"\"",
            "import webapp2",
            "import webob.multidict",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "class Webapp2Parser(core.Parser):",
            "    \"\"\"webapp2 request argument parser.\"\"\"",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(req.body)",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    raise",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.GET, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        return core.get_value(req.POST, name, field)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull the value from the cookiejar.\"\"\"",
            "        return core.get_value(req.cookies, name, field)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))",
            "        return core.get_value(webob.multidict.MultiDict(files), name, field)",
            "",
            "    def get_default_request(self):",
            "        return webapp2.get_request()",
            "",
            "",
            "parser = Webapp2Parser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"Webapp2 request argument parsing module.",
            "",
            "Example: ::",
            "",
            "    import webapp2",
            "",
            "    from marshmallow import fields",
            "    from webargs.webobparser import use_args",
            "",
            "    hello_args = {",
            "        'name': fields.Str(missing='World')",
            "    }",
            "",
            "    class MainPage(webapp2.RequestHandler):",
            "",
            "        @use_args(hello_args)",
            "        def get_args(self, args):",
            "            self.response.write('Hello, {name}!'.format(name=args['name']))",
            "",
            "        @use_kwargs(hello_args)",
            "        def get_kwargs(self, name=None):",
            "            self.response.write('Hello, {name}!'.format(name=name))",
            "",
            "    app = webapp2.WSGIApplication([",
            "        webapp2.Route(r'/hello', MainPage, handler_method='get_args'),",
            "        webapp2.Route(r'/hello_dict', MainPage, handler_method='get_kwargs'),",
            "    ], debug=True)",
            "\"\"\"",
            "import webapp2",
            "import webob.multidict",
            "",
            "from webargs import core",
            "from webargs.core import json",
            "",
            "",
            "class Webapp2Parser(core.Parser):",
            "    \"\"\"webapp2 request argument parser.\"\"\"",
            "",
            "    def parse_json(self, req, name, field):",
            "        \"\"\"Pull a json value from the request.\"\"\"",
            "        json_data = self._cache.get(\"json\")",
            "        if json_data is None:",
            "            if not core.is_json(req.content_type):",
            "                return core.missing",
            "",
            "            try:",
            "                self._cache[\"json\"] = json_data = core.parse_json(req.body)",
            "            except json.JSONDecodeError as e:",
            "                if e.doc == \"\":",
            "                    return core.missing",
            "                else:",
            "                    raise",
            "        return core.get_value(json_data, name, field, allow_many_nested=True)",
            "",
            "    def parse_querystring(self, req, name, field):",
            "        \"\"\"Pull a querystring value from the request.\"\"\"",
            "        return core.get_value(req.GET, name, field)",
            "",
            "    def parse_form(self, req, name, field):",
            "        \"\"\"Pull a form value from the request.\"\"\"",
            "        return core.get_value(req.POST, name, field)",
            "",
            "    def parse_cookies(self, req, name, field):",
            "        \"\"\"Pull the value from the cookiejar.\"\"\"",
            "        return core.get_value(req.cookies, name, field)",
            "",
            "    def parse_headers(self, req, name, field):",
            "        \"\"\"Pull a value from the header data.\"\"\"",
            "        return core.get_value(req.headers, name, field)",
            "",
            "    def parse_files(self, req, name, field):",
            "        \"\"\"Pull a file from the request.\"\"\"",
            "        files = ((k, v) for k, v in req.POST.items() if hasattr(v, \"file\"))",
            "        return core.get_value(webob.multidict.MultiDict(files), name, field)",
            "",
            "    def get_default_request(self):",
            "        return webapp2.get_request()",
            "",
            "",
            "parser = Webapp2Parser()",
            "use_args = parser.use_args",
            "use_kwargs = parser.use_kwargs"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.compute.test_compute_mgr.ComputeManagerMigrationTestCase.test_live_migration_abort_not_supported"
        ]
    }
}