{
    "flower/command.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from .urls import settings"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from .utils import abs_path, prepend_url"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from .options import DEFAULT_CONFIG_FILE, default_options"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from .views.auth import validate_auth_option"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " logger = logging.getLogger(__name__)"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " ENV_VAR_PREFIX = 'FLOWER_'"
            },
            "7": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         if options.ca_certs:"
            },
            "8": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "             settings['ssl_options']['ca_certs'] = abs_path(options.ca_certs)"
            },
            "9": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    if options.auth and not validate_auth_option(options.auth):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        logger.error(\"Invalid '--auth' option: %s\", options.auth)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        sys.exit(1)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " def is_flower_option(arg):"
            },
            "16": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     name, _, _ = arg.lstrip('-').partition(\"=\")"
            },
            "17": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         pformat(sorted(app.tasks.keys()))"
            },
            "18": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     )"
            },
            "19": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     logger.debug('Settings: %s', pformat(settings))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    if not (options.basic_auth or options.auth):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        logger.warning('Running without authentication')"
            }
        },
        "frontPatchFile": [
            "import os",
            "import sys",
            "import atexit",
            "import signal",
            "import logging",
            "",
            "from pprint import pformat",
            "",
            "from logging import NullHandler",
            "",
            "import click",
            "from tornado.options import options",
            "from tornado.options import parse_command_line, parse_config_file",
            "from tornado.log import enable_pretty_logging",
            "from celery.bin.base import CeleryCommand",
            "",
            "from .app import Flower",
            "from .urls import settings",
            "from .utils import abs_path, prepend_url",
            "from .options import DEFAULT_CONFIG_FILE, default_options",
            "",
            "logger = logging.getLogger(__name__)",
            "ENV_VAR_PREFIX = 'FLOWER_'",
            "",
            "",
            "@click.command(cls=CeleryCommand,",
            "               context_settings={",
            "                   'ignore_unknown_options': True",
            "               })",
            "@click.argument(\"tornado_argv\", nargs=-1, type=click.UNPROCESSED)",
            "@click.pass_context",
            "def flower(ctx, tornado_argv):",
            "    \"\"\"Web based tool for monitoring and administrating Celery clusters.\"\"\"",
            "    warn_about_celery_args_used_in_flower_command(ctx, tornado_argv)",
            "    apply_env_options()",
            "    apply_options(sys.argv[0], tornado_argv)",
            "",
            "    extract_settings()",
            "    setup_logging()",
            "",
            "    app = ctx.obj.app",
            "    flower = Flower(capp=app, options=options, **settings)",
            "",
            "    atexit.register(flower.stop)",
            "",
            "    def sigterm_handler(signal, frame):",
            "        logger.info('SIGTERM detected, shutting down')",
            "        sys.exit(0)",
            "",
            "    signal.signal(signal.SIGTERM, sigterm_handler)",
            "    print_banner(app, 'ssl_options' in settings)",
            "    try:",
            "        flower.start()",
            "    except (KeyboardInterrupt, SystemExit):",
            "        pass",
            "",
            "",
            "def apply_env_options():",
            "    \"apply options passed through environment variables\"",
            "    env_options = filter(is_flower_envvar, os.environ)",
            "    for env_var_name in env_options:",
            "        name = env_var_name.replace(ENV_VAR_PREFIX, '', 1).lower()",
            "        value = os.environ[env_var_name]",
            "        try:",
            "            option = options._options[name]",
            "        except KeyError:",
            "            option = options._options[name.replace('_', '-')]",
            "        if option.multiple:",
            "            value = [option.type(i) for i in value.split(',')]",
            "        else:",
            "            value = option.type(value)",
            "        setattr(options, name, value)",
            "",
            "",
            "def apply_options(prog_name, argv):",
            "    \"apply options passed through the configuration file\"",
            "    argv = list(filter(is_flower_option, argv))",
            "    # parse the command line to get --conf option",
            "    parse_command_line([prog_name] + argv)",
            "    try:",
            "        parse_config_file(os.path.abspath(options.conf), final=False)",
            "        parse_command_line([prog_name] + argv)",
            "    except IOError:",
            "        if os.path.basename(options.conf) != DEFAULT_CONFIG_FILE:",
            "            raise",
            "",
            "",
            "def warn_about_celery_args_used_in_flower_command(ctx, flower_args):",
            "    celery_options = [option for param in ctx.parent.command.params for option in param.opts]",
            "",
            "    incorrectly_used_args = []",
            "    for arg in flower_args:",
            "        arg_name, _, _ = arg.partition(\"=\")",
            "        if arg_name in celery_options:",
            "            incorrectly_used_args.append(arg_name)",
            "",
            "    if incorrectly_used_args:",
            "        logger.warning(",
            "            f'You have incorrectly specified the following celery arguments after flower command:'",
            "            f' {incorrectly_used_args}. '",
            "            f'Please specify them after celery command instead following this template: '",
            "            f'celery [celery args] flower [flower args].'",
            "        )",
            "",
            "",
            "def setup_logging():",
            "    if options.debug and options.logging == 'info':",
            "        options.logging = 'debug'",
            "        enable_pretty_logging()",
            "    else:",
            "        logging.getLogger(\"tornado.access\").addHandler(NullHandler())",
            "        logging.getLogger(\"tornado.access\").propagate = False",
            "",
            "",
            "def extract_settings():",
            "    settings['debug'] = options.debug",
            "",
            "    if options.cookie_secret:",
            "        settings['cookie_secret'] = options.cookie_secret",
            "",
            "    if options.url_prefix:",
            "        for name in ['login_url', 'static_url_prefix']:",
            "            settings[name] = prepend_url(settings[name], options.url_prefix)",
            "",
            "    if options.auth:",
            "        settings['oauth'] = {",
            "            'key': options.oauth2_key or os.environ.get('FLOWER_OAUTH2_KEY'),",
            "            'secret': options.oauth2_secret or os.environ.get('FLOWER_OAUTH2_SECRET'),",
            "            'redirect_uri': options.oauth2_redirect_uri or os.environ.get('FLOWER_OAUTH2_REDIRECT_URI'),",
            "        }",
            "",
            "    if options.certfile and options.keyfile:",
            "        settings['ssl_options'] = dict(certfile=abs_path(options.certfile),",
            "                                       keyfile=abs_path(options.keyfile))",
            "        if options.ca_certs:",
            "            settings['ssl_options']['ca_certs'] = abs_path(options.ca_certs)",
            "",
            "",
            "def is_flower_option(arg):",
            "    name, _, _ = arg.lstrip('-').partition(\"=\")",
            "    name = name.replace('-', '_')",
            "    return hasattr(options, name)",
            "",
            "",
            "def is_flower_envvar(name):",
            "    return name.startswith(ENV_VAR_PREFIX) and \\",
            "           name[len(ENV_VAR_PREFIX):].lower() in default_options",
            "",
            "",
            "def print_banner(app, ssl):",
            "    if not options.unix_socket:",
            "        if options.url_prefix:",
            "            prefix_str = f'/{options.url_prefix}/'",
            "        else:",
            "            prefix_str = ''",
            "",
            "        logger.info(",
            "            \"Visit me at http%s://%s:%s%s\", 's' if ssl else '',",
            "            options.address or 'localhost', options.port,",
            "            prefix_str",
            "        )",
            "    else:",
            "        logger.info(\"Visit me via unix socket file: %s\", options.unix_socket)",
            "",
            "    logger.info('Broker: %s', app.connection().as_uri())",
            "    logger.info(",
            "        'Registered tasks: \\n%s',",
            "        pformat(sorted(app.tasks.keys()))",
            "    )",
            "    logger.debug('Settings: %s', pformat(settings))"
        ],
        "afterPatchFile": [
            "import os",
            "import sys",
            "import atexit",
            "import signal",
            "import logging",
            "",
            "from pprint import pformat",
            "",
            "from logging import NullHandler",
            "",
            "import click",
            "from tornado.options import options",
            "from tornado.options import parse_command_line, parse_config_file",
            "from tornado.log import enable_pretty_logging",
            "from celery.bin.base import CeleryCommand",
            "",
            "from .app import Flower",
            "from .urls import settings",
            "from .utils import abs_path, prepend_url",
            "from .options import DEFAULT_CONFIG_FILE, default_options",
            "from .views.auth import validate_auth_option",
            "",
            "logger = logging.getLogger(__name__)",
            "ENV_VAR_PREFIX = 'FLOWER_'",
            "",
            "",
            "@click.command(cls=CeleryCommand,",
            "               context_settings={",
            "                   'ignore_unknown_options': True",
            "               })",
            "@click.argument(\"tornado_argv\", nargs=-1, type=click.UNPROCESSED)",
            "@click.pass_context",
            "def flower(ctx, tornado_argv):",
            "    \"\"\"Web based tool for monitoring and administrating Celery clusters.\"\"\"",
            "    warn_about_celery_args_used_in_flower_command(ctx, tornado_argv)",
            "    apply_env_options()",
            "    apply_options(sys.argv[0], tornado_argv)",
            "",
            "    extract_settings()",
            "    setup_logging()",
            "",
            "    app = ctx.obj.app",
            "    flower = Flower(capp=app, options=options, **settings)",
            "",
            "    atexit.register(flower.stop)",
            "",
            "    def sigterm_handler(signal, frame):",
            "        logger.info('SIGTERM detected, shutting down')",
            "        sys.exit(0)",
            "",
            "    signal.signal(signal.SIGTERM, sigterm_handler)",
            "    print_banner(app, 'ssl_options' in settings)",
            "    try:",
            "        flower.start()",
            "    except (KeyboardInterrupt, SystemExit):",
            "        pass",
            "",
            "",
            "def apply_env_options():",
            "    \"apply options passed through environment variables\"",
            "    env_options = filter(is_flower_envvar, os.environ)",
            "    for env_var_name in env_options:",
            "        name = env_var_name.replace(ENV_VAR_PREFIX, '', 1).lower()",
            "        value = os.environ[env_var_name]",
            "        try:",
            "            option = options._options[name]",
            "        except KeyError:",
            "            option = options._options[name.replace('_', '-')]",
            "        if option.multiple:",
            "            value = [option.type(i) for i in value.split(',')]",
            "        else:",
            "            value = option.type(value)",
            "        setattr(options, name, value)",
            "",
            "",
            "def apply_options(prog_name, argv):",
            "    \"apply options passed through the configuration file\"",
            "    argv = list(filter(is_flower_option, argv))",
            "    # parse the command line to get --conf option",
            "    parse_command_line([prog_name] + argv)",
            "    try:",
            "        parse_config_file(os.path.abspath(options.conf), final=False)",
            "        parse_command_line([prog_name] + argv)",
            "    except IOError:",
            "        if os.path.basename(options.conf) != DEFAULT_CONFIG_FILE:",
            "            raise",
            "",
            "",
            "def warn_about_celery_args_used_in_flower_command(ctx, flower_args):",
            "    celery_options = [option for param in ctx.parent.command.params for option in param.opts]",
            "",
            "    incorrectly_used_args = []",
            "    for arg in flower_args:",
            "        arg_name, _, _ = arg.partition(\"=\")",
            "        if arg_name in celery_options:",
            "            incorrectly_used_args.append(arg_name)",
            "",
            "    if incorrectly_used_args:",
            "        logger.warning(",
            "            f'You have incorrectly specified the following celery arguments after flower command:'",
            "            f' {incorrectly_used_args}. '",
            "            f'Please specify them after celery command instead following this template: '",
            "            f'celery [celery args] flower [flower args].'",
            "        )",
            "",
            "",
            "def setup_logging():",
            "    if options.debug and options.logging == 'info':",
            "        options.logging = 'debug'",
            "        enable_pretty_logging()",
            "    else:",
            "        logging.getLogger(\"tornado.access\").addHandler(NullHandler())",
            "        logging.getLogger(\"tornado.access\").propagate = False",
            "",
            "",
            "def extract_settings():",
            "    settings['debug'] = options.debug",
            "",
            "    if options.cookie_secret:",
            "        settings['cookie_secret'] = options.cookie_secret",
            "",
            "    if options.url_prefix:",
            "        for name in ['login_url', 'static_url_prefix']:",
            "            settings[name] = prepend_url(settings[name], options.url_prefix)",
            "",
            "    if options.auth:",
            "        settings['oauth'] = {",
            "            'key': options.oauth2_key or os.environ.get('FLOWER_OAUTH2_KEY'),",
            "            'secret': options.oauth2_secret or os.environ.get('FLOWER_OAUTH2_SECRET'),",
            "            'redirect_uri': options.oauth2_redirect_uri or os.environ.get('FLOWER_OAUTH2_REDIRECT_URI'),",
            "        }",
            "",
            "    if options.certfile and options.keyfile:",
            "        settings['ssl_options'] = dict(certfile=abs_path(options.certfile),",
            "                                       keyfile=abs_path(options.keyfile))",
            "        if options.ca_certs:",
            "            settings['ssl_options']['ca_certs'] = abs_path(options.ca_certs)",
            "",
            "    if options.auth and not validate_auth_option(options.auth):",
            "        logger.error(\"Invalid '--auth' option: %s\", options.auth)",
            "        sys.exit(1)",
            "",
            "",
            "def is_flower_option(arg):",
            "    name, _, _ = arg.lstrip('-').partition(\"=\")",
            "    name = name.replace('-', '_')",
            "    return hasattr(options, name)",
            "",
            "",
            "def is_flower_envvar(name):",
            "    return name.startswith(ENV_VAR_PREFIX) and \\",
            "           name[len(ENV_VAR_PREFIX):].lower() in default_options",
            "",
            "",
            "def print_banner(app, ssl):",
            "    if not options.unix_socket:",
            "        if options.url_prefix:",
            "            prefix_str = f'/{options.url_prefix}/'",
            "        else:",
            "            prefix_str = ''",
            "",
            "        logger.info(",
            "            \"Visit me at http%s://%s:%s%s\", 's' if ssl else '',",
            "            options.address or 'localhost', options.port,",
            "            prefix_str",
            "        )",
            "    else:",
            "        logger.info(\"Visit me via unix socket file: %s\", options.unix_socket)",
            "",
            "    logger.info('Broker: %s', app.connection().as_uri())",
            "    logger.info(",
            "        'Registered tasks: \\n%s',",
            "        pformat(sorted(app.tasks.keys()))",
            "    )",
            "    logger.debug('Settings: %s', pformat(settings))",
            "    if not (options.basic_auth or options.auth):",
            "        logger.warning('Running without authentication')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "flower/options.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import types"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from secrets import token_urlsafe"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from prometheus_client import Histogram"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from tornado.options import define"
            },
            "5": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "        help=\"refresh dashboards\", type=bool)"
            },
            "6": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " define(\"purge_offline_workers\", default=None, type=int,"
            },
            "7": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "        help=\"time (in seconds) after which offline workers are purged from dashboard\")"
            },
            "8": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-define(\"cookie_secret\", type=str, default=None,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+define(\"cookie_secret\", type=str, default=token_urlsafe(64),"
            },
            "10": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "        help=\"secure cookie secret\")"
            },
            "11": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " define(\"conf\", default=DEFAULT_CONFIG_FILE,"
            },
            "12": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "        help=\"configuration file\")"
            }
        },
        "frontPatchFile": [
            "import types",
            "",
            "from prometheus_client import Histogram",
            "from tornado.options import define",
            "from tornado.options import options",
            "",
            "",
            "DEFAULT_CONFIG_FILE = 'flowerconfig.py'",
            "",
            "",
            "define(\"port\", default=5555,",
            "       help=\"run on the given port\", type=int)",
            "define(\"address\", default='',",
            "       help=\"run on the given address\", type=str)",
            "define(\"unix_socket\", default='',",
            "       help=\"path to unix socket to bind\", type=str)",
            "define(\"debug\", default=False,",
            "       help=\"run in debug mode\", type=bool)",
            "define(\"inspect_timeout\", default=1000, type=float,",
            "       help=\"inspect timeout (in milliseconds)\")",
            "define(\"auth\", default='', type=str,",
            "       help=\"regexp of emails to grant access\")",
            "define(\"basic_auth\", type=str, default=None, multiple=True,",
            "       help=\"enable http basic authentication\")",
            "define(\"oauth2_key\", type=str, default=None,",
            "       help=\"OAuth2 key (requires --auth)\")",
            "define(\"oauth2_secret\", type=str, default=None,",
            "       help=\"OAuth2 secret (requires --auth)\")",
            "define(\"oauth2_redirect_uri\", type=str, default=None,",
            "       help=\"OAuth2 redirect uri (requires --auth)\")",
            "define(\"max_workers\", type=int, default=5000,",
            "       help=\"maximum number of workers to keep in memory\")",
            "define(\"max_tasks\", type=int, default=10000,",
            "       help=\"maximum number of tasks to keep in memory\")",
            "define(\"db\", type=str, default='flower',",
            "       help=\"flower database file\")",
            "define(\"persistent\", type=bool, default=False,",
            "       help=\"enable persistent mode\")",
            "define(\"state_save_interval\", type=int, default=0,",
            "       help=\"state save interval (in milliseconds)\")",
            "define(\"broker_api\", type=str, default=None,",
            "       help=\"inspect broker e.g. http://guest:guest@localhost:15672/api/\")",
            "define(\"ca_certs\", type=str, default=None,",
            "       help=\"SSL certificate authority (CA) file\")",
            "define(\"certfile\", type=str, default=None,",
            "       help=\"SSL certificate file\")",
            "define(\"keyfile\", type=str, default=None,",
            "       help=\"SSL key file\")",
            "define(\"xheaders\", type=bool, default=False,",
            "       help=\"enable support for the 'X-Real-Ip' and 'X-Scheme' headers.\")",
            "define(\"auto_refresh\", default=True,",
            "       help=\"refresh dashboards\", type=bool)",
            "define(\"purge_offline_workers\", default=None, type=int,",
            "       help=\"time (in seconds) after which offline workers are purged from dashboard\")",
            "define(\"cookie_secret\", type=str, default=None,",
            "       help=\"secure cookie secret\")",
            "define(\"conf\", default=DEFAULT_CONFIG_FILE,",
            "       help=\"configuration file\")",
            "define(\"enable_events\", type=bool, default=True,",
            "       help=\"periodically enable Celery events\")",
            "define(\"format_task\", type=types.FunctionType, default=None,",
            "       help=\"use custom task formatter\")",
            "define(\"natural_time\", type=bool, default=False,",
            "       help=\"show time in relative format\")",
            "define(\"tasks_columns\", type=str,",
            "       default=\"name,uuid,state,args,kwargs,result,received,started,runtime,worker\",",
            "       help=\"slugs of columns on /tasks/ page, delimited by comma\")",
            "define(\"auth_provider\", default='flower.views.auth.GoogleAuth2LoginHandler',",
            "       help=\"auth handler class\")",
            "define(\"url_prefix\", type=str, help=\"base url prefix\")",
            "define(\"task_runtime_metric_buckets\", type=float, default=Histogram.DEFAULT_BUCKETS,",
            "       multiple=True, help=\"histogram latency bucket value\")",
            "",
            "# deprecated options",
            "define(\"inspect\", default=False, help=\"inspect workers\", type=bool)",
            "",
            "default_options = options"
        ],
        "afterPatchFile": [
            "import types",
            "from secrets import token_urlsafe",
            "",
            "from prometheus_client import Histogram",
            "from tornado.options import define",
            "from tornado.options import options",
            "",
            "",
            "DEFAULT_CONFIG_FILE = 'flowerconfig.py'",
            "",
            "",
            "define(\"port\", default=5555,",
            "       help=\"run on the given port\", type=int)",
            "define(\"address\", default='',",
            "       help=\"run on the given address\", type=str)",
            "define(\"unix_socket\", default='',",
            "       help=\"path to unix socket to bind\", type=str)",
            "define(\"debug\", default=False,",
            "       help=\"run in debug mode\", type=bool)",
            "define(\"inspect_timeout\", default=1000, type=float,",
            "       help=\"inspect timeout (in milliseconds)\")",
            "define(\"auth\", default='', type=str,",
            "       help=\"regexp of emails to grant access\")",
            "define(\"basic_auth\", type=str, default=None, multiple=True,",
            "       help=\"enable http basic authentication\")",
            "define(\"oauth2_key\", type=str, default=None,",
            "       help=\"OAuth2 key (requires --auth)\")",
            "define(\"oauth2_secret\", type=str, default=None,",
            "       help=\"OAuth2 secret (requires --auth)\")",
            "define(\"oauth2_redirect_uri\", type=str, default=None,",
            "       help=\"OAuth2 redirect uri (requires --auth)\")",
            "define(\"max_workers\", type=int, default=5000,",
            "       help=\"maximum number of workers to keep in memory\")",
            "define(\"max_tasks\", type=int, default=10000,",
            "       help=\"maximum number of tasks to keep in memory\")",
            "define(\"db\", type=str, default='flower',",
            "       help=\"flower database file\")",
            "define(\"persistent\", type=bool, default=False,",
            "       help=\"enable persistent mode\")",
            "define(\"state_save_interval\", type=int, default=0,",
            "       help=\"state save interval (in milliseconds)\")",
            "define(\"broker_api\", type=str, default=None,",
            "       help=\"inspect broker e.g. http://guest:guest@localhost:15672/api/\")",
            "define(\"ca_certs\", type=str, default=None,",
            "       help=\"SSL certificate authority (CA) file\")",
            "define(\"certfile\", type=str, default=None,",
            "       help=\"SSL certificate file\")",
            "define(\"keyfile\", type=str, default=None,",
            "       help=\"SSL key file\")",
            "define(\"xheaders\", type=bool, default=False,",
            "       help=\"enable support for the 'X-Real-Ip' and 'X-Scheme' headers.\")",
            "define(\"auto_refresh\", default=True,",
            "       help=\"refresh dashboards\", type=bool)",
            "define(\"purge_offline_workers\", default=None, type=int,",
            "       help=\"time (in seconds) after which offline workers are purged from dashboard\")",
            "define(\"cookie_secret\", type=str, default=token_urlsafe(64),",
            "       help=\"secure cookie secret\")",
            "define(\"conf\", default=DEFAULT_CONFIG_FILE,",
            "       help=\"configuration file\")",
            "define(\"enable_events\", type=bool, default=True,",
            "       help=\"periodically enable Celery events\")",
            "define(\"format_task\", type=types.FunctionType, default=None,",
            "       help=\"use custom task formatter\")",
            "define(\"natural_time\", type=bool, default=False,",
            "       help=\"show time in relative format\")",
            "define(\"tasks_columns\", type=str,",
            "       default=\"name,uuid,state,args,kwargs,result,received,started,runtime,worker\",",
            "       help=\"slugs of columns on /tasks/ page, delimited by comma\")",
            "define(\"auth_provider\", default='flower.views.auth.GoogleAuth2LoginHandler',",
            "       help=\"auth handler class\")",
            "define(\"url_prefix\", type=str, help=\"base url prefix\")",
            "define(\"task_runtime_metric_buckets\", type=float, default=Histogram.DEFAULT_BUCKETS,",
            "       multiple=True, help=\"histogram latency bucket value\")",
            "",
            "# deprecated options",
            "define(\"inspect\", default=False, help=\"inspect workers\", type=bool)",
            "",
            "default_options = options"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "55": []
        },
        "addLocation": []
    },
    "flower/views/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " class BaseHandler(tornado.web.RequestHandler):"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     def set_default_headers(self):"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.set_header(\"Access-Control-Allow-Origin\", \"*\")"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.set_header(\"Access-Control-Allow-Headers\","
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        \"x-requested-with,access-control-allow-origin,authorization,content-type\")"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.set_header('Access-Control-Allow-Methods',"
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        ' PUT, DELETE, OPTIONS, POST, GET, PATCH')"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+        if not (self.application.options.basic_auth or self.application.options.auth):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+            self.set_header(\"Access-Control-Allow-Origin\", \"*\")"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+            self.set_header(\"Access-Control-Allow-Headers\","
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+                            \"x-requested-with,access-control-allow-origin,authorization,content-type\")"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+            self.set_header('Access-Control-Allow-Methods',"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+                            ' PUT, DELETE, OPTIONS, POST, GET, PATCH')"
            },
            "14": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     def options(self, *args, **kwargs):"
            },
            "16": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         self.set_status(204)"
            }
        },
        "frontPatchFile": [
            "import re",
            "import inspect",
            "import traceback",
            "import copy",
            "import logging",
            "",
            "from distutils.util import strtobool",
            "from base64 import b64decode",
            "",
            "import tornado",
            "",
            "from ..utils import template, bugreport, prepend_url",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class BaseHandler(tornado.web.RequestHandler):",
            "    def set_default_headers(self):",
            "        self.set_header(\"Access-Control-Allow-Origin\", \"*\")",
            "        self.set_header(\"Access-Control-Allow-Headers\",",
            "                        \"x-requested-with,access-control-allow-origin,authorization,content-type\")",
            "        self.set_header('Access-Control-Allow-Methods',",
            "                        ' PUT, DELETE, OPTIONS, POST, GET, PATCH')",
            "",
            "    def options(self, *args, **kwargs):",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    def render(self, *args, **kwargs):",
            "        app_options = self.application.options",
            "        functions = inspect.getmembers(template, inspect.isfunction)",
            "        assert not set(map(lambda x: x[0], functions)) & set(kwargs.keys())",
            "        kwargs.update(functions)",
            "        kwargs.update(url_prefix=app_options.url_prefix)",
            "        super(BaseHandler, self).render(*args, **kwargs)",
            "",
            "    def write_error(self, status_code, **kwargs):",
            "        if status_code in (404, 403):",
            "            message = ''",
            "            if 'exc_info' in kwargs and kwargs['exc_info'][0] == tornado.web.HTTPError:",
            "                message = kwargs['exc_info'][1].log_message",
            "            self.render('404.html', message=message)",
            "        elif status_code == 500:",
            "            error_trace = \"\"",
            "            for line in traceback.format_exception(*kwargs['exc_info']):",
            "                error_trace += line",
            "",
            "            self.render('error.html',",
            "                        debug=self.application.options.debug,",
            "                        status_code=status_code,",
            "                        error_trace=error_trace,",
            "                        bugreport=bugreport())",
            "        elif status_code == 401:",
            "            self.set_status(status_code)",
            "            self.set_header('WWW-Authenticate', 'Basic realm=\"flower\"')",
            "            self.finish('Access denied')",
            "        else:",
            "            message = ''",
            "            if 'exc_info' in kwargs and kwargs['exc_info'][0] == tornado.web.HTTPError:",
            "                message = kwargs['exc_info'][1].log_message",
            "                self.set_header('Content-Type', 'text/plain')",
            "                self.write(str(message))",
            "            self.set_status(status_code)",
            "            self.finish()",
            "",
            "    def get_current_user(self):",
            "        # Basic Auth",
            "        basic_auth = self.application.options.basic_auth",
            "        if basic_auth:",
            "            auth_header = self.request.headers.get(\"Authorization\", \"\")",
            "            try:",
            "                basic, credentials = auth_header.split()",
            "                credentials = b64decode(credentials.encode()).decode()",
            "                if basic != 'Basic' or credentials not in basic_auth:",
            "                    raise tornado.web.HTTPError(401)",
            "            except ValueError:",
            "                raise tornado.web.HTTPError(401)",
            "",
            "        # OAuth2",
            "        if not self.application.options.auth:",
            "            return True",
            "        user = self.get_secure_cookie('user')",
            "        if user:",
            "            if not isinstance(user, str):",
            "                user = user.decode()",
            "            if re.match(self.application.options.auth, user):",
            "                return user",
            "        return None",
            "",
            "    def get_argument(self, name, default=[], strip=True, type=None):",
            "        arg = super(BaseHandler, self).get_argument(name, default, strip)",
            "        if arg and isinstance(arg, str):",
            "            arg = tornado.escape.xhtml_escape(arg)",
            "        if type is not None:",
            "            try:",
            "                if type is bool:",
            "                    arg = strtobool(str(arg))",
            "                else:",
            "                    arg = type(arg)",
            "            except (ValueError, TypeError):",
            "                if arg is None and default is None:",
            "                    return arg",
            "                raise tornado.web.HTTPError(",
            "                    400,",
            "                    \"Invalid argument '%s' of type '%s'\" % (",
            "                        arg, type.__name__))",
            "        return arg",
            "",
            "    @property",
            "    def capp(self):",
            "        \"return Celery application object\"",
            "        return self.application.capp",
            "",
            "    def format_task(self, task):",
            "        custom_format_task = self.application.options.format_task",
            "        if custom_format_task:",
            "            try:",
            "                task = custom_format_task(copy.copy(task))",
            "            except:",
            "                logger.exception(\"Failed to format '%s' task\", task.uuid)",
            "        return task",
            "",
            "    def get_active_queue_names(self):",
            "        queues = set([])",
            "        for _, info in self.application.workers.items():",
            "            for q in info.get('active_queues', []):",
            "                queues.add(q['name'])",
            "        return queues"
        ],
        "afterPatchFile": [
            "import re",
            "import inspect",
            "import traceback",
            "import copy",
            "import logging",
            "",
            "from distutils.util import strtobool",
            "from base64 import b64decode",
            "",
            "import tornado",
            "",
            "from ..utils import template, bugreport, prepend_url",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class BaseHandler(tornado.web.RequestHandler):",
            "    def set_default_headers(self):",
            "        if not (self.application.options.basic_auth or self.application.options.auth):",
            "            self.set_header(\"Access-Control-Allow-Origin\", \"*\")",
            "            self.set_header(\"Access-Control-Allow-Headers\",",
            "                            \"x-requested-with,access-control-allow-origin,authorization,content-type\")",
            "            self.set_header('Access-Control-Allow-Methods',",
            "                            ' PUT, DELETE, OPTIONS, POST, GET, PATCH')",
            "",
            "    def options(self, *args, **kwargs):",
            "        self.set_status(204)",
            "        self.finish()",
            "",
            "    def render(self, *args, **kwargs):",
            "        app_options = self.application.options",
            "        functions = inspect.getmembers(template, inspect.isfunction)",
            "        assert not set(map(lambda x: x[0], functions)) & set(kwargs.keys())",
            "        kwargs.update(functions)",
            "        kwargs.update(url_prefix=app_options.url_prefix)",
            "        super(BaseHandler, self).render(*args, **kwargs)",
            "",
            "    def write_error(self, status_code, **kwargs):",
            "        if status_code in (404, 403):",
            "            message = ''",
            "            if 'exc_info' in kwargs and kwargs['exc_info'][0] == tornado.web.HTTPError:",
            "                message = kwargs['exc_info'][1].log_message",
            "            self.render('404.html', message=message)",
            "        elif status_code == 500:",
            "            error_trace = \"\"",
            "            for line in traceback.format_exception(*kwargs['exc_info']):",
            "                error_trace += line",
            "",
            "            self.render('error.html',",
            "                        debug=self.application.options.debug,",
            "                        status_code=status_code,",
            "                        error_trace=error_trace,",
            "                        bugreport=bugreport())",
            "        elif status_code == 401:",
            "            self.set_status(status_code)",
            "            self.set_header('WWW-Authenticate', 'Basic realm=\"flower\"')",
            "            self.finish('Access denied')",
            "        else:",
            "            message = ''",
            "            if 'exc_info' in kwargs and kwargs['exc_info'][0] == tornado.web.HTTPError:",
            "                message = kwargs['exc_info'][1].log_message",
            "                self.set_header('Content-Type', 'text/plain')",
            "                self.write(str(message))",
            "            self.set_status(status_code)",
            "            self.finish()",
            "",
            "    def get_current_user(self):",
            "        # Basic Auth",
            "        basic_auth = self.application.options.basic_auth",
            "        if basic_auth:",
            "            auth_header = self.request.headers.get(\"Authorization\", \"\")",
            "            try:",
            "                basic, credentials = auth_header.split()",
            "                credentials = b64decode(credentials.encode()).decode()",
            "                if basic != 'Basic' or credentials not in basic_auth:",
            "                    raise tornado.web.HTTPError(401)",
            "            except ValueError:",
            "                raise tornado.web.HTTPError(401)",
            "",
            "        # OAuth2",
            "        if not self.application.options.auth:",
            "            return True",
            "        user = self.get_secure_cookie('user')",
            "        if user:",
            "            if not isinstance(user, str):",
            "                user = user.decode()",
            "            if re.match(self.application.options.auth, user):",
            "                return user",
            "        return None",
            "",
            "    def get_argument(self, name, default=[], strip=True, type=None):",
            "        arg = super(BaseHandler, self).get_argument(name, default, strip)",
            "        if arg and isinstance(arg, str):",
            "            arg = tornado.escape.xhtml_escape(arg)",
            "        if type is not None:",
            "            try:",
            "                if type is bool:",
            "                    arg = strtobool(str(arg))",
            "                else:",
            "                    arg = type(arg)",
            "            except (ValueError, TypeError):",
            "                if arg is None and default is None:",
            "                    return arg",
            "                raise tornado.web.HTTPError(",
            "                    400,",
            "                    \"Invalid argument '%s' of type '%s'\" % (",
            "                        arg, type.__name__))",
            "        return arg",
            "",
            "    @property",
            "    def capp(self):",
            "        \"return Celery application object\"",
            "        return self.application.capp",
            "",
            "    def format_task(self, task):",
            "        custom_format_task = self.application.options.format_task",
            "        if custom_format_task:",
            "            try:",
            "                task = custom_format_task(copy.copy(task))",
            "            except:",
            "                logger.exception(\"Failed to format '%s' task\", task.uuid)",
            "        return task",
            "",
            "    def get_active_queue_names(self):",
            "        queues = set([])",
            "        for _, info in self.application.workers.items():",
            "            for q in info.get('active_queues', []):",
            "                queues.add(q['name'])",
            "        return queues"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": [
                "BaseHandler",
                "set_default_headers"
            ],
            "20": [
                "BaseHandler",
                "set_default_headers"
            ],
            "21": [
                "BaseHandler",
                "set_default_headers"
            ],
            "22": [
                "BaseHandler",
                "set_default_headers"
            ],
            "23": [
                "BaseHandler",
                "set_default_headers"
            ]
        },
        "addLocation": []
    },
    "flower/views/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from ..views import BaseHandler"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+def authenticate(pattern, email):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    if '|' in pattern:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+        return email in pattern.split('|')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    elif '*' in pattern:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+        pattern = re.escape(pattern).replace('\\.\\*', \"[A-Za-z0-9!#$%&'*+/=?^_`{|}~.\\-]*\")"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+        return re.fullmatch(pattern, email)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    else:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        return pattern == email"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+def validate_auth_option(pattern):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    if pattern.count('*') > 1:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        return False"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    if '*' in pattern and '|' in pattern:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        return False"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    if '*' in pattern.rsplit('@', 1)[-1]:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        return False"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    return True"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " class GoogleAuth2LoginHandler(BaseHandler, tornado.auth.GoogleOAuth2Mixin):"
            },
            "24": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     _OAUTH_SETTINGS_KEY = 'oauth'"
            },
            "25": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "             raise tornado.web.HTTPError(403, 'Google auth failed: %s' % e)"
            },
            "27": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         email = json.loads(response.body.decode('utf-8'))['email']"
            },
            "29": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not re.match(self.application.options.auth, email):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        if not authenticate(self.application.options.auth, email):"
            },
            "31": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "             message = ("
            },
            "32": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "                 \"Access denied to '{email}'. Please use another account or \""
            },
            "33": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "                 \"ask your admin to add your email to flower --auth.\""
            },
            "34": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "                      'User-agent': 'Tornado auth'})"
            },
            "35": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         emails = [email['email'].lower() for email in json.loads(response.body.decode('utf-8'))"
            },
            "37": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  if email['verified'] and re.match(self.application.options.auth, email['email'])]"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                  if email['verified'] and authenticate(self.application.options.auth, email['email'])]"
            },
            "39": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         if not emails:"
            },
            "41": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "             message = ("
            },
            "42": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             raise tornado.web.HTTPError(403, 'GitLab auth failed: %s' % e)"
            },
            "43": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         user_email = json.loads(response.body.decode('utf-8'))['email']"
            },
            "45": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        email_allowed = re.match(self.application.options.auth, user_email)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        email_allowed = authenticate(self.application.options.auth, user_email)"
            },
            "47": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "         # Check user's groups against list of allowed groups"
            },
            "49": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         matching_groups = []"
            },
            "50": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 343,
                "PatchRowcode": "         email = (decoded_body.get('email') or '').strip()"
            },
            "51": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 344,
                "PatchRowcode": "         email_verified = ("
            },
            "52": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 345,
                "PatchRowcode": "             decoded_body.get('email_verified') and"
            },
            "53": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            re.match(self.application.options.auth, email)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+            authenticate(self.application.options.auth, email)"
            },
            "55": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 347,
                "PatchRowcode": "         )"
            },
            "56": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 348,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 349,
                "PatchRowcode": "         if not email_verified:"
            }
        },
        "frontPatchFile": [
            "import json",
            "import re",
            "import os",
            "import uuid",
            "",
            "from urllib.parse import urlencode",
            "import tornado.gen",
            "import tornado.web",
            "import tornado.auth",
            "",
            "from tornado.options import options",
            "from celery.utils.imports import instantiate",
            "",
            "from ..views import BaseHandler",
            "",
            "",
            "class GoogleAuth2LoginHandler(BaseHandler, tornado.auth.GoogleOAuth2Mixin):",
            "    _OAUTH_SETTINGS_KEY = 'oauth'",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings[self._OAUTH_SETTINGS_KEY]['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            user = yield self.get_authenticated_user(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(user)",
            "        else:",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "                scope=['profile', 'email'],",
            "                response_type='code',",
            "                extra_params={'approval_prompt': ''}",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, user):",
            "        if not user:",
            "            raise tornado.web.HTTPError(403, 'Google auth failed')",
            "        access_token = user['access_token']",
            "",
            "        try:",
            "            response = yield self.get_auth_http_client().fetch(",
            "                'https://www.googleapis.com/userinfo/v2/me',",
            "                headers={'Authorization': 'Bearer %s' % access_token})",
            "        except Exception as e:",
            "            raise tornado.web.HTTPError(403, 'Google auth failed: %s' % e)",
            "",
            "        email = json.loads(response.body.decode('utf-8'))['email']",
            "        if not re.match(self.application.options.auth, email):",
            "            message = (",
            "                \"Access denied to '{email}'. Please use another account or \"",
            "                \"ask your admin to add your email to flower --auth.\"",
            "            ).format(email=email)",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie(\"user\", str(email))",
            "",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "",
            "        self.redirect(next_)",
            "",
            "",
            "class LoginHandler(BaseHandler):",
            "    def __new__(cls, *args, **kwargs):",
            "        return instantiate(options.auth_provider, *args, **kwargs)",
            "",
            "",
            "class GithubLoginHandler(BaseHandler, tornado.auth.OAuth2Mixin):",
            "",
            "    _OAUTH_AUTHORIZE_URL = \"https://github.com/login/oauth/authorize\"",
            "    _OAUTH_ACCESS_TOKEN_URL = \"https://github.com/login/oauth/access_token\"",
            "    _OAUTH_NO_CALLBACKS = False",
            "    _OAUTH_SETTINGS_KEY = 'oauth'",
            "",
            "    @tornado.gen.coroutine",
            "    def get_authenticated_user(self, redirect_uri, code):",
            "        body = urlencode({",
            "            \"redirect_uri\": redirect_uri,",
            "            \"code\": code,",
            "            \"client_id\": self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "            \"client_secret\": self.settings[self._OAUTH_SETTINGS_KEY]['secret'],",
            "            \"grant_type\": \"authorization_code\",",
            "        })",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_ACCESS_TOKEN_URL,",
            "            method=\"POST\",",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded',",
            "                     'Accept': 'application/json'}, body=body)",
            "",
            "        if response.error:",
            "            raise tornado.auth.AuthError(",
            "                'OAuth authenticator error: %s' % str(response))",
            "",
            "        raise tornado.gen.Return(json.loads(response.body.decode('utf-8')))",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings[self._OAUTH_SETTINGS_KEY]['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            user = yield self.get_authenticated_user(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(user)",
            "        else:",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "                scope=['user:email'],",
            "                response_type='code',",
            "                extra_params={'approval_prompt': ''}",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, user):",
            "        if not user:",
            "            raise tornado.web.HTTPError(500, 'OAuth authentication failed')",
            "        access_token = user['access_token']",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            'https://api.github.com/user/emails',",
            "            headers={'Authorization': 'token ' + access_token,",
            "                     'User-agent': 'Tornado auth'})",
            "",
            "        emails = [email['email'].lower() for email in json.loads(response.body.decode('utf-8'))",
            "                  if email['verified'] and re.match(self.application.options.auth, email['email'])]",
            "",
            "        if not emails:",
            "            message = (",
            "                \"Access denied. Please use another account or \"",
            "                \"ask your admin to add your email to flower --auth.\"",
            "            )",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie(\"user\", str(emails.pop()))",
            "",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "        self.redirect(next_)",
            "",
            "",
            "class GitLabLoginHandler(BaseHandler, tornado.auth.OAuth2Mixin):",
            "",
            "    _OAUTH_AUTHORIZE_URL = 'https://gitlab.com/oauth/authorize'",
            "    _OAUTH_ACCESS_TOKEN_URL = 'https://gitlab.com/oauth/token'",
            "    _OAUTH_NO_CALLBACKS = False",
            "",
            "    @tornado.gen.coroutine",
            "    def get_authenticated_user(self, redirect_uri, code):",
            "        body = urlencode({",
            "            'redirect_uri': redirect_uri,",
            "            'code': code,",
            "            'client_id': self.settings['oauth']['key'],",
            "            'client_secret': self.settings['oauth']['secret'],",
            "            'grant_type': 'authorization_code',",
            "        })",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_ACCESS_TOKEN_URL,",
            "            method='POST',",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded',",
            "                     'Accept': 'application/json'},",
            "            body=body",
            "        )",
            "        if response.error:",
            "            raise tornado.auth.AuthError('OAuth authenticator error: %s' % str(response))",
            "        raise tornado.gen.Return(json.loads(response.body.decode('utf-8')))",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings['oauth']['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            user = yield self.get_authenticated_user(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(user)",
            "        else:",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings['oauth']['key'],",
            "                scope=['read_api'],",
            "                response_type='code',",
            "                extra_params={'approval_prompt': ''},",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, user):",
            "        if not user:",
            "            raise tornado.web.HTTPError(500, 'OAuth authentication failed')",
            "        access_token = user['access_token']",
            "        allowed_groups = os.environ.get('FLOWER_GITLAB_AUTH_ALLOWED_GROUPS', '')",
            "        allowed_groups = [group.strip() for group in allowed_groups.split(',') if group]",
            "",
            "        # Check user email address against regexp",
            "        try:",
            "            response = yield self.get_auth_http_client().fetch(",
            "                'https://gitlab.com/api/v4/user',",
            "                headers={'Authorization': 'Bearer ' + access_token,",
            "                         'User-agent': 'Tornado auth'}",
            "            )",
            "        except Exception as e:",
            "            raise tornado.web.HTTPError(403, 'GitLab auth failed: %s' % e)",
            "",
            "        user_email = json.loads(response.body.decode('utf-8'))['email']",
            "        email_allowed = re.match(self.application.options.auth, user_email)",
            "",
            "        # Check user's groups against list of allowed groups",
            "        matching_groups = []",
            "        if allowed_groups:",
            "            min_access_level = os.environ.get('FLOWER_GITLAB_MIN_ACCESS_LEVEL', '20')",
            "            response = yield self.get_auth_http_client().fetch(",
            "                'https://gitlab.com/api/v4/groups?min_access_level=%s' % (min_access_level,),",
            "                headers={",
            "                    'Authorization': 'Bearer ' + access_token,",
            "                    'User-agent': 'Tornado auth'",
            "                }",
            "            )",
            "            matching_groups = [",
            "                group['id']",
            "                for group in json.loads(response.body.decode('utf-8'))",
            "                if group['full_path'] in allowed_groups",
            "            ]",
            "",
            "        if not email_allowed or (allowed_groups and len(matching_groups) == 0):",
            "            message = 'Access denied. Please use another account or contact your admin.'",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie('user', str(user_email))",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "        self.redirect(next_)",
            "",
            "",
            "class OktaLoginHandler(BaseHandler, tornado.auth.OAuth2Mixin):",
            "    _OAUTH_NO_CALLBACKS = False",
            "    _OAUTH_SETTINGS_KEY = 'oauth'",
            "",
            "    @property",
            "    def base_url(self):",
            "        return os.environ.get('FLOWER_OAUTH2_OKTA_BASE_URL')",
            "",
            "    @property",
            "    def _OAUTH_AUTHORIZE_URL(self):",
            "        return \"{}/v1/authorize\".format(self.base_url)",
            "",
            "    @property",
            "    def _OAUTH_ACCESS_TOKEN_URL(self):",
            "        return \"{}/v1/token\".format(self.base_url)",
            "",
            "    @property",
            "    def _OAUTH_USER_INFO_URL(self):",
            "        return \"{}/v1/userinfo\".format(self.base_url)",
            "",
            "    @tornado.gen.coroutine",
            "    def get_access_token(self, redirect_uri, code):",
            "        body = urlencode({",
            "            \"redirect_uri\": redirect_uri,",
            "            \"code\": code,",
            "            \"client_id\": self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "            \"client_secret\": self.settings[self._OAUTH_SETTINGS_KEY]['secret'],",
            "            \"grant_type\": \"authorization_code\",",
            "        })",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_ACCESS_TOKEN_URL,",
            "            method=\"POST\",",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded',",
            "                     'Accept': 'application/json'}, body=body)",
            "",
            "        if response.error:",
            "            raise tornado.auth.AuthError(",
            "                'OAuth authenticator error: %s' % str(response))",
            "",
            "        raise tornado.gen.Return(json.loads(response.body.decode('utf-8')))",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings[self._OAUTH_SETTINGS_KEY]['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            expected_state = (self.get_secure_cookie('oauth_state') or b'').decode('utf-8')",
            "            returned_state = self.get_argument('state')",
            "",
            "            if returned_state is None or returned_state != expected_state:",
            "                raise tornado.auth.AuthError(",
            "                    'OAuth authenticator error: State tokens do not match')",
            "",
            "            access_token_response = yield self.get_access_token(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(access_token_response)",
            "        else:",
            "            state = str(uuid.uuid4())",
            "            self.set_secure_cookie(\"oauth_state\", state)",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "                scope=['openid email'],",
            "                response_type='code',",
            "                extra_params={'state': state}",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, access_token_response):",
            "        if not access_token_response:",
            "            raise tornado.web.HTTPError(500, 'OAuth authentication failed')",
            "        access_token = access_token_response['access_token']",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_USER_INFO_URL,",
            "            headers={'Authorization': 'Bearer ' + access_token,",
            "                     'User-agent': 'Tornado auth'})",
            "",
            "        decoded_body = json.loads(response.body.decode('utf-8'))",
            "        email = (decoded_body.get('email') or '').strip()",
            "        email_verified = (",
            "            decoded_body.get('email_verified') and",
            "            re.match(self.application.options.auth, email)",
            "        )",
            "",
            "        if not email_verified:",
            "            message = (",
            "                \"Access denied. Please use another account or \"",
            "                \"ask your admin to add your email to flower --auth.\"",
            "            )",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie(\"user\", str(email))",
            "        self.clear_cookie('oauth_state')",
            "",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "        self.redirect(next_)"
        ],
        "afterPatchFile": [
            "import json",
            "import re",
            "import os",
            "import uuid",
            "",
            "from urllib.parse import urlencode",
            "import tornado.gen",
            "import tornado.web",
            "import tornado.auth",
            "",
            "from tornado.options import options",
            "from celery.utils.imports import instantiate",
            "",
            "from ..views import BaseHandler",
            "",
            "",
            "def authenticate(pattern, email):",
            "    if '|' in pattern:",
            "        return email in pattern.split('|')",
            "    elif '*' in pattern:",
            "        pattern = re.escape(pattern).replace('\\.\\*', \"[A-Za-z0-9!#$%&'*+/=?^_`{|}~.\\-]*\")",
            "        return re.fullmatch(pattern, email)",
            "    else:",
            "        return pattern == email",
            "",
            "",
            "def validate_auth_option(pattern):",
            "    if pattern.count('*') > 1:",
            "        return False",
            "    if '*' in pattern and '|' in pattern:",
            "        return False",
            "    if '*' in pattern.rsplit('@', 1)[-1]:",
            "        return False",
            "    return True",
            "",
            "",
            "class GoogleAuth2LoginHandler(BaseHandler, tornado.auth.GoogleOAuth2Mixin):",
            "    _OAUTH_SETTINGS_KEY = 'oauth'",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings[self._OAUTH_SETTINGS_KEY]['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            user = yield self.get_authenticated_user(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(user)",
            "        else:",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "                scope=['profile', 'email'],",
            "                response_type='code',",
            "                extra_params={'approval_prompt': ''}",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, user):",
            "        if not user:",
            "            raise tornado.web.HTTPError(403, 'Google auth failed')",
            "        access_token = user['access_token']",
            "",
            "        try:",
            "            response = yield self.get_auth_http_client().fetch(",
            "                'https://www.googleapis.com/userinfo/v2/me',",
            "                headers={'Authorization': 'Bearer %s' % access_token})",
            "        except Exception as e:",
            "            raise tornado.web.HTTPError(403, 'Google auth failed: %s' % e)",
            "",
            "        email = json.loads(response.body.decode('utf-8'))['email']",
            "        if not authenticate(self.application.options.auth, email):",
            "            message = (",
            "                \"Access denied to '{email}'. Please use another account or \"",
            "                \"ask your admin to add your email to flower --auth.\"",
            "            ).format(email=email)",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie(\"user\", str(email))",
            "",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "",
            "        self.redirect(next_)",
            "",
            "",
            "class LoginHandler(BaseHandler):",
            "    def __new__(cls, *args, **kwargs):",
            "        return instantiate(options.auth_provider, *args, **kwargs)",
            "",
            "",
            "class GithubLoginHandler(BaseHandler, tornado.auth.OAuth2Mixin):",
            "",
            "    _OAUTH_AUTHORIZE_URL = \"https://github.com/login/oauth/authorize\"",
            "    _OAUTH_ACCESS_TOKEN_URL = \"https://github.com/login/oauth/access_token\"",
            "    _OAUTH_NO_CALLBACKS = False",
            "    _OAUTH_SETTINGS_KEY = 'oauth'",
            "",
            "    @tornado.gen.coroutine",
            "    def get_authenticated_user(self, redirect_uri, code):",
            "        body = urlencode({",
            "            \"redirect_uri\": redirect_uri,",
            "            \"code\": code,",
            "            \"client_id\": self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "            \"client_secret\": self.settings[self._OAUTH_SETTINGS_KEY]['secret'],",
            "            \"grant_type\": \"authorization_code\",",
            "        })",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_ACCESS_TOKEN_URL,",
            "            method=\"POST\",",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded',",
            "                     'Accept': 'application/json'}, body=body)",
            "",
            "        if response.error:",
            "            raise tornado.auth.AuthError(",
            "                'OAuth authenticator error: %s' % str(response))",
            "",
            "        raise tornado.gen.Return(json.loads(response.body.decode('utf-8')))",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings[self._OAUTH_SETTINGS_KEY]['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            user = yield self.get_authenticated_user(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(user)",
            "        else:",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "                scope=['user:email'],",
            "                response_type='code',",
            "                extra_params={'approval_prompt': ''}",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, user):",
            "        if not user:",
            "            raise tornado.web.HTTPError(500, 'OAuth authentication failed')",
            "        access_token = user['access_token']",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            'https://api.github.com/user/emails',",
            "            headers={'Authorization': 'token ' + access_token,",
            "                     'User-agent': 'Tornado auth'})",
            "",
            "        emails = [email['email'].lower() for email in json.loads(response.body.decode('utf-8'))",
            "                  if email['verified'] and authenticate(self.application.options.auth, email['email'])]",
            "",
            "        if not emails:",
            "            message = (",
            "                \"Access denied. Please use another account or \"",
            "                \"ask your admin to add your email to flower --auth.\"",
            "            )",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie(\"user\", str(emails.pop()))",
            "",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "        self.redirect(next_)",
            "",
            "",
            "class GitLabLoginHandler(BaseHandler, tornado.auth.OAuth2Mixin):",
            "",
            "    _OAUTH_AUTHORIZE_URL = 'https://gitlab.com/oauth/authorize'",
            "    _OAUTH_ACCESS_TOKEN_URL = 'https://gitlab.com/oauth/token'",
            "    _OAUTH_NO_CALLBACKS = False",
            "",
            "    @tornado.gen.coroutine",
            "    def get_authenticated_user(self, redirect_uri, code):",
            "        body = urlencode({",
            "            'redirect_uri': redirect_uri,",
            "            'code': code,",
            "            'client_id': self.settings['oauth']['key'],",
            "            'client_secret': self.settings['oauth']['secret'],",
            "            'grant_type': 'authorization_code',",
            "        })",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_ACCESS_TOKEN_URL,",
            "            method='POST',",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded',",
            "                     'Accept': 'application/json'},",
            "            body=body",
            "        )",
            "        if response.error:",
            "            raise tornado.auth.AuthError('OAuth authenticator error: %s' % str(response))",
            "        raise tornado.gen.Return(json.loads(response.body.decode('utf-8')))",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings['oauth']['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            user = yield self.get_authenticated_user(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(user)",
            "        else:",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings['oauth']['key'],",
            "                scope=['read_api'],",
            "                response_type='code',",
            "                extra_params={'approval_prompt': ''},",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, user):",
            "        if not user:",
            "            raise tornado.web.HTTPError(500, 'OAuth authentication failed')",
            "        access_token = user['access_token']",
            "        allowed_groups = os.environ.get('FLOWER_GITLAB_AUTH_ALLOWED_GROUPS', '')",
            "        allowed_groups = [group.strip() for group in allowed_groups.split(',') if group]",
            "",
            "        # Check user email address against regexp",
            "        try:",
            "            response = yield self.get_auth_http_client().fetch(",
            "                'https://gitlab.com/api/v4/user',",
            "                headers={'Authorization': 'Bearer ' + access_token,",
            "                         'User-agent': 'Tornado auth'}",
            "            )",
            "        except Exception as e:",
            "            raise tornado.web.HTTPError(403, 'GitLab auth failed: %s' % e)",
            "",
            "        user_email = json.loads(response.body.decode('utf-8'))['email']",
            "        email_allowed = authenticate(self.application.options.auth, user_email)",
            "",
            "        # Check user's groups against list of allowed groups",
            "        matching_groups = []",
            "        if allowed_groups:",
            "            min_access_level = os.environ.get('FLOWER_GITLAB_MIN_ACCESS_LEVEL', '20')",
            "            response = yield self.get_auth_http_client().fetch(",
            "                'https://gitlab.com/api/v4/groups?min_access_level=%s' % (min_access_level,),",
            "                headers={",
            "                    'Authorization': 'Bearer ' + access_token,",
            "                    'User-agent': 'Tornado auth'",
            "                }",
            "            )",
            "            matching_groups = [",
            "                group['id']",
            "                for group in json.loads(response.body.decode('utf-8'))",
            "                if group['full_path'] in allowed_groups",
            "            ]",
            "",
            "        if not email_allowed or (allowed_groups and len(matching_groups) == 0):",
            "            message = 'Access denied. Please use another account or contact your admin.'",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie('user', str(user_email))",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "        self.redirect(next_)",
            "",
            "",
            "class OktaLoginHandler(BaseHandler, tornado.auth.OAuth2Mixin):",
            "    _OAUTH_NO_CALLBACKS = False",
            "    _OAUTH_SETTINGS_KEY = 'oauth'",
            "",
            "    @property",
            "    def base_url(self):",
            "        return os.environ.get('FLOWER_OAUTH2_OKTA_BASE_URL')",
            "",
            "    @property",
            "    def _OAUTH_AUTHORIZE_URL(self):",
            "        return \"{}/v1/authorize\".format(self.base_url)",
            "",
            "    @property",
            "    def _OAUTH_ACCESS_TOKEN_URL(self):",
            "        return \"{}/v1/token\".format(self.base_url)",
            "",
            "    @property",
            "    def _OAUTH_USER_INFO_URL(self):",
            "        return \"{}/v1/userinfo\".format(self.base_url)",
            "",
            "    @tornado.gen.coroutine",
            "    def get_access_token(self, redirect_uri, code):",
            "        body = urlencode({",
            "            \"redirect_uri\": redirect_uri,",
            "            \"code\": code,",
            "            \"client_id\": self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "            \"client_secret\": self.settings[self._OAUTH_SETTINGS_KEY]['secret'],",
            "            \"grant_type\": \"authorization_code\",",
            "        })",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_ACCESS_TOKEN_URL,",
            "            method=\"POST\",",
            "            headers={'Content-Type': 'application/x-www-form-urlencoded',",
            "                     'Accept': 'application/json'}, body=body)",
            "",
            "        if response.error:",
            "            raise tornado.auth.AuthError(",
            "                'OAuth authenticator error: %s' % str(response))",
            "",
            "        raise tornado.gen.Return(json.loads(response.body.decode('utf-8')))",
            "",
            "    @tornado.gen.coroutine",
            "    def get(self):",
            "        redirect_uri = self.settings[self._OAUTH_SETTINGS_KEY]['redirect_uri']",
            "        if self.get_argument('code', False):",
            "            expected_state = (self.get_secure_cookie('oauth_state') or b'').decode('utf-8')",
            "            returned_state = self.get_argument('state')",
            "",
            "            if returned_state is None or returned_state != expected_state:",
            "                raise tornado.auth.AuthError(",
            "                    'OAuth authenticator error: State tokens do not match')",
            "",
            "            access_token_response = yield self.get_access_token(",
            "                redirect_uri=redirect_uri,",
            "                code=self.get_argument('code'),",
            "            )",
            "            yield self._on_auth(access_token_response)",
            "        else:",
            "            state = str(uuid.uuid4())",
            "            self.set_secure_cookie(\"oauth_state\", state)",
            "            yield self.authorize_redirect(",
            "                redirect_uri=redirect_uri,",
            "                client_id=self.settings[self._OAUTH_SETTINGS_KEY]['key'],",
            "                scope=['openid email'],",
            "                response_type='code',",
            "                extra_params={'state': state}",
            "            )",
            "",
            "    @tornado.gen.coroutine",
            "    def _on_auth(self, access_token_response):",
            "        if not access_token_response:",
            "            raise tornado.web.HTTPError(500, 'OAuth authentication failed')",
            "        access_token = access_token_response['access_token']",
            "",
            "        response = yield self.get_auth_http_client().fetch(",
            "            self._OAUTH_USER_INFO_URL,",
            "            headers={'Authorization': 'Bearer ' + access_token,",
            "                     'User-agent': 'Tornado auth'})",
            "",
            "        decoded_body = json.loads(response.body.decode('utf-8'))",
            "        email = (decoded_body.get('email') or '').strip()",
            "        email_verified = (",
            "            decoded_body.get('email_verified') and",
            "            authenticate(self.application.options.auth, email)",
            "        )",
            "",
            "        if not email_verified:",
            "            message = (",
            "                \"Access denied. Please use another account or \"",
            "                \"ask your admin to add your email to flower --auth.\"",
            "            )",
            "            raise tornado.web.HTTPError(403, message)",
            "",
            "        self.set_secure_cookie(\"user\", str(email))",
            "        self.clear_cookie('oauth_state')",
            "",
            "        next_ = self.get_argument('next', self.application.options.url_prefix or '/')",
            "        if self.application.options.url_prefix and next_[0] != '/':",
            "            next_ = '/' + next_",
            "        self.redirect(next_)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "52": [
                "GoogleAuth2LoginHandler",
                "_on_auth"
            ],
            "132": [
                "GithubLoginHandler",
                "_on_auth"
            ],
            "212": [
                "GitLabLoginHandler",
                "_on_auth"
            ],
            "326": [
                "OktaLoginHandler",
                "_on_auth"
            ]
        },
        "addLocation": [
            "flower.views.auth.GithubLoginHandler._on_auth",
            "flower.views.auth.GoogleAuth2LoginHandler._on_auth",
            "flower.views.auth.OktaLoginHandler._on_auth",
            "flower.views.auth.GitLabLoginHandler._on_auth",
            "flower.command"
        ]
    }
}