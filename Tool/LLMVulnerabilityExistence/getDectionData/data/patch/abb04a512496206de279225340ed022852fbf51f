{
    "src/quart/app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             \"EXPLAIN_TEMPLATE_LOADING\": False,"
            },
            "1": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "             \"MAX_CONTENT_LENGTH\": 16 * 1024 * 1024,  # 16 MB Limit"
            },
            "2": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "             \"MAX_COOKIE_SIZE\": 4093,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            \"MAX_FORM_MEMORY_SIZE\": 500_000,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            \"MAX_FORM_PARTS\": 1_000,"
            },
            "5": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "             \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),"
            },
            "6": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             # Replaces PREFERRED_URL_SCHEME to allow for WebSocket scheme"
            },
            "7": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "             \"PREFER_SECURE_URLS\": False,"
            },
            "8": {
                "beforePatchRowNumber": 1130,
                "afterPatchRowNumber": 1132,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 1131,
                "afterPatchRowNumber": 1133,
                "PatchRowcode": "     def log_exception("
            },
            "10": {
                "beforePatchRowNumber": 1132,
                "afterPatchRowNumber": 1134,
                "PatchRowcode": "         self,"
            },
            "11": {
                "beforePatchRowNumber": 1133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        exception_info: tuple[type, BaseException, TracebackType]"
            },
            "12": {
                "beforePatchRowNumber": 1134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        | tuple[None, None, None],"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "+        exception_info: ("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1136,
                "PatchRowcode": "+            tuple[type, BaseException, TracebackType] | tuple[None, None, None]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1137,
                "PatchRowcode": "+        ),"
            },
            "16": {
                "beforePatchRowNumber": 1135,
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "     ) -> None:"
            },
            "17": {
                "beforePatchRowNumber": 1136,
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "         \"\"\"Log a exception to the :attr:`logger`."
            },
            "18": {
                "beforePatchRowNumber": 1137,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import os",
            "import signal",
            "import sys",
            "import warnings",
            "from collections import defaultdict",
            "from collections.abc import AsyncGenerator",
            "from collections.abc import Awaitable",
            "from collections.abc import Coroutine",
            "from datetime import timedelta",
            "from inspect import isasyncgen",
            "from inspect import iscoroutinefunction as _inspect_iscoroutinefunction",
            "from inspect import isgenerator",
            "from types import TracebackType",
            "from typing import Any",
            "from typing import AnyStr",
            "from typing import Callable",
            "from typing import cast",
            "from typing import NoReturn",
            "from typing import Optional",
            "from typing import overload",
            "from typing import TypeVar",
            "from urllib.parse import quote",
            "",
            "from aiofiles import open as async_open",
            "from aiofiles.base import AiofilesContextManager",
            "from flask.sansio.app import App",
            "from flask.sansio.scaffold import setupmethod",
            "from hypercorn.asyncio import serve",
            "from hypercorn.config import Config as HyperConfig",
            "from hypercorn.typing import ASGIReceiveCallable",
            "from hypercorn.typing import ASGISendCallable",
            "from hypercorn.typing import Scope",
            "from werkzeug.datastructures import Authorization",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.datastructures import ImmutableDict",
            "from werkzeug.exceptions import Aborter",
            "from werkzeug.exceptions import BadRequestKeyError",
            "from werkzeug.exceptions import HTTPException",
            "from werkzeug.exceptions import InternalServerError",
            "from werkzeug.routing import BuildError",
            "from werkzeug.routing import MapAdapter",
            "from werkzeug.routing import RoutingException",
            "from werkzeug.wrappers import Response as WerkzeugResponse",
            "",
            "from .asgi import ASGIHTTPConnection",
            "from .asgi import ASGILifespan",
            "from .asgi import ASGIWebsocketConnection",
            "from .cli import AppGroup",
            "from .config import Config",
            "from .ctx import _AppCtxGlobals",
            "from .ctx import AppContext",
            "from .ctx import has_request_context",
            "from .ctx import has_websocket_context",
            "from .ctx import RequestContext",
            "from .ctx import WebsocketContext",
            "from .globals import _cv_app",
            "from .globals import _cv_request",
            "from .globals import _cv_websocket",
            "from .globals import g",
            "from .globals import request",
            "from .globals import request_ctx",
            "from .globals import session",
            "from .globals import websocket",
            "from .globals import websocket_ctx",
            "from .helpers import get_debug_flag",
            "from .helpers import get_flashed_messages",
            "from .helpers import send_from_directory",
            "from .routing import QuartMap",
            "from .routing import QuartRule",
            "from .sessions import SecureCookieSessionInterface",
            "from .signals import appcontext_tearing_down",
            "from .signals import got_background_exception",
            "from .signals import got_request_exception",
            "from .signals import got_serving_exception",
            "from .signals import got_websocket_exception",
            "from .signals import request_finished",
            "from .signals import request_started",
            "from .signals import request_tearing_down",
            "from .signals import websocket_finished",
            "from .signals import websocket_started",
            "from .signals import websocket_tearing_down",
            "from .templating import _default_template_ctx_processor",
            "from .templating import Environment",
            "from .testing import make_test_body_with_headers",
            "from .testing import make_test_headers_path_and_query_string",
            "from .testing import make_test_scope",
            "from .testing import no_op_push",
            "from .testing import QuartClient",
            "from .testing import QuartCliRunner",
            "from .testing import sentinel",
            "from .testing import TestApp",
            "from .typing import AfterServingCallable",
            "from .typing import AfterWebsocketCallable",
            "from .typing import ASGIHTTPProtocol",
            "from .typing import ASGILifespanProtocol",
            "from .typing import ASGIWebsocketProtocol",
            "from .typing import BeforeServingCallable",
            "from .typing import BeforeWebsocketCallable",
            "from .typing import Event",
            "from .typing import FilePath",
            "from .typing import HeadersValue",
            "from .typing import ResponseReturnValue",
            "from .typing import ResponseTypes",
            "from .typing import ShellContextProcessorCallable",
            "from .typing import StatusCode",
            "from .typing import TeardownCallable",
            "from .typing import TemplateFilterCallable",
            "from .typing import TemplateGlobalCallable",
            "from .typing import TemplateTestCallable",
            "from .typing import TestAppProtocol",
            "from .typing import TestClientProtocol",
            "from .typing import WebsocketCallable",
            "from .typing import WhileServingCallable",
            "from .utils import cancel_tasks",
            "from .utils import file_path_to_path",
            "from .utils import MustReloadError",
            "from .utils import observe_changes",
            "from .utils import restart",
            "from .utils import run_sync",
            "from .wrappers import BaseRequestWebsocket",
            "from .wrappers import Request",
            "from .wrappers import Response",
            "from .wrappers import Websocket",
            "",
            "if sys.version_info >= (3, 10):",
            "    from typing import ParamSpec",
            "else:",
            "    from typing_extensions import ParamSpec",
            "",
            "# Python 3.14 deprecated asyncio.iscoroutinefunction, but suggested",
            "# inspect.iscoroutinefunction does not work correctly in some Python",
            "# versions before 3.12.",
            "# See https://github.com/python/cpython/issues/122858#issuecomment-2466239748",
            "if sys.version_info >= (3, 12):",
            "    iscoroutinefunction = _inspect_iscoroutinefunction",
            "else:",
            "    iscoroutinefunction = asyncio.iscoroutinefunction",
            "",
            "AppOrBlueprintKey = Optional[str]  # The App key is None, whereas blueprints are named",
            "T_after_serving = TypeVar(\"T_after_serving\", bound=AfterServingCallable)",
            "T_after_websocket = TypeVar(\"T_after_websocket\", bound=AfterWebsocketCallable)",
            "T_before_serving = TypeVar(\"T_before_serving\", bound=BeforeServingCallable)",
            "T_before_websocket = TypeVar(\"T_before_websocket\", bound=BeforeWebsocketCallable)",
            "T_shell_context_processor = TypeVar(",
            "    \"T_shell_context_processor\", bound=ShellContextProcessorCallable",
            ")",
            "T_teardown = TypeVar(\"T_teardown\", bound=TeardownCallable)",
            "T_template_filter = TypeVar(\"T_template_filter\", bound=TemplateFilterCallable)",
            "T_template_global = TypeVar(\"T_template_global\", bound=TemplateGlobalCallable)",
            "T_template_test = TypeVar(\"T_template_test\", bound=TemplateTestCallable)",
            "T_websocket = TypeVar(\"T_websocket\", bound=WebsocketCallable)",
            "T_while_serving = TypeVar(\"T_while_serving\", bound=WhileServingCallable)",
            "",
            "T = TypeVar(\"T\", bound=Any)",
            "P = ParamSpec(\"P\")",
            "",
            "",
            "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:",
            "    if value is None or isinstance(value, timedelta):",
            "        return value",
            "",
            "    return timedelta(seconds=value)",
            "",
            "",
            "class Quart(App):",
            "    \"\"\"The web framework class, handles requests and returns responses.",
            "",
            "    The primary method from a serving viewpoint is",
            "    :meth:`~quart.app.Quart.handle_request`, from an application",
            "    viewpoint all the other methods are vital.",
            "",
            "    This can be extended in many ways, with most methods designed with",
            "    this in mind. Additionally any of the classes listed as attributes",
            "    can be replaced.",
            "",
            "    Attributes:",
            "        aborter_class: The class to use to raise HTTP error via the abort",
            "            helper function.",
            "        app_ctx_globals_class: The class to use for the ``g`` object",
            "        asgi_http_class: The class to use to handle the ASGI HTTP",
            "            protocol.",
            "        asgi_lifespan_class: The class to use to handle the ASGI",
            "            lifespan protocol.",
            "        asgi_websocket_class: The class to use to handle the ASGI",
            "            websocket protocol.",
            "        config_class: The class to use for the configuration.",
            "        env: The name of the environment the app is running on.",
            "        event_class: The class to use to signal an event in an async",
            "            manner.",
            "        debug: Wrapper around configuration DEBUG value, in many places",
            "            this will result in more output if True. If unset, debug",
            "            mode will be activated if environ is set to 'development'.",
            "        jinja_environment: The class to use for the jinja environment.",
            "        jinja_options: The default options to set when creating the jinja",
            "            environment.",
            "        permanent_session_lifetime: Wrapper around configuration",
            "            PERMANENT_SESSION_LIFETIME value. Specifies how long the session",
            "            data should survive.",
            "        request_class: The class to use for requests.",
            "        response_class: The class to user for responses.",
            "        secret_key: Warpper around configuration SECRET_KEY value. The app",
            "            secret for signing sessions.",
            "        session_interface: The class to use as the session interface.",
            "        shutdown_event: This event is set when the app starts to",
            "            shutdown allowing waiting tasks to know when to stop.",
            "        url_map_class: The class to map rules to endpoints.",
            "        url_rule_class: The class to use for URL rules.",
            "        websocket_class: The class to use for websockets.",
            "",
            "    \"\"\"",
            "",
            "    asgi_http_class: type[ASGIHTTPProtocol]",
            "    asgi_lifespan_class: type[ASGILifespanProtocol]",
            "    asgi_websocket_class: type[ASGIWebsocketProtocol]",
            "    shutdown_event: Event",
            "    test_app_class: type[TestAppProtocol]",
            "    test_client_class: type[TestClientProtocol]  # type: ignore[assignment]",
            "",
            "    aborter_class = Aborter",
            "    app_ctx_globals_class = _AppCtxGlobals",
            "    asgi_http_class = ASGIHTTPConnection",
            "    asgi_lifespan_class = ASGILifespan",
            "    asgi_websocket_class = ASGIWebsocketConnection",
            "    config_class = Config",
            "    event_class = asyncio.Event",
            "    jinja_environment = Environment  # type: ignore[assignment]",
            "    lock_class = asyncio.Lock",
            "    request_class = Request",
            "    response_class = Response",
            "    session_interface = SecureCookieSessionInterface()",
            "    test_app_class = TestApp",
            "    test_client_class = QuartClient  # type: ignore[assignment]",
            "    test_cli_runner_class = QuartCliRunner  # type: ignore",
            "    url_map_class = QuartMap",
            "    url_rule_class = QuartRule  # type: ignore[assignment]",
            "    websocket_class = Websocket",
            "",
            "    default_config = ImmutableDict(",
            "        {",
            "            \"APPLICATION_ROOT\": \"/\",",
            "            \"BACKGROUND_TASK_SHUTDOWN_TIMEOUT\": 5,  # Second",
            "            \"BODY_TIMEOUT\": 60,  # Second",
            "            \"DEBUG\": None,",
            "            \"ENV\": None,",
            "            \"EXPLAIN_TEMPLATE_LOADING\": False,",
            "            \"MAX_CONTENT_LENGTH\": 16 * 1024 * 1024,  # 16 MB Limit",
            "            \"MAX_COOKIE_SIZE\": 4093,",
            "            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),",
            "            # Replaces PREFERRED_URL_SCHEME to allow for WebSocket scheme",
            "            \"PREFER_SECURE_URLS\": False,",
            "            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,",
            "            \"PROPAGATE_EXCEPTIONS\": None,",
            "            \"PROVIDE_AUTOMATIC_OPTIONS\": True,",
            "            \"RESPONSE_TIMEOUT\": 60,  # Second",
            "            \"SECRET_KEY\": None,",
            "            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),",
            "            \"SERVER_NAME\": None,",
            "            \"SESSION_COOKIE_DOMAIN\": None,",
            "            \"SESSION_COOKIE_HTTPONLY\": True,",
            "            \"SESSION_COOKIE_NAME\": \"session\",",
            "            \"SESSION_COOKIE_PATH\": None,",
            "            \"SESSION_COOKIE_SAMESITE\": None,",
            "            \"SESSION_COOKIE_SECURE\": False,",
            "            \"SESSION_REFRESH_EACH_REQUEST\": True,",
            "            \"TEMPLATES_AUTO_RELOAD\": None,",
            "            \"TESTING\": False,",
            "            \"TRAP_BAD_REQUEST_ERRORS\": None,",
            "            \"TRAP_HTTP_EXCEPTIONS\": False,",
            "        }",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        import_name: str,",
            "        static_url_path: str | None = None,",
            "        static_folder: str | None = \"static\",",
            "        static_host: str | None = None,",
            "        host_matching: bool = False,",
            "        subdomain_matching: bool = False,",
            "        template_folder: str | None = \"templates\",",
            "        instance_path: str | None = None,",
            "        instance_relative_config: bool = False,",
            "        root_path: str | None = None,",
            "    ) -> None:",
            "        \"\"\"Construct a Quart web application.",
            "",
            "        Use to create a new web application to which requests should",
            "        be handled, as specified by the various attached url",
            "        rules. See also :class:`~quart.static.PackageStatic` for",
            "        additional constructor arguments.",
            "",
            "        Arguments:",
            "            import_name: The name at import of the application, use",
            "                ``__name__`` unless there is a specific issue.",
            "            host_matching: Optionally choose to match the host to the",
            "                configured host on request (404 if no match).",
            "            instance_path: Optional path to an instance folder, for",
            "                deployment specific settings and files.",
            "            instance_relative_config: If True load the config from a",
            "                path relative to the instance path.",
            "        Attributes:",
            "            after_request_funcs: The functions to execute after a",
            "                request has been handled.",
            "            after_websocket_funcs: The functions to execute after a",
            "                websocket has been handled.",
            "            before_request_funcs: The functions to execute before handling",
            "                a request.",
            "            before_websocket_funcs: The functions to execute before handling",
            "                a websocket.",
            "        \"\"\"",
            "        super().__init__(",
            "            import_name,",
            "            static_url_path,",
            "            static_folder,",
            "            static_host,",
            "            host_matching,",
            "            subdomain_matching,",
            "            template_folder,",
            "            instance_path,",
            "            instance_relative_config,",
            "            root_path,",
            "        )",
            "",
            "        self.after_serving_funcs: list[Callable[[], Awaitable[None]]] = []",
            "        self.after_websocket_funcs: dict[",
            "            AppOrBlueprintKey, list[AfterWebsocketCallable]",
            "        ] = defaultdict(list)",
            "        self.background_tasks: set[asyncio.Task] = set()",
            "        self.before_serving_funcs: list[Callable[[], Awaitable[None]]] = []",
            "        self.before_websocket_funcs: dict[",
            "            AppOrBlueprintKey, list[BeforeWebsocketCallable]",
            "        ] = defaultdict(list)",
            "        self.teardown_websocket_funcs: dict[",
            "            AppOrBlueprintKey, list[TeardownCallable]",
            "        ] = defaultdict(list)",
            "        self.while_serving_gens: list[AsyncGenerator[None, None]] = []",
            "",
            "        self.template_context_processors[None] = [_default_template_ctx_processor]",
            "",
            "        self.cli = AppGroup()",
            "        self.cli.name = self.name",
            "",
            "        if self.has_static_folder:",
            "            assert (",
            "                bool(static_host) == host_matching",
            "            ), \"Invalid static_host/host_matching combination\"",
            "",
            "            self.add_url_rule(",
            "                f\"{self.static_url_path}/<path:filename>\",",
            "                \"static\",",
            "                self.send_static_file,",
            "                host=static_host,",
            "            )",
            "",
            "    def get_send_file_max_age(self, filename: str | None) -> int | None:",
            "        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache",
            "        value for a given file path if it wasn't passed.",
            "",
            "        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from",
            "        the configuration of :data:`~flask.current_app`. This defaults",
            "        to ``None``, which tells the browser to use conditional requests",
            "        instead of a timed cache, which is usually preferable.",
            "",
            "        Note this is a duplicate of the same method in the Quart",
            "        class.",
            "",
            "        \"\"\"",
            "        value = self.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]",
            "",
            "        if value is None:",
            "            return None",
            "",
            "        if isinstance(value, timedelta):",
            "            return int(value.total_seconds())",
            "",
            "        return value",
            "        return None",
            "",
            "    async def send_static_file(self, filename: str) -> Response:",
            "        if not self.has_static_folder:",
            "            raise RuntimeError(\"No static folder for this object\")",
            "        return await send_from_directory(self.static_folder, filename)",
            "",
            "    async def open_resource(",
            "        self,",
            "        path: FilePath,",
            "        mode: str = \"rb\",",
            "    ) -> AiofilesContextManager:",
            "        \"\"\"Open a file for reading.",
            "",
            "        Use as",
            "",
            "        .. code-block:: python",
            "",
            "            async with await app.open_resource(path) as file_:",
            "                await file_.read()",
            "        \"\"\"",
            "        if mode not in {\"r\", \"rb\", \"rt\"}:",
            "            raise ValueError(\"Files can only be opened for reading\")",
            "",
            "        return async_open(os.path.join(self.root_path, path), mode)  # type: ignore",
            "",
            "    async def open_instance_resource(",
            "        self, path: FilePath, mode: str = \"rb\"",
            "    ) -> AiofilesContextManager:",
            "        \"\"\"Open a file for reading.",
            "",
            "        Use as",
            "",
            "        .. code-block:: python",
            "",
            "            async with await app.open_instance_resource(path) as file_:",
            "                await file_.read()",
            "        \"\"\"",
            "        return async_open(self.instance_path / file_path_to_path(path), mode)  # type: ignore",
            "",
            "    def create_jinja_environment(self) -> Environment:  # type: ignore",
            "        \"\"\"Create and return the jinja environment.",
            "",
            "        This will create the environment based on the",
            "        :attr:`jinja_options` and configuration settings. The",
            "        environment will include the Quart globals by default.",
            "        \"\"\"",
            "        options = dict(self.jinja_options)",
            "        if \"autoescape\" not in options:",
            "            options[\"autoescape\"] = self.select_jinja_autoescape",
            "        if \"auto_reload\" not in options:",
            "            options[\"auto_reload\"] = self.config[\"TEMPLATES_AUTO_RELOAD\"]",
            "        jinja_env = self.jinja_environment(self, **options)  # type: ignore",
            "        jinja_env.globals.update(",
            "            {",
            "                \"config\": self.config,",
            "                \"g\": g,",
            "                \"get_flashed_messages\": get_flashed_messages,",
            "                \"request\": request,",
            "                \"session\": session,",
            "                \"url_for\": self.url_for,",
            "            }",
            "        )",
            "        jinja_env.policies[\"json.dumps_function\"] = self.json.dumps",
            "        return jinja_env",
            "",
            "    async def update_template_context(self, context: dict) -> None:",
            "        \"\"\"Update the provided template context.",
            "",
            "        This adds additional context from the various template context",
            "        processors.",
            "",
            "        Arguments:",
            "            context: The context to update (mutate).",
            "        \"\"\"",
            "        names = [None]",
            "        if has_request_context():",
            "            names.extend(reversed(request_ctx.request.blueprints))  # type: ignore",
            "        elif has_websocket_context():",
            "            names.extend(reversed(websocket_ctx.websocket.blueprints))  # type: ignore",
            "",
            "        extra_context: dict[str, Any] = {}",
            "        for name in names:",
            "            for processor in self.template_context_processors[name]:",
            "                extra_context.update(await self.ensure_async(processor)())  # type: ignore[call-overload]",
            "",
            "        original = context.copy()",
            "        context.update(extra_context)",
            "        context.update(original)",
            "",
            "    @setupmethod",
            "    def before_serving(",
            "        self,",
            "        func: T_before_serving,",
            "    ) -> T_before_serving:",
            "        \"\"\"Add a before serving function.",
            "",
            "        This will allow the function provided to be called once before",
            "        anything is served (before any byte is received).",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.before_serving",
            "            async def func():",
            "                ...",
            "",
            "        Arguments:",
            "            func: The function itself.",
            "        \"\"\"",
            "        self.before_serving_funcs.append(func)",
            "        return func",
            "",
            "    @setupmethod",
            "    def while_serving(",
            "        self,",
            "        func: T_while_serving,",
            "    ) -> T_while_serving:",
            "        \"\"\"Add a while serving generator function.",
            "",
            "        This will allow the generator provided to be invoked at",
            "        startup and then again at shutdown.",
            "",
            "        This is designed to be used as a decorator. An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.while_serving",
            "            async def func():",
            "                ...  # Startup",
            "                yield",
            "                ...  # Shutdown",
            "",
            "        Arguments:",
            "            func: The function itself.",
            "",
            "        \"\"\"",
            "        self.while_serving_gens.append(func())",
            "        return func",
            "",
            "    @setupmethod",
            "    def after_serving(",
            "        self,",
            "        func: T_after_serving,",
            "    ) -> T_after_serving:",
            "        \"\"\"Add a after serving function.",
            "",
            "        This will allow the function provided to be called once after",
            "        anything is served (after last byte is sent).",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.after_serving",
            "            async def func():",
            "                ...",
            "",
            "        Arguments:",
            "            func: The function itself.",
            "        \"\"\"",
            "        self.after_serving_funcs.append(func)",
            "        return func",
            "",
            "    def create_url_adapter(",
            "        self, request: BaseRequestWebsocket | None",
            "    ) -> MapAdapter | None:",
            "        \"\"\"Create and return a URL adapter.",
            "",
            "        This will create the adapter based on the request if present",
            "        otherwise the app configuration.",
            "        \"\"\"",
            "        if request is not None:",
            "            subdomain = (",
            "                (self.url_map.default_subdomain or None)",
            "                if not self.subdomain_matching",
            "                else None",
            "            )",
            "",
            "            return self.url_map.bind_to_request(  # type: ignore[attr-defined]",
            "                request, subdomain, self.config[\"SERVER_NAME\"]",
            "            )",
            "",
            "        if self.config[\"SERVER_NAME\"] is not None:",
            "            scheme = \"https\" if self.config[\"PREFER_SECURE_URLS\"] else \"http\"",
            "            return self.url_map.bind(self.config[\"SERVER_NAME\"], url_scheme=scheme)",
            "        return None",
            "",
            "    def websocket(",
            "        self,",
            "        rule: str,",
            "        **options: Any,",
            "    ) -> Callable[[T_websocket], T_websocket]:",
            "        \"\"\"Add a websocket to the application.",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.websocket('/')",
            "            async def websocket_route():",
            "                ...",
            "",
            "        Arguments:",
            "            rule: The path to route on, should start with a ``/``.",
            "            endpoint: Optional endpoint name, if not present the",
            "                function name is used.",
            "            defaults: A dictionary of variables to provide automatically, use",
            "                to provide a simpler default path for a route, e.g. to allow",
            "                for ``/book`` rather than ``/book/0``,",
            "",
            "                .. code-block:: python",
            "",
            "                    @app.websocket('/book', defaults={'page': 0})",
            "                    @app.websocket('/book/<int:page>')",
            "                    def book(page):",
            "                        ...",
            "",
            "            host: The full host name for this route (should include subdomain",
            "                if needed) - cannot be used with subdomain.",
            "            subdomain: A subdomain for this specific route.",
            "            strict_slashes: Strictly match the trailing slash present in the",
            "                path. Will redirect a leaf (no slash) to a branch (with slash).",
            "        \"\"\"",
            "",
            "        def decorator(func: T_websocket) -> T_websocket:",
            "            endpoint = options.pop(\"endpoint\", None)",
            "            self.add_websocket(",
            "                rule,",
            "                endpoint,",
            "                func,",
            "                **options,",
            "            )",
            "            return func",
            "",
            "        return decorator",
            "",
            "    def add_websocket(",
            "        self,",
            "        rule: str,",
            "        endpoint: str | None = None,",
            "        view_func: WebsocketCallable | None = None,",
            "        **options: Any,",
            "    ) -> None:",
            "        \"\"\"Add a websocket url rule to the application.",
            "",
            "        This is designed to be used on the application directly. An",
            "        example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            def websocket_route():",
            "                ...",
            "",
            "            app.add_websocket('/', websocket_route)",
            "",
            "        Arguments:",
            "            rule: The path to route on, should start with a ``/``.",
            "            endpoint: Optional endpoint name, if not present the",
            "                function name is used.",
            "            view_func: Callable that returns a response.",
            "            defaults: A dictionary of variables to provide automatically, use",
            "                to provide a simpler default path for a route, e.g. to allow",
            "                for ``/book`` rather than ``/book/0``,",
            "",
            "                .. code-block:: python",
            "",
            "                    @app.websocket('/book', defaults={'page': 0})",
            "                    @app.websocket('/book/<int:page>')",
            "                    def book(page):",
            "                        ...",
            "",
            "            host: The full host name for this route (should include subdomain",
            "                if needed) - cannot be used with subdomain.",
            "            subdomain: A subdomain for this specific route.",
            "            strict_slashes: Strictly match the trailing slash present in the",
            "                path. Will redirect a leaf (no slash) to a branch (with slash).",
            "        \"\"\"",
            "        return self.add_url_rule(",
            "            rule,",
            "            endpoint,",
            "            view_func,",
            "            methods={\"GET\"},",
            "            websocket=True,",
            "            **options,",
            "        )",
            "",
            "    def url_for(",
            "        self,",
            "        endpoint: str,",
            "        *,",
            "        _anchor: str | None = None,",
            "        _external: bool | None = None,",
            "        _method: str | None = None,",
            "        _scheme: str | None = None,",
            "        **values: Any,",
            "    ) -> str:",
            "        \"\"\"Return the url for a specific endpoint.",
            "",
            "        This is most useful in templates and redirects to create a URL",
            "        that can be used in the browser.",
            "",
            "        Arguments:",
            "            endpoint: The endpoint to build a url for, if prefixed with",
            "                ``.`` it targets endpoint's in the current blueprint.",
            "            _anchor: Additional anchor text to append (i.e. #text).",
            "            _external: Return an absolute url for external (to app) usage.",
            "            _method: The method to consider alongside the endpoint.",
            "            _scheme: A specific scheme to use.",
            "            values: The values to build into the URL, as specified in",
            "                the endpoint rule.",
            "        \"\"\"",
            "",
            "        app_context = _cv_app.get(None)",
            "        request_context = _cv_request.get(None)",
            "        websocket_context = _cv_websocket.get(None)",
            "",
            "        if request_context is not None:",
            "            url_adapter = request_context.url_adapter",
            "            if endpoint.startswith(\".\"):",
            "                if request.blueprint is not None:",
            "                    endpoint = request.blueprint + endpoint",
            "                else:",
            "                    endpoint = endpoint[1:]",
            "            if _external is None:",
            "                _external = _scheme is not None",
            "        elif websocket_context is not None:",
            "            url_adapter = websocket_context.url_adapter",
            "            if endpoint.startswith(\".\"):",
            "                if websocket.blueprint is not None:",
            "                    endpoint = websocket.blueprint + endpoint",
            "                else:",
            "                    endpoint = endpoint[1:]",
            "            if _external is None:",
            "                _external = _scheme is not None",
            "        elif app_context is not None:",
            "            url_adapter = app_context.url_adapter",
            "            if _external is None:",
            "                _external = True",
            "        else:",
            "            url_adapter = self.create_url_adapter(None)",
            "            if _external is None:",
            "                _external = True",
            "",
            "        if url_adapter is None:",
            "            raise RuntimeError(",
            "                \"Unable to create a url adapter, try setting the SERVER_NAME\"",
            "                \" config variable.\"",
            "            )",
            "        if _scheme is not None and not _external:",
            "            raise ValueError(\"External must be True for scheme usage\")",
            "",
            "        self.inject_url_defaults(endpoint, values)",
            "",
            "        old_scheme = None",
            "        if _scheme is not None:",
            "            old_scheme = url_adapter.url_scheme",
            "            url_adapter.url_scheme = _scheme",
            "",
            "        try:",
            "            url = url_adapter.build(",
            "                endpoint, values, method=_method, force_external=_external",
            "            )",
            "        except BuildError as error:",
            "            return self.handle_url_build_error(error, endpoint, values)",
            "        finally:",
            "            if old_scheme is not None:",
            "                url_adapter.url_scheme = old_scheme",
            "",
            "        if _anchor is not None:",
            "            quoted_anchor = quote(_anchor, safe=\"%!#$&'()*+,/:;=?@\")",
            "            url = f\"{url}#{quoted_anchor}\"",
            "        return url",
            "",
            "    def make_shell_context(self) -> dict:",
            "        \"\"\"Create a context for interactive shell usage.",
            "",
            "        The :attr:`shell_context_processors` can be used to add",
            "        additional context.",
            "        \"\"\"",
            "        context = {\"app\": self, \"g\": g}",
            "        for processor in self.shell_context_processors:",
            "            context.update(processor())",
            "        return context",
            "",
            "    def run(",
            "        self,",
            "        host: str | None = None,",
            "        port: int | None = None,",
            "        debug: bool | None = None,",
            "        use_reloader: bool = True,",
            "        loop: asyncio.AbstractEventLoop | None = None,",
            "        ca_certs: str | None = None,",
            "        certfile: str | None = None,",
            "        keyfile: str | None = None,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        \"\"\"Run this application.",
            "",
            "        This is best used for development only, see Hypercorn for",
            "        production servers.",
            "",
            "        Arguments:",
            "            host: Hostname to listen on. By default this is loopback",
            "                only, use 0.0.0.0 to have the server listen externally.",
            "            port: Port number to listen on.",
            "            debug: If set enable (or disable) debug mode and debug output.",
            "            use_reloader: Automatically reload on code changes.",
            "            loop: Asyncio loop to create the server in, if None, take default one.",
            "                If specified it is the caller's responsibility to close and cleanup the",
            "                loop.",
            "            ca_certs: Path to the SSL CA certificate file.",
            "            certfile: Path to the SSL certificate file.",
            "            keyfile: Path to the SSL key file.",
            "        \"\"\"",
            "        if kwargs:",
            "            warnings.warn(",
            "                f\"Additional arguments, {','.join(kwargs.keys())}, are not supported.\\n\"",
            "                \"They may be supported by Hypercorn, which is the ASGI server Quart \"",
            "                \"uses by default. This method is meant for development and debugging.\",",
            "                stacklevel=2,",
            "            )",
            "",
            "        if loop is None:",
            "            loop = asyncio.new_event_loop()",
            "            asyncio.set_event_loop(loop)",
            "",
            "        if \"QUART_DEBUG\" in os.environ:",
            "            self.debug = get_debug_flag()",
            "",
            "        if debug is not None:",
            "            self.debug = debug",
            "",
            "        loop.set_debug(self.debug)",
            "",
            "        shutdown_event = asyncio.Event()",
            "",
            "        def _signal_handler(*_: Any) -> None:",
            "            shutdown_event.set()",
            "",
            "        for signal_name in {\"SIGINT\", \"SIGTERM\", \"SIGBREAK\"}:",
            "            if hasattr(signal, signal_name):",
            "                try:",
            "                    loop.add_signal_handler(",
            "                        getattr(signal, signal_name), _signal_handler",
            "                    )",
            "                except NotImplementedError:",
            "                    # Add signal handler may not be implemented on Windows",
            "                    signal.signal(getattr(signal, signal_name), _signal_handler)",
            "",
            "        server_name = self.config.get(\"SERVER_NAME\")",
            "        sn_host = None",
            "        sn_port = None",
            "        if server_name is not None:",
            "            sn_host, _, sn_port = server_name.partition(\":\")",
            "",
            "        if host is None:",
            "            host = sn_host or \"127.0.0.1\"",
            "",
            "        if port is None:",
            "            port = int(sn_port or \"5000\")",
            "",
            "        task = self.run_task(",
            "            host,",
            "            port,",
            "            debug,",
            "            ca_certs,",
            "            certfile,",
            "            keyfile,",
            "            shutdown_trigger=shutdown_event.wait,  # type: ignore",
            "        )",
            "        print(f\" * Serving Quart app '{self.name}'\")  # noqa: T201",
            "        print(f\" * Debug mode: {self.debug or False}\")  # noqa: T201",
            "        print(\" * Please use an ASGI server (e.g. Hypercorn) directly in production\")  # noqa: T201",
            "        scheme = \"https\" if certfile is not None and keyfile is not None else \"http\"",
            "        print(f\" * Running on {scheme}://{host}:{port} (CTRL + C to quit)\")  # noqa: T201",
            "",
            "        tasks = [loop.create_task(task)]",
            "",
            "        if use_reloader:",
            "            tasks.append(",
            "                loop.create_task(observe_changes(asyncio.sleep, shutdown_event))",
            "            )",
            "",
            "        reload_ = False",
            "        try:",
            "            loop.run_until_complete(asyncio.gather(*tasks))",
            "        except MustReloadError:",
            "            reload_ = True",
            "        finally:",
            "            try:",
            "                _cancel_all_tasks(loop)",
            "                loop.run_until_complete(loop.shutdown_asyncgens())",
            "            finally:",
            "                asyncio.set_event_loop(None)",
            "                loop.close()",
            "",
            "        if reload_:",
            "            restart()",
            "",
            "    def run_task(",
            "        self,",
            "        host: str = \"127.0.0.1\",",
            "        port: int = 5000,",
            "        debug: bool | None = None,",
            "        ca_certs: str | None = None,",
            "        certfile: str | None = None,",
            "        keyfile: str | None = None,",
            "        shutdown_trigger: Callable[..., Awaitable[None]] | None = None,",
            "    ) -> Coroutine[None, None, None]:",
            "        \"\"\"Return a task that when awaited runs this application.",
            "",
            "        This is best used for development only, see Hypercorn for",
            "        production servers.",
            "",
            "        Arguments:",
            "            host: Hostname to listen on. By default this is loopback",
            "                only, use 0.0.0.0 to have the server listen externally.",
            "            port: Port number to listen on.",
            "            debug: If set enable (or disable) debug mode and debug output.",
            "            ca_certs: Path to the SSL CA certificate file.",
            "            certfile: Path to the SSL certificate file.",
            "            keyfile: Path to the SSL key file.",
            "",
            "        \"\"\"",
            "        config = HyperConfig()",
            "        config.access_log_format = \"%(h)s %(r)s %(s)s %(b)s %(D)s\"",
            "        config.accesslog = \"-\"",
            "        config.bind = [f\"{host}:{port}\"]",
            "        config.ca_certs = ca_certs",
            "        config.certfile = certfile",
            "        if debug is not None:",
            "            self.debug = debug",
            "        config.errorlog = config.accesslog",
            "        config.keyfile = keyfile",
            "",
            "        return serve(self, config, shutdown_trigger=shutdown_trigger)",
            "",
            "    def test_client(",
            "        self, use_cookies: bool = True, **kwargs: Any",
            "    ) -> TestClientProtocol:",
            "        \"\"\"Creates and returns a test client.\"\"\"",
            "        return self.test_client_class(self, use_cookies=use_cookies, **kwargs)",
            "",
            "    def test_cli_runner(self, **kwargs: Any) -> QuartCliRunner:",
            "        \"\"\"Creates and returns a CLI test runner.\"\"\"",
            "        return self.test_cli_runner_class(self, **kwargs)  # type: ignore",
            "",
            "    @setupmethod",
            "    def before_websocket(",
            "        self,",
            "        func: T_before_websocket,",
            "    ) -> T_before_websocket:",
            "        \"\"\"Add a before websocket function.",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.before_websocket",
            "            async def func():",
            "                ...",
            "",
            "        Arguments:",
            "            func: The before websocket function itself.",
            "        \"\"\"",
            "        self.before_websocket_funcs[None].append(func)",
            "        return func",
            "",
            "    @setupmethod",
            "    def after_websocket(",
            "        self,",
            "        func: T_after_websocket,",
            "    ) -> T_after_websocket:",
            "        \"\"\"Add an after websocket function.",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.after_websocket",
            "            async def func(response):",
            "                return response",
            "",
            "        Arguments:",
            "            func: The after websocket function itself.",
            "        \"\"\"",
            "        self.after_websocket_funcs[None].append(func)",
            "        return func",
            "",
            "    @setupmethod",
            "    def teardown_websocket(",
            "        self,",
            "        func: T_teardown,",
            "    ) -> T_teardown:",
            "        \"\"\"Add a teardown websocket function.",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "        .. code-block:: python",
            "            @app.teardown_websocket",
            "            async def func():",
            "                ...",
            "        Arguments:",
            "            func: The teardown websocket function itself.",
            "        \"\"\"",
            "        self.teardown_websocket_funcs[None].append(func)",
            "        return func",
            "",
            "    async def handle_http_exception(",
            "        self, error: HTTPException",
            "    ) -> HTTPException | ResponseReturnValue:",
            "        \"\"\"Handle a HTTPException subclass error.",
            "",
            "        This will attempt to find a handler for the error and if fails",
            "        will fall back to the error response.",
            "        \"\"\"",
            "        if error.code is None:",
            "            return error",
            "",
            "        if isinstance(error, RoutingException):",
            "            return error",
            "",
            "        blueprints = []",
            "        if has_request_context():",
            "            blueprints = request.blueprints",
            "        elif has_websocket_context():",
            "            blueprints = websocket.blueprints",
            "",
            "        handler = self._find_error_handler(error, blueprints)",
            "        if handler is None:",
            "            return error",
            "        else:",
            "            return await self.ensure_async(handler)(error)  # type: ignore[return-value]",
            "",
            "    async def handle_user_exception(",
            "        self, error: Exception",
            "    ) -> HTTPException | ResponseReturnValue:",
            "        \"\"\"Handle an exception that has been raised.",
            "",
            "        This should forward :class:`~quart.exception.HTTPException` to",
            "        :meth:`handle_http_exception`, then attempt to handle the",
            "        error. If it cannot it should reraise the error.",
            "        \"\"\"",
            "        if isinstance(error, BadRequestKeyError) and (",
            "            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]",
            "        ):",
            "            error.show_exception = True",
            "",
            "        if isinstance(error, HTTPException) and not self.trap_http_exception(error):",
            "            return await self.handle_http_exception(error)",
            "",
            "        blueprints = []",
            "        if has_request_context():",
            "            blueprints = request.blueprints",
            "        elif has_websocket_context():",
            "            blueprints = websocket.blueprints",
            "",
            "        handler = self._find_error_handler(error, blueprints)",
            "        if handler is None:",
            "            raise error",
            "        return await self.ensure_async(handler)(error)  # type: ignore[return-value]",
            "",
            "    async def handle_exception(self, error: Exception) -> ResponseTypes:",
            "        \"\"\"Handle an uncaught exception.",
            "",
            "        By default this switches the error response to a 500 internal",
            "        server error.",
            "        \"\"\"",
            "        exc_info = sys.exc_info()",
            "        await got_request_exception.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exception=error,",
            "        )",
            "        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]",
            "",
            "        if propagate is None:",
            "            propagate = self.testing or self.debug",
            "",
            "        if propagate:",
            "            # Re-raise if called with an active exception, otherwise",
            "            # raise the passed in exception.",
            "            if exc_info[1] is error:",
            "                raise",
            "",
            "            raise error",
            "",
            "        self.log_exception(exc_info)",
            "        server_error: InternalServerError | ResponseReturnValue",
            "        server_error = InternalServerError(original_exception=error)",
            "        handler = self._find_error_handler(server_error, request.blueprints)",
            "",
            "        if handler is not None:",
            "            server_error = await self.ensure_async(handler)(server_error)  # type: ignore[assignment]",
            "",
            "        return await self.finalize_request(server_error, from_error_handler=True)",
            "",
            "    async def handle_websocket_exception(",
            "        self, error: Exception",
            "    ) -> ResponseTypes | None:",
            "        \"\"\"Handle an uncaught exception.",
            "",
            "        By default this logs the exception and then re-raises it.",
            "        \"\"\"",
            "        exc_info = sys.exc_info()",
            "        await got_websocket_exception.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exception=error,",
            "        )",
            "        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]",
            "",
            "        if propagate is None:",
            "            propagate = self.testing or self.debug",
            "",
            "        if propagate:",
            "            # Re-raise if called with an active exception, otherwise",
            "            # raise the passed in exception.",
            "            if exc_info[1] is error:",
            "                raise",
            "",
            "            raise error",
            "",
            "        self.log_exception(exc_info)",
            "        server_error: InternalServerError | ResponseReturnValue",
            "        server_error = InternalServerError(original_exception=error)",
            "        handler = self._find_error_handler(server_error, websocket.blueprints)",
            "",
            "        if handler is not None:",
            "            server_error = await self.ensure_async(handler)(server_error)  # type: ignore[assignment]",
            "",
            "        return await self.finalize_websocket(server_error, from_error_handler=True)",
            "",
            "    def log_exception(",
            "        self,",
            "        exception_info: tuple[type, BaseException, TracebackType]",
            "        | tuple[None, None, None],",
            "    ) -> None:",
            "        \"\"\"Log a exception to the :attr:`logger`.",
            "",
            "        By default this is only invoked for unhandled exceptions.",
            "        \"\"\"",
            "        if has_request_context():",
            "            request_ = request_ctx.request",
            "            self.logger.error(",
            "                f\"Exception on request {request_.method} {request_.path}\",",
            "                exc_info=exception_info,",
            "            )",
            "        elif has_websocket_context():",
            "            websocket_ = websocket_ctx.websocket",
            "            self.logger.error(",
            "                f\"Exception on websocket {websocket_.path}\", exc_info=exception_info",
            "            )",
            "        else:",
            "            self.logger.error(\"Exception\", exc_info=exception_info)",
            "",
            "    @overload",
            "    def ensure_async(",
            "        self, func: Callable[P, Awaitable[T]]",
            "    ) -> Callable[P, Awaitable[T]]: ...",
            "",
            "    @overload",
            "    def ensure_async(self, func: Callable[P, T]) -> Callable[P, Awaitable[T]]: ...",
            "",
            "    def ensure_async(",
            "        self, func: Callable[P, Awaitable[T]] | Callable[P, T]",
            "    ) -> Callable[P, Awaitable[T]]:",
            "        \"\"\"Ensure that the returned func is async and calls the func.",
            "",
            "        .. versionadded:: 0.11",
            "",
            "        Override if you wish to change how synchronous functions are",
            "        run. Before Quart 0.11 this did not run the synchronous code",
            "        in an executor.",
            "        \"\"\"",
            "        if iscoroutinefunction(func):",
            "            return func",
            "        else:",
            "            return self.sync_to_async(cast(Callable[P, T], func))",
            "",
            "    def sync_to_async(self, func: Callable[P, T]) -> Callable[P, Awaitable[T]]:",
            "        \"\"\"Return a async function that will run the synchronous function *func*.",
            "",
            "        This can be used as so,::",
            "",
            "            result = await app.sync_to_async(func)(*args, **kwargs)",
            "",
            "        Override this method to change how the app converts sync code",
            "        to be asynchronously callable.",
            "        \"\"\"",
            "        return run_sync(func)",
            "",
            "    async def do_teardown_request(",
            "        self, exc: BaseException | None, request_context: RequestContext | None = None",
            "    ) -> None:",
            "        \"\"\"Teardown the request, calling the teardown functions.",
            "",
            "        Arguments:",
            "            exc: Any exception not handled that has caused the request",
            "                to teardown.",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(request_context or request_ctx).request.blueprints, None]",
            "        for name in names:",
            "            for function in reversed(self.teardown_request_funcs[name]):",
            "                await self.ensure_async(function)(exc)",
            "",
            "        await request_tearing_down.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exc=exc,",
            "        )",
            "",
            "    async def do_teardown_websocket(",
            "        self,",
            "        exc: BaseException | None,",
            "        websocket_context: WebsocketContext | None = None,",
            "    ) -> None:",
            "        \"\"\"Teardown the websocket, calling the teardown functions.",
            "",
            "        Arguments:",
            "            exc: Any exception not handled that has caused the websocket",
            "                to teardown.",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(websocket_context or websocket_ctx).websocket.blueprints, None]",
            "        for name in names:",
            "            for function in reversed(self.teardown_websocket_funcs[name]):",
            "                await self.ensure_async(function)(exc)",
            "",
            "        await websocket_tearing_down.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exc=exc,",
            "        )",
            "",
            "    async def do_teardown_appcontext(self, exc: BaseException | None) -> None:",
            "        \"\"\"Teardown the app (context), calling the teardown functions.\"\"\"",
            "        for function in self.teardown_appcontext_funcs:",
            "            await self.ensure_async(function)(exc)",
            "        await appcontext_tearing_down.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exc=exc,",
            "        )",
            "",
            "    def app_context(self) -> AppContext:",
            "        \"\"\"Create and return an app context.",
            "",
            "        This is best used within a context, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.app_context():",
            "                ...",
            "        \"\"\"",
            "        return AppContext(self)",
            "",
            "    def request_context(self, request: Request) -> RequestContext:",
            "        \"\"\"Create and return a request context.",
            "",
            "        Use the :meth:`test_request_context` whilst testing. This is",
            "        best used within a context, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.request_context(request):",
            "                ...",
            "",
            "        Arguments:",
            "            request: A request to build a context around.",
            "        \"\"\"",
            "        return RequestContext(self, request)",
            "",
            "    def websocket_context(self, websocket: Websocket) -> WebsocketContext:",
            "        \"\"\"Create and return a websocket context.",
            "",
            "        Use the :meth:`test_websocket_context` whilst testing. This is",
            "        best used within a context, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.websocket_context(websocket):",
            "                ...",
            "",
            "        Arguments:",
            "            websocket: A websocket to build a context around.",
            "        \"\"\"",
            "        return WebsocketContext(self, websocket)",
            "",
            "    def test_app(self) -> TestAppProtocol:",
            "        return self.test_app_class(self)",
            "",
            "    def test_request_context(",
            "        self,",
            "        path: str,",
            "        *,",
            "        method: str = \"GET\",",
            "        headers: dict | Headers | None = None,",
            "        query_string: dict | None = None,",
            "        scheme: str = \"http\",",
            "        send_push_promise: Callable[[str, Headers], Awaitable[None]] = no_op_push,",
            "        data: AnyStr | None = None,",
            "        form: dict | None = None,",
            "        json: Any = sentinel,",
            "        root_path: str = \"\",",
            "        http_version: str = \"1.1\",",
            "        scope_base: dict | None = None,",
            "        auth: Authorization | tuple[str, str] | None = None,",
            "        subdomain: str | None = None,",
            "    ) -> RequestContext:",
            "        \"\"\"Create a request context for testing purposes.",
            "",
            "        This is best used for testing code within request contexts. It",
            "        is a simplified wrapper of :meth:`request_context`. It is best",
            "        used in a with block, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.test_request_context(\"/\", method=\"GET\"):",
            "                ...",
            "",
            "        Arguments:",
            "            path: Request path.",
            "            method: HTTP verb",
            "            headers: Headers to include in the request.",
            "            query_string: To send as a dictionary, alternatively the",
            "                query_string can be determined from the path.",
            "            scheme: Scheme for the request, default http.",
            "        \"\"\"",
            "        headers, path, query_string_bytes = make_test_headers_path_and_query_string(",
            "            self,",
            "            path,",
            "            headers,",
            "            query_string,",
            "            auth,",
            "            subdomain,",
            "        )",
            "        request_body, body_headers = make_test_body_with_headers(",
            "            data=data, form=form, json=json",
            "        )",
            "        headers.update(**body_headers)",
            "        scope = make_test_scope(",
            "            \"http\",",
            "            path,",
            "            method,",
            "            headers,",
            "            query_string_bytes,",
            "            scheme,",
            "            root_path,",
            "            http_version,",
            "            scope_base,",
            "        )",
            "        request = self.request_class(",
            "            method,",
            "            scheme,",
            "            path,",
            "            query_string_bytes,",
            "            headers,",
            "            root_path,",
            "            http_version,",
            "            send_push_promise=send_push_promise,",
            "            scope=scope,",
            "        )",
            "        request.body.set_result(request_body)",
            "        return self.request_context(request)",
            "",
            "    def add_background_task(self, func: Callable, *args: Any, **kwargs: Any) -> None:",
            "        async def _wrapper() -> None:",
            "            try:",
            "                async with self.app_context():",
            "                    await self.ensure_async(func)(*args, **kwargs)",
            "            except Exception as error:",
            "                await self.handle_background_exception(error)",
            "",
            "        task = asyncio.get_event_loop().create_task(_wrapper())",
            "        self.background_tasks.add(task)",
            "        task.add_done_callback(self.background_tasks.discard)",
            "",
            "    async def handle_background_exception(self, error: Exception) -> None:",
            "        await got_background_exception.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exception=error,",
            "        )",
            "",
            "        self.log_exception(sys.exc_info())",
            "",
            "    async def make_default_options_response(self) -> Response:",
            "        \"\"\"This is the default route function for OPTIONS requests.\"\"\"",
            "        methods = request_ctx.url_adapter.allowed_methods()",
            "        return self.response_class(\"\", headers={\"Allow\": \", \".join(methods)})",
            "",
            "    async def make_response(",
            "        self, result: ResponseReturnValue | HTTPException",
            "    ) -> ResponseTypes:",
            "        \"\"\"Make a Response from the result of the route handler.",
            "",
            "        The result itself can either be:",
            "          - A Response object (or subclass).",
            "          - A tuple of a ResponseValue and a header dictionary.",
            "          - A tuple of a ResponseValue, status code and a header dictionary.",
            "",
            "        A ResponseValue is either a Response object (or subclass) or a str.",
            "        \"\"\"",
            "        headers: HeadersValue | None = None",
            "        status: StatusCode | None = None",
            "        if isinstance(result, tuple):",
            "            if len(result) == 3:",
            "                value, status, headers = result",
            "            elif len(result) == 2:",
            "                value, status_or_headers = result",
            "",
            "                if isinstance(status_or_headers, (Headers, dict, list)):",
            "                    headers = status_or_headers",
            "                    status = None",
            "                elif status_or_headers is not None:",
            "                    status = status_or_headers  # type: ignore[assignment]",
            "            else:",
            "                raise TypeError(",
            "                    \"\"\"The response value returned must be either (body, status), (body,",
            "                    headers), or (body, status, headers)\"\"\"",
            "                )",
            "        else:",
            "            value = result  # type: ignore[assignment]",
            "",
            "        if value is None:",
            "            raise TypeError(",
            "                \"The response value returned by the view function cannot be None\"",
            "            )",
            "",
            "        response: ResponseTypes",
            "        if isinstance(value, HTTPException):",
            "            response = value.get_response()  # type: ignore",
            "        elif not isinstance(value, (Response, WerkzeugResponse)):",
            "            if (",
            "                isinstance(value, (str, bytes, bytearray))",
            "                or isgenerator(value)",
            "                or isasyncgen(value)",
            "            ):",
            "                response = self.response_class(value)",
            "            elif isinstance(value, (list, dict)):",
            "                response = self.json.response(value)  # type: ignore[assignment]",
            "            else:",
            "                raise TypeError(",
            "                    f\"The response value type ({type(value).__name__}) is not valid\"",
            "                )",
            "        else:",
            "            response = value",
            "",
            "        if status is not None:",
            "            response.status_code = int(status)",
            "",
            "        if headers is not None:",
            "            response.headers.update(headers)",
            "",
            "        return response",
            "",
            "    async def handle_request(self, request: Request) -> ResponseTypes:",
            "        async with self.request_context(request) as request_context:",
            "            try:",
            "                return await self.full_dispatch_request(request_context)",
            "            except asyncio.CancelledError:",
            "                raise  # CancelledErrors should be handled by serving code.",
            "            except Exception as error:",
            "                return await self.handle_exception(error)",
            "            finally:",
            "                if request.scope.get(\"_quart._preserve_context\", False):",
            "                    self._preserved_context = request_context.copy()",
            "",
            "    async def handle_websocket(self, websocket: Websocket) -> ResponseTypes | None:",
            "        async with self.websocket_context(websocket) as websocket_context:",
            "            try:",
            "                return await self.full_dispatch_websocket(websocket_context)",
            "            except asyncio.CancelledError:",
            "                raise  # CancelledErrors should be handled by serving code.",
            "            except Exception as error:",
            "                return await self.handle_websocket_exception(error)",
            "            finally:",
            "                if websocket.scope.get(\"_quart._preserve_context\", False):",
            "                    self._preserved_context = websocket_context.copy()",
            "",
            "    async def full_dispatch_request(",
            "        self, request_context: RequestContext | None = None",
            "    ) -> ResponseTypes:",
            "        \"\"\"Adds pre and post processing to the request dispatching.",
            "",
            "        Arguments:",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        try:",
            "            await request_started.send_async(self, _sync_wrapper=self.ensure_async)  # type: ignore",
            "",
            "            result: ResponseReturnValue | HTTPException | None",
            "            result = await self.preprocess_request(request_context)",
            "            if result is None:",
            "                result = await self.dispatch_request(request_context)",
            "        except Exception as error:",
            "            result = await self.handle_user_exception(error)",
            "        return await self.finalize_request(result, request_context)",
            "",
            "    async def full_dispatch_websocket(",
            "        self, websocket_context: WebsocketContext | None = None",
            "    ) -> ResponseTypes | None:",
            "        \"\"\"Adds pre and post processing to the websocket dispatching.",
            "",
            "        Arguments:",
            "            websocket_context: The websocket context, optional to match",
            "                the Flask convention.",
            "        \"\"\"",
            "        try:",
            "            await websocket_started.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore",
            "            )",
            "",
            "            result: ResponseReturnValue | HTTPException | None",
            "            result = await self.preprocess_websocket(websocket_context)",
            "            if result is None:",
            "                result = await self.dispatch_websocket(websocket_context)",
            "        except Exception as error:",
            "            result = await self.handle_user_exception(error)",
            "        return await self.finalize_websocket(result, websocket_context)",
            "",
            "    async def preprocess_request(",
            "        self, request_context: RequestContext | None = None",
            "    ) -> ResponseReturnValue | None:",
            "        \"\"\"Preprocess the request i.e. call before_request functions.",
            "",
            "        Arguments:",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [None, *reversed((request_context or request_ctx).request.blueprints)]",
            "",
            "        for name in names:",
            "            for processor in self.url_value_preprocessors[name]:",
            "                processor(request.endpoint, request.view_args)",
            "",
            "        for name in names:",
            "            for function in self.before_request_funcs[name]:",
            "                result = await self.ensure_async(function)()",
            "                if result is not None:",
            "                    return result  # type: ignore[return-value]",
            "",
            "        return None",
            "",
            "    async def preprocess_websocket(",
            "        self, websocket_context: WebsocketContext | None = None",
            "    ) -> ResponseReturnValue | None:",
            "        \"\"\"Preprocess the websocket i.e. call before_websocket functions.",
            "",
            "        Arguments:",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [",
            "            None,",
            "            *reversed((websocket_context or websocket_ctx).websocket.blueprints),",
            "        ]",
            "",
            "        for name in names:",
            "            for processor in self.url_value_preprocessors[name]:",
            "                processor(request.endpoint, request.view_args)",
            "",
            "        for name in names:",
            "            for function in self.before_websocket_funcs[name]:",
            "                result = await self.ensure_async(function)()",
            "                if result is not None:",
            "                    return result  # type: ignore[return-value]",
            "",
            "        return None",
            "",
            "    def raise_routing_exception(self, request: BaseRequestWebsocket) -> NoReturn:",
            "        raise request.routing_exception",
            "",
            "    async def dispatch_request(",
            "        self, request_context: RequestContext | None = None",
            "    ) -> ResponseReturnValue:",
            "        \"\"\"Dispatch the request to the view function.",
            "",
            "        Arguments:",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        request_ = (request_context or request_ctx).request",
            "        if request_.routing_exception is not None:",
            "            self.raise_routing_exception(request_)",
            "",
            "        if request_.method == \"OPTIONS\" and request_.url_rule.provide_automatic_options:",
            "            return await self.make_default_options_response()",
            "",
            "        handler = self.view_functions[request_.url_rule.endpoint]",
            "        return await self.ensure_async(handler)(**request_.view_args)  # type: ignore[return-value]",
            "",
            "    async def dispatch_websocket(",
            "        self, websocket_context: WebsocketContext | None = None",
            "    ) -> ResponseReturnValue | None:",
            "        \"\"\"Dispatch the websocket to the view function.",
            "",
            "        Arguments:",
            "            websocket_context: The websocket context, optional to match",
            "                the Flask convention.",
            "        \"\"\"",
            "        websocket_ = (websocket_context or websocket_ctx).websocket",
            "        if websocket_.routing_exception is not None:",
            "            self.raise_routing_exception(websocket_)",
            "",
            "        handler = self.view_functions[websocket_.url_rule.endpoint]",
            "        return await self.ensure_async(handler)(**websocket_.view_args)  # type: ignore[return-value]",
            "",
            "    async def finalize_request(",
            "        self,",
            "        result: ResponseReturnValue | HTTPException,",
            "        request_context: RequestContext | None = None,",
            "        from_error_handler: bool = False,",
            "    ) -> ResponseTypes:",
            "        \"\"\"Turns the view response return value into a response.",
            "",
            "        Arguments:",
            "            result: The result of the request to finalize into a response.",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        response = await self.make_response(result)",
            "        try:",
            "            response = await self.process_response(response, request_context)",
            "            await request_finished.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                response=response,",
            "            )",
            "        except Exception:",
            "            if not from_error_handler:",
            "                raise",
            "            self.logger.exception(\"Request finalizing errored\")",
            "        return response",
            "",
            "    async def finalize_websocket(",
            "        self,",
            "        result: ResponseReturnValue | HTTPException,",
            "        websocket_context: WebsocketContext | None = None,",
            "        from_error_handler: bool = False,",
            "    ) -> ResponseTypes | None:",
            "        \"\"\"Turns the view response return value into a response.",
            "",
            "        Arguments:",
            "            result: The result of the websocket to finalize into a response.",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        if result is not None:",
            "            response = await self.make_response(result)",
            "        else:",
            "            response = None",
            "        try:",
            "            response = await self.postprocess_websocket(response, websocket_context)",
            "            await websocket_finished.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                response=response,",
            "            )",
            "        except Exception:",
            "            if not from_error_handler:",
            "                raise",
            "            self.logger.exception(\"Request finalizing errored\")",
            "        return response",
            "",
            "    async def process_response(",
            "        self,",
            "        response: ResponseTypes,",
            "        request_context: RequestContext | None = None,",
            "    ) -> ResponseTypes:",
            "        \"\"\"Postprocess the request acting on the response.",
            "",
            "        Arguments:",
            "            response: The response after the request is finalized.",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(request_context or request_ctx).request.blueprints, None]",
            "",
            "        for function in (request_context or request_ctx)._after_request_functions:",
            "            response = await self.ensure_async(function)(response)  # type: ignore[assignment]",
            "",
            "        for name in names:",
            "            for function in reversed(self.after_request_funcs[name]):",
            "                response = await self.ensure_async(function)(response)",
            "",
            "        session_ = (request_context or request_ctx).session",
            "        if not self.session_interface.is_null_session(session_):",
            "            await self.ensure_async(self.session_interface.save_session)(",
            "                self, session_, response",
            "            )",
            "        return response",
            "",
            "    async def postprocess_websocket(",
            "        self,",
            "        response: ResponseTypes | None,",
            "        websocket_context: WebsocketContext | None = None,",
            "    ) -> ResponseTypes:",
            "        \"\"\"Postprocess the websocket acting on the response.",
            "",
            "        Arguments:",
            "            response: The response after the websocket is finalized.",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(websocket_context or websocket_ctx).websocket.blueprints, None]",
            "",
            "        for function in (websocket_context or websocket_ctx)._after_websocket_functions:",
            "            response = await self.ensure_async(function)(response)  # type: ignore[assignment]",
            "",
            "        for name in names:",
            "            for function in reversed(self.after_websocket_funcs[name]):",
            "                response = await self.ensure_async(function)(response)  # type: ignore[assignment]",
            "",
            "        session_ = (websocket_context or websocket_ctx).session",
            "        if not self.session_interface.is_null_session(session_):",
            "            await self.session_interface.save_session(self, session_, response)",
            "        return response",
            "",
            "    async def __call__(",
            "        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable",
            "    ) -> None:",
            "        \"\"\"Called by ASGI servers.",
            "",
            "        The related :meth:`~quart.app.Quart.asgi_app` is called,",
            "        allowing for middleware usage whilst keeping the top level app",
            "        a :class:`~quart.app.Quart` instance.",
            "        \"\"\"",
            "        await self.asgi_app(scope, receive, send)",
            "",
            "    async def asgi_app(",
            "        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable",
            "    ) -> None:",
            "        \"\"\"This handles ASGI calls, it can be wrapped in middleware.",
            "",
            "        When using middleware with Quart it is preferable to wrap this",
            "        method rather than the app itself. This is to ensure that the",
            "        app is an instance of this class - which allows the quart cli",
            "        to work correctly. To use this feature simply do,",
            "",
            "        .. code-block:: python",
            "",
            "            app.asgi_app = middleware(app.asgi_app)",
            "",
            "        \"\"\"",
            "        asgi_handler: ASGIHTTPProtocol | ASGILifespanProtocol | ASGIWebsocketProtocol",
            "        if scope[\"type\"] == \"http\":",
            "            asgi_handler = self.asgi_http_class(self, scope)",
            "        elif scope[\"type\"] == \"websocket\":",
            "            asgi_handler = self.asgi_websocket_class(self, scope)",
            "        elif scope[\"type\"] == \"lifespan\":",
            "            asgi_handler = self.asgi_lifespan_class(self, scope)",
            "        else:",
            "            raise RuntimeError(\"ASGI Scope type is unknown\")",
            "        await asgi_handler(receive, send)",
            "",
            "    async def startup(self) -> None:",
            "        self.shutdown_event = self.event_class()",
            "        try:",
            "            async with self.app_context():",
            "                for func in self.before_serving_funcs:",
            "                    await self.ensure_async(func)()",
            "                for gen in self.while_serving_gens:",
            "                    await gen.__anext__()",
            "        except Exception as error:",
            "            await got_serving_exception.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                exception=error,",
            "            )",
            "            self.log_exception(sys.exc_info())",
            "            raise",
            "",
            "    async def shutdown(self) -> None:",
            "        self.shutdown_event.set()",
            "        try:",
            "            await asyncio.wait_for(",
            "                asyncio.gather(*self.background_tasks),",
            "                timeout=self.config[\"BACKGROUND_TASK_SHUTDOWN_TIMEOUT\"],",
            "            )",
            "        except asyncio.TimeoutError:",
            "            await cancel_tasks(self.background_tasks)",
            "",
            "        try:",
            "            async with self.app_context():",
            "                for func in self.after_serving_funcs:",
            "                    await self.ensure_async(func)()",
            "                for gen in self.while_serving_gens:",
            "                    try:",
            "                        await gen.__anext__()",
            "                    except StopAsyncIteration:",
            "                        pass",
            "                    else:",
            "                        raise RuntimeError(\"While serving generator didn't terminate\")",
            "        except Exception as error:",
            "            await got_serving_exception.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                exception=error,",
            "            )",
            "            self.log_exception(sys.exc_info())",
            "            raise",
            "",
            "",
            "def _cancel_all_tasks(loop: asyncio.AbstractEventLoop) -> None:",
            "    tasks = [task for task in asyncio.all_tasks(loop) if not task.done()]",
            "    if not tasks:",
            "        return",
            "",
            "    for task in tasks:",
            "        task.cancel()",
            "    loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))",
            "",
            "    for task in tasks:",
            "        if not task.cancelled() and task.exception() is not None:",
            "            loop.call_exception_handler(",
            "                {",
            "                    \"message\": \"unhandled exception during shutdown\",",
            "                    \"exception\": task.exception(),",
            "                    \"task\": task,",
            "                }",
            "            )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import os",
            "import signal",
            "import sys",
            "import warnings",
            "from collections import defaultdict",
            "from collections.abc import AsyncGenerator",
            "from collections.abc import Awaitable",
            "from collections.abc import Coroutine",
            "from datetime import timedelta",
            "from inspect import isasyncgen",
            "from inspect import iscoroutinefunction as _inspect_iscoroutinefunction",
            "from inspect import isgenerator",
            "from types import TracebackType",
            "from typing import Any",
            "from typing import AnyStr",
            "from typing import Callable",
            "from typing import cast",
            "from typing import NoReturn",
            "from typing import Optional",
            "from typing import overload",
            "from typing import TypeVar",
            "from urllib.parse import quote",
            "",
            "from aiofiles import open as async_open",
            "from aiofiles.base import AiofilesContextManager",
            "from flask.sansio.app import App",
            "from flask.sansio.scaffold import setupmethod",
            "from hypercorn.asyncio import serve",
            "from hypercorn.config import Config as HyperConfig",
            "from hypercorn.typing import ASGIReceiveCallable",
            "from hypercorn.typing import ASGISendCallable",
            "from hypercorn.typing import Scope",
            "from werkzeug.datastructures import Authorization",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.datastructures import ImmutableDict",
            "from werkzeug.exceptions import Aborter",
            "from werkzeug.exceptions import BadRequestKeyError",
            "from werkzeug.exceptions import HTTPException",
            "from werkzeug.exceptions import InternalServerError",
            "from werkzeug.routing import BuildError",
            "from werkzeug.routing import MapAdapter",
            "from werkzeug.routing import RoutingException",
            "from werkzeug.wrappers import Response as WerkzeugResponse",
            "",
            "from .asgi import ASGIHTTPConnection",
            "from .asgi import ASGILifespan",
            "from .asgi import ASGIWebsocketConnection",
            "from .cli import AppGroup",
            "from .config import Config",
            "from .ctx import _AppCtxGlobals",
            "from .ctx import AppContext",
            "from .ctx import has_request_context",
            "from .ctx import has_websocket_context",
            "from .ctx import RequestContext",
            "from .ctx import WebsocketContext",
            "from .globals import _cv_app",
            "from .globals import _cv_request",
            "from .globals import _cv_websocket",
            "from .globals import g",
            "from .globals import request",
            "from .globals import request_ctx",
            "from .globals import session",
            "from .globals import websocket",
            "from .globals import websocket_ctx",
            "from .helpers import get_debug_flag",
            "from .helpers import get_flashed_messages",
            "from .helpers import send_from_directory",
            "from .routing import QuartMap",
            "from .routing import QuartRule",
            "from .sessions import SecureCookieSessionInterface",
            "from .signals import appcontext_tearing_down",
            "from .signals import got_background_exception",
            "from .signals import got_request_exception",
            "from .signals import got_serving_exception",
            "from .signals import got_websocket_exception",
            "from .signals import request_finished",
            "from .signals import request_started",
            "from .signals import request_tearing_down",
            "from .signals import websocket_finished",
            "from .signals import websocket_started",
            "from .signals import websocket_tearing_down",
            "from .templating import _default_template_ctx_processor",
            "from .templating import Environment",
            "from .testing import make_test_body_with_headers",
            "from .testing import make_test_headers_path_and_query_string",
            "from .testing import make_test_scope",
            "from .testing import no_op_push",
            "from .testing import QuartClient",
            "from .testing import QuartCliRunner",
            "from .testing import sentinel",
            "from .testing import TestApp",
            "from .typing import AfterServingCallable",
            "from .typing import AfterWebsocketCallable",
            "from .typing import ASGIHTTPProtocol",
            "from .typing import ASGILifespanProtocol",
            "from .typing import ASGIWebsocketProtocol",
            "from .typing import BeforeServingCallable",
            "from .typing import BeforeWebsocketCallable",
            "from .typing import Event",
            "from .typing import FilePath",
            "from .typing import HeadersValue",
            "from .typing import ResponseReturnValue",
            "from .typing import ResponseTypes",
            "from .typing import ShellContextProcessorCallable",
            "from .typing import StatusCode",
            "from .typing import TeardownCallable",
            "from .typing import TemplateFilterCallable",
            "from .typing import TemplateGlobalCallable",
            "from .typing import TemplateTestCallable",
            "from .typing import TestAppProtocol",
            "from .typing import TestClientProtocol",
            "from .typing import WebsocketCallable",
            "from .typing import WhileServingCallable",
            "from .utils import cancel_tasks",
            "from .utils import file_path_to_path",
            "from .utils import MustReloadError",
            "from .utils import observe_changes",
            "from .utils import restart",
            "from .utils import run_sync",
            "from .wrappers import BaseRequestWebsocket",
            "from .wrappers import Request",
            "from .wrappers import Response",
            "from .wrappers import Websocket",
            "",
            "if sys.version_info >= (3, 10):",
            "    from typing import ParamSpec",
            "else:",
            "    from typing_extensions import ParamSpec",
            "",
            "# Python 3.14 deprecated asyncio.iscoroutinefunction, but suggested",
            "# inspect.iscoroutinefunction does not work correctly in some Python",
            "# versions before 3.12.",
            "# See https://github.com/python/cpython/issues/122858#issuecomment-2466239748",
            "if sys.version_info >= (3, 12):",
            "    iscoroutinefunction = _inspect_iscoroutinefunction",
            "else:",
            "    iscoroutinefunction = asyncio.iscoroutinefunction",
            "",
            "AppOrBlueprintKey = Optional[str]  # The App key is None, whereas blueprints are named",
            "T_after_serving = TypeVar(\"T_after_serving\", bound=AfterServingCallable)",
            "T_after_websocket = TypeVar(\"T_after_websocket\", bound=AfterWebsocketCallable)",
            "T_before_serving = TypeVar(\"T_before_serving\", bound=BeforeServingCallable)",
            "T_before_websocket = TypeVar(\"T_before_websocket\", bound=BeforeWebsocketCallable)",
            "T_shell_context_processor = TypeVar(",
            "    \"T_shell_context_processor\", bound=ShellContextProcessorCallable",
            ")",
            "T_teardown = TypeVar(\"T_teardown\", bound=TeardownCallable)",
            "T_template_filter = TypeVar(\"T_template_filter\", bound=TemplateFilterCallable)",
            "T_template_global = TypeVar(\"T_template_global\", bound=TemplateGlobalCallable)",
            "T_template_test = TypeVar(\"T_template_test\", bound=TemplateTestCallable)",
            "T_websocket = TypeVar(\"T_websocket\", bound=WebsocketCallable)",
            "T_while_serving = TypeVar(\"T_while_serving\", bound=WhileServingCallable)",
            "",
            "T = TypeVar(\"T\", bound=Any)",
            "P = ParamSpec(\"P\")",
            "",
            "",
            "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:",
            "    if value is None or isinstance(value, timedelta):",
            "        return value",
            "",
            "    return timedelta(seconds=value)",
            "",
            "",
            "class Quart(App):",
            "    \"\"\"The web framework class, handles requests and returns responses.",
            "",
            "    The primary method from a serving viewpoint is",
            "    :meth:`~quart.app.Quart.handle_request`, from an application",
            "    viewpoint all the other methods are vital.",
            "",
            "    This can be extended in many ways, with most methods designed with",
            "    this in mind. Additionally any of the classes listed as attributes",
            "    can be replaced.",
            "",
            "    Attributes:",
            "        aborter_class: The class to use to raise HTTP error via the abort",
            "            helper function.",
            "        app_ctx_globals_class: The class to use for the ``g`` object",
            "        asgi_http_class: The class to use to handle the ASGI HTTP",
            "            protocol.",
            "        asgi_lifespan_class: The class to use to handle the ASGI",
            "            lifespan protocol.",
            "        asgi_websocket_class: The class to use to handle the ASGI",
            "            websocket protocol.",
            "        config_class: The class to use for the configuration.",
            "        env: The name of the environment the app is running on.",
            "        event_class: The class to use to signal an event in an async",
            "            manner.",
            "        debug: Wrapper around configuration DEBUG value, in many places",
            "            this will result in more output if True. If unset, debug",
            "            mode will be activated if environ is set to 'development'.",
            "        jinja_environment: The class to use for the jinja environment.",
            "        jinja_options: The default options to set when creating the jinja",
            "            environment.",
            "        permanent_session_lifetime: Wrapper around configuration",
            "            PERMANENT_SESSION_LIFETIME value. Specifies how long the session",
            "            data should survive.",
            "        request_class: The class to use for requests.",
            "        response_class: The class to user for responses.",
            "        secret_key: Warpper around configuration SECRET_KEY value. The app",
            "            secret for signing sessions.",
            "        session_interface: The class to use as the session interface.",
            "        shutdown_event: This event is set when the app starts to",
            "            shutdown allowing waiting tasks to know when to stop.",
            "        url_map_class: The class to map rules to endpoints.",
            "        url_rule_class: The class to use for URL rules.",
            "        websocket_class: The class to use for websockets.",
            "",
            "    \"\"\"",
            "",
            "    asgi_http_class: type[ASGIHTTPProtocol]",
            "    asgi_lifespan_class: type[ASGILifespanProtocol]",
            "    asgi_websocket_class: type[ASGIWebsocketProtocol]",
            "    shutdown_event: Event",
            "    test_app_class: type[TestAppProtocol]",
            "    test_client_class: type[TestClientProtocol]  # type: ignore[assignment]",
            "",
            "    aborter_class = Aborter",
            "    app_ctx_globals_class = _AppCtxGlobals",
            "    asgi_http_class = ASGIHTTPConnection",
            "    asgi_lifespan_class = ASGILifespan",
            "    asgi_websocket_class = ASGIWebsocketConnection",
            "    config_class = Config",
            "    event_class = asyncio.Event",
            "    jinja_environment = Environment  # type: ignore[assignment]",
            "    lock_class = asyncio.Lock",
            "    request_class = Request",
            "    response_class = Response",
            "    session_interface = SecureCookieSessionInterface()",
            "    test_app_class = TestApp",
            "    test_client_class = QuartClient  # type: ignore[assignment]",
            "    test_cli_runner_class = QuartCliRunner  # type: ignore",
            "    url_map_class = QuartMap",
            "    url_rule_class = QuartRule  # type: ignore[assignment]",
            "    websocket_class = Websocket",
            "",
            "    default_config = ImmutableDict(",
            "        {",
            "            \"APPLICATION_ROOT\": \"/\",",
            "            \"BACKGROUND_TASK_SHUTDOWN_TIMEOUT\": 5,  # Second",
            "            \"BODY_TIMEOUT\": 60,  # Second",
            "            \"DEBUG\": None,",
            "            \"ENV\": None,",
            "            \"EXPLAIN_TEMPLATE_LOADING\": False,",
            "            \"MAX_CONTENT_LENGTH\": 16 * 1024 * 1024,  # 16 MB Limit",
            "            \"MAX_COOKIE_SIZE\": 4093,",
            "            \"MAX_FORM_MEMORY_SIZE\": 500_000,",
            "            \"MAX_FORM_PARTS\": 1_000,",
            "            \"PERMANENT_SESSION_LIFETIME\": timedelta(days=31),",
            "            # Replaces PREFERRED_URL_SCHEME to allow for WebSocket scheme",
            "            \"PREFER_SECURE_URLS\": False,",
            "            \"PRESERVE_CONTEXT_ON_EXCEPTION\": None,",
            "            \"PROPAGATE_EXCEPTIONS\": None,",
            "            \"PROVIDE_AUTOMATIC_OPTIONS\": True,",
            "            \"RESPONSE_TIMEOUT\": 60,  # Second",
            "            \"SECRET_KEY\": None,",
            "            \"SEND_FILE_MAX_AGE_DEFAULT\": timedelta(hours=12),",
            "            \"SERVER_NAME\": None,",
            "            \"SESSION_COOKIE_DOMAIN\": None,",
            "            \"SESSION_COOKIE_HTTPONLY\": True,",
            "            \"SESSION_COOKIE_NAME\": \"session\",",
            "            \"SESSION_COOKIE_PATH\": None,",
            "            \"SESSION_COOKIE_SAMESITE\": None,",
            "            \"SESSION_COOKIE_SECURE\": False,",
            "            \"SESSION_REFRESH_EACH_REQUEST\": True,",
            "            \"TEMPLATES_AUTO_RELOAD\": None,",
            "            \"TESTING\": False,",
            "            \"TRAP_BAD_REQUEST_ERRORS\": None,",
            "            \"TRAP_HTTP_EXCEPTIONS\": False,",
            "        }",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        import_name: str,",
            "        static_url_path: str | None = None,",
            "        static_folder: str | None = \"static\",",
            "        static_host: str | None = None,",
            "        host_matching: bool = False,",
            "        subdomain_matching: bool = False,",
            "        template_folder: str | None = \"templates\",",
            "        instance_path: str | None = None,",
            "        instance_relative_config: bool = False,",
            "        root_path: str | None = None,",
            "    ) -> None:",
            "        \"\"\"Construct a Quart web application.",
            "",
            "        Use to create a new web application to which requests should",
            "        be handled, as specified by the various attached url",
            "        rules. See also :class:`~quart.static.PackageStatic` for",
            "        additional constructor arguments.",
            "",
            "        Arguments:",
            "            import_name: The name at import of the application, use",
            "                ``__name__`` unless there is a specific issue.",
            "            host_matching: Optionally choose to match the host to the",
            "                configured host on request (404 if no match).",
            "            instance_path: Optional path to an instance folder, for",
            "                deployment specific settings and files.",
            "            instance_relative_config: If True load the config from a",
            "                path relative to the instance path.",
            "        Attributes:",
            "            after_request_funcs: The functions to execute after a",
            "                request has been handled.",
            "            after_websocket_funcs: The functions to execute after a",
            "                websocket has been handled.",
            "            before_request_funcs: The functions to execute before handling",
            "                a request.",
            "            before_websocket_funcs: The functions to execute before handling",
            "                a websocket.",
            "        \"\"\"",
            "        super().__init__(",
            "            import_name,",
            "            static_url_path,",
            "            static_folder,",
            "            static_host,",
            "            host_matching,",
            "            subdomain_matching,",
            "            template_folder,",
            "            instance_path,",
            "            instance_relative_config,",
            "            root_path,",
            "        )",
            "",
            "        self.after_serving_funcs: list[Callable[[], Awaitable[None]]] = []",
            "        self.after_websocket_funcs: dict[",
            "            AppOrBlueprintKey, list[AfterWebsocketCallable]",
            "        ] = defaultdict(list)",
            "        self.background_tasks: set[asyncio.Task] = set()",
            "        self.before_serving_funcs: list[Callable[[], Awaitable[None]]] = []",
            "        self.before_websocket_funcs: dict[",
            "            AppOrBlueprintKey, list[BeforeWebsocketCallable]",
            "        ] = defaultdict(list)",
            "        self.teardown_websocket_funcs: dict[",
            "            AppOrBlueprintKey, list[TeardownCallable]",
            "        ] = defaultdict(list)",
            "        self.while_serving_gens: list[AsyncGenerator[None, None]] = []",
            "",
            "        self.template_context_processors[None] = [_default_template_ctx_processor]",
            "",
            "        self.cli = AppGroup()",
            "        self.cli.name = self.name",
            "",
            "        if self.has_static_folder:",
            "            assert (",
            "                bool(static_host) == host_matching",
            "            ), \"Invalid static_host/host_matching combination\"",
            "",
            "            self.add_url_rule(",
            "                f\"{self.static_url_path}/<path:filename>\",",
            "                \"static\",",
            "                self.send_static_file,",
            "                host=static_host,",
            "            )",
            "",
            "    def get_send_file_max_age(self, filename: str | None) -> int | None:",
            "        \"\"\"Used by :func:`send_file` to determine the ``max_age`` cache",
            "        value for a given file path if it wasn't passed.",
            "",
            "        By default, this returns :data:`SEND_FILE_MAX_AGE_DEFAULT` from",
            "        the configuration of :data:`~flask.current_app`. This defaults",
            "        to ``None``, which tells the browser to use conditional requests",
            "        instead of a timed cache, which is usually preferable.",
            "",
            "        Note this is a duplicate of the same method in the Quart",
            "        class.",
            "",
            "        \"\"\"",
            "        value = self.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]",
            "",
            "        if value is None:",
            "            return None",
            "",
            "        if isinstance(value, timedelta):",
            "            return int(value.total_seconds())",
            "",
            "        return value",
            "        return None",
            "",
            "    async def send_static_file(self, filename: str) -> Response:",
            "        if not self.has_static_folder:",
            "            raise RuntimeError(\"No static folder for this object\")",
            "        return await send_from_directory(self.static_folder, filename)",
            "",
            "    async def open_resource(",
            "        self,",
            "        path: FilePath,",
            "        mode: str = \"rb\",",
            "    ) -> AiofilesContextManager:",
            "        \"\"\"Open a file for reading.",
            "",
            "        Use as",
            "",
            "        .. code-block:: python",
            "",
            "            async with await app.open_resource(path) as file_:",
            "                await file_.read()",
            "        \"\"\"",
            "        if mode not in {\"r\", \"rb\", \"rt\"}:",
            "            raise ValueError(\"Files can only be opened for reading\")",
            "",
            "        return async_open(os.path.join(self.root_path, path), mode)  # type: ignore",
            "",
            "    async def open_instance_resource(",
            "        self, path: FilePath, mode: str = \"rb\"",
            "    ) -> AiofilesContextManager:",
            "        \"\"\"Open a file for reading.",
            "",
            "        Use as",
            "",
            "        .. code-block:: python",
            "",
            "            async with await app.open_instance_resource(path) as file_:",
            "                await file_.read()",
            "        \"\"\"",
            "        return async_open(self.instance_path / file_path_to_path(path), mode)  # type: ignore",
            "",
            "    def create_jinja_environment(self) -> Environment:  # type: ignore",
            "        \"\"\"Create and return the jinja environment.",
            "",
            "        This will create the environment based on the",
            "        :attr:`jinja_options` and configuration settings. The",
            "        environment will include the Quart globals by default.",
            "        \"\"\"",
            "        options = dict(self.jinja_options)",
            "        if \"autoescape\" not in options:",
            "            options[\"autoescape\"] = self.select_jinja_autoescape",
            "        if \"auto_reload\" not in options:",
            "            options[\"auto_reload\"] = self.config[\"TEMPLATES_AUTO_RELOAD\"]",
            "        jinja_env = self.jinja_environment(self, **options)  # type: ignore",
            "        jinja_env.globals.update(",
            "            {",
            "                \"config\": self.config,",
            "                \"g\": g,",
            "                \"get_flashed_messages\": get_flashed_messages,",
            "                \"request\": request,",
            "                \"session\": session,",
            "                \"url_for\": self.url_for,",
            "            }",
            "        )",
            "        jinja_env.policies[\"json.dumps_function\"] = self.json.dumps",
            "        return jinja_env",
            "",
            "    async def update_template_context(self, context: dict) -> None:",
            "        \"\"\"Update the provided template context.",
            "",
            "        This adds additional context from the various template context",
            "        processors.",
            "",
            "        Arguments:",
            "            context: The context to update (mutate).",
            "        \"\"\"",
            "        names = [None]",
            "        if has_request_context():",
            "            names.extend(reversed(request_ctx.request.blueprints))  # type: ignore",
            "        elif has_websocket_context():",
            "            names.extend(reversed(websocket_ctx.websocket.blueprints))  # type: ignore",
            "",
            "        extra_context: dict[str, Any] = {}",
            "        for name in names:",
            "            for processor in self.template_context_processors[name]:",
            "                extra_context.update(await self.ensure_async(processor)())  # type: ignore[call-overload]",
            "",
            "        original = context.copy()",
            "        context.update(extra_context)",
            "        context.update(original)",
            "",
            "    @setupmethod",
            "    def before_serving(",
            "        self,",
            "        func: T_before_serving,",
            "    ) -> T_before_serving:",
            "        \"\"\"Add a before serving function.",
            "",
            "        This will allow the function provided to be called once before",
            "        anything is served (before any byte is received).",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.before_serving",
            "            async def func():",
            "                ...",
            "",
            "        Arguments:",
            "            func: The function itself.",
            "        \"\"\"",
            "        self.before_serving_funcs.append(func)",
            "        return func",
            "",
            "    @setupmethod",
            "    def while_serving(",
            "        self,",
            "        func: T_while_serving,",
            "    ) -> T_while_serving:",
            "        \"\"\"Add a while serving generator function.",
            "",
            "        This will allow the generator provided to be invoked at",
            "        startup and then again at shutdown.",
            "",
            "        This is designed to be used as a decorator. An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.while_serving",
            "            async def func():",
            "                ...  # Startup",
            "                yield",
            "                ...  # Shutdown",
            "",
            "        Arguments:",
            "            func: The function itself.",
            "",
            "        \"\"\"",
            "        self.while_serving_gens.append(func())",
            "        return func",
            "",
            "    @setupmethod",
            "    def after_serving(",
            "        self,",
            "        func: T_after_serving,",
            "    ) -> T_after_serving:",
            "        \"\"\"Add a after serving function.",
            "",
            "        This will allow the function provided to be called once after",
            "        anything is served (after last byte is sent).",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.after_serving",
            "            async def func():",
            "                ...",
            "",
            "        Arguments:",
            "            func: The function itself.",
            "        \"\"\"",
            "        self.after_serving_funcs.append(func)",
            "        return func",
            "",
            "    def create_url_adapter(",
            "        self, request: BaseRequestWebsocket | None",
            "    ) -> MapAdapter | None:",
            "        \"\"\"Create and return a URL adapter.",
            "",
            "        This will create the adapter based on the request if present",
            "        otherwise the app configuration.",
            "        \"\"\"",
            "        if request is not None:",
            "            subdomain = (",
            "                (self.url_map.default_subdomain or None)",
            "                if not self.subdomain_matching",
            "                else None",
            "            )",
            "",
            "            return self.url_map.bind_to_request(  # type: ignore[attr-defined]",
            "                request, subdomain, self.config[\"SERVER_NAME\"]",
            "            )",
            "",
            "        if self.config[\"SERVER_NAME\"] is not None:",
            "            scheme = \"https\" if self.config[\"PREFER_SECURE_URLS\"] else \"http\"",
            "            return self.url_map.bind(self.config[\"SERVER_NAME\"], url_scheme=scheme)",
            "        return None",
            "",
            "    def websocket(",
            "        self,",
            "        rule: str,",
            "        **options: Any,",
            "    ) -> Callable[[T_websocket], T_websocket]:",
            "        \"\"\"Add a websocket to the application.",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.websocket('/')",
            "            async def websocket_route():",
            "                ...",
            "",
            "        Arguments:",
            "            rule: The path to route on, should start with a ``/``.",
            "            endpoint: Optional endpoint name, if not present the",
            "                function name is used.",
            "            defaults: A dictionary of variables to provide automatically, use",
            "                to provide a simpler default path for a route, e.g. to allow",
            "                for ``/book`` rather than ``/book/0``,",
            "",
            "                .. code-block:: python",
            "",
            "                    @app.websocket('/book', defaults={'page': 0})",
            "                    @app.websocket('/book/<int:page>')",
            "                    def book(page):",
            "                        ...",
            "",
            "            host: The full host name for this route (should include subdomain",
            "                if needed) - cannot be used with subdomain.",
            "            subdomain: A subdomain for this specific route.",
            "            strict_slashes: Strictly match the trailing slash present in the",
            "                path. Will redirect a leaf (no slash) to a branch (with slash).",
            "        \"\"\"",
            "",
            "        def decorator(func: T_websocket) -> T_websocket:",
            "            endpoint = options.pop(\"endpoint\", None)",
            "            self.add_websocket(",
            "                rule,",
            "                endpoint,",
            "                func,",
            "                **options,",
            "            )",
            "            return func",
            "",
            "        return decorator",
            "",
            "    def add_websocket(",
            "        self,",
            "        rule: str,",
            "        endpoint: str | None = None,",
            "        view_func: WebsocketCallable | None = None,",
            "        **options: Any,",
            "    ) -> None:",
            "        \"\"\"Add a websocket url rule to the application.",
            "",
            "        This is designed to be used on the application directly. An",
            "        example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            def websocket_route():",
            "                ...",
            "",
            "            app.add_websocket('/', websocket_route)",
            "",
            "        Arguments:",
            "            rule: The path to route on, should start with a ``/``.",
            "            endpoint: Optional endpoint name, if not present the",
            "                function name is used.",
            "            view_func: Callable that returns a response.",
            "            defaults: A dictionary of variables to provide automatically, use",
            "                to provide a simpler default path for a route, e.g. to allow",
            "                for ``/book`` rather than ``/book/0``,",
            "",
            "                .. code-block:: python",
            "",
            "                    @app.websocket('/book', defaults={'page': 0})",
            "                    @app.websocket('/book/<int:page>')",
            "                    def book(page):",
            "                        ...",
            "",
            "            host: The full host name for this route (should include subdomain",
            "                if needed) - cannot be used with subdomain.",
            "            subdomain: A subdomain for this specific route.",
            "            strict_slashes: Strictly match the trailing slash present in the",
            "                path. Will redirect a leaf (no slash) to a branch (with slash).",
            "        \"\"\"",
            "        return self.add_url_rule(",
            "            rule,",
            "            endpoint,",
            "            view_func,",
            "            methods={\"GET\"},",
            "            websocket=True,",
            "            **options,",
            "        )",
            "",
            "    def url_for(",
            "        self,",
            "        endpoint: str,",
            "        *,",
            "        _anchor: str | None = None,",
            "        _external: bool | None = None,",
            "        _method: str | None = None,",
            "        _scheme: str | None = None,",
            "        **values: Any,",
            "    ) -> str:",
            "        \"\"\"Return the url for a specific endpoint.",
            "",
            "        This is most useful in templates and redirects to create a URL",
            "        that can be used in the browser.",
            "",
            "        Arguments:",
            "            endpoint: The endpoint to build a url for, if prefixed with",
            "                ``.`` it targets endpoint's in the current blueprint.",
            "            _anchor: Additional anchor text to append (i.e. #text).",
            "            _external: Return an absolute url for external (to app) usage.",
            "            _method: The method to consider alongside the endpoint.",
            "            _scheme: A specific scheme to use.",
            "            values: The values to build into the URL, as specified in",
            "                the endpoint rule.",
            "        \"\"\"",
            "",
            "        app_context = _cv_app.get(None)",
            "        request_context = _cv_request.get(None)",
            "        websocket_context = _cv_websocket.get(None)",
            "",
            "        if request_context is not None:",
            "            url_adapter = request_context.url_adapter",
            "            if endpoint.startswith(\".\"):",
            "                if request.blueprint is not None:",
            "                    endpoint = request.blueprint + endpoint",
            "                else:",
            "                    endpoint = endpoint[1:]",
            "            if _external is None:",
            "                _external = _scheme is not None",
            "        elif websocket_context is not None:",
            "            url_adapter = websocket_context.url_adapter",
            "            if endpoint.startswith(\".\"):",
            "                if websocket.blueprint is not None:",
            "                    endpoint = websocket.blueprint + endpoint",
            "                else:",
            "                    endpoint = endpoint[1:]",
            "            if _external is None:",
            "                _external = _scheme is not None",
            "        elif app_context is not None:",
            "            url_adapter = app_context.url_adapter",
            "            if _external is None:",
            "                _external = True",
            "        else:",
            "            url_adapter = self.create_url_adapter(None)",
            "            if _external is None:",
            "                _external = True",
            "",
            "        if url_adapter is None:",
            "            raise RuntimeError(",
            "                \"Unable to create a url adapter, try setting the SERVER_NAME\"",
            "                \" config variable.\"",
            "            )",
            "        if _scheme is not None and not _external:",
            "            raise ValueError(\"External must be True for scheme usage\")",
            "",
            "        self.inject_url_defaults(endpoint, values)",
            "",
            "        old_scheme = None",
            "        if _scheme is not None:",
            "            old_scheme = url_adapter.url_scheme",
            "            url_adapter.url_scheme = _scheme",
            "",
            "        try:",
            "            url = url_adapter.build(",
            "                endpoint, values, method=_method, force_external=_external",
            "            )",
            "        except BuildError as error:",
            "            return self.handle_url_build_error(error, endpoint, values)",
            "        finally:",
            "            if old_scheme is not None:",
            "                url_adapter.url_scheme = old_scheme",
            "",
            "        if _anchor is not None:",
            "            quoted_anchor = quote(_anchor, safe=\"%!#$&'()*+,/:;=?@\")",
            "            url = f\"{url}#{quoted_anchor}\"",
            "        return url",
            "",
            "    def make_shell_context(self) -> dict:",
            "        \"\"\"Create a context for interactive shell usage.",
            "",
            "        The :attr:`shell_context_processors` can be used to add",
            "        additional context.",
            "        \"\"\"",
            "        context = {\"app\": self, \"g\": g}",
            "        for processor in self.shell_context_processors:",
            "            context.update(processor())",
            "        return context",
            "",
            "    def run(",
            "        self,",
            "        host: str | None = None,",
            "        port: int | None = None,",
            "        debug: bool | None = None,",
            "        use_reloader: bool = True,",
            "        loop: asyncio.AbstractEventLoop | None = None,",
            "        ca_certs: str | None = None,",
            "        certfile: str | None = None,",
            "        keyfile: str | None = None,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        \"\"\"Run this application.",
            "",
            "        This is best used for development only, see Hypercorn for",
            "        production servers.",
            "",
            "        Arguments:",
            "            host: Hostname to listen on. By default this is loopback",
            "                only, use 0.0.0.0 to have the server listen externally.",
            "            port: Port number to listen on.",
            "            debug: If set enable (or disable) debug mode and debug output.",
            "            use_reloader: Automatically reload on code changes.",
            "            loop: Asyncio loop to create the server in, if None, take default one.",
            "                If specified it is the caller's responsibility to close and cleanup the",
            "                loop.",
            "            ca_certs: Path to the SSL CA certificate file.",
            "            certfile: Path to the SSL certificate file.",
            "            keyfile: Path to the SSL key file.",
            "        \"\"\"",
            "        if kwargs:",
            "            warnings.warn(",
            "                f\"Additional arguments, {','.join(kwargs.keys())}, are not supported.\\n\"",
            "                \"They may be supported by Hypercorn, which is the ASGI server Quart \"",
            "                \"uses by default. This method is meant for development and debugging.\",",
            "                stacklevel=2,",
            "            )",
            "",
            "        if loop is None:",
            "            loop = asyncio.new_event_loop()",
            "            asyncio.set_event_loop(loop)",
            "",
            "        if \"QUART_DEBUG\" in os.environ:",
            "            self.debug = get_debug_flag()",
            "",
            "        if debug is not None:",
            "            self.debug = debug",
            "",
            "        loop.set_debug(self.debug)",
            "",
            "        shutdown_event = asyncio.Event()",
            "",
            "        def _signal_handler(*_: Any) -> None:",
            "            shutdown_event.set()",
            "",
            "        for signal_name in {\"SIGINT\", \"SIGTERM\", \"SIGBREAK\"}:",
            "            if hasattr(signal, signal_name):",
            "                try:",
            "                    loop.add_signal_handler(",
            "                        getattr(signal, signal_name), _signal_handler",
            "                    )",
            "                except NotImplementedError:",
            "                    # Add signal handler may not be implemented on Windows",
            "                    signal.signal(getattr(signal, signal_name), _signal_handler)",
            "",
            "        server_name = self.config.get(\"SERVER_NAME\")",
            "        sn_host = None",
            "        sn_port = None",
            "        if server_name is not None:",
            "            sn_host, _, sn_port = server_name.partition(\":\")",
            "",
            "        if host is None:",
            "            host = sn_host or \"127.0.0.1\"",
            "",
            "        if port is None:",
            "            port = int(sn_port or \"5000\")",
            "",
            "        task = self.run_task(",
            "            host,",
            "            port,",
            "            debug,",
            "            ca_certs,",
            "            certfile,",
            "            keyfile,",
            "            shutdown_trigger=shutdown_event.wait,  # type: ignore",
            "        )",
            "        print(f\" * Serving Quart app '{self.name}'\")  # noqa: T201",
            "        print(f\" * Debug mode: {self.debug or False}\")  # noqa: T201",
            "        print(\" * Please use an ASGI server (e.g. Hypercorn) directly in production\")  # noqa: T201",
            "        scheme = \"https\" if certfile is not None and keyfile is not None else \"http\"",
            "        print(f\" * Running on {scheme}://{host}:{port} (CTRL + C to quit)\")  # noqa: T201",
            "",
            "        tasks = [loop.create_task(task)]",
            "",
            "        if use_reloader:",
            "            tasks.append(",
            "                loop.create_task(observe_changes(asyncio.sleep, shutdown_event))",
            "            )",
            "",
            "        reload_ = False",
            "        try:",
            "            loop.run_until_complete(asyncio.gather(*tasks))",
            "        except MustReloadError:",
            "            reload_ = True",
            "        finally:",
            "            try:",
            "                _cancel_all_tasks(loop)",
            "                loop.run_until_complete(loop.shutdown_asyncgens())",
            "            finally:",
            "                asyncio.set_event_loop(None)",
            "                loop.close()",
            "",
            "        if reload_:",
            "            restart()",
            "",
            "    def run_task(",
            "        self,",
            "        host: str = \"127.0.0.1\",",
            "        port: int = 5000,",
            "        debug: bool | None = None,",
            "        ca_certs: str | None = None,",
            "        certfile: str | None = None,",
            "        keyfile: str | None = None,",
            "        shutdown_trigger: Callable[..., Awaitable[None]] | None = None,",
            "    ) -> Coroutine[None, None, None]:",
            "        \"\"\"Return a task that when awaited runs this application.",
            "",
            "        This is best used for development only, see Hypercorn for",
            "        production servers.",
            "",
            "        Arguments:",
            "            host: Hostname to listen on. By default this is loopback",
            "                only, use 0.0.0.0 to have the server listen externally.",
            "            port: Port number to listen on.",
            "            debug: If set enable (or disable) debug mode and debug output.",
            "            ca_certs: Path to the SSL CA certificate file.",
            "            certfile: Path to the SSL certificate file.",
            "            keyfile: Path to the SSL key file.",
            "",
            "        \"\"\"",
            "        config = HyperConfig()",
            "        config.access_log_format = \"%(h)s %(r)s %(s)s %(b)s %(D)s\"",
            "        config.accesslog = \"-\"",
            "        config.bind = [f\"{host}:{port}\"]",
            "        config.ca_certs = ca_certs",
            "        config.certfile = certfile",
            "        if debug is not None:",
            "            self.debug = debug",
            "        config.errorlog = config.accesslog",
            "        config.keyfile = keyfile",
            "",
            "        return serve(self, config, shutdown_trigger=shutdown_trigger)",
            "",
            "    def test_client(",
            "        self, use_cookies: bool = True, **kwargs: Any",
            "    ) -> TestClientProtocol:",
            "        \"\"\"Creates and returns a test client.\"\"\"",
            "        return self.test_client_class(self, use_cookies=use_cookies, **kwargs)",
            "",
            "    def test_cli_runner(self, **kwargs: Any) -> QuartCliRunner:",
            "        \"\"\"Creates and returns a CLI test runner.\"\"\"",
            "        return self.test_cli_runner_class(self, **kwargs)  # type: ignore",
            "",
            "    @setupmethod",
            "    def before_websocket(",
            "        self,",
            "        func: T_before_websocket,",
            "    ) -> T_before_websocket:",
            "        \"\"\"Add a before websocket function.",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.before_websocket",
            "            async def func():",
            "                ...",
            "",
            "        Arguments:",
            "            func: The before websocket function itself.",
            "        \"\"\"",
            "        self.before_websocket_funcs[None].append(func)",
            "        return func",
            "",
            "    @setupmethod",
            "    def after_websocket(",
            "        self,",
            "        func: T_after_websocket,",
            "    ) -> T_after_websocket:",
            "        \"\"\"Add an after websocket function.",
            "",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "",
            "        .. code-block:: python",
            "",
            "            @app.after_websocket",
            "            async def func(response):",
            "                return response",
            "",
            "        Arguments:",
            "            func: The after websocket function itself.",
            "        \"\"\"",
            "        self.after_websocket_funcs[None].append(func)",
            "        return func",
            "",
            "    @setupmethod",
            "    def teardown_websocket(",
            "        self,",
            "        func: T_teardown,",
            "    ) -> T_teardown:",
            "        \"\"\"Add a teardown websocket function.",
            "        This is designed to be used as a decorator, if used to",
            "        decorate a synchronous function, the function will be wrapped",
            "        in :func:`~quart.utils.run_sync` and run in a thread executor",
            "        (with the wrapped function returned). An example usage,",
            "        .. code-block:: python",
            "            @app.teardown_websocket",
            "            async def func():",
            "                ...",
            "        Arguments:",
            "            func: The teardown websocket function itself.",
            "        \"\"\"",
            "        self.teardown_websocket_funcs[None].append(func)",
            "        return func",
            "",
            "    async def handle_http_exception(",
            "        self, error: HTTPException",
            "    ) -> HTTPException | ResponseReturnValue:",
            "        \"\"\"Handle a HTTPException subclass error.",
            "",
            "        This will attempt to find a handler for the error and if fails",
            "        will fall back to the error response.",
            "        \"\"\"",
            "        if error.code is None:",
            "            return error",
            "",
            "        if isinstance(error, RoutingException):",
            "            return error",
            "",
            "        blueprints = []",
            "        if has_request_context():",
            "            blueprints = request.blueprints",
            "        elif has_websocket_context():",
            "            blueprints = websocket.blueprints",
            "",
            "        handler = self._find_error_handler(error, blueprints)",
            "        if handler is None:",
            "            return error",
            "        else:",
            "            return await self.ensure_async(handler)(error)  # type: ignore[return-value]",
            "",
            "    async def handle_user_exception(",
            "        self, error: Exception",
            "    ) -> HTTPException | ResponseReturnValue:",
            "        \"\"\"Handle an exception that has been raised.",
            "",
            "        This should forward :class:`~quart.exception.HTTPException` to",
            "        :meth:`handle_http_exception`, then attempt to handle the",
            "        error. If it cannot it should reraise the error.",
            "        \"\"\"",
            "        if isinstance(error, BadRequestKeyError) and (",
            "            self.debug or self.config[\"TRAP_BAD_REQUEST_ERRORS\"]",
            "        ):",
            "            error.show_exception = True",
            "",
            "        if isinstance(error, HTTPException) and not self.trap_http_exception(error):",
            "            return await self.handle_http_exception(error)",
            "",
            "        blueprints = []",
            "        if has_request_context():",
            "            blueprints = request.blueprints",
            "        elif has_websocket_context():",
            "            blueprints = websocket.blueprints",
            "",
            "        handler = self._find_error_handler(error, blueprints)",
            "        if handler is None:",
            "            raise error",
            "        return await self.ensure_async(handler)(error)  # type: ignore[return-value]",
            "",
            "    async def handle_exception(self, error: Exception) -> ResponseTypes:",
            "        \"\"\"Handle an uncaught exception.",
            "",
            "        By default this switches the error response to a 500 internal",
            "        server error.",
            "        \"\"\"",
            "        exc_info = sys.exc_info()",
            "        await got_request_exception.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exception=error,",
            "        )",
            "        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]",
            "",
            "        if propagate is None:",
            "            propagate = self.testing or self.debug",
            "",
            "        if propagate:",
            "            # Re-raise if called with an active exception, otherwise",
            "            # raise the passed in exception.",
            "            if exc_info[1] is error:",
            "                raise",
            "",
            "            raise error",
            "",
            "        self.log_exception(exc_info)",
            "        server_error: InternalServerError | ResponseReturnValue",
            "        server_error = InternalServerError(original_exception=error)",
            "        handler = self._find_error_handler(server_error, request.blueprints)",
            "",
            "        if handler is not None:",
            "            server_error = await self.ensure_async(handler)(server_error)  # type: ignore[assignment]",
            "",
            "        return await self.finalize_request(server_error, from_error_handler=True)",
            "",
            "    async def handle_websocket_exception(",
            "        self, error: Exception",
            "    ) -> ResponseTypes | None:",
            "        \"\"\"Handle an uncaught exception.",
            "",
            "        By default this logs the exception and then re-raises it.",
            "        \"\"\"",
            "        exc_info = sys.exc_info()",
            "        await got_websocket_exception.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exception=error,",
            "        )",
            "        propagate = self.config[\"PROPAGATE_EXCEPTIONS\"]",
            "",
            "        if propagate is None:",
            "            propagate = self.testing or self.debug",
            "",
            "        if propagate:",
            "            # Re-raise if called with an active exception, otherwise",
            "            # raise the passed in exception.",
            "            if exc_info[1] is error:",
            "                raise",
            "",
            "            raise error",
            "",
            "        self.log_exception(exc_info)",
            "        server_error: InternalServerError | ResponseReturnValue",
            "        server_error = InternalServerError(original_exception=error)",
            "        handler = self._find_error_handler(server_error, websocket.blueprints)",
            "",
            "        if handler is not None:",
            "            server_error = await self.ensure_async(handler)(server_error)  # type: ignore[assignment]",
            "",
            "        return await self.finalize_websocket(server_error, from_error_handler=True)",
            "",
            "    def log_exception(",
            "        self,",
            "        exception_info: (",
            "            tuple[type, BaseException, TracebackType] | tuple[None, None, None]",
            "        ),",
            "    ) -> None:",
            "        \"\"\"Log a exception to the :attr:`logger`.",
            "",
            "        By default this is only invoked for unhandled exceptions.",
            "        \"\"\"",
            "        if has_request_context():",
            "            request_ = request_ctx.request",
            "            self.logger.error(",
            "                f\"Exception on request {request_.method} {request_.path}\",",
            "                exc_info=exception_info,",
            "            )",
            "        elif has_websocket_context():",
            "            websocket_ = websocket_ctx.websocket",
            "            self.logger.error(",
            "                f\"Exception on websocket {websocket_.path}\", exc_info=exception_info",
            "            )",
            "        else:",
            "            self.logger.error(\"Exception\", exc_info=exception_info)",
            "",
            "    @overload",
            "    def ensure_async(",
            "        self, func: Callable[P, Awaitable[T]]",
            "    ) -> Callable[P, Awaitable[T]]: ...",
            "",
            "    @overload",
            "    def ensure_async(self, func: Callable[P, T]) -> Callable[P, Awaitable[T]]: ...",
            "",
            "    def ensure_async(",
            "        self, func: Callable[P, Awaitable[T]] | Callable[P, T]",
            "    ) -> Callable[P, Awaitable[T]]:",
            "        \"\"\"Ensure that the returned func is async and calls the func.",
            "",
            "        .. versionadded:: 0.11",
            "",
            "        Override if you wish to change how synchronous functions are",
            "        run. Before Quart 0.11 this did not run the synchronous code",
            "        in an executor.",
            "        \"\"\"",
            "        if iscoroutinefunction(func):",
            "            return func",
            "        else:",
            "            return self.sync_to_async(cast(Callable[P, T], func))",
            "",
            "    def sync_to_async(self, func: Callable[P, T]) -> Callable[P, Awaitable[T]]:",
            "        \"\"\"Return a async function that will run the synchronous function *func*.",
            "",
            "        This can be used as so,::",
            "",
            "            result = await app.sync_to_async(func)(*args, **kwargs)",
            "",
            "        Override this method to change how the app converts sync code",
            "        to be asynchronously callable.",
            "        \"\"\"",
            "        return run_sync(func)",
            "",
            "    async def do_teardown_request(",
            "        self, exc: BaseException | None, request_context: RequestContext | None = None",
            "    ) -> None:",
            "        \"\"\"Teardown the request, calling the teardown functions.",
            "",
            "        Arguments:",
            "            exc: Any exception not handled that has caused the request",
            "                to teardown.",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(request_context or request_ctx).request.blueprints, None]",
            "        for name in names:",
            "            for function in reversed(self.teardown_request_funcs[name]):",
            "                await self.ensure_async(function)(exc)",
            "",
            "        await request_tearing_down.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exc=exc,",
            "        )",
            "",
            "    async def do_teardown_websocket(",
            "        self,",
            "        exc: BaseException | None,",
            "        websocket_context: WebsocketContext | None = None,",
            "    ) -> None:",
            "        \"\"\"Teardown the websocket, calling the teardown functions.",
            "",
            "        Arguments:",
            "            exc: Any exception not handled that has caused the websocket",
            "                to teardown.",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(websocket_context or websocket_ctx).websocket.blueprints, None]",
            "        for name in names:",
            "            for function in reversed(self.teardown_websocket_funcs[name]):",
            "                await self.ensure_async(function)(exc)",
            "",
            "        await websocket_tearing_down.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exc=exc,",
            "        )",
            "",
            "    async def do_teardown_appcontext(self, exc: BaseException | None) -> None:",
            "        \"\"\"Teardown the app (context), calling the teardown functions.\"\"\"",
            "        for function in self.teardown_appcontext_funcs:",
            "            await self.ensure_async(function)(exc)",
            "        await appcontext_tearing_down.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exc=exc,",
            "        )",
            "",
            "    def app_context(self) -> AppContext:",
            "        \"\"\"Create and return an app context.",
            "",
            "        This is best used within a context, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.app_context():",
            "                ...",
            "        \"\"\"",
            "        return AppContext(self)",
            "",
            "    def request_context(self, request: Request) -> RequestContext:",
            "        \"\"\"Create and return a request context.",
            "",
            "        Use the :meth:`test_request_context` whilst testing. This is",
            "        best used within a context, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.request_context(request):",
            "                ...",
            "",
            "        Arguments:",
            "            request: A request to build a context around.",
            "        \"\"\"",
            "        return RequestContext(self, request)",
            "",
            "    def websocket_context(self, websocket: Websocket) -> WebsocketContext:",
            "        \"\"\"Create and return a websocket context.",
            "",
            "        Use the :meth:`test_websocket_context` whilst testing. This is",
            "        best used within a context, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.websocket_context(websocket):",
            "                ...",
            "",
            "        Arguments:",
            "            websocket: A websocket to build a context around.",
            "        \"\"\"",
            "        return WebsocketContext(self, websocket)",
            "",
            "    def test_app(self) -> TestAppProtocol:",
            "        return self.test_app_class(self)",
            "",
            "    def test_request_context(",
            "        self,",
            "        path: str,",
            "        *,",
            "        method: str = \"GET\",",
            "        headers: dict | Headers | None = None,",
            "        query_string: dict | None = None,",
            "        scheme: str = \"http\",",
            "        send_push_promise: Callable[[str, Headers], Awaitable[None]] = no_op_push,",
            "        data: AnyStr | None = None,",
            "        form: dict | None = None,",
            "        json: Any = sentinel,",
            "        root_path: str = \"\",",
            "        http_version: str = \"1.1\",",
            "        scope_base: dict | None = None,",
            "        auth: Authorization | tuple[str, str] | None = None,",
            "        subdomain: str | None = None,",
            "    ) -> RequestContext:",
            "        \"\"\"Create a request context for testing purposes.",
            "",
            "        This is best used for testing code within request contexts. It",
            "        is a simplified wrapper of :meth:`request_context`. It is best",
            "        used in a with block, i.e.",
            "",
            "        .. code-block:: python",
            "",
            "            async with app.test_request_context(\"/\", method=\"GET\"):",
            "                ...",
            "",
            "        Arguments:",
            "            path: Request path.",
            "            method: HTTP verb",
            "            headers: Headers to include in the request.",
            "            query_string: To send as a dictionary, alternatively the",
            "                query_string can be determined from the path.",
            "            scheme: Scheme for the request, default http.",
            "        \"\"\"",
            "        headers, path, query_string_bytes = make_test_headers_path_and_query_string(",
            "            self,",
            "            path,",
            "            headers,",
            "            query_string,",
            "            auth,",
            "            subdomain,",
            "        )",
            "        request_body, body_headers = make_test_body_with_headers(",
            "            data=data, form=form, json=json",
            "        )",
            "        headers.update(**body_headers)",
            "        scope = make_test_scope(",
            "            \"http\",",
            "            path,",
            "            method,",
            "            headers,",
            "            query_string_bytes,",
            "            scheme,",
            "            root_path,",
            "            http_version,",
            "            scope_base,",
            "        )",
            "        request = self.request_class(",
            "            method,",
            "            scheme,",
            "            path,",
            "            query_string_bytes,",
            "            headers,",
            "            root_path,",
            "            http_version,",
            "            send_push_promise=send_push_promise,",
            "            scope=scope,",
            "        )",
            "        request.body.set_result(request_body)",
            "        return self.request_context(request)",
            "",
            "    def add_background_task(self, func: Callable, *args: Any, **kwargs: Any) -> None:",
            "        async def _wrapper() -> None:",
            "            try:",
            "                async with self.app_context():",
            "                    await self.ensure_async(func)(*args, **kwargs)",
            "            except Exception as error:",
            "                await self.handle_background_exception(error)",
            "",
            "        task = asyncio.get_event_loop().create_task(_wrapper())",
            "        self.background_tasks.add(task)",
            "        task.add_done_callback(self.background_tasks.discard)",
            "",
            "    async def handle_background_exception(self, error: Exception) -> None:",
            "        await got_background_exception.send_async(",
            "            self,",
            "            _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "            exception=error,",
            "        )",
            "",
            "        self.log_exception(sys.exc_info())",
            "",
            "    async def make_default_options_response(self) -> Response:",
            "        \"\"\"This is the default route function for OPTIONS requests.\"\"\"",
            "        methods = request_ctx.url_adapter.allowed_methods()",
            "        return self.response_class(\"\", headers={\"Allow\": \", \".join(methods)})",
            "",
            "    async def make_response(",
            "        self, result: ResponseReturnValue | HTTPException",
            "    ) -> ResponseTypes:",
            "        \"\"\"Make a Response from the result of the route handler.",
            "",
            "        The result itself can either be:",
            "          - A Response object (or subclass).",
            "          - A tuple of a ResponseValue and a header dictionary.",
            "          - A tuple of a ResponseValue, status code and a header dictionary.",
            "",
            "        A ResponseValue is either a Response object (or subclass) or a str.",
            "        \"\"\"",
            "        headers: HeadersValue | None = None",
            "        status: StatusCode | None = None",
            "        if isinstance(result, tuple):",
            "            if len(result) == 3:",
            "                value, status, headers = result",
            "            elif len(result) == 2:",
            "                value, status_or_headers = result",
            "",
            "                if isinstance(status_or_headers, (Headers, dict, list)):",
            "                    headers = status_or_headers",
            "                    status = None",
            "                elif status_or_headers is not None:",
            "                    status = status_or_headers  # type: ignore[assignment]",
            "            else:",
            "                raise TypeError(",
            "                    \"\"\"The response value returned must be either (body, status), (body,",
            "                    headers), or (body, status, headers)\"\"\"",
            "                )",
            "        else:",
            "            value = result  # type: ignore[assignment]",
            "",
            "        if value is None:",
            "            raise TypeError(",
            "                \"The response value returned by the view function cannot be None\"",
            "            )",
            "",
            "        response: ResponseTypes",
            "        if isinstance(value, HTTPException):",
            "            response = value.get_response()  # type: ignore",
            "        elif not isinstance(value, (Response, WerkzeugResponse)):",
            "            if (",
            "                isinstance(value, (str, bytes, bytearray))",
            "                or isgenerator(value)",
            "                or isasyncgen(value)",
            "            ):",
            "                response = self.response_class(value)",
            "            elif isinstance(value, (list, dict)):",
            "                response = self.json.response(value)  # type: ignore[assignment]",
            "            else:",
            "                raise TypeError(",
            "                    f\"The response value type ({type(value).__name__}) is not valid\"",
            "                )",
            "        else:",
            "            response = value",
            "",
            "        if status is not None:",
            "            response.status_code = int(status)",
            "",
            "        if headers is not None:",
            "            response.headers.update(headers)",
            "",
            "        return response",
            "",
            "    async def handle_request(self, request: Request) -> ResponseTypes:",
            "        async with self.request_context(request) as request_context:",
            "            try:",
            "                return await self.full_dispatch_request(request_context)",
            "            except asyncio.CancelledError:",
            "                raise  # CancelledErrors should be handled by serving code.",
            "            except Exception as error:",
            "                return await self.handle_exception(error)",
            "            finally:",
            "                if request.scope.get(\"_quart._preserve_context\", False):",
            "                    self._preserved_context = request_context.copy()",
            "",
            "    async def handle_websocket(self, websocket: Websocket) -> ResponseTypes | None:",
            "        async with self.websocket_context(websocket) as websocket_context:",
            "            try:",
            "                return await self.full_dispatch_websocket(websocket_context)",
            "            except asyncio.CancelledError:",
            "                raise  # CancelledErrors should be handled by serving code.",
            "            except Exception as error:",
            "                return await self.handle_websocket_exception(error)",
            "            finally:",
            "                if websocket.scope.get(\"_quart._preserve_context\", False):",
            "                    self._preserved_context = websocket_context.copy()",
            "",
            "    async def full_dispatch_request(",
            "        self, request_context: RequestContext | None = None",
            "    ) -> ResponseTypes:",
            "        \"\"\"Adds pre and post processing to the request dispatching.",
            "",
            "        Arguments:",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        try:",
            "            await request_started.send_async(self, _sync_wrapper=self.ensure_async)  # type: ignore",
            "",
            "            result: ResponseReturnValue | HTTPException | None",
            "            result = await self.preprocess_request(request_context)",
            "            if result is None:",
            "                result = await self.dispatch_request(request_context)",
            "        except Exception as error:",
            "            result = await self.handle_user_exception(error)",
            "        return await self.finalize_request(result, request_context)",
            "",
            "    async def full_dispatch_websocket(",
            "        self, websocket_context: WebsocketContext | None = None",
            "    ) -> ResponseTypes | None:",
            "        \"\"\"Adds pre and post processing to the websocket dispatching.",
            "",
            "        Arguments:",
            "            websocket_context: The websocket context, optional to match",
            "                the Flask convention.",
            "        \"\"\"",
            "        try:",
            "            await websocket_started.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore",
            "            )",
            "",
            "            result: ResponseReturnValue | HTTPException | None",
            "            result = await self.preprocess_websocket(websocket_context)",
            "            if result is None:",
            "                result = await self.dispatch_websocket(websocket_context)",
            "        except Exception as error:",
            "            result = await self.handle_user_exception(error)",
            "        return await self.finalize_websocket(result, websocket_context)",
            "",
            "    async def preprocess_request(",
            "        self, request_context: RequestContext | None = None",
            "    ) -> ResponseReturnValue | None:",
            "        \"\"\"Preprocess the request i.e. call before_request functions.",
            "",
            "        Arguments:",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [None, *reversed((request_context or request_ctx).request.blueprints)]",
            "",
            "        for name in names:",
            "            for processor in self.url_value_preprocessors[name]:",
            "                processor(request.endpoint, request.view_args)",
            "",
            "        for name in names:",
            "            for function in self.before_request_funcs[name]:",
            "                result = await self.ensure_async(function)()",
            "                if result is not None:",
            "                    return result  # type: ignore[return-value]",
            "",
            "        return None",
            "",
            "    async def preprocess_websocket(",
            "        self, websocket_context: WebsocketContext | None = None",
            "    ) -> ResponseReturnValue | None:",
            "        \"\"\"Preprocess the websocket i.e. call before_websocket functions.",
            "",
            "        Arguments:",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [",
            "            None,",
            "            *reversed((websocket_context or websocket_ctx).websocket.blueprints),",
            "        ]",
            "",
            "        for name in names:",
            "            for processor in self.url_value_preprocessors[name]:",
            "                processor(request.endpoint, request.view_args)",
            "",
            "        for name in names:",
            "            for function in self.before_websocket_funcs[name]:",
            "                result = await self.ensure_async(function)()",
            "                if result is not None:",
            "                    return result  # type: ignore[return-value]",
            "",
            "        return None",
            "",
            "    def raise_routing_exception(self, request: BaseRequestWebsocket) -> NoReturn:",
            "        raise request.routing_exception",
            "",
            "    async def dispatch_request(",
            "        self, request_context: RequestContext | None = None",
            "    ) -> ResponseReturnValue:",
            "        \"\"\"Dispatch the request to the view function.",
            "",
            "        Arguments:",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        request_ = (request_context or request_ctx).request",
            "        if request_.routing_exception is not None:",
            "            self.raise_routing_exception(request_)",
            "",
            "        if request_.method == \"OPTIONS\" and request_.url_rule.provide_automatic_options:",
            "            return await self.make_default_options_response()",
            "",
            "        handler = self.view_functions[request_.url_rule.endpoint]",
            "        return await self.ensure_async(handler)(**request_.view_args)  # type: ignore[return-value]",
            "",
            "    async def dispatch_websocket(",
            "        self, websocket_context: WebsocketContext | None = None",
            "    ) -> ResponseReturnValue | None:",
            "        \"\"\"Dispatch the websocket to the view function.",
            "",
            "        Arguments:",
            "            websocket_context: The websocket context, optional to match",
            "                the Flask convention.",
            "        \"\"\"",
            "        websocket_ = (websocket_context or websocket_ctx).websocket",
            "        if websocket_.routing_exception is not None:",
            "            self.raise_routing_exception(websocket_)",
            "",
            "        handler = self.view_functions[websocket_.url_rule.endpoint]",
            "        return await self.ensure_async(handler)(**websocket_.view_args)  # type: ignore[return-value]",
            "",
            "    async def finalize_request(",
            "        self,",
            "        result: ResponseReturnValue | HTTPException,",
            "        request_context: RequestContext | None = None,",
            "        from_error_handler: bool = False,",
            "    ) -> ResponseTypes:",
            "        \"\"\"Turns the view response return value into a response.",
            "",
            "        Arguments:",
            "            result: The result of the request to finalize into a response.",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        response = await self.make_response(result)",
            "        try:",
            "            response = await self.process_response(response, request_context)",
            "            await request_finished.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                response=response,",
            "            )",
            "        except Exception:",
            "            if not from_error_handler:",
            "                raise",
            "            self.logger.exception(\"Request finalizing errored\")",
            "        return response",
            "",
            "    async def finalize_websocket(",
            "        self,",
            "        result: ResponseReturnValue | HTTPException,",
            "        websocket_context: WebsocketContext | None = None,",
            "        from_error_handler: bool = False,",
            "    ) -> ResponseTypes | None:",
            "        \"\"\"Turns the view response return value into a response.",
            "",
            "        Arguments:",
            "            result: The result of the websocket to finalize into a response.",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        if result is not None:",
            "            response = await self.make_response(result)",
            "        else:",
            "            response = None",
            "        try:",
            "            response = await self.postprocess_websocket(response, websocket_context)",
            "            await websocket_finished.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                response=response,",
            "            )",
            "        except Exception:",
            "            if not from_error_handler:",
            "                raise",
            "            self.logger.exception(\"Request finalizing errored\")",
            "        return response",
            "",
            "    async def process_response(",
            "        self,",
            "        response: ResponseTypes,",
            "        request_context: RequestContext | None = None,",
            "    ) -> ResponseTypes:",
            "        \"\"\"Postprocess the request acting on the response.",
            "",
            "        Arguments:",
            "            response: The response after the request is finalized.",
            "            request_context: The request context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(request_context or request_ctx).request.blueprints, None]",
            "",
            "        for function in (request_context or request_ctx)._after_request_functions:",
            "            response = await self.ensure_async(function)(response)  # type: ignore[assignment]",
            "",
            "        for name in names:",
            "            for function in reversed(self.after_request_funcs[name]):",
            "                response = await self.ensure_async(function)(response)",
            "",
            "        session_ = (request_context or request_ctx).session",
            "        if not self.session_interface.is_null_session(session_):",
            "            await self.ensure_async(self.session_interface.save_session)(",
            "                self, session_, response",
            "            )",
            "        return response",
            "",
            "    async def postprocess_websocket(",
            "        self,",
            "        response: ResponseTypes | None,",
            "        websocket_context: WebsocketContext | None = None,",
            "    ) -> ResponseTypes:",
            "        \"\"\"Postprocess the websocket acting on the response.",
            "",
            "        Arguments:",
            "            response: The response after the websocket is finalized.",
            "            websocket_context: The websocket context, optional as Flask",
            "                omits this argument.",
            "        \"\"\"",
            "        names = [*(websocket_context or websocket_ctx).websocket.blueprints, None]",
            "",
            "        for function in (websocket_context or websocket_ctx)._after_websocket_functions:",
            "            response = await self.ensure_async(function)(response)  # type: ignore[assignment]",
            "",
            "        for name in names:",
            "            for function in reversed(self.after_websocket_funcs[name]):",
            "                response = await self.ensure_async(function)(response)  # type: ignore[assignment]",
            "",
            "        session_ = (websocket_context or websocket_ctx).session",
            "        if not self.session_interface.is_null_session(session_):",
            "            await self.session_interface.save_session(self, session_, response)",
            "        return response",
            "",
            "    async def __call__(",
            "        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable",
            "    ) -> None:",
            "        \"\"\"Called by ASGI servers.",
            "",
            "        The related :meth:`~quart.app.Quart.asgi_app` is called,",
            "        allowing for middleware usage whilst keeping the top level app",
            "        a :class:`~quart.app.Quart` instance.",
            "        \"\"\"",
            "        await self.asgi_app(scope, receive, send)",
            "",
            "    async def asgi_app(",
            "        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable",
            "    ) -> None:",
            "        \"\"\"This handles ASGI calls, it can be wrapped in middleware.",
            "",
            "        When using middleware with Quart it is preferable to wrap this",
            "        method rather than the app itself. This is to ensure that the",
            "        app is an instance of this class - which allows the quart cli",
            "        to work correctly. To use this feature simply do,",
            "",
            "        .. code-block:: python",
            "",
            "            app.asgi_app = middleware(app.asgi_app)",
            "",
            "        \"\"\"",
            "        asgi_handler: ASGIHTTPProtocol | ASGILifespanProtocol | ASGIWebsocketProtocol",
            "        if scope[\"type\"] == \"http\":",
            "            asgi_handler = self.asgi_http_class(self, scope)",
            "        elif scope[\"type\"] == \"websocket\":",
            "            asgi_handler = self.asgi_websocket_class(self, scope)",
            "        elif scope[\"type\"] == \"lifespan\":",
            "            asgi_handler = self.asgi_lifespan_class(self, scope)",
            "        else:",
            "            raise RuntimeError(\"ASGI Scope type is unknown\")",
            "        await asgi_handler(receive, send)",
            "",
            "    async def startup(self) -> None:",
            "        self.shutdown_event = self.event_class()",
            "        try:",
            "            async with self.app_context():",
            "                for func in self.before_serving_funcs:",
            "                    await self.ensure_async(func)()",
            "                for gen in self.while_serving_gens:",
            "                    await gen.__anext__()",
            "        except Exception as error:",
            "            await got_serving_exception.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                exception=error,",
            "            )",
            "            self.log_exception(sys.exc_info())",
            "            raise",
            "",
            "    async def shutdown(self) -> None:",
            "        self.shutdown_event.set()",
            "        try:",
            "            await asyncio.wait_for(",
            "                asyncio.gather(*self.background_tasks),",
            "                timeout=self.config[\"BACKGROUND_TASK_SHUTDOWN_TIMEOUT\"],",
            "            )",
            "        except asyncio.TimeoutError:",
            "            await cancel_tasks(self.background_tasks)",
            "",
            "        try:",
            "            async with self.app_context():",
            "                for func in self.after_serving_funcs:",
            "                    await self.ensure_async(func)()",
            "                for gen in self.while_serving_gens:",
            "                    try:",
            "                        await gen.__anext__()",
            "                    except StopAsyncIteration:",
            "                        pass",
            "                    else:",
            "                        raise RuntimeError(\"While serving generator didn't terminate\")",
            "        except Exception as error:",
            "            await got_serving_exception.send_async(",
            "                self,",
            "                _sync_wrapper=self.ensure_async,  # type: ignore[arg-type]",
            "                exception=error,",
            "            )",
            "            self.log_exception(sys.exc_info())",
            "            raise",
            "",
            "",
            "def _cancel_all_tasks(loop: asyncio.AbstractEventLoop) -> None:",
            "    tasks = [task for task in asyncio.all_tasks(loop) if not task.done()]",
            "    if not tasks:",
            "        return",
            "",
            "    for task in tasks:",
            "        task.cancel()",
            "    loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))",
            "",
            "    for task in tasks:",
            "        if not task.cancelled() and task.exception() is not None:",
            "            loop.call_exception_handler(",
            "                {",
            "                    \"message\": \"unhandled exception during shutdown\",",
            "                    \"exception\": task.exception(),",
            "                    \"task\": task,",
            "                }",
            "            )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1133": [
                "Quart",
                "log_exception"
            ],
            "1134": [
                "Quart",
                "log_exception"
            ]
        },
        "addLocation": [
            "src.quart.app.Quart.self"
        ]
    },
    "src/quart/formparser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     def __init__("
            },
            "2": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         self,"
            },
            "3": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        stream_factory: StreamFactory = default_stream_factory,"
            },
            "4": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_form_memory_size: int | None = None,"
            },
            "5": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_content_length: int | None = None,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        *,"
            },
            "7": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         cls: type[MultiDict] | None = MultiDict,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        max_content_length: int | None = None,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        max_form_memory_size: int | None = None,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        max_form_parts: int | None = None,"
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         silent: bool = True,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        stream_factory: StreamFactory = default_stream_factory,"
            },
            "13": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     ) -> None:"
            },
            "14": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.stream_factory = stream_factory"
            },
            "15": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         self.cls = cls"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        self.max_content_length = max_content_length"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        self.max_form_memory_size = max_form_memory_size"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        self.max_form_parts = max_form_parts"
            },
            "19": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         self.silent = silent"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        self.stream_factory = stream_factory"
            },
            "21": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     def get_parse_func("
            },
            "23": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         self, mimetype: str, options: dict[str, str]"
            },
            "24": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         options: dict[str, str],"
            },
            "25": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     ) -> tuple[MultiDict, MultiDict]:"
            },
            "26": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         parser = MultiPartParser("
            },
            "27": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.stream_factory,"
            },
            "28": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             cls=self.cls,"
            },
            "29": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "             file_storage_cls=self.file_storage_class,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            max_content_length=self.max_content_length,"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            max_form_memory_size=self.max_form_memory_size,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            max_form_parts=self.max_form_parts,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            stream_factory=self.stream_factory,"
            },
            "34": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         )"
            },
            "35": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         boundary = options.get(\"boundary\", \"\").encode(\"ascii\")"
            },
            "36": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 103,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         content_length: int | None,"
            },
            "38": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         options: dict[str, str],"
            },
            "39": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     ) -> tuple[MultiDict, MultiDict]:"
            },
            "40": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        form = parse_qsl("
            },
            "41": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            (await body).decode(),"
            },
            "42": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            keep_blank_values=True,"
            },
            "43": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        try:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            form = parse_qsl("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+                (await body).decode(),"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                keep_blank_values=True,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                max_num_fields=self.max_form_parts,"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+            )"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        except ValueError:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            raise RequestEntityTooLarge() from None"
            },
            "52": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         return self.cls(form), self.cls()"
            },
            "53": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "     parse_functions: dict[str, ParserFunc] = {"
            },
            "55": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " class MultiPartParser:"
            },
            "56": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     def __init__("
            },
            "57": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         self,"
            },
            "58": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        stream_factory: StreamFactory = default_stream_factory,"
            },
            "59": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        max_form_memory_size: int | None = None,"
            },
            "60": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cls: type[MultiDict] = MultiDict,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        *,"
            },
            "62": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "         buffer_size: int = 64 * 1024,"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        cls: type[MultiDict] = MultiDict,"
            },
            "64": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         file_storage_cls: type[FileStorage] = FileStorage,"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        max_content_length: int | None = None,"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        max_form_memory_size: int | None = None,"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        max_form_parts: int | None = None,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        stream_factory: StreamFactory = default_stream_factory,"
            },
            "69": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     ) -> None:"
            },
            "70": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.max_form_memory_size = max_form_memory_size"
            },
            "71": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.stream_factory = stream_factory"
            },
            "72": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.cls = cls"
            },
            "73": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         self.buffer_size = buffer_size"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        self.cls = cls"
            },
            "75": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         self.file_storage_cls = file_storage_cls"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        self.max_content_length = max_content_length"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        self.max_form_memory_size = max_form_memory_size"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        self.max_form_parts = max_form_parts"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        self.stream_factory = stream_factory"
            },
            "80": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "     def fail(self, message: str) -> NoReturn:"
            },
            "82": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "         raise ValueError(message)"
            },
            "83": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         container: IO[bytes] | list[bytes]"
            },
            "84": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         _write: Callable[[bytes], Any]"
            },
            "85": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        parser = MultipartDecoder(boundary, self.max_form_memory_size)"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        parser = MultipartDecoder("
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            boundary, self.max_content_length, max_parts=self.max_form_parts"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        )"
            },
            "90": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         fields = []"
            },
            "92": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         files = []"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from collections.abc import Awaitable",
            "from typing import Any",
            "from typing import Callable",
            "from typing import cast",
            "from typing import IO",
            "from typing import NoReturn",
            "from typing import Optional",
            "from typing import TYPE_CHECKING",
            "from urllib.parse import parse_qsl",
            "",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.datastructures import MultiDict",
            "from werkzeug.exceptions import RequestEntityTooLarge",
            "from werkzeug.formparser import default_stream_factory",
            "from werkzeug.http import parse_options_header",
            "from werkzeug.sansio.multipart import Data",
            "from werkzeug.sansio.multipart import Epilogue",
            "from werkzeug.sansio.multipart import Field",
            "from werkzeug.sansio.multipart import File",
            "from werkzeug.sansio.multipart import MultipartDecoder",
            "from werkzeug.sansio.multipart import NeedData",
            "",
            "from .datastructures import FileStorage",
            "",
            "if TYPE_CHECKING:",
            "    from .wrappers.request import Body",
            "",
            "StreamFactory = Callable[",
            "    [Optional[int], Optional[str], Optional[str], Optional[int]],",
            "    IO[bytes],",
            "]",
            "",
            "ParserFunc = Callable[",
            "    [\"FormDataParser\", \"Body\", str, Optional[int], dict[str, str]],",
            "    Awaitable[tuple[MultiDict, MultiDict]],",
            "]",
            "",
            "",
            "class FormDataParser:",
            "    file_storage_class = FileStorage",
            "",
            "    def __init__(",
            "        self,",
            "        stream_factory: StreamFactory = default_stream_factory,",
            "        max_form_memory_size: int | None = None,",
            "        max_content_length: int | None = None,",
            "        cls: type[MultiDict] | None = MultiDict,",
            "        silent: bool = True,",
            "    ) -> None:",
            "        self.stream_factory = stream_factory",
            "        self.cls = cls",
            "        self.silent = silent",
            "",
            "    def get_parse_func(",
            "        self, mimetype: str, options: dict[str, str]",
            "    ) -> ParserFunc | None:",
            "        return self.parse_functions.get(mimetype)",
            "",
            "    async def parse(",
            "        self,",
            "        body: Body,",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str] | None = None,",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        if options is None:",
            "            options = {}",
            "",
            "        parse_func = self.get_parse_func(mimetype, options)",
            "",
            "        if parse_func is not None:",
            "            try:",
            "                return await parse_func(self, body, mimetype, content_length, options)",
            "            except ValueError:",
            "                if not self.silent:",
            "                    raise",
            "",
            "        return self.cls(), self.cls()",
            "",
            "    async def _parse_multipart(",
            "        self,",
            "        body: Body,",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        parser = MultiPartParser(",
            "            self.stream_factory,",
            "            cls=self.cls,",
            "            file_storage_cls=self.file_storage_class,",
            "        )",
            "        boundary = options.get(\"boundary\", \"\").encode(\"ascii\")",
            "",
            "        if not boundary:",
            "            raise ValueError(\"Missing boundary\")",
            "",
            "        return await parser.parse(body, boundary, content_length)",
            "",
            "    async def _parse_urlencoded(",
            "        self,",
            "        body: Body,",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        form = parse_qsl(",
            "            (await body).decode(),",
            "            keep_blank_values=True,",
            "        )",
            "        return self.cls(form), self.cls()",
            "",
            "    parse_functions: dict[str, ParserFunc] = {",
            "        \"multipart/form-data\": _parse_multipart,",
            "        \"application/x-www-form-urlencoded\": _parse_urlencoded,",
            "        \"application/x-url-encoded\": _parse_urlencoded,",
            "    }",
            "",
            "",
            "class MultiPartParser:",
            "    def __init__(",
            "        self,",
            "        stream_factory: StreamFactory = default_stream_factory,",
            "        max_form_memory_size: int | None = None,",
            "        cls: type[MultiDict] = MultiDict,",
            "        buffer_size: int = 64 * 1024,",
            "        file_storage_cls: type[FileStorage] = FileStorage,",
            "    ) -> None:",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.stream_factory = stream_factory",
            "        self.cls = cls",
            "        self.buffer_size = buffer_size",
            "        self.file_storage_cls = file_storage_cls",
            "",
            "    def fail(self, message: str) -> NoReturn:",
            "        raise ValueError(message)",
            "",
            "    def get_part_charset(self, headers: Headers) -> str:",
            "        content_type = headers.get(\"content-type\")",
            "",
            "        if content_type:",
            "            parameters = parse_options_header(content_type)[1]",
            "            ct_charset = parameters.get(\"charset\", \"\").lower()",
            "",
            "            # A safe list of encodings. Modern clients should only send ASCII or UTF-8.",
            "            # This list will not be extended further.",
            "            if ct_charset in {\"ascii\", \"us-ascii\", \"utf-8\", \"iso-8859-1\"}:",
            "                return ct_charset",
            "",
            "        return \"utf-8\"",
            "",
            "    def start_file_streaming(self, event: File, total_content_length: int) -> IO[bytes]:",
            "        content_type = event.headers.get(\"content-type\")",
            "",
            "        try:",
            "            content_length = int(event.headers[\"content-length\"])",
            "        except (KeyError, ValueError):",
            "            content_length = 0",
            "",
            "        container = self.stream_factory(",
            "            total_content_length,",
            "            content_type,",
            "            event.filename,",
            "            content_length,",
            "        )",
            "        return container",
            "",
            "    async def parse(",
            "        self, body: Body, boundary: bytes, content_length: int",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        container: IO[bytes] | list[bytes]",
            "        _write: Callable[[bytes], Any]",
            "",
            "        parser = MultipartDecoder(boundary, self.max_form_memory_size)",
            "",
            "        fields = []",
            "        files = []",
            "",
            "        current_part: Field | File",
            "        field_size: int | None = None",
            "        async for data in body:",
            "            parser.receive_data(data)",
            "            event = parser.next_event()",
            "            while not isinstance(event, (Epilogue, NeedData)):",
            "                if isinstance(event, Field):",
            "                    current_part = event",
            "                    field_size = 0",
            "                    container = []",
            "                    _write = container.append",
            "                elif isinstance(event, File):",
            "                    current_part = event",
            "                    field_size = None",
            "                    container = self.start_file_streaming(event, content_length)",
            "                    _write = container.write",
            "                elif isinstance(event, Data):",
            "                    if self.max_form_memory_size is not None and field_size is not None:",
            "                        field_size += len(event.data)",
            "",
            "                        if field_size > self.max_form_memory_size:",
            "                            raise RequestEntityTooLarge()",
            "",
            "                    _write(event.data)",
            "                    if not event.more_data:",
            "                        if isinstance(current_part, Field):",
            "                            value = b\"\".join(container).decode(",
            "                                self.get_part_charset(current_part.headers), \"replace\"",
            "                            )",
            "                            fields.append((current_part.name, value))",
            "                        else:",
            "                            container = cast(IO[bytes], container)",
            "                            container.seek(0)",
            "                            files.append(",
            "                                (",
            "                                    current_part.name,",
            "                                    self.file_storage_cls(",
            "                                        container,",
            "                                        current_part.filename,",
            "                                        current_part.name,",
            "                                        headers=current_part.headers,",
            "                                    ),",
            "                                )",
            "                            )",
            "",
            "                event = parser.next_event()",
            "",
            "        return self.cls(fields), self.cls(files)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from collections.abc import Awaitable",
            "from typing import Any",
            "from typing import Callable",
            "from typing import cast",
            "from typing import IO",
            "from typing import NoReturn",
            "from typing import Optional",
            "from typing import TYPE_CHECKING",
            "from urllib.parse import parse_qsl",
            "",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.datastructures import MultiDict",
            "from werkzeug.exceptions import RequestEntityTooLarge",
            "from werkzeug.formparser import default_stream_factory",
            "from werkzeug.http import parse_options_header",
            "from werkzeug.sansio.multipart import Data",
            "from werkzeug.sansio.multipart import Epilogue",
            "from werkzeug.sansio.multipart import Field",
            "from werkzeug.sansio.multipart import File",
            "from werkzeug.sansio.multipart import MultipartDecoder",
            "from werkzeug.sansio.multipart import NeedData",
            "",
            "from .datastructures import FileStorage",
            "",
            "if TYPE_CHECKING:",
            "    from .wrappers.request import Body",
            "",
            "StreamFactory = Callable[",
            "    [Optional[int], Optional[str], Optional[str], Optional[int]],",
            "    IO[bytes],",
            "]",
            "",
            "ParserFunc = Callable[",
            "    [\"FormDataParser\", \"Body\", str, Optional[int], dict[str, str]],",
            "    Awaitable[tuple[MultiDict, MultiDict]],",
            "]",
            "",
            "",
            "class FormDataParser:",
            "    file_storage_class = FileStorage",
            "",
            "    def __init__(",
            "        self,",
            "        *,",
            "        cls: type[MultiDict] | None = MultiDict,",
            "        max_content_length: int | None = None,",
            "        max_form_memory_size: int | None = None,",
            "        max_form_parts: int | None = None,",
            "        silent: bool = True,",
            "        stream_factory: StreamFactory = default_stream_factory,",
            "    ) -> None:",
            "        self.cls = cls",
            "        self.max_content_length = max_content_length",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_form_parts = max_form_parts",
            "        self.silent = silent",
            "        self.stream_factory = stream_factory",
            "",
            "    def get_parse_func(",
            "        self, mimetype: str, options: dict[str, str]",
            "    ) -> ParserFunc | None:",
            "        return self.parse_functions.get(mimetype)",
            "",
            "    async def parse(",
            "        self,",
            "        body: Body,",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str] | None = None,",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        if options is None:",
            "            options = {}",
            "",
            "        parse_func = self.get_parse_func(mimetype, options)",
            "",
            "        if parse_func is not None:",
            "            try:",
            "                return await parse_func(self, body, mimetype, content_length, options)",
            "            except ValueError:",
            "                if not self.silent:",
            "                    raise",
            "",
            "        return self.cls(), self.cls()",
            "",
            "    async def _parse_multipart(",
            "        self,",
            "        body: Body,",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        parser = MultiPartParser(",
            "            cls=self.cls,",
            "            file_storage_cls=self.file_storage_class,",
            "            max_content_length=self.max_content_length,",
            "            max_form_memory_size=self.max_form_memory_size,",
            "            max_form_parts=self.max_form_parts,",
            "            stream_factory=self.stream_factory,",
            "        )",
            "        boundary = options.get(\"boundary\", \"\").encode(\"ascii\")",
            "",
            "        if not boundary:",
            "            raise ValueError(\"Missing boundary\")",
            "",
            "        return await parser.parse(body, boundary, content_length)",
            "",
            "    async def _parse_urlencoded(",
            "        self,",
            "        body: Body,",
            "        mimetype: str,",
            "        content_length: int | None,",
            "        options: dict[str, str],",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        try:",
            "            form = parse_qsl(",
            "                (await body).decode(),",
            "                keep_blank_values=True,",
            "                max_num_fields=self.max_form_parts,",
            "            )",
            "        except ValueError:",
            "            raise RequestEntityTooLarge() from None",
            "        return self.cls(form), self.cls()",
            "",
            "    parse_functions: dict[str, ParserFunc] = {",
            "        \"multipart/form-data\": _parse_multipart,",
            "        \"application/x-www-form-urlencoded\": _parse_urlencoded,",
            "        \"application/x-url-encoded\": _parse_urlencoded,",
            "    }",
            "",
            "",
            "class MultiPartParser:",
            "    def __init__(",
            "        self,",
            "        *,",
            "        buffer_size: int = 64 * 1024,",
            "        cls: type[MultiDict] = MultiDict,",
            "        file_storage_cls: type[FileStorage] = FileStorage,",
            "        max_content_length: int | None = None,",
            "        max_form_memory_size: int | None = None,",
            "        max_form_parts: int | None = None,",
            "        stream_factory: StreamFactory = default_stream_factory,",
            "    ) -> None:",
            "        self.buffer_size = buffer_size",
            "        self.cls = cls",
            "        self.file_storage_cls = file_storage_cls",
            "        self.max_content_length = max_content_length",
            "        self.max_form_memory_size = max_form_memory_size",
            "        self.max_form_parts = max_form_parts",
            "        self.stream_factory = stream_factory",
            "",
            "    def fail(self, message: str) -> NoReturn:",
            "        raise ValueError(message)",
            "",
            "    def get_part_charset(self, headers: Headers) -> str:",
            "        content_type = headers.get(\"content-type\")",
            "",
            "        if content_type:",
            "            parameters = parse_options_header(content_type)[1]",
            "            ct_charset = parameters.get(\"charset\", \"\").lower()",
            "",
            "            # A safe list of encodings. Modern clients should only send ASCII or UTF-8.",
            "            # This list will not be extended further.",
            "            if ct_charset in {\"ascii\", \"us-ascii\", \"utf-8\", \"iso-8859-1\"}:",
            "                return ct_charset",
            "",
            "        return \"utf-8\"",
            "",
            "    def start_file_streaming(self, event: File, total_content_length: int) -> IO[bytes]:",
            "        content_type = event.headers.get(\"content-type\")",
            "",
            "        try:",
            "            content_length = int(event.headers[\"content-length\"])",
            "        except (KeyError, ValueError):",
            "            content_length = 0",
            "",
            "        container = self.stream_factory(",
            "            total_content_length,",
            "            content_type,",
            "            event.filename,",
            "            content_length,",
            "        )",
            "        return container",
            "",
            "    async def parse(",
            "        self, body: Body, boundary: bytes, content_length: int",
            "    ) -> tuple[MultiDict, MultiDict]:",
            "        container: IO[bytes] | list[bytes]",
            "        _write: Callable[[bytes], Any]",
            "",
            "        parser = MultipartDecoder(",
            "            boundary, self.max_content_length, max_parts=self.max_form_parts",
            "        )",
            "",
            "        fields = []",
            "        files = []",
            "",
            "        current_part: Field | File",
            "        field_size: int | None = None",
            "        async for data in body:",
            "            parser.receive_data(data)",
            "            event = parser.next_event()",
            "            while not isinstance(event, (Epilogue, NeedData)):",
            "                if isinstance(event, Field):",
            "                    current_part = event",
            "                    field_size = 0",
            "                    container = []",
            "                    _write = container.append",
            "                elif isinstance(event, File):",
            "                    current_part = event",
            "                    field_size = None",
            "                    container = self.start_file_streaming(event, content_length)",
            "                    _write = container.write",
            "                elif isinstance(event, Data):",
            "                    if self.max_form_memory_size is not None and field_size is not None:",
            "                        field_size += len(event.data)",
            "",
            "                        if field_size > self.max_form_memory_size:",
            "                            raise RequestEntityTooLarge()",
            "",
            "                    _write(event.data)",
            "                    if not event.more_data:",
            "                        if isinstance(current_part, Field):",
            "                            value = b\"\".join(container).decode(",
            "                                self.get_part_charset(current_part.headers), \"replace\"",
            "                            )",
            "                            fields.append((current_part.name, value))",
            "                        else:",
            "                            container = cast(IO[bytes], container)",
            "                            container.seek(0)",
            "                            files.append(",
            "                                (",
            "                                    current_part.name,",
            "                                    self.file_storage_cls(",
            "                                        container,",
            "                                        current_part.filename,",
            "                                        current_part.name,",
            "                                        headers=current_part.headers,",
            "                                    ),",
            "                                )",
            "                            )",
            "",
            "                event = parser.next_event()",
            "",
            "        return self.cls(fields), self.cls(files)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "46": [
                "FormDataParser",
                "__init__"
            ],
            "47": [
                "FormDataParser",
                "__init__"
            ],
            "48": [
                "FormDataParser",
                "__init__"
            ],
            "52": [
                "FormDataParser",
                "__init__"
            ],
            "90": [
                "FormDataParser"
            ],
            "108": [
                "FormDataParser"
            ],
            "109": [
                "FormDataParser"
            ],
            "110": [
                "FormDataParser"
            ],
            "111": [
                "FormDataParser"
            ],
            "124": [
                "MultiPartParser",
                "__init__"
            ],
            "125": [
                "MultiPartParser",
                "__init__"
            ],
            "126": [
                "MultiPartParser",
                "__init__"
            ],
            "130": [
                "MultiPartParser",
                "__init__"
            ],
            "131": [
                "MultiPartParser",
                "__init__"
            ],
            "132": [
                "MultiPartParser",
                "__init__"
            ],
            "175": [
                "MultiPartParser"
            ]
        },
        "addLocation": []
    },
    "src/quart/wrappers/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from werkzeug.sansio.request import Request as SansIORequest"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from .. import json"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ..globals import current_app"
            },
            "4": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     from ..routing import QuartRule  # noqa"
            },
            "7": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         self.http_version = http_version"
            },
            "8": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         self.scope = scope"
            },
            "9": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @property"
            },
            "11": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def max_content_length(self) -> int | None:"
            },
            "12": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\""
            },
            "13": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if current_app:"
            },
            "14": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return current_app.config[\"MAX_CONTENT_LENGTH\"]"
            },
            "15": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "16": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return None"
            },
            "17": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "18": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     @property"
            },
            "19": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     def endpoint(self) -> str | None:"
            },
            "20": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         \"\"\"Returns the corresponding endpoint matched for this request."
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "from typing import TYPE_CHECKING",
            "",
            "from hypercorn.typing import WWWScope",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.sansio.request import Request as SansIORequest",
            "",
            "from .. import json",
            "from ..globals import current_app",
            "",
            "if TYPE_CHECKING:",
            "    from ..routing import QuartRule  # noqa",
            "",
            "",
            "class BaseRequestWebsocket(SansIORequest):",
            "    \"\"\"This class is the basis for Requests and websockets..",
            "",
            "    Attributes:",
            "        json_module: A custom json decoding/encoding module, it should",
            "            have `dump`, `dumps`, `load`, and `loads` methods",
            "        routing_exception: If an exception is raised during the route",
            "            matching it will be stored here.",
            "        url_rule: The rule that this request has been matched too.",
            "        view_args: The keyword arguments for the view from the route",
            "            matching.",
            "    \"\"\"",
            "",
            "    json_module: json.provider.JSONProvider = json  # type: ignore",
            "    routing_exception: Exception | None = None",
            "    url_rule: QuartRule | None = None",
            "    view_args: dict[str, Any] | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        method: str,",
            "        scheme: str,",
            "        path: str,",
            "        query_string: bytes,",
            "        headers: Headers,",
            "        root_path: str,",
            "        http_version: str,",
            "        scope: WWWScope,",
            "    ) -> None:",
            "        \"\"\"Create a request or websocket base object.",
            "",
            "        Arguments:",
            "            method: The HTTP verb.",
            "            scheme: The scheme used for the request.",
            "            path: The full unquoted path of the request.",
            "            query_string: The raw bytes for the query string part.",
            "            headers: The request headers.",
            "            root_path: The root path that should be prepended to all",
            "                routes.",
            "            http_version: The HTTP version of the request.",
            "            scope: Underlying ASGI scope dictionary.",
            "",
            "        Attributes:",
            "            args: The query string arguments.",
            "            scheme: The URL scheme, http or https.",
            "        \"\"\"",
            "        super().__init__(",
            "            method,",
            "            scheme,",
            "            scope.get(\"server\"),",
            "            root_path,",
            "            path,",
            "            query_string,",
            "            headers,",
            "            headers.get(\"Remote-Addr\"),",
            "        )",
            "        self.http_version = http_version",
            "        self.scope = scope",
            "",
            "    @property",
            "    def max_content_length(self) -> int | None:",
            "        \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\"",
            "        if current_app:",
            "            return current_app.config[\"MAX_CONTENT_LENGTH\"]",
            "        else:",
            "            return None",
            "",
            "    @property",
            "    def endpoint(self) -> str | None:",
            "        \"\"\"Returns the corresponding endpoint matched for this request.",
            "",
            "        This can be None if the request has not been matched with a",
            "        rule.",
            "        \"\"\"",
            "        if self.url_rule is not None:",
            "            return self.url_rule.endpoint",
            "        else:",
            "            return None",
            "",
            "    @property",
            "    def blueprint(self) -> str | None:",
            "        \"\"\"Returns the blueprint the matched endpoint belongs to.",
            "",
            "        This can be None if the request has not been matched or the",
            "        endpoint is not in a blueprint.",
            "        \"\"\"",
            "        if self.endpoint is not None and \".\" in self.endpoint:",
            "            return self.endpoint.rsplit(\".\", 1)[0]",
            "        else:",
            "            return None",
            "",
            "    @property",
            "    def blueprints(self) -> list[str]:",
            "        \"\"\"Return the names of the current blueprints.",
            "        The returned list is ordered from the current blueprint,",
            "        upwards through parent blueprints.",
            "        \"\"\"",
            "        # Avoid circular import",
            "        from ..helpers import _split_blueprint_path",
            "",
            "        if self.blueprint is not None:",
            "            return _split_blueprint_path(self.blueprint)",
            "        else:",
            "            return []",
            "",
            "    @property",
            "    def script_root(self) -> str:",
            "        return self.root_path",
            "",
            "    @property",
            "    def url_root(self) -> str:",
            "        return self.root_url"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "from typing import TYPE_CHECKING",
            "",
            "from hypercorn.typing import WWWScope",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.sansio.request import Request as SansIORequest",
            "",
            "from .. import json",
            "",
            "if TYPE_CHECKING:",
            "    from ..routing import QuartRule  # noqa",
            "",
            "",
            "class BaseRequestWebsocket(SansIORequest):",
            "    \"\"\"This class is the basis for Requests and websockets..",
            "",
            "    Attributes:",
            "        json_module: A custom json decoding/encoding module, it should",
            "            have `dump`, `dumps`, `load`, and `loads` methods",
            "        routing_exception: If an exception is raised during the route",
            "            matching it will be stored here.",
            "        url_rule: The rule that this request has been matched too.",
            "        view_args: The keyword arguments for the view from the route",
            "            matching.",
            "    \"\"\"",
            "",
            "    json_module: json.provider.JSONProvider = json  # type: ignore",
            "    routing_exception: Exception | None = None",
            "    url_rule: QuartRule | None = None",
            "    view_args: dict[str, Any] | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        method: str,",
            "        scheme: str,",
            "        path: str,",
            "        query_string: bytes,",
            "        headers: Headers,",
            "        root_path: str,",
            "        http_version: str,",
            "        scope: WWWScope,",
            "    ) -> None:",
            "        \"\"\"Create a request or websocket base object.",
            "",
            "        Arguments:",
            "            method: The HTTP verb.",
            "            scheme: The scheme used for the request.",
            "            path: The full unquoted path of the request.",
            "            query_string: The raw bytes for the query string part.",
            "            headers: The request headers.",
            "            root_path: The root path that should be prepended to all",
            "                routes.",
            "            http_version: The HTTP version of the request.",
            "            scope: Underlying ASGI scope dictionary.",
            "",
            "        Attributes:",
            "            args: The query string arguments.",
            "            scheme: The URL scheme, http or https.",
            "        \"\"\"",
            "        super().__init__(",
            "            method,",
            "            scheme,",
            "            scope.get(\"server\"),",
            "            root_path,",
            "            path,",
            "            query_string,",
            "            headers,",
            "            headers.get(\"Remote-Addr\"),",
            "        )",
            "        self.http_version = http_version",
            "        self.scope = scope",
            "",
            "    @property",
            "    def endpoint(self) -> str | None:",
            "        \"\"\"Returns the corresponding endpoint matched for this request.",
            "",
            "        This can be None if the request has not been matched with a",
            "        rule.",
            "        \"\"\"",
            "        if self.url_rule is not None:",
            "            return self.url_rule.endpoint",
            "        else:",
            "            return None",
            "",
            "    @property",
            "    def blueprint(self) -> str | None:",
            "        \"\"\"Returns the blueprint the matched endpoint belongs to.",
            "",
            "        This can be None if the request has not been matched or the",
            "        endpoint is not in a blueprint.",
            "        \"\"\"",
            "        if self.endpoint is not None and \".\" in self.endpoint:",
            "            return self.endpoint.rsplit(\".\", 1)[0]",
            "        else:",
            "            return None",
            "",
            "    @property",
            "    def blueprints(self) -> list[str]:",
            "        \"\"\"Return the names of the current blueprints.",
            "        The returned list is ordered from the current blueprint,",
            "        upwards through parent blueprints.",
            "        \"\"\"",
            "        # Avoid circular import",
            "        from ..helpers import _split_blueprint_path",
            "",
            "        if self.blueprint is not None:",
            "            return _split_blueprint_path(self.blueprint)",
            "        else:",
            "            return []",
            "",
            "    @property",
            "    def script_root(self) -> str:",
            "        return self.root_path",
            "",
            "    @property",
            "    def url_root(self) -> str:",
            "        return self.root_url"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "76": [
                "BaseRequestWebsocket"
            ],
            "77": [
                "BaseRequestWebsocket",
                "max_content_length"
            ],
            "78": [
                "BaseRequestWebsocket",
                "max_content_length"
            ],
            "79": [
                "BaseRequestWebsocket",
                "max_content_length"
            ],
            "80": [
                "BaseRequestWebsocket",
                "max_content_length"
            ],
            "81": [
                "BaseRequestWebsocket",
                "max_content_length"
            ],
            "82": [
                "BaseRequestWebsocket",
                "max_content_length"
            ],
            "83": [
                "BaseRequestWebsocket"
            ]
        },
        "addLocation": []
    },
    "src/quart/wrappers/request.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     body_class = Body"
            },
            "1": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     form_data_parser_class = FormDataParser"
            },
            "2": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "     lock_class = asyncio.Lock"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    _max_content_length: int | None = None"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    _max_form_memory_size: int | None = None"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    _max_form_parts: int | None = None"
            },
            "6": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     def __init__("
            },
            "8": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         self,"
            },
            "9": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "         self._parsing_lock = self.lock_class()"
            },
            "10": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         self._send_push_promise = send_push_promise"
            },
            "11": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 194,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+    @property"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+    def max_content_length(self) -> int | None:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        if self._max_content_length is not None:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            return self._max_content_length"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        if current_app:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            return current_app.config[\"MAX_CONTENT_LENGTH\"]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        return None"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+    @max_content_length.setter"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+    def max_content_length(self, value: int | None) -> None:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        self._max_content_length = value"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+    @property"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+    def max_form_memory_size(self) -> int | None:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+        if self._max_form_memory_size is not None:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            return self._max_form_memory_size"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        if current_app:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            return current_app.config[\"MAX_FORM_MEMORY_SIZE\"]"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        return None"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    @max_form_memory_size.setter"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    def max_form_memory_size(self, value: int | None) -> None:"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        self._max_form_memory_size = value"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+    @property"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+    def max_form_parts(self) -> int | None:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        if self._max_form_parts is not None:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            return self._max_form_parts"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        if current_app:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+            return current_app.config[\"MAX_FORM_PARTS\"]"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        return None"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+    @max_form_parts.setter"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+    def max_form_parts(self, value: int | None) -> None:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        self._max_form_parts = value"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     @property"
            },
            "55": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "     async def stream(self) -> NoReturn:"
            },
            "56": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         raise NotImplementedError(\"Use body instead\")"
            },
            "57": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "     def make_form_data_parser(self) -> FormDataParser:"
            },
            "58": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         return self.form_data_parser_class("
            },
            "59": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "             max_content_length=self.max_content_length,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+            max_form_memory_size=self.max_form_memory_size,"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+            max_form_parts=self.max_form_parts,"
            },
            "62": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "             cls=self.parameter_storage_class,"
            },
            "63": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         )"
            },
            "64": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 336,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "from collections.abc import Awaitable",
            "from collections.abc import Generator",
            "from typing import Any",
            "from typing import Callable",
            "from typing import Literal",
            "from typing import NoReturn",
            "from typing import overload",
            "",
            "from hypercorn.typing import HTTPScope",
            "from werkzeug.datastructures import CombinedMultiDict",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.datastructures import iter_multi_items",
            "from werkzeug.datastructures import MultiDict",
            "from werkzeug.exceptions import BadRequest",
            "from werkzeug.exceptions import RequestEntityTooLarge",
            "from werkzeug.exceptions import RequestTimeout",
            "",
            "from ..formparser import FormDataParser",
            "from ..globals import current_app",
            "from .base import BaseRequestWebsocket",
            "",
            "SERVER_PUSH_HEADERS_TO_COPY = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "class Body:",
            "    \"\"\"A request body container.",
            "",
            "    The request body can either be iterated over and consumed in parts",
            "    (without building up memory usage) or awaited.",
            "",
            "    .. code-block:: python",
            "",
            "        async for data in body:",
            "            ...",
            "        # or simply",
            "        complete = await body",
            "",
            "    Note: It is not possible to iterate over the data and then await",
            "    it.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, expected_content_length: int | None, max_content_length: int | None",
            "    ) -> None:",
            "        self._data = bytearray()",
            "        self._complete: asyncio.Event = asyncio.Event()",
            "        self._has_data: asyncio.Event = asyncio.Event()",
            "        self._max_content_length = max_content_length",
            "        # Exceptions must be raised within application (not ASGI)",
            "        # calls, this is achieved by having the ASGI methods set this",
            "        # to an exception on error.",
            "        self._must_raise: Exception | None = None",
            "        if (",
            "            expected_content_length is not None",
            "            and max_content_length is not None",
            "            and expected_content_length > max_content_length",
            "        ):",
            "            self._must_raise = RequestEntityTooLarge()",
            "",
            "    def __aiter__(self) -> Body:",
            "        return self",
            "",
            "    async def __anext__(self) -> bytes:",
            "        if self._must_raise is not None:",
            "            raise self._must_raise",
            "",
            "        # if we got all of the data in the first shot, then self._complete is",
            "        # set and self._has_data will not get set again, so skip the await",
            "        # if we already have completed everything",
            "        if not self._complete.is_set():",
            "            await self._has_data.wait()",
            "",
            "        if self._complete.is_set() and len(self._data) == 0:",
            "            raise StopAsyncIteration()",
            "",
            "        data = bytes(self._data)",
            "        self._data.clear()",
            "        self._has_data.clear()",
            "        return data",
            "",
            "    def __await__(self) -> Generator[Any, None, Any]:",
            "        # Must check the _must_raise before and after waiting on the",
            "        # completion event as it may change whilst waiting and the",
            "        # event may not be set if there is already an issue.",
            "        if self._must_raise is not None:",
            "            raise self._must_raise",
            "",
            "        yield from self._complete.wait().__await__()",
            "",
            "        if self._must_raise is not None:",
            "            raise self._must_raise",
            "        return bytes(self._data)",
            "",
            "    def append(self, data: bytes) -> None:",
            "        if data == b\"\" or self._must_raise is not None:",
            "            return",
            "        self._data.extend(data)",
            "        self._has_data.set()",
            "        if (",
            "            self._max_content_length is not None",
            "            and len(self._data) > self._max_content_length",
            "        ):",
            "            self._must_raise = RequestEntityTooLarge()",
            "            self.set_complete()",
            "",
            "    def set_complete(self) -> None:",
            "        self._complete.set()",
            "        self._has_data.set()",
            "",
            "    def set_result(self, data: bytes) -> None:",
            "        \"\"\"Convenience method, mainly for testing.\"\"\"",
            "        self.append(data)",
            "        self.set_complete()",
            "",
            "    def clear(self) -> None:",
            "        self._data.clear()",
            "",
            "",
            "class Request(BaseRequestWebsocket):",
            "    \"\"\"This class represents a request.",
            "",
            "    It can be subclassed and the subclassed used in preference by",
            "    replacing the :attr:`~quart.Quart.request_class` with your",
            "    subclass.",
            "",
            "    Attributes:",
            "        body_class: The class to store the body data within.",
            "        form_data_parser_class: Can be overridden to implement a",
            "            different form data parsing.",
            "    \"\"\"",
            "",
            "    body_class = Body",
            "    form_data_parser_class = FormDataParser",
            "    lock_class = asyncio.Lock",
            "",
            "    def __init__(",
            "        self,",
            "        method: str,",
            "        scheme: str,",
            "        path: str,",
            "        query_string: bytes,",
            "        headers: Headers,",
            "        root_path: str,",
            "        http_version: str,",
            "        scope: HTTPScope,",
            "        *,",
            "        max_content_length: int | None = None,",
            "        body_timeout: int | None = None,",
            "        send_push_promise: Callable[[str, Headers], Awaitable[None]],",
            "    ) -> None:",
            "        \"\"\"Create a request object.",
            "",
            "        Arguments:",
            "            method: The HTTP verb.",
            "            scheme: The scheme used for the request.",
            "            path: The full unquoted path of the request.",
            "            query_string: The raw bytes for the query string part.",
            "            headers: The request headers.",
            "            root_path: The root path that should be prepended to all",
            "                routes.",
            "            http_version: The HTTP version of the request.",
            "            body: An awaitable future for the body data i.e.",
            "                ``data = await body``",
            "            max_content_length: The maximum length in bytes of the",
            "                body (None implies no limit in Quart).",
            "            body_timeout: The maximum time (seconds) to wait for the",
            "                body before timing out.",
            "            send_push_promise: An awaitable to send a push promise based",
            "                off of this request (HTTP/2 feature).",
            "            scope: Underlying ASGI scope dictionary.",
            "        \"\"\"",
            "        super().__init__(",
            "            method, scheme, path, query_string, headers, root_path, http_version, scope",
            "        )",
            "        self.body_timeout = body_timeout",
            "        self.body = self.body_class(self.content_length, max_content_length)",
            "        self._cached_json: dict[bool, Any] = {False: Ellipsis, True: Ellipsis}",
            "        self._form: MultiDict | None = None",
            "        self._files: MultiDict | None = None",
            "        self._parsing_lock = self.lock_class()",
            "        self._send_push_promise = send_push_promise",
            "",
            "    @property",
            "    async def stream(self) -> NoReturn:",
            "        raise NotImplementedError(\"Use body instead\")",
            "",
            "    @property",
            "    async def data(self) -> bytes:",
            "        return await self.get_data(as_text=False, parse_form_data=True)  # type: ignore",
            "",
            "    @overload",
            "    async def get_data(",
            "        self, cache: bool, as_text: Literal[False], parse_form_data: bool",
            "    ) -> bytes: ...",
            "",
            "    @overload",
            "    async def get_data(",
            "        self, cache: bool, as_text: Literal[True], parse_form_data: bool",
            "    ) -> str: ...",
            "",
            "    @overload",
            "    async def get_data(",
            "        self, cache: bool = True, as_text: bool = False, parse_form_data: bool = False",
            "    ) -> str | bytes: ...",
            "",
            "    async def get_data(",
            "        self, cache: bool = True, as_text: bool = False, parse_form_data: bool = False",
            "    ) -> str | bytes:",
            "        \"\"\"Get the request body data.",
            "",
            "        Arguments:",
            "            cache: If False the body data will be cleared, resulting in any",
            "                subsequent calls returning an empty str | bytes and reducing",
            "                memory usage.",
            "            as_text: If True the data is returned as a decoded string,",
            "                otherwise raw bytes are returned.",
            "            parse_form_data: Parse the data as form data first, return any",
            "                remaining data.",
            "        \"\"\"",
            "        if parse_form_data:",
            "            await self._load_form_data()",
            "",
            "        try:",
            "            raw_data = await asyncio.wait_for(self.body, timeout=self.body_timeout)",
            "        except asyncio.TimeoutError as e:",
            "            raise RequestTimeout() from e",
            "        else:",
            "            if not cache:",
            "                self.body.clear()",
            "",
            "            if as_text:",
            "                return raw_data.decode()",
            "            else:",
            "                return raw_data",
            "",
            "    @property",
            "    async def values(self) -> CombinedMultiDict:",
            "        sources = [self.args]",
            "        if self.method != \"GET\":",
            "            # Whilst GET requests are allowed to have a body, most",
            "            # implementations do not allow this hence this",
            "            # inconsistency may result in confusing values.",
            "            form = await self.form",
            "            sources.append(form)",
            "",
            "        multidict_sources: list[MultiDict] = []",
            "        for source in sources:",
            "            if not isinstance(source, MultiDict):",
            "                multidict_sources.append(MultiDict(source))",
            "            else:",
            "                multidict_sources.append(source)",
            "",
            "        return CombinedMultiDict(multidict_sources)",
            "",
            "    @property",
            "    async def form(self) -> MultiDict:",
            "        \"\"\"The parsed form encoded data.",
            "",
            "        Note file data is present in the :attr:`files`.",
            "        \"\"\"",
            "        await self._load_form_data()",
            "        return self._form",
            "",
            "    @property",
            "    async def files(self) -> MultiDict:",
            "        \"\"\"The parsed files.",
            "",
            "        This will return an empty multidict unless the request",
            "        mimetype was ``enctype=\"multipart/form-data\"`` and the method",
            "        POST, PUT, or PATCH.",
            "        \"\"\"",
            "        await self._load_form_data()",
            "        return self._files",
            "",
            "    def make_form_data_parser(self) -> FormDataParser:",
            "        return self.form_data_parser_class(",
            "            max_content_length=self.max_content_length,",
            "            cls=self.parameter_storage_class,",
            "        )",
            "",
            "    async def _load_form_data(self) -> None:",
            "        async with self._parsing_lock:",
            "            if self._form is None:",
            "                parser = self.make_form_data_parser()",
            "                try:",
            "                    self._form, self._files = await asyncio.wait_for(",
            "                        parser.parse(",
            "                            self.body,",
            "                            self.mimetype,",
            "                            self.content_length,",
            "                            self.mimetype_params,",
            "                        ),",
            "                        timeout=self.body_timeout,",
            "                    )",
            "                except asyncio.TimeoutError as e:",
            "                    raise RequestTimeout() from e",
            "",
            "    @property",
            "    async def json(self) -> Any:",
            "        return await self.get_json()",
            "",
            "    async def get_json(",
            "        self, force: bool = False, silent: bool = False, cache: bool = True",
            "    ) -> Any:",
            "        \"\"\"Parses the body data as JSON and returns it.",
            "",
            "        Arguments:",
            "            force: Force JSON parsing even if the mimetype is not JSON.",
            "            silent: Do not trigger error handling if parsing fails, without",
            "                this the :meth:`on_json_loading_failed` will be called on",
            "                error.",
            "            cache: Cache the parsed JSON on this request object.",
            "        \"\"\"",
            "        if cache and self._cached_json[silent] is not Ellipsis:",
            "            return self._cached_json[silent]",
            "",
            "        if not (force or self.is_json):",
            "            return None",
            "",
            "        data = await self.get_data(cache=cache, as_text=True)",
            "",
            "        try:",
            "            result = self.json_module.loads(data)",
            "        except ValueError as error:",
            "            if silent:",
            "                result = None",
            "            else:",
            "                result = self.on_json_loading_failed(error)",
            "",
            "        if cache:",
            "            self._cached_json[silent] = result",
            "",
            "        return result",
            "",
            "    def on_json_loading_failed(self, error: Exception) -> Any:",
            "        \"\"\"Handle a JSON parsing error.",
            "",
            "        Arguments:",
            "            error: The exception raised during parsing.",
            "        Returns:",
            "            Any value returned (if overridden) will be used as the",
            "            default for any get_json calls.",
            "        \"\"\"",
            "        if current_app and current_app.debug:",
            "            raise BadRequest(f\"Failed to decode JSON: {error}\")",
            "",
            "        raise BadRequest()",
            "",
            "    async def send_push_promise(self, path: str) -> None:",
            "        headers = Headers()",
            "        for name in SERVER_PUSH_HEADERS_TO_COPY:",
            "            for value in self.headers.getlist(name):",
            "                headers.add(name, value)",
            "        await self._send_push_promise(path, headers)",
            "",
            "    async def close(self) -> None:",
            "        for _key, value in iter_multi_items(self._files or ()):",
            "            value.close()"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "from collections.abc import Awaitable",
            "from collections.abc import Generator",
            "from typing import Any",
            "from typing import Callable",
            "from typing import Literal",
            "from typing import NoReturn",
            "from typing import overload",
            "",
            "from hypercorn.typing import HTTPScope",
            "from werkzeug.datastructures import CombinedMultiDict",
            "from werkzeug.datastructures import Headers",
            "from werkzeug.datastructures import iter_multi_items",
            "from werkzeug.datastructures import MultiDict",
            "from werkzeug.exceptions import BadRequest",
            "from werkzeug.exceptions import RequestEntityTooLarge",
            "from werkzeug.exceptions import RequestTimeout",
            "",
            "from ..formparser import FormDataParser",
            "from ..globals import current_app",
            "from .base import BaseRequestWebsocket",
            "",
            "SERVER_PUSH_HEADERS_TO_COPY = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "class Body:",
            "    \"\"\"A request body container.",
            "",
            "    The request body can either be iterated over and consumed in parts",
            "    (without building up memory usage) or awaited.",
            "",
            "    .. code-block:: python",
            "",
            "        async for data in body:",
            "            ...",
            "        # or simply",
            "        complete = await body",
            "",
            "    Note: It is not possible to iterate over the data and then await",
            "    it.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self, expected_content_length: int | None, max_content_length: int | None",
            "    ) -> None:",
            "        self._data = bytearray()",
            "        self._complete: asyncio.Event = asyncio.Event()",
            "        self._has_data: asyncio.Event = asyncio.Event()",
            "        self._max_content_length = max_content_length",
            "        # Exceptions must be raised within application (not ASGI)",
            "        # calls, this is achieved by having the ASGI methods set this",
            "        # to an exception on error.",
            "        self._must_raise: Exception | None = None",
            "        if (",
            "            expected_content_length is not None",
            "            and max_content_length is not None",
            "            and expected_content_length > max_content_length",
            "        ):",
            "            self._must_raise = RequestEntityTooLarge()",
            "",
            "    def __aiter__(self) -> Body:",
            "        return self",
            "",
            "    async def __anext__(self) -> bytes:",
            "        if self._must_raise is not None:",
            "            raise self._must_raise",
            "",
            "        # if we got all of the data in the first shot, then self._complete is",
            "        # set and self._has_data will not get set again, so skip the await",
            "        # if we already have completed everything",
            "        if not self._complete.is_set():",
            "            await self._has_data.wait()",
            "",
            "        if self._complete.is_set() and len(self._data) == 0:",
            "            raise StopAsyncIteration()",
            "",
            "        data = bytes(self._data)",
            "        self._data.clear()",
            "        self._has_data.clear()",
            "        return data",
            "",
            "    def __await__(self) -> Generator[Any, None, Any]:",
            "        # Must check the _must_raise before and after waiting on the",
            "        # completion event as it may change whilst waiting and the",
            "        # event may not be set if there is already an issue.",
            "        if self._must_raise is not None:",
            "            raise self._must_raise",
            "",
            "        yield from self._complete.wait().__await__()",
            "",
            "        if self._must_raise is not None:",
            "            raise self._must_raise",
            "        return bytes(self._data)",
            "",
            "    def append(self, data: bytes) -> None:",
            "        if data == b\"\" or self._must_raise is not None:",
            "            return",
            "        self._data.extend(data)",
            "        self._has_data.set()",
            "        if (",
            "            self._max_content_length is not None",
            "            and len(self._data) > self._max_content_length",
            "        ):",
            "            self._must_raise = RequestEntityTooLarge()",
            "            self.set_complete()",
            "",
            "    def set_complete(self) -> None:",
            "        self._complete.set()",
            "        self._has_data.set()",
            "",
            "    def set_result(self, data: bytes) -> None:",
            "        \"\"\"Convenience method, mainly for testing.\"\"\"",
            "        self.append(data)",
            "        self.set_complete()",
            "",
            "    def clear(self) -> None:",
            "        self._data.clear()",
            "",
            "",
            "class Request(BaseRequestWebsocket):",
            "    \"\"\"This class represents a request.",
            "",
            "    It can be subclassed and the subclassed used in preference by",
            "    replacing the :attr:`~quart.Quart.request_class` with your",
            "    subclass.",
            "",
            "    Attributes:",
            "        body_class: The class to store the body data within.",
            "        form_data_parser_class: Can be overridden to implement a",
            "            different form data parsing.",
            "    \"\"\"",
            "",
            "    body_class = Body",
            "    form_data_parser_class = FormDataParser",
            "    lock_class = asyncio.Lock",
            "    _max_content_length: int | None = None",
            "    _max_form_memory_size: int | None = None",
            "    _max_form_parts: int | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        method: str,",
            "        scheme: str,",
            "        path: str,",
            "        query_string: bytes,",
            "        headers: Headers,",
            "        root_path: str,",
            "        http_version: str,",
            "        scope: HTTPScope,",
            "        *,",
            "        max_content_length: int | None = None,",
            "        body_timeout: int | None = None,",
            "        send_push_promise: Callable[[str, Headers], Awaitable[None]],",
            "    ) -> None:",
            "        \"\"\"Create a request object.",
            "",
            "        Arguments:",
            "            method: The HTTP verb.",
            "            scheme: The scheme used for the request.",
            "            path: The full unquoted path of the request.",
            "            query_string: The raw bytes for the query string part.",
            "            headers: The request headers.",
            "            root_path: The root path that should be prepended to all",
            "                routes.",
            "            http_version: The HTTP version of the request.",
            "            body: An awaitable future for the body data i.e.",
            "                ``data = await body``",
            "            max_content_length: The maximum length in bytes of the",
            "                body (None implies no limit in Quart).",
            "            body_timeout: The maximum time (seconds) to wait for the",
            "                body before timing out.",
            "            send_push_promise: An awaitable to send a push promise based",
            "                off of this request (HTTP/2 feature).",
            "            scope: Underlying ASGI scope dictionary.",
            "        \"\"\"",
            "        super().__init__(",
            "            method, scheme, path, query_string, headers, root_path, http_version, scope",
            "        )",
            "        self.body_timeout = body_timeout",
            "        self.body = self.body_class(self.content_length, max_content_length)",
            "        self._cached_json: dict[bool, Any] = {False: Ellipsis, True: Ellipsis}",
            "        self._form: MultiDict | None = None",
            "        self._files: MultiDict | None = None",
            "        self._parsing_lock = self.lock_class()",
            "        self._send_push_promise = send_push_promise",
            "",
            "    @property",
            "    def max_content_length(self) -> int | None:",
            "        if self._max_content_length is not None:",
            "            return self._max_content_length",
            "",
            "        if current_app:",
            "            return current_app.config[\"MAX_CONTENT_LENGTH\"]",
            "",
            "        return None",
            "",
            "    @max_content_length.setter",
            "    def max_content_length(self, value: int | None) -> None:",
            "        self._max_content_length = value",
            "",
            "    @property",
            "    def max_form_memory_size(self) -> int | None:",
            "        if self._max_form_memory_size is not None:",
            "            return self._max_form_memory_size",
            "",
            "        if current_app:",
            "            return current_app.config[\"MAX_FORM_MEMORY_SIZE\"]",
            "",
            "        return None",
            "",
            "    @max_form_memory_size.setter",
            "    def max_form_memory_size(self, value: int | None) -> None:",
            "        self._max_form_memory_size = value",
            "",
            "    @property",
            "    def max_form_parts(self) -> int | None:",
            "        if self._max_form_parts is not None:",
            "            return self._max_form_parts",
            "",
            "        if current_app:",
            "            return current_app.config[\"MAX_FORM_PARTS\"]",
            "",
            "        return None",
            "",
            "    @max_form_parts.setter",
            "    def max_form_parts(self, value: int | None) -> None:",
            "        self._max_form_parts = value",
            "",
            "    @property",
            "    async def stream(self) -> NoReturn:",
            "        raise NotImplementedError(\"Use body instead\")",
            "",
            "    @property",
            "    async def data(self) -> bytes:",
            "        return await self.get_data(as_text=False, parse_form_data=True)  # type: ignore",
            "",
            "    @overload",
            "    async def get_data(",
            "        self, cache: bool, as_text: Literal[False], parse_form_data: bool",
            "    ) -> bytes: ...",
            "",
            "    @overload",
            "    async def get_data(",
            "        self, cache: bool, as_text: Literal[True], parse_form_data: bool",
            "    ) -> str: ...",
            "",
            "    @overload",
            "    async def get_data(",
            "        self, cache: bool = True, as_text: bool = False, parse_form_data: bool = False",
            "    ) -> str | bytes: ...",
            "",
            "    async def get_data(",
            "        self, cache: bool = True, as_text: bool = False, parse_form_data: bool = False",
            "    ) -> str | bytes:",
            "        \"\"\"Get the request body data.",
            "",
            "        Arguments:",
            "            cache: If False the body data will be cleared, resulting in any",
            "                subsequent calls returning an empty str | bytes and reducing",
            "                memory usage.",
            "            as_text: If True the data is returned as a decoded string,",
            "                otherwise raw bytes are returned.",
            "            parse_form_data: Parse the data as form data first, return any",
            "                remaining data.",
            "        \"\"\"",
            "        if parse_form_data:",
            "            await self._load_form_data()",
            "",
            "        try:",
            "            raw_data = await asyncio.wait_for(self.body, timeout=self.body_timeout)",
            "        except asyncio.TimeoutError as e:",
            "            raise RequestTimeout() from e",
            "        else:",
            "            if not cache:",
            "                self.body.clear()",
            "",
            "            if as_text:",
            "                return raw_data.decode()",
            "            else:",
            "                return raw_data",
            "",
            "    @property",
            "    async def values(self) -> CombinedMultiDict:",
            "        sources = [self.args]",
            "        if self.method != \"GET\":",
            "            # Whilst GET requests are allowed to have a body, most",
            "            # implementations do not allow this hence this",
            "            # inconsistency may result in confusing values.",
            "            form = await self.form",
            "            sources.append(form)",
            "",
            "        multidict_sources: list[MultiDict] = []",
            "        for source in sources:",
            "            if not isinstance(source, MultiDict):",
            "                multidict_sources.append(MultiDict(source))",
            "            else:",
            "                multidict_sources.append(source)",
            "",
            "        return CombinedMultiDict(multidict_sources)",
            "",
            "    @property",
            "    async def form(self) -> MultiDict:",
            "        \"\"\"The parsed form encoded data.",
            "",
            "        Note file data is present in the :attr:`files`.",
            "        \"\"\"",
            "        await self._load_form_data()",
            "        return self._form",
            "",
            "    @property",
            "    async def files(self) -> MultiDict:",
            "        \"\"\"The parsed files.",
            "",
            "        This will return an empty multidict unless the request",
            "        mimetype was ``enctype=\"multipart/form-data\"`` and the method",
            "        POST, PUT, or PATCH.",
            "        \"\"\"",
            "        await self._load_form_data()",
            "        return self._files",
            "",
            "    def make_form_data_parser(self) -> FormDataParser:",
            "        return self.form_data_parser_class(",
            "            max_content_length=self.max_content_length,",
            "            max_form_memory_size=self.max_form_memory_size,",
            "            max_form_parts=self.max_form_parts,",
            "            cls=self.parameter_storage_class,",
            "        )",
            "",
            "    async def _load_form_data(self) -> None:",
            "        async with self._parsing_lock:",
            "            if self._form is None:",
            "                parser = self.make_form_data_parser()",
            "                try:",
            "                    self._form, self._files = await asyncio.wait_for(",
            "                        parser.parse(",
            "                            self.body,",
            "                            self.mimetype,",
            "                            self.content_length,",
            "                            self.mimetype_params,",
            "                        ),",
            "                        timeout=self.body_timeout,",
            "                    )",
            "                except asyncio.TimeoutError as e:",
            "                    raise RequestTimeout() from e",
            "",
            "    @property",
            "    async def json(self) -> Any:",
            "        return await self.get_json()",
            "",
            "    async def get_json(",
            "        self, force: bool = False, silent: bool = False, cache: bool = True",
            "    ) -> Any:",
            "        \"\"\"Parses the body data as JSON and returns it.",
            "",
            "        Arguments:",
            "            force: Force JSON parsing even if the mimetype is not JSON.",
            "            silent: Do not trigger error handling if parsing fails, without",
            "                this the :meth:`on_json_loading_failed` will be called on",
            "                error.",
            "            cache: Cache the parsed JSON on this request object.",
            "        \"\"\"",
            "        if cache and self._cached_json[silent] is not Ellipsis:",
            "            return self._cached_json[silent]",
            "",
            "        if not (force or self.is_json):",
            "            return None",
            "",
            "        data = await self.get_data(cache=cache, as_text=True)",
            "",
            "        try:",
            "            result = self.json_module.loads(data)",
            "        except ValueError as error:",
            "            if silent:",
            "                result = None",
            "            else:",
            "                result = self.on_json_loading_failed(error)",
            "",
            "        if cache:",
            "            self._cached_json[silent] = result",
            "",
            "        return result",
            "",
            "    def on_json_loading_failed(self, error: Exception) -> Any:",
            "        \"\"\"Handle a JSON parsing error.",
            "",
            "        Arguments:",
            "            error: The exception raised during parsing.",
            "        Returns:",
            "            Any value returned (if overridden) will be used as the",
            "            default for any get_json calls.",
            "        \"\"\"",
            "        if current_app and current_app.debug:",
            "            raise BadRequest(f\"Failed to decode JSON: {error}\")",
            "",
            "        raise BadRequest()",
            "",
            "    async def send_push_promise(self, path: str) -> None:",
            "        headers = Headers()",
            "        for name in SERVER_PUSH_HEADERS_TO_COPY:",
            "            for value in self.headers.getlist(name):",
            "                headers.add(name, value)",
            "        await self._send_push_promise(path, headers)",
            "",
            "    async def close(self) -> None:",
            "        for _key, value in iter_multi_items(self._files or ()):",
            "            value.close()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.quart.wrappers.request.Request._load_form_data",
            "src.quart.wrappers.request.Request.self",
            "aiohttp.client_reqrep"
        ]
    }
}