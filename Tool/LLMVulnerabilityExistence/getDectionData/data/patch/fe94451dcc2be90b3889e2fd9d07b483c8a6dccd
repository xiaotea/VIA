{
    "src/pyload/webui/app/blueprints/app_blueprint.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " def login():"
            },
            "1": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     api = flask.current_app.config[\"PYLOAD_API\"]"
            },
            "2": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    next = get_redirect_url(fallback=flask.url_for(\"app.dashboard\"))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    next_url = get_redirect_url(fallback=\"app.dashboard\")"
            },
            "5": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     if flask.request.method == \"POST\":"
            },
            "7": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         user = flask.request.form[\"username\"]"
            },
            "8": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")"
            },
            "9": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         if not user_info:"
            },
            "10": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             log.error(f\"Login failed for user '{sanitized_user}'\")"
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return render_template(\"login.html\", next=next, errors=True)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+            return render_template(\"login.html\", errors=True)"
            },
            "13": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         set_session(user_info)"
            },
            "15": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         log.info(f\"User '{sanitized_user}' successfully logged in\")"
            },
            "16": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         flask.flash(\"Logged in successfully\")"
            },
            "17": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     if is_authenticated():"
            },
            "19": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return flask.redirect(next)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        return flask.redirect(next_url)"
            },
            "21": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     if api.get_config_value(\"webui\", \"autologin\"):"
            },
            "23": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         allusers = api.get_all_userdata()"
            },
            "24": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             # NOTE: Double-check authentication here because if session[name] is empty,"
            },
            "25": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "             #       next login_required redirects here again and all loop out."
            },
            "26": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             if is_authenticated():"
            },
            "27": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return flask.redirect(next)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                return flask.redirect(next_url)"
            },
            "29": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return render_template(\"login.html\", next=next)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    return render_template(\"login.html\")"
            },
            "32": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " @bp.route(\"/logout\", endpoint=\"logout\")"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import datetime",
            "import mimetypes",
            "import operator",
            "import os",
            "import re",
            "import sys",
            "import time",
            "from logging import getLogger",
            "from urllib.parse import unquote",
            "",
            "import flask",
            "from pyload import APPID, PKGDIR",
            "from pyload.core.utils import format",
            "",
            "from ..helpers import (",
            "    clear_session, get_permission, get_redirect_url, is_authenticated, login_required, permlist, render_base,",
            "    render_template, set_session, static_file_url)",
            "",
            "_RE_LOGLINE = re.compile(r\"\\[([\\d\\-]+) ([\\d:]+)\\] +([A-Z]+) +(.+?) (.*)\")",
            "",
            "bp = flask.Blueprint(\"app\", __name__)",
            "log = getLogger(APPID)",
            "",
            "",
            "@bp.route(\"/favicon.ico\", endpoint=\"favicon\")",
            "def favicon():",
            "    location = static_file_url(\"img/favicon.ico\")",
            "    return flask.redirect(location)",
            "",
            "",
            "@bp.route(\"/render/<path:filename>\", endpoint=\"render\")",
            "def render(filename):",
            "    mimetype = mimetypes.guess_type(filename)[0] or \"text/html\"",
            "    data = render_template(filename)",
            "    return flask.Response(data, mimetype=mimetype)",
            "",
            "",
            "@bp.route(\"/robots.txt\", endpoint=\"robots\")",
            "def robots():",
            "    return \"User-agent: *\\nDisallow: /\"",
            "",
            "",
            "# TODO: Rewrite login route using flask-login",
            "@bp.route(\"/login\", methods=[\"GET\", \"POST\"], endpoint=\"login\")",
            "def login():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    next = get_redirect_url(fallback=flask.url_for(\"app.dashboard\"))",
            "",
            "    if flask.request.method == \"POST\":",
            "        user = flask.request.form[\"username\"]",
            "        password = flask.request.form[\"password\"]",
            "        user_info = api.check_auth(user, password)",
            "",
            "        sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")",
            "        if not user_info:",
            "            log.error(f\"Login failed for user '{sanitized_user}'\")",
            "            return render_template(\"login.html\", next=next, errors=True)",
            "",
            "        set_session(user_info)",
            "        log.info(f\"User '{sanitized_user}' successfully logged in\")",
            "        flask.flash(\"Logged in successfully\")",
            "",
            "    if is_authenticated():",
            "        return flask.redirect(next)",
            "",
            "    if api.get_config_value(\"webui\", \"autologin\"):",
            "        allusers = api.get_all_userdata()",
            "        if len(allusers) == 1:  # TODO: check if localhost",
            "            user_info = list(allusers.values())[0]",
            "            set_session(user_info)",
            "            # NOTE: Double-check authentication here because if session[name] is empty,",
            "            #       next login_required redirects here again and all loop out.",
            "            if is_authenticated():",
            "                return flask.redirect(next)",
            "",
            "    return render_template(\"login.html\", next=next)",
            "",
            "",
            "@bp.route(\"/logout\", endpoint=\"logout\")",
            "def logout():",
            "    s = flask.session",
            "    user = s.get(\"name\")",
            "    clear_session(s)",
            "    if user:",
            "        log.info(f\"User '{user}' logged out\")",
            "    return render_template(\"logout.html\")",
            "",
            "",
            "@bp.route(\"/\", endpoint=\"index\")",
            "@bp.route(\"/home\", endpoint=\"home\")",
            "@bp.route(\"/dashboard\", endpoint=\"dashboard\")",
            "@login_required(\"LIST\")",
            "def dashboard():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    links = api.status_downloads()",
            "",
            "    for link in links:",
            "        if link[\"status\"] == 12:",
            "            current_size = link[\"size\"] - link[\"bleft\"]",
            "            formatted_speed = format.speed(link[\"speed\"])",
            "            link[\"info\"] = f\"{current_size} KiB @ {formatted_speed}\"",
            "",
            "    return render_template(\"dashboard.html\", res=links)",
            "",
            "",
            "@bp.route(\"/queue\", endpoint=\"queue\")",
            "@login_required(\"LIST\")",
            "def queue():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    queue = api.get_queue()",
            "    queue.sort(key=operator.attrgetter(\"order\"))",
            "",
            "    return render_template(\"packages.html\", content=queue, target=1)",
            "",
            "",
            "@bp.route(\"/collector\", endpoint=\"collector\")",
            "@login_required(\"LIST\")",
            "def collector():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    queue = api.get_collector()",
            "",
            "    queue.sort(key=operator.attrgetter(\"order\"))",
            "",
            "    return render_template(\"packages.html\", content=queue, target=0)",
            "",
            "",
            "@bp.route(\"/files\", endpoint=\"files\")",
            "@login_required(\"DOWNLOAD\")",
            "def files():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    root = api.get_config_value(\"general\", \"storage_folder\")",
            "",
            "    if not os.path.isdir(root):",
            "        messages = [\"Download directory not found.\"]",
            "        return render_base(messages)",
            "    data = {\"folder\": [], \"files\": []}",
            "",
            "    for entry in sorted(os.listdir(root)):",
            "        if os.path.isdir(os.path.join(root, entry)):",
            "            folder = {\"name\": entry, \"path\": entry, \"files\": []}",
            "            files = os.listdir(os.path.join(root, entry))",
            "            for file in sorted(files):",
            "                try:",
            "                    if os.path.isfile(os.path.join(root, entry, file)):",
            "                        folder[\"files\"].append(file)",
            "                except Exception:",
            "                    pass",
            "",
            "            data[\"folder\"].append(folder)",
            "",
            "        elif os.path.isfile(os.path.join(root, entry)):",
            "            data[\"files\"].append(entry)",
            "",
            "    return render_template(\"files.html\", files=data)",
            "",
            "",
            "@bp.route(\"/files/get/<path:path>\", endpoint=\"get_file\")",
            "@login_required(\"DOWNLOAD\")",
            "def get_file(path):",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    path = unquote(path).replace(\"..\", \"\")",
            "    directory = api.get_config_value(\"general\", \"storage_folder\")",
            "    return flask.send_from_directory(directory, path, as_attachment=True)",
            "",
            "",
            "@bp.route(\"/settings\", endpoint=\"settings\")",
            "@login_required(\"SETTINGS\")",
            "def settings():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    conf = api.get_config()",
            "    plugin = api.get_plugin_config()",
            "",
            "    conf_menu = []",
            "    plugin_menu = []",
            "",
            "    for entry in sorted(conf.keys()):",
            "        conf_menu.append((entry, conf[entry].description))",
            "",
            "    for entry in sorted(plugin.keys()):",
            "        plugin_menu.append((entry, plugin[entry].description))",
            "",
            "    accs = []",
            "",
            "    for userdata in api.get_accounts(False):",
            "        if userdata.trafficleft is None:",
            "            trafficleft = \"not available\"",
            "        elif userdata.trafficleft == -1:",
            "            trafficleft = \"unlimited\"",
            "        elif userdata.trafficleft == 0:",
            "            trafficleft = \"drained\"",
            "        else:",
            "            trafficleft = format.size(userdata.trafficleft)",
            "",
            "        if userdata.validuntil == -1:",
            "            validuntil = \"unlimited\"",
            "        elif not userdata.validuntil:",
            "            validuntil = \"not available\"",
            "        else:",
            "            t = time.localtime(userdata.validuntil)",
            "            validuntil = time.strftime(\"%d.%m.%Y\", t)",
            "",
            "        if \"time\" in userdata.options:",
            "            try:",
            "                _time = userdata.options[\"time\"][0]",
            "            except Exception:",
            "                _time = \"\"",
            "        else:",
            "            _time = \"\"",
            "",
            "        if \"limit_dl\" in userdata.options:",
            "            try:",
            "                limitdl = userdata.options[\"limit_dl\"][0]",
            "            except Exception:",
            "                limitdl = \"0\"",
            "        else:",
            "            limitdl = \"0\"",
            "",
            "        accs.append(",
            "            {",
            "                \"type\": userdata.type,",
            "                \"login\": userdata.login,",
            "                \"valid\": userdata.valid,",
            "                \"premium\": userdata.premium,",
            "                \"trafficleft\": trafficleft,",
            "                \"validuntil\": validuntil,",
            "                \"limitdl\": limitdl,",
            "                \"time\": _time,",
            "            }",
            "        )",
            "",
            "    all_users = api.get_all_userdata()",
            "    users = {}",
            "    for userdata in all_users.values():",
            "        name = userdata[\"name\"]",
            "        users[name] = {\"perms\": get_permission(userdata[\"permission\"])}",
            "        users[name][\"perms\"][\"admin\"] = userdata[\"role\"] == 0",
            "",
            "    admin_menu = {",
            "        \"permlist\": permlist(),",
            "        \"users\": users",
            "    }",
            "",
            "    context = {",
            "        \"conf\": {\"plugin\": plugin_menu, \"general\": conf_menu, \"accs\": accs, \"admin\": admin_menu},",
            "        \"types\": api.get_account_types(),",
            "    }",
            "    return render_template(\"settings.html\", **context)",
            "",
            "",
            "@bp.route(\"/pathchooser/\", endpoint=\"pathchooser\")",
            "@bp.route(\"/filechooser/\", endpoint=\"filechooser\")",
            "@login_required(\"SETTINGS\")",
            "def pathchooser():",
            "    browse_for = \"folder\" if flask.request.endpoint == \"app.pathchooser\" else \"file\"",
            "    path = os.path.normpath(flask.request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        oldfile = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        oldfile = \"\"",
            "",
            "    abs = False",
            "",
            "    if os.path.isdir(path):",
            "        if os.path.isabs(path):",
            "            cwd = os.path.realpath(path)",
            "            abs = True",
            "        else:",
            "            cwd = os.path.relpath(path)",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parentdir = os.path.dirname(cwd)",
            "    if not abs:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parentdir = os.path.relpath(parentdir) + os.path.sep",
            "",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "        parentdir = \"\"",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    files = []",
            "",
            "    for f in folders:",
            "        try:",
            "            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "            data[\"modified\"] = datetime.datetime.fromtimestamp(",
            "                int(os.path.getmtime(os.path.join(cwd, f)))",
            "            )",
            "            data[\"ext\"] = os.path.splitext(f)[1]",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"unit\"] = units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parentdir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": oldfile,",
            "        \"absolute\": abs,",
            "    }",
            "    return render_template(\"pathchooser.html\", **context)",
            "",
            "",
            "@bp.route(\"/logs\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")",
            "@bp.route(\"/logs/<int:start_line>\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")",
            "@login_required(\"LOGS\")",
            "def logs(start_line=-1):",
            "    s = flask.session",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    per_page = s.get(\"perpage\", 34)",
            "    reversed = s.get(\"reversed\", False)",
            "",
            "    warning = \"\"",
            "    conf = api.get_config_value(\"log\", \"filelog\")",
            "    if not conf:",
            "        warning = \"Warning: File log is disabled, see settings page.\"",
            "",
            "    per_page_selection = ((20, 20), (34, 34), (40, 40), (100, 100), (0, \"all\"))",
            "    fro = None",
            "",
            "    if flask.request.method == \"POST\":",
            "        try:",
            "            from_form = flask.request.form[\"from\"]",
            "            fro = datetime.datetime.strptime(from_form, \"%Y-%m-%d %H:%M:%S\")",
            "        except Exception:",
            "            pass",
            "",
            "        per_page = int(flask.request.form.get(\"perpage\", 34))",
            "        s[\"perpage\"] = per_page",
            "",
            "        reversed = bool(flask.request.form.get(\"reversed\", False))",
            "        s[\"reversed\"] = reversed",
            "",
            "        # s.modified = True",
            "",
            "    log_entries = api.get_log()",
            "    if not per_page:",
            "        start_line = 0",
            "",
            "    if start_line < 1:",
            "        start_line = (",
            "            1 if len(log_entries) - per_page + 1 < 1 or per_page == 0 else len(log_entries) - per_page + 1",
            "        )",
            "",
            "    if isinstance(fro, datetime.datetime):  #: we will search for datetime.datetime",
            "        start_line = -1",
            "",
            "    data = []",
            "    inpage_counter = 0",
            "    for counter, logline in enumerate(log_entries, start=1):",
            "        if counter >= start_line:",
            "            try:",
            "                date, time, level, source, message = _RE_LOGLINE.match(logline).groups()",
            "                dtime = datetime.datetime.strptime(",
            "                    date + \" \" + time, \"%Y-%m-%d %H:%M:%S\"",
            "                )",
            "                message = message.strip()",
            "            except (AttributeError, IndexError):",
            "                dtime = None",
            "                date = \"?\"",
            "                time = \" \"",
            "                level = \"?\"",
            "                source = \"?\"",
            "                message = logline",
            "            if start_line == -1 and dtime is not None and fro <= dtime:",
            "                start_line = counter  #: found our datetime.datetime",
            "",
            "            if start_line >= 0:",
            "                data.append(",
            "                    {",
            "                        \"line\": counter,",
            "                        \"date\": date + \" \" + time,",
            "                        \"level\": level,",
            "                        \"source\": source,",
            "                        \"message\": message.rstrip('\\n'),",
            "                    }",
            "                )",
            "                inpage_counter += 1",
            "                if (",
            "                    fro is None and dtime is not None",
            "                ):  #: if fro not set, set it to first showed line",
            "                    fro = dtime",
            "            if inpage_counter >= per_page > 0:",
            "                break",
            "",
            "    if fro is None:  #: still not set, empty log?",
            "        fro = datetime.datetime.now()",
            "",
            "    if reversed:",
            "        data.reverse()",
            "",
            "    context = {",
            "        \"warning\": warning,",
            "        \"log\": data,",
            "        \"from\": fro.strftime(\"%Y-%m-%d %H:%M:%S\"),",
            "        \"reversed\": reversed,",
            "        \"perpage\": per_page,",
            "        \"perpage_p\": sorted(per_page_selection),",
            "        \"iprev\": max(start_line - per_page, 1),",
            "        \"inext\": (start_line + per_page) if start_line + per_page <= len(log_entries) else start_line,",
            "    }",
            "    return render_template(\"logs.html\", **context)",
            "",
            "",
            "@bp.route(\"/filemanager\", endpoint=\"filemanager\")",
            "@login_required(\"MODIFY\")",
            "def filemanager(path):",
            "    return render_template(\"filemanager.html\")",
            "",
            "",
            "@bp.route(\"/info\", endpoint=\"info\")",
            "@login_required(\"STATUS\")",
            "def info():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    conf = api.get_config_dict()",
            "    extra = os.uname() if hasattr(os, \"uname\") else tuple()",
            "",
            "    context = {",
            "        \"python\": sys.version,",
            "        \"os\": \" \".join((os.name, sys.platform) + extra),",
            "        \"version\": api.get_server_version(),",
            "        \"folder\": PKGDIR,",
            "        \"config_folder\": api.get_userdir(),",
            "        \"download\": conf[\"general\"][\"storage_folder\"][\"value\"],",
            "        \"freespace\": format.size(api.free_space()),",
            "        \"webif\": conf[\"webui\"][\"port\"][\"value\"],",
            "        \"language\": conf[\"general\"][\"language\"][\"value\"],",
            "    }",
            "    return render_template(\"info.html\", **context)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import datetime",
            "import mimetypes",
            "import operator",
            "import os",
            "import re",
            "import sys",
            "import time",
            "from logging import getLogger",
            "from urllib.parse import unquote",
            "",
            "import flask",
            "from pyload import APPID, PKGDIR",
            "from pyload.core.utils import format",
            "",
            "from ..helpers import (",
            "    clear_session, get_permission, get_redirect_url, is_authenticated, login_required, permlist, render_base,",
            "    render_template, set_session, static_file_url)",
            "",
            "_RE_LOGLINE = re.compile(r\"\\[([\\d\\-]+) ([\\d:]+)\\] +([A-Z]+) +(.+?) (.*)\")",
            "",
            "bp = flask.Blueprint(\"app\", __name__)",
            "log = getLogger(APPID)",
            "",
            "",
            "@bp.route(\"/favicon.ico\", endpoint=\"favicon\")",
            "def favicon():",
            "    location = static_file_url(\"img/favicon.ico\")",
            "    return flask.redirect(location)",
            "",
            "",
            "@bp.route(\"/render/<path:filename>\", endpoint=\"render\")",
            "def render(filename):",
            "    mimetype = mimetypes.guess_type(filename)[0] or \"text/html\"",
            "    data = render_template(filename)",
            "    return flask.Response(data, mimetype=mimetype)",
            "",
            "",
            "@bp.route(\"/robots.txt\", endpoint=\"robots\")",
            "def robots():",
            "    return \"User-agent: *\\nDisallow: /\"",
            "",
            "",
            "# TODO: Rewrite login route using flask-login",
            "@bp.route(\"/login\", methods=[\"GET\", \"POST\"], endpoint=\"login\")",
            "def login():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    next_url = get_redirect_url(fallback=\"app.dashboard\")",
            "",
            "    if flask.request.method == \"POST\":",
            "        user = flask.request.form[\"username\"]",
            "        password = flask.request.form[\"password\"]",
            "        user_info = api.check_auth(user, password)",
            "",
            "        sanitized_user = user.replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\")",
            "        if not user_info:",
            "            log.error(f\"Login failed for user '{sanitized_user}'\")",
            "            return render_template(\"login.html\", errors=True)",
            "",
            "        set_session(user_info)",
            "        log.info(f\"User '{sanitized_user}' successfully logged in\")",
            "        flask.flash(\"Logged in successfully\")",
            "",
            "    if is_authenticated():",
            "        return flask.redirect(next_url)",
            "",
            "    if api.get_config_value(\"webui\", \"autologin\"):",
            "        allusers = api.get_all_userdata()",
            "        if len(allusers) == 1:  # TODO: check if localhost",
            "            user_info = list(allusers.values())[0]",
            "            set_session(user_info)",
            "            # NOTE: Double-check authentication here because if session[name] is empty,",
            "            #       next login_required redirects here again and all loop out.",
            "            if is_authenticated():",
            "                return flask.redirect(next_url)",
            "",
            "    return render_template(\"login.html\")",
            "",
            "",
            "@bp.route(\"/logout\", endpoint=\"logout\")",
            "def logout():",
            "    s = flask.session",
            "    user = s.get(\"name\")",
            "    clear_session(s)",
            "    if user:",
            "        log.info(f\"User '{user}' logged out\")",
            "    return render_template(\"logout.html\")",
            "",
            "",
            "@bp.route(\"/\", endpoint=\"index\")",
            "@bp.route(\"/home\", endpoint=\"home\")",
            "@bp.route(\"/dashboard\", endpoint=\"dashboard\")",
            "@login_required(\"LIST\")",
            "def dashboard():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    links = api.status_downloads()",
            "",
            "    for link in links:",
            "        if link[\"status\"] == 12:",
            "            current_size = link[\"size\"] - link[\"bleft\"]",
            "            formatted_speed = format.speed(link[\"speed\"])",
            "            link[\"info\"] = f\"{current_size} KiB @ {formatted_speed}\"",
            "",
            "    return render_template(\"dashboard.html\", res=links)",
            "",
            "",
            "@bp.route(\"/queue\", endpoint=\"queue\")",
            "@login_required(\"LIST\")",
            "def queue():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    queue = api.get_queue()",
            "    queue.sort(key=operator.attrgetter(\"order\"))",
            "",
            "    return render_template(\"packages.html\", content=queue, target=1)",
            "",
            "",
            "@bp.route(\"/collector\", endpoint=\"collector\")",
            "@login_required(\"LIST\")",
            "def collector():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    queue = api.get_collector()",
            "",
            "    queue.sort(key=operator.attrgetter(\"order\"))",
            "",
            "    return render_template(\"packages.html\", content=queue, target=0)",
            "",
            "",
            "@bp.route(\"/files\", endpoint=\"files\")",
            "@login_required(\"DOWNLOAD\")",
            "def files():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    root = api.get_config_value(\"general\", \"storage_folder\")",
            "",
            "    if not os.path.isdir(root):",
            "        messages = [\"Download directory not found.\"]",
            "        return render_base(messages)",
            "    data = {\"folder\": [], \"files\": []}",
            "",
            "    for entry in sorted(os.listdir(root)):",
            "        if os.path.isdir(os.path.join(root, entry)):",
            "            folder = {\"name\": entry, \"path\": entry, \"files\": []}",
            "            files = os.listdir(os.path.join(root, entry))",
            "            for file in sorted(files):",
            "                try:",
            "                    if os.path.isfile(os.path.join(root, entry, file)):",
            "                        folder[\"files\"].append(file)",
            "                except Exception:",
            "                    pass",
            "",
            "            data[\"folder\"].append(folder)",
            "",
            "        elif os.path.isfile(os.path.join(root, entry)):",
            "            data[\"files\"].append(entry)",
            "",
            "    return render_template(\"files.html\", files=data)",
            "",
            "",
            "@bp.route(\"/files/get/<path:path>\", endpoint=\"get_file\")",
            "@login_required(\"DOWNLOAD\")",
            "def get_file(path):",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    path = unquote(path).replace(\"..\", \"\")",
            "    directory = api.get_config_value(\"general\", \"storage_folder\")",
            "    return flask.send_from_directory(directory, path, as_attachment=True)",
            "",
            "",
            "@bp.route(\"/settings\", endpoint=\"settings\")",
            "@login_required(\"SETTINGS\")",
            "def settings():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    conf = api.get_config()",
            "    plugin = api.get_plugin_config()",
            "",
            "    conf_menu = []",
            "    plugin_menu = []",
            "",
            "    for entry in sorted(conf.keys()):",
            "        conf_menu.append((entry, conf[entry].description))",
            "",
            "    for entry in sorted(plugin.keys()):",
            "        plugin_menu.append((entry, plugin[entry].description))",
            "",
            "    accs = []",
            "",
            "    for userdata in api.get_accounts(False):",
            "        if userdata.trafficleft is None:",
            "            trafficleft = \"not available\"",
            "        elif userdata.trafficleft == -1:",
            "            trafficleft = \"unlimited\"",
            "        elif userdata.trafficleft == 0:",
            "            trafficleft = \"drained\"",
            "        else:",
            "            trafficleft = format.size(userdata.trafficleft)",
            "",
            "        if userdata.validuntil == -1:",
            "            validuntil = \"unlimited\"",
            "        elif not userdata.validuntil:",
            "            validuntil = \"not available\"",
            "        else:",
            "            t = time.localtime(userdata.validuntil)",
            "            validuntil = time.strftime(\"%d.%m.%Y\", t)",
            "",
            "        if \"time\" in userdata.options:",
            "            try:",
            "                _time = userdata.options[\"time\"][0]",
            "            except Exception:",
            "                _time = \"\"",
            "        else:",
            "            _time = \"\"",
            "",
            "        if \"limit_dl\" in userdata.options:",
            "            try:",
            "                limitdl = userdata.options[\"limit_dl\"][0]",
            "            except Exception:",
            "                limitdl = \"0\"",
            "        else:",
            "            limitdl = \"0\"",
            "",
            "        accs.append(",
            "            {",
            "                \"type\": userdata.type,",
            "                \"login\": userdata.login,",
            "                \"valid\": userdata.valid,",
            "                \"premium\": userdata.premium,",
            "                \"trafficleft\": trafficleft,",
            "                \"validuntil\": validuntil,",
            "                \"limitdl\": limitdl,",
            "                \"time\": _time,",
            "            }",
            "        )",
            "",
            "    all_users = api.get_all_userdata()",
            "    users = {}",
            "    for userdata in all_users.values():",
            "        name = userdata[\"name\"]",
            "        users[name] = {\"perms\": get_permission(userdata[\"permission\"])}",
            "        users[name][\"perms\"][\"admin\"] = userdata[\"role\"] == 0",
            "",
            "    admin_menu = {",
            "        \"permlist\": permlist(),",
            "        \"users\": users",
            "    }",
            "",
            "    context = {",
            "        \"conf\": {\"plugin\": plugin_menu, \"general\": conf_menu, \"accs\": accs, \"admin\": admin_menu},",
            "        \"types\": api.get_account_types(),",
            "    }",
            "    return render_template(\"settings.html\", **context)",
            "",
            "",
            "@bp.route(\"/pathchooser/\", endpoint=\"pathchooser\")",
            "@bp.route(\"/filechooser/\", endpoint=\"filechooser\")",
            "@login_required(\"SETTINGS\")",
            "def pathchooser():",
            "    browse_for = \"folder\" if flask.request.endpoint == \"app.pathchooser\" else \"file\"",
            "    path = os.path.normpath(flask.request.args.get('path', \"\"))",
            "",
            "    if os.path.isfile(path):",
            "        oldfile = path",
            "        path = os.path.dirname(path)",
            "    else:",
            "        oldfile = \"\"",
            "",
            "    abs = False",
            "",
            "    if os.path.isdir(path):",
            "        if os.path.isabs(path):",
            "            cwd = os.path.realpath(path)",
            "            abs = True",
            "        else:",
            "            cwd = os.path.relpath(path)",
            "    else:",
            "        cwd = os.getcwd()",
            "",
            "    cwd = os.path.normpath(os.path.realpath(cwd))",
            "    parentdir = os.path.dirname(cwd)",
            "    if not abs:",
            "        if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "            cwd = os.path.relpath(cwd)",
            "        else:",
            "            cwd = os.path.relpath(cwd) + os.path.sep",
            "        parentdir = os.path.relpath(parentdir) + os.path.sep",
            "",
            "    if os.path.realpath(cwd) == os.path.realpath(\"/\"):",
            "        parentdir = \"\"",
            "",
            "    try:",
            "        folders = os.listdir(cwd)",
            "    except Exception:",
            "        folders = []",
            "",
            "    files = []",
            "",
            "    for f in folders:",
            "        try:",
            "            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}",
            "            data[\"sort\"] = data[\"fullpath\"].lower()",
            "            data[\"modified\"] = datetime.datetime.fromtimestamp(",
            "                int(os.path.getmtime(os.path.join(cwd, f)))",
            "            )",
            "            data[\"ext\"] = os.path.splitext(f)[1]",
            "        except Exception:",
            "            continue",
            "",
            "        if os.path.isfile(os.path.join(cwd, f)):",
            "            data[\"type\"] = \"file\"",
            "            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))",
            "",
            "            power = 0",
            "            while (data[\"size\"] >> 10) > 0.3:",
            "                power += 1",
            "                data[\"size\"] >>= 10",
            "            units = (\"\", \"K\", \"M\", \"G\", \"T\")",
            "            data[\"unit\"] = units[power] + \"Byte\"",
            "        else:",
            "            data[\"type\"] = \"dir\"",
            "            data[\"size\"] = \"\"",
            "",
            "        files.append(data)",
            "",
            "    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))",
            "",
            "    context = {",
            "        \"cwd\": cwd,",
            "        \"files\": files,",
            "        \"parentdir\": parentdir,",
            "        \"type\": browse_for,",
            "        \"oldfile\": oldfile,",
            "        \"absolute\": abs,",
            "    }",
            "    return render_template(\"pathchooser.html\", **context)",
            "",
            "",
            "@bp.route(\"/logs\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")",
            "@bp.route(\"/logs/<int:start_line>\", methods=[\"GET\", \"POST\"], endpoint=\"logs\")",
            "@login_required(\"LOGS\")",
            "def logs(start_line=-1):",
            "    s = flask.session",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "",
            "    per_page = s.get(\"perpage\", 34)",
            "    reversed = s.get(\"reversed\", False)",
            "",
            "    warning = \"\"",
            "    conf = api.get_config_value(\"log\", \"filelog\")",
            "    if not conf:",
            "        warning = \"Warning: File log is disabled, see settings page.\"",
            "",
            "    per_page_selection = ((20, 20), (34, 34), (40, 40), (100, 100), (0, \"all\"))",
            "    fro = None",
            "",
            "    if flask.request.method == \"POST\":",
            "        try:",
            "            from_form = flask.request.form[\"from\"]",
            "            fro = datetime.datetime.strptime(from_form, \"%Y-%m-%d %H:%M:%S\")",
            "        except Exception:",
            "            pass",
            "",
            "        per_page = int(flask.request.form.get(\"perpage\", 34))",
            "        s[\"perpage\"] = per_page",
            "",
            "        reversed = bool(flask.request.form.get(\"reversed\", False))",
            "        s[\"reversed\"] = reversed",
            "",
            "        # s.modified = True",
            "",
            "    log_entries = api.get_log()",
            "    if not per_page:",
            "        start_line = 0",
            "",
            "    if start_line < 1:",
            "        start_line = (",
            "            1 if len(log_entries) - per_page + 1 < 1 or per_page == 0 else len(log_entries) - per_page + 1",
            "        )",
            "",
            "    if isinstance(fro, datetime.datetime):  #: we will search for datetime.datetime",
            "        start_line = -1",
            "",
            "    data = []",
            "    inpage_counter = 0",
            "    for counter, logline in enumerate(log_entries, start=1):",
            "        if counter >= start_line:",
            "            try:",
            "                date, time, level, source, message = _RE_LOGLINE.match(logline).groups()",
            "                dtime = datetime.datetime.strptime(",
            "                    date + \" \" + time, \"%Y-%m-%d %H:%M:%S\"",
            "                )",
            "                message = message.strip()",
            "            except (AttributeError, IndexError):",
            "                dtime = None",
            "                date = \"?\"",
            "                time = \" \"",
            "                level = \"?\"",
            "                source = \"?\"",
            "                message = logline",
            "            if start_line == -1 and dtime is not None and fro <= dtime:",
            "                start_line = counter  #: found our datetime.datetime",
            "",
            "            if start_line >= 0:",
            "                data.append(",
            "                    {",
            "                        \"line\": counter,",
            "                        \"date\": date + \" \" + time,",
            "                        \"level\": level,",
            "                        \"source\": source,",
            "                        \"message\": message.rstrip('\\n'),",
            "                    }",
            "                )",
            "                inpage_counter += 1",
            "                if (",
            "                    fro is None and dtime is not None",
            "                ):  #: if fro not set, set it to first showed line",
            "                    fro = dtime",
            "            if inpage_counter >= per_page > 0:",
            "                break",
            "",
            "    if fro is None:  #: still not set, empty log?",
            "        fro = datetime.datetime.now()",
            "",
            "    if reversed:",
            "        data.reverse()",
            "",
            "    context = {",
            "        \"warning\": warning,",
            "        \"log\": data,",
            "        \"from\": fro.strftime(\"%Y-%m-%d %H:%M:%S\"),",
            "        \"reversed\": reversed,",
            "        \"perpage\": per_page,",
            "        \"perpage_p\": sorted(per_page_selection),",
            "        \"iprev\": max(start_line - per_page, 1),",
            "        \"inext\": (start_line + per_page) if start_line + per_page <= len(log_entries) else start_line,",
            "    }",
            "    return render_template(\"logs.html\", **context)",
            "",
            "",
            "@bp.route(\"/filemanager\", endpoint=\"filemanager\")",
            "@login_required(\"MODIFY\")",
            "def filemanager(path):",
            "    return render_template(\"filemanager.html\")",
            "",
            "",
            "@bp.route(\"/info\", endpoint=\"info\")",
            "@login_required(\"STATUS\")",
            "def info():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    conf = api.get_config_dict()",
            "    extra = os.uname() if hasattr(os, \"uname\") else tuple()",
            "",
            "    context = {",
            "        \"python\": sys.version,",
            "        \"os\": \" \".join((os.name, sys.platform) + extra),",
            "        \"version\": api.get_server_version(),",
            "        \"folder\": PKGDIR,",
            "        \"config_folder\": api.get_userdir(),",
            "        \"download\": conf[\"general\"][\"storage_folder\"][\"value\"],",
            "        \"freespace\": format.size(api.free_space()),",
            "        \"webif\": conf[\"webui\"][\"port\"][\"value\"],",
            "        \"language\": conf[\"general\"][\"language\"][\"value\"],",
            "    }",
            "    return render_template(\"info.html\", **context)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "50": [
                "login"
            ],
            "60": [
                "login"
            ],
            "67": [
                "login"
            ],
            "77": [
                "login"
            ],
            "79": [
                "login"
            ]
        },
        "addLocation": []
    },
    "src/pyload/webui/app/helpers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import json"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from functools import wraps"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from urllib.parse import unquote, urljoin, urlparse"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from urllib.parse import urljoin, urlparse"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import flask"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import flask_themes2"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+import werkzeug.routing.exceptions"
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from pyload.core.api import Perms, Role, has_permission"
            },
            "10": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " #: Checks if location belongs to same host address"
            },
            "14": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " def is_safe_url(location):"
            },
            "15": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ref_url = urlparse(flask.request.host_url)"
            },
            "16": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    test_url = urlparse(urljoin(flask.request.host_url, location))"
            },
            "17": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return test_url.scheme in ('http', 'https') and ref_url.netloc == test_url.netloc"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    location_urlp = urlparse(location)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    #: if relative URL then must start with \"/\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    if not location_urlp.netloc and location[0] != \"/\":"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        return False"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    host_urlp = urlparse(flask.request.host_url)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    test_urlp = urlparse(urljoin(flask.request.host_url, location))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    return test_urlp.scheme in ('http', 'https') and host_urlp.netloc == test_urlp.netloc"
            },
            "25": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " def get_redirect_url(fallback=None):"
            },
            "28": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    login_url = urljoin(flask.request.url_root, flask.url_for('app.login'))"
            },
            "29": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    request_url = unquote(flask.request.url)"
            },
            "30": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for location in flask.request.values.get(\"next\"), flask.request.referrer:"
            },
            "31": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not location:"
            },
            "32": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            continue"
            },
            "33": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if location in (request_url, login_url):  # don't redirect to same location"
            },
            "34": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            continue"
            },
            "35": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if is_safe_url(location):"
            },
            "36": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return location"
            },
            "37": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return fallback"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    next_arg = flask.request.values.get(\"next\")"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    redirect_url = flask.url_for(fallback)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    if next_arg and next_arg != \"login\":  # don't redirect to same location"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        try:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            redirect_url = flask.url_for(f\"app.{next_arg}\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        except werkzeug.routing.exceptions.BuildError:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            pass"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    return urljoin(flask.request.url_root, redirect_url)"
            },
            "47": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " def render_base(messages):"
            },
            "50": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "                 else:"
            },
            "51": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "                     location = flask.url_for("
            },
            "52": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "                         \"app.login\","
            },
            "53": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        next=flask.request.url"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                        next=flask.request.endpoint.split(\".\")[-1]"
            },
            "55": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "                     )"
            },
            "56": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "                     response = flask.redirect(location)"
            },
            "57": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 216,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import json",
            "from functools import wraps",
            "from urllib.parse import unquote, urljoin, urlparse",
            "",
            "import flask",
            "import flask_themes2",
            "from pyload.core.api import Perms, Role, has_permission",
            "",
            "",
            "class JSONEncoder(json.JSONEncoder):",
            "    def default(self, obj):",
            "        try:",
            "            return dict(obj)",
            "        except TypeError:",
            "            pass",
            "        return super().default(obj)",
            "",
            "",
            "try:",
            "    JSONProviderBase = flask.json.provider.JSONProvider",
            "except AttributeError:",
            "    pass",
            "else:",
            "    class JSONProvider(JSONProviderBase):",
            "        def dumps(self, obj, **kwargs):",
            "            return json.dumps(obj, **kwargs, cls=JSONEncoder)",
            "",
            "        def loads(self, s, **kwargs):",
            "            return json.loads(s, **kwargs)",
            "",
            "",
            "#: Checks if location belongs to same host address",
            "def is_safe_url(location):",
            "    ref_url = urlparse(flask.request.host_url)",
            "    test_url = urlparse(urljoin(flask.request.host_url, location))",
            "    return test_url.scheme in ('http', 'https') and ref_url.netloc == test_url.netloc",
            "",
            "",
            "def get_redirect_url(fallback=None):",
            "    login_url = urljoin(flask.request.url_root, flask.url_for('app.login'))",
            "    request_url = unquote(flask.request.url)",
            "    for location in flask.request.values.get(\"next\"), flask.request.referrer:",
            "        if not location:",
            "            continue",
            "        if location in (request_url, login_url):  # don't redirect to same location",
            "            continue",
            "        if is_safe_url(location):",
            "            return location",
            "    return fallback",
            "",
            "",
            "def render_base(messages):",
            "    return render_template(\"base.html\", messages=messages)",
            "",
            "",
            "def clear_session(session=flask.session, permanent=True):",
            "    session.permanent = bool(permanent)",
            "    session.clear()",
            "    # session.modified = True",
            "",
            "",
            "def current_theme_id():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    return api.get_config_value(\"webui\", \"theme\").lower()",
            "",
            "",
            "#: tries to serve the file from the static directory of the current theme otherwise fallback to builtin one",
            "def static_file_url(filename):",
            "    themeid = current_theme_id()",
            "    try:",
            "        url = flask_themes2.static_file_url(themeid, filename)",
            "    except KeyError:",
            "        url = flask.url_for(\"static\", filename=filename)",
            "    return url",
            "",
            "",
            "def theme_template(filename):",
            "    return flask.url_for(\"app.render\", filename=filename)",
            "",
            "",
            "#: tries to render the template of the current theme otherwise fallback to builtin template",
            "def render_template(template, **context):",
            "    themeid = current_theme_id()",
            "    return flask_themes2.render_theme_template(themeid, template, **context)",
            "",
            "",
            "def parse_permissions(session=flask.session):",
            "    perms = {x.name: False for x in Perms}",
            "    perms[\"ADMIN\"] = False",
            "    perms[\"is_admin\"] = False",
            "",
            "    if not session.get(\"authenticated\", False):",
            "        return perms",
            "",
            "    perms[\"ANY\"] = True",
            "    if session.get(\"role\") == Role.ADMIN:",
            "        for key in perms.keys():",
            "            perms[key] = True",
            "",
            "    elif session.get(\"perms\"):",
            "        p = session.get(\"perms\")",
            "        perms.update(get_permission(p))",
            "",
            "    return perms",
            "",
            "",
            "def permlist():",
            "    return [x.name for x in Perms if x.name != \"ANY\"]",
            "",
            "",
            "def get_permission(userperms):",
            "    \"\"\"",
            "    Returns a dict with permission key.",
            "",
            "    :param userperms: permission bits",
            "    \"\"\"",
            "    return {",
            "        name: has_permission(userperms, getattr(Perms, name).value)",
            "        for name in permlist()",
            "    }",
            "",
            "",
            "def set_permission(perms):",
            "    \"\"\"",
            "    generates permission bits from dictionary.",
            "",
            "    :param perms: dict",
            "    \"\"\"",
            "    permission = 0",
            "    for name in permlist():",
            "        if name.startswith(\"_\"):",
            "            continue",
            "",
            "        if name in perms and perms[name]:",
            "            permission |= getattr(Perms, name)",
            "",
            "    return permission",
            "",
            "",
            "def set_session(user_info, session=flask.session, permanent=True):",
            "    session.permanent = bool(permanent)",
            "    session.update(",
            "        {",
            "            \"authenticated\": True,",
            "            \"id\": user_info[\"id\"],",
            "            \"name\": user_info[\"name\"],",
            "            \"role\": user_info[\"role\"],",
            "            \"perms\": user_info[\"permission\"],",
            "            \"template\": user_info[\"template\"],",
            "        }",
            "    )",
            "    # session.modified = True",
            "    return session",
            "",
            "",
            "# TODO: Recheck...",
            "def parse_userdata(session=flask.session):",
            "    return {",
            "        \"name\": session.get(\"name\", \"Anonymous\"),",
            "        \"is_admin\": session.get(\"role\", 1) == 0,",
            "        \"is_authenticated\": session.get(\"authenticated\", False),",
            "    }",
            "",
            "",
            "def apiver_check(func):",
            "    # if no apiver is provided assumes latest",
            "    @wraps(func)",
            "    def wrapper(*args, **kwargs):",
            "        api = flask.current_app.config[\"PYLOAD_API\"]",
            "        core_apiver = api.__version__",
            "        if int(kwargs.get(\"apiver\", core_apiver).strip(\"v\")) < core_apiver:",
            "            return \"Obsolete API\", 404",
            "        return func(*args, **kwargs)",
            "",
            "    return wrapper",
            "",
            "",
            "def is_authenticated(session=flask.session):",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    user = session.get(\"name\")",
            "    authenticated = session.get(\"authenticated\")",
            "",
            "    return authenticated and api.user_exists(user)",
            "",
            "",
            "def login_required(perm):",
            "    def decorator(func):",
            "        @wraps(func)",
            "        def wrapper(*args, **kwargs):",
            "            s = flask.session",
            "            #: already authenticated?",
            "            if is_authenticated(s):",
            "                perms = parse_permissions(s)",
            "                if perm not in perms or not perms[perm]:",
            "                    response = \"Forbidden\", 403",
            "                else:",
            "                    response = func(*args, **kwargs)",
            "",
            "            else:",
            "                clear_session(s)",
            "                if flask.request.headers.get(\"X-Requested-With\") == \"XMLHttpRequest\":",
            "                    response = \"Forbidden\", 403",
            "",
            "                else:",
            "                    location = flask.url_for(",
            "                        \"app.login\",",
            "                        next=flask.request.url",
            "                    )",
            "                    response = flask.redirect(location)",
            "",
            "            return response",
            "",
            "        return wrapper",
            "",
            "    return decorator"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "import json",
            "from functools import wraps",
            "from urllib.parse import urljoin, urlparse",
            "",
            "import flask",
            "import flask_themes2",
            "import werkzeug.routing.exceptions",
            "from pyload.core.api import Perms, Role, has_permission",
            "",
            "",
            "class JSONEncoder(json.JSONEncoder):",
            "    def default(self, obj):",
            "        try:",
            "            return dict(obj)",
            "        except TypeError:",
            "            pass",
            "        return super().default(obj)",
            "",
            "",
            "try:",
            "    JSONProviderBase = flask.json.provider.JSONProvider",
            "except AttributeError:",
            "    pass",
            "else:",
            "    class JSONProvider(JSONProviderBase):",
            "        def dumps(self, obj, **kwargs):",
            "            return json.dumps(obj, **kwargs, cls=JSONEncoder)",
            "",
            "        def loads(self, s, **kwargs):",
            "            return json.loads(s, **kwargs)",
            "",
            "",
            "#: Checks if location belongs to same host address",
            "def is_safe_url(location):",
            "    location_urlp = urlparse(location)",
            "    #: if relative URL then must start with \"/\"",
            "    if not location_urlp.netloc and location[0] != \"/\":",
            "        return False",
            "    host_urlp = urlparse(flask.request.host_url)",
            "    test_urlp = urlparse(urljoin(flask.request.host_url, location))",
            "    return test_urlp.scheme in ('http', 'https') and host_urlp.netloc == test_urlp.netloc",
            "",
            "",
            "def get_redirect_url(fallback=None):",
            "    next_arg = flask.request.values.get(\"next\")",
            "    redirect_url = flask.url_for(fallback)",
            "    if next_arg and next_arg != \"login\":  # don't redirect to same location",
            "        try:",
            "            redirect_url = flask.url_for(f\"app.{next_arg}\")",
            "        except werkzeug.routing.exceptions.BuildError:",
            "            pass",
            "",
            "    return urljoin(flask.request.url_root, redirect_url)",
            "",
            "",
            "def render_base(messages):",
            "    return render_template(\"base.html\", messages=messages)",
            "",
            "",
            "def clear_session(session=flask.session, permanent=True):",
            "    session.permanent = bool(permanent)",
            "    session.clear()",
            "    # session.modified = True",
            "",
            "",
            "def current_theme_id():",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    return api.get_config_value(\"webui\", \"theme\").lower()",
            "",
            "",
            "#: tries to serve the file from the static directory of the current theme otherwise fallback to builtin one",
            "def static_file_url(filename):",
            "    themeid = current_theme_id()",
            "    try:",
            "        url = flask_themes2.static_file_url(themeid, filename)",
            "    except KeyError:",
            "        url = flask.url_for(\"static\", filename=filename)",
            "    return url",
            "",
            "",
            "def theme_template(filename):",
            "    return flask.url_for(\"app.render\", filename=filename)",
            "",
            "",
            "#: tries to render the template of the current theme otherwise fallback to builtin template",
            "def render_template(template, **context):",
            "    themeid = current_theme_id()",
            "    return flask_themes2.render_theme_template(themeid, template, **context)",
            "",
            "",
            "def parse_permissions(session=flask.session):",
            "    perms = {x.name: False for x in Perms}",
            "    perms[\"ADMIN\"] = False",
            "    perms[\"is_admin\"] = False",
            "",
            "    if not session.get(\"authenticated\", False):",
            "        return perms",
            "",
            "    perms[\"ANY\"] = True",
            "    if session.get(\"role\") == Role.ADMIN:",
            "        for key in perms.keys():",
            "            perms[key] = True",
            "",
            "    elif session.get(\"perms\"):",
            "        p = session.get(\"perms\")",
            "        perms.update(get_permission(p))",
            "",
            "    return perms",
            "",
            "",
            "def permlist():",
            "    return [x.name for x in Perms if x.name != \"ANY\"]",
            "",
            "",
            "def get_permission(userperms):",
            "    \"\"\"",
            "    Returns a dict with permission key.",
            "",
            "    :param userperms: permission bits",
            "    \"\"\"",
            "    return {",
            "        name: has_permission(userperms, getattr(Perms, name).value)",
            "        for name in permlist()",
            "    }",
            "",
            "",
            "def set_permission(perms):",
            "    \"\"\"",
            "    generates permission bits from dictionary.",
            "",
            "    :param perms: dict",
            "    \"\"\"",
            "    permission = 0",
            "    for name in permlist():",
            "        if name.startswith(\"_\"):",
            "            continue",
            "",
            "        if name in perms and perms[name]:",
            "            permission |= getattr(Perms, name)",
            "",
            "    return permission",
            "",
            "",
            "def set_session(user_info, session=flask.session, permanent=True):",
            "    session.permanent = bool(permanent)",
            "    session.update(",
            "        {",
            "            \"authenticated\": True,",
            "            \"id\": user_info[\"id\"],",
            "            \"name\": user_info[\"name\"],",
            "            \"role\": user_info[\"role\"],",
            "            \"perms\": user_info[\"permission\"],",
            "            \"template\": user_info[\"template\"],",
            "        }",
            "    )",
            "    # session.modified = True",
            "    return session",
            "",
            "",
            "# TODO: Recheck...",
            "def parse_userdata(session=flask.session):",
            "    return {",
            "        \"name\": session.get(\"name\", \"Anonymous\"),",
            "        \"is_admin\": session.get(\"role\", 1) == 0,",
            "        \"is_authenticated\": session.get(\"authenticated\", False),",
            "    }",
            "",
            "",
            "def apiver_check(func):",
            "    # if no apiver is provided assumes latest",
            "    @wraps(func)",
            "    def wrapper(*args, **kwargs):",
            "        api = flask.current_app.config[\"PYLOAD_API\"]",
            "        core_apiver = api.__version__",
            "        if int(kwargs.get(\"apiver\", core_apiver).strip(\"v\")) < core_apiver:",
            "            return \"Obsolete API\", 404",
            "        return func(*args, **kwargs)",
            "",
            "    return wrapper",
            "",
            "",
            "def is_authenticated(session=flask.session):",
            "    api = flask.current_app.config[\"PYLOAD_API\"]",
            "    user = session.get(\"name\")",
            "    authenticated = session.get(\"authenticated\")",
            "",
            "    return authenticated and api.user_exists(user)",
            "",
            "",
            "def login_required(perm):",
            "    def decorator(func):",
            "        @wraps(func)",
            "        def wrapper(*args, **kwargs):",
            "            s = flask.session",
            "            #: already authenticated?",
            "            if is_authenticated(s):",
            "                perms = parse_permissions(s)",
            "                if perm not in perms or not perms[perm]:",
            "                    response = \"Forbidden\", 403",
            "                else:",
            "                    response = func(*args, **kwargs)",
            "",
            "            else:",
            "                clear_session(s)",
            "                if flask.request.headers.get(\"X-Requested-With\") == \"XMLHttpRequest\":",
            "                    response = \"Forbidden\", 403",
            "",
            "                else:",
            "                    location = flask.url_for(",
            "                        \"app.login\",",
            "                        next=flask.request.endpoint.split(\".\")[-1]",
            "                    )",
            "                    response = flask.redirect(location)",
            "",
            "            return response",
            "",
            "        return wrapper",
            "",
            "    return decorator"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "36": [
                "is_safe_url"
            ],
            "37": [
                "is_safe_url"
            ],
            "38": [
                "is_safe_url"
            ],
            "42": [
                "get_redirect_url"
            ],
            "43": [
                "get_redirect_url"
            ],
            "44": [
                "get_redirect_url"
            ],
            "45": [
                "get_redirect_url"
            ],
            "46": [
                "get_redirect_url"
            ],
            "47": [
                "get_redirect_url"
            ],
            "48": [
                "get_redirect_url"
            ],
            "49": [
                "get_redirect_url"
            ],
            "50": [
                "get_redirect_url"
            ],
            "51": [
                "get_redirect_url"
            ],
            "209": [
                "login_required",
                "decorator",
                "wrapper"
            ]
        },
        "addLocation": []
    }
}