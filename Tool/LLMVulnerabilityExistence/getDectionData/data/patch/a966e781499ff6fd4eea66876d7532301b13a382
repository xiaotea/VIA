{
    "apkleaks/apkleaks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from apkleaks.colors import clr"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from contextlib import closing"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from distutils.spawn import find_executable"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from pipes import quote"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from pyaxmlparser import APK"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from urllib.request import urlopen"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from zipfile import ZipFile"
            },
            "7": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " \t\t\t\t\tclasses.write(zipped.read(\"classes.dex\"))"
            },
            "8": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": " \t\t\texcept Exception as e:"
            },
            "9": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " \t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))"
            },
            "10": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\t\tdec = \"%s %s -d %s --deobf\" % (self.jadx, dex, self.tempdir)"
            },
            "11": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-\t\tos.system(dec)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+\t\targs = [self.jadx, dex, \"-d\", self.tempdir, \"--deobf\"]"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+\t\tcomm = \"%s\" % (\" \".join(quote(arg) for arg in args))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+\t\tos.system(comm)"
            },
            "15": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " \t\treturn self.tempdir"
            },
            "16": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " \tdef unique(self, list): "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python3",
            "from apkleaks.colors import clr",
            "from contextlib import closing",
            "from distutils.spawn import find_executable",
            "from pyaxmlparser import APK",
            "from urllib.request import urlopen",
            "from zipfile import ZipFile",
            "import io",
            "import json",
            "import logging.config",
            "import mimetypes",
            "import numpy",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import tempfile",
            "import threading",
            "",
            "class APKLeaks:",
            "\tdef __init__(self, args):",
            "\t\tself.file = args.file",
            "\t\tself.prefix = \"apkleaks-\"",
            "\t\tself.tempdir = tempfile.mkdtemp(prefix=self.prefix)",
            "\t\tself.main_dir = os.path.dirname(os.path.realpath(__file__))",
            "\t\tself.output = tempfile.mkstemp(suffix=\".txt\", prefix=self.prefix)[1] if args.output is None else args.output",
            "\t\tself.pattern = self.main_dir + \"/../config/regexes.json\" if args.pattern is None else args.pattern",
            "\t\tself.jadx = find_executable(\"jadx\") if find_executable(\"jadx\") is not None else self.main_dir + \"/../jadx/bin/jadx%s\" % (\".bat\" if os.name == \"nt\" else \"\")",
            "\t\tlogging.config.dictConfig({\"version\": 1, \"disable_existing_loggers\": True})",
            "",
            "\tdef apk_info(self):",
            "\t\treturn APK(self.file)",
            "",
            "\tdef dependencies(self):",
            "\t\texter = \"https://github.com/skylot/jadx/releases/download/v1.2.0/jadx-1.2.0.zip\"",
            "\t\twith closing(urlopen(exter)) as jadx:",
            "\t\t\twith ZipFile(io.BytesIO(jadx.read())) as zfile:",
            "\t\t\t\tzfile.extractall(self.main_dir + \"/../jadx\")",
            "\t\tos.chmod(self.jadx, 33268)",
            "",
            "\tdef write(self, message, color):",
            "\t\tsys.stdout.write(\"%s%s%s\" % (color, message, clr.ENDC))",
            "",
            "\tdef writeln(self, message, color):",
            "\t\tself.write(message + \"\\n\", color)",
            "",
            "\tdef integrity(self):",
            "\t\tif os.path.exists(self.jadx) is False:",
            "\t\t\tself.writeln(\"Can't find jadx binary.\", clr.WARNING)",
            "\t\t\tvalid = {\"yes\": True, \"y\": True, \"ye\": True, \"no\": False, \"n\": False}",
            "\t\t\twhile True:",
            "\t\t\t\tself.write(\"Do you want to download jadx? (Y/n) \", clr.OKBLUE)",
            "\t\t\t\tchoice = input().lower()",
            "\t\t\t\tif choice == \"\":",
            "\t\t\t\t\tchoice = valid[\"y\"]",
            "\t\t\t\t\tbreak",
            "\t\t\t\telif choice in valid:",
            "\t\t\t\t\tchoice = valid[choice]",
            "\t\t\t\t\tbreak",
            "\t\t\t\telse:",
            "\t\t\t\t\tself.writeln(\"\\nPlease respond with 'yes' or 'no' (or 'y' or 'n').\", clr.WARNING)",
            "\t\t\tif choice:",
            "\t\t\t\tself.writeln(\"** Downloading jadx...\\n\", clr.OKBLUE)",
            "\t\t\t\tself.dependencies()",
            "\t\t\telse:",
            "\t\t\t\tsys.exit(self.writeln(\"Aborted.\", clr.FAIL))",
            "",
            "\t\tif os.path.isfile(self.file) is True:",
            "\t\t\ttry:",
            "\t\t\t\tself.apk = self.apk_info()",
            "\t\t\texcept Exception as e:",
            "\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))",
            "\t\t\telse:",
            "\t\t\t\treturn self.apk",
            "\t\telse:",
            "\t\t\tsys.exit(self.writeln(\"It's not a valid file!\", clr.WARNING))",
            "",
            "\tdef decompile(self):",
            "\t\tself.writeln(\"** Decompiling APK...\", clr.OKBLUE)",
            "\t\twith ZipFile(self.file) as zipped:",
            "\t\t\ttry:",
            "\t\t\t\tdex = self.tempdir + \"/\" + self.apk.package + \".dex\"",
            "\t\t\t\twith open(dex, \"wb\") as classes:",
            "\t\t\t\t\tclasses.write(zipped.read(\"classes.dex\"))",
            "\t\t\texcept Exception as e:",
            "\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))",
            "\t\tdec = \"%s %s -d %s --deobf\" % (self.jadx, dex, self.tempdir)",
            "\t\tos.system(dec)",
            "\t\treturn self.tempdir",
            "",
            "\tdef unique(self, list): ",
            "\t\tx = numpy.array(list) ",
            "\t\treturn (numpy.unique(x))",
            "",
            "\tdef finder(self, pattern, path):",
            "\t\tmatcher = re.compile(pattern)",
            "\t\tfound = []",
            "\t\tfor path, _, files in os.walk(path):",
            "\t\t\tfor fn in files:",
            "\t\t\t\tfilepath = os.path.join(path, fn)",
            "\t\t\t\tif mimetypes.guess_type(filepath)[0] is None:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\twith open(filepath) as handle:",
            "\t\t\t\t\tfor lineno, line in enumerate(handle):",
            "\t\t\t\t\t\tmo = matcher.search(line)",
            "\t\t\t\t\t\tif mo:",
            "\t\t\t\t\t\t\tfound.append(mo.group())",
            "\t\treturn self.unique(found)",
            "",
            "\tdef extract(self, name, matches):",
            "\t\toutput = open(self.output, \"a+\")",
            "\t\tif matches:",
            "\t\t\tstdout = (\"[%s]\" % (name))",
            "\t\t\tself.writeln(\"\\n\" + stdout, clr.OKGREEN)",
            "\t\t\toutput.write(stdout + \"\\n\")",
            "\t\t\tfor secret in matches:",
            "\t\t\t\tif name == \"LinkFinder\" and re.match(r\"^.(L[a-z]|application|audio|fonts|image|layout|multipart|plain|text|video).*\\/.+\", secret) is not None:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\tstdout = (\"- %s\" % (secret))",
            "\t\t\t\tprint(stdout)",
            "\t\t\t\toutput.write(stdout + \"\\n\")",
            "\t\t\toutput.write(\"\\n\")",
            "\t\toutput.close()",
            "",
            "\tdef scanning(self):",
            "\t\tself.writeln(\"\\n** Scanning against '%s'\" % (self.apk.package), clr.OKBLUE)",
            "\t\twith open(self.pattern) as regexes:",
            "\t\t\tregex = json.load(regexes)",
            "\t\t\tfor name, pattern in regex.items():",
            "\t\t\t\tif isinstance(pattern, list):",
            "\t\t\t\t\tfor pattern in pattern:",
            "\t\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))",
            "\t\t\t\t\t\tthread.start()",
            "\t\t\t\telse:",
            "\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))",
            "\t\t\t\t\tthread.start()",
            "",
            "\tdef __del__(self):",
            "\t\tprint(\"%s\\n** Results saved into '%s%s%s%s'%s\" % (clr.OKBLUE, clr.ENDC, clr.OKGREEN, self.output, clr.OKBLUE, clr.ENDC))",
            "\t\ttry:",
            "\t\t\tshutil.rmtree(self.tempdir)",
            "\t\texcept Exception:",
            "\t\t\treturn"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python3",
            "from apkleaks.colors import clr",
            "from contextlib import closing",
            "from distutils.spawn import find_executable",
            "from pipes import quote",
            "from pyaxmlparser import APK",
            "from urllib.request import urlopen",
            "from zipfile import ZipFile",
            "import io",
            "import json",
            "import logging.config",
            "import mimetypes",
            "import numpy",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import tempfile",
            "import threading",
            "",
            "class APKLeaks:",
            "\tdef __init__(self, args):",
            "\t\tself.file = args.file",
            "\t\tself.prefix = \"apkleaks-\"",
            "\t\tself.tempdir = tempfile.mkdtemp(prefix=self.prefix)",
            "\t\tself.main_dir = os.path.dirname(os.path.realpath(__file__))",
            "\t\tself.output = tempfile.mkstemp(suffix=\".txt\", prefix=self.prefix)[1] if args.output is None else args.output",
            "\t\tself.pattern = self.main_dir + \"/../config/regexes.json\" if args.pattern is None else args.pattern",
            "\t\tself.jadx = find_executable(\"jadx\") if find_executable(\"jadx\") is not None else self.main_dir + \"/../jadx/bin/jadx%s\" % (\".bat\" if os.name == \"nt\" else \"\")",
            "\t\tlogging.config.dictConfig({\"version\": 1, \"disable_existing_loggers\": True})",
            "",
            "\tdef apk_info(self):",
            "\t\treturn APK(self.file)",
            "",
            "\tdef dependencies(self):",
            "\t\texter = \"https://github.com/skylot/jadx/releases/download/v1.2.0/jadx-1.2.0.zip\"",
            "\t\twith closing(urlopen(exter)) as jadx:",
            "\t\t\twith ZipFile(io.BytesIO(jadx.read())) as zfile:",
            "\t\t\t\tzfile.extractall(self.main_dir + \"/../jadx\")",
            "\t\tos.chmod(self.jadx, 33268)",
            "",
            "\tdef write(self, message, color):",
            "\t\tsys.stdout.write(\"%s%s%s\" % (color, message, clr.ENDC))",
            "",
            "\tdef writeln(self, message, color):",
            "\t\tself.write(message + \"\\n\", color)",
            "",
            "\tdef integrity(self):",
            "\t\tif os.path.exists(self.jadx) is False:",
            "\t\t\tself.writeln(\"Can't find jadx binary.\", clr.WARNING)",
            "\t\t\tvalid = {\"yes\": True, \"y\": True, \"ye\": True, \"no\": False, \"n\": False}",
            "\t\t\twhile True:",
            "\t\t\t\tself.write(\"Do you want to download jadx? (Y/n) \", clr.OKBLUE)",
            "\t\t\t\tchoice = input().lower()",
            "\t\t\t\tif choice == \"\":",
            "\t\t\t\t\tchoice = valid[\"y\"]",
            "\t\t\t\t\tbreak",
            "\t\t\t\telif choice in valid:",
            "\t\t\t\t\tchoice = valid[choice]",
            "\t\t\t\t\tbreak",
            "\t\t\t\telse:",
            "\t\t\t\t\tself.writeln(\"\\nPlease respond with 'yes' or 'no' (or 'y' or 'n').\", clr.WARNING)",
            "\t\t\tif choice:",
            "\t\t\t\tself.writeln(\"** Downloading jadx...\\n\", clr.OKBLUE)",
            "\t\t\t\tself.dependencies()",
            "\t\t\telse:",
            "\t\t\t\tsys.exit(self.writeln(\"Aborted.\", clr.FAIL))",
            "",
            "\t\tif os.path.isfile(self.file) is True:",
            "\t\t\ttry:",
            "\t\t\t\tself.apk = self.apk_info()",
            "\t\t\texcept Exception as e:",
            "\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))",
            "\t\t\telse:",
            "\t\t\t\treturn self.apk",
            "\t\telse:",
            "\t\t\tsys.exit(self.writeln(\"It's not a valid file!\", clr.WARNING))",
            "",
            "\tdef decompile(self):",
            "\t\tself.writeln(\"** Decompiling APK...\", clr.OKBLUE)",
            "\t\twith ZipFile(self.file) as zipped:",
            "\t\t\ttry:",
            "\t\t\t\tdex = self.tempdir + \"/\" + self.apk.package + \".dex\"",
            "\t\t\t\twith open(dex, \"wb\") as classes:",
            "\t\t\t\t\tclasses.write(zipped.read(\"classes.dex\"))",
            "\t\t\texcept Exception as e:",
            "\t\t\t\tsys.exit(self.writeln(str(e), clr.WARNING))",
            "\t\targs = [self.jadx, dex, \"-d\", self.tempdir, \"--deobf\"]",
            "\t\tcomm = \"%s\" % (\" \".join(quote(arg) for arg in args))",
            "\t\tos.system(comm)",
            "\t\treturn self.tempdir",
            "",
            "\tdef unique(self, list): ",
            "\t\tx = numpy.array(list) ",
            "\t\treturn (numpy.unique(x))",
            "",
            "\tdef finder(self, pattern, path):",
            "\t\tmatcher = re.compile(pattern)",
            "\t\tfound = []",
            "\t\tfor path, _, files in os.walk(path):",
            "\t\t\tfor fn in files:",
            "\t\t\t\tfilepath = os.path.join(path, fn)",
            "\t\t\t\tif mimetypes.guess_type(filepath)[0] is None:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\twith open(filepath) as handle:",
            "\t\t\t\t\tfor lineno, line in enumerate(handle):",
            "\t\t\t\t\t\tmo = matcher.search(line)",
            "\t\t\t\t\t\tif mo:",
            "\t\t\t\t\t\t\tfound.append(mo.group())",
            "\t\treturn self.unique(found)",
            "",
            "\tdef extract(self, name, matches):",
            "\t\toutput = open(self.output, \"a+\")",
            "\t\tif matches:",
            "\t\t\tstdout = (\"[%s]\" % (name))",
            "\t\t\tself.writeln(\"\\n\" + stdout, clr.OKGREEN)",
            "\t\t\toutput.write(stdout + \"\\n\")",
            "\t\t\tfor secret in matches:",
            "\t\t\t\tif name == \"LinkFinder\" and re.match(r\"^.(L[a-z]|application|audio|fonts|image|layout|multipart|plain|text|video).*\\/.+\", secret) is not None:",
            "\t\t\t\t\tcontinue",
            "\t\t\t\tstdout = (\"- %s\" % (secret))",
            "\t\t\t\tprint(stdout)",
            "\t\t\t\toutput.write(stdout + \"\\n\")",
            "\t\t\toutput.write(\"\\n\")",
            "\t\toutput.close()",
            "",
            "\tdef scanning(self):",
            "\t\tself.writeln(\"\\n** Scanning against '%s'\" % (self.apk.package), clr.OKBLUE)",
            "\t\twith open(self.pattern) as regexes:",
            "\t\t\tregex = json.load(regexes)",
            "\t\t\tfor name, pattern in regex.items():",
            "\t\t\t\tif isinstance(pattern, list):",
            "\t\t\t\t\tfor pattern in pattern:",
            "\t\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))",
            "\t\t\t\t\t\tthread.start()",
            "\t\t\t\telse:",
            "\t\t\t\t\tthread = threading.Thread(target = self.extract, args = (name, self.finder(pattern, self.tempdir)))",
            "\t\t\t\t\tthread.start()",
            "",
            "\tdef __del__(self):",
            "\t\tprint(\"%s\\n** Results saved into '%s%s%s%s'%s\" % (clr.OKBLUE, clr.ENDC, clr.OKGREEN, self.output, clr.OKBLUE, clr.ENDC))",
            "\t\ttry:",
            "\t\t\tshutil.rmtree(self.tempdir)",
            "\t\texcept Exception:",
            "\t\t\treturn"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "87": [
                "APKLeaks",
                "decompile"
            ],
            "88": [
                "APKLeaks",
                "decompile"
            ]
        },
        "addLocation": []
    }
}