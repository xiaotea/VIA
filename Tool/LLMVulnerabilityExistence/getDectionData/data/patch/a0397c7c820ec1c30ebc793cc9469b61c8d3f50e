{
    "tuf/sig.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "   \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "   <Purpose>"
            },
            "2": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     Return a dictionary representing the status of the signatures listed in"
            },
            "3": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public"
            },
            "4": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,"
            },
            "5": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    the status of these signatures can be determined.  This method will iterate"
            },
            "6": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    the signatures in 'signable' and enumerate all the keys that are valid,"
            },
            "7": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    invalid, unrecognized, or unauthorized."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+    'signable'. Signatures in the returned dictionary are identified by the"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+    signature keyid and can have a status of either:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    * bad -- Invalid signature"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    * good -- Valid signature from key that is available in 'tuf.keydb', and is"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+      authorized for the passed role as per 'tuf.roledb' (authorization may be"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+      overwritten by passed 'keyids')."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    * unknown -- Signature from key that is not available in 'tuf.keydb'."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+    * unknown signing schemes -- Signature from key with unknown signing"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+      scheme."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    * untrusted -- Valid signature from key that is available in 'tuf.keydb',"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+      but is not trusted for the passed role as per 'tuf.roledb' or the passed"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+      'keyids'."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+    NOTE: The result may contain duplicate keyids or keyids that reference the"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    same key, if 'signable' lists multiple signatures from the same key."
            },
            "24": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "   <Arguments>"
            },
            "26": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "     signable:"
            },
            "27": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "       Conformant to tuf.formats.SIGNABLE_SCHEMA."
            },
            "28": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     role:"
            },
            "30": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-      TUF role (e.g., 'root', 'targets', 'snapshot')."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+      TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp)."
            },
            "32": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     threshold:"
            },
            "34": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "       Rather than reference the role's threshold as set in tuf.roledb.py, use"
            },
            "35": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "   # The signature status dictionary returned."
            },
            "37": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "   signature_status = {}"
            },
            "38": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # The fields of the signature_status dict, where each field stores keyids.  A"
            },
            "40": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # description of each field:"
            },
            "41": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  #"
            },
            "42": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are"
            },
            "43": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # associated with 'role';"
            },
            "44": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  #"
            },
            "45": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # bad_sigs = negation of good_sigs;"
            },
            "46": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  #"
            },
            "47": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # unknown_sigs = keys not found in the 'keydb' database;"
            },
            "48": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  #"
            },
            "49": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # untrusted_sigs = keys that are not in the list of keyids associated with"
            },
            "50": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # 'role';"
            },
            "51": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  #"
            },
            "52": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # unknown_signing_scheme = signing schemes specified in keys that are"
            },
            "53": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  # unsupported;"
            },
            "54": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "   good_sigs = []"
            },
            "55": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "   bad_sigs = []"
            },
            "56": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "   unknown_sigs = []"
            },
            "57": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "     keyids=None):"
            },
            "58": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "   \"\"\""
            },
            "59": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "   <Purpose>"
            },
            "60": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Verify whether the authorized signatures of 'signable' meet the minimum"
            },
            "61": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    required by 'role'.  Authorized signatures are those with valid keys"
            },
            "62": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA"
            },
            "63": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    and 'role' must not equal 'None' or be less than zero."
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    Verify that 'signable' has a valid threshold of authorized signatures"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+    identified by unique keyids. The threshold and whether a keyid is"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    authorized is determined by querying the 'threshold' and 'keyids' info for"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    the passed 'role' in 'tuf.roledb'. Both values can be overwritten by"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+    passing the 'threshold' or 'keyids' arguments."
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    NOTE:"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+    - Signatures with identical authorized keyids only count towards the"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+      threshold once."
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    - Signatures with different authorized keyids each count towards the"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+      threshold, even if the keyids identify the same key."
            },
            "75": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 249,
                "PatchRowcode": " "
            },
            "76": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "   <Arguments>"
            },
            "77": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "     signable:"
            },
            "78": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-      A dictionary containing a list of signatures and a 'signed' identifier."
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+      A dictionary containing a list of signatures and a 'signed' identifier"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+      that conforms to SIGNABLE_SCHEMA, e.g.:"
            },
            "81": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "       signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}"
            },
            "82": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 255,
                "PatchRowcode": " "
            },
            "83": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "     role:"
            },
            "84": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-      TUF role (e.g., 'root', 'targets', 'snapshot')."
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+      TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp)."
            },
            "86": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "     threshold:"
            },
            "88": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "       Rather than reference the role's threshold as set in tuf.roledb.py, use"
            },
            "89": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 281,
                "PatchRowcode": "     get_signature_status() will be caught here and re-raised."
            },
            "90": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 282,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "   <Returns>"
            },
            "92": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Boolean.  True if the number of good signatures >= the role's threshold,"
            },
            "93": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    False otherwise."
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+    Boolean.  True if the number of good unique (by keyid) signatures >= the"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+    role's threshold, False otherwise."
            },
            "96": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "   \"\"\""
            },
            "97": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 287,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "   tuf.formats.SIGNABLE_SCHEMA.check_match(signable)"
            },
            "99": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "   if threshold is None or threshold <= 0: #pragma: no cover"
            },
            "100": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))"
            },
            "101": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 308,
                "PatchRowcode": " "
            },
            "102": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-  return len(good_sigs) >= threshold"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+  return len(set(good_sigs)) >= threshold"
            },
            "104": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 310,
                "PatchRowcode": " "
            },
            "105": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 311,
                "PatchRowcode": " "
            },
            "106": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 312,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "",
            "# Copyright 2012 - 2017, New York University and the TUF contributors",
            "# SPDX-License-Identifier: MIT OR Apache-2.0",
            "",
            "\"\"\"",
            "<Program Name>",
            "  sig.py",
            "",
            "<Author>",
            "  Vladimir Diaz <vladimir.v.diaz@gmail.com>",
            "",
            "<Started>",
            "  February 28, 2012.   Based on a previous version by Geremy Condra.",
            "",
            "<Copyright>",
            "  See LICENSE-MIT OR LICENSE for licensing information.",
            "",
            "<Purpose>",
            "  Survivable key compromise is one feature of a secure update system",
            "  incorporated into TUF's design. Responsibility separation through",
            "  the use of multiple roles, multi-signature trust, and explicit and",
            "  implicit key revocation are some of the mechanisms employed towards",
            "  this goal of survivability.  These mechanisms can all be seen in",
            "  play by the functions available in this module.",
            "",
            "  The signed metadata files utilized by TUF to download target files",
            "  securely are used and represented here as the 'signable' object.",
            "  More precisely, the signature structures contained within these metadata",
            "  files are packaged into 'signable' dictionaries.  This module makes it",
            "  possible to capture the states of these signatures by organizing the",
            "  keys into different categories.  As keys are added and removed, the",
            "  system must securely and efficiently verify the status of these signatures.",
            "  For instance, a bunch of keys have recently expired. How many valid keys",
            "  are now available to the Snapshot role?  This question can be answered by",
            "  get_signature_status(), which will return a full 'status report' of these",
            "  'signable' dicts.  This module also provides a convenient verify() function",
            "  that will determine if a role still has a sufficient number of valid keys.",
            "  If a caller needs to update the signatures of a 'signable' object, there",
            "  is also a function for that.",
            "\"\"\"",
            "",
            "# Help with Python 3 compatibility, where the print statement is a function, an",
            "# implicit relative import is invalid, and the '/' operator performs true",
            "# division.  Example:  print 'hello world' raises a 'SyntaxError' exception.",
            "from __future__ import print_function",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import unicode_literals",
            "",
            "import logging",
            "",
            "import tuf",
            "import tuf.keydb",
            "import tuf.roledb",
            "import tuf.formats",
            "",
            "import securesystemslib",
            "",
            "# See 'log.py' to learn how logging is handled in TUF.",
            "logger = logging.getLogger('tuf.sig')",
            "",
            "# Disable 'iso8601' logger messages to prevent 'iso8601' from clogging the",
            "# log file.",
            "iso8601_logger = logging.getLogger('iso8601')",
            "iso8601_logger.disabled = True",
            "",
            "",
            "def get_signature_status(signable, role=None, repository_name='default',",
            "    threshold=None, keyids=None):",
            "  \"\"\"",
            "  <Purpose>",
            "    Return a dictionary representing the status of the signatures listed in",
            "    'signable'.  Given an object conformant to SIGNABLE_SCHEMA, a set of public",
            "    keys in 'tuf.keydb', a set of roles in 'tuf.roledb', and a role,",
            "    the status of these signatures can be determined.  This method will iterate",
            "    the signatures in 'signable' and enumerate all the keys that are valid,",
            "    invalid, unrecognized, or unauthorized.",
            "",
            "  <Arguments>",
            "    signable:",
            "      A dictionary containing a list of signatures and a 'signed' identifier.",
            "      signable = {'signed': 'signer',",
            "                  'signatures': [{'keyid': keyid,",
            "                                  'sig': sig}]}",
            "",
            "      Conformant to tuf.formats.SIGNABLE_SCHEMA.",
            "",
            "    role:",
            "      TUF role (e.g., 'root', 'targets', 'snapshot').",
            "",
            "    threshold:",
            "      Rather than reference the role's threshold as set in tuf.roledb.py, use",
            "      the given 'threshold' to calculate the signature status of 'signable'.",
            "      'threshold' is an integer value that sets the role's threshold value, or",
            "      the minimum number of signatures needed for metadata to be considered",
            "      fully signed.",
            "",
            "    keyids:",
            "      Similar to the 'threshold' argument, use the supplied list of 'keyids'",
            "      to calculate the signature status, instead of referencing the keyids",
            "      in tuf.roledb.py for 'role'.",
            "",
            "  <Exceptions>",
            "    securesystemslib.exceptions.FormatError, if 'signable' does not have the",
            "    correct format.",
            "",
            "    tuf.exceptions.UnknownRoleError, if 'role' is not recognized.",
            "",
            "  <Side Effects>",
            "    None.",
            "",
            "  <Returns>",
            "    A dictionary representing the status of the signatures in 'signable'.",
            "    Conformant to tuf.formats.SIGNATURESTATUS_SCHEMA.",
            "  \"\"\"",
            "",
            "  # Do the arguments have the correct format?  This check will ensure that",
            "  # arguments have the appropriate number of objects and object types, and that",
            "  # all dict keys are properly named.  Raise",
            "  # 'securesystemslib.exceptions.FormatError' if the check fails.",
            "  tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
            "  securesystemslib.formats.NAME_SCHEMA.check_match(repository_name)",
            "",
            "  if role is not None:",
            "    tuf.formats.ROLENAME_SCHEMA.check_match(role)",
            "",
            "  if threshold is not None:",
            "    tuf.formats.THRESHOLD_SCHEMA.check_match(threshold)",
            "",
            "  if keyids is not None:",
            "    securesystemslib.formats.KEYIDS_SCHEMA.check_match(keyids)",
            "",
            "  # The signature status dictionary returned.",
            "  signature_status = {}",
            "",
            "  # The fields of the signature_status dict, where each field stores keyids.  A",
            "  # description of each field:",
            "  #",
            "  # good_sigs = keys confirmed to have produced 'sig' using 'signed', which are",
            "  # associated with 'role';",
            "  #",
            "  # bad_sigs = negation of good_sigs;",
            "  #",
            "  # unknown_sigs = keys not found in the 'keydb' database;",
            "  #",
            "  # untrusted_sigs = keys that are not in the list of keyids associated with",
            "  # 'role';",
            "  #",
            "  # unknown_signing_scheme = signing schemes specified in keys that are",
            "  # unsupported;",
            "  good_sigs = []",
            "  bad_sigs = []",
            "  unknown_sigs = []",
            "  untrusted_sigs = []",
            "  unknown_signing_schemes = []",
            "",
            "  # Extract the relevant fields from 'signable' that will allow us to identify",
            "  # the different classes of keys (i.e., good_sigs, bad_sigs, etc.).",
            "  signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')",
            "  signatures = signable['signatures']",
            "",
            "  # Iterate the signatures and enumerate the signature_status fields.",
            "  # (i.e., good_sigs, bad_sigs, etc.).",
            "  for signature in signatures:",
            "    keyid = signature['keyid']",
            "",
            "    # Does the signature use an unrecognized key?",
            "    try:",
            "      key = tuf.keydb.get_key(keyid, repository_name)",
            "",
            "    except tuf.exceptions.UnknownKeyError:",
            "      unknown_sigs.append(keyid)",
            "      continue",
            "",
            "    # Does the signature use an unknown/unsupported signing scheme?",
            "    try:",
            "      valid_sig = securesystemslib.keys.verify_signature(key, signature, signed)",
            "",
            "    except securesystemslib.exceptions.UnsupportedAlgorithmError:",
            "      unknown_signing_schemes.append(keyid)",
            "      continue",
            "",
            "    # We are now dealing with either a trusted or untrusted key...",
            "    if valid_sig:",
            "      if role is not None:",
            "",
            "        # Is this an unauthorized key? (a keyid associated with 'role')",
            "        # Note that if the role is not known, tuf.exceptions.UnknownRoleError",
            "        # is raised here.",
            "        if keyids is None:",
            "          keyids = tuf.roledb.get_role_keyids(role, repository_name)",
            "",
            "        if keyid not in keyids:",
            "          untrusted_sigs.append(keyid)",
            "          continue",
            "",
            "      # This is an unset role, thus an unknown signature.",
            "      else:",
            "        unknown_sigs.append(keyid)",
            "        continue",
            "",
            "      # Identify good/authorized key.",
            "      good_sigs.append(keyid)",
            "",
            "    else:",
            "      # This is a bad signature for a trusted key.",
            "      bad_sigs.append(keyid)",
            "",
            "  # Retrieve the threshold value for 'role'.  Raise",
            "  # tuf.exceptions.UnknownRoleError if we were given an invalid role.",
            "  if role is not None:",
            "    if threshold is None:",
            "      # Note that if the role is not known, tuf.exceptions.UnknownRoleError is",
            "      # raised here.",
            "      threshold = tuf.roledb.get_role_threshold(",
            "          role, repository_name=repository_name)",
            "",
            "    else:",
            "      logger.debug('Not using roledb.py\\'s threshold for ' + repr(role))",
            "",
            "  else:",
            "    threshold = 0",
            "",
            "  # Build the signature_status dict.",
            "  signature_status['threshold'] = threshold",
            "  signature_status['good_sigs'] = good_sigs",
            "  signature_status['bad_sigs'] = bad_sigs",
            "  signature_status['unknown_sigs'] = unknown_sigs",
            "  signature_status['untrusted_sigs'] = untrusted_sigs",
            "  signature_status['unknown_signing_schemes'] = unknown_signing_schemes",
            "",
            "  return signature_status",
            "",
            "",
            "",
            "",
            "",
            "def verify(signable, role, repository_name='default', threshold=None,",
            "    keyids=None):",
            "  \"\"\"",
            "  <Purpose>",
            "    Verify whether the authorized signatures of 'signable' meet the minimum",
            "    required by 'role'.  Authorized signatures are those with valid keys",
            "    associated with 'role'.  'signable' must conform to SIGNABLE_SCHEMA",
            "    and 'role' must not equal 'None' or be less than zero.",
            "",
            "  <Arguments>",
            "    signable:",
            "      A dictionary containing a list of signatures and a 'signed' identifier.",
            "      signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}",
            "",
            "    role:",
            "      TUF role (e.g., 'root', 'targets', 'snapshot').",
            "",
            "    threshold:",
            "      Rather than reference the role's threshold as set in tuf.roledb.py, use",
            "      the given 'threshold' to calculate the signature status of 'signable'.",
            "      'threshold' is an integer value that sets the role's threshold value, or",
            "      the minimum number of signatures needed for metadata to be considered",
            "      fully signed.",
            "",
            "    keyids:",
            "      Similar to the 'threshold' argument, use the supplied list of 'keyids'",
            "      to calculate the signature status, instead of referencing the keyids",
            "      in tuf.roledb.py for 'role'.",
            "",
            "  <Exceptions>",
            "    tuf.exceptions.UnknownRoleError, if 'role' is not recognized.",
            "",
            "    securesystemslib.exceptions.FormatError, if 'signable' is not formatted",
            "    correctly.",
            "",
            "    securesystemslib.exceptions.Error, if an invalid threshold is encountered.",
            "",
            "  <Side Effects>",
            "    tuf.sig.get_signature_status() called.  Any exceptions thrown by",
            "    get_signature_status() will be caught here and re-raised.",
            "",
            "  <Returns>",
            "    Boolean.  True if the number of good signatures >= the role's threshold,",
            "    False otherwise.",
            "  \"\"\"",
            "",
            "  tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
            "  tuf.formats.ROLENAME_SCHEMA.check_match(role)",
            "  securesystemslib.formats.NAME_SCHEMA.check_match(repository_name)",
            "",
            "  # Retrieve the signature status.  tuf.sig.get_signature_status() raises:",
            "  # tuf.exceptions.UnknownRoleError",
            "  # securesystemslib.exceptions.FormatError.  'threshold' and 'keyids' are also",
            "  # validated.",
            "  status = get_signature_status(signable, role, repository_name, threshold, keyids)",
            "",
            "  # Retrieve the role's threshold and the authorized keys of 'status'",
            "  threshold = status['threshold']",
            "  good_sigs = status['good_sigs']",
            "",
            "  # Does 'status' have the required threshold of signatures?",
            "  # First check for invalid threshold values before returning result.",
            "  # Note: get_signature_status() is expected to verify that 'threshold' is",
            "  # not None or <= 0.",
            "  if threshold is None or threshold <= 0: #pragma: no cover",
            "    raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
            "",
            "  return len(good_sigs) >= threshold",
            "",
            "",
            "",
            "",
            "",
            "def may_need_new_keys(signature_status):",
            "  \"\"\"",
            "  <Purpose>",
            "    Return true iff downloading a new set of keys might tip this",
            "    signature status over to valid.  This is determined by checking",
            "    if either the number of unknown or untrusted keys is > 0.",
            "",
            "  <Arguments>",
            "    signature_status:",
            "      The dictionary returned by tuf.sig.get_signature_status().",
            "",
            "  <Exceptions>",
            "    securesystemslib.exceptions.FormatError, if 'signature_status does not have",
            "    the correct format.",
            "",
            "  <Side Effects>",
            "    None.",
            "",
            "  <Returns>",
            "    Boolean.",
            "  \"\"\"",
            "",
            "  # Does 'signature_status' have the correct format?",
            "  # This check will ensure 'signature_status' has the appropriate number",
            "  # of objects and object types, and that all dict keys are properly named.",
            "  # Raise 'securesystemslib.exceptions.FormatError' if the check fails.",
            "  tuf.formats.SIGNATURESTATUS_SCHEMA.check_match(signature_status)",
            "",
            "  unknown = signature_status['unknown_sigs']",
            "  untrusted = signature_status['untrusted_sigs']",
            "",
            "  return len(unknown) or len(untrusted)",
            "",
            "",
            "",
            "",
            "",
            "def generate_rsa_signature(signed, rsakey_dict):",
            "  \"\"\"",
            "  <Purpose>",
            "    Generate a new signature dict presumably to be added to the 'signatures'",
            "    field of 'signable'.  The 'signable' dict is of the form:",
            "",
            "    {'signed': 'signer',",
            "               'signatures': [{'keyid': keyid,",
            "                               'method': 'evp',",
            "                               'sig': sig}]}",
            "",
            "    The 'signed' argument is needed here for the signing process.",
            "    The 'rsakey_dict' argument is used to generate 'keyid', 'method', and 'sig'.",
            "",
            "    The caller should ensure the returned signature is not already in",
            "    'signable'.",
            "",
            "  <Arguments>",
            "    signed:",
            "      The data used by 'securesystemslib.keys.create_signature()' to generate",
            "      signatures.  It is stored in the 'signed' field of 'signable'.",
            "",
            "    rsakey_dict:",
            "      The RSA key, a 'securesystemslib.formats.RSAKEY_SCHEMA' dictionary.",
            "      Used here to produce 'keyid', 'method', and 'sig'.",
            "",
            "  <Exceptions>",
            "    securesystemslib.exceptions.FormatError, if 'rsakey_dict' does not have the",
            "    correct format.",
            "",
            "    TypeError, if a private key is not defined for 'rsakey_dict'.",
            "",
            "  <Side Effects>",
            "    None.",
            "",
            "  <Returns>",
            "    Signature dictionary conformant to securesystemslib.formats.SIGNATURE_SCHEMA.",
            "    Has the form:",
            "    {'keyid': keyid, 'method': 'evp', 'sig': sig}",
            "  \"\"\"",
            "",
            "  # We need 'signed' in canonical JSON format to generate",
            "  # the 'method' and 'sig' fields of the signature.",
            "  signed = securesystemslib.formats.encode_canonical(signed).encode('utf-8')",
            "",
            "  # Generate the RSA signature.",
            "  # Raises securesystemslib.exceptions.FormatError and TypeError.",
            "  signature = securesystemslib.keys.create_signature(rsakey_dict, signed)",
            "",
            "  return signature"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "",
            "# Copyright 2012 - 2017, New York University and the TUF contributors",
            "# SPDX-License-Identifier: MIT OR Apache-2.0",
            "",
            "\"\"\"",
            "<Program Name>",
            "  sig.py",
            "",
            "<Author>",
            "  Vladimir Diaz <vladimir.v.diaz@gmail.com>",
            "",
            "<Started>",
            "  February 28, 2012.   Based on a previous version by Geremy Condra.",
            "",
            "<Copyright>",
            "  See LICENSE-MIT OR LICENSE for licensing information.",
            "",
            "<Purpose>",
            "  Survivable key compromise is one feature of a secure update system",
            "  incorporated into TUF's design. Responsibility separation through",
            "  the use of multiple roles, multi-signature trust, and explicit and",
            "  implicit key revocation are some of the mechanisms employed towards",
            "  this goal of survivability.  These mechanisms can all be seen in",
            "  play by the functions available in this module.",
            "",
            "  The signed metadata files utilized by TUF to download target files",
            "  securely are used and represented here as the 'signable' object.",
            "  More precisely, the signature structures contained within these metadata",
            "  files are packaged into 'signable' dictionaries.  This module makes it",
            "  possible to capture the states of these signatures by organizing the",
            "  keys into different categories.  As keys are added and removed, the",
            "  system must securely and efficiently verify the status of these signatures.",
            "  For instance, a bunch of keys have recently expired. How many valid keys",
            "  are now available to the Snapshot role?  This question can be answered by",
            "  get_signature_status(), which will return a full 'status report' of these",
            "  'signable' dicts.  This module also provides a convenient verify() function",
            "  that will determine if a role still has a sufficient number of valid keys.",
            "  If a caller needs to update the signatures of a 'signable' object, there",
            "  is also a function for that.",
            "\"\"\"",
            "",
            "# Help with Python 3 compatibility, where the print statement is a function, an",
            "# implicit relative import is invalid, and the '/' operator performs true",
            "# division.  Example:  print 'hello world' raises a 'SyntaxError' exception.",
            "from __future__ import print_function",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import unicode_literals",
            "",
            "import logging",
            "",
            "import tuf",
            "import tuf.keydb",
            "import tuf.roledb",
            "import tuf.formats",
            "",
            "import securesystemslib",
            "",
            "# See 'log.py' to learn how logging is handled in TUF.",
            "logger = logging.getLogger('tuf.sig')",
            "",
            "# Disable 'iso8601' logger messages to prevent 'iso8601' from clogging the",
            "# log file.",
            "iso8601_logger = logging.getLogger('iso8601')",
            "iso8601_logger.disabled = True",
            "",
            "",
            "def get_signature_status(signable, role=None, repository_name='default',",
            "    threshold=None, keyids=None):",
            "  \"\"\"",
            "  <Purpose>",
            "    Return a dictionary representing the status of the signatures listed in",
            "    'signable'. Signatures in the returned dictionary are identified by the",
            "    signature keyid and can have a status of either:",
            "",
            "    * bad -- Invalid signature",
            "    * good -- Valid signature from key that is available in 'tuf.keydb', and is",
            "      authorized for the passed role as per 'tuf.roledb' (authorization may be",
            "      overwritten by passed 'keyids').",
            "    * unknown -- Signature from key that is not available in 'tuf.keydb'.",
            "    * unknown signing schemes -- Signature from key with unknown signing",
            "      scheme.",
            "    * untrusted -- Valid signature from key that is available in 'tuf.keydb',",
            "      but is not trusted for the passed role as per 'tuf.roledb' or the passed",
            "      'keyids'.",
            "",
            "    NOTE: The result may contain duplicate keyids or keyids that reference the",
            "    same key, if 'signable' lists multiple signatures from the same key.",
            "",
            "  <Arguments>",
            "    signable:",
            "      A dictionary containing a list of signatures and a 'signed' identifier.",
            "      signable = {'signed': 'signer',",
            "                  'signatures': [{'keyid': keyid,",
            "                                  'sig': sig}]}",
            "",
            "      Conformant to tuf.formats.SIGNABLE_SCHEMA.",
            "",
            "    role:",
            "      TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
            "",
            "    threshold:",
            "      Rather than reference the role's threshold as set in tuf.roledb.py, use",
            "      the given 'threshold' to calculate the signature status of 'signable'.",
            "      'threshold' is an integer value that sets the role's threshold value, or",
            "      the minimum number of signatures needed for metadata to be considered",
            "      fully signed.",
            "",
            "    keyids:",
            "      Similar to the 'threshold' argument, use the supplied list of 'keyids'",
            "      to calculate the signature status, instead of referencing the keyids",
            "      in tuf.roledb.py for 'role'.",
            "",
            "  <Exceptions>",
            "    securesystemslib.exceptions.FormatError, if 'signable' does not have the",
            "    correct format.",
            "",
            "    tuf.exceptions.UnknownRoleError, if 'role' is not recognized.",
            "",
            "  <Side Effects>",
            "    None.",
            "",
            "  <Returns>",
            "    A dictionary representing the status of the signatures in 'signable'.",
            "    Conformant to tuf.formats.SIGNATURESTATUS_SCHEMA.",
            "  \"\"\"",
            "",
            "  # Do the arguments have the correct format?  This check will ensure that",
            "  # arguments have the appropriate number of objects and object types, and that",
            "  # all dict keys are properly named.  Raise",
            "  # 'securesystemslib.exceptions.FormatError' if the check fails.",
            "  tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
            "  securesystemslib.formats.NAME_SCHEMA.check_match(repository_name)",
            "",
            "  if role is not None:",
            "    tuf.formats.ROLENAME_SCHEMA.check_match(role)",
            "",
            "  if threshold is not None:",
            "    tuf.formats.THRESHOLD_SCHEMA.check_match(threshold)",
            "",
            "  if keyids is not None:",
            "    securesystemslib.formats.KEYIDS_SCHEMA.check_match(keyids)",
            "",
            "  # The signature status dictionary returned.",
            "  signature_status = {}",
            "  good_sigs = []",
            "  bad_sigs = []",
            "  unknown_sigs = []",
            "  untrusted_sigs = []",
            "  unknown_signing_schemes = []",
            "",
            "  # Extract the relevant fields from 'signable' that will allow us to identify",
            "  # the different classes of keys (i.e., good_sigs, bad_sigs, etc.).",
            "  signed = securesystemslib.formats.encode_canonical(signable['signed']).encode('utf-8')",
            "  signatures = signable['signatures']",
            "",
            "  # Iterate the signatures and enumerate the signature_status fields.",
            "  # (i.e., good_sigs, bad_sigs, etc.).",
            "  for signature in signatures:",
            "    keyid = signature['keyid']",
            "",
            "    # Does the signature use an unrecognized key?",
            "    try:",
            "      key = tuf.keydb.get_key(keyid, repository_name)",
            "",
            "    except tuf.exceptions.UnknownKeyError:",
            "      unknown_sigs.append(keyid)",
            "      continue",
            "",
            "    # Does the signature use an unknown/unsupported signing scheme?",
            "    try:",
            "      valid_sig = securesystemslib.keys.verify_signature(key, signature, signed)",
            "",
            "    except securesystemslib.exceptions.UnsupportedAlgorithmError:",
            "      unknown_signing_schemes.append(keyid)",
            "      continue",
            "",
            "    # We are now dealing with either a trusted or untrusted key...",
            "    if valid_sig:",
            "      if role is not None:",
            "",
            "        # Is this an unauthorized key? (a keyid associated with 'role')",
            "        # Note that if the role is not known, tuf.exceptions.UnknownRoleError",
            "        # is raised here.",
            "        if keyids is None:",
            "          keyids = tuf.roledb.get_role_keyids(role, repository_name)",
            "",
            "        if keyid not in keyids:",
            "          untrusted_sigs.append(keyid)",
            "          continue",
            "",
            "      # This is an unset role, thus an unknown signature.",
            "      else:",
            "        unknown_sigs.append(keyid)",
            "        continue",
            "",
            "      # Identify good/authorized key.",
            "      good_sigs.append(keyid)",
            "",
            "    else:",
            "      # This is a bad signature for a trusted key.",
            "      bad_sigs.append(keyid)",
            "",
            "  # Retrieve the threshold value for 'role'.  Raise",
            "  # tuf.exceptions.UnknownRoleError if we were given an invalid role.",
            "  if role is not None:",
            "    if threshold is None:",
            "      # Note that if the role is not known, tuf.exceptions.UnknownRoleError is",
            "      # raised here.",
            "      threshold = tuf.roledb.get_role_threshold(",
            "          role, repository_name=repository_name)",
            "",
            "    else:",
            "      logger.debug('Not using roledb.py\\'s threshold for ' + repr(role))",
            "",
            "  else:",
            "    threshold = 0",
            "",
            "  # Build the signature_status dict.",
            "  signature_status['threshold'] = threshold",
            "  signature_status['good_sigs'] = good_sigs",
            "  signature_status['bad_sigs'] = bad_sigs",
            "  signature_status['unknown_sigs'] = unknown_sigs",
            "  signature_status['untrusted_sigs'] = untrusted_sigs",
            "  signature_status['unknown_signing_schemes'] = unknown_signing_schemes",
            "",
            "  return signature_status",
            "",
            "",
            "",
            "",
            "",
            "def verify(signable, role, repository_name='default', threshold=None,",
            "    keyids=None):",
            "  \"\"\"",
            "  <Purpose>",
            "    Verify that 'signable' has a valid threshold of authorized signatures",
            "    identified by unique keyids. The threshold and whether a keyid is",
            "    authorized is determined by querying the 'threshold' and 'keyids' info for",
            "    the passed 'role' in 'tuf.roledb'. Both values can be overwritten by",
            "    passing the 'threshold' or 'keyids' arguments.",
            "",
            "    NOTE:",
            "    - Signatures with identical authorized keyids only count towards the",
            "      threshold once.",
            "    - Signatures with different authorized keyids each count towards the",
            "      threshold, even if the keyids identify the same key.",
            "",
            "  <Arguments>",
            "    signable:",
            "      A dictionary containing a list of signatures and a 'signed' identifier",
            "      that conforms to SIGNABLE_SCHEMA, e.g.:",
            "      signable = {'signed':, 'signatures': [{'keyid':, 'method':, 'sig':}]}",
            "",
            "    role:",
            "      TUF role string (e.g. 'root', 'targets', 'snapshot' or timestamp).",
            "",
            "    threshold:",
            "      Rather than reference the role's threshold as set in tuf.roledb.py, use",
            "      the given 'threshold' to calculate the signature status of 'signable'.",
            "      'threshold' is an integer value that sets the role's threshold value, or",
            "      the minimum number of signatures needed for metadata to be considered",
            "      fully signed.",
            "",
            "    keyids:",
            "      Similar to the 'threshold' argument, use the supplied list of 'keyids'",
            "      to calculate the signature status, instead of referencing the keyids",
            "      in tuf.roledb.py for 'role'.",
            "",
            "  <Exceptions>",
            "    tuf.exceptions.UnknownRoleError, if 'role' is not recognized.",
            "",
            "    securesystemslib.exceptions.FormatError, if 'signable' is not formatted",
            "    correctly.",
            "",
            "    securesystemslib.exceptions.Error, if an invalid threshold is encountered.",
            "",
            "  <Side Effects>",
            "    tuf.sig.get_signature_status() called.  Any exceptions thrown by",
            "    get_signature_status() will be caught here and re-raised.",
            "",
            "  <Returns>",
            "    Boolean.  True if the number of good unique (by keyid) signatures >= the",
            "    role's threshold, False otherwise.",
            "  \"\"\"",
            "",
            "  tuf.formats.SIGNABLE_SCHEMA.check_match(signable)",
            "  tuf.formats.ROLENAME_SCHEMA.check_match(role)",
            "  securesystemslib.formats.NAME_SCHEMA.check_match(repository_name)",
            "",
            "  # Retrieve the signature status.  tuf.sig.get_signature_status() raises:",
            "  # tuf.exceptions.UnknownRoleError",
            "  # securesystemslib.exceptions.FormatError.  'threshold' and 'keyids' are also",
            "  # validated.",
            "  status = get_signature_status(signable, role, repository_name, threshold, keyids)",
            "",
            "  # Retrieve the role's threshold and the authorized keys of 'status'",
            "  threshold = status['threshold']",
            "  good_sigs = status['good_sigs']",
            "",
            "  # Does 'status' have the required threshold of signatures?",
            "  # First check for invalid threshold values before returning result.",
            "  # Note: get_signature_status() is expected to verify that 'threshold' is",
            "  # not None or <= 0.",
            "  if threshold is None or threshold <= 0: #pragma: no cover",
            "    raise securesystemslib.exceptions.Error(\"Invalid threshold: \" + repr(threshold))",
            "",
            "  return len(set(good_sigs)) >= threshold",
            "",
            "",
            "",
            "",
            "",
            "def may_need_new_keys(signature_status):",
            "  \"\"\"",
            "  <Purpose>",
            "    Return true iff downloading a new set of keys might tip this",
            "    signature status over to valid.  This is determined by checking",
            "    if either the number of unknown or untrusted keys is > 0.",
            "",
            "  <Arguments>",
            "    signature_status:",
            "      The dictionary returned by tuf.sig.get_signature_status().",
            "",
            "  <Exceptions>",
            "    securesystemslib.exceptions.FormatError, if 'signature_status does not have",
            "    the correct format.",
            "",
            "  <Side Effects>",
            "    None.",
            "",
            "  <Returns>",
            "    Boolean.",
            "  \"\"\"",
            "",
            "  # Does 'signature_status' have the correct format?",
            "  # This check will ensure 'signature_status' has the appropriate number",
            "  # of objects and object types, and that all dict keys are properly named.",
            "  # Raise 'securesystemslib.exceptions.FormatError' if the check fails.",
            "  tuf.formats.SIGNATURESTATUS_SCHEMA.check_match(signature_status)",
            "",
            "  unknown = signature_status['unknown_sigs']",
            "  untrusted = signature_status['untrusted_sigs']",
            "",
            "  return len(unknown) or len(untrusted)",
            "",
            "",
            "",
            "",
            "",
            "def generate_rsa_signature(signed, rsakey_dict):",
            "  \"\"\"",
            "  <Purpose>",
            "    Generate a new signature dict presumably to be added to the 'signatures'",
            "    field of 'signable'.  The 'signable' dict is of the form:",
            "",
            "    {'signed': 'signer',",
            "               'signatures': [{'keyid': keyid,",
            "                               'method': 'evp',",
            "                               'sig': sig}]}",
            "",
            "    The 'signed' argument is needed here for the signing process.",
            "    The 'rsakey_dict' argument is used to generate 'keyid', 'method', and 'sig'.",
            "",
            "    The caller should ensure the returned signature is not already in",
            "    'signable'.",
            "",
            "  <Arguments>",
            "    signed:",
            "      The data used by 'securesystemslib.keys.create_signature()' to generate",
            "      signatures.  It is stored in the 'signed' field of 'signable'.",
            "",
            "    rsakey_dict:",
            "      The RSA key, a 'securesystemslib.formats.RSAKEY_SCHEMA' dictionary.",
            "      Used here to produce 'keyid', 'method', and 'sig'.",
            "",
            "  <Exceptions>",
            "    securesystemslib.exceptions.FormatError, if 'rsakey_dict' does not have the",
            "    correct format.",
            "",
            "    TypeError, if a private key is not defined for 'rsakey_dict'.",
            "",
            "  <Side Effects>",
            "    None.",
            "",
            "  <Returns>",
            "    Signature dictionary conformant to securesystemslib.formats.SIGNATURE_SCHEMA.",
            "    Has the form:",
            "    {'keyid': keyid, 'method': 'evp', 'sig': sig}",
            "  \"\"\"",
            "",
            "  # We need 'signed' in canonical JSON format to generate",
            "  # the 'method' and 'sig' fields of the signature.",
            "  signed = securesystemslib.formats.encode_canonical(signed).encode('utf-8')",
            "",
            "  # Generate the RSA signature.",
            "  # Raises securesystemslib.exceptions.FormatError and TypeError.",
            "  signature = securesystemslib.keys.create_signature(rsakey_dict, signed)",
            "",
            "  return signature"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "74": [
                "get_signature_status"
            ],
            "75": [
                "get_signature_status"
            ],
            "76": [
                "get_signature_status"
            ],
            "77": [
                "get_signature_status"
            ],
            "78": [
                "get_signature_status"
            ],
            "90": [
                "get_signature_status"
            ],
            "136": [
                "get_signature_status"
            ],
            "137": [
                "get_signature_status"
            ],
            "138": [
                "get_signature_status"
            ],
            "139": [
                "get_signature_status"
            ],
            "140": [
                "get_signature_status"
            ],
            "141": [
                "get_signature_status"
            ],
            "142": [
                "get_signature_status"
            ],
            "143": [
                "get_signature_status"
            ],
            "144": [
                "get_signature_status"
            ],
            "145": [
                "get_signature_status"
            ],
            "146": [
                "get_signature_status"
            ],
            "147": [
                "get_signature_status"
            ],
            "148": [
                "get_signature_status"
            ],
            "149": [
                "get_signature_status"
            ],
            "150": [
                "get_signature_status"
            ],
            "151": [
                "get_signature_status"
            ],
            "243": [
                "verify"
            ],
            "244": [
                "verify"
            ],
            "245": [
                "verify"
            ],
            "246": [
                "verify"
            ],
            "250": [
                "verify"
            ],
            "254": [
                "verify"
            ],
            "281": [
                "verify"
            ],
            "282": [
                "verify"
            ],
            "306": [
                "verify"
            ]
        },
        "addLocation": []
    }
}