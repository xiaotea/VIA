{
    "yaql/standard_library/strings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 564,
                "PatchRowcode": "     return string"
            },
            "1": {
                "beforePatchRowNumber": 565,
                "afterPatchRowNumber": 565,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 566,
                "afterPatchRowNumber": 566,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 567,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@specs.parameter('__format_string', yaqltypes.String())"
            },
            "4": {
                "beforePatchRowNumber": 568,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@specs.extension_method"
            },
            "5": {
                "beforePatchRowNumber": 569,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def format_(__format_string, *args, **kwargs):"
            },
            "6": {
                "beforePatchRowNumber": 570,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\":yaql:format"
            },
            "7": {
                "beforePatchRowNumber": 571,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "8": {
                "beforePatchRowNumber": 572,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Returns a string formatted with positional and keyword arguments."
            },
            "9": {
                "beforePatchRowNumber": 573,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "10": {
                "beforePatchRowNumber": 574,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :signature: string.format([args], {kwargs})"
            },
            "11": {
                "beforePatchRowNumber": 575,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :receiverArg string: input string for formatting. Can be passed only as"
            },
            "12": {
                "beforePatchRowNumber": 576,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        first positional argument if used as a function. Can contain literal"
            },
            "13": {
                "beforePatchRowNumber": 577,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        text or replacement fields marked by braces {}. Every replacement field"
            },
            "14": {
                "beforePatchRowNumber": 578,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        should contain either the numeric index of a positional argument or the"
            },
            "15": {
                "beforePatchRowNumber": 579,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        name of a keyword argument"
            },
            "16": {
                "beforePatchRowNumber": 580,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :argType string: string"
            },
            "17": {
                "beforePatchRowNumber": 581,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :arg [args]: values for replacements for numeric markers"
            },
            "18": {
                "beforePatchRowNumber": 582,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :argType [args]: chain of strings"
            },
            "19": {
                "beforePatchRowNumber": 583,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :arg {kwargs}: values for keyword replacements"
            },
            "20": {
                "beforePatchRowNumber": 584,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :argType {kwargs}: chain of key-value arguments, where values are strings"
            },
            "21": {
                "beforePatchRowNumber": 585,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :returnValue: string"
            },
            "22": {
                "beforePatchRowNumber": 586,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "23": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    .. code::"
            },
            "24": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "25": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        yaql> \"abc{0}ab{1}abc\".format(\" \", \",\")"
            },
            "26": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"abc ab,abc\""
            },
            "27": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        yaql> \"abc{foo}ab{bar}abc\".format(foo => \" \", bar => \",\")"
            },
            "28": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"abc ab,abc\""
            },
            "29": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        yaql> format(\"abc{0}ab{foo}abc\", ' ', foo => \",\")"
            },
            "30": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"abc ab,abc\""
            },
            "31": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "32": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return __format_string.format(*args, **kwargs)"
            },
            "33": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "34": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "35": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": 567,
                "PatchRowcode": " @specs.parameter('left', yaqltypes.String())"
            },
            "36": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 568,
                "PatchRowcode": " @specs.parameter('right', int)"
            },
            "37": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": 569,
                "PatchRowcode": " @specs.name('#operator_*')"
            },
            "38": {
                "beforePatchRowNumber": 1045,
                "afterPatchRowNumber": 1013,
                "PatchRowcode": "     context.register_function(trim_right)"
            },
            "39": {
                "beforePatchRowNumber": 1046,
                "afterPatchRowNumber": 1014,
                "PatchRowcode": "     context.register_function(replace)"
            },
            "40": {
                "beforePatchRowNumber": 1047,
                "afterPatchRowNumber": 1015,
                "PatchRowcode": "     context.register_function(replace_with_dict)"
            },
            "41": {
                "beforePatchRowNumber": 1048,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    context.register_function(format_)"
            },
            "42": {
                "beforePatchRowNumber": 1049,
                "afterPatchRowNumber": 1016,
                "PatchRowcode": "     context.register_function(is_empty)"
            },
            "43": {
                "beforePatchRowNumber": 1050,
                "afterPatchRowNumber": 1017,
                "PatchRowcode": "     context.register_function(string_by_int)"
            },
            "44": {
                "beforePatchRowNumber": 1051,
                "afterPatchRowNumber": 1018,
                "PatchRowcode": "     context.register_function(int_by_string)"
            }
        },
        "frontPatchFile": [
            "#    Copyright (c) 2015 Mirantis, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "The module describes which operations can be done with strings in YAQL.",
            "\"\"\"",
            "",
            "import string as string_module",
            "",
            "from yaql.language import specs",
            "from yaql.language import utils",
            "from yaql.language import yaqltypes",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_>')",
            "def gt(left, right):",
            "    \"\"\":yaql:operator >",
            "",
            "    Returns true if the left operand is strictly greater than the right,",
            "    ordering lexicographically, otherwise false.",
            "",
            "    :signature: left > right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc\" > \"ab\"",
            "        true",
            "        yaql> \"abc\" > \"abb\"",
            "        true",
            "        yaql> \"abc\" > \"abc\"",
            "        false",
            "    \"\"\"",
            "    return left > right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_<')",
            "def lt(left, right):",
            "    \"\"\":yaql:operator <",
            "",
            "    Returns true if the left operand is strictly less than the right, ordering",
            "    lexicographically, otherwise false.",
            "",
            "    :signature: left < right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" < \"abc\"",
            "        true",
            "        yaql> \"abb\" < \"abc\"",
            "        true",
            "        yaql> \"abc\" < \"abc\"",
            "        false",
            "    \"\"\"",
            "    return left < right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_>=')",
            "def gte(left, right):",
            "    \"\"\":yaql:operator >=",
            "",
            "    Returns true if the left operand is greater or equal to the right, ordering",
            "    lexicographically, otherwise false.",
            "",
            "    :signature: left >= right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc\" >= \"ab\"",
            "        true",
            "        yaql> \"abc\" >= \"abc\"",
            "        true",
            "    \"\"\"",
            "    return left >= right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_<=')",
            "def lte(left, right):",
            "    \"\"\":yaql:operator <=",
            "",
            "    Returns true if the left operand is less or equal to the right, ordering",
            "    lexicographically, otherwise false.",
            "",
            "    :signature: left <= right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" <= \"abc\"",
            "        true",
            "        yaql> \"abc\" <= \"abc\"",
            "        true",
            "    \"\"\"",
            "    return left <= right",
            "",
            "",
            "@specs.parameter('args', yaqltypes.String())",
            "def concat(*args):",
            "    \"\"\":yaql:concat",
            "",
            "    Returns concatenated args.",
            "",
            "    :signature: concat([args])",
            "    :arg [args]: values to be joined",
            "    :argType [args]: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> concat(\"abc\", \"de\", \"f\")",
            "        \"abcdef\"",
            "    \"\"\"",
            "    return ''.join(args)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.method",
            "def to_upper(string):",
            "    \"\"\":yaql:toUpper",
            "",
            "    Returns a string with all case-based characters uppercase.",
            "",
            "    :signature: string.toUpper()",
            "    :receiverArg string: value to uppercase",
            "    :argType string: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"aB1c\".toUpper()",
            "        \"AB1C\"",
            "    \"\"\"",
            "    return string.upper()",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.extension_method",
            "def len_(string):",
            "    \"\"\":yaql:len",
            "",
            "    Returns size of the string.",
            "",
            "    :signature: string.len()",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc\".len()",
            "        3",
            "    \"\"\"",
            "    return len(string)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.method",
            "def to_lower(string):",
            "    \"\"\":yaql:toLower",
            "",
            "    Returns a string with all case-based characters lowercase.",
            "",
            "    :signature: string.toLower()",
            "    :receiverArg string: value to lowercase",
            "    :argType string: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"AB1c\".toLower()",
            "        \"ab1c\"",
            "    \"\"\"",
            "    return string.lower()",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('separator', yaqltypes.String(nullable=True))",
            "@specs.parameter('max_splits', int)",
            "@specs.method",
            "def split(string, separator=None, max_splits=-1):",
            "    \"\"\":yaql:split",
            "",
            "    Returns a list of tokens in the string, using separator as the",
            "    delimiter.",
            "",
            "    :signature: string.split(separator => null, maxSplits => -1)",
            "    :receiverArg string: value to be splitted",
            "    :argType string: string",
            "    :arg separator: delimiter for splitting. null by default, which means",
            "        splitting with whitespace characters",
            "    :argType separator: string",
            "    :arg maxSplits: maximum number of splittings. -1 by default, which means",
            "        all possible splits are done",
            "    :argType maxSplits: integer",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc     de  f\".split()",
            "        [\"abc\", \"de\", \"f\"]",
            "        yaql> \"abc     de  f\".split(maxSplits => 1)",
            "        [\"abc\", \"de  f\"]",
            "        yaql> \"abcde\".split(\"c\")",
            "        [\"ab\", \"de\"]",
            "    \"\"\"",
            "    return string.split(separator, max_splits)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('separator', yaqltypes.String(nullable=True))",
            "@specs.parameter('max_splits', int)",
            "@specs.method",
            "def right_split(string, separator=None, max_splits=-1):",
            "    \"\"\":yaql:rightSplit",
            "",
            "    Returns a list of tokens in the string, using separator as the",
            "    delimiter. If maxSplits is given then at most maxSplits splits are done -",
            "    the rightmost ones.",
            "",
            "    :signature: string.rightSplit(separator => null, maxSplits => -1)",
            "    :receiverArg string: value to be splitted",
            "    :argType string: string",
            "    :arg separator: delimiter for splitting. null by default, which means",
            "        splitting with whitespace characters",
            "    :argType separator: string",
            "    :arg maxSplits: number of splits to be done - the rightmost ones.",
            "        -1 by default, which means all possible splits are done",
            "    :argType maxSplits: integer",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc     de  f\".rightSplit()",
            "        [\"abc\", \"de\", \"f\"]",
            "        yaql> \"abc     de  f\".rightSplit(maxSplits => 1)",
            "        [\"abc     de\", \"f\"]",
            "    \"\"\"",
            "    return string.rsplit(separator, max_splits)",
            "",
            "",
            "@specs.parameter('sequence', yaqltypes.Iterable())",
            "@specs.parameter('separator', yaqltypes.String())",
            "@specs.inject('str_delegate', yaqltypes.Delegate('str'))",
            "@specs.method",
            "def join(sequence, separator, str_delegate):",
            "    \"\"\":yaql:join",
            "",
            "    Returns a string with sequence elements joined by the separator.",
            "",
            "    :signature: sequence.join(separator)",
            "    :receiverArg sequence: chain of values to be joined",
            "    :argType sequence: sequence of strings",
            "    :arg separator: value to be placed between joined pairs",
            "    :argType separator: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> [\"abc\", \"de\", \"f\"].join(\"\")",
            "        \"abcdef\"",
            "        yaql> [\"abc\", \"de\", \"f\"].join(\"|\")",
            "        \"abc|de|f\"",
            "    \"\"\"",
            "    return separator.join(map(str_delegate, sequence))",
            "",
            "",
            "@specs.parameter('sequence', yaqltypes.Iterable())",
            "@specs.parameter('separator', yaqltypes.String())",
            "@specs.inject('str_delegate', yaqltypes.Delegate('str'))",
            "@specs.method",
            "def join_(separator, sequence, str_delegate):",
            "    \"\"\":yaql:join",
            "",
            "    Returns a string with sequence elements joined by the separator.",
            "",
            "    :signature: separator.join(sequence)",
            "    :receiverArg separator: value to be placed between joined pairs",
            "    :argType separator: string",
            "    :arg sequence: chain of values to be joined",
            "    :argType sequence: sequence of strings",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"|\".join([\"abc\", \"de\", \"f\"])",
            "        \"abc|de|f\"",
            "    \"\"\"",
            "    return join(sequence, separator, str_delegate)",
            "",
            "",
            "@specs.parameter('value', nullable=True)",
            "def str_(value):",
            "    \"\"\":yaql:str",
            "",
            "    Returns a string representation of the value.",
            "",
            "    :signature: str(value)",
            "    :arg value: value to be evaluated to string",
            "    :argType value: any",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> str([\"abc\", \"de\"])",
            "        \"(u'abc', u'd')\"",
            "        yaql> str(123)",
            "        \"123\"",
            "    \"\"\"",
            "    if value is None:",
            "        return 'null'",
            "    elif value is True:",
            "        return 'true'",
            "    elif value is False:",
            "        return 'false'",
            "    else:",
            "        return str(value)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.method",
            "def trim(string, chars=None):",
            "    \"\"\":yaql:trim",
            "",
            "    Returns a string with the leading and trailing chars removed.",
            "",
            "    :signature: string.trim(chars => null)",
            "    :receiverArg string: value to be trimmed",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from input string. null by default,",
            "        which means trim is done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".trim()",
            "        \"abcd\"",
            "        yaql> \"aababa\".trim(\"a\")",
            "        \"bab\"",
            "    \"\"\"",
            "    return string.strip(chars)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.method",
            "def trim_left(string, chars=None):",
            "    \"\"\":yaql:trimLeft",
            "",
            "    Returns a string with the leading chars removed.",
            "",
            "    :signature: string.trimLeft(chars => null)",
            "    :receiverArg string: value to be trimmed",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from start of input string. null by",
            "        default, which means trim is done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".trimLeft()",
            "        \"abcd \"",
            "        yaql> \"aababa\".trimLeft(\"a\")",
            "        \"baba\"",
            "    \"\"\"",
            "    return string.lstrip(chars)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.method",
            "def trim_right(string, chars=None):",
            "    \"\"\":yaql:trimRight",
            "",
            "    Returns a string with the trailing chars removed.",
            "",
            "    :signature: string.trimRight(chars => null)",
            "    :receiverArg string: value to be trimmed",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from end of input string. null by",
            "        default, which means trim is done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".trimRight()",
            "        \"  abcd\"",
            "        yaql> \"aababa\".trimRight(\"a\")",
            "        \"aabab\"",
            "    \"\"\"",
            "    return string.rstrip(chars)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String(nullable=True))",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.extension_method",
            "def norm(string, chars=None):",
            "    \"\"\":yaql:norm",
            "",
            "    Returns a string with the leading and trailing chars removed.",
            "    If the resulting string is empty, returns null.",
            "",
            "    :signature: string.norm(chars => null)",
            "    :receiverArg string: value to be cut with specified chars",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from the start and the end of input",
            "        string. null by default, which means norm is done with whitespace",
            "        characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".norm()",
            "        \"abcd\"",
            "        yaql> \"aaaa\".norm(\"a\")",
            "        null",
            "    \"\"\"",
            "    if string is None:",
            "        return None",
            "    value = string.strip(chars)",
            "    return None if not value else value",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String(nullable=True))",
            "@specs.parameter('trim_spaces', bool, alias='trim')",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.extension_method",
            "def is_empty(string, trim_spaces=True, chars=None):",
            "    \"\"\":yaql:isEmpty",
            "",
            "    Returns true if the string with removed leading and trailing chars is",
            "    empty.",
            "",
            "    :signature: string.isEmpty(trimSpaces => true, chars => null)",
            "    :receiverArg string: value to be checked for emptiness after trim",
            "    :argType string: string",
            "    :arg trimSpaces: true by default, which means string to be trimmed with",
            "        chars. false means checking whether input string is empty",
            "    :argType trimSpaces: boolean",
            "    :arg chars: symbols for trimming. null by default, which means trim is",
            "        done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abaab\".isEmpty(chars=>\"ab\")",
            "        true",
            "        yaql> \"aba\".isEmpty(chars=>\"a\")",
            "        false",
            "    \"\"\"",
            "    if string is None:",
            "        return True",
            "    if trim_spaces:",
            "        string = string.strip(chars)",
            "    return not string",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('old', yaqltypes.String())",
            "@specs.parameter('new', yaqltypes.String())",
            "@specs.parameter('count', int)",
            "@specs.method",
            "def replace(string, old, new, count=-1):",
            "    \"\"\":yaql:replace",
            "",
            "    Returns a string with first count occurrences of old replaced with new.",
            "",
            "    :signature: string.replace(old, new, count => -1)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg old: value to be replaced",
            "    :argType old: string",
            "    :arg new: replacement for old value",
            "    :argType new: string",
            "    :arg count: how many first replacements to do. -1 by default, which means",
            "        to do all replacements",
            "    :argType count: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abaab\".replace(\"ab\", \"cd\")",
            "        \"cdacd\"",
            "    \"\"\"",
            "    return string.replace(old, new, count)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('replacements', utils.MappingType)",
            "@specs.parameter('count', int)",
            "@specs.inject('str_func', yaqltypes.Delegate('str'))",
            "@specs.method",
            "@specs.name('replace')",
            "def replace_with_dict(string, str_func, replacements, count=-1):",
            "    \"\"\":yaql:replace",
            "",
            "    Returns a string with all occurrences of replacements' keys replaced",
            "    with corresponding replacements' values.",
            "    If count is specified, only the first count occurrences of every key",
            "    are replaced.",
            "",
            "    :signature: string.replace(replacements, count => -1)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg replacements: dict of replacements in format {old => new ...}",
            "    :argType replacements: mapping",
            "    :arg count: how many first occurrences of every key are replaced. -1 by",
            "        default, which means to do all replacements",
            "    :argType count: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc ab abc\".replace({abc => xx, ab => yy})",
            "        \"xx yy xx\"",
            "        yaql> \"abc ab abc\".replace({ab => yy, abc => xx})",
            "        \"yyc yy yyc\"",
            "        yaql> \"abc ab abc\".replace({ab => yy, abc => xx}, 1)",
            "        \"yyc ab xx\"",
            "    \"\"\"",
            "    for key, value in replacements.items():",
            "        string = string.replace(str_func(key), str_func(value), count)",
            "    return string",
            "",
            "",
            "@specs.parameter('__format_string', yaqltypes.String())",
            "@specs.extension_method",
            "def format_(__format_string, *args, **kwargs):",
            "    \"\"\":yaql:format",
            "",
            "    Returns a string formatted with positional and keyword arguments.",
            "",
            "    :signature: string.format([args], {kwargs})",
            "    :receiverArg string: input string for formatting. Can be passed only as",
            "        first positional argument if used as a function. Can contain literal",
            "        text or replacement fields marked by braces {}. Every replacement field",
            "        should contain either the numeric index of a positional argument or the",
            "        name of a keyword argument",
            "    :argType string: string",
            "    :arg [args]: values for replacements for numeric markers",
            "    :argType [args]: chain of strings",
            "    :arg {kwargs}: values for keyword replacements",
            "    :argType {kwargs}: chain of key-value arguments, where values are strings",
            "    :returnValue: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc{0}ab{1}abc\".format(\" \", \",\")",
            "        \"abc ab,abc\"",
            "        yaql> \"abc{foo}ab{bar}abc\".format(foo => \" \", bar => \",\")",
            "        \"abc ab,abc\"",
            "        yaql> format(\"abc{0}ab{foo}abc\", ' ', foo => \",\")",
            "        \"abc ab,abc\"",
            "    \"\"\"",
            "    return __format_string.format(*args, **kwargs)",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', int)",
            "@specs.name('#operator_*')",
            "def string_by_int(left, right, engine):",
            "    \"\"\":yaql:operator *",
            "",
            "    Returns string repeated count times.",
            "",
            "    :signature: left * right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operator, how many times repeat input string",
            "    :argType right: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" * 2",
            "        \"abab\"",
            "    \"\"\"",
            "    utils.limit_memory_usage(engine, (-right + 1, u''), (right, left))",
            "    return left * right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_in')",
            "def in_(left, right):",
            "    \"\"\":yaql:operator in",
            "",
            "    Returns true if there is at least one occurrence of left string in right.",
            "",
            "    :signature: left in right",
            "    :arg left: left operand, which occurrence is checked",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" in \"abc\"",
            "        true",
            "        yaql> \"ab\" in \"acb\"",
            "        false",
            "    \"\"\"",
            "    return left in right",
            "",
            "",
            "@specs.parameter('left', int)",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_*')",
            "def int_by_string(left, right, engine):",
            "    \"\"\":yaql:operator *",
            "",
            "    Returns string repeated count times.",
            "",
            "    :signature: left * right",
            "    :arg left: left operand, how many times repeat input string",
            "    :argType left: integer",
            "    :arg right: right operator",
            "    :argType right: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> 2 * \"ab\"",
            "        \"abab\"",
            "    \"\"\"",
            "    return string_by_int(right, left, engine)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.parameter('length', int)",
            "@specs.method",
            "def substring(string, start, length=-1):",
            "    \"\"\":yaql:substring",
            "",
            "    Returns a substring beginning from start index ending with start+end index.",
            "",
            "    :signature: string.substring(start, length => -1)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg start: index for substring to start with",
            "    :argType start: integer",
            "    :arg length: length of substring. -1 by default, which means end of",
            "        substring to be equal to the end of input string",
            "    :argType length: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abcd\".substring(1)",
            "        \"bcd\"",
            "        yaql> \"abcd\".substring(1, 2)",
            "        \"bc\"",
            "    \"\"\"",
            "    if length < 0:",
            "        length = len(string)",
            "    if start < 0:",
            "        start += len(string)",
            "    return string[start:start + length]",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.method",
            "def index_of(string, sub, start=0):",
            "    \"\"\":yaql:indexOf",
            "",
            "    Returns an index of first occurrence sub in string beginning from start.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.indexOf(sub, start => 0)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdab\".indexOf(\"ab\")",
            "        1",
            "        yaql> \"cabcdab\".indexOf(\"ab\", 2)",
            "        5",
            "        yaql> \"cabcdab\".indexOf(\"ab\", 6)",
            "        -1",
            "    \"\"\"",
            "    return string.find(sub, start)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.parameter('length', int)",
            "@specs.method",
            "def index_of_(string, sub, start, length):",
            "    \"\"\":yaql:indexOf",
            "",
            "    Returns an index of first occurrence sub in string beginning from start",
            "    ending with start+length.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.indexOf(sub, start, length)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :arg length: length of string to find substring in",
            "    :argType length: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdab\".indexOf(\"bc\", 2, 2)",
            "        2",
            "    \"\"\"",
            "    if start < 0:",
            "        start += len(string)",
            "    if length < 0:",
            "        length = len(string) - start",
            "    return string.find(sub, start, start + length)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.method",
            "def last_index_of(string, sub, start=0):",
            "    \"\"\":yaql:lastIndexOf",
            "",
            "    Returns an index of last occurrence sub in string beginning from start.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.lastIndexOf(sub, start => 0)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdab\".lastIndexOf(\"ab\")",
            "        5",
            "    \"\"\"",
            "    return string.rfind(sub, start)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.parameter('length', int)",
            "@specs.method",
            "def last_index_of_(string, sub, start, length):",
            "    \"\"\":yaql:lastIndexOf",
            "",
            "    Returns an index of last occurrence sub in string beginning from start",
            "    ending with start+length.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.lastIndexOf(sub, start, length)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :arg length: length of string to find substring in",
            "    :argType length: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdbc\".lastIndexOf(\"bc\", 2, 5)",
            "        5",
            "    \"\"\"",
            "    if start < 0:",
            "        start += len(string)",
            "    if length < 0:",
            "        length = len(string) - start",
            "    return string.rfind(sub, start, start + length)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.method",
            "def to_char_array(string):",
            "    \"\"\":yaql:toCharArray",
            "",
            "    Converts a string to array of one character strings.",
            "",
            "    :signature: string.toCharArray()",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc de\".toCharArray()",
            "        [\"a\", \"b\", \"c\", \" \", \"d\", \"e\"]",
            "    \"\"\"",
            "    return tuple(string)",
            "",
            "",
            "def characters(",
            "        digits=False, hexdigits=False,",
            "        ascii_lowercase=False, ascii_uppercase=False,",
            "        ascii_letters=False, letters=False,",
            "        octdigits=False, punctuation=False, printable=False,",
            "        lowercase=False, uppercase=False, whitespace=False):",
            "    \"\"\":yaql:characters",
            "",
            "    Returns a list of all distinct items of specified types.",
            "",
            "    :signature: characters(digits => false, hexdigits => false,",
            "                           asciiLowercase => false, asciiUppercase => false,",
            "                           asciiLetters => false, letters => false,",
            "                           octdigits => false, punctuation => false,",
            "                           printable => false, lowercase => false,",
            "                           uppercase => false, whitespace => false)",
            "    :arg digits: include digits in output list if true, false by default",
            "    :argType digits: boolean",
            "    :arg hexdigits: include hexademical digits in output list if true, false",
            "        by default",
            "    :argType hexdigits: boolean",
            "    :arg asciiLowercase: include ASCII lowercase letters in output list if",
            "        true, false by default",
            "    :argType asciiLowercase: boolean",
            "    :arg asciiUppercase: include ASCII uppercase letters in output list if",
            "        true, false by default",
            "    :argType asciiUppercase: boolean",
            "    :arg asciiLetters: include both ASCII lowercase and uppercase letters",
            "        in output list if true, false by default",
            "    :argType asciiLetters: boolean",
            "    :arg letters: include both lowercase and uppercase letters in output list",
            "        if true, false by default",
            "    :argType letters: boolean",
            "    :arg octdigits: include digits from 0 to 7 in output list if true, false",
            "        by default",
            "    :argType octdigits: boolean",
            "    :arg punctuation: include ASCII characters, which are considered",
            "        punctuation, in output list if true, false by default",
            "    :argType punctuation: boolean",
            "    :arg printable: include digits, letters, punctuation, and whitespace in",
            "        output list if true, false by default",
            "    :argType printable: boolean",
            "    :arg lowercase: include lowercase letters in output list if true, false",
            "        by default",
            "    :argType lowercase: boolean",
            "    :arg uppercase: include uppercase letters in output list if true, false",
            "        by default",
            "    :argType uppercase: boolean",
            "    :arg whitespace: include all characters that are considered whitespace",
            "        in output list if true, false by default",
            "    :argType whitespace: boolean",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> characters(digits => true)",
            "        [\"1\", \"0\", \"3\", \"2\", \"5\", \"4\", \"7\", \"6\", \"9\", \"8\"]",
            "",
            "    \"\"\"",
            "    string = ''",
            "    if digits:",
            "        string += string_module.digits",
            "    if hexdigits:",
            "        string += string_module.hexdigits",
            "    if ascii_lowercase:",
            "        string += string_module.ascii_lowercase",
            "    if ascii_uppercase:",
            "        string += string_module.ascii_uppercase",
            "    if ascii_letters:",
            "        string += string_module.ascii_letters",
            "    if letters:",
            "        string += string_module.letters",
            "    if octdigits:",
            "        string += string_module.octdigits",
            "    if punctuation:",
            "        string += string_module.punctuation",
            "    if printable:",
            "        string += string_module.printable",
            "    if lowercase:",
            "        string += string_module.lowercase",
            "    if uppercase:",
            "        string += string_module.uppercase",
            "    if whitespace:",
            "        string += string_module.whitespace",
            "    return tuple(set(string))",
            "",
            "",
            "def is_string(arg):",
            "    \"\"\":yaql:isString",
            "",
            "    Returns true if arg is a string.",
            "",
            "    :signature: isString(arg)",
            "    :arg arg: input value",
            "    :argType arg: any",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> isString(\"ab\")",
            "        true",
            "        yaql> isString(1)",
            "        false",
            "    \"\"\"",
            "    return isinstance(arg, str)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('prefixes', yaqltypes.String())",
            "@specs.method",
            "def starts_with(string, *prefixes):",
            "    \"\"\":yaql:startsWith",
            "",
            "    Returns true if a string starts with any of given args.",
            "",
            "    :signature: string.startsWith([args])",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg [args]: chain of strings to check input string with",
            "    :argType [args]: strings",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abcd\".startsWith(\"ab\", \"xx\")",
            "        true",
            "        yaql> \"abcd\".startsWith(\"yy\", \"xx\", \"zz\")",
            "        false",
            "    \"\"\"",
            "    return string.startswith(prefixes)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('suffixes', yaqltypes.String())",
            "@specs.method",
            "def ends_with(string, *suffixes):",
            "    \"\"\":yaql:endsWith",
            "",
            "    Returns true if a string ends with any of given args.",
            "",
            "    :signature: string.endsWith([args])",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg [args]: chain of strings to check input string with",
            "    :argType [args]: strings",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abcd\".endsWith(\"cd\", \"xx\")",
            "        true",
            "        yaql> \"abcd\".endsWith(\"yy\", \"xx\", \"zz\")",
            "        false",
            "    \"\"\"",
            "    return string.endswith(suffixes)",
            "",
            "",
            "@specs.parameter('num', yaqltypes.Number(nullable=True))",
            "def hex_(num):",
            "    \"\"\":yaql:hex",
            "",
            "    Returns a string with hexadecimal representation of num.",
            "",
            "    :signature: hex(num)",
            "    :arg num: input number to be converted to hexademical",
            "    :argType num: number",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> hex(256)",
            "        \"0x100\"",
            "    \"\"\"",
            "    return hex(num)",
            "",
            "",
            "def register(context):",
            "    context.register_function(gt)",
            "    context.register_function(lt)",
            "    context.register_function(gte)",
            "    context.register_function(lte)",
            "    context.register_function(len_)",
            "    context.register_function(to_lower)",
            "    context.register_function(to_upper)",
            "    context.register_function(split)",
            "    context.register_function(right_split)",
            "    context.register_function(join)",
            "    context.register_function(join_)",
            "    context.register_function(str_)",
            "    context.register_function(concat)",
            "    context.register_function(concat, name='#operator_+')",
            "    context.register_function(trim)",
            "    context.register_function(trim_left)",
            "    context.register_function(trim_right)",
            "    context.register_function(replace)",
            "    context.register_function(replace_with_dict)",
            "    context.register_function(format_)",
            "    context.register_function(is_empty)",
            "    context.register_function(string_by_int)",
            "    context.register_function(int_by_string)",
            "    context.register_function(substring)",
            "    context.register_function(index_of)",
            "    context.register_function(index_of_)",
            "    context.register_function(last_index_of)",
            "    context.register_function(last_index_of_)",
            "    context.register_function(to_char_array)",
            "    context.register_function(characters)",
            "    context.register_function(is_string)",
            "    context.register_function(norm)",
            "    context.register_function(in_)",
            "    context.register_function(starts_with)",
            "    context.register_function(ends_with)",
            "    context.register_function(hex_)"
        ],
        "afterPatchFile": [
            "#    Copyright (c) 2015 Mirantis, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"",
            "The module describes which operations can be done with strings in YAQL.",
            "\"\"\"",
            "",
            "import string as string_module",
            "",
            "from yaql.language import specs",
            "from yaql.language import utils",
            "from yaql.language import yaqltypes",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_>')",
            "def gt(left, right):",
            "    \"\"\":yaql:operator >",
            "",
            "    Returns true if the left operand is strictly greater than the right,",
            "    ordering lexicographically, otherwise false.",
            "",
            "    :signature: left > right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc\" > \"ab\"",
            "        true",
            "        yaql> \"abc\" > \"abb\"",
            "        true",
            "        yaql> \"abc\" > \"abc\"",
            "        false",
            "    \"\"\"",
            "    return left > right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_<')",
            "def lt(left, right):",
            "    \"\"\":yaql:operator <",
            "",
            "    Returns true if the left operand is strictly less than the right, ordering",
            "    lexicographically, otherwise false.",
            "",
            "    :signature: left < right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" < \"abc\"",
            "        true",
            "        yaql> \"abb\" < \"abc\"",
            "        true",
            "        yaql> \"abc\" < \"abc\"",
            "        false",
            "    \"\"\"",
            "    return left < right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_>=')",
            "def gte(left, right):",
            "    \"\"\":yaql:operator >=",
            "",
            "    Returns true if the left operand is greater or equal to the right, ordering",
            "    lexicographically, otherwise false.",
            "",
            "    :signature: left >= right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc\" >= \"ab\"",
            "        true",
            "        yaql> \"abc\" >= \"abc\"",
            "        true",
            "    \"\"\"",
            "    return left >= right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_<=')",
            "def lte(left, right):",
            "    \"\"\":yaql:operator <=",
            "",
            "    Returns true if the left operand is less or equal to the right, ordering",
            "    lexicographically, otherwise false.",
            "",
            "    :signature: left <= right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" <= \"abc\"",
            "        true",
            "        yaql> \"abc\" <= \"abc\"",
            "        true",
            "    \"\"\"",
            "    return left <= right",
            "",
            "",
            "@specs.parameter('args', yaqltypes.String())",
            "def concat(*args):",
            "    \"\"\":yaql:concat",
            "",
            "    Returns concatenated args.",
            "",
            "    :signature: concat([args])",
            "    :arg [args]: values to be joined",
            "    :argType [args]: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> concat(\"abc\", \"de\", \"f\")",
            "        \"abcdef\"",
            "    \"\"\"",
            "    return ''.join(args)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.method",
            "def to_upper(string):",
            "    \"\"\":yaql:toUpper",
            "",
            "    Returns a string with all case-based characters uppercase.",
            "",
            "    :signature: string.toUpper()",
            "    :receiverArg string: value to uppercase",
            "    :argType string: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"aB1c\".toUpper()",
            "        \"AB1C\"",
            "    \"\"\"",
            "    return string.upper()",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.extension_method",
            "def len_(string):",
            "    \"\"\":yaql:len",
            "",
            "    Returns size of the string.",
            "",
            "    :signature: string.len()",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc\".len()",
            "        3",
            "    \"\"\"",
            "    return len(string)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.method",
            "def to_lower(string):",
            "    \"\"\":yaql:toLower",
            "",
            "    Returns a string with all case-based characters lowercase.",
            "",
            "    :signature: string.toLower()",
            "    :receiverArg string: value to lowercase",
            "    :argType string: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"AB1c\".toLower()",
            "        \"ab1c\"",
            "    \"\"\"",
            "    return string.lower()",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('separator', yaqltypes.String(nullable=True))",
            "@specs.parameter('max_splits', int)",
            "@specs.method",
            "def split(string, separator=None, max_splits=-1):",
            "    \"\"\":yaql:split",
            "",
            "    Returns a list of tokens in the string, using separator as the",
            "    delimiter.",
            "",
            "    :signature: string.split(separator => null, maxSplits => -1)",
            "    :receiverArg string: value to be splitted",
            "    :argType string: string",
            "    :arg separator: delimiter for splitting. null by default, which means",
            "        splitting with whitespace characters",
            "    :argType separator: string",
            "    :arg maxSplits: maximum number of splittings. -1 by default, which means",
            "        all possible splits are done",
            "    :argType maxSplits: integer",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc     de  f\".split()",
            "        [\"abc\", \"de\", \"f\"]",
            "        yaql> \"abc     de  f\".split(maxSplits => 1)",
            "        [\"abc\", \"de  f\"]",
            "        yaql> \"abcde\".split(\"c\")",
            "        [\"ab\", \"de\"]",
            "    \"\"\"",
            "    return string.split(separator, max_splits)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('separator', yaqltypes.String(nullable=True))",
            "@specs.parameter('max_splits', int)",
            "@specs.method",
            "def right_split(string, separator=None, max_splits=-1):",
            "    \"\"\":yaql:rightSplit",
            "",
            "    Returns a list of tokens in the string, using separator as the",
            "    delimiter. If maxSplits is given then at most maxSplits splits are done -",
            "    the rightmost ones.",
            "",
            "    :signature: string.rightSplit(separator => null, maxSplits => -1)",
            "    :receiverArg string: value to be splitted",
            "    :argType string: string",
            "    :arg separator: delimiter for splitting. null by default, which means",
            "        splitting with whitespace characters",
            "    :argType separator: string",
            "    :arg maxSplits: number of splits to be done - the rightmost ones.",
            "        -1 by default, which means all possible splits are done",
            "    :argType maxSplits: integer",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc     de  f\".rightSplit()",
            "        [\"abc\", \"de\", \"f\"]",
            "        yaql> \"abc     de  f\".rightSplit(maxSplits => 1)",
            "        [\"abc     de\", \"f\"]",
            "    \"\"\"",
            "    return string.rsplit(separator, max_splits)",
            "",
            "",
            "@specs.parameter('sequence', yaqltypes.Iterable())",
            "@specs.parameter('separator', yaqltypes.String())",
            "@specs.inject('str_delegate', yaqltypes.Delegate('str'))",
            "@specs.method",
            "def join(sequence, separator, str_delegate):",
            "    \"\"\":yaql:join",
            "",
            "    Returns a string with sequence elements joined by the separator.",
            "",
            "    :signature: sequence.join(separator)",
            "    :receiverArg sequence: chain of values to be joined",
            "    :argType sequence: sequence of strings",
            "    :arg separator: value to be placed between joined pairs",
            "    :argType separator: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> [\"abc\", \"de\", \"f\"].join(\"\")",
            "        \"abcdef\"",
            "        yaql> [\"abc\", \"de\", \"f\"].join(\"|\")",
            "        \"abc|de|f\"",
            "    \"\"\"",
            "    return separator.join(map(str_delegate, sequence))",
            "",
            "",
            "@specs.parameter('sequence', yaqltypes.Iterable())",
            "@specs.parameter('separator', yaqltypes.String())",
            "@specs.inject('str_delegate', yaqltypes.Delegate('str'))",
            "@specs.method",
            "def join_(separator, sequence, str_delegate):",
            "    \"\"\":yaql:join",
            "",
            "    Returns a string with sequence elements joined by the separator.",
            "",
            "    :signature: separator.join(sequence)",
            "    :receiverArg separator: value to be placed between joined pairs",
            "    :argType separator: string",
            "    :arg sequence: chain of values to be joined",
            "    :argType sequence: sequence of strings",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"|\".join([\"abc\", \"de\", \"f\"])",
            "        \"abc|de|f\"",
            "    \"\"\"",
            "    return join(sequence, separator, str_delegate)",
            "",
            "",
            "@specs.parameter('value', nullable=True)",
            "def str_(value):",
            "    \"\"\":yaql:str",
            "",
            "    Returns a string representation of the value.",
            "",
            "    :signature: str(value)",
            "    :arg value: value to be evaluated to string",
            "    :argType value: any",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> str([\"abc\", \"de\"])",
            "        \"(u'abc', u'd')\"",
            "        yaql> str(123)",
            "        \"123\"",
            "    \"\"\"",
            "    if value is None:",
            "        return 'null'",
            "    elif value is True:",
            "        return 'true'",
            "    elif value is False:",
            "        return 'false'",
            "    else:",
            "        return str(value)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.method",
            "def trim(string, chars=None):",
            "    \"\"\":yaql:trim",
            "",
            "    Returns a string with the leading and trailing chars removed.",
            "",
            "    :signature: string.trim(chars => null)",
            "    :receiverArg string: value to be trimmed",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from input string. null by default,",
            "        which means trim is done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".trim()",
            "        \"abcd\"",
            "        yaql> \"aababa\".trim(\"a\")",
            "        \"bab\"",
            "    \"\"\"",
            "    return string.strip(chars)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.method",
            "def trim_left(string, chars=None):",
            "    \"\"\":yaql:trimLeft",
            "",
            "    Returns a string with the leading chars removed.",
            "",
            "    :signature: string.trimLeft(chars => null)",
            "    :receiverArg string: value to be trimmed",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from start of input string. null by",
            "        default, which means trim is done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".trimLeft()",
            "        \"abcd \"",
            "        yaql> \"aababa\".trimLeft(\"a\")",
            "        \"baba\"",
            "    \"\"\"",
            "    return string.lstrip(chars)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.method",
            "def trim_right(string, chars=None):",
            "    \"\"\":yaql:trimRight",
            "",
            "    Returns a string with the trailing chars removed.",
            "",
            "    :signature: string.trimRight(chars => null)",
            "    :receiverArg string: value to be trimmed",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from end of input string. null by",
            "        default, which means trim is done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".trimRight()",
            "        \"  abcd\"",
            "        yaql> \"aababa\".trimRight(\"a\")",
            "        \"aabab\"",
            "    \"\"\"",
            "    return string.rstrip(chars)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String(nullable=True))",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.extension_method",
            "def norm(string, chars=None):",
            "    \"\"\":yaql:norm",
            "",
            "    Returns a string with the leading and trailing chars removed.",
            "    If the resulting string is empty, returns null.",
            "",
            "    :signature: string.norm(chars => null)",
            "    :receiverArg string: value to be cut with specified chars",
            "    :argType string: string",
            "    :arg chars: symbols to be removed from the start and the end of input",
            "        string. null by default, which means norm is done with whitespace",
            "        characters",
            "    :argType chars: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"  abcd \".norm()",
            "        \"abcd\"",
            "        yaql> \"aaaa\".norm(\"a\")",
            "        null",
            "    \"\"\"",
            "    if string is None:",
            "        return None",
            "    value = string.strip(chars)",
            "    return None if not value else value",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String(nullable=True))",
            "@specs.parameter('trim_spaces', bool, alias='trim')",
            "@specs.parameter('chars', yaqltypes.String(nullable=True))",
            "@specs.extension_method",
            "def is_empty(string, trim_spaces=True, chars=None):",
            "    \"\"\":yaql:isEmpty",
            "",
            "    Returns true if the string with removed leading and trailing chars is",
            "    empty.",
            "",
            "    :signature: string.isEmpty(trimSpaces => true, chars => null)",
            "    :receiverArg string: value to be checked for emptiness after trim",
            "    :argType string: string",
            "    :arg trimSpaces: true by default, which means string to be trimmed with",
            "        chars. false means checking whether input string is empty",
            "    :argType trimSpaces: boolean",
            "    :arg chars: symbols for trimming. null by default, which means trim is",
            "        done with whitespace characters",
            "    :argType chars: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abaab\".isEmpty(chars=>\"ab\")",
            "        true",
            "        yaql> \"aba\".isEmpty(chars=>\"a\")",
            "        false",
            "    \"\"\"",
            "    if string is None:",
            "        return True",
            "    if trim_spaces:",
            "        string = string.strip(chars)",
            "    return not string",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('old', yaqltypes.String())",
            "@specs.parameter('new', yaqltypes.String())",
            "@specs.parameter('count', int)",
            "@specs.method",
            "def replace(string, old, new, count=-1):",
            "    \"\"\":yaql:replace",
            "",
            "    Returns a string with first count occurrences of old replaced with new.",
            "",
            "    :signature: string.replace(old, new, count => -1)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg old: value to be replaced",
            "    :argType old: string",
            "    :arg new: replacement for old value",
            "    :argType new: string",
            "    :arg count: how many first replacements to do. -1 by default, which means",
            "        to do all replacements",
            "    :argType count: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abaab\".replace(\"ab\", \"cd\")",
            "        \"cdacd\"",
            "    \"\"\"",
            "    return string.replace(old, new, count)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('replacements', utils.MappingType)",
            "@specs.parameter('count', int)",
            "@specs.inject('str_func', yaqltypes.Delegate('str'))",
            "@specs.method",
            "@specs.name('replace')",
            "def replace_with_dict(string, str_func, replacements, count=-1):",
            "    \"\"\":yaql:replace",
            "",
            "    Returns a string with all occurrences of replacements' keys replaced",
            "    with corresponding replacements' values.",
            "    If count is specified, only the first count occurrences of every key",
            "    are replaced.",
            "",
            "    :signature: string.replace(replacements, count => -1)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg replacements: dict of replacements in format {old => new ...}",
            "    :argType replacements: mapping",
            "    :arg count: how many first occurrences of every key are replaced. -1 by",
            "        default, which means to do all replacements",
            "    :argType count: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc ab abc\".replace({abc => xx, ab => yy})",
            "        \"xx yy xx\"",
            "        yaql> \"abc ab abc\".replace({ab => yy, abc => xx})",
            "        \"yyc yy yyc\"",
            "        yaql> \"abc ab abc\".replace({ab => yy, abc => xx}, 1)",
            "        \"yyc ab xx\"",
            "    \"\"\"",
            "    for key, value in replacements.items():",
            "        string = string.replace(str_func(key), str_func(value), count)",
            "    return string",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', int)",
            "@specs.name('#operator_*')",
            "def string_by_int(left, right, engine):",
            "    \"\"\":yaql:operator *",
            "",
            "    Returns string repeated count times.",
            "",
            "    :signature: left * right",
            "    :arg left: left operand",
            "    :argType left: string",
            "    :arg right: right operator, how many times repeat input string",
            "    :argType right: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" * 2",
            "        \"abab\"",
            "    \"\"\"",
            "    utils.limit_memory_usage(engine, (-right + 1, u''), (right, left))",
            "    return left * right",
            "",
            "",
            "@specs.parameter('left', yaqltypes.String())",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_in')",
            "def in_(left, right):",
            "    \"\"\":yaql:operator in",
            "",
            "    Returns true if there is at least one occurrence of left string in right.",
            "",
            "    :signature: left in right",
            "    :arg left: left operand, which occurrence is checked",
            "    :argType left: string",
            "    :arg right: right operand",
            "    :argType right: string",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"ab\" in \"abc\"",
            "        true",
            "        yaql> \"ab\" in \"acb\"",
            "        false",
            "    \"\"\"",
            "    return left in right",
            "",
            "",
            "@specs.parameter('left', int)",
            "@specs.parameter('right', yaqltypes.String())",
            "@specs.name('#operator_*')",
            "def int_by_string(left, right, engine):",
            "    \"\"\":yaql:operator *",
            "",
            "    Returns string repeated count times.",
            "",
            "    :signature: left * right",
            "    :arg left: left operand, how many times repeat input string",
            "    :argType left: integer",
            "    :arg right: right operator",
            "    :argType right: string",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> 2 * \"ab\"",
            "        \"abab\"",
            "    \"\"\"",
            "    return string_by_int(right, left, engine)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.parameter('length', int)",
            "@specs.method",
            "def substring(string, start, length=-1):",
            "    \"\"\":yaql:substring",
            "",
            "    Returns a substring beginning from start index ending with start+end index.",
            "",
            "    :signature: string.substring(start, length => -1)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg start: index for substring to start with",
            "    :argType start: integer",
            "    :arg length: length of substring. -1 by default, which means end of",
            "        substring to be equal to the end of input string",
            "    :argType length: integer",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> \"abcd\".substring(1)",
            "        \"bcd\"",
            "        yaql> \"abcd\".substring(1, 2)",
            "        \"bc\"",
            "    \"\"\"",
            "    if length < 0:",
            "        length = len(string)",
            "    if start < 0:",
            "        start += len(string)",
            "    return string[start:start + length]",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.method",
            "def index_of(string, sub, start=0):",
            "    \"\"\":yaql:indexOf",
            "",
            "    Returns an index of first occurrence sub in string beginning from start.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.indexOf(sub, start => 0)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdab\".indexOf(\"ab\")",
            "        1",
            "        yaql> \"cabcdab\".indexOf(\"ab\", 2)",
            "        5",
            "        yaql> \"cabcdab\".indexOf(\"ab\", 6)",
            "        -1",
            "    \"\"\"",
            "    return string.find(sub, start)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.parameter('length', int)",
            "@specs.method",
            "def index_of_(string, sub, start, length):",
            "    \"\"\":yaql:indexOf",
            "",
            "    Returns an index of first occurrence sub in string beginning from start",
            "    ending with start+length.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.indexOf(sub, start, length)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :arg length: length of string to find substring in",
            "    :argType length: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdab\".indexOf(\"bc\", 2, 2)",
            "        2",
            "    \"\"\"",
            "    if start < 0:",
            "        start += len(string)",
            "    if length < 0:",
            "        length = len(string) - start",
            "    return string.find(sub, start, start + length)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.method",
            "def last_index_of(string, sub, start=0):",
            "    \"\"\":yaql:lastIndexOf",
            "",
            "    Returns an index of last occurrence sub in string beginning from start.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.lastIndexOf(sub, start => 0)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdab\".lastIndexOf(\"ab\")",
            "        5",
            "    \"\"\"",
            "    return string.rfind(sub, start)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('sub', yaqltypes.String())",
            "@specs.parameter('start', int)",
            "@specs.parameter('length', int)",
            "@specs.method",
            "def last_index_of_(string, sub, start, length):",
            "    \"\"\":yaql:lastIndexOf",
            "",
            "    Returns an index of last occurrence sub in string beginning from start",
            "    ending with start+length.",
            "    -1 is a return value if there is no any occurrence.",
            "",
            "    :signature: string.lastIndexOf(sub, start, length)",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg sub: substring to find in string",
            "    :argType sub: string",
            "    :arg start: index to start search with, 0 by default",
            "    :argType start: integer",
            "    :arg length: length of string to find substring in",
            "    :argType length: integer",
            "    :returnType: integer",
            "",
            "    .. code::",
            "",
            "        yaql> \"cabcdbc\".lastIndexOf(\"bc\", 2, 5)",
            "        5",
            "    \"\"\"",
            "    if start < 0:",
            "        start += len(string)",
            "    if length < 0:",
            "        length = len(string) - start",
            "    return string.rfind(sub, start, start + length)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.method",
            "def to_char_array(string):",
            "    \"\"\":yaql:toCharArray",
            "",
            "    Converts a string to array of one character strings.",
            "",
            "    :signature: string.toCharArray()",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> \"abc de\".toCharArray()",
            "        [\"a\", \"b\", \"c\", \" \", \"d\", \"e\"]",
            "    \"\"\"",
            "    return tuple(string)",
            "",
            "",
            "def characters(",
            "        digits=False, hexdigits=False,",
            "        ascii_lowercase=False, ascii_uppercase=False,",
            "        ascii_letters=False, letters=False,",
            "        octdigits=False, punctuation=False, printable=False,",
            "        lowercase=False, uppercase=False, whitespace=False):",
            "    \"\"\":yaql:characters",
            "",
            "    Returns a list of all distinct items of specified types.",
            "",
            "    :signature: characters(digits => false, hexdigits => false,",
            "                           asciiLowercase => false, asciiUppercase => false,",
            "                           asciiLetters => false, letters => false,",
            "                           octdigits => false, punctuation => false,",
            "                           printable => false, lowercase => false,",
            "                           uppercase => false, whitespace => false)",
            "    :arg digits: include digits in output list if true, false by default",
            "    :argType digits: boolean",
            "    :arg hexdigits: include hexademical digits in output list if true, false",
            "        by default",
            "    :argType hexdigits: boolean",
            "    :arg asciiLowercase: include ASCII lowercase letters in output list if",
            "        true, false by default",
            "    :argType asciiLowercase: boolean",
            "    :arg asciiUppercase: include ASCII uppercase letters in output list if",
            "        true, false by default",
            "    :argType asciiUppercase: boolean",
            "    :arg asciiLetters: include both ASCII lowercase and uppercase letters",
            "        in output list if true, false by default",
            "    :argType asciiLetters: boolean",
            "    :arg letters: include both lowercase and uppercase letters in output list",
            "        if true, false by default",
            "    :argType letters: boolean",
            "    :arg octdigits: include digits from 0 to 7 in output list if true, false",
            "        by default",
            "    :argType octdigits: boolean",
            "    :arg punctuation: include ASCII characters, which are considered",
            "        punctuation, in output list if true, false by default",
            "    :argType punctuation: boolean",
            "    :arg printable: include digits, letters, punctuation, and whitespace in",
            "        output list if true, false by default",
            "    :argType printable: boolean",
            "    :arg lowercase: include lowercase letters in output list if true, false",
            "        by default",
            "    :argType lowercase: boolean",
            "    :arg uppercase: include uppercase letters in output list if true, false",
            "        by default",
            "    :argType uppercase: boolean",
            "    :arg whitespace: include all characters that are considered whitespace",
            "        in output list if true, false by default",
            "    :argType whitespace: boolean",
            "    :returnType: list",
            "",
            "    .. code::",
            "",
            "        yaql> characters(digits => true)",
            "        [\"1\", \"0\", \"3\", \"2\", \"5\", \"4\", \"7\", \"6\", \"9\", \"8\"]",
            "",
            "    \"\"\"",
            "    string = ''",
            "    if digits:",
            "        string += string_module.digits",
            "    if hexdigits:",
            "        string += string_module.hexdigits",
            "    if ascii_lowercase:",
            "        string += string_module.ascii_lowercase",
            "    if ascii_uppercase:",
            "        string += string_module.ascii_uppercase",
            "    if ascii_letters:",
            "        string += string_module.ascii_letters",
            "    if letters:",
            "        string += string_module.letters",
            "    if octdigits:",
            "        string += string_module.octdigits",
            "    if punctuation:",
            "        string += string_module.punctuation",
            "    if printable:",
            "        string += string_module.printable",
            "    if lowercase:",
            "        string += string_module.lowercase",
            "    if uppercase:",
            "        string += string_module.uppercase",
            "    if whitespace:",
            "        string += string_module.whitespace",
            "    return tuple(set(string))",
            "",
            "",
            "def is_string(arg):",
            "    \"\"\":yaql:isString",
            "",
            "    Returns true if arg is a string.",
            "",
            "    :signature: isString(arg)",
            "    :arg arg: input value",
            "    :argType arg: any",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> isString(\"ab\")",
            "        true",
            "        yaql> isString(1)",
            "        false",
            "    \"\"\"",
            "    return isinstance(arg, str)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('prefixes', yaqltypes.String())",
            "@specs.method",
            "def starts_with(string, *prefixes):",
            "    \"\"\":yaql:startsWith",
            "",
            "    Returns true if a string starts with any of given args.",
            "",
            "    :signature: string.startsWith([args])",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg [args]: chain of strings to check input string with",
            "    :argType [args]: strings",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abcd\".startsWith(\"ab\", \"xx\")",
            "        true",
            "        yaql> \"abcd\".startsWith(\"yy\", \"xx\", \"zz\")",
            "        false",
            "    \"\"\"",
            "    return string.startswith(prefixes)",
            "",
            "",
            "@specs.parameter('string', yaqltypes.String())",
            "@specs.parameter('suffixes', yaqltypes.String())",
            "@specs.method",
            "def ends_with(string, *suffixes):",
            "    \"\"\":yaql:endsWith",
            "",
            "    Returns true if a string ends with any of given args.",
            "",
            "    :signature: string.endsWith([args])",
            "    :receiverArg string: input string",
            "    :argType string: string",
            "    :arg [args]: chain of strings to check input string with",
            "    :argType [args]: strings",
            "    :returnType: boolean",
            "",
            "    .. code::",
            "",
            "        yaql> \"abcd\".endsWith(\"cd\", \"xx\")",
            "        true",
            "        yaql> \"abcd\".endsWith(\"yy\", \"xx\", \"zz\")",
            "        false",
            "    \"\"\"",
            "    return string.endswith(suffixes)",
            "",
            "",
            "@specs.parameter('num', yaqltypes.Number(nullable=True))",
            "def hex_(num):",
            "    \"\"\":yaql:hex",
            "",
            "    Returns a string with hexadecimal representation of num.",
            "",
            "    :signature: hex(num)",
            "    :arg num: input number to be converted to hexademical",
            "    :argType num: number",
            "    :returnType: string",
            "",
            "    .. code::",
            "",
            "        yaql> hex(256)",
            "        \"0x100\"",
            "    \"\"\"",
            "    return hex(num)",
            "",
            "",
            "def register(context):",
            "    context.register_function(gt)",
            "    context.register_function(lt)",
            "    context.register_function(gte)",
            "    context.register_function(lte)",
            "    context.register_function(len_)",
            "    context.register_function(to_lower)",
            "    context.register_function(to_upper)",
            "    context.register_function(split)",
            "    context.register_function(right_split)",
            "    context.register_function(join)",
            "    context.register_function(join_)",
            "    context.register_function(str_)",
            "    context.register_function(concat)",
            "    context.register_function(concat, name='#operator_+')",
            "    context.register_function(trim)",
            "    context.register_function(trim_left)",
            "    context.register_function(trim_right)",
            "    context.register_function(replace)",
            "    context.register_function(replace_with_dict)",
            "    context.register_function(is_empty)",
            "    context.register_function(string_by_int)",
            "    context.register_function(int_by_string)",
            "    context.register_function(substring)",
            "    context.register_function(index_of)",
            "    context.register_function(index_of_)",
            "    context.register_function(last_index_of)",
            "    context.register_function(last_index_of_)",
            "    context.register_function(to_char_array)",
            "    context.register_function(characters)",
            "    context.register_function(is_string)",
            "    context.register_function(norm)",
            "    context.register_function(in_)",
            "    context.register_function(starts_with)",
            "    context.register_function(ends_with)",
            "    context.register_function(hex_)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "567": [],
            "568": [],
            "569": [
                "format_"
            ],
            "570": [
                "format_"
            ],
            "571": [
                "format_"
            ],
            "572": [
                "format_"
            ],
            "573": [
                "format_"
            ],
            "574": [
                "format_"
            ],
            "575": [
                "format_"
            ],
            "576": [
                "format_"
            ],
            "577": [
                "format_"
            ],
            "578": [
                "format_"
            ],
            "579": [
                "format_"
            ],
            "580": [
                "format_"
            ],
            "581": [
                "format_"
            ],
            "582": [
                "format_"
            ],
            "583": [
                "format_"
            ],
            "584": [
                "format_"
            ],
            "585": [
                "format_"
            ],
            "586": [
                "format_"
            ],
            "587": [
                "format_"
            ],
            "588": [
                "format_"
            ],
            "589": [
                "format_"
            ],
            "590": [
                "format_"
            ],
            "591": [
                "format_"
            ],
            "592": [
                "format_"
            ],
            "593": [
                "format_"
            ],
            "594": [
                "format_"
            ],
            "595": [
                "format_"
            ],
            "596": [
                "format_"
            ],
            "597": [],
            "598": [],
            "1048": [
                "register"
            ]
        },
        "addLocation": []
    },
    "yaql/tests/test_regex.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             '24.16 = 24(2-4) + 16(5-7)',"
            },
            "1": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             self.eval("
            },
            "2": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 r\"regex(`(\\d+)\\.?(\\d+)?`).search(\"r\"'aa24.16bb', \""
            },
            "3": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                r\"format('{0} = {1}({2}-{3}) + {4}({5}-{6})', \""
            },
            "4": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                r\"$.value, $2.value, $2.start, $2.end, \""
            },
            "5": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                r\"$3.value, $3.start, $3.end))\"))"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                r\"$.value + ' = ' + \""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                r\"$2.value + '(' + str($2.start) + '-' + str($2.end) + ') + ' \""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+                r\"+ $3.value + '(' + str($3.start) + '-' + str($3.end) + ')')\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            ))"
            },
            "10": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     def test_search_all(self):"
            },
            "12": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         self.assertEqual("
            }
        },
        "frontPatchFile": [
            "#    Copyright (c) 2015 Mirantis, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import yaql.tests",
            "",
            "",
            "class TestRegex(yaql.tests.TestCase):",
            "    def test_matches(self):",
            "        self.assertTrue(self.eval(\"regex('a.b').matches(axb)\"))",
            "        self.assertFalse(self.eval(\"regex('a.b').matches(abx)\"))",
            "",
            "    def test_matches_string_method(self):",
            "        self.assertTrue(self.eval(\"axb.matches('a.b')\"))",
            "        self.assertFalse(self.eval(\"abx.matches('a.b')\"))",
            "",
            "    def test_matches_operator_regex(self):",
            "        self.assertTrue(self.eval(\"axb =~ regex('a.b')\"))",
            "        self.assertFalse(self.eval(\"abx =~ regex('a.b')\"))",
            "",
            "    def test_not_matches_operator_regex(self):",
            "        self.assertFalse(self.eval(\"axb !~ regex('a.b')\"))",
            "        self.assertTrue(self.eval(\"abx !~ regex('a.b')\"))",
            "",
            "    def test_matches_operator_string(self):",
            "        self.assertTrue(self.eval(\"axb =~ 'a.b'\"))",
            "        self.assertFalse(self.eval(\"abx =~ 'a.b'\"))",
            "",
            "    def test_not_matches_operator_string(self):",
            "        self.assertFalse(self.eval(\"axb !~ 'a.b'\"))",
            "        self.assertTrue(self.eval(\"abx !~ 'a.b'\"))",
            "",
            "    def test_search(self):",
            "        self.assertEqual(",
            "            '24.16',",
            "            self.eval(r\"regex(`(\\d+)\\.?(\\d+)?`).search('a24.16b')\"))",
            "",
            "    def test_search_with_selector(self):",
            "        self.assertEqual(",
            "            '24.16 = 24(2-4) + 16(5-7)',",
            "            self.eval(",
            "                r\"regex(`(\\d+)\\.?(\\d+)?`).search(\"r\"'aa24.16bb', \"",
            "                r\"format('{0} = {1}({2}-{3}) + {4}({5}-{6})', \"",
            "                r\"$.value, $2.value, $2.start, $2.end, \"",
            "                r\"$3.value, $3.start, $3.end))\"))",
            "",
            "    def test_search_all(self):",
            "        self.assertEqual(",
            "            ['24', '16'],",
            "            self.eval(r\"regex(`\\d+`).searchAll('a24.16b')\"))",
            "",
            "    def test_search_all_with_selector(self):",
            "        self.assertEqual(",
            "            ['24!', '16!'],",
            "            self.eval(r\"regex(`\\d+`).searchAll('a24.16b', $.value+'!')\"))",
            "",
            "    def test_split(self):",
            "        self.assertEqual(",
            "            ['Words', 'words', 'words', ''],",
            "            self.eval(r\"regex(`\\W+`).split('Words, words, words.')\"))",
            "        self.assertEqual(",
            "            ['Words', ', ', 'words', ', ', 'words', '.', ''],",
            "            self.eval(r\"regex(`(\\W+)`).split('Words, words, words.')\"))",
            "        self.assertEqual(",
            "            ['Words', 'words, words.'],",
            "            self.eval(r\"regex(`\\W+`).split('Words, words, words.', 1)\"))",
            "        self.assertEqual(",
            "            ['0', '3', '9'],",
            "            self.eval(r\"regex('[a-f]+', ignoreCase => true).split('0a3B9')\"))",
            "",
            "    def test_split_on_string(self):",
            "        self.assertEqual(",
            "            ['Words', 'words', 'words', ''],",
            "            self.eval(r\"'Words, words, words.'.split(regex(`\\W+`))\"))",
            "        self.assertEqual(",
            "            ['Words', ', ', 'words', ', ', 'words', '.', ''],",
            "            self.eval(r\"'Words, words, words.'.split(regex(`(\\W+)`))\"))",
            "        self.assertEqual(",
            "            ['Words', 'words, words.'],",
            "            self.eval(r\"'Words, words, words.'.split(regex(`\\W+`), 1)\"))",
            "        self.assertEqual(",
            "            ['0', '3', '9'],",
            "            self.eval(r\"'0a3B9'.split(regex('[a-f]+', ignoreCase => true))\"))",
            "",
            "    def test_replace(self):",
            "        self.assertEqual(",
            "            'axxbxx',",
            "            self.eval(r\"regex(`\\d+`).replace(a12b23, xx)\"))",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"regex(`\\d+`).replace(a12b23, xx, 1)\"))",
            "",
            "    def test_replace_backref(self):",
            "        self.assertEqual(",
            "            'Foo_Bar_Foo',",
            "            self.eval(r\"regex(`([a-z0-9])([A-Z])`).replace(\"",
            "                      \"FooBarFoo, `\\\\1_\\\\2`)\"))",
            "",
            "    def test_replace_on_string(self):",
            "        self.assertEqual(",
            "            'axxbxx',",
            "            self.eval(r\"a12b23.replace(regex(`\\d+`), xx)\"))",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"a12b23.replace(regex(`\\d+`), xx, 1)\"))",
            "",
            "    def test_replace_by(self):",
            "        self.assertEqual(",
            "            'axxbyy',",
            "            self.eval(r\"regex(`\\d+`).replaceBy(a12b23, \"",
            "                      r\"let(a => int($.value)) -> switch(\"",
            "                      r\"$a < 20 => xx, true => yy))\"))",
            "",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"regex(`\\d+`).replaceBy(a12b23, \"",
            "                      r\"let(a => int($.value)) -> switch(\"",
            "                      r\"$a < 20 => xx, true => yy), 1)\"))",
            "",
            "    def test_replace_by_on_string(self):",
            "        self.assertEqual(",
            "            'axxbyy',",
            "            self.eval(r\"a12b23.replaceBy(regex(`\\d+`), \"",
            "                      r\"with(int($.value)) -> switch(\"",
            "                      r\"$ < 20 => xx, true => yy))\"))",
            "",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"a12b23.replaceBy(regex(`\\d+`), \"",
            "                      r\"let(a => int($.value)) -> switch(\"",
            "                      r\"$a < 20 => xx, true => yy), 1)\"))",
            "",
            "    def test_escape_regex(self):",
            "        self.assertEqual(",
            "            '\\\\[',",
            "            self.eval(r\"escapeRegex('[')\"))",
            "",
            "    def test_is_regex(self):",
            "        self.assertTrue(self.eval('isRegex(regex(\"a.b\"))'))",
            "        self.assertFalse(self.eval('isRegex(123)'))",
            "        self.assertFalse(self.eval('isRegex(abc)'))"
        ],
        "afterPatchFile": [
            "#    Copyright (c) 2015 Mirantis, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import yaql.tests",
            "",
            "",
            "class TestRegex(yaql.tests.TestCase):",
            "    def test_matches(self):",
            "        self.assertTrue(self.eval(\"regex('a.b').matches(axb)\"))",
            "        self.assertFalse(self.eval(\"regex('a.b').matches(abx)\"))",
            "",
            "    def test_matches_string_method(self):",
            "        self.assertTrue(self.eval(\"axb.matches('a.b')\"))",
            "        self.assertFalse(self.eval(\"abx.matches('a.b')\"))",
            "",
            "    def test_matches_operator_regex(self):",
            "        self.assertTrue(self.eval(\"axb =~ regex('a.b')\"))",
            "        self.assertFalse(self.eval(\"abx =~ regex('a.b')\"))",
            "",
            "    def test_not_matches_operator_regex(self):",
            "        self.assertFalse(self.eval(\"axb !~ regex('a.b')\"))",
            "        self.assertTrue(self.eval(\"abx !~ regex('a.b')\"))",
            "",
            "    def test_matches_operator_string(self):",
            "        self.assertTrue(self.eval(\"axb =~ 'a.b'\"))",
            "        self.assertFalse(self.eval(\"abx =~ 'a.b'\"))",
            "",
            "    def test_not_matches_operator_string(self):",
            "        self.assertFalse(self.eval(\"axb !~ 'a.b'\"))",
            "        self.assertTrue(self.eval(\"abx !~ 'a.b'\"))",
            "",
            "    def test_search(self):",
            "        self.assertEqual(",
            "            '24.16',",
            "            self.eval(r\"regex(`(\\d+)\\.?(\\d+)?`).search('a24.16b')\"))",
            "",
            "    def test_search_with_selector(self):",
            "        self.assertEqual(",
            "            '24.16 = 24(2-4) + 16(5-7)',",
            "            self.eval(",
            "                r\"regex(`(\\d+)\\.?(\\d+)?`).search(\"r\"'aa24.16bb', \"",
            "                r\"$.value + ' = ' + \"",
            "                r\"$2.value + '(' + str($2.start) + '-' + str($2.end) + ') + ' \"",
            "                r\"+ $3.value + '(' + str($3.start) + '-' + str($3.end) + ')')\"",
            "            ))",
            "",
            "    def test_search_all(self):",
            "        self.assertEqual(",
            "            ['24', '16'],",
            "            self.eval(r\"regex(`\\d+`).searchAll('a24.16b')\"))",
            "",
            "    def test_search_all_with_selector(self):",
            "        self.assertEqual(",
            "            ['24!', '16!'],",
            "            self.eval(r\"regex(`\\d+`).searchAll('a24.16b', $.value+'!')\"))",
            "",
            "    def test_split(self):",
            "        self.assertEqual(",
            "            ['Words', 'words', 'words', ''],",
            "            self.eval(r\"regex(`\\W+`).split('Words, words, words.')\"))",
            "        self.assertEqual(",
            "            ['Words', ', ', 'words', ', ', 'words', '.', ''],",
            "            self.eval(r\"regex(`(\\W+)`).split('Words, words, words.')\"))",
            "        self.assertEqual(",
            "            ['Words', 'words, words.'],",
            "            self.eval(r\"regex(`\\W+`).split('Words, words, words.', 1)\"))",
            "        self.assertEqual(",
            "            ['0', '3', '9'],",
            "            self.eval(r\"regex('[a-f]+', ignoreCase => true).split('0a3B9')\"))",
            "",
            "    def test_split_on_string(self):",
            "        self.assertEqual(",
            "            ['Words', 'words', 'words', ''],",
            "            self.eval(r\"'Words, words, words.'.split(regex(`\\W+`))\"))",
            "        self.assertEqual(",
            "            ['Words', ', ', 'words', ', ', 'words', '.', ''],",
            "            self.eval(r\"'Words, words, words.'.split(regex(`(\\W+)`))\"))",
            "        self.assertEqual(",
            "            ['Words', 'words, words.'],",
            "            self.eval(r\"'Words, words, words.'.split(regex(`\\W+`), 1)\"))",
            "        self.assertEqual(",
            "            ['0', '3', '9'],",
            "            self.eval(r\"'0a3B9'.split(regex('[a-f]+', ignoreCase => true))\"))",
            "",
            "    def test_replace(self):",
            "        self.assertEqual(",
            "            'axxbxx',",
            "            self.eval(r\"regex(`\\d+`).replace(a12b23, xx)\"))",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"regex(`\\d+`).replace(a12b23, xx, 1)\"))",
            "",
            "    def test_replace_backref(self):",
            "        self.assertEqual(",
            "            'Foo_Bar_Foo',",
            "            self.eval(r\"regex(`([a-z0-9])([A-Z])`).replace(\"",
            "                      \"FooBarFoo, `\\\\1_\\\\2`)\"))",
            "",
            "    def test_replace_on_string(self):",
            "        self.assertEqual(",
            "            'axxbxx',",
            "            self.eval(r\"a12b23.replace(regex(`\\d+`), xx)\"))",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"a12b23.replace(regex(`\\d+`), xx, 1)\"))",
            "",
            "    def test_replace_by(self):",
            "        self.assertEqual(",
            "            'axxbyy',",
            "            self.eval(r\"regex(`\\d+`).replaceBy(a12b23, \"",
            "                      r\"let(a => int($.value)) -> switch(\"",
            "                      r\"$a < 20 => xx, true => yy))\"))",
            "",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"regex(`\\d+`).replaceBy(a12b23, \"",
            "                      r\"let(a => int($.value)) -> switch(\"",
            "                      r\"$a < 20 => xx, true => yy), 1)\"))",
            "",
            "    def test_replace_by_on_string(self):",
            "        self.assertEqual(",
            "            'axxbyy',",
            "            self.eval(r\"a12b23.replaceBy(regex(`\\d+`), \"",
            "                      r\"with(int($.value)) -> switch(\"",
            "                      r\"$ < 20 => xx, true => yy))\"))",
            "",
            "        self.assertEqual(",
            "            'axxb23',",
            "            self.eval(r\"a12b23.replaceBy(regex(`\\d+`), \"",
            "                      r\"let(a => int($.value)) -> switch(\"",
            "                      r\"$a < 20 => xx, true => yy), 1)\"))",
            "",
            "    def test_escape_regex(self):",
            "        self.assertEqual(",
            "            '\\\\[',",
            "            self.eval(r\"escapeRegex('[')\"))",
            "",
            "    def test_is_regex(self):",
            "        self.assertTrue(self.eval('isRegex(regex(\"a.b\"))'))",
            "        self.assertFalse(self.eval('isRegex(123)'))",
            "        self.assertFalse(self.eval('isRegex(abc)'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "53": [
                "TestRegex",
                "test_search_with_selector"
            ],
            "54": [
                "TestRegex",
                "test_search_with_selector"
            ],
            "55": [
                "TestRegex",
                "test_search_with_selector"
            ]
        },
        "addLocation": []
    },
    "yaql/tests/test_strings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     def test_concat_func(self):"
            },
            "1": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         self.assertEqual('abc', self.eval(\"concat(a, b, c)\"))"
            },
            "2": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_format(self):"
            },
            "4": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual('a->b', self.eval(\"'{0}->{x}'.format(a, x => b)\"))"
            },
            "5": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual('a->b', self.eval(\"format('{0}->{x}', a, x => b)\"))"
            },
            "6": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "7": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     def test_trim(self):"
            },
            "8": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.assertEqual('x', self.eval(\"'  x  '.trim()\"))"
            },
            "9": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         self.assertEqual('x', self.eval(\"'abxba'.trim(ab)\"))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#    Copyright (c) 2015 Mirantis, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from yaql.language import exceptions",
            "import yaql.tests",
            "",
            "",
            "class TestStrings(yaql.tests.TestCase):",
            "    def test_scalar(self):",
            "        self.assertEqual(\"some \\ttext\", self.eval(\"'some \\\\ttext'\"))",
            "        self.assertEqual(r\"\\\\\", self.eval(r\"'\\\\\\\\'\"))",
            "        self.assertEqual(\"some \\\"text\\\"\", self.eval(r'\"some \\\"text\\\"\"'))",
            "",
            "    def test_verbatim_strings(self):",
            "        self.assertEqual('c:\\\\f\\\\x', self.eval(r\"`c:\\f\\x`\"))",
            "        self.assertEqual('`', self.eval(r\"`\\``\"))",
            "        self.assertEqual('\\\\n', self.eval(r\"`\\n`\"))",
            "        self.assertEqual(r\"\\\\\", self.eval(r\"`\\\\`\"))",
            "",
            "    def test_len(self):",
            "        self.assertEqual(3, self.eval('len(abc)'))",
            "",
            "    def test_to_upper(self):",
            "        self.assertEqual('QQ', self.eval('qq.toUpper()'))",
            "        self.assertEqual(u'\u041f\u0420\u0418\u0412\u0415\u0422', self.eval(u'\u041f\u0440\u0438\u0432\u0435\u0442.toUpper()'))",
            "",
            "    def test_to_lower(self):",
            "        self.assertEqual('qq', self.eval('QQ.toLower()'))",
            "        self.assertEqual(u'\u043f\u0440\u0438\u0432\u0435\u0442', self.eval(u'\u041f\u0440\u0438\u0432\u0435\u0442.toLower()'))",
            "",
            "    def test_eq(self):",
            "        self.assertTrue(self.eval('a = a'))",
            "        self.assertFalse(self.eval('a = b'))",
            "",
            "    def test_neq(self):",
            "        self.assertFalse(self.eval('a != a'))",
            "        self.assertTrue(self.eval('a != b'))",
            "",
            "    def test_is_string(self):",
            "        self.assertTrue(self.eval('isString(abc)'))",
            "        self.assertFalse(self.eval('isString(null)'))",
            "        self.assertFalse(self.eval('isString(123)'))",
            "        self.assertFalse(self.eval('isString(true)'))",
            "",
            "    def test_split(self):",
            "        self.assertEqual(",
            "            ['some', 'text'],",
            "            self.eval(\"$.split('\\\\n')\", data='some\\ntext'))",
            "",
            "    def test_rsplit(self):",
            "        self.assertEqual(",
            "            ['one\\ntwo', 'three'],",
            "            self.eval(\"$.rightSplit('\\\\n', 1)\", data='one\\ntwo\\nthree'))",
            "",
            "    def test_join(self):",
            "        self.assertEqual('some-text', self.eval(\"[some, text].join('-')\"))",
            "",
            "    def test_join_pythonic(self):",
            "        self.assertEqual('some-text', self.eval(\"'-'.join([some, text])\"))",
            "",
            "    def test_is_empty(self):",
            "        self.assertTrue(self.eval(\"isEmpty('')\"))",
            "        self.assertTrue(self.eval(\"isEmpty(null)\"))",
            "        self.assertTrue(self.eval(\"null.isEmpty()\"))",
            "        self.assertTrue(self.eval(\"isEmpty('  ')\"))",
            "        self.assertFalse(self.eval(\"isEmpty('  x')\"))",
            "",
            "    def test_norm(self):",
            "        self.assertIsNone(self.eval(\"norm('')\"))",
            "        self.assertIsNone(self.eval(\"norm(null)\"))",
            "        self.assertIsNone(self.eval(\"norm('  ')\"))",
            "        self.assertEqual('x', self.eval(\"norm('  x')\"))",
            "",
            "    def test_replace(self):",
            "        self.assertEqual('AxxD', self.eval(\"ABBD.replace(B, x)\"))",
            "        self.assertEqual('AxxD', self.eval(\"ABxD.replace(B, x, 1)\"))",
            "",
            "    def test_replace_with_dict(self):",
            "        self.assertEqual(",
            "            'Az1D',",
            "            self.eval('AxyD.replace({x => z, y => 1})'))",
            "",
            "        self.assertEqual(",
            "            'Ayfalse2D!', self.eval(",
            "                \"A122Dnull.replace({1 => y, 2 => false, null => '!'}, 1)\"))",
            "",
            "    def test_in(self):",
            "        self.assertTrue(self.eval(\"B in ABC\"))",
            "        self.assertFalse(self.eval(\"D in ABC\"))",
            "",
            "    def test_str(self):",
            "        self.assertEqual('null', self.eval('str(null)'))",
            "        self.assertEqual('true', self.eval('str(true)'))",
            "        self.assertEqual('false', self.eval('str(false)'))",
            "        self.assertEqual('12', self.eval(\"str('12')\"))",
            "",
            "    def test_join_seq(self):",
            "        self.assertEqual(",
            "            'text-1-null-true',",
            "            self.eval(\"[text, 1, null, true].select(str($)).join('-')\"))",
            "",
            "    def test_concat_plus(self):",
            "        self.assertEqual('abc', self.eval(\"a +b + c\"))",
            "",
            "    def test_concat_func(self):",
            "        self.assertEqual('abc', self.eval(\"concat(a, b, c)\"))",
            "",
            "    def test_format(self):",
            "        self.assertEqual('a->b', self.eval(\"'{0}->{x}'.format(a, x => b)\"))",
            "        self.assertEqual('a->b', self.eval(\"format('{0}->{x}', a, x => b)\"))",
            "",
            "    def test_trim(self):",
            "        self.assertEqual('x', self.eval(\"'  x  '.trim()\"))",
            "        self.assertEqual('x', self.eval(\"'abxba'.trim(ab)\"))",
            "",
            "    def test_trim_left(self):",
            "        self.assertEqual('x  ', self.eval(\"'  x  '.trimLeft()\"))",
            "        self.assertEqual('xba', self.eval(\"'abxba'.trimLeft(ab)\"))",
            "",
            "    def test_trim_right(self):",
            "        self.assertEqual('  x', self.eval(\"'  x  '.trimRight()\"))",
            "        self.assertEqual('abx', self.eval(\"'abxba'.trimRight(ab)\"))",
            "",
            "    def test_multiplication(self):",
            "        self.assertEqual('xxx', self.eval(\"x * 3\"))",
            "        self.assertEqual('xxx', self.eval(\"3 * x\"))",
            "",
            "    def test_substring(self):",
            "        data = 'abcdef'",
            "        self.assertEqual('cdef', self.eval('$.substring(2)', data=data))",
            "        self.assertEqual('ef', self.eval('$.substring(-2)', data=data))",
            "        self.assertEqual('cde', self.eval('$.substring(2, 3)', data=data))",
            "        self.assertEqual('de', self.eval('$.substring(-3, 2)', data=data))",
            "        self.assertEqual('bcdef', self.eval('$.substring(1, -1)', data=data))",
            "        self.assertEqual('bcdef', self.eval('$.substring(-5, -1)', data=data))",
            "",
            "    def test_index_of(self):",
            "        data = 'abcdefedcba'",
            "        self.assertEqual(2, self.eval('$.indexOf(c)', data=data))",
            "        self.assertEqual(2, self.eval('$.indexOf(c, 2)', data=data))",
            "        self.assertEqual(-1, self.eval('$.indexOf(x)', data=data))",
            "        self.assertEqual(5, self.eval('$.indexOf(f, 3)', data=data))",
            "        self.assertEqual(7, self.eval('$.indexOf(dcb, -4, 3)', data=data))",
            "        self.assertEqual(7, self.eval('$.indexOf(dcb, -4, 100)', data=data))",
            "        self.assertEqual(-1, self.eval('$.indexOf(dcb, 0, 5)', data=data))",
            "",
            "    def test_last_index_of(self):",
            "        data = 'abcdefedcbabc'",
            "        self.assertEqual(12, self.eval('$.lastIndexOf(c)', data=data))",
            "        self.assertEqual(2, self.eval('$.lastIndexOf(c, 0, 4)', data=data))",
            "        self.assertEqual(-1, self.eval('$.lastIndexOf(c, 3, 4)', data=data))",
            "        self.assertEqual(12, self.eval('$.lastIndexOf(c, -1, 1)', data=data))",
            "",
            "    def test_max(self):",
            "        self.assertEqual('z', self.eval('max(a, z)'))",
            "",
            "    def test_min(self):",
            "        self.assertEqual('a', self.eval('min(a, z)'))",
            "",
            "    def test_to_char_array(self):",
            "        self.assertEqual(['a', 'b', 'c'], self.eval('abc.toCharArray()'))",
            "",
            "    def test_characters(self):",
            "        self.assertCountEqual(",
            "            ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],",
            "            self.eval('characters(octdigits => true, digits => true)'))",
            "",
            "    def test_starts_with(self):",
            "        self.assertTrue(self.eval(\"ABC.startsWith(A)\"))",
            "        self.assertTrue(self.eval(\"ABC.startsWith(B, A)\"))",
            "        self.assertFalse(self.eval(\"ABC.startsWith(C)\"))",
            "        self.assertRaises(",
            "            exceptions.NoMatchingMethodException,",
            "            self.eval, \"ABC.startsWith(null)\")",
            "",
            "    def test_ends_with(self):",
            "        self.assertTrue(self.eval(\"ABC.endsWith(C)\"))",
            "        self.assertTrue(self.eval(\"ABC.endsWith(B, C)\"))",
            "        self.assertFalse(self.eval(\"ABC.endsWith(B)\"))",
            "        self.assertRaises(",
            "            exceptions.NoMatchingMethodException,",
            "            self.eval, \"ABC.endsWith(null)\")",
            "",
            "    def test_hex(self):",
            "        self.assertEqual('0xff', self.eval('hex(255)'))",
            "        self.assertEqual('-0x2a', self.eval('hex(-42)'))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "#    Copyright (c) 2015 Mirantis, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from yaql.language import exceptions",
            "import yaql.tests",
            "",
            "",
            "class TestStrings(yaql.tests.TestCase):",
            "    def test_scalar(self):",
            "        self.assertEqual(\"some \\ttext\", self.eval(\"'some \\\\ttext'\"))",
            "        self.assertEqual(r\"\\\\\", self.eval(r\"'\\\\\\\\'\"))",
            "        self.assertEqual(\"some \\\"text\\\"\", self.eval(r'\"some \\\"text\\\"\"'))",
            "",
            "    def test_verbatim_strings(self):",
            "        self.assertEqual('c:\\\\f\\\\x', self.eval(r\"`c:\\f\\x`\"))",
            "        self.assertEqual('`', self.eval(r\"`\\``\"))",
            "        self.assertEqual('\\\\n', self.eval(r\"`\\n`\"))",
            "        self.assertEqual(r\"\\\\\", self.eval(r\"`\\\\`\"))",
            "",
            "    def test_len(self):",
            "        self.assertEqual(3, self.eval('len(abc)'))",
            "",
            "    def test_to_upper(self):",
            "        self.assertEqual('QQ', self.eval('qq.toUpper()'))",
            "        self.assertEqual(u'\u041f\u0420\u0418\u0412\u0415\u0422', self.eval(u'\u041f\u0440\u0438\u0432\u0435\u0442.toUpper()'))",
            "",
            "    def test_to_lower(self):",
            "        self.assertEqual('qq', self.eval('QQ.toLower()'))",
            "        self.assertEqual(u'\u043f\u0440\u0438\u0432\u0435\u0442', self.eval(u'\u041f\u0440\u0438\u0432\u0435\u0442.toLower()'))",
            "",
            "    def test_eq(self):",
            "        self.assertTrue(self.eval('a = a'))",
            "        self.assertFalse(self.eval('a = b'))",
            "",
            "    def test_neq(self):",
            "        self.assertFalse(self.eval('a != a'))",
            "        self.assertTrue(self.eval('a != b'))",
            "",
            "    def test_is_string(self):",
            "        self.assertTrue(self.eval('isString(abc)'))",
            "        self.assertFalse(self.eval('isString(null)'))",
            "        self.assertFalse(self.eval('isString(123)'))",
            "        self.assertFalse(self.eval('isString(true)'))",
            "",
            "    def test_split(self):",
            "        self.assertEqual(",
            "            ['some', 'text'],",
            "            self.eval(\"$.split('\\\\n')\", data='some\\ntext'))",
            "",
            "    def test_rsplit(self):",
            "        self.assertEqual(",
            "            ['one\\ntwo', 'three'],",
            "            self.eval(\"$.rightSplit('\\\\n', 1)\", data='one\\ntwo\\nthree'))",
            "",
            "    def test_join(self):",
            "        self.assertEqual('some-text', self.eval(\"[some, text].join('-')\"))",
            "",
            "    def test_join_pythonic(self):",
            "        self.assertEqual('some-text', self.eval(\"'-'.join([some, text])\"))",
            "",
            "    def test_is_empty(self):",
            "        self.assertTrue(self.eval(\"isEmpty('')\"))",
            "        self.assertTrue(self.eval(\"isEmpty(null)\"))",
            "        self.assertTrue(self.eval(\"null.isEmpty()\"))",
            "        self.assertTrue(self.eval(\"isEmpty('  ')\"))",
            "        self.assertFalse(self.eval(\"isEmpty('  x')\"))",
            "",
            "    def test_norm(self):",
            "        self.assertIsNone(self.eval(\"norm('')\"))",
            "        self.assertIsNone(self.eval(\"norm(null)\"))",
            "        self.assertIsNone(self.eval(\"norm('  ')\"))",
            "        self.assertEqual('x', self.eval(\"norm('  x')\"))",
            "",
            "    def test_replace(self):",
            "        self.assertEqual('AxxD', self.eval(\"ABBD.replace(B, x)\"))",
            "        self.assertEqual('AxxD', self.eval(\"ABxD.replace(B, x, 1)\"))",
            "",
            "    def test_replace_with_dict(self):",
            "        self.assertEqual(",
            "            'Az1D',",
            "            self.eval('AxyD.replace({x => z, y => 1})'))",
            "",
            "        self.assertEqual(",
            "            'Ayfalse2D!', self.eval(",
            "                \"A122Dnull.replace({1 => y, 2 => false, null => '!'}, 1)\"))",
            "",
            "    def test_in(self):",
            "        self.assertTrue(self.eval(\"B in ABC\"))",
            "        self.assertFalse(self.eval(\"D in ABC\"))",
            "",
            "    def test_str(self):",
            "        self.assertEqual('null', self.eval('str(null)'))",
            "        self.assertEqual('true', self.eval('str(true)'))",
            "        self.assertEqual('false', self.eval('str(false)'))",
            "        self.assertEqual('12', self.eval(\"str('12')\"))",
            "",
            "    def test_join_seq(self):",
            "        self.assertEqual(",
            "            'text-1-null-true',",
            "            self.eval(\"[text, 1, null, true].select(str($)).join('-')\"))",
            "",
            "    def test_concat_plus(self):",
            "        self.assertEqual('abc', self.eval(\"a +b + c\"))",
            "",
            "    def test_concat_func(self):",
            "        self.assertEqual('abc', self.eval(\"concat(a, b, c)\"))",
            "",
            "    def test_trim(self):",
            "        self.assertEqual('x', self.eval(\"'  x  '.trim()\"))",
            "        self.assertEqual('x', self.eval(\"'abxba'.trim(ab)\"))",
            "",
            "    def test_trim_left(self):",
            "        self.assertEqual('x  ', self.eval(\"'  x  '.trimLeft()\"))",
            "        self.assertEqual('xba', self.eval(\"'abxba'.trimLeft(ab)\"))",
            "",
            "    def test_trim_right(self):",
            "        self.assertEqual('  x', self.eval(\"'  x  '.trimRight()\"))",
            "        self.assertEqual('abx', self.eval(\"'abxba'.trimRight(ab)\"))",
            "",
            "    def test_multiplication(self):",
            "        self.assertEqual('xxx', self.eval(\"x * 3\"))",
            "        self.assertEqual('xxx', self.eval(\"3 * x\"))",
            "",
            "    def test_substring(self):",
            "        data = 'abcdef'",
            "        self.assertEqual('cdef', self.eval('$.substring(2)', data=data))",
            "        self.assertEqual('ef', self.eval('$.substring(-2)', data=data))",
            "        self.assertEqual('cde', self.eval('$.substring(2, 3)', data=data))",
            "        self.assertEqual('de', self.eval('$.substring(-3, 2)', data=data))",
            "        self.assertEqual('bcdef', self.eval('$.substring(1, -1)', data=data))",
            "        self.assertEqual('bcdef', self.eval('$.substring(-5, -1)', data=data))",
            "",
            "    def test_index_of(self):",
            "        data = 'abcdefedcba'",
            "        self.assertEqual(2, self.eval('$.indexOf(c)', data=data))",
            "        self.assertEqual(2, self.eval('$.indexOf(c, 2)', data=data))",
            "        self.assertEqual(-1, self.eval('$.indexOf(x)', data=data))",
            "        self.assertEqual(5, self.eval('$.indexOf(f, 3)', data=data))",
            "        self.assertEqual(7, self.eval('$.indexOf(dcb, -4, 3)', data=data))",
            "        self.assertEqual(7, self.eval('$.indexOf(dcb, -4, 100)', data=data))",
            "        self.assertEqual(-1, self.eval('$.indexOf(dcb, 0, 5)', data=data))",
            "",
            "    def test_last_index_of(self):",
            "        data = 'abcdefedcbabc'",
            "        self.assertEqual(12, self.eval('$.lastIndexOf(c)', data=data))",
            "        self.assertEqual(2, self.eval('$.lastIndexOf(c, 0, 4)', data=data))",
            "        self.assertEqual(-1, self.eval('$.lastIndexOf(c, 3, 4)', data=data))",
            "        self.assertEqual(12, self.eval('$.lastIndexOf(c, -1, 1)', data=data))",
            "",
            "    def test_max(self):",
            "        self.assertEqual('z', self.eval('max(a, z)'))",
            "",
            "    def test_min(self):",
            "        self.assertEqual('a', self.eval('min(a, z)'))",
            "",
            "    def test_to_char_array(self):",
            "        self.assertEqual(['a', 'b', 'c'], self.eval('abc.toCharArray()'))",
            "",
            "    def test_characters(self):",
            "        self.assertCountEqual(",
            "            ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],",
            "            self.eval('characters(octdigits => true, digits => true)'))",
            "",
            "    def test_starts_with(self):",
            "        self.assertTrue(self.eval(\"ABC.startsWith(A)\"))",
            "        self.assertTrue(self.eval(\"ABC.startsWith(B, A)\"))",
            "        self.assertFalse(self.eval(\"ABC.startsWith(C)\"))",
            "        self.assertRaises(",
            "            exceptions.NoMatchingMethodException,",
            "            self.eval, \"ABC.startsWith(null)\")",
            "",
            "    def test_ends_with(self):",
            "        self.assertTrue(self.eval(\"ABC.endsWith(C)\"))",
            "        self.assertTrue(self.eval(\"ABC.endsWith(B, C)\"))",
            "        self.assertFalse(self.eval(\"ABC.endsWith(B)\"))",
            "        self.assertRaises(",
            "            exceptions.NoMatchingMethodException,",
            "            self.eval, \"ABC.endsWith(null)\")",
            "",
            "    def test_hex(self):",
            "        self.assertEqual('0xff', self.eval('hex(255)'))",
            "        self.assertEqual('-0x2a', self.eval('hex(-42)'))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "121": [
                "TestStrings",
                "test_format"
            ],
            "122": [
                "TestStrings",
                "test_format"
            ],
            "123": [
                "TestStrings",
                "test_format"
            ],
            "124": [
                "TestStrings"
            ]
        },
        "addLocation": []
    }
}