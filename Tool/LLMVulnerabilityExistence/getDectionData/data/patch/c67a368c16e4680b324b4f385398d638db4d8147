{
    "django/contrib/postgres/aggregates/general.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from django.contrib.postgres.fields import ArrayField, JSONField"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2,
                "PatchRowcode": "+from django.db.models import Value"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from django.db.models.aggregates import Aggregate"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from .mixins import OrderableAggMixin"
            },
            "5": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " class StringAgg(OrderableAggMixin, Aggregate):"
            },
            "7": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     function = 'STRING_AGG'"
            },
            "8": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    template = \"%(function)s(%(distinct)s%(expressions)s, '%(delimiter)s'%(ordering)s)\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'"
            },
            "10": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     allow_distinct = True"
            },
            "11": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     def __init__(self, expression, delimiter, **extra):"
            },
            "13": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super().__init__(expression, delimiter=delimiter, **extra)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        delimiter_expr = Value(str(delimiter))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        super().__init__(expression, delimiter_expr, **extra)"
            },
            "16": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     def convert_value(self, value, expression, connection):"
            },
            "18": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         if not value:"
            }
        },
        "frontPatchFile": [
            "from django.contrib.postgres.fields import ArrayField, JSONField",
            "from django.db.models.aggregates import Aggregate",
            "",
            "from .mixins import OrderableAggMixin",
            "",
            "__all__ = [",
            "    'ArrayAgg', 'BitAnd', 'BitOr', 'BoolAnd', 'BoolOr', 'JSONBAgg', 'StringAgg',",
            "]",
            "",
            "",
            "class ArrayAgg(OrderableAggMixin, Aggregate):",
            "    function = 'ARRAY_AGG'",
            "    template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'",
            "    allow_distinct = True",
            "",
            "    @property",
            "    def output_field(self):",
            "        return ArrayField(self.source_expressions[0].output_field)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        if not value:",
            "            return []",
            "        return value",
            "",
            "",
            "class BitAnd(Aggregate):",
            "    function = 'BIT_AND'",
            "",
            "",
            "class BitOr(Aggregate):",
            "    function = 'BIT_OR'",
            "",
            "",
            "class BoolAnd(Aggregate):",
            "    function = 'BOOL_AND'",
            "",
            "",
            "class BoolOr(Aggregate):",
            "    function = 'BOOL_OR'",
            "",
            "",
            "class JSONBAgg(Aggregate):",
            "    function = 'JSONB_AGG'",
            "    output_field = JSONField()",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        if not value:",
            "            return []",
            "        return value",
            "",
            "",
            "class StringAgg(OrderableAggMixin, Aggregate):",
            "    function = 'STRING_AGG'",
            "    template = \"%(function)s(%(distinct)s%(expressions)s, '%(delimiter)s'%(ordering)s)\"",
            "    allow_distinct = True",
            "",
            "    def __init__(self, expression, delimiter, **extra):",
            "        super().__init__(expression, delimiter=delimiter, **extra)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        if not value:",
            "            return ''",
            "        return value"
        ],
        "afterPatchFile": [
            "from django.contrib.postgres.fields import ArrayField, JSONField",
            "from django.db.models import Value",
            "from django.db.models.aggregates import Aggregate",
            "",
            "from .mixins import OrderableAggMixin",
            "",
            "__all__ = [",
            "    'ArrayAgg', 'BitAnd', 'BitOr', 'BoolAnd', 'BoolOr', 'JSONBAgg', 'StringAgg',",
            "]",
            "",
            "",
            "class ArrayAgg(OrderableAggMixin, Aggregate):",
            "    function = 'ARRAY_AGG'",
            "    template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'",
            "    allow_distinct = True",
            "",
            "    @property",
            "    def output_field(self):",
            "        return ArrayField(self.source_expressions[0].output_field)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        if not value:",
            "            return []",
            "        return value",
            "",
            "",
            "class BitAnd(Aggregate):",
            "    function = 'BIT_AND'",
            "",
            "",
            "class BitOr(Aggregate):",
            "    function = 'BIT_OR'",
            "",
            "",
            "class BoolAnd(Aggregate):",
            "    function = 'BOOL_AND'",
            "",
            "",
            "class BoolOr(Aggregate):",
            "    function = 'BOOL_OR'",
            "",
            "",
            "class JSONBAgg(Aggregate):",
            "    function = 'JSONB_AGG'",
            "    output_field = JSONField()",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        if not value:",
            "            return []",
            "        return value",
            "",
            "",
            "class StringAgg(OrderableAggMixin, Aggregate):",
            "    function = 'STRING_AGG'",
            "    template = '%(function)s(%(distinct)s%(expressions)s %(ordering)s)'",
            "    allow_distinct = True",
            "",
            "    def __init__(self, expression, delimiter, **extra):",
            "        delimiter_expr = Value(str(delimiter))",
            "        super().__init__(expression, delimiter_expr, **extra)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        if not value:",
            "            return ''",
            "        return value"
        ],
        "action": [
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "54": [
                "StringAgg"
            ],
            "58": [
                "StringAgg",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "django/contrib/postgres/aggregates/mixins.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " class OrderableAggMixin:"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, expression, ordering=(), **extra):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+    def __init__(self, *expressions, ordering=(), **extra):"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": "         if not isinstance(ordering, (list, tuple)):"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "             ordering = [ordering]"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "         ordering = ordering or []"
            },
            "8": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "             (OrderBy(F(o[1:]), descending=True) if isinstance(o, str) and o[0] == '-' else o)"
            },
            "9": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "             for o in ordering"
            },
            "10": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "         )"
            },
            "11": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        super().__init__(expression, **extra)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+        super().__init__(*expressions, **extra)"
            },
            "13": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "         self.ordering = self._parse_expressions(*ordering)"
            },
            "14": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     def resolve_expression(self, *args, **kwargs):"
            }
        },
        "frontPatchFile": [
            "from django.db.models.expressions import F, OrderBy",
            "",
            "",
            "class OrderableAggMixin:",
            "",
            "    def __init__(self, expression, ordering=(), **extra):",
            "        if not isinstance(ordering, (list, tuple)):",
            "            ordering = [ordering]",
            "        ordering = ordering or []",
            "        # Transform minus sign prefixed strings into an OrderBy() expression.",
            "        ordering = (",
            "            (OrderBy(F(o[1:]), descending=True) if isinstance(o, str) and o[0] == '-' else o)",
            "            for o in ordering",
            "        )",
            "        super().__init__(expression, **extra)",
            "        self.ordering = self._parse_expressions(*ordering)",
            "",
            "    def resolve_expression(self, *args, **kwargs):",
            "        self.ordering = [expr.resolve_expression(*args, **kwargs) for expr in self.ordering]",
            "        return super().resolve_expression(*args, **kwargs)",
            "",
            "    def as_sql(self, compiler, connection):",
            "        if self.ordering:",
            "            ordering_params = []",
            "            ordering_expr_sql = []",
            "            for expr in self.ordering:",
            "                expr_sql, expr_params = expr.as_sql(compiler, connection)",
            "                ordering_expr_sql.append(expr_sql)",
            "                ordering_params.extend(expr_params)",
            "            sql, sql_params = super().as_sql(compiler, connection, ordering=(",
            "                'ORDER BY ' + ', '.join(ordering_expr_sql)",
            "            ))",
            "            return sql, sql_params + ordering_params",
            "        return super().as_sql(compiler, connection, ordering='')",
            "",
            "    def set_source_expressions(self, exprs):",
            "        # Extract the ordering expressions because ORDER BY clause is handled",
            "        # in a custom way.",
            "        self.ordering = exprs[self._get_ordering_expressions_index():]",
            "        return super().set_source_expressions(exprs[:self._get_ordering_expressions_index()])",
            "",
            "    def get_source_expressions(self):",
            "        return self.source_expressions + self.ordering",
            "",
            "    def get_source_fields(self):",
            "        # Filter out fields contributed by the ordering expressions as",
            "        # these should not be used to determine which the return type of the",
            "        # expression.",
            "        return [",
            "            e._output_field_or_none",
            "            for e in self.get_source_expressions()[:self._get_ordering_expressions_index()]",
            "        ]",
            "",
            "    def _get_ordering_expressions_index(self):",
            "        \"\"\"Return the index at which the ordering expressions start.\"\"\"",
            "        source_expressions = self.get_source_expressions()",
            "        return len(source_expressions) - len(self.ordering)"
        ],
        "afterPatchFile": [
            "from django.db.models.expressions import F, OrderBy",
            "",
            "",
            "class OrderableAggMixin:",
            "",
            "    def __init__(self, *expressions, ordering=(), **extra):",
            "        if not isinstance(ordering, (list, tuple)):",
            "            ordering = [ordering]",
            "        ordering = ordering or []",
            "        # Transform minus sign prefixed strings into an OrderBy() expression.",
            "        ordering = (",
            "            (OrderBy(F(o[1:]), descending=True) if isinstance(o, str) and o[0] == '-' else o)",
            "            for o in ordering",
            "        )",
            "        super().__init__(*expressions, **extra)",
            "        self.ordering = self._parse_expressions(*ordering)",
            "",
            "    def resolve_expression(self, *args, **kwargs):",
            "        self.ordering = [expr.resolve_expression(*args, **kwargs) for expr in self.ordering]",
            "        return super().resolve_expression(*args, **kwargs)",
            "",
            "    def as_sql(self, compiler, connection):",
            "        if self.ordering:",
            "            ordering_params = []",
            "            ordering_expr_sql = []",
            "            for expr in self.ordering:",
            "                expr_sql, expr_params = expr.as_sql(compiler, connection)",
            "                ordering_expr_sql.append(expr_sql)",
            "                ordering_params.extend(expr_params)",
            "            sql, sql_params = super().as_sql(compiler, connection, ordering=(",
            "                'ORDER BY ' + ', '.join(ordering_expr_sql)",
            "            ))",
            "            return sql, sql_params + ordering_params",
            "        return super().as_sql(compiler, connection, ordering='')",
            "",
            "    def set_source_expressions(self, exprs):",
            "        # Extract the ordering expressions because ORDER BY clause is handled",
            "        # in a custom way.",
            "        self.ordering = exprs[self._get_ordering_expressions_index():]",
            "        return super().set_source_expressions(exprs[:self._get_ordering_expressions_index()])",
            "",
            "    def get_source_expressions(self):",
            "        return self.source_expressions + self.ordering",
            "",
            "    def get_source_fields(self):",
            "        # Filter out fields contributed by the ordering expressions as",
            "        # these should not be used to determine which the return type of the",
            "        # expression.",
            "        return [",
            "            e._output_field_or_none",
            "            for e in self.get_source_expressions()[:self._get_ordering_expressions_index()]",
            "        ]",
            "",
            "    def _get_ordering_expressions_index(self):",
            "        \"\"\"Return the index at which the ordering expressions start.\"\"\"",
            "        source_expressions = self.get_source_expressions()",
            "        return len(source_expressions) - len(self.ordering)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [
                "OrderableAggMixin",
                "__init__"
            ],
            "15": [
                "OrderableAggMixin",
                "__init__"
            ]
        },
        "addLocation": []
    }
}