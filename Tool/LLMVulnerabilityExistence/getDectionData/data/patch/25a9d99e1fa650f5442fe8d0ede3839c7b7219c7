{
    "skops/card/_model_card.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from hashlib import sha256"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from pathlib import Path"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from reprlib import Repr"
            },
            "3": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any, Iterator, Literal, Sequence, Union"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from typing import Any, Iterator, List, Literal, Optional, Sequence, Union"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import joblib"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from huggingface_hub import ModelCardData"
            },
            "8": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": 488,
                "PatchRowcode": "         model_diagram: bool | Literal[\"auto\"] | str = \"auto\","
            },
            "9": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 489,
                "PatchRowcode": "         metadata: ModelCardData | None = None,"
            },
            "10": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 490,
                "PatchRowcode": "         template: Literal[\"skops\"] | dict[str, str] | None = \"skops\","
            },
            "11": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        trusted: bool = False,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+        trusted: Optional[List[str]] = None,"
            },
            "13": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": 492,
                "PatchRowcode": "     ) -> None:"
            },
            "14": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 493,
                "PatchRowcode": "         self.model = model"
            },
            "15": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 494,
                "PatchRowcode": "         self.metadata = metadata or ModelCardData()"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "import re",
            "import shutil",
            "import sys",
            "import textwrap",
            "import zipfile",
            "from collections.abc import Mapping",
            "from dataclasses import dataclass, field",
            "from functools import cached_property",
            "from hashlib import sha256",
            "from pathlib import Path",
            "from reprlib import Repr",
            "from typing import Any, Iterator, Literal, Sequence, Union",
            "",
            "import joblib",
            "from huggingface_hub import ModelCardData",
            "from sklearn.utils import estimator_html_repr",
            "from tabulate import tabulate  # type: ignore",
            "",
            "from skops.card._templates import CONTENT_PLACEHOLDER, SKOPS_TEMPLATE, Templates",
            "from skops.io import load",
            "from skops.utils._fixes import boxplot",
            "from skops.utils.importutils import import_or_raise",
            "",
            "if sys.version_info >= (3, 11):",
            "    from typing import Self",
            "else:",
            "    from typing_extensions import Self",
            "",
            "# Repr attributes can be used to control the behavior of repr",
            "aRepr = Repr()",
            "aRepr.maxother = 79",
            "aRepr.maxstring = 79",
            "",
            "VALID_TEMPLATES = {item.value for item in Templates}",
            "NEED_SECTION_ERR_MSG = (",
            "    \"You are trying to {action} but you're using a custom template, please pass the \"",
            "    \"'section' argument to determine where to put the content\"",
            ")",
            "",
            "",
            "def wrap_as_details(text: str, folded: bool) -> str:",
            "    if not folded:",
            "        return text",
            "    return f\"<details>\\n<summary> Click to expand </summary>\\n\\n{text}\\n\\n</details>\"",
            "",
            "",
            "def _clean_table(table: str) -> str:",
            "    # replace line breaks \"\\n\" with html tag <br />, however, leave end-of-line",
            "    # line breaks (eol_lb) intact",
            "    eol_lb = \"|\\n\"",
            "    placeholder = \"\\x1f\"  # unit separator control character (ASCII control char 31)",
            "    table = (",
            "        table.replace(eol_lb, placeholder)",
            "        .replace(\"\\n\", \"<br />\")",
            "        .replace(placeholder, eol_lb)",
            "    )",
            "    return table",
            "",
            "",
            "def metadata_from_config(config_path: Union[str, Path]) -> ModelCardData:",
            "    \"\"\"Construct a ``ModelCardData`` object from a ``config.json`` file.",
            "",
            "    Most information needed for the metadata section of a ``README.md`` file on",
            "    Hugging Face Hub is included in the ``config.json`` file. This utility",
            "    function constructs a :class:`huggingface_hub.ModelCardData` object which",
            "    can then be passed to the :class:`~skops.card.Card` object.",
            "",
            "    This method populates the following attributes of the instance:",
            "",
            "    - ``library_name``: It needs to be ``\"sklearn\"`` for scikit-learn",
            "        compatible models.",
            "    - ``tags``: Set to a list, containing ``\"sklearn\"`` and the task of the",
            "        model. You can then add more tags to this list.",
            "    - ``widget``: It is populated with the example data to be used by the",
            "        widget component of the Hugging Face Hub widget, on the model's",
            "        repository page.",
            "",
            "    Parameters",
            "    ----------",
            "    config_path: str, or Path",
            "        Filepath to the ``config.json`` file, or the folder including that",
            "        file.",
            "",
            "    Returns",
            "    -------",
            "    card_data: huggingface_hub.ModelCardData",
            "        :class:`huggingface_hub.ModelCardData` object.",
            "",
            "    \"\"\"",
            "    config_path = Path(config_path)",
            "    if not config_path.is_file():",
            "        config_path = config_path / \"config.json\"",
            "",
            "    with open(config_path) as f:",
            "        config = json.load(f)",
            "    card_data = ModelCardData(",
            "        model_format=config.get(\"sklearn\", {}).get(\"model_format\", {})",
            "    )",
            "    card_data.library_name = \"sklearn\"",
            "    card_data.tags = [\"sklearn\", \"skops\"]",
            "    task = config.get(\"sklearn\", {}).get(\"task\", None)",
            "    if task:",
            "        card_data.tags += [task]",
            "    card_data.model_file = config.get(\"sklearn\", {}).get(\"model\", {}).get(\"file\")  # type: ignore",
            "",
            "    example_input = config.get(\"sklearn\", {}).get(\"example_input\", None)",
            "    # Documentation on what the widget expects:",
            "    # https://huggingface.co/docs/hub/models-widgets-examples",
            "    if example_input:",
            "        if \"tabular\" in task:",
            "            card_data.widget = [{\"structuredData\": example_input}]  # type: ignore",
            "        # TODO: add text data example here.",
            "",
            "    return card_data",
            "",
            "",
            "def split_subsection_names(key: str) -> list[str]:",
            "    r\"\"\"Split a string containing multiple sections into a list of strings for",
            "    each.",
            "",
            "    The separator is ``\"/\"``. To avoid splitting on ``\"/\"``, escape it using",
            "    ``\"\\\\/\"``.",
            "",
            "    Examples",
            "    --------",
            "    >>> split_subsection_names(\"Section A\")",
            "    ['Section A']",
            "    >>> split_subsection_names(\"Section A/Section B/Section C\")",
            "    ['Section A', 'Section B', 'Section C']",
            "    >>> split_subsection_names(\"A section containing \\\\/ a slash\")",
            "    ['A section containing / a slash']",
            "    >>> split_subsection_names(\"Spaces are / stripped\")",
            "    ['Spaces are', 'stripped']",
            "",
            "    Parameters",
            "    ----------",
            "    key : str",
            "        The section name consisting potentially of multiple subsections. It has",
            "        to be ensured beforhand that this is not an empty string.",
            "",
            "    Returns",
            "    -------",
            "    parts : list of str",
            "        The individual (sub)sections.",
            "",
            "    \"\"\"",
            "    placeholder = \"\\x1f\"  # unit separator control character (ASCII control char 31)",
            "    key = key.replace(\"\\\\/\", placeholder)",
            "    parts = (part.strip() for part in key.split(\"/\"))",
            "    return [part.replace(placeholder, \"/\") for part in parts]",
            "",
            "",
            "def _getting_started_code(",
            "    file_name: str, model_format: Literal[\"pickle\", \"skops\"], indent: str = \"    \"",
            ") -> list[str]:",
            "    # get lines of code required to load the model",
            "    lines = [",
            "        \"import json\",",
            "        \"import pandas as pd\",",
            "    ]",
            "    if model_format == \"skops\":",
            "        lines += [\"import skops.io as sio\"]",
            "    else:",
            "        lines += [\"import joblib\"]",
            "",
            "    if model_format == \"skops\":",
            "        lines += [f'model = sio.load(\"{file_name}\")']",
            "    else:  # pickle",
            "        lines += [f'model = joblib.load(\"{file_name}\")']",
            "",
            "    lines += [",
            "        'with open(\"config.json\") as f:',",
            "        indent + \"config = json.load(f)\",",
            "        'model.predict(pd.DataFrame.from_dict(config[\"sklearn\"][\"example_input\"]))',",
            "    ]",
            "    return lines",
            "",
            "",
            "@dataclass",
            "class Section:",
            "    \"\"\"Building block of the model card.",
            "",
            "    The model card is represented internally as a dict with keys being strings",
            "    and values being ``Section``s. The key is identical to the section title.",
            "",
            "    Additionally, the section may hold content in the form of strings (can be an",
            "    empty string) or a ``Formattable``, which is simply an object with a",
            "    ``format`` method that returns a string.",
            "",
            "    The section can contain subsections, which again are dicts of",
            "    string keys and section values (the dict can be empty). Therefore, the model",
            "    card representation forms a tree structure, making use of the fact that dict",
            "    order is preserved.",
            "",
            "    The section may also contain a ``visible`` flag, which determines if the",
            "    section will be shown when the card is rendered.",
            "",
            "    \"\"\"",
            "",
            "    title: str",
            "    content: str",
            "    subsections: dict[str, Section] = field(default_factory=dict)",
            "    visible: bool = True",
            "    folded: bool = False",
            "",
            "    def select(self, key: str) -> Section:",
            "        \"\"\"Return a subsection or subsubsection of this section",
            "",
            "        Parameters",
            "        ----------",
            "        key : str",
            "            The name of the (sub)section to select. When selecting a subsection,",
            "            either use a ``\"/\"`` in the name to separate the parent and child",
            "            sections, chain multiple ``select`` calls.",
            "",
            "        Returns",
            "        -------",
            "        section : Section",
            "            A dataclass containing all information relevant to the selected",
            "            section. Those are the title, the content, subsections (in a dict),",
            "            and additional fields that depend on the type of section.",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the given section name was not found, a ``KeyError`` is raised.",
            "",
            "        \"\"\"",
            "        section_names = split_subsection_names(key)",
            "        # check that no section name is empty",
            "        if not all(bool(name) for name in section_names):",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        section: Section = self",
            "        for section_name in section_names:",
            "            section = section.subsections[section_name]",
            "        return section",
            "",
            "    def format(self) -> str:",
            "        return wrap_as_details(self.content, folded=self.folded)",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"Generates the ``repr`` of this section.",
            "",
            "        ``repr`` determines how the content of this section is shown in the",
            "        Card's repr.",
            "        \"\"\"",
            "        return self.content",
            "",
            "",
            "@dataclass",
            "class PlotSection(Section):",
            "    \"\"\"Adds a link to a figure to the model card\"\"\"",
            "",
            "    path: str | Path = \"\"",
            "    alt_text: str = \"\"",
            "    folded: bool = False",
            "",
            "    def __post_init__(self) -> None:",
            "        if not self.path:",
            "            raise TypeError(f\"{self.__class__.__name__} requires a path\")",
            "",
            "    def format(self) -> str:",
            "        # if no alt text provided, fall back to figure path",
            "        alt_text = self.alt_text or self.path",
            "        text = f\"![{alt_text}]({self.path})\"",
            "        val = wrap_as_details(text, folded=self.folded)",
            "        if self.content:",
            "            val = f\"{self.content}\\n\\n{val}\"",
            "        return val",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"{self.__class__.__name__}({self.path})\"",
            "",
            "",
            "@dataclass",
            "class TableSection(Section):",
            "    \"\"\"Adds a table to the model card\"\"\"",
            "",
            "    table: Mapping[str, Sequence[Any]] = field(default_factory=dict)",
            "    folded: bool = False",
            "",
            "    def __post_init__(self) -> None:",
            "        self._check_table()",
            "",
            "    def _check_table(self) -> None:",
            "        try:",
            "            import pandas as pd",
            "",
            "            self._is_pandas_df = isinstance(self.table, pd.DataFrame)",
            "        except ImportError:",
            "            self._is_pandas_df = False",
            "",
            "        if self._is_pandas_df:",
            "            ncols = len(self.table.columns)  # type: ignore",
            "        else:",
            "            ncols = len(self.table)",
            "        if ncols == 0:",
            "            raise ValueError(\"Trying to add table with no columns\")",
            "",
            "    def format(self) -> str:",
            "        if self._is_pandas_df:",
            "            headers = self.table.columns  # type: ignore",
            "        else:",
            "            headers = self.table.keys()",
            "",
            "        table = _clean_table(",
            "            tabulate(self.table, tablefmt=\"github\", headers=headers, showindex=False)",
            "        )",
            "        val = wrap_as_details(table, folded=self.folded)",
            "",
            "        if self.content:",
            "            val = f\"{self.content}\\n\\n{val}\"",
            "        return val",
            "",
            "    def __repr__(self) -> str:",
            "        if self._is_pandas_df:",
            "            nrows, ncols = self.table.shape  # type: ignore",
            "        else:",
            "            # table cannot be empty, so no checks needed here",
            "            ncols = len(self.table)",
            "            key = next(iter(self.table.keys()))",
            "            nrows = len(self.table[key])",
            "        return f\"{self.__class__.__name__}({nrows}x{ncols})\"",
            "",
            "",
            "def _load_model(model: Any, trusted=False) -> Any:",
            "    \"\"\"Return a model instance.",
            "",
            "    Loads the model if provided a file path, if already a model instance return",
            "    it unmodified.",
            "",
            "    Parameters",
            "    ----------",
            "    model : pathlib.Path, str, or sklearn estimator",
            "        Path/str or the actual model instance. if a Path or str, loads the model.",
            "",
            "    trusted : bool, default=False",
            "        Passed to :func:`skops.io.load` if the model is a file path and it's",
            "        a `skops` file.",
            "",
            "    Returns",
            "    -------",
            "    model : object",
            "        Model instance.",
            "    \"\"\"",
            "",
            "    if not isinstance(model, (Path, str)):",
            "        return model",
            "",
            "    model_path = Path(model)",
            "    if not model_path.exists():",
            "        raise FileNotFoundError(f\"File is not present: {model_path}\")",
            "",
            "    try:",
            "        if zipfile.is_zipfile(model_path):",
            "            model = load(model_path, trusted=trusted)",
            "        else:",
            "            model = joblib.load(model_path)",
            "    except Exception as ex:",
            "        msg = f'An \"{type(ex).__name__}\" occurred during model loading.'",
            "        raise RuntimeError(msg) from ex",
            "",
            "    return model",
            "",
            "",
            "class Card:",
            "    \"\"\"Model card class that will be used to generate model card.",
            "",
            "    This class can be used to write information and plots to model card and save",
            "    it. This class by default generates an interactive plot of the model and a",
            "    table of hyperparameters. Some sections are added by default.",
            "",
            "    Parameters",
            "    ----------",
            "    model: pathlib.Path, str, or sklearn estimator object",
            "        ``Path``/``str`` of the model or the actual model instance that will be",
            "        documented. If a ``Path`` or ``str`` is provided, model will be loaded.",
            "",
            "    model_diagram: bool or \"auto\" or str, default=\"auto\"",
            "        If using the skops template, setting this to ``True`` or ``\"auto\"`` will",
            "        add the model diagram, as generated by sckit-learn, to the default",
            "        section, i.e \"Model description/Training Procedure/Model Plot\". Passing",
            "        a string to ``model_diagram`` will instead use that string as the",
            "        section name for the diagram. Set to ``False`` to not include the model",
            "        diagram.",
            "",
            "        If using a non-skops template, passing ``\"auto\"`` won't add the model",
            "        diagram because there is no pre-defined section to put it. The model",
            "        diagram can, however, always be added later using",
            "        :meth:`Card.add_model_plot`.",
            "",
            "    metadata: ModelCardData, optional",
            "        :class:`huggingface_hub.ModelCardData` object. The contents of this",
            "        object are saved as metadata at the beginning of the output file, and",
            "        used by Hugging Face Hub.",
            "",
            "        You can use :func:`~skops.card.metadata_from_config` to create an",
            "        instance pre-populated with necessary information based on the contents",
            "        of the ``config.json`` file, which itself is created by",
            "        :func:`skops.hub_utils.init`.",
            "",
            "    template: \"skops\", dict, or None (default=\"skops\")",
            "        Whether to add default sections or not. The template can be a predefined",
            "        template, which at the moment can only be the string ``\"skops\"``, which",
            "        is a template provided by ``skops`` that is geared towards typical",
            "        sklearn models. If you don't want any prefilled sections, just pass",
            "        ``None``. If you want custom prefilled sections, pass a ``dict``, where",
            "        keys are the sections and values are the contents of the sections. Note",
            "        that when you use no template or a custom template, some methods will",
            "        not work, e.g. :meth:`Card.add_metrics`, since it's not clear where to",
            "        put the metrics when there is no template or a custom template.",
            "",
            "    trusted: bool, default=False",
            "        Passed to :func:`skops.io.load` if the model is a file path and it's",
            "        a `skops` file.",
            "",
            "    Attributes",
            "    ----------",
            "    model: estimator object",
            "        The scikit-learn compatible model that will be documented.",
            "",
            "    metadata: ModelCardData",
            "        Metadata to be stored at the beginning of the saved model card, as",
            "        metadata to be understood by the Hugging Face Hub.",
            "",
            "    Examples",
            "    --------",
            "    >>> from sklearn.metrics import (",
            "    ...     ConfusionMatrixDisplay,",
            "    ...     confusion_matrix,",
            "    ...     accuracy_score,",
            "    ...     f1_score",
            "    ... )",
            "    >>> import tempfile",
            "    >>> from pathlib import Path",
            "    >>> from sklearn.datasets import load_iris",
            "    >>> from sklearn.linear_model import LogisticRegression",
            "    >>> from skops.card import Card",
            "    >>> X, y = load_iris(return_X_y=True)",
            "    >>> model = LogisticRegression(solver=\"liblinear\", random_state=0).fit(X, y)",
            "    >>> model_card = Card(model)",
            "    >>> model_card.metadata.license = \"mit\"",
            "    >>> y_pred = model.predict(X)",
            "    >>> model_card.add_metrics(**{",
            "    ...     \"accuracy\": accuracy_score(y, y_pred),",
            "    ...     \"f1 score\": f1_score(y, y_pred, average=\"micro\"),",
            "    ... })",
            "    Card(...)",
            "    >>> cm = confusion_matrix(y, y_pred,labels=model.classes_)",
            "    >>> disp = ConfusionMatrixDisplay(",
            "    ...     confusion_matrix=cm,",
            "    ...     display_labels=model.classes_",
            "    ... )",
            "    >>> disp.plot()",
            "    <sklearn.metrics._plot.confusion_matrix.ConfusionMatrixDisplay object at ...>",
            "    >>> tmp_path = Path(tempfile.mkdtemp(prefix=\"skops-\"))",
            "    >>> disp.figure_.savefig(tmp_path / \"confusion_matrix.png\")",
            "    ...",
            "    >>> model_card.add_plot(**{",
            "    ...     \"Model description/Confusion Matrix\": tmp_path / \"confusion_matrix.png\"",
            "    ... })",
            "    Card(...)",
            "    >>> # add new content to the existing section \"Model description\"",
            "    >>> model_card.add(**{\"Model description\": \"This is the best model\"})",
            "    Card(...)",
            "    >>> # add content to a new section",
            "    >>> model_card.add(**{\"A new section\": \"Please rate my model\"})",
            "    Card(...)",
            "    >>> # add new subsection to an existing section by using \"/\"",
            "    >>> model_card.add(**{\"Model description/Model name\": \"This model is called Bob\"})",
            "    Card(",
            "      model=LogisticRegression(random_state=0, solver='liblinear'),",
            "      ...",
            "    )",
            "    >>> # save the card to a README.md file",
            "    >>> model_card.save(tmp_path / \"README.md\")",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        model,",
            "        model_diagram: bool | Literal[\"auto\"] | str = \"auto\",",
            "        metadata: ModelCardData | None = None,",
            "        template: Literal[\"skops\"] | dict[str, str] | None = \"skops\",",
            "        trusted: bool = False,",
            "    ) -> None:",
            "        self.model = model",
            "        self.metadata = metadata or ModelCardData()",
            "        self.template = template",
            "        self.trusted = trusted",
            "",
            "        self._data: dict[str, Section] = {}",
            "        self._metrics: dict[str, str | float | int] = {}",
            "        self._model_hash = \"\"",
            "",
            "        self._populate_template(model_diagram=model_diagram)",
            "",
            "    def _populate_template(self, model_diagram: bool | Literal[\"auto\"] | str):",
            "        \"\"\"If initialized with a template, use it to populate the card.",
            "",
            "        Parameters",
            "        ----------",
            "        model_diagram: bool or \"auto\" or str",
            "            If using the default template, ``\"auto\"`` and ``True`` will add the",
            "            diagram in its default section. If using a custom template,",
            "            ``\"auto\"`` will not add the diagram, and passing ``True`` will",
            "            result in an error. For either, passing ``False`` will result in the",
            "            model diagram being omitted, and passing a string (other than",
            "            ``\"auto\"``) will put the model diagram into a section corresponding",
            "            to that string.",
            "",
            "        \"\"\"",
            "        if isinstance(self.template, str) and (self.template not in VALID_TEMPLATES):",
            "            valid_templates = \", \".join(f\"'{val}'\" for val in sorted(VALID_TEMPLATES))",
            "            msg = (",
            "                f\"Unknown template '{self.template}', \"",
            "                f\"template must be one of the following values: {valid_templates}\"",
            "            )",
            "            raise ValueError(msg)",
            "",
            "        # default template",
            "        if self.template == Templates.skops.value:",
            "            self.add(folded=False, **SKOPS_TEMPLATE)",
            "            # for the skops template, automatically add some default sections",
            "            self.add_hyperparams()",
            "            self.add_get_started_code()",
            "",
            "            if (model_diagram is True) or (model_diagram == \"auto\"):",
            "                self.add_model_plot()",
            "            elif isinstance(model_diagram, str):",
            "                self.add_model_plot(section=model_diagram)",
            "            return",
            "",
            "        # non-default template",
            "        if isinstance(self.template, Mapping):",
            "            self.add(folded=False, **self.template)",
            "",
            "        if isinstance(model_diagram, str) and (model_diagram != \"auto\"):",
            "            self.add_model_plot(section=model_diagram)",
            "        elif model_diagram is True:",
            "            # will trigger an error",
            "            self.add_model_plot()",
            "",
            "    def get_model(self) -> Any:",
            "        \"\"\"Returns sklearn estimator object.",
            "",
            "        If the ``model`` is already loaded, return it as is. If the ``model``",
            "        attribute is a ``Path``/``str``, load the model and return it.",
            "",
            "        Returns",
            "        -------",
            "        model : BaseEstimator",
            "            The model instance.",
            "",
            "        \"\"\"",
            "        if isinstance(self.model, (str, Path)) and hasattr(self, \"_model\"):",
            "            hash_obj = sha256()",
            "            buf_size = 2**20  # load in chunks to save memory",
            "            with open(self.model, \"rb\") as f:",
            "                for chunk in iter(lambda: f.read(buf_size), b\"\"):",
            "                    hash_obj.update(chunk)",
            "            model_hash = hash_obj.hexdigest()",
            "",
            "            # if hash changed, invalidate cache by deleting attribute",
            "            if model_hash != self._model_hash:",
            "                del self._model",
            "                self._model_hash = model_hash",
            "",
            "        return self._model",
            "",
            "    @cached_property",
            "    def _model(self):",
            "        model = _load_model(self.model, self.trusted)",
            "        return model",
            "",
            "    def add(self, folded: bool = False, **kwargs: str) -> Self:",
            "        \"\"\"Add new section(s) to the model card.",
            "",
            "        Add one or multiple sections to the model card. The section names are",
            "        taken from the keys and the contents are taken from the values.",
            "",
            "        To add to an existing section, use a ``\"/\"`` in the section name, e.g.:",
            "",
            "        ``card.add(**{\"Existing section/New section\": \"content\"})``.",
            "",
            "        If the parent section does not exist, it will be added automatically.",
            "",
            "        To add a section with ``\"/\"`` in its title (i.e. not inteded as a",
            "        subsection), escape the slash like so, ``\"\\\\/\"``, e.g.:",
            "",
            "        ``card.add(**{\"A section with\\\\/a slash in the title\": \"content\"})``.",
            "",
            "        If a section of the given name already exists, its content will be",
            "        overwritten.",
            "",
            "        Parameters",
            "        ----------",
            "        folded : bool",
            "            Whether to fold the sections by default or not.",
            "",
            "        **kwargs : dict",
            "            The keys of the dictionary serve as the section title and the values",
            "            as the section content. It's possible to add to existing sections.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        for key, val in kwargs.items():",
            "            self._add_single(key, val, folded=folded)",
            "        return self",
            "",
            "    def _select(",
            "        self, subsection_names: Sequence[str], create: bool = True",
            "    ) -> dict[str, Section]:",
            "        \"\"\"Select a single section from the data.",
            "",
            "        Parameters",
            "        ----------",
            "        subsection_names: list of str",
            "            The subsection names, already split into individual subsections.",
            "",
            "        create: bool (default=True)",
            "            Whether to create the subsection if it does not already exist or",
            "            not.",
            "",
            "        Returns",
            "        -------",
            "        section: dict of Section",
            "            A dict mapping the section key (identical to the title) to the",
            "            actual ``Section``, which is a dataclass that contains the actual",
            "            data of the section.",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the section does not exist and ``create=False``, raises a",
            "            ``KeyError``.",
            "",
            "        \"\"\"",
            "        section = self._data",
            "        if not subsection_names:",
            "            return section",
            "",
            "        for subsection_name in subsection_names:",
            "            section_maybe = section.get(subsection_name)",
            "",
            "            # there are already subsections",
            "            if section_maybe is not None:",
            "                section = section_maybe.subsections",
            "                continue",
            "",
            "            if create:",
            "                # no subsection, create",
            "                entry = Section(title=subsection_name, content=\"\")",
            "                section[subsection_name] = entry",
            "                section = entry.subsections",
            "            else:",
            "                raise KeyError(f\"Section {subsection_name} does not exist\")",
            "",
            "        return section",
            "",
            "    def select(self, key: str) -> Section:",
            "        \"\"\"Select a section from the model card.",
            "",
            "        To select a subsection of an existing section, use a ``\"/\"`` in the",
            "        section name, e.g.:",
            "",
            "        ``card.select(\"Main section/Subsection\")``.",
            "",
            "        Alternatively, multiple ``select`` calls can be chained:",
            "",
            "        ``card.select(\"Main section\").select(\"Subsection\")``.",
            "",
            "        Parameters",
            "        ----------",
            "        key : str",
            "            The name of the (sub)section to select. When selecting a subsection,",
            "            either use a ``\"/\"`` in the name to separate the parent and child",
            "            sections, chain multiple ``select`` calls.",
            "",
            "        Returns",
            "        -------",
            "        self : Section",
            "            A dataclass containing all information relevant to the selected",
            "            section. Those are the title, the content, and subsections (in a",
            "            dict).",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the given section name was not found, a ``KeyError`` is raised.",
            "",
            "        \"\"\"",
            "        if not key:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        *subsection_names, leaf_node_name = split_subsection_names(key)",
            "",
            "        if not leaf_node_name:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        parent_section = self._select(subsection_names, create=False)",
            "        return parent_section[leaf_node_name]",
            "",
            "    def delete(self, key: str | Sequence[str]) -> None:",
            "        \"\"\"Delete a section from the model card.",
            "",
            "        To delete a subsection of an existing section, use a ``\"/\"`` in the",
            "        section name, e.g.:",
            "",
            "        ``card.delete(\"Existing section/New section\")``.",
            "",
            "        Alternatively, a list of strings can be passed:",
            "",
            "        ``card.delete([\"Existing section\", \"New section\"])``.",
            "",
            "        Parameters",
            "        ----------",
            "        key : str or list of str",
            "            The name of the (sub)section to select. When selecting a subsection,",
            "            either use a ``\"/\"`` in the name to separate the parent and child",
            "            sections, or pass a list of strings.",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the given section name was not found, a ``KeyError`` is raised.",
            "",
            "        \"\"\"",
            "        if not key:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        if isinstance(key, str):",
            "            *subsection_names, leaf_node_name = split_subsection_names(key)",
            "        else:",
            "            *subsection_names, leaf_node_name = key",
            "",
            "        if not leaf_node_name:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        parent_section = self._select(subsection_names, create=False)",
            "        del parent_section[leaf_node_name]",
            "",
            "    def _add_single(",
            "        self, key: str, val: str | Section, folded: bool = False",
            "    ) -> Section:",
            "        \"\"\"Add a single section.",
            "",
            "        If the (sub)section does not exist, it is created. Otherwise, the",
            "        existing (sub)section is modified.",
            "",
            "        Parameters",
            "        ----------",
            "        key: str",
            "            The name of the (sub)section.",
            "",
            "        val: str or Section",
            "            The value to assign to the (sub)section. If this is already a",
            "            section, leave it as it is. If it's a string, create a",
            "            :class:`skops.card._model_card.Section`.",
            "",
            "        folded: bool",
            "            Whether the (sub)section should be folded or not.",
            "",
            "        Returns",
            "        -------",
            "        Section instance",
            "            The section that has been added or modified.",
            "",
            "        \"\"\"",
            "        *subsection_names, leaf_node_name = split_subsection_names(key)",
            "        section = self._select(subsection_names)",
            "",
            "        if isinstance(val, str):",
            "            # val is a str, create a Section",
            "            new_section = Section(title=leaf_node_name, content=val, folded=folded)",
            "        else:",
            "            # val is already a section and can be used as is",
            "            new_section = val",
            "",
            "        if leaf_node_name in section:",
            "            # entry exists, preserve its subsections",
            "            old_section = section[leaf_node_name]",
            "            if new_section.subsections and (",
            "                new_section.subsections != old_section.subsections",
            "            ):",
            "                msg = (",
            "                    f\"Trying to override section '{leaf_node_name}' but found \"",
            "                    \"conflicting subsections.\"",
            "                )",
            "                raise ValueError(msg)",
            "            new_section.subsections = old_section.subsections",
            "",
            "        section[leaf_node_name] = new_section",
            "        return section[leaf_node_name]",
            "",
            "    def add_model_plot(",
            "        self,",
            "        section: str = \"Model description/Training Procedure/Model Plot\",",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"Add a model plot",
            "",
            "        Use sklearn model visualization to add create a diagram of the model.",
            "        See the `sklearn model visualization docs",
            "        <https://scikit-learn.org/stable/modules/compose.html#visualizing-composite-estimators>`_.",
            "",
            "        The model diagram is not added if the card class was instantiated with",
            "        ``model_diagram=False``.",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"Model description/Training Procedure/Model Plot\")",
            "            The section that the model plot should be added to. By default, the",
            "            section is set to fit the skops model card template. If you're using",
            "            a different template, you may have to choose a different section name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the model plot. If you're",
            "            using the default skops template, a standard text is used. Pass a",
            "            string here if you want to use your own text instead. Leave this",
            "            empty to not add any description.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        self._add_model_plot(",
            "            self.get_model(), section_name=section, description=description",
            "        )",
            "",
            "        return self",
            "",
            "    def _add_model_plot(",
            "        self, model: Any, section_name: str, description: str | None",
            "    ) -> None:",
            "        \"\"\"Add model plot section",
            "",
            "        The model should be a loaded sklearn model, not a path.",
            "",
            "        \"\"\"",
            "        model_plot_div = re.sub(r\"\\n\\s+\", \"\", str(estimator_html_repr(model)))",
            "        if model_plot_div.count(\"sk-top-container\") == 1:",
            "            model_plot_div = model_plot_div.replace(",
            "                \"sk-top-container\", 'sk-top-container\" style=\"overflow: auto;'",
            "            )",
            "",
            "        if description:",
            "            content = f\"{description}\\n\\n{model_plot_div}\"",
            "        else:",
            "            content = model_plot_div",
            "",
            "        description = description or \"\"",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = Section(title=title, content=content)",
            "        self._add_single(section_name, section)",
            "",
            "    def add_hyperparams(",
            "        self,",
            "        section: str = \"Model description/Training Procedure/Hyperparameters\",",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"Add the model's hyperparameters as a table",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"Model description/Training Procedure/Hyperparameters\")",
            "            The section that the hyperparameters should be added to. By default,",
            "            the section is set to fit the skops model card template. If you're",
            "            using a different template, you may have to choose a different section",
            "            name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the hyperparamters. If",
            "            you're using the default skops template, a standard text is used.",
            "            Pass a string here if you want to use your own text instead. Leave",
            "            this empty to not add any description.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        self._add_hyperparams(",
            "            self.get_model(), section_name=section, description=description",
            "        )",
            "        return self",
            "",
            "    def _add_hyperparams(",
            "        self, model: Any, section_name: str, description: str | None",
            "    ) -> None:",
            "        \"\"\"Add hyperparameter section.",
            "",
            "        The model should be a loaded sklearn model, not a path.",
            "",
            "        \"\"\"",
            "        params = model.get_params(deep=True)",
            "        table = {\"Hyperparameter\": list(params.keys()), \"Value\": list(params.values())}",
            "",
            "        description = description or \"\"",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = TableSection(",
            "            title=title, content=description, table=table, folded=True",
            "        )",
            "        self._add_single(section_name, section)",
            "",
            "    def add_get_started_code(",
            "        self,",
            "        section: str = \"How to Get Started with the Model\",",
            "        description: str | None = None,",
            "        file_name: str | None = None,",
            "        model_format: Literal[\"pickle\", \"skops\"] | None = None,",
            "    ) -> Self:",
            "        \"\"\"Add getting started code",
            "",
            "        This code can be copied by users to load the model and make predictions",
            "        with it.",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"How to Get Started with the Model\")",
            "            The section that the code for loading the model should be added to.",
            "            By default, the section is set to fit the skops model card template.",
            "            If you're using a different template, you may have to choose a",
            "            different section name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the code. If you're using",
            "            the default skops template, a standard text is used. Pass a string",
            "            here if you want to use your own text instead. Leave this empty to",
            "            not add any description.",
            "",
            "        file_name : str or None, default=None",
            "            The file name of the model. If no file name is indicated, there will",
            "            be an attempt to read the file name from the card's metadata. If",
            "            that fails, an error is raised and you have to pass this argument",
            "            explicitly.",
            "",
            "        model_format : \"skops\", \"pickle\", or None, default=None",
            "            The model format used to store the model.If format is indicated,",
            "            there will be an attempt to read the model format from the card's",
            "            metadata. If that fails, an error is raised and you have to pass",
            "            this argument explicitly.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        if file_name is None:",
            "            file_name = self.metadata.to_dict().get(\"model_file\")",
            "",
            "        if model_format is None:",
            "            model_format = (",
            "                self.metadata.to_dict().get(\"sklearn\", {}).get(\"model_format\")",
            "            )",
            "",
            "        if model_format and (model_format not in (\"pickle\", \"skops\")):",
            "            msg = (",
            "                f\"Invalid model format '{model_format}', should be one of \"",
            "                \"'pickle' or 'skops'\"",
            "            )",
            "            raise ValueError(msg)",
            "",
            "        if (not file_name) or (not model_format):",
            "            return self",
            "",
            "        self._add_get_started_code(",
            "            section,",
            "            file_name=file_name,",
            "            model_format=model_format,",
            "            description=description,",
            "        )",
            "",
            "        return self",
            "",
            "    def _add_get_started_code(",
            "        self,",
            "        section_name: str,",
            "        file_name: str,",
            "        model_format: Literal[\"pickle\", \"skops\"],",
            "        description: str | None,",
            "        indent: str = \"    \",",
            "    ) -> None:",
            "        \"\"\"Add getting started code to the corresponding section\"\"\"",
            "        lines = _getting_started_code(",
            "            file_name, model_format=model_format, indent=indent",
            "        )",
            "        lines = [\"```python\"] + lines + [\"```\"]",
            "        code = \"\\n\".join(lines)",
            "",
            "        if description:",
            "            content = f\"{description}\\n\\n{code}\"",
            "        else:",
            "            content = code",
            "",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = Section(title=title, content=content)",
            "        self._add_single(section_name, section)",
            "",
            "    def add_plot(",
            "        self,",
            "        *,",
            "        description: str | None = None,",
            "        alt_text: str | None = None,",
            "        folded=False,",
            "        **kwargs: str | Path,",
            "    ) -> Self:",
            "        \"\"\"Add plots to the model card.",
            "",
            "        The plot should be saved on the file system and the path passed as",
            "        value.",
            "",
            "        Parameters",
            "        ----------",
            "        description: str or None (default=None)",
            "            If a string is passed as description, it is shown before the figure.",
            "            If multiple figures are added with one call, they all get the same",
            "            description. To add multiple figures with different descriptions,",
            "            call this method multiple times.",
            "",
            "        alt_text: : str or None (default=None)",
            "            If a string is passed as ``alt_text``, it is used as the alternative",
            "            text for the figure (i.e. what is shown if the figure cannot be",
            "            rendered). If this argument is ``None``, the alt_text will just be",
            "            the same as the section title. If multiple figures are added with",
            "            one call, they all get the same alt text. To add multiple figures",
            "            with different alt texts, call this method multiple times.",
            "",
            "        folded: bool (default=False)",
            "            If set to ``True``, the plot will be enclosed in a ``details`` tag.",
            "            That means the content is folded by default and users have to click",
            "            to show the content. This option is useful if the added plot is",
            "            large.",
            "",
            "        **kwargs : dict",
            "            The arguments should be of the form ``name=plot_path``, where",
            "            ``name`` is the name of the plot and section, and ``plot_path`` is",
            "            the path to the plot on the file system (either a str or",
            "            ``pathlib.Path``), relative to the root of the project. The plots",
            "            should have already been saved under the project's folder.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        description = description or \"\"",
            "        for section_name, plot_path in kwargs.items():",
            "            title = split_subsection_names(section_name)[-1]",
            "            alt_text = alt_text or title",
            "            section = PlotSection(",
            "                title=title,",
            "                content=description,",
            "                alt_text=alt_text,",
            "                path=plot_path,",
            "                folded=folded,",
            "            )",
            "            self._add_single(section_name, section)",
            "        return self",
            "",
            "    def add_table(",
            "        self,",
            "        *,",
            "        description: str | None = None,",
            "        folded: bool = False,",
            "        **kwargs: dict[\"str\", list[Any]],",
            "    ) -> Self:",
            "        \"\"\"Add a table to the model card.",
            "",
            "        Add a table to the model card. This can be especially useful when you",
            "        using cross validation with sklearn. E.g. you can directly pass the",
            "        result from calling :func:`sklearn.model_selection.cross_validate` or",
            "        the ``cv_results_`` attribute from any of the hyperparameter searches,",
            "        such as :class:`sklearn.model_selection.GridSearchCV`.",
            "",
            "        Morevoer, you can pass any pandas :class:`pandas.DataFrame` to this",
            "        method and it will be rendered in the model card. You may consider",
            "        selecting only a part of the table if it's too big:",
            "",
            "        .. code:: python",
            "",
            "            search = GridSearchCV(...)",
            "            search.fit(X, y)",
            "            df = pd.DataFrame(search.cv_results_)",
            "            # show only top 10 highest scores",
            "            df = df.sort_values([\"mean_test_score\"], ascending=False).head(10)",
            "            model_card = skops.card.Card(...)",
            "            model_card.add_table(**{\"Hyperparameter search results top 10\": df})",
            "",
            "        Parameters",
            "        ----------",
            "        description: str or None (default=None)",
            "            If a string is passed as description, it is shown before the table.",
            "            If multiple tables are added with one call, they all get the same",
            "            description. To add multiple tables with different descriptions,",
            "            call this method multiple times.",
            "",
            "        folded: bool (default=False)",
            "            If set to ``True``, the table will be enclosed in a ``details`` tag.",
            "            That means the content is folded by default and users have to click",
            "            to show the content. This option is useful if the added table is",
            "            large.",
            "",
            "        **kwargs : dict",
            "            The keys should be strings, which will be used as the section",
            "            headers, and the values should be tables. Tables can be either dicts",
            "            with the key being strings that represent the column name, and the",
            "            values being lists that represent the entries for each row.",
            "            Alternatively, the table can be a :class:`pandas.DataFrame`. The",
            "            table must not be empty.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        description = description or \"\"",
            "        for key, val in kwargs.items():",
            "            section = TableSection(",
            "                title=key, content=description, table=val, folded=folded",
            "            )",
            "            self._add_single(key, section)",
            "        return self",
            "",
            "    def add_metrics(",
            "        self,",
            "        section: str = \"Model description/Evaluation Results\",",
            "        description: str | None = None,",
            "        **kwargs: str | int | float,",
            "    ) -> Self:",
            "        \"\"\"Add metric values to the model card.",
            "",
            "        All metrics will be collected in, and then formatted to, a table.",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"Model description/Evaluation Results\")",
            "            The section that metrics should be added to. By default, the section",
            "            is set to fit the skops model card template. If you're using a",
            "            different template, you may have to choose a different section name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the metrics. If you're",
            "            using the default skops template, a standard text is used. Pass a",
            "            string here if you want to use your own text instead. Leave this",
            "            empty to not add any description.",
            "",
            "        **kwargs : dict",
            "            A dictionary of the form ``{metric name: metric value}``.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        self._metrics.update(kwargs)",
            "        self._add_metrics(section, description=description, metrics=self._metrics)",
            "        return self",
            "",
            "    def add_permutation_importances(",
            "        self,",
            "        permutation_importances,",
            "        columns: Sequence[str],",
            "        plot_file: str | Path = \"permutation_importances.png\",",
            "        plot_name: str = \"Permutation Importances\",",
            "        overwrite: bool = False,",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"Plots permutation importance and saves it to model card.",
            "",
            "        Parameters",
            "        ----------",
            "        permutation_importances : sklearn.utils.Bunch",
            "            Output of :func:`sklearn.inspection.permutation_importance`.",
            "",
            "        columns : str, list or pandas.Index",
            "            Column names of the data used to generate importances.",
            "",
            "        plot_file : str or pathlib.Path",
            "            Filename for the plot.",
            "",
            "        plot_name : str",
            "            Name of the plot.",
            "",
            "        overwrite : bool (default=False)",
            "            Whether to overwrite the permutation importance plot file, if a plot by that",
            "            name already exists.",
            "",
            "        description : str | None (default=None)",
            "            An optional description to be added before the plot.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "        \"\"\"",
            "        plt = import_or_raise(\"matplotlib.pyplot\", \"permutation importance\")",
            "",
            "        if Path(plot_file).exists() and overwrite is False:",
            "            raise ValueError(",
            "                f\"{str(plot_file)} already exists. Set `overwrite` to `True` or pass a\"",
            "                \" different filename for the plot.\"",
            "            )",
            "        sorted_importances_idx = permutation_importances.importances_mean.argsort()",
            "        _, ax = plt.subplots()",
            "        boxplot(",
            "            ax,",
            "            x=permutation_importances.importances[sorted_importances_idx].T,",
            "            tick_labels=columns[sorted_importances_idx],",
            "            vert=False,",
            "        )",
            "        ax.set_title(plot_name)",
            "        ax.set_xlabel(\"Decrease in Score\")",
            "        plt.savefig(plot_file)",
            "        self.add_plot(description=description, alt_text=None, **{plot_name: plot_file})",
            "",
            "        return self",
            "",
            "    def add_fairlearn_metric_frame(",
            "        self,",
            "        metric_frame,",
            "        table_name: str = \"Fairlearn MetricFrame Table\",",
            "        transpose: bool = True,",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"",
            "        Add a :class:`fairlearn.metrics.MetricFrame` table to the model card.",
            "        The table contains the difference, group_ma, group_min, and ratio for",
            "        each metric.",
            "",
            "        Parameters",
            "        ----------",
            "        metric_frame: MetricFrame",
            "            The Fairlearn MetricFrame to add to the model card.",
            "",
            "        table_name: str",
            "            The desired name of the table section in the model card.",
            "",
            "        transpose: bool, default=True",
            "            Whether to transpose the table or not.",
            "",
            "",
            "        description : str | None (default=None)",
            "            An optional description to be added before the table.",
            "",
            "        Returns",
            "        -------",
            "        self: Card",
            "            The model card with the metric frame added.",
            "",
            "        Notes",
            "        --------",
            "        You can check `fairlearn's documentation",
            "        <https://fairlearn.org/v0.8/user_guide/assessment/index.html>`__ on how to",
            "        work with `MetricFrame`s.",
            "",
            "        \"\"\"",
            "        frame_dict = {",
            "            \"difference\": metric_frame.difference(),",
            "            \"group_max\": metric_frame.group_max(),",
            "            \"group_min\": metric_frame.group_min(),",
            "            \"ratio\": metric_frame.ratio(),",
            "        }",
            "",
            "        if transpose is True:",
            "            pd = import_or_raise(\"pandas\", \"Pandas is used to pivot the table.\")",
            "",
            "            frame_dict = pd.DataFrame(frame_dict).T",
            "",
            "        return self.add_table(",
            "            folded=True, description=description, **{table_name: frame_dict}",
            "        )",
            "",
            "    def _add_metrics(",
            "        self,",
            "        section_name: str,",
            "        description: str | None,",
            "        metrics: dict[str, str | float | int],",
            "    ) -> None:",
            "        \"\"\"Add metrics to the Evaluation Results section.\"\"\"",
            "        if self._metrics:",
            "            # transpose from row oriented to column oriented",
            "            data_transposed = zip(*self._metrics.items())",
            "            table = {",
            "                key: list(val) for key, val in zip([\"Metric\", \"Value\"], data_transposed)",
            "            }",
            "        else:",
            "            # create empty table",
            "            table = {\"Metric\": [], \"Value\": []}",
            "",
            "        description = description or \"\"",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = TableSection(title=title, content=description, table=table)",
            "        self._add_single(section_name, section)",
            "",
            "    def _generate_metadata(self, metadata: ModelCardData) -> Iterator[str]:",
            "        \"\"\"Yield metadata in yaml format\"\"\"",
            "        for key, val in metadata.to_dict().items() if metadata else {}:",
            "            yield aRepr.repr(f\"metadata.{key}={val},\").strip('\"').strip(\"'\")",
            "",
            "    def _generate_content(",
            "        self,",
            "        data: dict[str, Section],",
            "        depth: int = 1,",
            "        destination_path: Path | None = None,",
            "    ) -> Iterator[str]:",
            "        \"\"\"Yield title and (formatted) contents.",
            "",
            "        Recursively go through the data and consecutively yield the title with",
            "        the appropriate number of \"#\"s (markdown format), then the associated",
            "        content.",
            "",
            "        \"\"\"",
            "        for section in data.values():",
            "            if not section.visible:",
            "                continue",
            "",
            "            title = f\"{depth * '#'} {section.title}\"",
            "            yield title",
            "",
            "            yield section.format()",
            "",
            "            if destination_path is not None and isinstance(section, PlotSection):",
            "                shutil.copy(section.path, destination_path)",
            "",
            "            if section.subsections and not section.folded:",
            "                yield from self._generate_content(",
            "                    section.subsections,",
            "                    depth=depth + 1,",
            "                    destination_path=destination_path,",
            "                )",
            "",
            "    def _iterate_content(",
            "        self, data: dict[str, Section], parent_section: str = \"\"",
            "    ) -> Iterator[tuple[str, Section]]:",
            "        \"\"\"Yield tuples of title and (non-formatted) content.\"\"\"",
            "        for val in data.values():",
            "            if parent_section:",
            "                title = \"/\".join((parent_section, val.title))",
            "            else:",
            "                title = val.title",
            "",
            "            yield title, val",
            "",
            "            if val.subsections:",
            "                yield from self._iterate_content(val.subsections, parent_section=title)",
            "",
            "    @staticmethod",
            "    def _format_repr(text: str) -> str:",
            "        # Remove new lines, multiple spaces, quotation marks, and cap line length",
            "        text = text.replace(\"\\n\", \" \")",
            "        text = re.sub(r\"\\s+\", r\" \", text)",
            "        return aRepr.repr(text).strip('\"').strip(\"'\")",
            "",
            "    def __str__(self) -> str:",
            "        return self.__repr__()",
            "",
            "    def __repr__(self) -> str:",
            "        # repr for the model",
            "        model = getattr(self, \"model\", None)",
            "        if model:",
            "            model_repr = self._format_repr(f\"model={repr(self.get_model())},\")",
            "        else:",
            "            model_repr = None",
            "",
            "        # repr for metadata",
            "        metadata_reprs = []",
            "        for key, val in self.metadata.to_dict().items() if self.metadata else {}:",
            "            if key == \"widget\":",
            "                metadata_reprs.append(\"metadata.widget=[{...}],\")",
            "                continue",
            "",
            "            metadata_reprs.append(self._format_repr(f\"metadata.{key}={val},\"))",
            "        metadata_repr = \"\\n\".join(metadata_reprs)",
            "",
            "        # repr for contents",
            "        content_reprs = []",
            "        for title, section in self._iterate_content(self._data):",
            "            content = section.format()",
            "            if not content:",
            "                continue",
            "            if content.rstrip(\"`\").rstrip().endswith(CONTENT_PLACEHOLDER):",
            "                # if content is just some default text, no need to show it",
            "                continue",
            "            content_reprs.append(self._format_repr(f\"{title}={section},\"))",
            "        content_repr = \"\\n\".join(content_reprs)",
            "",
            "        # combine all parts",
            "        complete_repr = \"Card(\\n\"",
            "        if model_repr:",
            "            complete_repr += textwrap.indent(model_repr, \"  \") + \"\\n\"",
            "        if metadata_reprs:",
            "            complete_repr += textwrap.indent(metadata_repr, \"  \") + \"\\n\"",
            "        if content_reprs:",
            "            complete_repr += textwrap.indent(content_repr, \"  \") + \"\\n\"",
            "        complete_repr += \")\"",
            "        return complete_repr",
            "",
            "    def _generate_card(self, destination_path: Path | None = None) -> Iterator[str]:",
            "        \"\"\"Yield sections of the model card, including the metadata.\"\"\"",
            "        if self.metadata.to_dict():",
            "            yield f\"---\\n{self.metadata.to_yaml()}\\n---\"",
            "",
            "        for line in self._generate_content(",
            "            self._data, destination_path=destination_path",
            "        ):",
            "            if line:",
            "                yield \"\\n\" + line",
            "",
            "        # add an empty line add the end",
            "        yield \"\"",
            "",
            "    def save(self, path: str | Path, copy_files: bool = False) -> None:",
            "        \"\"\"Save the model card.",
            "",
            "        This method renders the model card in markdown format and then saves it",
            "        as the specified file.",
            "",
            "        Parameters",
            "        ----------",
            "        path: Path",
            "            Filepath to save your card.",
            "",
            "        plot_path: str",
            "            Filepath to save the plots. Use this when saving the model card",
            "            before creating the repository. Without this path the README will",
            "            have an absolute path to the plot that won't exist in the",
            "            repository.",
            "",
            "        Notes",
            "        -----",
            "        The keys in model card metadata can be seen `here",
            "        <https://huggingface.co/docs/hub/models-cards#model-card-metadata>`__.",
            "        \"\"\"",
            "        with open(path, \"w\", encoding=\"utf-8\") as f:",
            "            if not isinstance(path, Path):",
            "                path = Path(path)",
            "            destination_path = path.parent if copy_files else None",
            "            f.write(\"\\n\".join(self._generate_card(destination_path=destination_path)))",
            "",
            "    def render(self) -> str:",
            "        \"\"\"Render the final model card as a string.",
            "",
            "        Returns",
            "        -------",
            "        result : str",
            "            The rendered model card with all placeholders filled and all extra",
            "            sections inserted.",
            "        \"\"\"",
            "        return \"\\n\".join(self._generate_card())",
            "",
            "    def _iterate_key_section_content(",
            "        self,",
            "        data: dict[str, Section],",
            "        level: int = 0,",
            "    ):",
            "        \"\"\"Iterate through the key sections and yield the title and level.",
            "",
            "        Parameters",
            "        ----------",
            "        data : dict[str, Section]",
            "            The card data to iterate through. This is usually the sections and",
            "            subsections.",
            "",
            "        level : int, optional",
            "            The level of the section, by default 0. This keeps track of subsections.",
            "",
            "        Returns",
            "        -------",
            "        table_of_contents : str",
            "        \"\"\"",
            "        for key, val in data.items():",
            "            if not getattr(val, \"visible\", True):",
            "                continue",
            "",
            "            title = val.title",
            "            yield title, level",
            "",
            "            if val.subsections:",
            "                yield from self._iterate_key_section_content(",
            "                    val.subsections,",
            "                    level=level + 1,",
            "                )",
            "",
            "    def get_toc(self) -> str:",
            "        \"\"\"Get the table of contents for the model card.",
            "",
            "        Returns",
            "        -------",
            "        toc : str",
            "            The table of contents for the model card formatted as a markdown string.",
            "            Example:",
            "                - Model description",
            "                    - Intended uses & limitations",
            "                    - Training Procedure",
            "                        - Hyperparameters",
            "                        - Model Plot",
            "                    - Evaluation Results",
            "                - How to Get Started with the Model",
            "                - Model Card Authors",
            "                - Model Card Contact",
            "        \"\"\"",
            "        sections = []",
            "        for title, level in self._iterate_key_section_content(self._data):",
            "            sections.append(f\"{'  ' * level}- {title}\")",
            "",
            "        return \"\\n\".join(sections)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import json",
            "import re",
            "import shutil",
            "import sys",
            "import textwrap",
            "import zipfile",
            "from collections.abc import Mapping",
            "from dataclasses import dataclass, field",
            "from functools import cached_property",
            "from hashlib import sha256",
            "from pathlib import Path",
            "from reprlib import Repr",
            "from typing import Any, Iterator, List, Literal, Optional, Sequence, Union",
            "",
            "import joblib",
            "from huggingface_hub import ModelCardData",
            "from sklearn.utils import estimator_html_repr",
            "from tabulate import tabulate  # type: ignore",
            "",
            "from skops.card._templates import CONTENT_PLACEHOLDER, SKOPS_TEMPLATE, Templates",
            "from skops.io import load",
            "from skops.utils._fixes import boxplot",
            "from skops.utils.importutils import import_or_raise",
            "",
            "if sys.version_info >= (3, 11):",
            "    from typing import Self",
            "else:",
            "    from typing_extensions import Self",
            "",
            "# Repr attributes can be used to control the behavior of repr",
            "aRepr = Repr()",
            "aRepr.maxother = 79",
            "aRepr.maxstring = 79",
            "",
            "VALID_TEMPLATES = {item.value for item in Templates}",
            "NEED_SECTION_ERR_MSG = (",
            "    \"You are trying to {action} but you're using a custom template, please pass the \"",
            "    \"'section' argument to determine where to put the content\"",
            ")",
            "",
            "",
            "def wrap_as_details(text: str, folded: bool) -> str:",
            "    if not folded:",
            "        return text",
            "    return f\"<details>\\n<summary> Click to expand </summary>\\n\\n{text}\\n\\n</details>\"",
            "",
            "",
            "def _clean_table(table: str) -> str:",
            "    # replace line breaks \"\\n\" with html tag <br />, however, leave end-of-line",
            "    # line breaks (eol_lb) intact",
            "    eol_lb = \"|\\n\"",
            "    placeholder = \"\\x1f\"  # unit separator control character (ASCII control char 31)",
            "    table = (",
            "        table.replace(eol_lb, placeholder)",
            "        .replace(\"\\n\", \"<br />\")",
            "        .replace(placeholder, eol_lb)",
            "    )",
            "    return table",
            "",
            "",
            "def metadata_from_config(config_path: Union[str, Path]) -> ModelCardData:",
            "    \"\"\"Construct a ``ModelCardData`` object from a ``config.json`` file.",
            "",
            "    Most information needed for the metadata section of a ``README.md`` file on",
            "    Hugging Face Hub is included in the ``config.json`` file. This utility",
            "    function constructs a :class:`huggingface_hub.ModelCardData` object which",
            "    can then be passed to the :class:`~skops.card.Card` object.",
            "",
            "    This method populates the following attributes of the instance:",
            "",
            "    - ``library_name``: It needs to be ``\"sklearn\"`` for scikit-learn",
            "        compatible models.",
            "    - ``tags``: Set to a list, containing ``\"sklearn\"`` and the task of the",
            "        model. You can then add more tags to this list.",
            "    - ``widget``: It is populated with the example data to be used by the",
            "        widget component of the Hugging Face Hub widget, on the model's",
            "        repository page.",
            "",
            "    Parameters",
            "    ----------",
            "    config_path: str, or Path",
            "        Filepath to the ``config.json`` file, or the folder including that",
            "        file.",
            "",
            "    Returns",
            "    -------",
            "    card_data: huggingface_hub.ModelCardData",
            "        :class:`huggingface_hub.ModelCardData` object.",
            "",
            "    \"\"\"",
            "    config_path = Path(config_path)",
            "    if not config_path.is_file():",
            "        config_path = config_path / \"config.json\"",
            "",
            "    with open(config_path) as f:",
            "        config = json.load(f)",
            "    card_data = ModelCardData(",
            "        model_format=config.get(\"sklearn\", {}).get(\"model_format\", {})",
            "    )",
            "    card_data.library_name = \"sklearn\"",
            "    card_data.tags = [\"sklearn\", \"skops\"]",
            "    task = config.get(\"sklearn\", {}).get(\"task\", None)",
            "    if task:",
            "        card_data.tags += [task]",
            "    card_data.model_file = config.get(\"sklearn\", {}).get(\"model\", {}).get(\"file\")  # type: ignore",
            "",
            "    example_input = config.get(\"sklearn\", {}).get(\"example_input\", None)",
            "    # Documentation on what the widget expects:",
            "    # https://huggingface.co/docs/hub/models-widgets-examples",
            "    if example_input:",
            "        if \"tabular\" in task:",
            "            card_data.widget = [{\"structuredData\": example_input}]  # type: ignore",
            "        # TODO: add text data example here.",
            "",
            "    return card_data",
            "",
            "",
            "def split_subsection_names(key: str) -> list[str]:",
            "    r\"\"\"Split a string containing multiple sections into a list of strings for",
            "    each.",
            "",
            "    The separator is ``\"/\"``. To avoid splitting on ``\"/\"``, escape it using",
            "    ``\"\\\\/\"``.",
            "",
            "    Examples",
            "    --------",
            "    >>> split_subsection_names(\"Section A\")",
            "    ['Section A']",
            "    >>> split_subsection_names(\"Section A/Section B/Section C\")",
            "    ['Section A', 'Section B', 'Section C']",
            "    >>> split_subsection_names(\"A section containing \\\\/ a slash\")",
            "    ['A section containing / a slash']",
            "    >>> split_subsection_names(\"Spaces are / stripped\")",
            "    ['Spaces are', 'stripped']",
            "",
            "    Parameters",
            "    ----------",
            "    key : str",
            "        The section name consisting potentially of multiple subsections. It has",
            "        to be ensured beforhand that this is not an empty string.",
            "",
            "    Returns",
            "    -------",
            "    parts : list of str",
            "        The individual (sub)sections.",
            "",
            "    \"\"\"",
            "    placeholder = \"\\x1f\"  # unit separator control character (ASCII control char 31)",
            "    key = key.replace(\"\\\\/\", placeholder)",
            "    parts = (part.strip() for part in key.split(\"/\"))",
            "    return [part.replace(placeholder, \"/\") for part in parts]",
            "",
            "",
            "def _getting_started_code(",
            "    file_name: str, model_format: Literal[\"pickle\", \"skops\"], indent: str = \"    \"",
            ") -> list[str]:",
            "    # get lines of code required to load the model",
            "    lines = [",
            "        \"import json\",",
            "        \"import pandas as pd\",",
            "    ]",
            "    if model_format == \"skops\":",
            "        lines += [\"import skops.io as sio\"]",
            "    else:",
            "        lines += [\"import joblib\"]",
            "",
            "    if model_format == \"skops\":",
            "        lines += [f'model = sio.load(\"{file_name}\")']",
            "    else:  # pickle",
            "        lines += [f'model = joblib.load(\"{file_name}\")']",
            "",
            "    lines += [",
            "        'with open(\"config.json\") as f:',",
            "        indent + \"config = json.load(f)\",",
            "        'model.predict(pd.DataFrame.from_dict(config[\"sklearn\"][\"example_input\"]))',",
            "    ]",
            "    return lines",
            "",
            "",
            "@dataclass",
            "class Section:",
            "    \"\"\"Building block of the model card.",
            "",
            "    The model card is represented internally as a dict with keys being strings",
            "    and values being ``Section``s. The key is identical to the section title.",
            "",
            "    Additionally, the section may hold content in the form of strings (can be an",
            "    empty string) or a ``Formattable``, which is simply an object with a",
            "    ``format`` method that returns a string.",
            "",
            "    The section can contain subsections, which again are dicts of",
            "    string keys and section values (the dict can be empty). Therefore, the model",
            "    card representation forms a tree structure, making use of the fact that dict",
            "    order is preserved.",
            "",
            "    The section may also contain a ``visible`` flag, which determines if the",
            "    section will be shown when the card is rendered.",
            "",
            "    \"\"\"",
            "",
            "    title: str",
            "    content: str",
            "    subsections: dict[str, Section] = field(default_factory=dict)",
            "    visible: bool = True",
            "    folded: bool = False",
            "",
            "    def select(self, key: str) -> Section:",
            "        \"\"\"Return a subsection or subsubsection of this section",
            "",
            "        Parameters",
            "        ----------",
            "        key : str",
            "            The name of the (sub)section to select. When selecting a subsection,",
            "            either use a ``\"/\"`` in the name to separate the parent and child",
            "            sections, chain multiple ``select`` calls.",
            "",
            "        Returns",
            "        -------",
            "        section : Section",
            "            A dataclass containing all information relevant to the selected",
            "            section. Those are the title, the content, subsections (in a dict),",
            "            and additional fields that depend on the type of section.",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the given section name was not found, a ``KeyError`` is raised.",
            "",
            "        \"\"\"",
            "        section_names = split_subsection_names(key)",
            "        # check that no section name is empty",
            "        if not all(bool(name) for name in section_names):",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        section: Section = self",
            "        for section_name in section_names:",
            "            section = section.subsections[section_name]",
            "        return section",
            "",
            "    def format(self) -> str:",
            "        return wrap_as_details(self.content, folded=self.folded)",
            "",
            "    def __repr__(self) -> str:",
            "        \"\"\"Generates the ``repr`` of this section.",
            "",
            "        ``repr`` determines how the content of this section is shown in the",
            "        Card's repr.",
            "        \"\"\"",
            "        return self.content",
            "",
            "",
            "@dataclass",
            "class PlotSection(Section):",
            "    \"\"\"Adds a link to a figure to the model card\"\"\"",
            "",
            "    path: str | Path = \"\"",
            "    alt_text: str = \"\"",
            "    folded: bool = False",
            "",
            "    def __post_init__(self) -> None:",
            "        if not self.path:",
            "            raise TypeError(f\"{self.__class__.__name__} requires a path\")",
            "",
            "    def format(self) -> str:",
            "        # if no alt text provided, fall back to figure path",
            "        alt_text = self.alt_text or self.path",
            "        text = f\"![{alt_text}]({self.path})\"",
            "        val = wrap_as_details(text, folded=self.folded)",
            "        if self.content:",
            "            val = f\"{self.content}\\n\\n{val}\"",
            "        return val",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"{self.__class__.__name__}({self.path})\"",
            "",
            "",
            "@dataclass",
            "class TableSection(Section):",
            "    \"\"\"Adds a table to the model card\"\"\"",
            "",
            "    table: Mapping[str, Sequence[Any]] = field(default_factory=dict)",
            "    folded: bool = False",
            "",
            "    def __post_init__(self) -> None:",
            "        self._check_table()",
            "",
            "    def _check_table(self) -> None:",
            "        try:",
            "            import pandas as pd",
            "",
            "            self._is_pandas_df = isinstance(self.table, pd.DataFrame)",
            "        except ImportError:",
            "            self._is_pandas_df = False",
            "",
            "        if self._is_pandas_df:",
            "            ncols = len(self.table.columns)  # type: ignore",
            "        else:",
            "            ncols = len(self.table)",
            "        if ncols == 0:",
            "            raise ValueError(\"Trying to add table with no columns\")",
            "",
            "    def format(self) -> str:",
            "        if self._is_pandas_df:",
            "            headers = self.table.columns  # type: ignore",
            "        else:",
            "            headers = self.table.keys()",
            "",
            "        table = _clean_table(",
            "            tabulate(self.table, tablefmt=\"github\", headers=headers, showindex=False)",
            "        )",
            "        val = wrap_as_details(table, folded=self.folded)",
            "",
            "        if self.content:",
            "            val = f\"{self.content}\\n\\n{val}\"",
            "        return val",
            "",
            "    def __repr__(self) -> str:",
            "        if self._is_pandas_df:",
            "            nrows, ncols = self.table.shape  # type: ignore",
            "        else:",
            "            # table cannot be empty, so no checks needed here",
            "            ncols = len(self.table)",
            "            key = next(iter(self.table.keys()))",
            "            nrows = len(self.table[key])",
            "        return f\"{self.__class__.__name__}({nrows}x{ncols})\"",
            "",
            "",
            "def _load_model(model: Any, trusted=False) -> Any:",
            "    \"\"\"Return a model instance.",
            "",
            "    Loads the model if provided a file path, if already a model instance return",
            "    it unmodified.",
            "",
            "    Parameters",
            "    ----------",
            "    model : pathlib.Path, str, or sklearn estimator",
            "        Path/str or the actual model instance. if a Path or str, loads the model.",
            "",
            "    trusted : bool, default=False",
            "        Passed to :func:`skops.io.load` if the model is a file path and it's",
            "        a `skops` file.",
            "",
            "    Returns",
            "    -------",
            "    model : object",
            "        Model instance.",
            "    \"\"\"",
            "",
            "    if not isinstance(model, (Path, str)):",
            "        return model",
            "",
            "    model_path = Path(model)",
            "    if not model_path.exists():",
            "        raise FileNotFoundError(f\"File is not present: {model_path}\")",
            "",
            "    try:",
            "        if zipfile.is_zipfile(model_path):",
            "            model = load(model_path, trusted=trusted)",
            "        else:",
            "            model = joblib.load(model_path)",
            "    except Exception as ex:",
            "        msg = f'An \"{type(ex).__name__}\" occurred during model loading.'",
            "        raise RuntimeError(msg) from ex",
            "",
            "    return model",
            "",
            "",
            "class Card:",
            "    \"\"\"Model card class that will be used to generate model card.",
            "",
            "    This class can be used to write information and plots to model card and save",
            "    it. This class by default generates an interactive plot of the model and a",
            "    table of hyperparameters. Some sections are added by default.",
            "",
            "    Parameters",
            "    ----------",
            "    model: pathlib.Path, str, or sklearn estimator object",
            "        ``Path``/``str`` of the model or the actual model instance that will be",
            "        documented. If a ``Path`` or ``str`` is provided, model will be loaded.",
            "",
            "    model_diagram: bool or \"auto\" or str, default=\"auto\"",
            "        If using the skops template, setting this to ``True`` or ``\"auto\"`` will",
            "        add the model diagram, as generated by sckit-learn, to the default",
            "        section, i.e \"Model description/Training Procedure/Model Plot\". Passing",
            "        a string to ``model_diagram`` will instead use that string as the",
            "        section name for the diagram. Set to ``False`` to not include the model",
            "        diagram.",
            "",
            "        If using a non-skops template, passing ``\"auto\"`` won't add the model",
            "        diagram because there is no pre-defined section to put it. The model",
            "        diagram can, however, always be added later using",
            "        :meth:`Card.add_model_plot`.",
            "",
            "    metadata: ModelCardData, optional",
            "        :class:`huggingface_hub.ModelCardData` object. The contents of this",
            "        object are saved as metadata at the beginning of the output file, and",
            "        used by Hugging Face Hub.",
            "",
            "        You can use :func:`~skops.card.metadata_from_config` to create an",
            "        instance pre-populated with necessary information based on the contents",
            "        of the ``config.json`` file, which itself is created by",
            "        :func:`skops.hub_utils.init`.",
            "",
            "    template: \"skops\", dict, or None (default=\"skops\")",
            "        Whether to add default sections or not. The template can be a predefined",
            "        template, which at the moment can only be the string ``\"skops\"``, which",
            "        is a template provided by ``skops`` that is geared towards typical",
            "        sklearn models. If you don't want any prefilled sections, just pass",
            "        ``None``. If you want custom prefilled sections, pass a ``dict``, where",
            "        keys are the sections and values are the contents of the sections. Note",
            "        that when you use no template or a custom template, some methods will",
            "        not work, e.g. :meth:`Card.add_metrics`, since it's not clear where to",
            "        put the metrics when there is no template or a custom template.",
            "",
            "    trusted: bool, default=False",
            "        Passed to :func:`skops.io.load` if the model is a file path and it's",
            "        a `skops` file.",
            "",
            "    Attributes",
            "    ----------",
            "    model: estimator object",
            "        The scikit-learn compatible model that will be documented.",
            "",
            "    metadata: ModelCardData",
            "        Metadata to be stored at the beginning of the saved model card, as",
            "        metadata to be understood by the Hugging Face Hub.",
            "",
            "    Examples",
            "    --------",
            "    >>> from sklearn.metrics import (",
            "    ...     ConfusionMatrixDisplay,",
            "    ...     confusion_matrix,",
            "    ...     accuracy_score,",
            "    ...     f1_score",
            "    ... )",
            "    >>> import tempfile",
            "    >>> from pathlib import Path",
            "    >>> from sklearn.datasets import load_iris",
            "    >>> from sklearn.linear_model import LogisticRegression",
            "    >>> from skops.card import Card",
            "    >>> X, y = load_iris(return_X_y=True)",
            "    >>> model = LogisticRegression(solver=\"liblinear\", random_state=0).fit(X, y)",
            "    >>> model_card = Card(model)",
            "    >>> model_card.metadata.license = \"mit\"",
            "    >>> y_pred = model.predict(X)",
            "    >>> model_card.add_metrics(**{",
            "    ...     \"accuracy\": accuracy_score(y, y_pred),",
            "    ...     \"f1 score\": f1_score(y, y_pred, average=\"micro\"),",
            "    ... })",
            "    Card(...)",
            "    >>> cm = confusion_matrix(y, y_pred,labels=model.classes_)",
            "    >>> disp = ConfusionMatrixDisplay(",
            "    ...     confusion_matrix=cm,",
            "    ...     display_labels=model.classes_",
            "    ... )",
            "    >>> disp.plot()",
            "    <sklearn.metrics._plot.confusion_matrix.ConfusionMatrixDisplay object at ...>",
            "    >>> tmp_path = Path(tempfile.mkdtemp(prefix=\"skops-\"))",
            "    >>> disp.figure_.savefig(tmp_path / \"confusion_matrix.png\")",
            "    ...",
            "    >>> model_card.add_plot(**{",
            "    ...     \"Model description/Confusion Matrix\": tmp_path / \"confusion_matrix.png\"",
            "    ... })",
            "    Card(...)",
            "    >>> # add new content to the existing section \"Model description\"",
            "    >>> model_card.add(**{\"Model description\": \"This is the best model\"})",
            "    Card(...)",
            "    >>> # add content to a new section",
            "    >>> model_card.add(**{\"A new section\": \"Please rate my model\"})",
            "    Card(...)",
            "    >>> # add new subsection to an existing section by using \"/\"",
            "    >>> model_card.add(**{\"Model description/Model name\": \"This model is called Bob\"})",
            "    Card(",
            "      model=LogisticRegression(random_state=0, solver='liblinear'),",
            "      ...",
            "    )",
            "    >>> # save the card to a README.md file",
            "    >>> model_card.save(tmp_path / \"README.md\")",
            "",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        model,",
            "        model_diagram: bool | Literal[\"auto\"] | str = \"auto\",",
            "        metadata: ModelCardData | None = None,",
            "        template: Literal[\"skops\"] | dict[str, str] | None = \"skops\",",
            "        trusted: Optional[List[str]] = None,",
            "    ) -> None:",
            "        self.model = model",
            "        self.metadata = metadata or ModelCardData()",
            "        self.template = template",
            "        self.trusted = trusted",
            "",
            "        self._data: dict[str, Section] = {}",
            "        self._metrics: dict[str, str | float | int] = {}",
            "        self._model_hash = \"\"",
            "",
            "        self._populate_template(model_diagram=model_diagram)",
            "",
            "    def _populate_template(self, model_diagram: bool | Literal[\"auto\"] | str):",
            "        \"\"\"If initialized with a template, use it to populate the card.",
            "",
            "        Parameters",
            "        ----------",
            "        model_diagram: bool or \"auto\" or str",
            "            If using the default template, ``\"auto\"`` and ``True`` will add the",
            "            diagram in its default section. If using a custom template,",
            "            ``\"auto\"`` will not add the diagram, and passing ``True`` will",
            "            result in an error. For either, passing ``False`` will result in the",
            "            model diagram being omitted, and passing a string (other than",
            "            ``\"auto\"``) will put the model diagram into a section corresponding",
            "            to that string.",
            "",
            "        \"\"\"",
            "        if isinstance(self.template, str) and (self.template not in VALID_TEMPLATES):",
            "            valid_templates = \", \".join(f\"'{val}'\" for val in sorted(VALID_TEMPLATES))",
            "            msg = (",
            "                f\"Unknown template '{self.template}', \"",
            "                f\"template must be one of the following values: {valid_templates}\"",
            "            )",
            "            raise ValueError(msg)",
            "",
            "        # default template",
            "        if self.template == Templates.skops.value:",
            "            self.add(folded=False, **SKOPS_TEMPLATE)",
            "            # for the skops template, automatically add some default sections",
            "            self.add_hyperparams()",
            "            self.add_get_started_code()",
            "",
            "            if (model_diagram is True) or (model_diagram == \"auto\"):",
            "                self.add_model_plot()",
            "            elif isinstance(model_diagram, str):",
            "                self.add_model_plot(section=model_diagram)",
            "            return",
            "",
            "        # non-default template",
            "        if isinstance(self.template, Mapping):",
            "            self.add(folded=False, **self.template)",
            "",
            "        if isinstance(model_diagram, str) and (model_diagram != \"auto\"):",
            "            self.add_model_plot(section=model_diagram)",
            "        elif model_diagram is True:",
            "            # will trigger an error",
            "            self.add_model_plot()",
            "",
            "    def get_model(self) -> Any:",
            "        \"\"\"Returns sklearn estimator object.",
            "",
            "        If the ``model`` is already loaded, return it as is. If the ``model``",
            "        attribute is a ``Path``/``str``, load the model and return it.",
            "",
            "        Returns",
            "        -------",
            "        model : BaseEstimator",
            "            The model instance.",
            "",
            "        \"\"\"",
            "        if isinstance(self.model, (str, Path)) and hasattr(self, \"_model\"):",
            "            hash_obj = sha256()",
            "            buf_size = 2**20  # load in chunks to save memory",
            "            with open(self.model, \"rb\") as f:",
            "                for chunk in iter(lambda: f.read(buf_size), b\"\"):",
            "                    hash_obj.update(chunk)",
            "            model_hash = hash_obj.hexdigest()",
            "",
            "            # if hash changed, invalidate cache by deleting attribute",
            "            if model_hash != self._model_hash:",
            "                del self._model",
            "                self._model_hash = model_hash",
            "",
            "        return self._model",
            "",
            "    @cached_property",
            "    def _model(self):",
            "        model = _load_model(self.model, self.trusted)",
            "        return model",
            "",
            "    def add(self, folded: bool = False, **kwargs: str) -> Self:",
            "        \"\"\"Add new section(s) to the model card.",
            "",
            "        Add one or multiple sections to the model card. The section names are",
            "        taken from the keys and the contents are taken from the values.",
            "",
            "        To add to an existing section, use a ``\"/\"`` in the section name, e.g.:",
            "",
            "        ``card.add(**{\"Existing section/New section\": \"content\"})``.",
            "",
            "        If the parent section does not exist, it will be added automatically.",
            "",
            "        To add a section with ``\"/\"`` in its title (i.e. not inteded as a",
            "        subsection), escape the slash like so, ``\"\\\\/\"``, e.g.:",
            "",
            "        ``card.add(**{\"A section with\\\\/a slash in the title\": \"content\"})``.",
            "",
            "        If a section of the given name already exists, its content will be",
            "        overwritten.",
            "",
            "        Parameters",
            "        ----------",
            "        folded : bool",
            "            Whether to fold the sections by default or not.",
            "",
            "        **kwargs : dict",
            "            The keys of the dictionary serve as the section title and the values",
            "            as the section content. It's possible to add to existing sections.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        for key, val in kwargs.items():",
            "            self._add_single(key, val, folded=folded)",
            "        return self",
            "",
            "    def _select(",
            "        self, subsection_names: Sequence[str], create: bool = True",
            "    ) -> dict[str, Section]:",
            "        \"\"\"Select a single section from the data.",
            "",
            "        Parameters",
            "        ----------",
            "        subsection_names: list of str",
            "            The subsection names, already split into individual subsections.",
            "",
            "        create: bool (default=True)",
            "            Whether to create the subsection if it does not already exist or",
            "            not.",
            "",
            "        Returns",
            "        -------",
            "        section: dict of Section",
            "            A dict mapping the section key (identical to the title) to the",
            "            actual ``Section``, which is a dataclass that contains the actual",
            "            data of the section.",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the section does not exist and ``create=False``, raises a",
            "            ``KeyError``.",
            "",
            "        \"\"\"",
            "        section = self._data",
            "        if not subsection_names:",
            "            return section",
            "",
            "        for subsection_name in subsection_names:",
            "            section_maybe = section.get(subsection_name)",
            "",
            "            # there are already subsections",
            "            if section_maybe is not None:",
            "                section = section_maybe.subsections",
            "                continue",
            "",
            "            if create:",
            "                # no subsection, create",
            "                entry = Section(title=subsection_name, content=\"\")",
            "                section[subsection_name] = entry",
            "                section = entry.subsections",
            "            else:",
            "                raise KeyError(f\"Section {subsection_name} does not exist\")",
            "",
            "        return section",
            "",
            "    def select(self, key: str) -> Section:",
            "        \"\"\"Select a section from the model card.",
            "",
            "        To select a subsection of an existing section, use a ``\"/\"`` in the",
            "        section name, e.g.:",
            "",
            "        ``card.select(\"Main section/Subsection\")``.",
            "",
            "        Alternatively, multiple ``select`` calls can be chained:",
            "",
            "        ``card.select(\"Main section\").select(\"Subsection\")``.",
            "",
            "        Parameters",
            "        ----------",
            "        key : str",
            "            The name of the (sub)section to select. When selecting a subsection,",
            "            either use a ``\"/\"`` in the name to separate the parent and child",
            "            sections, chain multiple ``select`` calls.",
            "",
            "        Returns",
            "        -------",
            "        self : Section",
            "            A dataclass containing all information relevant to the selected",
            "            section. Those are the title, the content, and subsections (in a",
            "            dict).",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the given section name was not found, a ``KeyError`` is raised.",
            "",
            "        \"\"\"",
            "        if not key:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        *subsection_names, leaf_node_name = split_subsection_names(key)",
            "",
            "        if not leaf_node_name:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        parent_section = self._select(subsection_names, create=False)",
            "        return parent_section[leaf_node_name]",
            "",
            "    def delete(self, key: str | Sequence[str]) -> None:",
            "        \"\"\"Delete a section from the model card.",
            "",
            "        To delete a subsection of an existing section, use a ``\"/\"`` in the",
            "        section name, e.g.:",
            "",
            "        ``card.delete(\"Existing section/New section\")``.",
            "",
            "        Alternatively, a list of strings can be passed:",
            "",
            "        ``card.delete([\"Existing section\", \"New section\"])``.",
            "",
            "        Parameters",
            "        ----------",
            "        key : str or list of str",
            "            The name of the (sub)section to select. When selecting a subsection,",
            "            either use a ``\"/\"`` in the name to separate the parent and child",
            "            sections, or pass a list of strings.",
            "",
            "        Raises",
            "        ------",
            "        KeyError",
            "            If the given section name was not found, a ``KeyError`` is raised.",
            "",
            "        \"\"\"",
            "        if not key:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        if isinstance(key, str):",
            "            *subsection_names, leaf_node_name = split_subsection_names(key)",
            "        else:",
            "            *subsection_names, leaf_node_name = key",
            "",
            "        if not leaf_node_name:",
            "            msg = f\"Section name cannot be empty but got '{key}'\"",
            "            raise KeyError(msg)",
            "",
            "        parent_section = self._select(subsection_names, create=False)",
            "        del parent_section[leaf_node_name]",
            "",
            "    def _add_single(",
            "        self, key: str, val: str | Section, folded: bool = False",
            "    ) -> Section:",
            "        \"\"\"Add a single section.",
            "",
            "        If the (sub)section does not exist, it is created. Otherwise, the",
            "        existing (sub)section is modified.",
            "",
            "        Parameters",
            "        ----------",
            "        key: str",
            "            The name of the (sub)section.",
            "",
            "        val: str or Section",
            "            The value to assign to the (sub)section. If this is already a",
            "            section, leave it as it is. If it's a string, create a",
            "            :class:`skops.card._model_card.Section`.",
            "",
            "        folded: bool",
            "            Whether the (sub)section should be folded or not.",
            "",
            "        Returns",
            "        -------",
            "        Section instance",
            "            The section that has been added or modified.",
            "",
            "        \"\"\"",
            "        *subsection_names, leaf_node_name = split_subsection_names(key)",
            "        section = self._select(subsection_names)",
            "",
            "        if isinstance(val, str):",
            "            # val is a str, create a Section",
            "            new_section = Section(title=leaf_node_name, content=val, folded=folded)",
            "        else:",
            "            # val is already a section and can be used as is",
            "            new_section = val",
            "",
            "        if leaf_node_name in section:",
            "            # entry exists, preserve its subsections",
            "            old_section = section[leaf_node_name]",
            "            if new_section.subsections and (",
            "                new_section.subsections != old_section.subsections",
            "            ):",
            "                msg = (",
            "                    f\"Trying to override section '{leaf_node_name}' but found \"",
            "                    \"conflicting subsections.\"",
            "                )",
            "                raise ValueError(msg)",
            "            new_section.subsections = old_section.subsections",
            "",
            "        section[leaf_node_name] = new_section",
            "        return section[leaf_node_name]",
            "",
            "    def add_model_plot(",
            "        self,",
            "        section: str = \"Model description/Training Procedure/Model Plot\",",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"Add a model plot",
            "",
            "        Use sklearn model visualization to add create a diagram of the model.",
            "        See the `sklearn model visualization docs",
            "        <https://scikit-learn.org/stable/modules/compose.html#visualizing-composite-estimators>`_.",
            "",
            "        The model diagram is not added if the card class was instantiated with",
            "        ``model_diagram=False``.",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"Model description/Training Procedure/Model Plot\")",
            "            The section that the model plot should be added to. By default, the",
            "            section is set to fit the skops model card template. If you're using",
            "            a different template, you may have to choose a different section name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the model plot. If you're",
            "            using the default skops template, a standard text is used. Pass a",
            "            string here if you want to use your own text instead. Leave this",
            "            empty to not add any description.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        self._add_model_plot(",
            "            self.get_model(), section_name=section, description=description",
            "        )",
            "",
            "        return self",
            "",
            "    def _add_model_plot(",
            "        self, model: Any, section_name: str, description: str | None",
            "    ) -> None:",
            "        \"\"\"Add model plot section",
            "",
            "        The model should be a loaded sklearn model, not a path.",
            "",
            "        \"\"\"",
            "        model_plot_div = re.sub(r\"\\n\\s+\", \"\", str(estimator_html_repr(model)))",
            "        if model_plot_div.count(\"sk-top-container\") == 1:",
            "            model_plot_div = model_plot_div.replace(",
            "                \"sk-top-container\", 'sk-top-container\" style=\"overflow: auto;'",
            "            )",
            "",
            "        if description:",
            "            content = f\"{description}\\n\\n{model_plot_div}\"",
            "        else:",
            "            content = model_plot_div",
            "",
            "        description = description or \"\"",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = Section(title=title, content=content)",
            "        self._add_single(section_name, section)",
            "",
            "    def add_hyperparams(",
            "        self,",
            "        section: str = \"Model description/Training Procedure/Hyperparameters\",",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"Add the model's hyperparameters as a table",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"Model description/Training Procedure/Hyperparameters\")",
            "            The section that the hyperparameters should be added to. By default,",
            "            the section is set to fit the skops model card template. If you're",
            "            using a different template, you may have to choose a different section",
            "            name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the hyperparamters. If",
            "            you're using the default skops template, a standard text is used.",
            "            Pass a string here if you want to use your own text instead. Leave",
            "            this empty to not add any description.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        self._add_hyperparams(",
            "            self.get_model(), section_name=section, description=description",
            "        )",
            "        return self",
            "",
            "    def _add_hyperparams(",
            "        self, model: Any, section_name: str, description: str | None",
            "    ) -> None:",
            "        \"\"\"Add hyperparameter section.",
            "",
            "        The model should be a loaded sklearn model, not a path.",
            "",
            "        \"\"\"",
            "        params = model.get_params(deep=True)",
            "        table = {\"Hyperparameter\": list(params.keys()), \"Value\": list(params.values())}",
            "",
            "        description = description or \"\"",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = TableSection(",
            "            title=title, content=description, table=table, folded=True",
            "        )",
            "        self._add_single(section_name, section)",
            "",
            "    def add_get_started_code(",
            "        self,",
            "        section: str = \"How to Get Started with the Model\",",
            "        description: str | None = None,",
            "        file_name: str | None = None,",
            "        model_format: Literal[\"pickle\", \"skops\"] | None = None,",
            "    ) -> Self:",
            "        \"\"\"Add getting started code",
            "",
            "        This code can be copied by users to load the model and make predictions",
            "        with it.",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"How to Get Started with the Model\")",
            "            The section that the code for loading the model should be added to.",
            "            By default, the section is set to fit the skops model card template.",
            "            If you're using a different template, you may have to choose a",
            "            different section name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the code. If you're using",
            "            the default skops template, a standard text is used. Pass a string",
            "            here if you want to use your own text instead. Leave this empty to",
            "            not add any description.",
            "",
            "        file_name : str or None, default=None",
            "            The file name of the model. If no file name is indicated, there will",
            "            be an attempt to read the file name from the card's metadata. If",
            "            that fails, an error is raised and you have to pass this argument",
            "            explicitly.",
            "",
            "        model_format : \"skops\", \"pickle\", or None, default=None",
            "            The model format used to store the model.If format is indicated,",
            "            there will be an attempt to read the model format from the card's",
            "            metadata. If that fails, an error is raised and you have to pass",
            "            this argument explicitly.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        if file_name is None:",
            "            file_name = self.metadata.to_dict().get(\"model_file\")",
            "",
            "        if model_format is None:",
            "            model_format = (",
            "                self.metadata.to_dict().get(\"sklearn\", {}).get(\"model_format\")",
            "            )",
            "",
            "        if model_format and (model_format not in (\"pickle\", \"skops\")):",
            "            msg = (",
            "                f\"Invalid model format '{model_format}', should be one of \"",
            "                \"'pickle' or 'skops'\"",
            "            )",
            "            raise ValueError(msg)",
            "",
            "        if (not file_name) or (not model_format):",
            "            return self",
            "",
            "        self._add_get_started_code(",
            "            section,",
            "            file_name=file_name,",
            "            model_format=model_format,",
            "            description=description,",
            "        )",
            "",
            "        return self",
            "",
            "    def _add_get_started_code(",
            "        self,",
            "        section_name: str,",
            "        file_name: str,",
            "        model_format: Literal[\"pickle\", \"skops\"],",
            "        description: str | None,",
            "        indent: str = \"    \",",
            "    ) -> None:",
            "        \"\"\"Add getting started code to the corresponding section\"\"\"",
            "        lines = _getting_started_code(",
            "            file_name, model_format=model_format, indent=indent",
            "        )",
            "        lines = [\"```python\"] + lines + [\"```\"]",
            "        code = \"\\n\".join(lines)",
            "",
            "        if description:",
            "            content = f\"{description}\\n\\n{code}\"",
            "        else:",
            "            content = code",
            "",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = Section(title=title, content=content)",
            "        self._add_single(section_name, section)",
            "",
            "    def add_plot(",
            "        self,",
            "        *,",
            "        description: str | None = None,",
            "        alt_text: str | None = None,",
            "        folded=False,",
            "        **kwargs: str | Path,",
            "    ) -> Self:",
            "        \"\"\"Add plots to the model card.",
            "",
            "        The plot should be saved on the file system and the path passed as",
            "        value.",
            "",
            "        Parameters",
            "        ----------",
            "        description: str or None (default=None)",
            "            If a string is passed as description, it is shown before the figure.",
            "            If multiple figures are added with one call, they all get the same",
            "            description. To add multiple figures with different descriptions,",
            "            call this method multiple times.",
            "",
            "        alt_text: : str or None (default=None)",
            "            If a string is passed as ``alt_text``, it is used as the alternative",
            "            text for the figure (i.e. what is shown if the figure cannot be",
            "            rendered). If this argument is ``None``, the alt_text will just be",
            "            the same as the section title. If multiple figures are added with",
            "            one call, they all get the same alt text. To add multiple figures",
            "            with different alt texts, call this method multiple times.",
            "",
            "        folded: bool (default=False)",
            "            If set to ``True``, the plot will be enclosed in a ``details`` tag.",
            "            That means the content is folded by default and users have to click",
            "            to show the content. This option is useful if the added plot is",
            "            large.",
            "",
            "        **kwargs : dict",
            "            The arguments should be of the form ``name=plot_path``, where",
            "            ``name`` is the name of the plot and section, and ``plot_path`` is",
            "            the path to the plot on the file system (either a str or",
            "            ``pathlib.Path``), relative to the root of the project. The plots",
            "            should have already been saved under the project's folder.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        description = description or \"\"",
            "        for section_name, plot_path in kwargs.items():",
            "            title = split_subsection_names(section_name)[-1]",
            "            alt_text = alt_text or title",
            "            section = PlotSection(",
            "                title=title,",
            "                content=description,",
            "                alt_text=alt_text,",
            "                path=plot_path,",
            "                folded=folded,",
            "            )",
            "            self._add_single(section_name, section)",
            "        return self",
            "",
            "    def add_table(",
            "        self,",
            "        *,",
            "        description: str | None = None,",
            "        folded: bool = False,",
            "        **kwargs: dict[\"str\", list[Any]],",
            "    ) -> Self:",
            "        \"\"\"Add a table to the model card.",
            "",
            "        Add a table to the model card. This can be especially useful when you",
            "        using cross validation with sklearn. E.g. you can directly pass the",
            "        result from calling :func:`sklearn.model_selection.cross_validate` or",
            "        the ``cv_results_`` attribute from any of the hyperparameter searches,",
            "        such as :class:`sklearn.model_selection.GridSearchCV`.",
            "",
            "        Morevoer, you can pass any pandas :class:`pandas.DataFrame` to this",
            "        method and it will be rendered in the model card. You may consider",
            "        selecting only a part of the table if it's too big:",
            "",
            "        .. code:: python",
            "",
            "            search = GridSearchCV(...)",
            "            search.fit(X, y)",
            "            df = pd.DataFrame(search.cv_results_)",
            "            # show only top 10 highest scores",
            "            df = df.sort_values([\"mean_test_score\"], ascending=False).head(10)",
            "            model_card = skops.card.Card(...)",
            "            model_card.add_table(**{\"Hyperparameter search results top 10\": df})",
            "",
            "        Parameters",
            "        ----------",
            "        description: str or None (default=None)",
            "            If a string is passed as description, it is shown before the table.",
            "            If multiple tables are added with one call, they all get the same",
            "            description. To add multiple tables with different descriptions,",
            "            call this method multiple times.",
            "",
            "        folded: bool (default=False)",
            "            If set to ``True``, the table will be enclosed in a ``details`` tag.",
            "            That means the content is folded by default and users have to click",
            "            to show the content. This option is useful if the added table is",
            "            large.",
            "",
            "        **kwargs : dict",
            "            The keys should be strings, which will be used as the section",
            "            headers, and the values should be tables. Tables can be either dicts",
            "            with the key being strings that represent the column name, and the",
            "            values being lists that represent the entries for each row.",
            "            Alternatively, the table can be a :class:`pandas.DataFrame`. The",
            "            table must not be empty.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        description = description or \"\"",
            "        for key, val in kwargs.items():",
            "            section = TableSection(",
            "                title=key, content=description, table=val, folded=folded",
            "            )",
            "            self._add_single(key, section)",
            "        return self",
            "",
            "    def add_metrics(",
            "        self,",
            "        section: str = \"Model description/Evaluation Results\",",
            "        description: str | None = None,",
            "        **kwargs: str | int | float,",
            "    ) -> Self:",
            "        \"\"\"Add metric values to the model card.",
            "",
            "        All metrics will be collected in, and then formatted to, a table.",
            "",
            "        Parameters",
            "        ----------",
            "        section : str (default=\"Model description/Evaluation Results\")",
            "            The section that metrics should be added to. By default, the section",
            "            is set to fit the skops model card template. If you're using a",
            "            different template, you may have to choose a different section name.",
            "",
            "        description : str or None, default=None",
            "            An optional description to be added before the metrics. If you're",
            "            using the default skops template, a standard text is used. Pass a",
            "            string here if you want to use your own text instead. Leave this",
            "            empty to not add any description.",
            "",
            "        **kwargs : dict",
            "            A dictionary of the form ``{metric name: metric value}``.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "",
            "        \"\"\"",
            "        self._metrics.update(kwargs)",
            "        self._add_metrics(section, description=description, metrics=self._metrics)",
            "        return self",
            "",
            "    def add_permutation_importances(",
            "        self,",
            "        permutation_importances,",
            "        columns: Sequence[str],",
            "        plot_file: str | Path = \"permutation_importances.png\",",
            "        plot_name: str = \"Permutation Importances\",",
            "        overwrite: bool = False,",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"Plots permutation importance and saves it to model card.",
            "",
            "        Parameters",
            "        ----------",
            "        permutation_importances : sklearn.utils.Bunch",
            "            Output of :func:`sklearn.inspection.permutation_importance`.",
            "",
            "        columns : str, list or pandas.Index",
            "            Column names of the data used to generate importances.",
            "",
            "        plot_file : str or pathlib.Path",
            "            Filename for the plot.",
            "",
            "        plot_name : str",
            "            Name of the plot.",
            "",
            "        overwrite : bool (default=False)",
            "            Whether to overwrite the permutation importance plot file, if a plot by that",
            "            name already exists.",
            "",
            "        description : str | None (default=None)",
            "            An optional description to be added before the plot.",
            "",
            "        Returns",
            "        -------",
            "        self : object",
            "            Card object.",
            "        \"\"\"",
            "        plt = import_or_raise(\"matplotlib.pyplot\", \"permutation importance\")",
            "",
            "        if Path(plot_file).exists() and overwrite is False:",
            "            raise ValueError(",
            "                f\"{str(plot_file)} already exists. Set `overwrite` to `True` or pass a\"",
            "                \" different filename for the plot.\"",
            "            )",
            "        sorted_importances_idx = permutation_importances.importances_mean.argsort()",
            "        _, ax = plt.subplots()",
            "        boxplot(",
            "            ax,",
            "            x=permutation_importances.importances[sorted_importances_idx].T,",
            "            tick_labels=columns[sorted_importances_idx],",
            "            vert=False,",
            "        )",
            "        ax.set_title(plot_name)",
            "        ax.set_xlabel(\"Decrease in Score\")",
            "        plt.savefig(plot_file)",
            "        self.add_plot(description=description, alt_text=None, **{plot_name: plot_file})",
            "",
            "        return self",
            "",
            "    def add_fairlearn_metric_frame(",
            "        self,",
            "        metric_frame,",
            "        table_name: str = \"Fairlearn MetricFrame Table\",",
            "        transpose: bool = True,",
            "        description: str | None = None,",
            "    ) -> Self:",
            "        \"\"\"",
            "        Add a :class:`fairlearn.metrics.MetricFrame` table to the model card.",
            "        The table contains the difference, group_ma, group_min, and ratio for",
            "        each metric.",
            "",
            "        Parameters",
            "        ----------",
            "        metric_frame: MetricFrame",
            "            The Fairlearn MetricFrame to add to the model card.",
            "",
            "        table_name: str",
            "            The desired name of the table section in the model card.",
            "",
            "        transpose: bool, default=True",
            "            Whether to transpose the table or not.",
            "",
            "",
            "        description : str | None (default=None)",
            "            An optional description to be added before the table.",
            "",
            "        Returns",
            "        -------",
            "        self: Card",
            "            The model card with the metric frame added.",
            "",
            "        Notes",
            "        --------",
            "        You can check `fairlearn's documentation",
            "        <https://fairlearn.org/v0.8/user_guide/assessment/index.html>`__ on how to",
            "        work with `MetricFrame`s.",
            "",
            "        \"\"\"",
            "        frame_dict = {",
            "            \"difference\": metric_frame.difference(),",
            "            \"group_max\": metric_frame.group_max(),",
            "            \"group_min\": metric_frame.group_min(),",
            "            \"ratio\": metric_frame.ratio(),",
            "        }",
            "",
            "        if transpose is True:",
            "            pd = import_or_raise(\"pandas\", \"Pandas is used to pivot the table.\")",
            "",
            "            frame_dict = pd.DataFrame(frame_dict).T",
            "",
            "        return self.add_table(",
            "            folded=True, description=description, **{table_name: frame_dict}",
            "        )",
            "",
            "    def _add_metrics(",
            "        self,",
            "        section_name: str,",
            "        description: str | None,",
            "        metrics: dict[str, str | float | int],",
            "    ) -> None:",
            "        \"\"\"Add metrics to the Evaluation Results section.\"\"\"",
            "        if self._metrics:",
            "            # transpose from row oriented to column oriented",
            "            data_transposed = zip(*self._metrics.items())",
            "            table = {",
            "                key: list(val) for key, val in zip([\"Metric\", \"Value\"], data_transposed)",
            "            }",
            "        else:",
            "            # create empty table",
            "            table = {\"Metric\": [], \"Value\": []}",
            "",
            "        description = description or \"\"",
            "        title = split_subsection_names(section_name)[-1]",
            "        section = TableSection(title=title, content=description, table=table)",
            "        self._add_single(section_name, section)",
            "",
            "    def _generate_metadata(self, metadata: ModelCardData) -> Iterator[str]:",
            "        \"\"\"Yield metadata in yaml format\"\"\"",
            "        for key, val in metadata.to_dict().items() if metadata else {}:",
            "            yield aRepr.repr(f\"metadata.{key}={val},\").strip('\"').strip(\"'\")",
            "",
            "    def _generate_content(",
            "        self,",
            "        data: dict[str, Section],",
            "        depth: int = 1,",
            "        destination_path: Path | None = None,",
            "    ) -> Iterator[str]:",
            "        \"\"\"Yield title and (formatted) contents.",
            "",
            "        Recursively go through the data and consecutively yield the title with",
            "        the appropriate number of \"#\"s (markdown format), then the associated",
            "        content.",
            "",
            "        \"\"\"",
            "        for section in data.values():",
            "            if not section.visible:",
            "                continue",
            "",
            "            title = f\"{depth * '#'} {section.title}\"",
            "            yield title",
            "",
            "            yield section.format()",
            "",
            "            if destination_path is not None and isinstance(section, PlotSection):",
            "                shutil.copy(section.path, destination_path)",
            "",
            "            if section.subsections and not section.folded:",
            "                yield from self._generate_content(",
            "                    section.subsections,",
            "                    depth=depth + 1,",
            "                    destination_path=destination_path,",
            "                )",
            "",
            "    def _iterate_content(",
            "        self, data: dict[str, Section], parent_section: str = \"\"",
            "    ) -> Iterator[tuple[str, Section]]:",
            "        \"\"\"Yield tuples of title and (non-formatted) content.\"\"\"",
            "        for val in data.values():",
            "            if parent_section:",
            "                title = \"/\".join((parent_section, val.title))",
            "            else:",
            "                title = val.title",
            "",
            "            yield title, val",
            "",
            "            if val.subsections:",
            "                yield from self._iterate_content(val.subsections, parent_section=title)",
            "",
            "    @staticmethod",
            "    def _format_repr(text: str) -> str:",
            "        # Remove new lines, multiple spaces, quotation marks, and cap line length",
            "        text = text.replace(\"\\n\", \" \")",
            "        text = re.sub(r\"\\s+\", r\" \", text)",
            "        return aRepr.repr(text).strip('\"').strip(\"'\")",
            "",
            "    def __str__(self) -> str:",
            "        return self.__repr__()",
            "",
            "    def __repr__(self) -> str:",
            "        # repr for the model",
            "        model = getattr(self, \"model\", None)",
            "        if model:",
            "            model_repr = self._format_repr(f\"model={repr(self.get_model())},\")",
            "        else:",
            "            model_repr = None",
            "",
            "        # repr for metadata",
            "        metadata_reprs = []",
            "        for key, val in self.metadata.to_dict().items() if self.metadata else {}:",
            "            if key == \"widget\":",
            "                metadata_reprs.append(\"metadata.widget=[{...}],\")",
            "                continue",
            "",
            "            metadata_reprs.append(self._format_repr(f\"metadata.{key}={val},\"))",
            "        metadata_repr = \"\\n\".join(metadata_reprs)",
            "",
            "        # repr for contents",
            "        content_reprs = []",
            "        for title, section in self._iterate_content(self._data):",
            "            content = section.format()",
            "            if not content:",
            "                continue",
            "            if content.rstrip(\"`\").rstrip().endswith(CONTENT_PLACEHOLDER):",
            "                # if content is just some default text, no need to show it",
            "                continue",
            "            content_reprs.append(self._format_repr(f\"{title}={section},\"))",
            "        content_repr = \"\\n\".join(content_reprs)",
            "",
            "        # combine all parts",
            "        complete_repr = \"Card(\\n\"",
            "        if model_repr:",
            "            complete_repr += textwrap.indent(model_repr, \"  \") + \"\\n\"",
            "        if metadata_reprs:",
            "            complete_repr += textwrap.indent(metadata_repr, \"  \") + \"\\n\"",
            "        if content_reprs:",
            "            complete_repr += textwrap.indent(content_repr, \"  \") + \"\\n\"",
            "        complete_repr += \")\"",
            "        return complete_repr",
            "",
            "    def _generate_card(self, destination_path: Path | None = None) -> Iterator[str]:",
            "        \"\"\"Yield sections of the model card, including the metadata.\"\"\"",
            "        if self.metadata.to_dict():",
            "            yield f\"---\\n{self.metadata.to_yaml()}\\n---\"",
            "",
            "        for line in self._generate_content(",
            "            self._data, destination_path=destination_path",
            "        ):",
            "            if line:",
            "                yield \"\\n\" + line",
            "",
            "        # add an empty line add the end",
            "        yield \"\"",
            "",
            "    def save(self, path: str | Path, copy_files: bool = False) -> None:",
            "        \"\"\"Save the model card.",
            "",
            "        This method renders the model card in markdown format and then saves it",
            "        as the specified file.",
            "",
            "        Parameters",
            "        ----------",
            "        path: Path",
            "            Filepath to save your card.",
            "",
            "        plot_path: str",
            "            Filepath to save the plots. Use this when saving the model card",
            "            before creating the repository. Without this path the README will",
            "            have an absolute path to the plot that won't exist in the",
            "            repository.",
            "",
            "        Notes",
            "        -----",
            "        The keys in model card metadata can be seen `here",
            "        <https://huggingface.co/docs/hub/models-cards#model-card-metadata>`__.",
            "        \"\"\"",
            "        with open(path, \"w\", encoding=\"utf-8\") as f:",
            "            if not isinstance(path, Path):",
            "                path = Path(path)",
            "            destination_path = path.parent if copy_files else None",
            "            f.write(\"\\n\".join(self._generate_card(destination_path=destination_path)))",
            "",
            "    def render(self) -> str:",
            "        \"\"\"Render the final model card as a string.",
            "",
            "        Returns",
            "        -------",
            "        result : str",
            "            The rendered model card with all placeholders filled and all extra",
            "            sections inserted.",
            "        \"\"\"",
            "        return \"\\n\".join(self._generate_card())",
            "",
            "    def _iterate_key_section_content(",
            "        self,",
            "        data: dict[str, Section],",
            "        level: int = 0,",
            "    ):",
            "        \"\"\"Iterate through the key sections and yield the title and level.",
            "",
            "        Parameters",
            "        ----------",
            "        data : dict[str, Section]",
            "            The card data to iterate through. This is usually the sections and",
            "            subsections.",
            "",
            "        level : int, optional",
            "            The level of the section, by default 0. This keeps track of subsections.",
            "",
            "        Returns",
            "        -------",
            "        table_of_contents : str",
            "        \"\"\"",
            "        for key, val in data.items():",
            "            if not getattr(val, \"visible\", True):",
            "                continue",
            "",
            "            title = val.title",
            "            yield title, level",
            "",
            "            if val.subsections:",
            "                yield from self._iterate_key_section_content(",
            "                    val.subsections,",
            "                    level=level + 1,",
            "                )",
            "",
            "    def get_toc(self) -> str:",
            "        \"\"\"Get the table of contents for the model card.",
            "",
            "        Returns",
            "        -------",
            "        toc : str",
            "            The table of contents for the model card formatted as a markdown string.",
            "            Example:",
            "                - Model description",
            "                    - Intended uses & limitations",
            "                    - Training Procedure",
            "                        - Hyperparameters",
            "                        - Model Plot",
            "                    - Evaluation Results",
            "                - How to Get Started with the Model",
            "                - Model Card Authors",
            "                - Model Card Contact",
            "        \"\"\"",
            "        sections = []",
            "        for title, level in self._iterate_key_section_content(self._data):",
            "            sections.append(f\"{'  ' * level}- {title}\")",
            "",
            "        return \"\\n\".join(sections)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "15": [],
            "491": [
                "Card",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "skops/card/tests/test_card.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     TableSection,"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     _load_model,"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from skops.io import dump, load"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+from skops.io import dump, get_untrusted_types, load"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from skops.utils.importutils import import_or_raise"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " def test_load_model(suffix):"
            },
            "9": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     model0 = LinearRegression(n_jobs=123)"
            },
            "10": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     _, save_file = save_model_to_file(model0, suffix)"
            },
            "11": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    loaded_model_str = _load_model(save_file, trusted=True)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+    if suffix == \".skops\":"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        untrusted_types = get_untrusted_types(file=save_file)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    else:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        untrusted_types = None"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    loaded_model_str = _load_model(save_file, trusted=untrusted_types)"
            },
            "17": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     save_file_path = Path(save_file)"
            },
            "18": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    loaded_model_path = _load_model(save_file_path, trusted=True)"
            },
            "19": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    loaded_model_instance = _load_model(model0, trusted=True)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    loaded_model_path = _load_model(save_file_path, trusted=untrusted_types)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    loaded_model_instance = _load_model(model0, trusted=untrusted_types)"
            },
            "22": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     assert loaded_model_str.n_jobs == 123"
            },
            "24": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     assert loaded_model_path.n_jobs == 123"
            },
            "25": {
                "beforePatchRowNumber": 1383,
                "afterPatchRowNumber": 1387,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 1384,
                "afterPatchRowNumber": 1388,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 1385,
                "afterPatchRowNumber": 1389,
                "PatchRowcode": " class TestCardModelAttributeIsPath:"
            },
            "28": {
                "beforePatchRowNumber": 1386,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def path_to_card(self, path):"
            },
            "29": {
                "beforePatchRowNumber": 1387,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        card = Card(model=path, trusted=True)"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1390,
                "PatchRowcode": "+    def path_to_card(self, path, suffix):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1391,
                "PatchRowcode": "+        if suffix == \".skops\":"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1392,
                "PatchRowcode": "+            card = Card(model=path, trusted=get_untrusted_types(file=path))"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1393,
                "PatchRowcode": "+        else:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1394,
                "PatchRowcode": "+            card = Card(model=path)"
            },
            "35": {
                "beforePatchRowNumber": 1388,
                "afterPatchRowNumber": 1395,
                "PatchRowcode": "         return card"
            },
            "36": {
                "beforePatchRowNumber": 1389,
                "afterPatchRowNumber": 1396,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 1390,
                "afterPatchRowNumber": 1397,
                "PatchRowcode": "     @pytest.mark.parametrize(\"meth\", [repr, str])"
            },
            "38": {
                "beforePatchRowNumber": 1397,
                "afterPatchRowNumber": 1404,
                "PatchRowcode": "         model = LinearRegression(fit_intercept=False)"
            },
            "39": {
                "beforePatchRowNumber": 1398,
                "afterPatchRowNumber": 1405,
                "PatchRowcode": "         file_handle, file_name = save_model_to_file(model, suffix)"
            },
            "40": {
                "beforePatchRowNumber": 1399,
                "afterPatchRowNumber": 1406,
                "PatchRowcode": "         os.close(file_handle)"
            },
            "41": {
                "beforePatchRowNumber": 1400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        card_from_path = self.path_to_card(file_name)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1407,
                "PatchRowcode": "+        card_from_path = self.path_to_card(file_name, suffix=suffix)"
            },
            "43": {
                "beforePatchRowNumber": 1401,
                "afterPatchRowNumber": 1408,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 1402,
                "afterPatchRowNumber": 1409,
                "PatchRowcode": "         result0 = meth(card_from_path)"
            },
            "45": {
                "beforePatchRowNumber": 1403,
                "afterPatchRowNumber": 1410,
                "PatchRowcode": "         expected = \"Card(\\n  model=LinearRegression(fit_intercept=False),\""
            }
        },
        "frontPatchFile": [
            "import os",
            "import pickle",
            "import re",
            "import tempfile",
            "import textwrap",
            "from pathlib import Path",
            "from unittest import mock",
            "",
            "import numpy as np",
            "import pytest",
            "import sklearn",
            "from huggingface_hub import ModelCardData, metadata_load",
            "from sklearn.datasets import load_iris",
            "from sklearn.inspection import permutation_importance",
            "from sklearn.linear_model import LinearRegression, LogisticRegression",
            "from sklearn.metrics import f1_score, make_scorer",
            "from sklearn.neighbors import KNeighborsClassifier",
            "",
            "from skops import hub_utils",
            "from skops.card import Card, metadata_from_config",
            "from skops.card._model_card import (",
            "    CONTENT_PLACEHOLDER,",
            "    SKOPS_TEMPLATE,",
            "    PlotSection,",
            "    Section,",
            "    TableSection,",
            "    _load_model,",
            ")",
            "from skops.io import dump, load",
            "from skops.utils.importutils import import_or_raise",
            "",
            "",
            "def fit_model():",
            "    X = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])",
            "    y = np.dot(X, np.array([1, 2])) + 3",
            "    reg = LinearRegression().fit(X, y)",
            "    return reg",
            "",
            "",
            "def save_model_to_file(model_instance, suffix):",
            "    save_file_handle, save_file = tempfile.mkstemp(suffix=suffix, prefix=\"skops-test\")",
            "    if suffix in (\".pkl\", \".pickle\"):",
            "        with open(save_file, \"wb\") as f:",
            "            pickle.dump(model_instance, f)",
            "    elif suffix == \".skops\":",
            "        dump(model_instance, save_file)",
            "    return save_file_handle, save_file",
            "",
            "",
            "@pytest.mark.parametrize(\"suffix\", [\".pkl\", \".pickle\", \".skops\"])",
            "def test_load_model(suffix):",
            "    model0 = LinearRegression(n_jobs=123)",
            "    _, save_file = save_model_to_file(model0, suffix)",
            "    loaded_model_str = _load_model(save_file, trusted=True)",
            "    save_file_path = Path(save_file)",
            "    loaded_model_path = _load_model(save_file_path, trusted=True)",
            "    loaded_model_instance = _load_model(model0, trusted=True)",
            "",
            "    assert loaded_model_str.n_jobs == 123",
            "    assert loaded_model_path.n_jobs == 123",
            "    assert loaded_model_instance.n_jobs == 123",
            "",
            "",
            "@pytest.fixture",
            "def model_card(model_diagram=True):",
            "    model = fit_model()",
            "    card = Card(model, model_diagram)",
            "    yield card",
            "",
            "",
            "@pytest.fixture",
            "def iris_data():",
            "    X, y = load_iris(return_X_y=True, as_frame=True)",
            "    yield X, y",
            "",
            "",
            "@pytest.fixture",
            "def iris_estimator(iris_data):",
            "    X, y = iris_data",
            "    est = LogisticRegression(solver=\"liblinear\").fit(X, y)",
            "    yield est",
            "",
            "",
            "@pytest.fixture",
            "def iris_pkl_file(iris_estimator):",
            "    pkl_file = tempfile.mkstemp(suffix=\".pkl\", prefix=\"skops-test\")[1]",
            "    with open(pkl_file, \"wb\") as f:",
            "        pickle.dump(iris_estimator, f)",
            "    yield pkl_file",
            "",
            "",
            "@pytest.fixture",
            "def iris_skops_file(iris_estimator):",
            "    skops_folder = tempfile.mkdtemp()",
            "    model_name = \"model.skops\"",
            "    skops_path = Path(skops_folder) / model_name",
            "    dump(iris_estimator, skops_path)",
            "    yield skops_path",
            "",
            "",
            "def _create_model_card_from_saved_model(",
            "    destination_path,",
            "    iris_estimator,",
            "    iris_data,",
            "    save_file,",
            "):",
            "    X, y = iris_data",
            "    hub_utils.init(",
            "        model=save_file,",
            "        requirements=[f\"scikit-learn=={sklearn.__version__}\"],",
            "        dst=destination_path,",
            "        task=\"tabular-classification\",",
            "        data=X,",
            "    )",
            "    card = Card(iris_estimator, metadata=metadata_from_config(destination_path))",
            "    card.save(Path(destination_path) / \"README.md\")",
            "    return card",
            "",
            "",
            "@pytest.fixture",
            "def skops_model_card_metadata_from_config(",
            "    destination_path, iris_estimator, iris_skops_file, iris_data",
            "):",
            "    yield _create_model_card_from_saved_model(",
            "        destination_path, iris_estimator, iris_data, iris_skops_file",
            "    )",
            "",
            "",
            "@pytest.fixture",
            "def pkl_model_card_metadata_from_config(",
            "    destination_path, iris_estimator, iris_pkl_file, iris_data",
            "):",
            "    yield _create_model_card_from_saved_model(",
            "        destination_path, iris_estimator, iris_data, iris_pkl_file",
            "    )",
            "",
            "",
            "@pytest.fixture",
            "def destination_path():",
            "    with tempfile.TemporaryDirectory(prefix=\"skops-test\") as dir_path:",
            "        yield Path(dir_path)",
            "",
            "",
            "def test_save_model_card(destination_path, model_card):",
            "    model_card.save(Path(destination_path) / \"README.md\")",
            "    assert (Path(destination_path) / \"README.md\").exists()",
            "",
            "",
            "def test_model_caching(",
            "    skops_model_card_metadata_from_config, iris_skops_file, destination_path",
            "):",
            "    \"\"\"Tests that the model card caches the model to avoid loading it multiple times\"\"\"",
            "",
            "    new_model = LogisticRegression(random_state=4321)",
            "    # mock _load_model, it still loads the model but we can track call count",
            "    mock_load_model = mock.Mock(side_effect=load)",
            "    card = Card(iris_skops_file, metadata=metadata_from_config(destination_path))",
            "    with mock.patch(\"skops.card._model_card._load_model\", mock_load_model):",
            "        model1 = card.get_model()",
            "        model2 = card.get_model()",
            "        assert model1 is model2",
            "        # model is cached, hence _load_model is not called",
            "        mock_load_model.assert_not_called()",
            "",
            "        # override model with new model",
            "        dump(new_model, card.model)",
            "",
            "        model3 = card.get_model()",
            "        assert mock_load_model.call_count == 1",
            "        assert model3.random_state == 4321",
            "        model4 = card.get_model()",
            "",
            "        assert model3 is model4",
            "        assert mock_load_model.call_count == 1  # cached call",
            "",
            "",
            "CUSTOM_TEMPLATES = [None, {}, {\"A Title\", \"Another Title\", \"A Title/A Section\"}]  # type: ignore",
            "",
            "",
            "class TestAddModelPlot:",
            "    \"\"\"Tests for the sklearn model repr\"\"\"",
            "",
            "    def test_default(self, model_card):",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_no_overflow(self, model_card):",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # test if the model doesn't overflow the huggingface models page",
            "        assert result.count(\"sk-top-container\") == 1",
            "        assert 'style=\"overflow: auto;' in result",
            "",
            "    def test_model_diagram_false(self):",
            "        model = fit_model()",
            "        model_card = Card(model, model_diagram=False)",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        assert result == CONTENT_PLACEHOLDER",
            "",
            "    def test_model_diagram_str(self):",
            "        # if passing a str, use that as the section name",
            "        model = fit_model()",
            "        other_section_name = \"Here is the model diagram\"",
            "        model_card = Card(model, model_diagram=other_section_name)",
            "",
            "        # first check that default section only contains placeholder",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        assert result == CONTENT_PLACEHOLDER",
            "",
            "        # now check that the actual model diagram is in the other section",
            "        result = model_card.select(other_section_name).format()",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_other_section(self, model_card):",
            "        model_card.add_model_plot(section=\"Other section\")",
            "        result = model_card.select(\"Other section\").content",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_with_description(self, model_card):",
            "        model_card.add_model_plot(description=\"Awesome diagram below\")",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        assert result.startswith(\"Awesome diagram below\\n\\n<style>#sk-\")",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_uses_default(self, template):",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "        model_card.add_model_plot()",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_init_str_works(self, template):",
            "        model = fit_model()",
            "        section_name = \"Here is the model diagram\"",
            "        model_card = Card(model, template=template, model_diagram=section_name)",
            "",
            "        result = model_card.select(section_name).format()",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_default_template_and_model_diagram_true(self, model_card):",
            "        # setting model_diagram=True should not change anything vs auto with the",
            "        # default template",
            "        model = fit_model()",
            "        model_card = Card(model, model_diagram=True)",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_and_model_diagram_true_uses_default(",
            "        self, model_card, template",
            "    ):",
            "        # when using a custom template and not indicating a section, use the",
            "        # default section",
            "        model = fit_model()",
            "        Card(model, template=template, model_diagram=True)",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        text1 = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).content",
            "        model_card.add_model_plot(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").content",
            "",
            "        # both are identical, except for numbers like \"#sk-container-id-123\",",
            "        # thus compare everything but the numbers",
            "        assert re.split(r\"\\d+\", text1) == re.split(r\"\\d+\", text2)",
            "",
            "",
            "def _strip_multiple_chars(text, char):",
            "    # utility function needed to compare tables across systems",
            "    # _strip_multiple_chars(\"hi    there\") == \"hi there\"",
            "    # _strip_multiple_chars(\"|---|--|\", \"-\") == \"|-|-|\"",
            "    while char + char in text:",
            "        text = text.replace(char + char, char)",
            "    return text",
            "",
            "",
            "class TestAddHyperparams:",
            "    \"\"\"Tests for the model hyperparameters\"\"\"",
            "",
            "    @pytest.fixture",
            "    def expected(self):",
            "        lines = [",
            "            \"<details>\",",
            "            \"<summary> Click to expand </summary>\",",
            "            \"\",",
            "            \"| Hyperparameter   | Value       |\",",
            "            \"|------------------|-------------|\",",
            "            \"| copy_X           | True        |\",",
            "            \"| fit_intercept    | True        |\",",
            "            \"| n_jobs           |             |\",",
            "            \"| normalize        | deprecated  |\",",
            "            \"| positive         | False       |\",",
            "            \"\",",
            "            \"</details>\",",
            "        ]",
            "        # TODO: After dropping sklearn < 1.2, when the \"normalize\" parameter is",
            "        # removed, remove it from the table above and remove the code below.",
            "        major, minor, *_ = sklearn.__version__.split(\".\")",
            "        major, minor = int(major), int(minor)",
            "        if (major >= 1) and (minor >= 2):",
            "            del lines[8]",
            "",
            "        table = \"\\n\".join(lines)",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        table = _strip_multiple_chars(table, \" \")",
            "        table = _strip_multiple_chars(table, \"-\")",
            "        return table",
            "",
            "    def test_default(self, model_card, expected):",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_other_section(self, model_card, expected):",
            "        model_card.add_hyperparams(section=\"Other section\")",
            "        result = model_card.select(\"Other section\").format()",
            "",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_with_description(self, model_card, expected):",
            "        model_card.add_hyperparams(description=\"Awesome hyperparams\")",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "        assert result.startswith(\"Awesome hyperparams\")",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_uses_default(self, template, expected):",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "        model_card.add_hyperparams()",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        text1 = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "        model_card.add_hyperparams(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").format()",
            "",
            "        assert text1 == text2",
            "",
            "    def test_hyperparameter_table_with_line_break(self):",
            "        # Hyperparameters can contain values with line breaks, \"\\n\", in them. In",
            "        # that case, the markdown table is broken. Check that the hyperparameter",
            "        # table we create properly replaces the \"\\n\" with \"<br />\".",
            "        class EstimatorWithLbInParams:",
            "            def get_params(self, deep=False):",
            "                return {\"fit_intercept\": True, \"n_jobs\": \"line\\nwith\\nbreak\"}",
            "",
            "        model_card = Card(EstimatorWithLbInParams())",
            "        section_name = \"Model description/Training Procedure/Hyperparameters\"",
            "        text_hyperparams = model_card.select(section_name).format()",
            "",
            "        # remove multiple whitespaces, as they're not important",
            "        text_cleaned = _strip_multiple_chars(text_hyperparams, \" \")",
            "        assert \"| n_jobs | line<br />with<br />break |\" in text_cleaned",
            "",
            "",
            "class TestAddMetrics:",
            "    \"\"\"Tests for adding metrics\"\"\"",
            "",
            "    def test_default(self, model_card):",
            "        # by default, don't add a table, as there are no metrics",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        expected = CONTENT_PLACEHOLDER",
            "        assert result == expected",
            "",
            "    def test_empty_metrics_table(self, model_card):",
            "        model_card.add_metrics()",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        expected = (",
            "            \"| Metric   | Value   |\\n\"  # fmt: skip",
            "            \"|----------|---------|\"",
            "        )",
            "        assert result == expected",
            "",
            "    def test_multiple_metrics(self, model_card):",
            "        model_card.add_metrics(**{\"acc\": \"0.1\"})  # str",
            "        model_card.add_metrics(",
            "            f1=0.1,  # float",
            "            awesomeness=123,  # int",
            "        )",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        expected = (",
            "            \"| Metric      |   Value |\\n\"",
            "            \"|-------------|---------|\\n\"",
            "            \"| acc         |     0.1 |\\n\"",
            "            \"| f1          |     0.1 |\\n\"",
            "            \"| awesomeness |   123   |\"",
            "        )",
            "        assert result == expected",
            "",
            "    def test_other_section(self, model_card):",
            "        model_card.add_metrics(accuracy=0.9, section=\"Other section\")",
            "        result = model_card.select(\"Other section\").format()",
            "        # fmt: off",
            "        expected = (",
            "            \"| Metric   |   Value |\\n\"",
            "            \"|----------|---------|\\n\"",
            "            \"| accuracy |     0.9 |\"",
            "        )",
            "        # fmt: on",
            "        assert result == expected",
            "",
            "    def test_with_description(self, model_card):",
            "        model_card.add_metrics(accuracy=0.9, description=\"Awesome metrics\")",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        assert result.startswith(\"Awesome metrics\\n\\n| Metric \")",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_raises(self, template):",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "        model_card.add_metrics(accuracy=0.9)",
            "",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        # fmt: off",
            "        expected = (",
            "            \"| Metric   |   Value |\\n\"",
            "            \"|----------|---------|\\n\"",
            "            \"| accuracy |     0.9 |\"",
            "        )",
            "        # fmt: on",
            "        assert result == expected",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        model_card.add_metrics(accuracy=0.9)",
            "        text1 = model_card.select(\"Model description/Evaluation Results\").format()",
            "        model_card.add_metrics(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").format()",
            "        assert text1 == text2",
            "",
            "",
            "class TestAddPermutationImportance:",
            "    @pytest.fixture",
            "    def importances(self, iris_estimator, iris_data):",
            "        X, y = iris_data",
            "        result = permutation_importance(",
            "            iris_estimator, X, y, n_repeats=10, random_state=42, n_jobs=2",
            "        )",
            "        return result",
            "",
            "    def test_permutation_importances(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        model_card.add_permutation_importances(",
            "            importances,",
            "            columns=X.columns,",
            "            plot_file=Path(destination_path) / \"importance.png\",",
            "            plot_name=\"Permutation Importance\",",
            "        )",
            "        temp_path = Path(destination_path) / \"importance.png\"",
            "        section = model_card.select(\"Permutation Importance\")",
            "        expected = f\"![Permutation Importance]({temp_path})\"",
            "        assert section.format() == expected",
            "",
            "    def test_multiple_permutation_importances(",
            "        self, iris_data, iris_estimator, importances, model_card, destination_path",
            "    ):",
            "        X, y = iris_data",
            "        model_card.add_permutation_importances(",
            "            importances, X.columns, plot_file=Path(destination_path) / \"importance.png\"",
            "        )",
            "",
            "        f1 = make_scorer(f1_score, average=\"micro\")",
            "        importances_f1 = permutation_importance(",
            "            iris_estimator, X, y, scoring=f1, n_repeats=10, random_state=42, n_jobs=2",
            "        )",
            "        model_card.add_permutation_importances(",
            "            importances_f1,",
            "            columns=X.columns,",
            "            plot_file=Path(destination_path) / \"f1_importance.png\",",
            "            plot_name=\"Permutation Importance on f1\",",
            "        )",
            "",
            "        # check for default one",
            "        temp_path = Path(destination_path) / \"importance.png\"",
            "        section = model_card.select(\"Permutation Importances\")",
            "        expected = f\"![Permutation Importances]({temp_path})\"",
            "        assert section.format() == expected",
            "",
            "        # check for F1",
            "        temp_path_f1 = Path(destination_path) / \"f1_importance.png\"",
            "        section = model_card.select(\"Permutation Importance on f1\")",
            "        expected = f\"![Permutation Importance on f1]({temp_path_f1})\"",
            "        assert section.format() == expected",
            "",
            "    def test_duplicate_permutation_importances(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        plot_path = os.path.join(destination_path, \"importance.png\")",
            "        model_card.add_permutation_importances(",
            "            importances, X.columns, plot_file=plot_path",
            "        )",
            "        with pytest.raises(",
            "            ValueError,",
            "            match=(",
            "                \"already exists. Set `overwrite` to `True` or pass a\"",
            "                \" different filename for the plot.\"",
            "            ),",
            "        ):",
            "            model_card.add_permutation_importances(",
            "                importances,",
            "                columns=X.columns,",
            "                plot_file=plot_path,",
            "                plot_name=\"Permutation Importance on f1\",",
            "            )",
            "",
            "    def test_duplicate_permutation_importances_overwrite(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        plot_path = os.path.join(destination_path, \"importance.png\")",
            "        model_card.add_permutation_importances(",
            "            importances, X.columns, plot_file=plot_path",
            "        )",
            "",
            "        model_card.add_permutation_importances(",
            "            importances,",
            "            columns=X.columns,",
            "            plot_file=plot_path,",
            "            plot_name=\"Permutation Importance on f1\",",
            "            overwrite=True,",
            "        )",
            "        section = model_card.select(\"Permutation Importance on f1\")",
            "        expected = f\"![Permutation Importance on f1]({plot_path})\"",
            "        assert section.format() == expected",
            "",
            "    def test_permutation_importances_with_description(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        model_card.add_permutation_importances(",
            "            importances,",
            "            columns=X.columns,",
            "            plot_file=Path(destination_path) / \"importance.png\",",
            "            description=\"Very important\",",
            "        )",
            "        temp_path = Path(destination_path) / \"importance.png\"",
            "        section = model_card.select(\"Permutation Importances\")",
            "        expected = f\"Very important\\n\\n![Permutation Importances]({temp_path})\"",
            "        assert section.format() == expected",
            "",
            "",
            "class TestAddGetStartedCode:",
            "    \"\"\"Tests for getting started code\"\"\"",
            "",
            "    @pytest.fixture",
            "    def metadata(self):",
            "        # dummy ModelCardData using pickle",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.pickle\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"pickle\",",
            "                    },",
            "                }",
            "",
            "        return Metadata()",
            "",
            "    @pytest.fixture",
            "    def model_card(self, metadata):",
            "        model = fit_model()",
            "        card = Card(model, metadata=metadata)",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def metadata_skops(self):",
            "        # dummy ModelCardData using skops",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.skops\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"skops\",",
            "                    },",
            "                }",
            "",
            "        return Metadata()",
            "",
            "    @pytest.fixture",
            "    def model_card_skops(self, metadata_skops):",
            "        model = fit_model()",
            "        card = Card(model, metadata=metadata_skops)",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def text_pickle(self):",
            "        return (",
            "            \"```python\\n\"",
            "            \"import json\\n\"",
            "            \"import pandas as pd\\n\"",
            "            \"import joblib\\n\"",
            "            'model = joblib.load(\"my-model.pickle\")\\n'",
            "            'with open(\"config.json\") as f:\\n'",
            "            \"    config = json.load(f)\\n\"",
            "            'model.predict(pd.DataFrame.from_dict(config[\"sklearn\"][\"example_input\"]))\\n'",
            "            \"```\"",
            "        )",
            "",
            "    @pytest.fixture",
            "    def text_skops(self):",
            "        return (",
            "            \"```python\\n\"",
            "            \"import json\\n\"",
            "            \"import pandas as pd\\n\"",
            "            \"import skops.io as sio\\n\"",
            "            'model = sio.load(\"my-model.skops\")\\n'",
            "            'with open(\"config.json\") as f:\\n'",
            "            \"    config = json.load(f)\\n\"",
            "            'model.predict(pd.DataFrame.from_dict(config[\"sklearn\"][\"example_input\"]))\\n'",
            "            \"```\"",
            "        )",
            "",
            "    def test_default_pickle(self, model_card, text_pickle):",
            "        # by default, don't add a table, as there are no metrics",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result == text_pickle",
            "",
            "    def test_default_skops(self, model_card_skops, text_skops):",
            "        # by default, don't add a table, as there are no metrics",
            "        result = model_card_skops.select(\"How to Get Started with the Model\").format()",
            "        assert result == text_skops",
            "",
            "    def test_no_metadata_file_name(self):",
            "        model = fit_model()",
            "        card = Card(model, metadata=None)",
            "        card.add_get_started_code()  # does not raise",
            "",
            "    def test_no_metadata_file_format(self):",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.skops\",",
            "                    # missing file format entry",
            "                }",
            "",
            "        model = fit_model()",
            "        card = Card(model, metadata=Metadata())",
            "        card.add_get_started_code()  # does not raise",
            "",
            "    def test_other_section(self, model_card, text_pickle):",
            "        model_card.add_get_started_code(section=\"Other section\")",
            "        result = model_card.select(\"Other section\").format()",
            "        assert result == text_pickle",
            "",
            "    def test_use_description(self, model_card):",
            "        model_card.add_get_started_code(description=\"Awesome code\")",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result.startswith(\"Awesome code\")",
            "",
            "    def test_other_filename(self, model_card, text_pickle):",
            "        model_card.add_get_started_code(file_name=\"foobar.pkl\")",
            "        text = text_pickle.replace(\"my-model.pickle\", \"foobar.pkl\")",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result == text",
            "",
            "    def test_explicitly_set_other_model_format(self, model_card, text_skops):",
            "        model_card.add_get_started_code(model_format=\"skops\")",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        # file name is still \"my-model.pickle\", only the loading code changes",
            "        text = text_skops.replace(\".skops\", \".pickle\")",
            "        assert result == text",
            "",
            "    def test_invalid_model_format_passed(self, model_card):",
            "        # json is not a valid model format",
            "        msg = \"Invalid model format 'json', should be one of 'pickle' or 'skops'\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            model_card.add_get_started_code(model_format=\"json\")",
            "",
            "    def test_invalid_model_format_passed_via_metadata(self):",
            "        # metadata contains invalid model format json",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.skops\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"json\",",
            "                    },",
            "                }",
            "",
            "        model = fit_model()",
            "",
            "        msg = \"Invalid model format 'json', should be one of 'pickle' or 'skops'\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            Card(model, metadata=Metadata())",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_uses_default(self, template, text_pickle):",
            "        model = fit_model()",
            "",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.pickle\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"pickle\",",
            "                    },",
            "                }",
            "",
            "        model_card = Card(model, metadata=Metadata(), template=template)",
            "        model_card.add_get_started_code()",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result == text_pickle",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        text1 = model_card.select(\"How to Get Started with the Model\").format()",
            "        model_card.add_get_started_code(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").format()",
            "        assert text1 == text2",
            "",
            "",
            "class TestRender:",
            "    def test_render(self, model_card, destination_path):",
            "        file_name = destination_path / \"README.md\"",
            "        model_card.save(file_name)",
            "        with open(file_name, \"r\", encoding=\"utf-8\") as f:",
            "            loaded = f.read()",
            "",
            "        rendered = model_card.render()",
            "        assert loaded == rendered",
            "",
            "    def test_render_with_metadata(self, model_card):",
            "        model_card.metadata.foo = \"something\"",
            "        model_card.metadata.bar = \"something else\"",
            "        rendered = model_card.render()",
            "        expected = textwrap.dedent(\"\"\"",
            "            ---",
            "            foo: something",
            "            bar: something else",
            "            ---",
            "            \"\"\").strip()",
            "        assert rendered.startswith(expected)",
            "",
            "",
            "class TestSelect:",
            "    \"\"\"Selecting sections from the model card\"\"\"",
            "",
            "    def test_select_existing_section(self, model_card):",
            "        section = model_card.select(\"Model description\")",
            "        assert section.title == \"Model description\"",
            "",
            "    def test_select_existing_subsection(self, model_card):",
            "        section = model_card.select(\"Model description/Training Procedure\")",
            "        assert section.title == \"Training Procedure\"",
            "",
            "        section = model_card.select(\"Model description\").select(\"Training Procedure\")",
            "        assert section.title == \"Training Procedure\"",
            "",
            "    def test_select_existing_subsubsection(self, model_card):",
            "        section = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        )",
            "        assert section.title == \"Hyperparameters\"",
            "",
            "        section = (",
            "            model_card.select(\"Model description\")",
            "            .select(\"Training Procedure\")",
            "            .select(\"Hyperparameters\")",
            "        )",
            "        assert section.title == \"Hyperparameters\"",
            "",
            "    def test_select_non_existing_section_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"non-existing section\")",
            "",
            "    def test_select_non_existing_subsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description/non-existing subsection\")",
            "",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description\").select(\"non-existing subsection\")",
            "",
            "    def test_select_non_existing_subsubsection_raises(self, model_card):",
            "        msg = \"non-existing sub-subsection\"",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(",
            "                \"Model description/Training Procedure/non-existing sub-subsection\"",
            "            )",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            (",
            "                model_card.select(\"Model description\")",
            "                .select(\"Training Procedure\")",
            "                .select(\"non-existing sub-subsection\")",
            "            )",
            "",
            "    def test_select_non_existing_section_and_subsection_raises(self, model_card):",
            "        msg = \"non-existing section\"",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"non-existing section/non-existing subsection\")",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"non-existing section\").select(\"non-existing subsection\")",
            "",
            "    def test_select_empty_key_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got ''\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"\")",
            "",
            "    def test_select_empty_key_subsection_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got 'Model description/'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"Model description/\")",
            "",
            "        msg = r\"Section name cannot be empty but got ''\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"Model description\").select(\"\")",
            "",
            "    def test_default_skops_sections_present(self, model_card):",
            "        # model_card (which is prefilled) contains all default sections",
            "        for key in SKOPS_TEMPLATE:",
            "            model_card.select(key)",
            "",
            "    def test_default_skops_sections_empty_card(self, model_card):",
            "        # Without prefilled template, the card should not contain the default sections",
            "",
            "        # empty card does not contain any sections, so trying to select them",
            "        # should raise a KeyError",
            "        model = fit_model()",
            "        card_empty = Card(model, model_diagram=False, template=None)",
            "        for key in SKOPS_TEMPLATE:",
            "            with pytest.raises(KeyError):",
            "                card_empty.select(key)",
            "",
            "    def test_invalid_template_name_raises(self):",
            "        msg = \"Unknown template 'does-not-exist', template must be one of the following\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            Card(model=None, template=\"does-not-exist\")",
            "",
            "",
            "class TestAdd:",
            "    \"\"\"Adding sections and subsections\"\"\"",
            "",
            "    @pytest.mark.parametrize(\"folded\", [True, False])",
            "    def test_add_new_section(self, model_card, folded):",
            "        model_card = model_card.add(**{\"A new section\": \"sklearn FTW\"}, folded=folded)",
            "        section = model_card.select(\"A new section\")",
            "        assert section.title == \"A new section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "        output = section.format()",
            "        if folded:",
            "            assert \"<details>\" in output",
            "        else:",
            "            assert \"<details>\" not in output",
            "",
            "    def test_add_new_subsection(self, model_card):",
            "        model_card = model_card.add(",
            "            **{\"Model description/A new section\": \"sklearn FTW\"}",
            "        )",
            "        section = model_card.select(\"Model description/A new section\")",
            "        assert section.title == \"A new section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "        # make sure that the new subsection is the last subsection",
            "        subsections = model_card._data[\"Model description\"].subsections",
            "        assert len(subsections) > 1  # exclude trivial case of only one subsection",
            "",
            "        last_subsection = list(subsections.values())[-1]",
            "        assert last_subsection is section",
            "",
            "    def test_add_new_section_and_subsection(self, model_card):",
            "        model_card = model_card.add(**{\"A new section/A new subsection\": \"sklearn FTW\"})",
            "",
            "        section = model_card.select(\"A new section\")",
            "        assert section.title == \"A new section\"",
            "        assert section.content == \"\"",
            "",
            "        subsection = model_card.select(\"A new section/A new subsection\")",
            "        assert subsection.title == \"A new subsection\"",
            "        assert subsection.content == \"sklearn FTW\"",
            "",
            "    def test_add_new_section_with_slash_in_name(self, model_card):",
            "        model_card = model_card.add(**{\"A new\\\\/section\": \"sklearn FTW\"})",
            "        section = model_card.select(\"A new\\\\/section\")",
            "        assert section.title == \"A new/section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "    def test_add_new_subsection_with_slash_in_name(self, model_card):",
            "        model_card = model_card.add(",
            "            **{\"Model description/A new\\\\/section\": \"sklearn FTW\"}",
            "        )",
            "        section = model_card.select(\"Model description/A new\\\\/section\")",
            "        assert section.title == \"A new/section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "    def test_add_content_to_existing_section(self, model_card):",
            "        # Add content (not new sections) to an existing section. Make sure that",
            "        # existing subsections are not affected by this",
            "        section = model_card.select(\"Model description\")",
            "        num_subsection_before = len(section.subsections)",
            "        assert num_subsection_before > 0  # exclude trivial case of empty sections",
            "",
            "        # add content to \"Model description\" section",
            "        model_card = model_card.add(**{\"Model description\": \"sklearn FTW\"})",
            "        section = model_card.select(\"Model description\")",
            "        num_subsection_after = len(section.subsections)",
            "",
            "        assert num_subsection_before == num_subsection_after",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "    def test_add_plain_section_works(self, model_card):",
            "        # It is allowed to add a *Section object, but it's not documented and",
            "        # users should normally not use that feature",
            "        section = Section(\"title may differ from section name\", \"some content\")",
            "        model_card.add(",
            "            a_string=\"normal string\",",
            "            a_section=section,",
            "        )",
            "        assert model_card.select(\"a_section\") == section",
            "",
            "    def test_add_section_preserves_subsections(self, model_card):",
            "        # As explained in the previous test, users can theoretically add section",
            "        # instances. If they override an existing section with a new section,",
            "        # the subsections of the existing section should be preserved.",
            "",
            "        # first let's add a section and a subsection",
            "        model_card.add(**{\"new section\": \"hello\", \"new section/subsection\": \"world\"})",
            "        assert model_card.select(\"new section\").format() == \"hello\"",
            "        assert model_card.select(\"new section/subsection\").format() == \"world\"",
            "",
            "        # now let's override the section, the subsection should be preserved",
            "        new_section = Section(\"new section\", \"bonjour\")",
            "        model_card.add(**{\"new section\": new_section})",
            "        assert model_card.select(\"new section\").format() == \"bonjour\"",
            "        assert model_card.select(\"new section/subsection\").format() == \"world\"",
            "",
            "    def test_add_section_with_identical_subsection_preserves_subsections(",
            "        self, model_card",
            "    ):",
            "        # As explained in the previous tests, users can theoretically add",
            "        # section instances. If they override an existing section with a new",
            "        # section, the subsections of the existing section should be preserved.",
            "        # If the new section they add has its own subsections, and these",
            "        # subsections are identical to the old subsections, that should be fine.",
            "",
            "        # first let's add a section and a subsection",
            "        model_card.add(**{\"new section\": \"hello\", \"new section/subsection\": \"world\"})",
            "",
            "        # now let's override the section using the same subsections",
            "        old_subsection = model_card.select(\"new section\").subsections",
            "        new_section = Section(\"new section\", \"bonjour\", subsections=old_subsection)",
            "        model_card.add(**{\"new section\": new_section})",
            "        assert model_card.select(\"new section\").format() == \"bonjour\"",
            "        assert model_card.select(\"new section/subsection\").format() == \"world\"",
            "",
            "    def test_add_section_with_different_subsection_raises(self, model_card):",
            "        # This is the same as the previous test, but now the section used to",
            "        # override the previous section has different subsections. Now we don't",
            "        # know what to do and should raise. This is okay because normally, a",
            "        # user shouldn't add section instances anyway.",
            "",
            "        # first let's add a section and a subsection",
            "        model_card.add(**{\"new section\": \"hello\", \"new section/subsection\": \"world\"})",
            "",
            "        # now let's override the section using different subsections",
            "        new_subsection = {\"new subsection\": Section(\"subsection\", \"mars\")}",
            "        new_section = Section(\"new section\", \"bonjour\", subsections=new_subsection)",
            "",
            "        match = (",
            "            \"Trying to override section 'new section' but found conflicting subsections\"",
            "        )",
            "        with pytest.raises(ValueError, match=match):",
            "            model_card.add(**{\"new section\": new_section})",
            "",
            "",
            "class TestDelete:",
            "    \"\"\"Deleting sections and subsections\"\"\"",
            "",
            "    def test_delete_section(self, model_card):",
            "        model_card.select(\"Model description\")",
            "        model_card.delete(\"Model description\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description\")",
            "",
            "    def test_delete_subsection(self, model_card):",
            "        model_card.select(\"Model description/Training Procedure\")",
            "        model_card.delete(\"Model description/Training Procedure\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description/Training Procedure\")",
            "        # parent section still exists",
            "        model_card.delete(\"Model description\")",
            "",
            "    def test_delete_subsubsection(self, model_card):",
            "        model_card.select(\"Model description/Training Procedure/Hyperparameters\")",
            "        model_card.delete(\"Model description/Training Procedure/Hyperparameters\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description/Training Procedure/Hyperparameters\")",
            "        # parent section still exists",
            "        model_card.delete(\"Model description/Training Procedure\")",
            "",
            "    def test_delete_section_with_slash_in_name(self, model_card):",
            "        model_card.add(**{\"A new\\\\/section\": \"some content\"})",
            "        model_card.select(\"A new\\\\/section\")",
            "        model_card.delete(\"A new\\\\/section\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"A new\\\\/section\")",
            "",
            "    def test_delete_non_existing_section_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(\"non-existing section\")",
            "",
            "    def test_delete_non_existing_subsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(\"Model description/non-existing subsection\")",
            "",
            "        with pytest.raises(KeyError):",
            "            model_card.delete([\"Model description\", \"non-existing subsection\"])",
            "",
            "    def test_delete_non_existing_subsubsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(",
            "                \"Model description/Training Procedure/non-existing sub-subsection\"",
            "            )",
            "",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(",
            "                [",
            "                    \"Model description\",",
            "                    \"Training Procedure\",",
            "                    \"non-existing sub-subsection\",",
            "                ]",
            "            )",
            "",
            "    def test_delete_non_existing_section_and_subsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete([\"non-existing section\", \"non-existing subsection\"])",
            "",
            "    def test_delete_empty_key_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got ''\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete(\"\")",
            "",
            "        msg = r\"Section name cannot be empty but got '\\[\\]'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete([])",
            "",
            "    def test_delete_empty_key_subsection_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got 'Model description/'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete(\"Model description/\")",
            "",
            "        msg = r\"Section name cannot be empty but got '\\['Model description', ''\\]'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete([\"Model description\", \"\"])",
            "",
            "",
            "class TestAddPlot:",
            "    def test_add_plot(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(fig1=\"fig1.png\")",
            "        plot_content = model_card.select(\"fig1\").format()",
            "        assert plot_content == \"![fig1](fig1.png)\"",
            "",
            "    def test_add_plot_to_existing_section(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(**{\"Model description/Figure 1\": \"fig1.png\"})",
            "        plot_content = model_card.select(\"Model description/Figure 1\").format()",
            "        assert plot_content == \"![Figure 1](fig1.png)\"",
            "",
            "    def test_add_plot_with_description(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(description=\"My fancy plot\", fig1=\"fig1.png\")",
            "        plot_content = model_card.select(\"fig1\").format()",
            "        assert plot_content == \"My fancy plot\\n\\n![fig1](fig1.png)\"",
            "",
            "    def test_add_plot_with_alt_text(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(alt_text=\"the figure\", fig1=\"fig1.png\")",
            "        plot_content = model_card.select(\"fig1\").format()",
            "        assert plot_content == \"![the figure](fig1.png)\"",
            "",
            "",
            "class TestMetadata:",
            "    def test_adding_metadata(self, model_card):",
            "        # test if the metadata is added to the card",
            "        model_card.metadata.tags = \"dummy\"",
            "        metadata = list(model_card._generate_metadata(model_card.metadata))",
            "        assert len(metadata) == 1",
            "        assert metadata[0] == \"metadata.tags=dummy,\"",
            "",
            "    def test_metadata_from_config_tabular_data(",
            "        self, pkl_model_card_metadata_from_config, destination_path",
            "    ):",
            "        # test if widget data is correctly set in the README",
            "        metadata = metadata_load(local_path=Path(destination_path) / \"README.md\")",
            "        assert \"widget\" in metadata",
            "",
            "        expected_data = [",
            "            {",
            "                \"structuredData\": {",
            "                    \"petal length (cm)\": [1.4, 1.4, 1.3],",
            "                    \"petal width (cm)\": [0.2, 0.2, 0.2],",
            "                    \"sepal length (cm)\": [5.1, 4.9, 4.7],",
            "                    \"sepal width (cm)\": [3.5, 3.0, 3.2],",
            "                }",
            "            },",
            "        ]",
            "        assert metadata[\"widget\"] == expected_data",
            "",
            "        for tag in [\"sklearn\", \"skops\", \"tabular-classification\"]:",
            "            assert tag in metadata[\"tags\"]",
            "",
            "    def test_metadata_model_format_pkl(",
            "        self, pkl_model_card_metadata_from_config, destination_path",
            "    ):",
            "        metadata = metadata_load(local_path=Path(destination_path) / \"README.md\")",
            "        assert metadata[\"model_format\"] == \"pickle\"",
            "",
            "    def test_metadata_model_format_skops(",
            "        self, skops_model_card_metadata_from_config, destination_path",
            "    ):",
            "        metadata = metadata_load(local_path=Path(destination_path) / \"README.md\")",
            "        assert metadata[\"model_format\"] == \"skops\"",
            "",
            "",
            "@pytest.mark.xfail(reason=\"dynamic adjustment when model changes not implemented yet\")",
            "class TestModelDynamicUpdate:",
            "    def test_model_related_sections_updated_dynamically_skops_template(",
            "        self, model_card",
            "    ):",
            "        # Change the model to be a KNN classifier and check that the sections",
            "        # related to the model, the plot and hyperparams, are updated correctly.",
            "        # But first, as a sanity check, ensure that before the change, there is",
            "        # no reference to KNN.",
            "        model_plot_before = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        )",
            "        assert \"KNeighborsClassifier\" not in model_plot_before.content",
            "",
            "        hyperparams_before = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        )",
            "        assert \"n_neighbors\" not in hyperparams_before.content.format()",
            "",
            "        # change model to KNN",
            "        model_after = KNeighborsClassifier()",
            "        model_card.model = model_after",
            "",
            "        model_plot_after = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).content",
            "        assert \"KNeighborsClassifier\" in model_plot_after",
            "",
            "        hyperparams_after = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        )",
            "        assert \"n_neighbors\" in hyperparams_after.content.format()",
            "",
            "    def test_model_related_sections_updated_dynamically_custom_template(",
            "        self, model_card",
            "    ):",
            "        # same as previous test but using a custom template",
            "        template = {\"My model plot\": \"\"}",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "",
            "        # add model plot and hyperparams -- section must be passed but it",
            "        # doesn't need to already exist in the custom template",
            "        model_card.add_model_plot(section=\"My model plot\")",
            "        model_card.add_hyperparams(section=\"My hyperparams\")",
            "",
            "        model_plot_before = model_card.select(\"My model plot\")",
            "        assert \"KNeighborsClassifier\" not in model_plot_before.content",
            "",
            "        hyperparams_before = model_card.select(\"My hyperparams\")",
            "        assert \"n_neighbors\" not in hyperparams_before.content.format()",
            "",
            "        # change model to KNN",
            "        model_after = KNeighborsClassifier()",
            "        model_card.model = model_after",
            "",
            "        model_plot_after = model_card.select(\"My model plot\")",
            "        assert \"KNeighborsClassifier\" in model_plot_after.content",
            "",
            "        hyperparams_after = model_card.select(\"My hyperparams\")",
            "        assert \"n_neighbors\" in hyperparams_after.content.format()",
            "",
            "",
            "class TestCardRepr:",
            "    \"\"\"Test __str__ and __repr__ methods of Card, which are identical for now\"\"\"",
            "",
            "    @pytest.fixture",
            "    def card(self):",
            "        model = LinearRegression(fit_intercept=False)",
            "        card = Card(model=model)",
            "        card.add(Figures=\"\")",
            "        card.add(",
            "            **{",
            "                \"Model Description\": \"A description\",",
            "                \"Model Card Authors\": \"Jane Doe\",",
            "            }",
            "        )",
            "        card.add_plot(",
            "            **{",
            "                \"Figures/ROC\": \"ROC.png\",",
            "                \"Figures/Confusion matrix\": \"confusion_matrix.jpg\",",
            "            }",
            "        )",
            "        card.add_table(**{\"Search Results\": {\"split\": [1, 2, 3], \"score\": [4, 5, 6]}})",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def expected_lines(self):",
            "        card_repr = \"\"\"",
            "        Card(",
            "          model=LinearRegression(fit_intercept=False),",
            "          Model description/Training Procedure/Hyperparameters=TableSection(4x2),",
            "          Model description/Training Procedure/...</div>,",
            "          Model Card Authors=Jane Doe,",
            "          Figures/ROC=PlotSection(ROC.png),",
            "          Figures/Confusion matrix=PlotSection(confusion_matrix.jpg),",
            "          Model Description=A description,",
            "          Search Results=TableSection(3x2),",
            "        )",
            "        \"\"\"",
            "        expected = textwrap.dedent(card_repr).strip()",
            "        lines = expected.split(\"\\n\")",
            "        return lines",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_card_repr(self, card: Card, meth, expected_lines):",
            "        result = meth(card)",
            "        expected = \"\\n\".join(expected_lines)",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "        assert re.match(expected, result)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_card_repr_empty_card(self, meth):",
            "        \"\"\"Without prefilled template, the repr should be empty\"\"\"",
            "        model = fit_model()",
            "        card = Card(model, model_diagram=False, template=None)",
            "        result = meth(card)",
            "        expected = textwrap.dedent(\"\"\"",
            "        Card(",
            "          model=LinearRegression(),",
            "        )",
            "        \"\"\").strip()",
            "        assert result == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_very_long_lines_are_shortened(self, card: Card, meth, expected_lines):",
            "        card.add(my_section=\"very long line \" * 100)",
            "",
            "        # expected results contain 1 line at the very end",
            "        extra_line = (",
            "            \"  my_section=very long line very long l... \"",
            "            \"line very long line very long line ,\"",
            "        )",
            "        expected_lines.insert(-1, extra_line)",
            "        expected = \"\\n\".join(expected_lines)",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "",
            "        result = meth(card)",
            "        assert re.match(expected, result)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_without_model_attribute(self, card: Card, meth, expected_lines):",
            "        del card.model",
            "",
            "        # remove line 1 from expected results, which corresponds to the model",
            "        del expected_lines[1]",
            "        expected = \"\\n\".join(expected_lines)",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "",
            "        result = meth(card)",
            "        assert re.match(expected, result)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_with_metadata(self, card: Card, meth, expected_lines):",
            "        metadata = ModelCardData(",
            "            language=\"fr\",",
            "            license=\"bsd\",",
            "            library_name=\"sklearn\",",
            "            tags=[\"sklearn\", \"tabular-classification\"],",
            "            foo={\"bar\": 123},",
            "            widget=[{\"something\": \"very-long\"}],",
            "        )",
            "        card.metadata = metadata",
            "",
            "        # metadata comes after model line, i.e. position 2",
            "        extra_lines = [",
            "            \"  metadata.language=fr,\",",
            "            \"  metadata.license=bsd,\",",
            "            \"  metadata.library_name=sklearn,\",",
            "            \"  metadata.tags=['sklearn', 'tabular-classification'],\",",
            "            \"  metadata.foo={'bar': 123},\",",
            "            \"  metadata.widget=[{...}],\",",
            "        ]",
            "        expected = \"\\n\".join(expected_lines[:2] + extra_lines + expected_lines[2:])",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "        result = meth(card)",
            "",
            "        assert re.match(expected, result)",
            "",
            "",
            "class TestCardModelAttributeIsPath:",
            "    def path_to_card(self, path):",
            "        card = Card(model=path, trusted=True)",
            "        return card",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    @pytest.mark.parametrize(\"suffix\", [\".pkl\", \".skops\"])",
            "    def test_model_card_repr(self, meth, suffix):",
            "        # Test that if the model is changed, Card takes this into account, if",
            "        # the model argument is a path to a model file. First, we test that if",
            "        # the model path changes, the Card changes. Then we test that if the",
            "        # file on disk changes, the Card changes.",
            "        model = LinearRegression(fit_intercept=False)",
            "        file_handle, file_name = save_model_to_file(model, suffix)",
            "        os.close(file_handle)",
            "        card_from_path = self.path_to_card(file_name)",
            "",
            "        result0 = meth(card_from_path)",
            "        expected = \"Card(\\n  model=LinearRegression(fit_intercept=False),\"",
            "        assert result0.startswith(expected)",
            "",
            "        # change file name, same card should show different result",
            "        model = LinearRegression()",
            "        file_handle, file_name = save_model_to_file(model, suffix)",
            "        card_from_path.model = file_name",
            "        result1 = meth(card_from_path)",
            "        expected = \"Card(\\n  model=LinearRegression(),\"",
            "        assert result1.startswith(expected)",
            "",
            "        # change model on disk but keep same file name, should show different",
            "        # result",
            "        model = LinearRegression(fit_intercept=None)",
            "        with open(file_name, \"wb\") as f:",
            "            dump_fn = pickle.dump if suffix == \".pkl\" else dump",
            "            dump_fn(model, f)",
            "        result2 = meth(card_from_path)",
            "        expected = \"Card(\\n  model=LinearRegression(fit_intercept=None),\"",
            "        assert result2.startswith(expected)",
            "",
            "    @pytest.mark.parametrize(\"suffix\", [\".pkl\", \".skops\"])",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_load_model_exception(self, meth, suffix):",
            "        file_handle, file_name = tempfile.mkstemp(suffix=suffix, prefix=\"skops-test\")",
            "",
            "        os.close(file_handle)",
            "",
            "        with pytest.raises(Exception, match=\"occurred during model loading.\"):",
            "            card = Card(file_name)",
            "            meth(card)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_load_model_file_not_found(self, meth):",
            "        file_handle, file_name = tempfile.mkstemp(suffix=\".pkl\", prefix=\"skops-test\")",
            "",
            "        os.close(file_handle)",
            "        os.remove(file_name)",
            "",
            "        with pytest.raises(FileNotFoundError) as excinfo:",
            "            card = Card(file_name)",
            "            meth(card)",
            "",
            "        assert file_name in str(excinfo.value)",
            "",
            "",
            "class TestPlotSection:",
            "    def test_format_path_is_str(self):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=\"path/plot.png\"",
            "        )",
            "        expected = \"![some title](path/plot.png)\"",
            "        assert section.format() == expected",
            "",
            "    def test_format_path_is_pathlib(self):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=Path(\"path\") / \"plot.png\"",
            "        )",
            "        expected = f\"![some title](path{os.path.sep}plot.png)\"",
            "        assert section.format() == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [str, repr])",
            "    def test_str_and_repr(self, meth):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=\"path/plot.png\"",
            "        )",
            "        expected = \"PlotSection(path/plot.png)\"",
            "        assert meth(section) == expected",
            "",
            "    def test_str(self):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=\"path/plot.png\"",
            "        )",
            "        expected = \"PlotSection(path/plot.png)\"",
            "        assert str(section) == expected",
            "",
            "    @pytest.mark.parametrize(\"folded\", [True, False])",
            "    def test_folded(self, folded):",
            "        section = PlotSection(",
            "            title=\"\",",
            "            content=\"\",",
            "            alt_text=\"some title\",",
            "            path=\"path/plot.png\",",
            "            folded=folded,",
            "        )",
            "        output = section.format()",
            "        if folded:",
            "            assert \"<details>\" in output",
            "        else:",
            "            assert \"<details>\" not in output",
            "",
            "    def test_add_with_description(self):",
            "        # FIXME",
            "        pass",
            "",
            "",
            "class TestTableSection:",
            "    @pytest.fixture",
            "    def table_dict(self):",
            "        return {\"split\": [1, 2, 3], \"score\": [4, 5, 6]}",
            "",
            "    def test_table_is_dict(self, table_dict):",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        expected = \"\"\"|   split |   score |",
            "|---------|---------|",
            "|       1 |       4 |",
            "|       2 |       5 |",
            "|       3 |       6 |\"\"\"",
            "        assert section.format() == expected",
            "",
            "    def test_table_is_dataframe(self, table_dict):",
            "        pd = pytest.importorskip(\"pandas\")",
            "        df = pd.DataFrame(table_dict)",
            "        section = TableSection(title=\"\", content=\"\", table=df)",
            "        expected = \"\"\"|   split |   score |",
            "|---------|---------|",
            "|       1 |       4 |",
            "|       2 |       5 |",
            "|       3 |       6 |\"\"\"",
            "        assert section.format() == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [str, repr])",
            "    def test_str_and_repr_table_is_dict(self, table_dict, meth):",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        expected = \"TableSection(3x2)\"",
            "        assert meth(section) == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [str, repr])",
            "    def test_str_and_repr_table_is_dataframe(self, table_dict, meth):",
            "        pd = pytest.importorskip(\"pandas\")",
            "        df = pd.DataFrame(table_dict)",
            "        section = TableSection(title=\"\", content=\"\", table=df)",
            "        expected = \"TableSection(3x2)\"",
            "        assert meth(section) == expected",
            "",
            "    @pytest.mark.parametrize(\"table\", [{}, \"pandas\"])",
            "    def test_raise_error_empty_table(self, table):",
            "        # If there are no columns, raise",
            "        if table == \"pandas\":",
            "            pd = pytest.importorskip(\"pandas\")",
            "            table = pd.DataFrame([])",
            "",
            "        msg = \"Trying to add table with no columns\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            TableSection(title=\"\", content=\"\", table=table)",
            "",
            "    @pytest.mark.parametrize(\"table\", [{\"col0\": []}, \"pandas\"])",
            "    def test_table_with_no_rows_works(self, table):",
            "        # If there are no rows, it's okay",
            "        if table == \"pandas\":",
            "            pd = pytest.importorskip(\"pandas\")",
            "            table = pd.DataFrame(data=[], columns=[\"col0\"])",
            "",
            "        TableSection(title=\"\", content=\"\", table=table).format()  # no error raised",
            "",
            "    def test_pandas_not_installed(self, table_dict, pandas_not_installed):",
            "        # use pandas_not_installed fixture from conftest.py to pretend that",
            "        # pandas is not installed",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        assert section._is_pandas_df is False",
            "",
            "    @pytest.mark.parametrize(\"folded\", [True, False])",
            "    def test_folded(self, table_dict, folded):",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict, folded=folded)",
            "        output = section.format()",
            "        if folded:",
            "            assert \"<details>\" in output",
            "        else:",
            "            assert \"<details>\" not in output",
            "",
            "    def test_line_break_in_entry(self, table_dict):",
            "        # Line breaks are not allowed inside markdown tables, so check that",
            "        # they're removed. We test 3 conditions here:",
            "",
            "        # 1. custom object with line breaks in repr",
            "        # 2. string with line break in the middle",
            "        # 3. string with line break at start, middle, and end",
            "",
            "        # Note that for the latter, tabulate will automatically strip the line",
            "        # breaks from the start and end.",
            "        class LineBreakInRepr:",
            "            \"\"\"Custom object whose repr has a line break\"\"\"",
            "",
            "            def __repr__(self) -> str:",
            "                return \"obj\\nwith lb\"",
            "",
            "        table_dict[\"with break\"] = [",
            "            LineBreakInRepr(),",
            "            \"hi\\nthere\",",
            "            \"\"\"",
            "entry with",
            "line breaks",
            "\"\"\",",
            "        ]",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        expected = \"\"\"| split | score | with break |",
            "|-|-|-|",
            "| 1 | 4 | obj<br />with lb |",
            "| 2 | 5 | hi<br />there |",
            "| 3 | 6 | entry with<br />line breaks |\"\"\"",
            "",
            "        result = section.format()",
            "        # remove multiple whitespaces and dashes, as they're not important",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_add_table_with_description(self, model_card, table_dict):",
            "        model_card.add_table(description=\"My fancy table\", **{\"The table\": table_dict})",
            "        section = model_card.select(\"The table\")",
            "        content = section.format()",
            "        expected = \"\"\"My fancy table",
            "",
            "|   split |   score |",
            "|---------|---------|",
            "|       1 |       4 |",
            "|       2 |       5 |",
            "|       3 |       6 |\"\"\"",
            "        assert content == expected",
            "",
            "",
            "class TestCustomTemplate:",
            "    @pytest.fixture",
            "    def template(self):",
            "        return {",
            "            \"My description\": \"An awesome model\",",
            "            \"Model\": \"Here goes model related stuff\",",
            "            \"Model/Metrics\": \"\",",
            "            \"Foo/Bar\": \"Baz\",",
            "        }",
            "",
            "    @pytest.fixture",
            "    def card(self, template):",
            "        model = fit_model()",
            "        card = Card(model, template=template)",
            "        return card",
            "",
            "    def test_add_model_plot(self, card):",
            "        card.add_model_plot(section=\"Model/Model plot\")",
            "        content = card.select(\"Model/Model plot\").format()",
            "        assert \"LinearRegression\" in content",
            "",
            "    def test_add_hyperparams(self, card):",
            "        card.add_hyperparams(section=\"Model/Hyperparams\")",
            "        content = card.select(\"Model/Hyperparams\").format()",
            "        assert \"fit_intercept\" in content",
            "",
            "    def test_add_metrics(self, card):",
            "        card.add_metrics(accuracy=0.1, section=\"Model/Metrics\")",
            "        content = card.select(\"Model/Metrics\").format()",
            "        assert \"accuracy\" in content",
            "        assert \"0.1\" in content",
            "",
            "    def test_add_get_started_code(self, card):",
            "        card.add_get_started_code(",
            "            section=\"Getting Started\",",
            "            file_name=\"foobar.skops\",",
            "            model_format=\"skops\",",
            "        )",
            "        content = card.select(\"Getting Started\").content",
            "        assert \"load\" in content",
            "",
            "    def test_custom_template_all_sections_present(self, template, card):",
            "        # model_card contains all default sections",
            "        for key in template:",
            "            card.select(key)",
            "",
            "        # no other top level sections as those defined in the template",
            "        expected = [\"My description\", \"Model\", \"Foo\"]",
            "        assert list(card._data.keys()) == expected",
            "",
            "",
            "class TestRenderedCardVisibility:",
            "    \"\"\"Check that visibility flag works",
            "",
            "    Sections that are not visible should not be rendered, neither when calling",
            "    model_card.render, nor when calling model_card.save.",
            "",
            "    \"\"\"",
            "",
            "    @pytest.fixture",
            "    def template(self):",
            "        return {",
            "            \"Model\": \"Here goes model related stuff\",",
            "            \"Model/Metrics\": \"123\",",
            "            \"Model/Bar\": \"Baz\",",
            "            \"Authors\": \"Jane Doe\",",
            "        }",
            "",
            "    @pytest.fixture",
            "    def card(self, template):",
            "        model = fit_model()",
            "        card = Card(model, template=template)",
            "        return card",
            "",
            "    def test_all_visible_by_default(self, card):",
            "        rendered = card.render()",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Metrics\\n\\n\"",
            "            \"123\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        assert rendered.strip() == expected",
            "",
            "    def test_section_invisible(self, card):",
            "        card.select(\"Model/Metrics\").visible = False",
            "        rendered = card.render()",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        assert rendered.strip() == expected",
            "",
            "    def test_restoring_visibility_works(self, card):",
            "        card.select(\"Model/Metrics\").visible = False",
            "        card.select(\"Model/Metrics\").visible = True",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Metrics\\n\\n\"",
            "            \"123\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        rendered = card.render()",
            "        assert rendered.strip() == expected",
            "",
            "    def test_invisible_parent_section_hides_subsections(self, card):",
            "        # By making the parent section \"Model\" invisible, all of the subsections",
            "        # are also turned invisible",
            "        card.select(\"Model\").visible = False",
            "        # fmt: off",
            "        expected = (",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        # fmt: on",
            "        rendered = card.render()",
            "        assert rendered.strip() == expected",
            "",
            "    def test_visibility_with_card_save(self, card):",
            "        # Since .save and .render share the same functionality, it's not",
            "        # necessary to repeat all the tests above with .save. Just do one test",
            "        # to ensure that the same functionality is indeed being used.",
            "        file = tempfile.mkstemp(suffix=\".md\", prefix=\"skops-model-card\")[1]",
            "        card.select(\"Model/Metrics\").visible = False",
            "        card.save(file)",
            "",
            "        with open(file, \"r\") as f:",
            "            loaded = f.read()",
            "",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        assert loaded.strip() == expected",
            "",
            "",
            "class TestAddFairlearnMetricFrame:",
            "    @pytest.fixture",
            "    def card(self):",
            "        model = LinearRegression()",
            "        card = Card(model=model)",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def metric_frame(self):",
            "        metrics = import_or_raise(",
            "            \"fairlearn.metrics\", \"model card fairlearn metricframe\"",
            "        )",
            "",
            "        y_true = [1, 1, 1, 1, 1, 0, 0, 1, 1, 0]",
            "        y_pred = [0, 1, 1, 1, 1, 0, 0, 0, 1, 1]",
            "        sex = [\"Female\"] * 5 + [\"Male\"] * 5",
            "        metric_dict = {\"selection_rate\": metrics.selection_rate}",
            "        metric_frame = metrics.MetricFrame(",
            "            y_true=y_true, y_pred=y_pred, sensitive_features=sex, metrics=metric_dict",
            "        )",
            "        return metric_frame",
            "",
            "    @pytest.mark.parametrize(\"transpose\", [True, False])",
            "    def test_metric_table(self, card: Card, transpose, metric_frame):",
            "        card.add_fairlearn_metric_frame(",
            "            metric_frame=metric_frame,",
            "            transpose=transpose,",
            "            table_name=\"Metric Frame Table\",",
            "        )",
            "",
            "        actual_table = card.select(\"Metric Frame Table\").format()",
            "",
            "        if transpose is True:",
            "            expected_table = (",
            "                \"<details>\\n<summary> Click to expand </summary>\\n\\n|   selection_rate\"",
            "                \" |\\n|------------------|\\n|              0.4 |\\n|              0.8\"",
            "                \" |\\n|              0.4 |\\n|              0.5 |\\n\\n</details>\"",
            "            )",
            "        else:",
            "            expected_table = (",
            "                \"<details>\\n<summary> Click to expand </summary>\\n\\n|   difference |  \"",
            "                \" group_max |   group_min |   ratio\"",
            "                \" |\\n|--------------|-------------|-------------|---------|\\n|         \"",
            "                \" 0.4 |         0.8 |         0.4 |     0.5 |\\n\\n</details>\"",
            "            )",
            "",
            "        assert expected_table == actual_table",
            "",
            "    def test_metric_table_with_description(self, card: Card, metric_frame):",
            "        card.add_fairlearn_metric_frame(",
            "            description=\"An awesome table\",",
            "            metric_frame=metric_frame,",
            "            table_name=\"Metric Frame Table\",",
            "        )",
            "",
            "        actual_table = card.select(\"Metric Frame Table\").format()",
            "        expected_table = (",
            "            \"An awesome table\\n\\n\"",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\n|   selection_rate\"",
            "            \" |\\n|------------------|\\n|              0.4 |\\n|              0.8\"",
            "            \" |\\n|              0.4 |\\n|              0.5 |\\n\\n</details>\"",
            "        )",
            "        assert expected_table == actual_table",
            "",
            "",
            "class TestCardTableOfContents:",
            "    @pytest.fixture",
            "    def card(self):",
            "        model = LinearRegression()",
            "        card = Card(model=model)",
            "        card.add_model_plot()",
            "        card.add_hyperparams()",
            "        card.add_metrics(accuracy=0.1)",
            "        card.add_get_started_code()",
            "        return card",
            "",
            "    def test_toc(self, card):",
            "        toc = card.get_toc()",
            "        exptected_toc = [",
            "            \"- Model description\",",
            "            \"  - Intended uses & limitations\",",
            "            \"  - Training Procedure\",",
            "            \"    - Hyperparameters\",",
            "            \"    - Model Plot\",",
            "            \"  - Evaluation Results\",",
            "            \"- How to Get Started with the Model\",",
            "            \"- Model Card Authors\",",
            "            \"- Model Card Contact\",",
            "            \"- Citation\",",
            "        ]",
            "",
            "        assert toc == \"\\n\".join(exptected_toc)",
            "",
            "    def test_toc_with_invisible_section(self, card):",
            "        section = card.select(\"Citation\")",
            "        section.visible = False",
            "        toc = card.get_toc()",
            "        exptected_toc = [",
            "            \"- Model description\",",
            "            \"  - Intended uses & limitations\",",
            "            \"  - Training Procedure\",",
            "            \"    - Hyperparameters\",",
            "            \"    - Model Plot\",",
            "            \"  - Evaluation Results\",",
            "            \"- How to Get Started with the Model\",",
            "            \"- Model Card Authors\",",
            "            \"- Model Card Contact\",",
            "        ]",
            "",
            "        assert toc == \"\\n\".join(exptected_toc)",
            "",
            "",
            "class TestFoldedSection:",
            "    def test_folded_section(self, destination_path, model_card):",
            "        model_card.add(foo=\"Foo\")",
            "        model_card.add(**{\"foo/bar\": \"Foo/Bar\", \"foo/baz\": \"Foo/Baz\"})",
            "        model_card.select(\"foo/baz\").folded = True",
            "",
            "        foo_details = (",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\nFoo\\n\\n</details>\\n\"",
            "        )",
            "        foo_bar_details = (",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\nFoo/Bar\\n\\n</details>\\n\"",
            "        )",
            "        foo_baz_details = (",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\nFoo/Baz\\n\\n</details>\\n\"",
            "        )",
            "",
            "        output = model_card.render()",
            "        assert foo_details not in output",
            "        assert foo_bar_details not in output",
            "        assert foo_baz_details in output",
            "",
            "        model_card.select(\"foo\").folded = True",
            "",
            "        output = model_card.render()",
            "        assert foo_details in output",
            "        assert foo_bar_details not in output",
            "        assert foo_baz_details not in output",
            "",
            "        model_card.select(\"foo\").folded = False",
            "",
            "        output = model_card.render()",
            "        assert foo_details not in output",
            "        assert foo_bar_details not in output",
            "        assert foo_baz_details in output",
            "",
            "        model_card.select(\"foo/bar\").folded = True",
            "        model_card.select(\"foo/baz\").folded = False",
            "",
            "        output = model_card.render()",
            "        assert foo_details not in output",
            "        assert foo_bar_details in output",
            "        assert foo_baz_details not in output",
            "",
            "",
            "class TestCardSaveWithPlots:",
            "    def test_copy_plots(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        with tempfile.TemporaryDirectory(prefix=\"skops-test-plots\") as plot_path:",
            "            plt.plot([4, 5, 6, 7])",
            "            fig_1_path = Path(plot_path) / \"fig1.png\"",
            "            plt.savefig(fig_1_path)",
            "            model_card = model_card.add_plot(fig1=fig_1_path)",
            "",
            "            plt.plot([7, 6, 5, 4])",
            "            fig_2_path = \"fig2.png\"",
            "            plt.savefig(fig_2_path)",
            "            model_card = model_card.add_plot(fig2=fig_2_path)",
            "",
            "            model_card.save(Path(destination_path) / \"README.md\", copy_files=True)",
            "",
            "        assert (Path(destination_path) / \"README.md\").exists()",
            "        assert (Path(destination_path) / \"fig1.png\").exists()",
            "        assert (Path(destination_path) / \"fig2.png\").exists()"
        ],
        "afterPatchFile": [
            "import os",
            "import pickle",
            "import re",
            "import tempfile",
            "import textwrap",
            "from pathlib import Path",
            "from unittest import mock",
            "",
            "import numpy as np",
            "import pytest",
            "import sklearn",
            "from huggingface_hub import ModelCardData, metadata_load",
            "from sklearn.datasets import load_iris",
            "from sklearn.inspection import permutation_importance",
            "from sklearn.linear_model import LinearRegression, LogisticRegression",
            "from sklearn.metrics import f1_score, make_scorer",
            "from sklearn.neighbors import KNeighborsClassifier",
            "",
            "from skops import hub_utils",
            "from skops.card import Card, metadata_from_config",
            "from skops.card._model_card import (",
            "    CONTENT_PLACEHOLDER,",
            "    SKOPS_TEMPLATE,",
            "    PlotSection,",
            "    Section,",
            "    TableSection,",
            "    _load_model,",
            ")",
            "from skops.io import dump, get_untrusted_types, load",
            "from skops.utils.importutils import import_or_raise",
            "",
            "",
            "def fit_model():",
            "    X = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])",
            "    y = np.dot(X, np.array([1, 2])) + 3",
            "    reg = LinearRegression().fit(X, y)",
            "    return reg",
            "",
            "",
            "def save_model_to_file(model_instance, suffix):",
            "    save_file_handle, save_file = tempfile.mkstemp(suffix=suffix, prefix=\"skops-test\")",
            "    if suffix in (\".pkl\", \".pickle\"):",
            "        with open(save_file, \"wb\") as f:",
            "            pickle.dump(model_instance, f)",
            "    elif suffix == \".skops\":",
            "        dump(model_instance, save_file)",
            "    return save_file_handle, save_file",
            "",
            "",
            "@pytest.mark.parametrize(\"suffix\", [\".pkl\", \".pickle\", \".skops\"])",
            "def test_load_model(suffix):",
            "    model0 = LinearRegression(n_jobs=123)",
            "    _, save_file = save_model_to_file(model0, suffix)",
            "    if suffix == \".skops\":",
            "        untrusted_types = get_untrusted_types(file=save_file)",
            "    else:",
            "        untrusted_types = None",
            "    loaded_model_str = _load_model(save_file, trusted=untrusted_types)",
            "    save_file_path = Path(save_file)",
            "    loaded_model_path = _load_model(save_file_path, trusted=untrusted_types)",
            "    loaded_model_instance = _load_model(model0, trusted=untrusted_types)",
            "",
            "    assert loaded_model_str.n_jobs == 123",
            "    assert loaded_model_path.n_jobs == 123",
            "    assert loaded_model_instance.n_jobs == 123",
            "",
            "",
            "@pytest.fixture",
            "def model_card(model_diagram=True):",
            "    model = fit_model()",
            "    card = Card(model, model_diagram)",
            "    yield card",
            "",
            "",
            "@pytest.fixture",
            "def iris_data():",
            "    X, y = load_iris(return_X_y=True, as_frame=True)",
            "    yield X, y",
            "",
            "",
            "@pytest.fixture",
            "def iris_estimator(iris_data):",
            "    X, y = iris_data",
            "    est = LogisticRegression(solver=\"liblinear\").fit(X, y)",
            "    yield est",
            "",
            "",
            "@pytest.fixture",
            "def iris_pkl_file(iris_estimator):",
            "    pkl_file = tempfile.mkstemp(suffix=\".pkl\", prefix=\"skops-test\")[1]",
            "    with open(pkl_file, \"wb\") as f:",
            "        pickle.dump(iris_estimator, f)",
            "    yield pkl_file",
            "",
            "",
            "@pytest.fixture",
            "def iris_skops_file(iris_estimator):",
            "    skops_folder = tempfile.mkdtemp()",
            "    model_name = \"model.skops\"",
            "    skops_path = Path(skops_folder) / model_name",
            "    dump(iris_estimator, skops_path)",
            "    yield skops_path",
            "",
            "",
            "def _create_model_card_from_saved_model(",
            "    destination_path,",
            "    iris_estimator,",
            "    iris_data,",
            "    save_file,",
            "):",
            "    X, y = iris_data",
            "    hub_utils.init(",
            "        model=save_file,",
            "        requirements=[f\"scikit-learn=={sklearn.__version__}\"],",
            "        dst=destination_path,",
            "        task=\"tabular-classification\",",
            "        data=X,",
            "    )",
            "    card = Card(iris_estimator, metadata=metadata_from_config(destination_path))",
            "    card.save(Path(destination_path) / \"README.md\")",
            "    return card",
            "",
            "",
            "@pytest.fixture",
            "def skops_model_card_metadata_from_config(",
            "    destination_path, iris_estimator, iris_skops_file, iris_data",
            "):",
            "    yield _create_model_card_from_saved_model(",
            "        destination_path, iris_estimator, iris_data, iris_skops_file",
            "    )",
            "",
            "",
            "@pytest.fixture",
            "def pkl_model_card_metadata_from_config(",
            "    destination_path, iris_estimator, iris_pkl_file, iris_data",
            "):",
            "    yield _create_model_card_from_saved_model(",
            "        destination_path, iris_estimator, iris_data, iris_pkl_file",
            "    )",
            "",
            "",
            "@pytest.fixture",
            "def destination_path():",
            "    with tempfile.TemporaryDirectory(prefix=\"skops-test\") as dir_path:",
            "        yield Path(dir_path)",
            "",
            "",
            "def test_save_model_card(destination_path, model_card):",
            "    model_card.save(Path(destination_path) / \"README.md\")",
            "    assert (Path(destination_path) / \"README.md\").exists()",
            "",
            "",
            "def test_model_caching(",
            "    skops_model_card_metadata_from_config, iris_skops_file, destination_path",
            "):",
            "    \"\"\"Tests that the model card caches the model to avoid loading it multiple times\"\"\"",
            "",
            "    new_model = LogisticRegression(random_state=4321)",
            "    # mock _load_model, it still loads the model but we can track call count",
            "    mock_load_model = mock.Mock(side_effect=load)",
            "    card = Card(iris_skops_file, metadata=metadata_from_config(destination_path))",
            "    with mock.patch(\"skops.card._model_card._load_model\", mock_load_model):",
            "        model1 = card.get_model()",
            "        model2 = card.get_model()",
            "        assert model1 is model2",
            "        # model is cached, hence _load_model is not called",
            "        mock_load_model.assert_not_called()",
            "",
            "        # override model with new model",
            "        dump(new_model, card.model)",
            "",
            "        model3 = card.get_model()",
            "        assert mock_load_model.call_count == 1",
            "        assert model3.random_state == 4321",
            "        model4 = card.get_model()",
            "",
            "        assert model3 is model4",
            "        assert mock_load_model.call_count == 1  # cached call",
            "",
            "",
            "CUSTOM_TEMPLATES = [None, {}, {\"A Title\", \"Another Title\", \"A Title/A Section\"}]  # type: ignore",
            "",
            "",
            "class TestAddModelPlot:",
            "    \"\"\"Tests for the sklearn model repr\"\"\"",
            "",
            "    def test_default(self, model_card):",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_no_overflow(self, model_card):",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # test if the model doesn't overflow the huggingface models page",
            "        assert result.count(\"sk-top-container\") == 1",
            "        assert 'style=\"overflow: auto;' in result",
            "",
            "    def test_model_diagram_false(self):",
            "        model = fit_model()",
            "        model_card = Card(model, model_diagram=False)",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        assert result == CONTENT_PLACEHOLDER",
            "",
            "    def test_model_diagram_str(self):",
            "        # if passing a str, use that as the section name",
            "        model = fit_model()",
            "        other_section_name = \"Here is the model diagram\"",
            "        model_card = Card(model, model_diagram=other_section_name)",
            "",
            "        # first check that default section only contains placeholder",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        assert result == CONTENT_PLACEHOLDER",
            "",
            "        # now check that the actual model diagram is in the other section",
            "        result = model_card.select(other_section_name).format()",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_other_section(self, model_card):",
            "        model_card.add_model_plot(section=\"Other section\")",
            "        result = model_card.select(\"Other section\").content",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_with_description(self, model_card):",
            "        model_card.add_model_plot(description=\"Awesome diagram below\")",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        assert result.startswith(\"Awesome diagram below\\n\\n<style>#sk-\")",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_uses_default(self, template):",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "        model_card.add_model_plot()",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_init_str_works(self, template):",
            "        model = fit_model()",
            "        section_name = \"Here is the model diagram\"",
            "        model_card = Card(model, template=template, model_diagram=section_name)",
            "",
            "        result = model_card.select(section_name).format()",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_default_template_and_model_diagram_true(self, model_card):",
            "        # setting model_diagram=True should not change anything vs auto with the",
            "        # default template",
            "        model = fit_model()",
            "        model_card = Card(model, model_diagram=True)",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_and_model_diagram_true_uses_default(",
            "        self, model_card, template",
            "    ):",
            "        # when using a custom template and not indicating a section, use the",
            "        # default section",
            "        model = fit_model()",
            "        Card(model, template=template, model_diagram=True)",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).format()",
            "        # don't compare whole text, as it's quite long and non-deterministic",
            "        assert result.startswith(\"<style>#sk-\")",
            "        assert \"<style>\" in result",
            "        assert \"LinearRegression()\" in result",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        text1 = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).content",
            "        model_card.add_model_plot(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").content",
            "",
            "        # both are identical, except for numbers like \"#sk-container-id-123\",",
            "        # thus compare everything but the numbers",
            "        assert re.split(r\"\\d+\", text1) == re.split(r\"\\d+\", text2)",
            "",
            "",
            "def _strip_multiple_chars(text, char):",
            "    # utility function needed to compare tables across systems",
            "    # _strip_multiple_chars(\"hi    there\") == \"hi there\"",
            "    # _strip_multiple_chars(\"|---|--|\", \"-\") == \"|-|-|\"",
            "    while char + char in text:",
            "        text = text.replace(char + char, char)",
            "    return text",
            "",
            "",
            "class TestAddHyperparams:",
            "    \"\"\"Tests for the model hyperparameters\"\"\"",
            "",
            "    @pytest.fixture",
            "    def expected(self):",
            "        lines = [",
            "            \"<details>\",",
            "            \"<summary> Click to expand </summary>\",",
            "            \"\",",
            "            \"| Hyperparameter   | Value       |\",",
            "            \"|------------------|-------------|\",",
            "            \"| copy_X           | True        |\",",
            "            \"| fit_intercept    | True        |\",",
            "            \"| n_jobs           |             |\",",
            "            \"| normalize        | deprecated  |\",",
            "            \"| positive         | False       |\",",
            "            \"\",",
            "            \"</details>\",",
            "        ]",
            "        # TODO: After dropping sklearn < 1.2, when the \"normalize\" parameter is",
            "        # removed, remove it from the table above and remove the code below.",
            "        major, minor, *_ = sklearn.__version__.split(\".\")",
            "        major, minor = int(major), int(minor)",
            "        if (major >= 1) and (minor >= 2):",
            "            del lines[8]",
            "",
            "        table = \"\\n\".join(lines)",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        table = _strip_multiple_chars(table, \" \")",
            "        table = _strip_multiple_chars(table, \"-\")",
            "        return table",
            "",
            "    def test_default(self, model_card, expected):",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_other_section(self, model_card, expected):",
            "        model_card.add_hyperparams(section=\"Other section\")",
            "        result = model_card.select(\"Other section\").format()",
            "",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_with_description(self, model_card, expected):",
            "        model_card.add_hyperparams(description=\"Awesome hyperparams\")",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "        assert result.startswith(\"Awesome hyperparams\")",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_uses_default(self, template, expected):",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "        model_card.add_hyperparams()",
            "        result = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "",
            "        # remove multiple whitespaces and dashes, as they're not important and may",
            "        # differ depending on OS",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        text1 = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        ).format()",
            "        model_card.add_hyperparams(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").format()",
            "",
            "        assert text1 == text2",
            "",
            "    def test_hyperparameter_table_with_line_break(self):",
            "        # Hyperparameters can contain values with line breaks, \"\\n\", in them. In",
            "        # that case, the markdown table is broken. Check that the hyperparameter",
            "        # table we create properly replaces the \"\\n\" with \"<br />\".",
            "        class EstimatorWithLbInParams:",
            "            def get_params(self, deep=False):",
            "                return {\"fit_intercept\": True, \"n_jobs\": \"line\\nwith\\nbreak\"}",
            "",
            "        model_card = Card(EstimatorWithLbInParams())",
            "        section_name = \"Model description/Training Procedure/Hyperparameters\"",
            "        text_hyperparams = model_card.select(section_name).format()",
            "",
            "        # remove multiple whitespaces, as they're not important",
            "        text_cleaned = _strip_multiple_chars(text_hyperparams, \" \")",
            "        assert \"| n_jobs | line<br />with<br />break |\" in text_cleaned",
            "",
            "",
            "class TestAddMetrics:",
            "    \"\"\"Tests for adding metrics\"\"\"",
            "",
            "    def test_default(self, model_card):",
            "        # by default, don't add a table, as there are no metrics",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        expected = CONTENT_PLACEHOLDER",
            "        assert result == expected",
            "",
            "    def test_empty_metrics_table(self, model_card):",
            "        model_card.add_metrics()",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        expected = (",
            "            \"| Metric   | Value   |\\n\"  # fmt: skip",
            "            \"|----------|---------|\"",
            "        )",
            "        assert result == expected",
            "",
            "    def test_multiple_metrics(self, model_card):",
            "        model_card.add_metrics(**{\"acc\": \"0.1\"})  # str",
            "        model_card.add_metrics(",
            "            f1=0.1,  # float",
            "            awesomeness=123,  # int",
            "        )",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        expected = (",
            "            \"| Metric      |   Value |\\n\"",
            "            \"|-------------|---------|\\n\"",
            "            \"| acc         |     0.1 |\\n\"",
            "            \"| f1          |     0.1 |\\n\"",
            "            \"| awesomeness |   123   |\"",
            "        )",
            "        assert result == expected",
            "",
            "    def test_other_section(self, model_card):",
            "        model_card.add_metrics(accuracy=0.9, section=\"Other section\")",
            "        result = model_card.select(\"Other section\").format()",
            "        # fmt: off",
            "        expected = (",
            "            \"| Metric   |   Value |\\n\"",
            "            \"|----------|---------|\\n\"",
            "            \"| accuracy |     0.9 |\"",
            "        )",
            "        # fmt: on",
            "        assert result == expected",
            "",
            "    def test_with_description(self, model_card):",
            "        model_card.add_metrics(accuracy=0.9, description=\"Awesome metrics\")",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        assert result.startswith(\"Awesome metrics\\n\\n| Metric \")",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_raises(self, template):",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "        model_card.add_metrics(accuracy=0.9)",
            "",
            "        result = model_card.select(\"Model description/Evaluation Results\").format()",
            "        # fmt: off",
            "        expected = (",
            "            \"| Metric   |   Value |\\n\"",
            "            \"|----------|---------|\\n\"",
            "            \"| accuracy |     0.9 |\"",
            "        )",
            "        # fmt: on",
            "        assert result == expected",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        model_card.add_metrics(accuracy=0.9)",
            "        text1 = model_card.select(\"Model description/Evaluation Results\").format()",
            "        model_card.add_metrics(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").format()",
            "        assert text1 == text2",
            "",
            "",
            "class TestAddPermutationImportance:",
            "    @pytest.fixture",
            "    def importances(self, iris_estimator, iris_data):",
            "        X, y = iris_data",
            "        result = permutation_importance(",
            "            iris_estimator, X, y, n_repeats=10, random_state=42, n_jobs=2",
            "        )",
            "        return result",
            "",
            "    def test_permutation_importances(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        model_card.add_permutation_importances(",
            "            importances,",
            "            columns=X.columns,",
            "            plot_file=Path(destination_path) / \"importance.png\",",
            "            plot_name=\"Permutation Importance\",",
            "        )",
            "        temp_path = Path(destination_path) / \"importance.png\"",
            "        section = model_card.select(\"Permutation Importance\")",
            "        expected = f\"![Permutation Importance]({temp_path})\"",
            "        assert section.format() == expected",
            "",
            "    def test_multiple_permutation_importances(",
            "        self, iris_data, iris_estimator, importances, model_card, destination_path",
            "    ):",
            "        X, y = iris_data",
            "        model_card.add_permutation_importances(",
            "            importances, X.columns, plot_file=Path(destination_path) / \"importance.png\"",
            "        )",
            "",
            "        f1 = make_scorer(f1_score, average=\"micro\")",
            "        importances_f1 = permutation_importance(",
            "            iris_estimator, X, y, scoring=f1, n_repeats=10, random_state=42, n_jobs=2",
            "        )",
            "        model_card.add_permutation_importances(",
            "            importances_f1,",
            "            columns=X.columns,",
            "            plot_file=Path(destination_path) / \"f1_importance.png\",",
            "            plot_name=\"Permutation Importance on f1\",",
            "        )",
            "",
            "        # check for default one",
            "        temp_path = Path(destination_path) / \"importance.png\"",
            "        section = model_card.select(\"Permutation Importances\")",
            "        expected = f\"![Permutation Importances]({temp_path})\"",
            "        assert section.format() == expected",
            "",
            "        # check for F1",
            "        temp_path_f1 = Path(destination_path) / \"f1_importance.png\"",
            "        section = model_card.select(\"Permutation Importance on f1\")",
            "        expected = f\"![Permutation Importance on f1]({temp_path_f1})\"",
            "        assert section.format() == expected",
            "",
            "    def test_duplicate_permutation_importances(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        plot_path = os.path.join(destination_path, \"importance.png\")",
            "        model_card.add_permutation_importances(",
            "            importances, X.columns, plot_file=plot_path",
            "        )",
            "        with pytest.raises(",
            "            ValueError,",
            "            match=(",
            "                \"already exists. Set `overwrite` to `True` or pass a\"",
            "                \" different filename for the plot.\"",
            "            ),",
            "        ):",
            "            model_card.add_permutation_importances(",
            "                importances,",
            "                columns=X.columns,",
            "                plot_file=plot_path,",
            "                plot_name=\"Permutation Importance on f1\",",
            "            )",
            "",
            "    def test_duplicate_permutation_importances_overwrite(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        plot_path = os.path.join(destination_path, \"importance.png\")",
            "        model_card.add_permutation_importances(",
            "            importances, X.columns, plot_file=plot_path",
            "        )",
            "",
            "        model_card.add_permutation_importances(",
            "            importances,",
            "            columns=X.columns,",
            "            plot_file=plot_path,",
            "            plot_name=\"Permutation Importance on f1\",",
            "            overwrite=True,",
            "        )",
            "        section = model_card.select(\"Permutation Importance on f1\")",
            "        expected = f\"![Permutation Importance on f1]({plot_path})\"",
            "        assert section.format() == expected",
            "",
            "    def test_permutation_importances_with_description(",
            "        self, iris_data, importances, model_card, destination_path",
            "    ):",
            "        X, _ = iris_data",
            "        model_card.add_permutation_importances(",
            "            importances,",
            "            columns=X.columns,",
            "            plot_file=Path(destination_path) / \"importance.png\",",
            "            description=\"Very important\",",
            "        )",
            "        temp_path = Path(destination_path) / \"importance.png\"",
            "        section = model_card.select(\"Permutation Importances\")",
            "        expected = f\"Very important\\n\\n![Permutation Importances]({temp_path})\"",
            "        assert section.format() == expected",
            "",
            "",
            "class TestAddGetStartedCode:",
            "    \"\"\"Tests for getting started code\"\"\"",
            "",
            "    @pytest.fixture",
            "    def metadata(self):",
            "        # dummy ModelCardData using pickle",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.pickle\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"pickle\",",
            "                    },",
            "                }",
            "",
            "        return Metadata()",
            "",
            "    @pytest.fixture",
            "    def model_card(self, metadata):",
            "        model = fit_model()",
            "        card = Card(model, metadata=metadata)",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def metadata_skops(self):",
            "        # dummy ModelCardData using skops",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.skops\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"skops\",",
            "                    },",
            "                }",
            "",
            "        return Metadata()",
            "",
            "    @pytest.fixture",
            "    def model_card_skops(self, metadata_skops):",
            "        model = fit_model()",
            "        card = Card(model, metadata=metadata_skops)",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def text_pickle(self):",
            "        return (",
            "            \"```python\\n\"",
            "            \"import json\\n\"",
            "            \"import pandas as pd\\n\"",
            "            \"import joblib\\n\"",
            "            'model = joblib.load(\"my-model.pickle\")\\n'",
            "            'with open(\"config.json\") as f:\\n'",
            "            \"    config = json.load(f)\\n\"",
            "            'model.predict(pd.DataFrame.from_dict(config[\"sklearn\"][\"example_input\"]))\\n'",
            "            \"```\"",
            "        )",
            "",
            "    @pytest.fixture",
            "    def text_skops(self):",
            "        return (",
            "            \"```python\\n\"",
            "            \"import json\\n\"",
            "            \"import pandas as pd\\n\"",
            "            \"import skops.io as sio\\n\"",
            "            'model = sio.load(\"my-model.skops\")\\n'",
            "            'with open(\"config.json\") as f:\\n'",
            "            \"    config = json.load(f)\\n\"",
            "            'model.predict(pd.DataFrame.from_dict(config[\"sklearn\"][\"example_input\"]))\\n'",
            "            \"```\"",
            "        )",
            "",
            "    def test_default_pickle(self, model_card, text_pickle):",
            "        # by default, don't add a table, as there are no metrics",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result == text_pickle",
            "",
            "    def test_default_skops(self, model_card_skops, text_skops):",
            "        # by default, don't add a table, as there are no metrics",
            "        result = model_card_skops.select(\"How to Get Started with the Model\").format()",
            "        assert result == text_skops",
            "",
            "    def test_no_metadata_file_name(self):",
            "        model = fit_model()",
            "        card = Card(model, metadata=None)",
            "        card.add_get_started_code()  # does not raise",
            "",
            "    def test_no_metadata_file_format(self):",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.skops\",",
            "                    # missing file format entry",
            "                }",
            "",
            "        model = fit_model()",
            "        card = Card(model, metadata=Metadata())",
            "        card.add_get_started_code()  # does not raise",
            "",
            "    def test_other_section(self, model_card, text_pickle):",
            "        model_card.add_get_started_code(section=\"Other section\")",
            "        result = model_card.select(\"Other section\").format()",
            "        assert result == text_pickle",
            "",
            "    def test_use_description(self, model_card):",
            "        model_card.add_get_started_code(description=\"Awesome code\")",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result.startswith(\"Awesome code\")",
            "",
            "    def test_other_filename(self, model_card, text_pickle):",
            "        model_card.add_get_started_code(file_name=\"foobar.pkl\")",
            "        text = text_pickle.replace(\"my-model.pickle\", \"foobar.pkl\")",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result == text",
            "",
            "    def test_explicitly_set_other_model_format(self, model_card, text_skops):",
            "        model_card.add_get_started_code(model_format=\"skops\")",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        # file name is still \"my-model.pickle\", only the loading code changes",
            "        text = text_skops.replace(\".skops\", \".pickle\")",
            "        assert result == text",
            "",
            "    def test_invalid_model_format_passed(self, model_card):",
            "        # json is not a valid model format",
            "        msg = \"Invalid model format 'json', should be one of 'pickle' or 'skops'\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            model_card.add_get_started_code(model_format=\"json\")",
            "",
            "    def test_invalid_model_format_passed_via_metadata(self):",
            "        # metadata contains invalid model format json",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.skops\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"json\",",
            "                    },",
            "                }",
            "",
            "        model = fit_model()",
            "",
            "        msg = \"Invalid model format 'json', should be one of 'pickle' or 'skops'\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            Card(model, metadata=Metadata())",
            "",
            "    @pytest.mark.parametrize(\"template\", CUSTOM_TEMPLATES)",
            "    def test_custom_template_no_section_uses_default(self, template, text_pickle):",
            "        model = fit_model()",
            "",
            "        class Metadata:",
            "            def to_dict(self):",
            "                return {",
            "                    \"model_file\": \"my-model.pickle\",",
            "                    \"sklearn\": {",
            "                        \"model_format\": \"pickle\",",
            "                    },",
            "                }",
            "",
            "        model_card = Card(model, metadata=Metadata(), template=template)",
            "        model_card.add_get_started_code()",
            "        result = model_card.select(\"How to Get Started with the Model\").format()",
            "        assert result == text_pickle",
            "",
            "    def test_add_twice(self, model_card):",
            "        # it's possible to add the section twice, even if it doesn't make a lot",
            "        # of sense",
            "        text1 = model_card.select(\"How to Get Started with the Model\").format()",
            "        model_card.add_get_started_code(section=\"Other section\")",
            "        text2 = model_card.select(\"Other section\").format()",
            "        assert text1 == text2",
            "",
            "",
            "class TestRender:",
            "    def test_render(self, model_card, destination_path):",
            "        file_name = destination_path / \"README.md\"",
            "        model_card.save(file_name)",
            "        with open(file_name, \"r\", encoding=\"utf-8\") as f:",
            "            loaded = f.read()",
            "",
            "        rendered = model_card.render()",
            "        assert loaded == rendered",
            "",
            "    def test_render_with_metadata(self, model_card):",
            "        model_card.metadata.foo = \"something\"",
            "        model_card.metadata.bar = \"something else\"",
            "        rendered = model_card.render()",
            "        expected = textwrap.dedent(\"\"\"",
            "            ---",
            "            foo: something",
            "            bar: something else",
            "            ---",
            "            \"\"\").strip()",
            "        assert rendered.startswith(expected)",
            "",
            "",
            "class TestSelect:",
            "    \"\"\"Selecting sections from the model card\"\"\"",
            "",
            "    def test_select_existing_section(self, model_card):",
            "        section = model_card.select(\"Model description\")",
            "        assert section.title == \"Model description\"",
            "",
            "    def test_select_existing_subsection(self, model_card):",
            "        section = model_card.select(\"Model description/Training Procedure\")",
            "        assert section.title == \"Training Procedure\"",
            "",
            "        section = model_card.select(\"Model description\").select(\"Training Procedure\")",
            "        assert section.title == \"Training Procedure\"",
            "",
            "    def test_select_existing_subsubsection(self, model_card):",
            "        section = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        )",
            "        assert section.title == \"Hyperparameters\"",
            "",
            "        section = (",
            "            model_card.select(\"Model description\")",
            "            .select(\"Training Procedure\")",
            "            .select(\"Hyperparameters\")",
            "        )",
            "        assert section.title == \"Hyperparameters\"",
            "",
            "    def test_select_non_existing_section_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"non-existing section\")",
            "",
            "    def test_select_non_existing_subsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description/non-existing subsection\")",
            "",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description\").select(\"non-existing subsection\")",
            "",
            "    def test_select_non_existing_subsubsection_raises(self, model_card):",
            "        msg = \"non-existing sub-subsection\"",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(",
            "                \"Model description/Training Procedure/non-existing sub-subsection\"",
            "            )",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            (",
            "                model_card.select(\"Model description\")",
            "                .select(\"Training Procedure\")",
            "                .select(\"non-existing sub-subsection\")",
            "            )",
            "",
            "    def test_select_non_existing_section_and_subsection_raises(self, model_card):",
            "        msg = \"non-existing section\"",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"non-existing section/non-existing subsection\")",
            "",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"non-existing section\").select(\"non-existing subsection\")",
            "",
            "    def test_select_empty_key_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got ''\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"\")",
            "",
            "    def test_select_empty_key_subsection_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got 'Model description/'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"Model description/\")",
            "",
            "        msg = r\"Section name cannot be empty but got ''\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.select(\"Model description\").select(\"\")",
            "",
            "    def test_default_skops_sections_present(self, model_card):",
            "        # model_card (which is prefilled) contains all default sections",
            "        for key in SKOPS_TEMPLATE:",
            "            model_card.select(key)",
            "",
            "    def test_default_skops_sections_empty_card(self, model_card):",
            "        # Without prefilled template, the card should not contain the default sections",
            "",
            "        # empty card does not contain any sections, so trying to select them",
            "        # should raise a KeyError",
            "        model = fit_model()",
            "        card_empty = Card(model, model_diagram=False, template=None)",
            "        for key in SKOPS_TEMPLATE:",
            "            with pytest.raises(KeyError):",
            "                card_empty.select(key)",
            "",
            "    def test_invalid_template_name_raises(self):",
            "        msg = \"Unknown template 'does-not-exist', template must be one of the following\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            Card(model=None, template=\"does-not-exist\")",
            "",
            "",
            "class TestAdd:",
            "    \"\"\"Adding sections and subsections\"\"\"",
            "",
            "    @pytest.mark.parametrize(\"folded\", [True, False])",
            "    def test_add_new_section(self, model_card, folded):",
            "        model_card = model_card.add(**{\"A new section\": \"sklearn FTW\"}, folded=folded)",
            "        section = model_card.select(\"A new section\")",
            "        assert section.title == \"A new section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "        output = section.format()",
            "        if folded:",
            "            assert \"<details>\" in output",
            "        else:",
            "            assert \"<details>\" not in output",
            "",
            "    def test_add_new_subsection(self, model_card):",
            "        model_card = model_card.add(",
            "            **{\"Model description/A new section\": \"sklearn FTW\"}",
            "        )",
            "        section = model_card.select(\"Model description/A new section\")",
            "        assert section.title == \"A new section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "        # make sure that the new subsection is the last subsection",
            "        subsections = model_card._data[\"Model description\"].subsections",
            "        assert len(subsections) > 1  # exclude trivial case of only one subsection",
            "",
            "        last_subsection = list(subsections.values())[-1]",
            "        assert last_subsection is section",
            "",
            "    def test_add_new_section_and_subsection(self, model_card):",
            "        model_card = model_card.add(**{\"A new section/A new subsection\": \"sklearn FTW\"})",
            "",
            "        section = model_card.select(\"A new section\")",
            "        assert section.title == \"A new section\"",
            "        assert section.content == \"\"",
            "",
            "        subsection = model_card.select(\"A new section/A new subsection\")",
            "        assert subsection.title == \"A new subsection\"",
            "        assert subsection.content == \"sklearn FTW\"",
            "",
            "    def test_add_new_section_with_slash_in_name(self, model_card):",
            "        model_card = model_card.add(**{\"A new\\\\/section\": \"sklearn FTW\"})",
            "        section = model_card.select(\"A new\\\\/section\")",
            "        assert section.title == \"A new/section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "    def test_add_new_subsection_with_slash_in_name(self, model_card):",
            "        model_card = model_card.add(",
            "            **{\"Model description/A new\\\\/section\": \"sklearn FTW\"}",
            "        )",
            "        section = model_card.select(\"Model description/A new\\\\/section\")",
            "        assert section.title == \"A new/section\"",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "    def test_add_content_to_existing_section(self, model_card):",
            "        # Add content (not new sections) to an existing section. Make sure that",
            "        # existing subsections are not affected by this",
            "        section = model_card.select(\"Model description\")",
            "        num_subsection_before = len(section.subsections)",
            "        assert num_subsection_before > 0  # exclude trivial case of empty sections",
            "",
            "        # add content to \"Model description\" section",
            "        model_card = model_card.add(**{\"Model description\": \"sklearn FTW\"})",
            "        section = model_card.select(\"Model description\")",
            "        num_subsection_after = len(section.subsections)",
            "",
            "        assert num_subsection_before == num_subsection_after",
            "        assert section.content == \"sklearn FTW\"",
            "",
            "    def test_add_plain_section_works(self, model_card):",
            "        # It is allowed to add a *Section object, but it's not documented and",
            "        # users should normally not use that feature",
            "        section = Section(\"title may differ from section name\", \"some content\")",
            "        model_card.add(",
            "            a_string=\"normal string\",",
            "            a_section=section,",
            "        )",
            "        assert model_card.select(\"a_section\") == section",
            "",
            "    def test_add_section_preserves_subsections(self, model_card):",
            "        # As explained in the previous test, users can theoretically add section",
            "        # instances. If they override an existing section with a new section,",
            "        # the subsections of the existing section should be preserved.",
            "",
            "        # first let's add a section and a subsection",
            "        model_card.add(**{\"new section\": \"hello\", \"new section/subsection\": \"world\"})",
            "        assert model_card.select(\"new section\").format() == \"hello\"",
            "        assert model_card.select(\"new section/subsection\").format() == \"world\"",
            "",
            "        # now let's override the section, the subsection should be preserved",
            "        new_section = Section(\"new section\", \"bonjour\")",
            "        model_card.add(**{\"new section\": new_section})",
            "        assert model_card.select(\"new section\").format() == \"bonjour\"",
            "        assert model_card.select(\"new section/subsection\").format() == \"world\"",
            "",
            "    def test_add_section_with_identical_subsection_preserves_subsections(",
            "        self, model_card",
            "    ):",
            "        # As explained in the previous tests, users can theoretically add",
            "        # section instances. If they override an existing section with a new",
            "        # section, the subsections of the existing section should be preserved.",
            "        # If the new section they add has its own subsections, and these",
            "        # subsections are identical to the old subsections, that should be fine.",
            "",
            "        # first let's add a section and a subsection",
            "        model_card.add(**{\"new section\": \"hello\", \"new section/subsection\": \"world\"})",
            "",
            "        # now let's override the section using the same subsections",
            "        old_subsection = model_card.select(\"new section\").subsections",
            "        new_section = Section(\"new section\", \"bonjour\", subsections=old_subsection)",
            "        model_card.add(**{\"new section\": new_section})",
            "        assert model_card.select(\"new section\").format() == \"bonjour\"",
            "        assert model_card.select(\"new section/subsection\").format() == \"world\"",
            "",
            "    def test_add_section_with_different_subsection_raises(self, model_card):",
            "        # This is the same as the previous test, but now the section used to",
            "        # override the previous section has different subsections. Now we don't",
            "        # know what to do and should raise. This is okay because normally, a",
            "        # user shouldn't add section instances anyway.",
            "",
            "        # first let's add a section and a subsection",
            "        model_card.add(**{\"new section\": \"hello\", \"new section/subsection\": \"world\"})",
            "",
            "        # now let's override the section using different subsections",
            "        new_subsection = {\"new subsection\": Section(\"subsection\", \"mars\")}",
            "        new_section = Section(\"new section\", \"bonjour\", subsections=new_subsection)",
            "",
            "        match = (",
            "            \"Trying to override section 'new section' but found conflicting subsections\"",
            "        )",
            "        with pytest.raises(ValueError, match=match):",
            "            model_card.add(**{\"new section\": new_section})",
            "",
            "",
            "class TestDelete:",
            "    \"\"\"Deleting sections and subsections\"\"\"",
            "",
            "    def test_delete_section(self, model_card):",
            "        model_card.select(\"Model description\")",
            "        model_card.delete(\"Model description\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description\")",
            "",
            "    def test_delete_subsection(self, model_card):",
            "        model_card.select(\"Model description/Training Procedure\")",
            "        model_card.delete(\"Model description/Training Procedure\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description/Training Procedure\")",
            "        # parent section still exists",
            "        model_card.delete(\"Model description\")",
            "",
            "    def test_delete_subsubsection(self, model_card):",
            "        model_card.select(\"Model description/Training Procedure/Hyperparameters\")",
            "        model_card.delete(\"Model description/Training Procedure/Hyperparameters\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"Model description/Training Procedure/Hyperparameters\")",
            "        # parent section still exists",
            "        model_card.delete(\"Model description/Training Procedure\")",
            "",
            "    def test_delete_section_with_slash_in_name(self, model_card):",
            "        model_card.add(**{\"A new\\\\/section\": \"some content\"})",
            "        model_card.select(\"A new\\\\/section\")",
            "        model_card.delete(\"A new\\\\/section\")",
            "        with pytest.raises(KeyError):",
            "            model_card.select(\"A new\\\\/section\")",
            "",
            "    def test_delete_non_existing_section_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(\"non-existing section\")",
            "",
            "    def test_delete_non_existing_subsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(\"Model description/non-existing subsection\")",
            "",
            "        with pytest.raises(KeyError):",
            "            model_card.delete([\"Model description\", \"non-existing subsection\"])",
            "",
            "    def test_delete_non_existing_subsubsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(",
            "                \"Model description/Training Procedure/non-existing sub-subsection\"",
            "            )",
            "",
            "        with pytest.raises(KeyError):",
            "            model_card.delete(",
            "                [",
            "                    \"Model description\",",
            "                    \"Training Procedure\",",
            "                    \"non-existing sub-subsection\",",
            "                ]",
            "            )",
            "",
            "    def test_delete_non_existing_section_and_subsection_raises(self, model_card):",
            "        with pytest.raises(KeyError):",
            "            model_card.delete([\"non-existing section\", \"non-existing subsection\"])",
            "",
            "    def test_delete_empty_key_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got ''\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete(\"\")",
            "",
            "        msg = r\"Section name cannot be empty but got '\\[\\]'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete([])",
            "",
            "    def test_delete_empty_key_subsection_raises(self, model_card):",
            "        msg = r\"Section name cannot be empty but got 'Model description/'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete(\"Model description/\")",
            "",
            "        msg = r\"Section name cannot be empty but got '\\['Model description', ''\\]'\"",
            "        with pytest.raises(KeyError, match=msg):",
            "            model_card.delete([\"Model description\", \"\"])",
            "",
            "",
            "class TestAddPlot:",
            "    def test_add_plot(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(fig1=\"fig1.png\")",
            "        plot_content = model_card.select(\"fig1\").format()",
            "        assert plot_content == \"![fig1](fig1.png)\"",
            "",
            "    def test_add_plot_to_existing_section(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(**{\"Model description/Figure 1\": \"fig1.png\"})",
            "        plot_content = model_card.select(\"Model description/Figure 1\").format()",
            "        assert plot_content == \"![Figure 1](fig1.png)\"",
            "",
            "    def test_add_plot_with_description(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(description=\"My fancy plot\", fig1=\"fig1.png\")",
            "        plot_content = model_card.select(\"fig1\").format()",
            "        assert plot_content == \"My fancy plot\\n\\n![fig1](fig1.png)\"",
            "",
            "    def test_add_plot_with_alt_text(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        plt.plot([4, 5, 6, 7])",
            "        plt.savefig(Path(destination_path) / \"fig1.png\")",
            "        model_card = model_card.add_plot(alt_text=\"the figure\", fig1=\"fig1.png\")",
            "        plot_content = model_card.select(\"fig1\").format()",
            "        assert plot_content == \"![the figure](fig1.png)\"",
            "",
            "",
            "class TestMetadata:",
            "    def test_adding_metadata(self, model_card):",
            "        # test if the metadata is added to the card",
            "        model_card.metadata.tags = \"dummy\"",
            "        metadata = list(model_card._generate_metadata(model_card.metadata))",
            "        assert len(metadata) == 1",
            "        assert metadata[0] == \"metadata.tags=dummy,\"",
            "",
            "    def test_metadata_from_config_tabular_data(",
            "        self, pkl_model_card_metadata_from_config, destination_path",
            "    ):",
            "        # test if widget data is correctly set in the README",
            "        metadata = metadata_load(local_path=Path(destination_path) / \"README.md\")",
            "        assert \"widget\" in metadata",
            "",
            "        expected_data = [",
            "            {",
            "                \"structuredData\": {",
            "                    \"petal length (cm)\": [1.4, 1.4, 1.3],",
            "                    \"petal width (cm)\": [0.2, 0.2, 0.2],",
            "                    \"sepal length (cm)\": [5.1, 4.9, 4.7],",
            "                    \"sepal width (cm)\": [3.5, 3.0, 3.2],",
            "                }",
            "            },",
            "        ]",
            "        assert metadata[\"widget\"] == expected_data",
            "",
            "        for tag in [\"sklearn\", \"skops\", \"tabular-classification\"]:",
            "            assert tag in metadata[\"tags\"]",
            "",
            "    def test_metadata_model_format_pkl(",
            "        self, pkl_model_card_metadata_from_config, destination_path",
            "    ):",
            "        metadata = metadata_load(local_path=Path(destination_path) / \"README.md\")",
            "        assert metadata[\"model_format\"] == \"pickle\"",
            "",
            "    def test_metadata_model_format_skops(",
            "        self, skops_model_card_metadata_from_config, destination_path",
            "    ):",
            "        metadata = metadata_load(local_path=Path(destination_path) / \"README.md\")",
            "        assert metadata[\"model_format\"] == \"skops\"",
            "",
            "",
            "@pytest.mark.xfail(reason=\"dynamic adjustment when model changes not implemented yet\")",
            "class TestModelDynamicUpdate:",
            "    def test_model_related_sections_updated_dynamically_skops_template(",
            "        self, model_card",
            "    ):",
            "        # Change the model to be a KNN classifier and check that the sections",
            "        # related to the model, the plot and hyperparams, are updated correctly.",
            "        # But first, as a sanity check, ensure that before the change, there is",
            "        # no reference to KNN.",
            "        model_plot_before = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        )",
            "        assert \"KNeighborsClassifier\" not in model_plot_before.content",
            "",
            "        hyperparams_before = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        )",
            "        assert \"n_neighbors\" not in hyperparams_before.content.format()",
            "",
            "        # change model to KNN",
            "        model_after = KNeighborsClassifier()",
            "        model_card.model = model_after",
            "",
            "        model_plot_after = model_card.select(",
            "            \"Model description/Training Procedure/Model Plot\"",
            "        ).content",
            "        assert \"KNeighborsClassifier\" in model_plot_after",
            "",
            "        hyperparams_after = model_card.select(",
            "            \"Model description/Training Procedure/Hyperparameters\"",
            "        )",
            "        assert \"n_neighbors\" in hyperparams_after.content.format()",
            "",
            "    def test_model_related_sections_updated_dynamically_custom_template(",
            "        self, model_card",
            "    ):",
            "        # same as previous test but using a custom template",
            "        template = {\"My model plot\": \"\"}",
            "        model = fit_model()",
            "        model_card = Card(model, template=template)",
            "",
            "        # add model plot and hyperparams -- section must be passed but it",
            "        # doesn't need to already exist in the custom template",
            "        model_card.add_model_plot(section=\"My model plot\")",
            "        model_card.add_hyperparams(section=\"My hyperparams\")",
            "",
            "        model_plot_before = model_card.select(\"My model plot\")",
            "        assert \"KNeighborsClassifier\" not in model_plot_before.content",
            "",
            "        hyperparams_before = model_card.select(\"My hyperparams\")",
            "        assert \"n_neighbors\" not in hyperparams_before.content.format()",
            "",
            "        # change model to KNN",
            "        model_after = KNeighborsClassifier()",
            "        model_card.model = model_after",
            "",
            "        model_plot_after = model_card.select(\"My model plot\")",
            "        assert \"KNeighborsClassifier\" in model_plot_after.content",
            "",
            "        hyperparams_after = model_card.select(\"My hyperparams\")",
            "        assert \"n_neighbors\" in hyperparams_after.content.format()",
            "",
            "",
            "class TestCardRepr:",
            "    \"\"\"Test __str__ and __repr__ methods of Card, which are identical for now\"\"\"",
            "",
            "    @pytest.fixture",
            "    def card(self):",
            "        model = LinearRegression(fit_intercept=False)",
            "        card = Card(model=model)",
            "        card.add(Figures=\"\")",
            "        card.add(",
            "            **{",
            "                \"Model Description\": \"A description\",",
            "                \"Model Card Authors\": \"Jane Doe\",",
            "            }",
            "        )",
            "        card.add_plot(",
            "            **{",
            "                \"Figures/ROC\": \"ROC.png\",",
            "                \"Figures/Confusion matrix\": \"confusion_matrix.jpg\",",
            "            }",
            "        )",
            "        card.add_table(**{\"Search Results\": {\"split\": [1, 2, 3], \"score\": [4, 5, 6]}})",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def expected_lines(self):",
            "        card_repr = \"\"\"",
            "        Card(",
            "          model=LinearRegression(fit_intercept=False),",
            "          Model description/Training Procedure/Hyperparameters=TableSection(4x2),",
            "          Model description/Training Procedure/...</div>,",
            "          Model Card Authors=Jane Doe,",
            "          Figures/ROC=PlotSection(ROC.png),",
            "          Figures/Confusion matrix=PlotSection(confusion_matrix.jpg),",
            "          Model Description=A description,",
            "          Search Results=TableSection(3x2),",
            "        )",
            "        \"\"\"",
            "        expected = textwrap.dedent(card_repr).strip()",
            "        lines = expected.split(\"\\n\")",
            "        return lines",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_card_repr(self, card: Card, meth, expected_lines):",
            "        result = meth(card)",
            "        expected = \"\\n\".join(expected_lines)",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "        assert re.match(expected, result)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_card_repr_empty_card(self, meth):",
            "        \"\"\"Without prefilled template, the repr should be empty\"\"\"",
            "        model = fit_model()",
            "        card = Card(model, model_diagram=False, template=None)",
            "        result = meth(card)",
            "        expected = textwrap.dedent(\"\"\"",
            "        Card(",
            "          model=LinearRegression(),",
            "        )",
            "        \"\"\").strip()",
            "        assert result == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_very_long_lines_are_shortened(self, card: Card, meth, expected_lines):",
            "        card.add(my_section=\"very long line \" * 100)",
            "",
            "        # expected results contain 1 line at the very end",
            "        extra_line = (",
            "            \"  my_section=very long line very long l... \"",
            "            \"line very long line very long line ,\"",
            "        )",
            "        expected_lines.insert(-1, extra_line)",
            "        expected = \"\\n\".join(expected_lines)",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "",
            "        result = meth(card)",
            "        assert re.match(expected, result)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_without_model_attribute(self, card: Card, meth, expected_lines):",
            "        del card.model",
            "",
            "        # remove line 1 from expected results, which corresponds to the model",
            "        del expected_lines[1]",
            "        expected = \"\\n\".join(expected_lines)",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "",
            "        result = meth(card)",
            "        assert re.match(expected, result)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_with_metadata(self, card: Card, meth, expected_lines):",
            "        metadata = ModelCardData(",
            "            language=\"fr\",",
            "            license=\"bsd\",",
            "            library_name=\"sklearn\",",
            "            tags=[\"sklearn\", \"tabular-classification\"],",
            "            foo={\"bar\": 123},",
            "            widget=[{\"something\": \"very-long\"}],",
            "        )",
            "        card.metadata = metadata",
            "",
            "        # metadata comes after model line, i.e. position 2",
            "        extra_lines = [",
            "            \"  metadata.language=fr,\",",
            "            \"  metadata.license=bsd,\",",
            "            \"  metadata.library_name=sklearn,\",",
            "            \"  metadata.tags=['sklearn', 'tabular-classification'],\",",
            "            \"  metadata.foo={'bar': 123},\",",
            "            \"  metadata.widget=[{...}],\",",
            "        ]",
            "        expected = \"\\n\".join(expected_lines[:2] + extra_lines + expected_lines[2:])",
            "        expected = re.escape(expected)",
            "        expected = expected.replace(r\"\\.\\.\\.\", \".*\")",
            "        result = meth(card)",
            "",
            "        assert re.match(expected, result)",
            "",
            "",
            "class TestCardModelAttributeIsPath:",
            "    def path_to_card(self, path, suffix):",
            "        if suffix == \".skops\":",
            "            card = Card(model=path, trusted=get_untrusted_types(file=path))",
            "        else:",
            "            card = Card(model=path)",
            "        return card",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    @pytest.mark.parametrize(\"suffix\", [\".pkl\", \".skops\"])",
            "    def test_model_card_repr(self, meth, suffix):",
            "        # Test that if the model is changed, Card takes this into account, if",
            "        # the model argument is a path to a model file. First, we test that if",
            "        # the model path changes, the Card changes. Then we test that if the",
            "        # file on disk changes, the Card changes.",
            "        model = LinearRegression(fit_intercept=False)",
            "        file_handle, file_name = save_model_to_file(model, suffix)",
            "        os.close(file_handle)",
            "        card_from_path = self.path_to_card(file_name, suffix=suffix)",
            "",
            "        result0 = meth(card_from_path)",
            "        expected = \"Card(\\n  model=LinearRegression(fit_intercept=False),\"",
            "        assert result0.startswith(expected)",
            "",
            "        # change file name, same card should show different result",
            "        model = LinearRegression()",
            "        file_handle, file_name = save_model_to_file(model, suffix)",
            "        card_from_path.model = file_name",
            "        result1 = meth(card_from_path)",
            "        expected = \"Card(\\n  model=LinearRegression(),\"",
            "        assert result1.startswith(expected)",
            "",
            "        # change model on disk but keep same file name, should show different",
            "        # result",
            "        model = LinearRegression(fit_intercept=None)",
            "        with open(file_name, \"wb\") as f:",
            "            dump_fn = pickle.dump if suffix == \".pkl\" else dump",
            "            dump_fn(model, f)",
            "        result2 = meth(card_from_path)",
            "        expected = \"Card(\\n  model=LinearRegression(fit_intercept=None),\"",
            "        assert result2.startswith(expected)",
            "",
            "    @pytest.mark.parametrize(\"suffix\", [\".pkl\", \".skops\"])",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_load_model_exception(self, meth, suffix):",
            "        file_handle, file_name = tempfile.mkstemp(suffix=suffix, prefix=\"skops-test\")",
            "",
            "        os.close(file_handle)",
            "",
            "        with pytest.raises(Exception, match=\"occurred during model loading.\"):",
            "            card = Card(file_name)",
            "            meth(card)",
            "",
            "    @pytest.mark.parametrize(\"meth\", [repr, str])",
            "    def test_load_model_file_not_found(self, meth):",
            "        file_handle, file_name = tempfile.mkstemp(suffix=\".pkl\", prefix=\"skops-test\")",
            "",
            "        os.close(file_handle)",
            "        os.remove(file_name)",
            "",
            "        with pytest.raises(FileNotFoundError) as excinfo:",
            "            card = Card(file_name)",
            "            meth(card)",
            "",
            "        assert file_name in str(excinfo.value)",
            "",
            "",
            "class TestPlotSection:",
            "    def test_format_path_is_str(self):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=\"path/plot.png\"",
            "        )",
            "        expected = \"![some title](path/plot.png)\"",
            "        assert section.format() == expected",
            "",
            "    def test_format_path_is_pathlib(self):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=Path(\"path\") / \"plot.png\"",
            "        )",
            "        expected = f\"![some title](path{os.path.sep}plot.png)\"",
            "        assert section.format() == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [str, repr])",
            "    def test_str_and_repr(self, meth):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=\"path/plot.png\"",
            "        )",
            "        expected = \"PlotSection(path/plot.png)\"",
            "        assert meth(section) == expected",
            "",
            "    def test_str(self):",
            "        section = PlotSection(",
            "            title=\"\", content=\"\", alt_text=\"some title\", path=\"path/plot.png\"",
            "        )",
            "        expected = \"PlotSection(path/plot.png)\"",
            "        assert str(section) == expected",
            "",
            "    @pytest.mark.parametrize(\"folded\", [True, False])",
            "    def test_folded(self, folded):",
            "        section = PlotSection(",
            "            title=\"\",",
            "            content=\"\",",
            "            alt_text=\"some title\",",
            "            path=\"path/plot.png\",",
            "            folded=folded,",
            "        )",
            "        output = section.format()",
            "        if folded:",
            "            assert \"<details>\" in output",
            "        else:",
            "            assert \"<details>\" not in output",
            "",
            "    def test_add_with_description(self):",
            "        # FIXME",
            "        pass",
            "",
            "",
            "class TestTableSection:",
            "    @pytest.fixture",
            "    def table_dict(self):",
            "        return {\"split\": [1, 2, 3], \"score\": [4, 5, 6]}",
            "",
            "    def test_table_is_dict(self, table_dict):",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        expected = \"\"\"|   split |   score |",
            "|---------|---------|",
            "|       1 |       4 |",
            "|       2 |       5 |",
            "|       3 |       6 |\"\"\"",
            "        assert section.format() == expected",
            "",
            "    def test_table_is_dataframe(self, table_dict):",
            "        pd = pytest.importorskip(\"pandas\")",
            "        df = pd.DataFrame(table_dict)",
            "        section = TableSection(title=\"\", content=\"\", table=df)",
            "        expected = \"\"\"|   split |   score |",
            "|---------|---------|",
            "|       1 |       4 |",
            "|       2 |       5 |",
            "|       3 |       6 |\"\"\"",
            "        assert section.format() == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [str, repr])",
            "    def test_str_and_repr_table_is_dict(self, table_dict, meth):",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        expected = \"TableSection(3x2)\"",
            "        assert meth(section) == expected",
            "",
            "    @pytest.mark.parametrize(\"meth\", [str, repr])",
            "    def test_str_and_repr_table_is_dataframe(self, table_dict, meth):",
            "        pd = pytest.importorskip(\"pandas\")",
            "        df = pd.DataFrame(table_dict)",
            "        section = TableSection(title=\"\", content=\"\", table=df)",
            "        expected = \"TableSection(3x2)\"",
            "        assert meth(section) == expected",
            "",
            "    @pytest.mark.parametrize(\"table\", [{}, \"pandas\"])",
            "    def test_raise_error_empty_table(self, table):",
            "        # If there are no columns, raise",
            "        if table == \"pandas\":",
            "            pd = pytest.importorskip(\"pandas\")",
            "            table = pd.DataFrame([])",
            "",
            "        msg = \"Trying to add table with no columns\"",
            "        with pytest.raises(ValueError, match=msg):",
            "            TableSection(title=\"\", content=\"\", table=table)",
            "",
            "    @pytest.mark.parametrize(\"table\", [{\"col0\": []}, \"pandas\"])",
            "    def test_table_with_no_rows_works(self, table):",
            "        # If there are no rows, it's okay",
            "        if table == \"pandas\":",
            "            pd = pytest.importorskip(\"pandas\")",
            "            table = pd.DataFrame(data=[], columns=[\"col0\"])",
            "",
            "        TableSection(title=\"\", content=\"\", table=table).format()  # no error raised",
            "",
            "    def test_pandas_not_installed(self, table_dict, pandas_not_installed):",
            "        # use pandas_not_installed fixture from conftest.py to pretend that",
            "        # pandas is not installed",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        assert section._is_pandas_df is False",
            "",
            "    @pytest.mark.parametrize(\"folded\", [True, False])",
            "    def test_folded(self, table_dict, folded):",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict, folded=folded)",
            "        output = section.format()",
            "        if folded:",
            "            assert \"<details>\" in output",
            "        else:",
            "            assert \"<details>\" not in output",
            "",
            "    def test_line_break_in_entry(self, table_dict):",
            "        # Line breaks are not allowed inside markdown tables, so check that",
            "        # they're removed. We test 3 conditions here:",
            "",
            "        # 1. custom object with line breaks in repr",
            "        # 2. string with line break in the middle",
            "        # 3. string with line break at start, middle, and end",
            "",
            "        # Note that for the latter, tabulate will automatically strip the line",
            "        # breaks from the start and end.",
            "        class LineBreakInRepr:",
            "            \"\"\"Custom object whose repr has a line break\"\"\"",
            "",
            "            def __repr__(self) -> str:",
            "                return \"obj\\nwith lb\"",
            "",
            "        table_dict[\"with break\"] = [",
            "            LineBreakInRepr(),",
            "            \"hi\\nthere\",",
            "            \"\"\"",
            "entry with",
            "line breaks",
            "\"\"\",",
            "        ]",
            "        section = TableSection(title=\"\", content=\"\", table=table_dict)",
            "        expected = \"\"\"| split | score | with break |",
            "|-|-|-|",
            "| 1 | 4 | obj<br />with lb |",
            "| 2 | 5 | hi<br />there |",
            "| 3 | 6 | entry with<br />line breaks |\"\"\"",
            "",
            "        result = section.format()",
            "        # remove multiple whitespaces and dashes, as they're not important",
            "        result = _strip_multiple_chars(result, \" \")",
            "        result = _strip_multiple_chars(result, \"-\")",
            "        assert result == expected",
            "",
            "    def test_add_table_with_description(self, model_card, table_dict):",
            "        model_card.add_table(description=\"My fancy table\", **{\"The table\": table_dict})",
            "        section = model_card.select(\"The table\")",
            "        content = section.format()",
            "        expected = \"\"\"My fancy table",
            "",
            "|   split |   score |",
            "|---------|---------|",
            "|       1 |       4 |",
            "|       2 |       5 |",
            "|       3 |       6 |\"\"\"",
            "        assert content == expected",
            "",
            "",
            "class TestCustomTemplate:",
            "    @pytest.fixture",
            "    def template(self):",
            "        return {",
            "            \"My description\": \"An awesome model\",",
            "            \"Model\": \"Here goes model related stuff\",",
            "            \"Model/Metrics\": \"\",",
            "            \"Foo/Bar\": \"Baz\",",
            "        }",
            "",
            "    @pytest.fixture",
            "    def card(self, template):",
            "        model = fit_model()",
            "        card = Card(model, template=template)",
            "        return card",
            "",
            "    def test_add_model_plot(self, card):",
            "        card.add_model_plot(section=\"Model/Model plot\")",
            "        content = card.select(\"Model/Model plot\").format()",
            "        assert \"LinearRegression\" in content",
            "",
            "    def test_add_hyperparams(self, card):",
            "        card.add_hyperparams(section=\"Model/Hyperparams\")",
            "        content = card.select(\"Model/Hyperparams\").format()",
            "        assert \"fit_intercept\" in content",
            "",
            "    def test_add_metrics(self, card):",
            "        card.add_metrics(accuracy=0.1, section=\"Model/Metrics\")",
            "        content = card.select(\"Model/Metrics\").format()",
            "        assert \"accuracy\" in content",
            "        assert \"0.1\" in content",
            "",
            "    def test_add_get_started_code(self, card):",
            "        card.add_get_started_code(",
            "            section=\"Getting Started\",",
            "            file_name=\"foobar.skops\",",
            "            model_format=\"skops\",",
            "        )",
            "        content = card.select(\"Getting Started\").content",
            "        assert \"load\" in content",
            "",
            "    def test_custom_template_all_sections_present(self, template, card):",
            "        # model_card contains all default sections",
            "        for key in template:",
            "            card.select(key)",
            "",
            "        # no other top level sections as those defined in the template",
            "        expected = [\"My description\", \"Model\", \"Foo\"]",
            "        assert list(card._data.keys()) == expected",
            "",
            "",
            "class TestRenderedCardVisibility:",
            "    \"\"\"Check that visibility flag works",
            "",
            "    Sections that are not visible should not be rendered, neither when calling",
            "    model_card.render, nor when calling model_card.save.",
            "",
            "    \"\"\"",
            "",
            "    @pytest.fixture",
            "    def template(self):",
            "        return {",
            "            \"Model\": \"Here goes model related stuff\",",
            "            \"Model/Metrics\": \"123\",",
            "            \"Model/Bar\": \"Baz\",",
            "            \"Authors\": \"Jane Doe\",",
            "        }",
            "",
            "    @pytest.fixture",
            "    def card(self, template):",
            "        model = fit_model()",
            "        card = Card(model, template=template)",
            "        return card",
            "",
            "    def test_all_visible_by_default(self, card):",
            "        rendered = card.render()",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Metrics\\n\\n\"",
            "            \"123\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        assert rendered.strip() == expected",
            "",
            "    def test_section_invisible(self, card):",
            "        card.select(\"Model/Metrics\").visible = False",
            "        rendered = card.render()",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        assert rendered.strip() == expected",
            "",
            "    def test_restoring_visibility_works(self, card):",
            "        card.select(\"Model/Metrics\").visible = False",
            "        card.select(\"Model/Metrics\").visible = True",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Metrics\\n\\n\"",
            "            \"123\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        rendered = card.render()",
            "        assert rendered.strip() == expected",
            "",
            "    def test_invisible_parent_section_hides_subsections(self, card):",
            "        # By making the parent section \"Model\" invisible, all of the subsections",
            "        # are also turned invisible",
            "        card.select(\"Model\").visible = False",
            "        # fmt: off",
            "        expected = (",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        # fmt: on",
            "        rendered = card.render()",
            "        assert rendered.strip() == expected",
            "",
            "    def test_visibility_with_card_save(self, card):",
            "        # Since .save and .render share the same functionality, it's not",
            "        # necessary to repeat all the tests above with .save. Just do one test",
            "        # to ensure that the same functionality is indeed being used.",
            "        file = tempfile.mkstemp(suffix=\".md\", prefix=\"skops-model-card\")[1]",
            "        card.select(\"Model/Metrics\").visible = False",
            "        card.save(file)",
            "",
            "        with open(file, \"r\") as f:",
            "            loaded = f.read()",
            "",
            "        expected = (",
            "            \"# Model\\n\\n\"",
            "            \"Here goes model related stuff\\n\\n\"",
            "            \"## Bar\\n\\n\"",
            "            \"Baz\\n\\n\"",
            "            \"# Authors\\n\\n\"",
            "            \"Jane Doe\"",
            "        )",
            "        assert loaded.strip() == expected",
            "",
            "",
            "class TestAddFairlearnMetricFrame:",
            "    @pytest.fixture",
            "    def card(self):",
            "        model = LinearRegression()",
            "        card = Card(model=model)",
            "        return card",
            "",
            "    @pytest.fixture",
            "    def metric_frame(self):",
            "        metrics = import_or_raise(",
            "            \"fairlearn.metrics\", \"model card fairlearn metricframe\"",
            "        )",
            "",
            "        y_true = [1, 1, 1, 1, 1, 0, 0, 1, 1, 0]",
            "        y_pred = [0, 1, 1, 1, 1, 0, 0, 0, 1, 1]",
            "        sex = [\"Female\"] * 5 + [\"Male\"] * 5",
            "        metric_dict = {\"selection_rate\": metrics.selection_rate}",
            "        metric_frame = metrics.MetricFrame(",
            "            y_true=y_true, y_pred=y_pred, sensitive_features=sex, metrics=metric_dict",
            "        )",
            "        return metric_frame",
            "",
            "    @pytest.mark.parametrize(\"transpose\", [True, False])",
            "    def test_metric_table(self, card: Card, transpose, metric_frame):",
            "        card.add_fairlearn_metric_frame(",
            "            metric_frame=metric_frame,",
            "            transpose=transpose,",
            "            table_name=\"Metric Frame Table\",",
            "        )",
            "",
            "        actual_table = card.select(\"Metric Frame Table\").format()",
            "",
            "        if transpose is True:",
            "            expected_table = (",
            "                \"<details>\\n<summary> Click to expand </summary>\\n\\n|   selection_rate\"",
            "                \" |\\n|------------------|\\n|              0.4 |\\n|              0.8\"",
            "                \" |\\n|              0.4 |\\n|              0.5 |\\n\\n</details>\"",
            "            )",
            "        else:",
            "            expected_table = (",
            "                \"<details>\\n<summary> Click to expand </summary>\\n\\n|   difference |  \"",
            "                \" group_max |   group_min |   ratio\"",
            "                \" |\\n|--------------|-------------|-------------|---------|\\n|         \"",
            "                \" 0.4 |         0.8 |         0.4 |     0.5 |\\n\\n</details>\"",
            "            )",
            "",
            "        assert expected_table == actual_table",
            "",
            "    def test_metric_table_with_description(self, card: Card, metric_frame):",
            "        card.add_fairlearn_metric_frame(",
            "            description=\"An awesome table\",",
            "            metric_frame=metric_frame,",
            "            table_name=\"Metric Frame Table\",",
            "        )",
            "",
            "        actual_table = card.select(\"Metric Frame Table\").format()",
            "        expected_table = (",
            "            \"An awesome table\\n\\n\"",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\n|   selection_rate\"",
            "            \" |\\n|------------------|\\n|              0.4 |\\n|              0.8\"",
            "            \" |\\n|              0.4 |\\n|              0.5 |\\n\\n</details>\"",
            "        )",
            "        assert expected_table == actual_table",
            "",
            "",
            "class TestCardTableOfContents:",
            "    @pytest.fixture",
            "    def card(self):",
            "        model = LinearRegression()",
            "        card = Card(model=model)",
            "        card.add_model_plot()",
            "        card.add_hyperparams()",
            "        card.add_metrics(accuracy=0.1)",
            "        card.add_get_started_code()",
            "        return card",
            "",
            "    def test_toc(self, card):",
            "        toc = card.get_toc()",
            "        exptected_toc = [",
            "            \"- Model description\",",
            "            \"  - Intended uses & limitations\",",
            "            \"  - Training Procedure\",",
            "            \"    - Hyperparameters\",",
            "            \"    - Model Plot\",",
            "            \"  - Evaluation Results\",",
            "            \"- How to Get Started with the Model\",",
            "            \"- Model Card Authors\",",
            "            \"- Model Card Contact\",",
            "            \"- Citation\",",
            "        ]",
            "",
            "        assert toc == \"\\n\".join(exptected_toc)",
            "",
            "    def test_toc_with_invisible_section(self, card):",
            "        section = card.select(\"Citation\")",
            "        section.visible = False",
            "        toc = card.get_toc()",
            "        exptected_toc = [",
            "            \"- Model description\",",
            "            \"  - Intended uses & limitations\",",
            "            \"  - Training Procedure\",",
            "            \"    - Hyperparameters\",",
            "            \"    - Model Plot\",",
            "            \"  - Evaluation Results\",",
            "            \"- How to Get Started with the Model\",",
            "            \"- Model Card Authors\",",
            "            \"- Model Card Contact\",",
            "        ]",
            "",
            "        assert toc == \"\\n\".join(exptected_toc)",
            "",
            "",
            "class TestFoldedSection:",
            "    def test_folded_section(self, destination_path, model_card):",
            "        model_card.add(foo=\"Foo\")",
            "        model_card.add(**{\"foo/bar\": \"Foo/Bar\", \"foo/baz\": \"Foo/Baz\"})",
            "        model_card.select(\"foo/baz\").folded = True",
            "",
            "        foo_details = (",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\nFoo\\n\\n</details>\\n\"",
            "        )",
            "        foo_bar_details = (",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\nFoo/Bar\\n\\n</details>\\n\"",
            "        )",
            "        foo_baz_details = (",
            "            \"<details>\\n<summary> Click to expand </summary>\\n\\nFoo/Baz\\n\\n</details>\\n\"",
            "        )",
            "",
            "        output = model_card.render()",
            "        assert foo_details not in output",
            "        assert foo_bar_details not in output",
            "        assert foo_baz_details in output",
            "",
            "        model_card.select(\"foo\").folded = True",
            "",
            "        output = model_card.render()",
            "        assert foo_details in output",
            "        assert foo_bar_details not in output",
            "        assert foo_baz_details not in output",
            "",
            "        model_card.select(\"foo\").folded = False",
            "",
            "        output = model_card.render()",
            "        assert foo_details not in output",
            "        assert foo_bar_details not in output",
            "        assert foo_baz_details in output",
            "",
            "        model_card.select(\"foo/bar\").folded = True",
            "        model_card.select(\"foo/baz\").folded = False",
            "",
            "        output = model_card.render()",
            "        assert foo_details not in output",
            "        assert foo_bar_details in output",
            "        assert foo_baz_details not in output",
            "",
            "",
            "class TestCardSaveWithPlots:",
            "    def test_copy_plots(self, destination_path, model_card):",
            "        import matplotlib.pyplot as plt",
            "",
            "        with tempfile.TemporaryDirectory(prefix=\"skops-test-plots\") as plot_path:",
            "            plt.plot([4, 5, 6, 7])",
            "            fig_1_path = Path(plot_path) / \"fig1.png\"",
            "            plt.savefig(fig_1_path)",
            "            model_card = model_card.add_plot(fig1=fig_1_path)",
            "",
            "            plt.plot([7, 6, 5, 4])",
            "            fig_2_path = \"fig2.png\"",
            "            plt.savefig(fig_2_path)",
            "            model_card = model_card.add_plot(fig2=fig_2_path)",
            "",
            "            model_card.save(Path(destination_path) / \"README.md\", copy_files=True)",
            "",
            "        assert (Path(destination_path) / \"README.md\").exists()",
            "        assert (Path(destination_path) / \"fig1.png\").exists()",
            "        assert (Path(destination_path) / \"fig2.png\").exists()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [],
            "54": [
                "test_load_model"
            ],
            "56": [
                "test_load_model"
            ],
            "57": [
                "test_load_model"
            ],
            "1386": [
                "TestCardModelAttributeIsPath",
                "path_to_card"
            ],
            "1387": [
                "TestCardModelAttributeIsPath",
                "path_to_card"
            ],
            "1400": [
                "TestCardModelAttributeIsPath",
                "test_model_card_repr"
            ]
        },
        "addLocation": []
    },
    "skops/cli/_update.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from pathlib import Path"
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from skops.cli._utils import get_log_level"
            },
            "3": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from skops.io import dump, load"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from skops.io import dump, get_untrusted_types, load"
            },
            "5": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from skops.io._protocol import PROTOCOL"
            },
            "6": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "                 \" file.\""
            },
            "9": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             )"
            },
            "10": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    input_model = load(input_file, trusted=True)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    input_model = load(input_file, trusted=get_untrusted_types(file=input_file))"
            },
            "13": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     with zipfile.ZipFile(input_file, \"r\") as zip_file:"
            },
            "14": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         input_file_schema = json.loads(zip_file.read(\"schema.json\"))"
            },
            "15": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import argparse",
            "import json",
            "import logging",
            "import shutil",
            "import tempfile",
            "import zipfile",
            "from pathlib import Path",
            "",
            "from skops.cli._utils import get_log_level",
            "from skops.io import dump, load",
            "from skops.io._protocol import PROTOCOL",
            "",
            "",
            "def _update_file(",
            "    input_file: str | Path,",
            "    output_file: str | Path | None = None,",
            "    inplace: bool = False,",
            "    logger: logging.Logger = logging.getLogger(),",
            ") -> None:",
            "    \"\"\"Function that is called by ``skops update`` entrypoint.",
            "",
            "    Loads a skops model from the input path, updates it to the current skops format, and",
            "    saves to an output file. It will overwrite the input file if `inplace` is True.",
            "",
            "    Parameters",
            "    ----------",
            "    input_file : str, or Path",
            "        Path of input skops model to load.",
            "",
            "    output_file : str, or Path, default=None",
            "        Path to save the updated skops model to.",
            "",
            "    inplace : bool, default=False",
            "        Whether to update and overwrite the input file in place.",
            "",
            "    logger : logging.Logger, default=logging.getLogger()",
            "        Logger to use for logging.",
            "    \"\"\"",
            "    if inplace:",
            "        if output_file is None:",
            "            output_file = input_file",
            "        else:",
            "            raise ValueError(",
            "                \"Cannot specify both an output file path and the inplace flag. Please\"",
            "                \" choose whether you want to create a new file or overwrite the input\"",
            "                \" file.\"",
            "            )",
            "",
            "    input_model = load(input_file, trusted=True)",
            "    with zipfile.ZipFile(input_file, \"r\") as zip_file:",
            "        input_file_schema = json.loads(zip_file.read(\"schema.json\"))",
            "",
            "    if input_file_schema[\"protocol\"] == PROTOCOL:",
            "        logger.warning(",
            "            \"File was not updated because already up to date with the current protocol:\"",
            "            f\" {PROTOCOL}\"",
            "        )",
            "        return None",
            "",
            "    if input_file_schema[\"protocol\"] > PROTOCOL:",
            "        logger.warning(",
            "            \"File cannot be updated because its protocol is more recent than the \"",
            "            f\"current protocol: {PROTOCOL}\"",
            "        )",
            "        return None",
            "",
            "    if output_file is None:",
            "        logger.warning(",
            "            f\"File can be updated to the current protocol: {PROTOCOL}. Please\"",
            "            \" specify an output file path or use the `inplace` flag to create the\"",
            "            \" updated Skops file.\"",
            "        )",
            "        return None",
            "",
            "    with tempfile.TemporaryDirectory() as tmp_dir:",
            "        tmp_output_file = Path(tmp_dir) / f\"{output_file}.tmp\"",
            "        dump(input_model, tmp_output_file)",
            "        shutil.move(str(tmp_output_file), str(output_file))",
            "    logger.info(f\"Updated skops file written to {output_file}\")",
            "",
            "",
            "def format_parser(",
            "    parser: argparse.ArgumentParser | None = None,",
            ") -> argparse.ArgumentParser:",
            "    \"\"\"Adds arguments and help to parent CLI parser for the `update` method.\"\"\"",
            "",
            "    if not parser:  # used in tests",
            "        parser = argparse.ArgumentParser()",
            "",
            "    parser_subgroup = parser.add_argument_group(\"update\")",
            "    parser_subgroup.add_argument(\"input\", help=\"Path to an input file to update.\")",
            "",
            "    parser_subgroup.add_argument(",
            "        \"-o\",",
            "        \"--output-file\",",
            "        help=\"Specify the output file name for the updated skops file.\",",
            "        default=None,",
            "    )",
            "    parser_subgroup.add_argument(",
            "        \"--inplace\",",
            "        help=\"Update and overwrite the input file in place.\",",
            "        action=\"store_true\",",
            "    )",
            "    parser_subgroup.add_argument(",
            "        \"-v\",",
            "        \"--verbose\",",
            "        help=(",
            "            \"Increases verbosity of logging. Can be used multiple times to increase \"",
            "            \"verbosity further.\"",
            "        ),",
            "        action=\"count\",",
            "        dest=\"loglevel\",",
            "        default=0,",
            "    )",
            "    return parser",
            "",
            "",
            "def main(",
            "    parsed_args: argparse.Namespace,",
            "    logger: logging.Logger = logging.getLogger(),",
            ") -> None:",
            "    output_file = Path(parsed_args.output_file) if parsed_args.output_file else None",
            "    input_file = Path(parsed_args.input)",
            "    inplace = parsed_args.inplace",
            "",
            "    logging.basicConfig(format=\"%(levelname)-8s: %(message)s\")",
            "    logger.setLevel(level=get_log_level(parsed_args.loglevel))",
            "",
            "    _update_file(",
            "        input_file=input_file,",
            "        output_file=output_file,",
            "        inplace=inplace,",
            "        logger=logger,",
            "    )"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import argparse",
            "import json",
            "import logging",
            "import shutil",
            "import tempfile",
            "import zipfile",
            "from pathlib import Path",
            "",
            "from skops.cli._utils import get_log_level",
            "from skops.io import dump, get_untrusted_types, load",
            "from skops.io._protocol import PROTOCOL",
            "",
            "",
            "def _update_file(",
            "    input_file: str | Path,",
            "    output_file: str | Path | None = None,",
            "    inplace: bool = False,",
            "    logger: logging.Logger = logging.getLogger(),",
            ") -> None:",
            "    \"\"\"Function that is called by ``skops update`` entrypoint.",
            "",
            "    Loads a skops model from the input path, updates it to the current skops format, and",
            "    saves to an output file. It will overwrite the input file if `inplace` is True.",
            "",
            "    Parameters",
            "    ----------",
            "    input_file : str, or Path",
            "        Path of input skops model to load.",
            "",
            "    output_file : str, or Path, default=None",
            "        Path to save the updated skops model to.",
            "",
            "    inplace : bool, default=False",
            "        Whether to update and overwrite the input file in place.",
            "",
            "    logger : logging.Logger, default=logging.getLogger()",
            "        Logger to use for logging.",
            "    \"\"\"",
            "    if inplace:",
            "        if output_file is None:",
            "            output_file = input_file",
            "        else:",
            "            raise ValueError(",
            "                \"Cannot specify both an output file path and the inplace flag. Please\"",
            "                \" choose whether you want to create a new file or overwrite the input\"",
            "                \" file.\"",
            "            )",
            "",
            "    input_model = load(input_file, trusted=get_untrusted_types(file=input_file))",
            "    with zipfile.ZipFile(input_file, \"r\") as zip_file:",
            "        input_file_schema = json.loads(zip_file.read(\"schema.json\"))",
            "",
            "    if input_file_schema[\"protocol\"] == PROTOCOL:",
            "        logger.warning(",
            "            \"File was not updated because already up to date with the current protocol:\"",
            "            f\" {PROTOCOL}\"",
            "        )",
            "        return None",
            "",
            "    if input_file_schema[\"protocol\"] > PROTOCOL:",
            "        logger.warning(",
            "            \"File cannot be updated because its protocol is more recent than the \"",
            "            f\"current protocol: {PROTOCOL}\"",
            "        )",
            "        return None",
            "",
            "    if output_file is None:",
            "        logger.warning(",
            "            f\"File can be updated to the current protocol: {PROTOCOL}. Please\"",
            "            \" specify an output file path or use the `inplace` flag to create the\"",
            "            \" updated Skops file.\"",
            "        )",
            "        return None",
            "",
            "    with tempfile.TemporaryDirectory() as tmp_dir:",
            "        tmp_output_file = Path(tmp_dir) / f\"{output_file}.tmp\"",
            "        dump(input_model, tmp_output_file)",
            "        shutil.move(str(tmp_output_file), str(output_file))",
            "    logger.info(f\"Updated skops file written to {output_file}\")",
            "",
            "",
            "def format_parser(",
            "    parser: argparse.ArgumentParser | None = None,",
            ") -> argparse.ArgumentParser:",
            "    \"\"\"Adds arguments and help to parent CLI parser for the `update` method.\"\"\"",
            "",
            "    if not parser:  # used in tests",
            "        parser = argparse.ArgumentParser()",
            "",
            "    parser_subgroup = parser.add_argument_group(\"update\")",
            "    parser_subgroup.add_argument(\"input\", help=\"Path to an input file to update.\")",
            "",
            "    parser_subgroup.add_argument(",
            "        \"-o\",",
            "        \"--output-file\",",
            "        help=\"Specify the output file name for the updated skops file.\",",
            "        default=None,",
            "    )",
            "    parser_subgroup.add_argument(",
            "        \"--inplace\",",
            "        help=\"Update and overwrite the input file in place.\",",
            "        action=\"store_true\",",
            "    )",
            "    parser_subgroup.add_argument(",
            "        \"-v\",",
            "        \"--verbose\",",
            "        help=(",
            "            \"Increases verbosity of logging. Can be used multiple times to increase \"",
            "            \"verbosity further.\"",
            "        ),",
            "        action=\"count\",",
            "        dest=\"loglevel\",",
            "        default=0,",
            "    )",
            "    return parser",
            "",
            "",
            "def main(",
            "    parsed_args: argparse.Namespace,",
            "    logger: logging.Logger = logging.getLogger(),",
            ") -> None:",
            "    output_file = Path(parsed_args.output_file) if parsed_args.output_file else None",
            "    input_file = Path(parsed_args.input)",
            "    inplace = parsed_args.inplace",
            "",
            "    logging.basicConfig(format=\"%(levelname)-8s: %(message)s\")",
            "    logger.setLevel(level=get_log_level(parsed_args.loglevel))",
            "",
            "    _update_file(",
            "        input_file=input_file,",
            "        output_file=output_file,",
            "        inplace=inplace,",
            "        logger=logger,",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "12": [],
            "51": [
                "_update_file"
            ]
        },
        "addLocation": []
    },
    "skops/cli/tests/test_convert.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import pytest"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from skops.cli import _convert"
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from skops.io import load"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from skops.io import get_untrusted_types, load"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " class MockUnsafeType:"
            },
            "8": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     ):"
            },
            "9": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         caplog.set_level(logging.WARNING)"
            },
            "10": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         _convert._convert_file(pkl_path, skops_path)"
            },
            "11": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        persisted_obj = load(skops_path, trusted=True)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        persisted_obj = load(skops_path, trusted=get_untrusted_types(file=skops_path))"
            },
            "13": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         assert isinstance(persisted_obj, MockUnsafeType)"
            },
            "15": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import logging",
            "import pathlib",
            "import pickle",
            "from unittest import mock",
            "",
            "import numpy as np",
            "import pytest",
            "",
            "from skops.cli import _convert",
            "from skops.io import load",
            "",
            "",
            "class MockUnsafeType:",
            "    def __init__(self):",
            "        pass",
            "",
            "",
            "class TestConvert:",
            "    model_name = \"some_model_name\"",
            "",
            "    @pytest.fixture",
            "    def safe_obj(self):",
            "        return np.ndarray([1, 2, 3, 4])",
            "",
            "    @pytest.fixture",
            "    def unsafe_obj(self):",
            "        return MockUnsafeType()",
            "",
            "    @pytest.fixture",
            "    def pkl_path(self, tmp_path):",
            "        return tmp_path / f\"{self.model_name}.pkl\"",
            "",
            "    @pytest.fixture",
            "    def skops_path(self, tmp_path):",
            "        return tmp_path / f\"{self.model_name}.skops\"",
            "",
            "    @pytest.fixture",
            "    def write_safe_file(self, pkl_path, safe_obj):",
            "        with open(pkl_path, \"wb\") as f:",
            "            pickle.dump(safe_obj, f)",
            "",
            "    @pytest.fixture",
            "    def write_unsafe_file(self, pkl_path, unsafe_obj):",
            "        with open(pkl_path, \"wb\") as f:",
            "            pickle.dump(unsafe_obj, f)",
            "",
            "    def test_base_case_works_as_expected(",
            "        self, pkl_path, tmp_path, skops_path, write_safe_file, safe_obj, caplog",
            "    ):",
            "        mock_logger = mock.MagicMock()",
            "        _convert._convert_file(pkl_path, skops_path, logger=mock_logger)",
            "        persisted_obj = load(skops_path)",
            "        assert np.array_equal(persisted_obj, safe_obj)",
            "",
            "        # Check no warnings or errors raised",
            "        mock_logger.warning.assert_not_called()",
            "        mock_logger.error.assert_not_called()",
            "",
            "    def test_unsafe_case_works_as_expected(",
            "        self, pkl_path, tmp_path, skops_path, write_unsafe_file, caplog",
            "    ):",
            "        caplog.set_level(logging.WARNING)",
            "        _convert._convert_file(pkl_path, skops_path)",
            "        persisted_obj = load(skops_path, trusted=True)",
            "",
            "        assert isinstance(persisted_obj, MockUnsafeType)",
            "",
            "        # check logging has warned that an unsafe type was found",
            "        assert MockUnsafeType.__name__ in caplog.text",
            "",
            "",
            "class TestMain:",
            "    @staticmethod",
            "    def assert_called_correctly(",
            "        mock_convert: mock.MagicMock,",
            "        path,",
            "        output_file=None,",
            "    ):",
            "        if not output_file:",
            "            output_file = pathlib.Path.cwd() / f\"{pathlib.Path(path).stem}.skops\"",
            "        mock_convert.assert_called_once_with(input_file=path, output_file=output_file)",
            "",
            "    @mock.patch(\"skops.cli._convert._convert_file\")",
            "    def test_base_works_as_expected(self, mock_convert: mock.MagicMock):",
            "        path = \"123.pkl\"",
            "        namespace, _ = _convert.format_parser().parse_known_args([path])",
            "",
            "        _convert.main(namespace)",
            "        self.assert_called_correctly(mock_convert, path)",
            "",
            "    @mock.patch(\"skops.cli._convert._convert_file\")",
            "    @pytest.mark.parametrize(",
            "        \"input_path, output_file, expected_path\",",
            "        [",
            "            (\"abc.123\", \"some/file/path.out\", \"some/file/path.out\"),",
            "            (\"abc.123\", None, pathlib.Path.cwd() / \"abc.skops\"),",
            "        ],",
            "        ids=[\"Given an output path\", \"No output path\"],",
            "    )",
            "    def test_with_output_dir_works_as_expected(",
            "        self, mock_convert: mock.MagicMock, input_path, output_file, expected_path",
            "    ):",
            "        if output_file is not None:",
            "            args = [input_path, \"--output\", output_file]",
            "        else:",
            "            args = [input_path]",
            "",
            "        namespace, _ = _convert.format_parser().parse_known_args(args)",
            "",
            "        _convert.main(namespace)",
            "        self.assert_called_correctly(",
            "            mock_convert, path=input_path, output_file=expected_path",
            "        )",
            "",
            "    @mock.patch(\"skops.cli._convert._convert_file\")",
            "    @pytest.mark.parametrize(",
            "        \"verbosity, expected_level\",",
            "        [",
            "            (\"\", logging.WARNING),",
            "            (\"-v\", logging.INFO),",
            "            (\"--verbose\", logging.INFO),",
            "            (\"-vv\", logging.DEBUG),",
            "            (\"-v -v\", logging.DEBUG),",
            "            (\"-vvvvv\", logging.DEBUG),",
            "            (\"--verbose --verbose\", logging.DEBUG),",
            "        ],",
            "    )",
            "    def test_given_log_levels_works_as_expected(",
            "        self, mock_convert: mock.MagicMock, verbosity, expected_level, caplog",
            "    ):",
            "        input_path = \"abc.def\"",
            "        output_path = \"bde.skops\"",
            "        args = [input_path, \"--output\", output_path, verbosity.split()]",
            "",
            "        namespace, _ = _convert.format_parser().parse_known_args(args)",
            "",
            "        _convert.main(namespace)",
            "        self.assert_called_correctly(",
            "            mock_convert, path=input_path, output_file=output_path",
            "        )",
            "",
            "        assert caplog.at_level(expected_level)"
        ],
        "afterPatchFile": [
            "import logging",
            "import pathlib",
            "import pickle",
            "from unittest import mock",
            "",
            "import numpy as np",
            "import pytest",
            "",
            "from skops.cli import _convert",
            "from skops.io import get_untrusted_types, load",
            "",
            "",
            "class MockUnsafeType:",
            "    def __init__(self):",
            "        pass",
            "",
            "",
            "class TestConvert:",
            "    model_name = \"some_model_name\"",
            "",
            "    @pytest.fixture",
            "    def safe_obj(self):",
            "        return np.ndarray([1, 2, 3, 4])",
            "",
            "    @pytest.fixture",
            "    def unsafe_obj(self):",
            "        return MockUnsafeType()",
            "",
            "    @pytest.fixture",
            "    def pkl_path(self, tmp_path):",
            "        return tmp_path / f\"{self.model_name}.pkl\"",
            "",
            "    @pytest.fixture",
            "    def skops_path(self, tmp_path):",
            "        return tmp_path / f\"{self.model_name}.skops\"",
            "",
            "    @pytest.fixture",
            "    def write_safe_file(self, pkl_path, safe_obj):",
            "        with open(pkl_path, \"wb\") as f:",
            "            pickle.dump(safe_obj, f)",
            "",
            "    @pytest.fixture",
            "    def write_unsafe_file(self, pkl_path, unsafe_obj):",
            "        with open(pkl_path, \"wb\") as f:",
            "            pickle.dump(unsafe_obj, f)",
            "",
            "    def test_base_case_works_as_expected(",
            "        self, pkl_path, tmp_path, skops_path, write_safe_file, safe_obj, caplog",
            "    ):",
            "        mock_logger = mock.MagicMock()",
            "        _convert._convert_file(pkl_path, skops_path, logger=mock_logger)",
            "        persisted_obj = load(skops_path)",
            "        assert np.array_equal(persisted_obj, safe_obj)",
            "",
            "        # Check no warnings or errors raised",
            "        mock_logger.warning.assert_not_called()",
            "        mock_logger.error.assert_not_called()",
            "",
            "    def test_unsafe_case_works_as_expected(",
            "        self, pkl_path, tmp_path, skops_path, write_unsafe_file, caplog",
            "    ):",
            "        caplog.set_level(logging.WARNING)",
            "        _convert._convert_file(pkl_path, skops_path)",
            "        persisted_obj = load(skops_path, trusted=get_untrusted_types(file=skops_path))",
            "",
            "        assert isinstance(persisted_obj, MockUnsafeType)",
            "",
            "        # check logging has warned that an unsafe type was found",
            "        assert MockUnsafeType.__name__ in caplog.text",
            "",
            "",
            "class TestMain:",
            "    @staticmethod",
            "    def assert_called_correctly(",
            "        mock_convert: mock.MagicMock,",
            "        path,",
            "        output_file=None,",
            "    ):",
            "        if not output_file:",
            "            output_file = pathlib.Path.cwd() / f\"{pathlib.Path(path).stem}.skops\"",
            "        mock_convert.assert_called_once_with(input_file=path, output_file=output_file)",
            "",
            "    @mock.patch(\"skops.cli._convert._convert_file\")",
            "    def test_base_works_as_expected(self, mock_convert: mock.MagicMock):",
            "        path = \"123.pkl\"",
            "        namespace, _ = _convert.format_parser().parse_known_args([path])",
            "",
            "        _convert.main(namespace)",
            "        self.assert_called_correctly(mock_convert, path)",
            "",
            "    @mock.patch(\"skops.cli._convert._convert_file\")",
            "    @pytest.mark.parametrize(",
            "        \"input_path, output_file, expected_path\",",
            "        [",
            "            (\"abc.123\", \"some/file/path.out\", \"some/file/path.out\"),",
            "            (\"abc.123\", None, pathlib.Path.cwd() / \"abc.skops\"),",
            "        ],",
            "        ids=[\"Given an output path\", \"No output path\"],",
            "    )",
            "    def test_with_output_dir_works_as_expected(",
            "        self, mock_convert: mock.MagicMock, input_path, output_file, expected_path",
            "    ):",
            "        if output_file is not None:",
            "            args = [input_path, \"--output\", output_file]",
            "        else:",
            "            args = [input_path]",
            "",
            "        namespace, _ = _convert.format_parser().parse_known_args(args)",
            "",
            "        _convert.main(namespace)",
            "        self.assert_called_correctly(",
            "            mock_convert, path=input_path, output_file=expected_path",
            "        )",
            "",
            "    @mock.patch(\"skops.cli._convert._convert_file\")",
            "    @pytest.mark.parametrize(",
            "        \"verbosity, expected_level\",",
            "        [",
            "            (\"\", logging.WARNING),",
            "            (\"-v\", logging.INFO),",
            "            (\"--verbose\", logging.INFO),",
            "            (\"-vv\", logging.DEBUG),",
            "            (\"-v -v\", logging.DEBUG),",
            "            (\"-vvvvv\", logging.DEBUG),",
            "            (\"--verbose --verbose\", logging.DEBUG),",
            "        ],",
            "    )",
            "    def test_given_log_levels_works_as_expected(",
            "        self, mock_convert: mock.MagicMock, verbosity, expected_level, caplog",
            "    ):",
            "        input_path = \"abc.def\"",
            "        output_path = \"bde.skops\"",
            "        args = [input_path, \"--output\", output_path, verbosity.split()]",
            "",
            "        namespace, _ = _convert.format_parser().parse_known_args(args)",
            "",
            "        _convert.main(namespace)",
            "        self.assert_called_correctly(",
            "            mock_convert, path=input_path, output_file=output_path",
            "        )",
            "",
            "        assert caplog.at_level(expected_level)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": [],
            "64": [
                "TestConvert",
                "test_unsafe_case_works_as_expected"
            ]
        },
        "addLocation": []
    },
    "skops/io/_audit.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import io"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from contextlib import contextmanager"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any, Dict, Generator, List, Literal, Optional, Sequence, Type, Union"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from typing import Any, Dict, Generator, List, Optional, Sequence, Type, Union"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from ._protocol import PROTOCOL"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ._utils import LoadContext, get_module, get_type_paths"
            },
            "8": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " ]"
            },
            "9": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def check_type("
            },
            "12": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    module_name: str, type_name: str, trusted: Literal[True] | Sequence[str]"
            },
            "13": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-) -> bool:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+def check_type(module_name: str, type_name: str, trusted: Sequence[str]) -> bool:"
            },
            "15": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     \"\"\"Check if a type is safe to load."
            },
            "16": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     A type is safe to load only if it's present in the trusted list."
            },
            "18": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     is_safe : bool"
            },
            "19": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         True if the type is safe, False otherwise."
            },
            "20": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "     \"\"\""
            },
            "21": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if trusted is True:"
            },
            "22": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return True"
            },
            "23": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     return module_name + \".\" + type_name in trusted"
            },
            "24": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " def audit_tree(tree: Node) -> None:"
            },
            "27": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     \"\"\"Audit a tree of nodes."
            },
            "28": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    A tree is safe if it only contains trusted types. Audit is skipped if"
            },
            "30": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    trusted is ``True``."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    A tree is safe if it only contains trusted types."
            },
            "32": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     Parameters"
            },
            "34": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     ----------"
            },
            "35": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     UntrustedTypesFoundException"
            },
            "36": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         If the tree contains an untrusted type."
            },
            "37": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     \"\"\""
            },
            "38": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if tree.trusted is True:"
            },
            "39": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return"
            },
            "40": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "41": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     unsafe = tree.get_unsafe_set()"
            },
            "42": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     if unsafe:"
            },
            "43": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         raise UntrustedTypesFoundException(unsafe)"
            },
            "44": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         self,"
            },
            "45": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         state: dict[str, Any],"
            },
            "46": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         load_context: LoadContext,"
            },
            "47": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        trusted: bool | Sequence[str] = False,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        trusted: Optional[Sequence[str]] = None,"
            },
            "49": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         memoize: bool = True,"
            },
            "50": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     ) -> None:"
            },
            "51": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         self.class_name, self.module_name = state[\"__class__\"], state[\"__module__\"]"
            },
            "52": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     @staticmethod"
            },
            "54": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     def _get_trusted("
            },
            "55": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        trusted: bool | Sequence[Union[str, Type]], default: Sequence[Union[str, Type]]"
            },
            "56": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ) -> Literal[True] | list[str]:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        trusted: Optional[Sequence[Union[str, Type]]],"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        default: Sequence[Union[str, Type]],"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    ) -> list[str]:"
            },
            "60": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         \"\"\"Return a trusted list, or True."
            },
            "61": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        If ``trusted`` is ``False``, we return the ``default``. If a list of"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        If ``trusted`` is ``None``, we return the ``default``. If a list of"
            },
            "64": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         types are being passed, those types, as well as default trusted types,"
            },
            "65": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         are returned."
            },
            "66": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         This is a convenience method called by child classes."
            },
            "68": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         \"\"\""
            },
            "70": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if trusted is True:"
            },
            "71": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # if trusted is True, we trust the node"
            },
            "72": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return True"
            },
            "73": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "74": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if trusted is False:"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        if trusted is None:"
            },
            "76": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "             # if trusted is False, we only trust the defaults"
            },
            "77": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             return get_type_paths(default)"
            },
            "78": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 190,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         self,"
            },
            "80": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         state: dict[str, Any],"
            },
            "81": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 280,
                "PatchRowcode": "         load_context: LoadContext,"
            },
            "82": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        trusted: bool = False,"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+        trusted: Optional[List[str]] = None,"
            },
            "84": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "     ):"
            },
            "85": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         # we pass memoize as False because we don't want to memoize the cached"
            },
            "86": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "         # node."
            },
            "87": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "         super().__init__(state, load_context, trusted, memoize=False)"
            },
            "88": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.trusted = True"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        self.trusted = self._get_trusted(trusted, default=[])"
            },
            "90": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         # TODO: deal with case that __id__ is unknown or prevent it from"
            },
            "91": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "         # happening"
            },
            "92": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         self.cached = load_context.get_object(state.get(\"__id__\"))  # type: ignore"
            },
            "93": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 302,
                "PatchRowcode": " def get_tree("
            },
            "94": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "     state: dict[str, Any],"
            },
            "95": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "     load_context: LoadContext,"
            },
            "96": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    trusted: bool | Sequence[str],"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+    trusted: Optional[Sequence[str]],"
            },
            "98": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 306,
                "PatchRowcode": " ) -> Node:"
            },
            "99": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     \"\"\"Get the tree of nodes."
            },
            "100": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 308,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import io",
            "from contextlib import contextmanager",
            "from typing import Any, Dict, Generator, List, Literal, Optional, Sequence, Type, Union",
            "",
            "from ._protocol import PROTOCOL",
            "from ._utils import LoadContext, get_module, get_type_paths",
            "from .exceptions import UntrustedTypesFoundException",
            "",
            "NODE_TYPE_MAPPING: dict[tuple[str, int], Type[Node]] = {}",
            "VALID_NODE_CHILD_TYPES = Optional[",
            "    Union[\"Node\", List[\"Node\"], Dict[str, \"Node\"], Type, str, io.BytesIO]",
            "]",
            "",
            "",
            "def check_type(",
            "    module_name: str, type_name: str, trusted: Literal[True] | Sequence[str]",
            ") -> bool:",
            "    \"\"\"Check if a type is safe to load.",
            "",
            "    A type is safe to load only if it's present in the trusted list.",
            "",
            "    Parameters",
            "    ----------",
            "    module_name : str",
            "        The module name of the type.",
            "",
            "    type_name : str",
            "        The class name of the type.",
            "",
            "    trusted : True, or list of str",
            "        If ``True``, the tree is considered safe. Otherwise trusted has to be",
            "        a list of trusted types.",
            "",
            "    Returns",
            "    -------",
            "    is_safe : bool",
            "        True if the type is safe, False otherwise.",
            "    \"\"\"",
            "    if trusted is True:",
            "        return True",
            "    return module_name + \".\" + type_name in trusted",
            "",
            "",
            "def audit_tree(tree: Node) -> None:",
            "    \"\"\"Audit a tree of nodes.",
            "",
            "    A tree is safe if it only contains trusted types. Audit is skipped if",
            "    trusted is ``True``.",
            "",
            "    Parameters",
            "    ----------",
            "    tree : skops.io._dispatch.Node",
            "        The tree to audit.",
            "",
            "    Raises",
            "    ------",
            "    UntrustedTypesFoundException",
            "        If the tree contains an untrusted type.",
            "    \"\"\"",
            "    if tree.trusted is True:",
            "        return",
            "",
            "    unsafe = tree.get_unsafe_set()",
            "    if unsafe:",
            "        raise UntrustedTypesFoundException(unsafe)",
            "",
            "",
            "class UNINITIALIZED:",
            "    \"\"\"Sentinel value to indicate that a value has not been initialized yet.\"\"\"",
            "",
            "",
            "# Node: types for Generator mean: YieldType, SendType, ReturnType",
            "@contextmanager",
            "def temp_setattr(obj: Any, **kwargs: Any) -> Generator[None, None, None]:",
            "    \"\"\"Context manager to temporarily set attributes on an object.\"\"\"",
            "    existing_attrs = {k for k in kwargs.keys() if hasattr(obj, k)}",
            "    previous_values = {k: getattr(obj, k, None) for k in kwargs}",
            "    for k, v in kwargs.items():",
            "        setattr(obj, k, v)",
            "    try:",
            "        yield",
            "    finally:",
            "        for k, v in previous_values.items():",
            "            if k in existing_attrs:",
            "                setattr(obj, k, v)",
            "            else:",
            "                delattr(obj, k)",
            "",
            "",
            "class Node:",
            "    \"\"\"A node in the tree of objects.",
            "",
            "    This class is a parent class for all nodes in the tree of objects. Each",
            "    type of object (e.g. dict, list, etc.) has its own subclass of Node.",
            "",
            "    Each child class has to implement two methods: ``__init__`` and",
            "    ``_construct``.",
            "",
            "    ``__init__`` takes care of traversing the state tree and to create the",
            "    corresponding ``Node`` objects. It has access to the ``load_context`` which",
            "    in turn has access to the source zip file. The child class's ``__init__``",
            "    must load attributes into the ``children`` attribute, which is a",
            "    dictionary of ``{child_name: unloaded_value/Node/list/etc}``. The",
            "    ``get_unsafe_set`` should be able to parse and validate the values set",
            "    under the ``children`` attribute. Note that primitives are persisted as a",
            "    ``JsonNode``.",
            "",
            "    ``_construct`` takes care of constructing the object. It is only called",
            "    once and the result is cached in ``construct`` which is implemented in this",
            "    class. All required data to construct an instance should be loaded during",
            "    ``__init__``.",
            "",
            "    The separation of ``__init__`` and ``_construct`` is necessary because",
            "    audit methods are called after ``__init__`` and before ``construct``.",
            "    Therefore ``__init__`` should avoid creating any instances or importing",
            "    any modules, to avoid running potentially untrusted code.",
            "",
            "    Parameters",
            "    ----------",
            "    state : dict",
            "        A dict representing the state of the dumped object.",
            "",
            "    load_context : LoadContext",
            "        The context of the loading process.",
            "",
            "    trusted : bool or list of str, default=False",
            "        If ``True``, the object will be loaded without any security checks. If",
            "        ``False``, the object will be loaded only if there are only trusted",
            "        objects in the dumped file. If a list of strings, the object will be",
            "        loaded only if all of its required types are listed in ``trusted``",
            "        or are trusted by default.",
            "",
            "    memoize : bool, default=True",
            "        If ``True``, the object will be memoized in the load context, if it has",
            "        the ``__id__`` set. This is used to avoid loading the same object",
            "        multiple times.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        state: dict[str, Any],",
            "        load_context: LoadContext,",
            "        trusted: bool | Sequence[str] = False,",
            "        memoize: bool = True,",
            "    ) -> None:",
            "        self.class_name, self.module_name = state[\"__class__\"], state[\"__module__\"]",
            "        self._is_safe = None",
            "        self._constructed = UNINITIALIZED",
            "        saved_id = state.get(\"__id__\")",
            "        if saved_id and memoize:",
            "            # hold reference to obj in case same instance encountered again in",
            "            # save state",
            "            load_context.memoize(self, saved_id)",
            "",
            "        # subclasses should always:",
            "        # 1. call super().__init__()",
            "        # 2. set self.trusted = self._get_trusted(trusted, ...) where ... is a",
            "        #    list of appropriate trusted types",
            "        # 3. set self.children, where children are states of child nodes; do not",
            "        #    construct the children objects yet",
            "        self.trusted = self._get_trusted(trusted, [])",
            "        self.children: dict[str, VALID_NODE_CHILD_TYPES] = {}",
            "",
            "    def construct(self):",
            "        \"\"\"Construct the object.",
            "",
            "        We only construct the object once, and then cache the result.",
            "        \"\"\"",
            "        if self._constructed is not UNINITIALIZED:",
            "            return self._constructed",
            "        self._constructed = self._construct()",
            "        return self._constructed",
            "",
            "    def _construct(self):",
            "        raise NotImplementedError(",
            "            f\"{self.__class__.__name__} should implement a '_construct' method\"",
            "        )",
            "",
            "    @staticmethod",
            "    def _get_trusted(",
            "        trusted: bool | Sequence[Union[str, Type]], default: Sequence[Union[str, Type]]",
            "    ) -> Literal[True] | list[str]:",
            "        \"\"\"Return a trusted list, or True.",
            "",
            "        If ``trusted`` is ``False``, we return the ``default``. If a list of",
            "        types are being passed, those types, as well as default trusted types,",
            "        are returned.",
            "",
            "        This is a convenience method called by child classes.",
            "",
            "        \"\"\"",
            "        if trusted is True:",
            "            # if trusted is True, we trust the node",
            "            return True",
            "",
            "        if trusted is False:",
            "            # if trusted is False, we only trust the defaults",
            "            return get_type_paths(default)",
            "",
            "        # otherwise, we trust the given list and default trusted types",
            "        return get_type_paths(trusted) + get_type_paths(default)",
            "",
            "    def is_self_safe(self) -> bool:",
            "        \"\"\"True only if the node's type is considered safe.",
            "",
            "        This property only checks the type of the node, not its children.",
            "        \"\"\"",
            "        return check_type(self.module_name, self.class_name, self.trusted)",
            "",
            "    def is_safe(self) -> bool:",
            "        \"\"\"True only if the node and all its children are safe.\"\"\"",
            "        # if trusted is set to True, we don't do any safety checks.",
            "        if self.trusted is True:",
            "            return True",
            "",
            "        return len(self.get_unsafe_set()) == 0",
            "",
            "    def get_unsafe_set(self) -> set[str]:",
            "        \"\"\"Get the set of unsafe types.",
            "",
            "        This method returns all types which are not trusted, including this",
            "        node and all its children.",
            "",
            "        Returns",
            "        -------",
            "        unsafe_set : set",
            "            A set of unsafe types.",
            "        \"\"\"",
            "        if hasattr(self, \"_computing_unsafe_set\"):",
            "            # this means we're already computing this node's unsafe set, so we",
            "            # return an empty set and let the computation of the parent node",
            "            # continue. This is to avoid infinite recursion.",
            "            return set()",
            "",
            "        with temp_setattr(self, _computing_unsafe_set=True):",
            "            res = set()",
            "            if not self.is_self_safe():",
            "                res.add(self.module_name + \".\" + self.class_name)",
            "",
            "            for child in self.children.values():",
            "                if child is None:",
            "                    continue",
            "",
            "                # Get the safety set based on the type of the child. In most cases",
            "                # other than ListNode and DictNode, children are all of type Node.",
            "                if isinstance(child, list):",
            "                    # iterate through the list",
            "                    for value in child:",
            "                        res.update(value.get_unsafe_set())",
            "                elif isinstance(child, dict):",
            "                    # iterate through the values of the dict only",
            "                    # TODO: should we check the types of the keys?",
            "                    for value in child.values():",
            "                        res.update(value.get_unsafe_set())",
            "                elif isinstance(child, Node):",
            "                    # delegate to the child Node",
            "                    res.update(child.get_unsafe_set())",
            "                elif type(child) is type:",
            "                    # the if condition bellow is not merged with the previous",
            "                    # one because if the above condition is True, the following",
            "                    # conditions about BytesIO, etc should be ignored.",
            "                    if not check_type(get_module(child), child.__name__, self.trusted):",
            "                        # if the child is a type, we check its safety",
            "                        res.add(get_module(child) + \".\" + child.__name__)",
            "                elif isinstance(child, (io.BytesIO, str)):",
            "                    # We trust BytesIO objects, which are read by other",
            "                    # libraries such as numpy, scipy. We trust str but have to",
            "                    # be careful that anything with str is dealt with",
            "                    # appropriately.",
            "                    continue",
            "                else:",
            "                    raise ValueError(",
            "                        f\"Cannot determine the safety of type {type(child)}. Please\"",
            "                        \" open an issue at https://github.com/skops-dev/skops/issues\"",
            "                        \" for us to fix the issue.\"",
            "                    )",
            "",
            "        return res",
            "",
            "    def format(self) -> str:",
            "        \"\"\"Representation of the node's content.\"\"\"",
            "        return f\"{self.module_name}.{self.class_name}\"",
            "",
            "",
            "class CachedNode(Node):",
            "    def __init__(",
            "        self,",
            "        state: dict[str, Any],",
            "        load_context: LoadContext,",
            "        trusted: bool = False,",
            "    ):",
            "        # we pass memoize as False because we don't want to memoize the cached",
            "        # node.",
            "        super().__init__(state, load_context, trusted, memoize=False)",
            "        self.trusted = True",
            "        # TODO: deal with case that __id__ is unknown or prevent it from",
            "        # happening",
            "        self.cached = load_context.get_object(state.get(\"__id__\"))  # type: ignore",
            "        self.children = {}  # type: ignore",
            "",
            "    def _construct(self):",
            "        # TODO: FIXME This causes a recursion error when loading a cached",
            "        # object if we call the cached object's `construct``. Some refactoring",
            "        # is needed to fix this.",
            "        return self.cached.construct()",
            "",
            "",
            "NODE_TYPE_MAPPING[(\"CachedNode\", PROTOCOL)] = CachedNode",
            "",
            "",
            "def get_tree(",
            "    state: dict[str, Any],",
            "    load_context: LoadContext,",
            "    trusted: bool | Sequence[str],",
            ") -> Node:",
            "    \"\"\"Get the tree of nodes.",
            "",
            "    This function returns the root node of the tree of nodes. The tree is",
            "    constructed recursively by traversing the state tree. No instances are",
            "    created during this process. One would need to call ``construct`` on the",
            "    root node to create the instances.",
            "",
            "    This function also handles memoization of the nodes. If a node has already",
            "    been created, it is returned instead of creating a new one.",
            "",
            "    Parameters",
            "    ----------",
            "    state : dict",
            "        The state of the dumped object.",
            "",
            "    load_context : LoadContext",
            "        The context of the loading process.",
            "",
            "    trusted : bool, or list of str",
            "        If ``True``, the object will be loaded without any security checks. If",
            "        ``False``, the object will be loaded only if there are only trusted",
            "        objects in the dumped file. If a list of strings, the object will be",
            "        loaded only if there are only trusted objects and objects of types",
            "        listed in ``trusted`` in the dumped file.",
            "",
            "    Returns",
            "    -------",
            "    loaded_tree : Node",
            "        The tree containing all its (non-instantiated) child nodes.",
            "    \"\"\"",
            "    saved_id = state.get(\"__id__\")",
            "    if saved_id in load_context.memo:",
            "        # This means the node is already loaded, so we return it. Note that the",
            "        # node is not constructed at this point. It will be constructed when",
            "        # the parent node's ``construct`` method is called, and for this node",
            "        # it'll be called more than once. But that's not an issue since the",
            "        # node's ``construct`` method caches the instance.",
            "        return load_context.get_object(saved_id)",
            "",
            "    loader: str = state[\"__loader__\"]",
            "    protocol = load_context.protocol",
            "    key = (loader, protocol)",
            "",
            "    if key in NODE_TYPE_MAPPING:",
            "        node_cls = NODE_TYPE_MAPPING[key]",
            "    else:",
            "        # What probably happened here is that we released a new protocol. If",
            "        # there is no specific key for the old protocol, it means it is safe to",
            "        # use the current protocol instead, because this node was not changed.",
            "        key_new = (loader, PROTOCOL)",
            "        try:",
            "            node_cls = NODE_TYPE_MAPPING[key_new]",
            "        except KeyError:",
            "            # If we still cannot find the loader for this key, something went",
            "            # wrong.",
            "            type_name = f\"{state['__module__']}.{state['__class__']}\"",
            "            raise TypeError(",
            "                f\" Can't find loader {state['__loader__']} for type {type_name} and \"",
            "                f\"protocol {protocol}.\"",
            "            )",
            "",
            "    loaded_tree = node_cls(state, load_context, trusted=trusted)",
            "    return loaded_tree"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import io",
            "from contextlib import contextmanager",
            "from typing import Any, Dict, Generator, List, Optional, Sequence, Type, Union",
            "",
            "from ._protocol import PROTOCOL",
            "from ._utils import LoadContext, get_module, get_type_paths",
            "from .exceptions import UntrustedTypesFoundException",
            "",
            "NODE_TYPE_MAPPING: dict[tuple[str, int], Type[Node]] = {}",
            "VALID_NODE_CHILD_TYPES = Optional[",
            "    Union[\"Node\", List[\"Node\"], Dict[str, \"Node\"], Type, str, io.BytesIO]",
            "]",
            "",
            "",
            "def check_type(module_name: str, type_name: str, trusted: Sequence[str]) -> bool:",
            "    \"\"\"Check if a type is safe to load.",
            "",
            "    A type is safe to load only if it's present in the trusted list.",
            "",
            "    Parameters",
            "    ----------",
            "    module_name : str",
            "        The module name of the type.",
            "",
            "    type_name : str",
            "        The class name of the type.",
            "",
            "    trusted : True, or list of str",
            "        If ``True``, the tree is considered safe. Otherwise trusted has to be",
            "        a list of trusted types.",
            "",
            "    Returns",
            "    -------",
            "    is_safe : bool",
            "        True if the type is safe, False otherwise.",
            "    \"\"\"",
            "    return module_name + \".\" + type_name in trusted",
            "",
            "",
            "def audit_tree(tree: Node) -> None:",
            "    \"\"\"Audit a tree of nodes.",
            "",
            "    A tree is safe if it only contains trusted types.",
            "",
            "    Parameters",
            "    ----------",
            "    tree : skops.io._dispatch.Node",
            "        The tree to audit.",
            "",
            "    Raises",
            "    ------",
            "    UntrustedTypesFoundException",
            "        If the tree contains an untrusted type.",
            "    \"\"\"",
            "    unsafe = tree.get_unsafe_set()",
            "    if unsafe:",
            "        raise UntrustedTypesFoundException(unsafe)",
            "",
            "",
            "class UNINITIALIZED:",
            "    \"\"\"Sentinel value to indicate that a value has not been initialized yet.\"\"\"",
            "",
            "",
            "# Node: types for Generator mean: YieldType, SendType, ReturnType",
            "@contextmanager",
            "def temp_setattr(obj: Any, **kwargs: Any) -> Generator[None, None, None]:",
            "    \"\"\"Context manager to temporarily set attributes on an object.\"\"\"",
            "    existing_attrs = {k for k in kwargs.keys() if hasattr(obj, k)}",
            "    previous_values = {k: getattr(obj, k, None) for k in kwargs}",
            "    for k, v in kwargs.items():",
            "        setattr(obj, k, v)",
            "    try:",
            "        yield",
            "    finally:",
            "        for k, v in previous_values.items():",
            "            if k in existing_attrs:",
            "                setattr(obj, k, v)",
            "            else:",
            "                delattr(obj, k)",
            "",
            "",
            "class Node:",
            "    \"\"\"A node in the tree of objects.",
            "",
            "    This class is a parent class for all nodes in the tree of objects. Each",
            "    type of object (e.g. dict, list, etc.) has its own subclass of Node.",
            "",
            "    Each child class has to implement two methods: ``__init__`` and",
            "    ``_construct``.",
            "",
            "    ``__init__`` takes care of traversing the state tree and to create the",
            "    corresponding ``Node`` objects. It has access to the ``load_context`` which",
            "    in turn has access to the source zip file. The child class's ``__init__``",
            "    must load attributes into the ``children`` attribute, which is a",
            "    dictionary of ``{child_name: unloaded_value/Node/list/etc}``. The",
            "    ``get_unsafe_set`` should be able to parse and validate the values set",
            "    under the ``children`` attribute. Note that primitives are persisted as a",
            "    ``JsonNode``.",
            "",
            "    ``_construct`` takes care of constructing the object. It is only called",
            "    once and the result is cached in ``construct`` which is implemented in this",
            "    class. All required data to construct an instance should be loaded during",
            "    ``__init__``.",
            "",
            "    The separation of ``__init__`` and ``_construct`` is necessary because",
            "    audit methods are called after ``__init__`` and before ``construct``.",
            "    Therefore ``__init__`` should avoid creating any instances or importing",
            "    any modules, to avoid running potentially untrusted code.",
            "",
            "    Parameters",
            "    ----------",
            "    state : dict",
            "        A dict representing the state of the dumped object.",
            "",
            "    load_context : LoadContext",
            "        The context of the loading process.",
            "",
            "    trusted : bool or list of str, default=False",
            "        If ``True``, the object will be loaded without any security checks. If",
            "        ``False``, the object will be loaded only if there are only trusted",
            "        objects in the dumped file. If a list of strings, the object will be",
            "        loaded only if all of its required types are listed in ``trusted``",
            "        or are trusted by default.",
            "",
            "    memoize : bool, default=True",
            "        If ``True``, the object will be memoized in the load context, if it has",
            "        the ``__id__`` set. This is used to avoid loading the same object",
            "        multiple times.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        state: dict[str, Any],",
            "        load_context: LoadContext,",
            "        trusted: Optional[Sequence[str]] = None,",
            "        memoize: bool = True,",
            "    ) -> None:",
            "        self.class_name, self.module_name = state[\"__class__\"], state[\"__module__\"]",
            "        self._is_safe = None",
            "        self._constructed = UNINITIALIZED",
            "        saved_id = state.get(\"__id__\")",
            "        if saved_id and memoize:",
            "            # hold reference to obj in case same instance encountered again in",
            "            # save state",
            "            load_context.memoize(self, saved_id)",
            "",
            "        # subclasses should always:",
            "        # 1. call super().__init__()",
            "        # 2. set self.trusted = self._get_trusted(trusted, ...) where ... is a",
            "        #    list of appropriate trusted types",
            "        # 3. set self.children, where children are states of child nodes; do not",
            "        #    construct the children objects yet",
            "        self.trusted = self._get_trusted(trusted, [])",
            "        self.children: dict[str, VALID_NODE_CHILD_TYPES] = {}",
            "",
            "    def construct(self):",
            "        \"\"\"Construct the object.",
            "",
            "        We only construct the object once, and then cache the result.",
            "        \"\"\"",
            "        if self._constructed is not UNINITIALIZED:",
            "            return self._constructed",
            "        self._constructed = self._construct()",
            "        return self._constructed",
            "",
            "    def _construct(self):",
            "        raise NotImplementedError(",
            "            f\"{self.__class__.__name__} should implement a '_construct' method\"",
            "        )",
            "",
            "    @staticmethod",
            "    def _get_trusted(",
            "        trusted: Optional[Sequence[Union[str, Type]]],",
            "        default: Sequence[Union[str, Type]],",
            "    ) -> list[str]:",
            "        \"\"\"Return a trusted list, or True.",
            "",
            "        If ``trusted`` is ``None``, we return the ``default``. If a list of",
            "        types are being passed, those types, as well as default trusted types,",
            "        are returned.",
            "",
            "        This is a convenience method called by child classes.",
            "",
            "        \"\"\"",
            "        if trusted is None:",
            "            # if trusted is False, we only trust the defaults",
            "            return get_type_paths(default)",
            "",
            "        # otherwise, we trust the given list and default trusted types",
            "        return get_type_paths(trusted) + get_type_paths(default)",
            "",
            "    def is_self_safe(self) -> bool:",
            "        \"\"\"True only if the node's type is considered safe.",
            "",
            "        This property only checks the type of the node, not its children.",
            "        \"\"\"",
            "        return check_type(self.module_name, self.class_name, self.trusted)",
            "",
            "    def is_safe(self) -> bool:",
            "        \"\"\"True only if the node and all its children are safe.\"\"\"",
            "        # if trusted is set to True, we don't do any safety checks.",
            "        if self.trusted is True:",
            "            return True",
            "",
            "        return len(self.get_unsafe_set()) == 0",
            "",
            "    def get_unsafe_set(self) -> set[str]:",
            "        \"\"\"Get the set of unsafe types.",
            "",
            "        This method returns all types which are not trusted, including this",
            "        node and all its children.",
            "",
            "        Returns",
            "        -------",
            "        unsafe_set : set",
            "            A set of unsafe types.",
            "        \"\"\"",
            "        if hasattr(self, \"_computing_unsafe_set\"):",
            "            # this means we're already computing this node's unsafe set, so we",
            "            # return an empty set and let the computation of the parent node",
            "            # continue. This is to avoid infinite recursion.",
            "            return set()",
            "",
            "        with temp_setattr(self, _computing_unsafe_set=True):",
            "            res = set()",
            "            if not self.is_self_safe():",
            "                res.add(self.module_name + \".\" + self.class_name)",
            "",
            "            for child in self.children.values():",
            "                if child is None:",
            "                    continue",
            "",
            "                # Get the safety set based on the type of the child. In most cases",
            "                # other than ListNode and DictNode, children are all of type Node.",
            "                if isinstance(child, list):",
            "                    # iterate through the list",
            "                    for value in child:",
            "                        res.update(value.get_unsafe_set())",
            "                elif isinstance(child, dict):",
            "                    # iterate through the values of the dict only",
            "                    # TODO: should we check the types of the keys?",
            "                    for value in child.values():",
            "                        res.update(value.get_unsafe_set())",
            "                elif isinstance(child, Node):",
            "                    # delegate to the child Node",
            "                    res.update(child.get_unsafe_set())",
            "                elif type(child) is type:",
            "                    # the if condition bellow is not merged with the previous",
            "                    # one because if the above condition is True, the following",
            "                    # conditions about BytesIO, etc should be ignored.",
            "                    if not check_type(get_module(child), child.__name__, self.trusted):",
            "                        # if the child is a type, we check its safety",
            "                        res.add(get_module(child) + \".\" + child.__name__)",
            "                elif isinstance(child, (io.BytesIO, str)):",
            "                    # We trust BytesIO objects, which are read by other",
            "                    # libraries such as numpy, scipy. We trust str but have to",
            "                    # be careful that anything with str is dealt with",
            "                    # appropriately.",
            "                    continue",
            "                else:",
            "                    raise ValueError(",
            "                        f\"Cannot determine the safety of type {type(child)}. Please\"",
            "                        \" open an issue at https://github.com/skops-dev/skops/issues\"",
            "                        \" for us to fix the issue.\"",
            "                    )",
            "",
            "        return res",
            "",
            "    def format(self) -> str:",
            "        \"\"\"Representation of the node's content.\"\"\"",
            "        return f\"{self.module_name}.{self.class_name}\"",
            "",
            "",
            "class CachedNode(Node):",
            "    def __init__(",
            "        self,",
            "        state: dict[str, Any],",
            "        load_context: LoadContext,",
            "        trusted: Optional[List[str]] = None,",
            "    ):",
            "        # we pass memoize as False because we don't want to memoize the cached",
            "        # node.",
            "        super().__init__(state, load_context, trusted, memoize=False)",
            "        self.trusted = self._get_trusted(trusted, default=[])",
            "        # TODO: deal with case that __id__ is unknown or prevent it from",
            "        # happening",
            "        self.cached = load_context.get_object(state.get(\"__id__\"))  # type: ignore",
            "        self.children = {}  # type: ignore",
            "",
            "    def _construct(self):",
            "        # TODO: FIXME This causes a recursion error when loading a cached",
            "        # object if we call the cached object's `construct``. Some refactoring",
            "        # is needed to fix this.",
            "        return self.cached.construct()",
            "",
            "",
            "NODE_TYPE_MAPPING[(\"CachedNode\", PROTOCOL)] = CachedNode",
            "",
            "",
            "def get_tree(",
            "    state: dict[str, Any],",
            "    load_context: LoadContext,",
            "    trusted: Optional[Sequence[str]],",
            ") -> Node:",
            "    \"\"\"Get the tree of nodes.",
            "",
            "    This function returns the root node of the tree of nodes. The tree is",
            "    constructed recursively by traversing the state tree. No instances are",
            "    created during this process. One would need to call ``construct`` on the",
            "    root node to create the instances.",
            "",
            "    This function also handles memoization of the nodes. If a node has already",
            "    been created, it is returned instead of creating a new one.",
            "",
            "    Parameters",
            "    ----------",
            "    state : dict",
            "        The state of the dumped object.",
            "",
            "    load_context : LoadContext",
            "        The context of the loading process.",
            "",
            "    trusted : bool, or list of str",
            "        If ``True``, the object will be loaded without any security checks. If",
            "        ``False``, the object will be loaded only if there are only trusted",
            "        objects in the dumped file. If a list of strings, the object will be",
            "        loaded only if there are only trusted objects and objects of types",
            "        listed in ``trusted`` in the dumped file.",
            "",
            "    Returns",
            "    -------",
            "    loaded_tree : Node",
            "        The tree containing all its (non-instantiated) child nodes.",
            "    \"\"\"",
            "    saved_id = state.get(\"__id__\")",
            "    if saved_id in load_context.memo:",
            "        # This means the node is already loaded, so we return it. Note that the",
            "        # node is not constructed at this point. It will be constructed when",
            "        # the parent node's ``construct`` method is called, and for this node",
            "        # it'll be called more than once. But that's not an issue since the",
            "        # node's ``construct`` method caches the instance.",
            "        return load_context.get_object(saved_id)",
            "",
            "    loader: str = state[\"__loader__\"]",
            "    protocol = load_context.protocol",
            "    key = (loader, protocol)",
            "",
            "    if key in NODE_TYPE_MAPPING:",
            "        node_cls = NODE_TYPE_MAPPING[key]",
            "    else:",
            "        # What probably happened here is that we released a new protocol. If",
            "        # there is no specific key for the old protocol, it means it is safe to",
            "        # use the current protocol instead, because this node was not changed.",
            "        key_new = (loader, PROTOCOL)",
            "        try:",
            "            node_cls = NODE_TYPE_MAPPING[key_new]",
            "        except KeyError:",
            "            # If we still cannot find the loader for this key, something went",
            "            # wrong.",
            "            type_name = f\"{state['__module__']}.{state['__class__']}\"",
            "            raise TypeError(",
            "                f\" Can't find loader {state['__loader__']} for type {type_name} and \"",
            "                f\"protocol {protocol}.\"",
            "            )",
            "",
            "    loaded_tree = node_cls(state, load_context, trusted=trusted)",
            "    return loaded_tree"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "17": [
                "check_type"
            ],
            "18": [
                "check_type"
            ],
            "19": [
                "check_type"
            ],
            "41": [
                "check_type"
            ],
            "42": [
                "check_type"
            ],
            "49": [
                "audit_tree"
            ],
            "50": [
                "audit_tree"
            ],
            "62": [
                "audit_tree"
            ],
            "63": [
                "audit_tree"
            ],
            "64": [
                "audit_tree"
            ],
            "145": [
                "Node",
                "__init__"
            ],
            "183": [
                "Node",
                "_get_trusted"
            ],
            "184": [
                "Node",
                "_get_trusted"
            ],
            "187": [
                "Node",
                "_get_trusted"
            ],
            "194": [
                "Node",
                "_get_trusted"
            ],
            "195": [
                "Node",
                "_get_trusted"
            ],
            "196": [
                "Node",
                "_get_trusted"
            ],
            "197": [
                "Node",
                "_get_trusted"
            ],
            "198": [
                "Node",
                "_get_trusted"
            ],
            "292": [
                "CachedNode",
                "__init__"
            ],
            "297": [
                "CachedNode",
                "__init__"
            ],
            "316": [
                "get_tree"
            ]
        },
        "addLocation": []
    }
}