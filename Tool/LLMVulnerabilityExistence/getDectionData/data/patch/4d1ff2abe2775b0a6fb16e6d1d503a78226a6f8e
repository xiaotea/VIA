{
    "nautobot/core/testing/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "                             escape(str(instance.cf.get(custom_field.key) or \"\")), response_body, msg=response_body"
            },
            "1": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "                         )"
            },
            "2": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 215,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            return response  # for consumption by child test cases if desired"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "         @override_settings(EXEMPT_VIEW_PERMISSIONS=[])"
            },
            "6": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "         def test_get_object_with_constrained_permission(self):"
            },
            "7": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "             instance1, instance2 = self._get_queryset().all()[:2]"
            },
            "8": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))"
            },
            "9": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             # Try GET to permitted object"
            },
            "11": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertHttpStatus(self.client.get(instance1.get_absolute_url()), 200)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+            response = self.client.get(instance1.get_absolute_url())"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+            self.assertHttpStatus(response, 200)"
            },
            "14": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "             # Try GET to non-permitted object"
            },
            "16": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "             self.assertHttpStatus(self.client.get(instance2.get_absolute_url()), 404)"
            },
            "17": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+            return response  # for consumption by child test cases if desired"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         @override_settings(EXEMPT_VIEW_PERMISSIONS=[])"
            },
            "21": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         def test_has_advanced_tab(self):"
            },
            "22": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             instance = self._get_queryset().first()"
            }
        },
        "frontPatchFile": [
            "import re",
            "from typing import Optional, Sequence",
            "from unittest import skipIf",
            "import uuid",
            "",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.core.validators import URLValidator",
            "from django.test import override_settings, tag, TestCase as _TestCase",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import escape",
            "from django.utils.http import urlencode",
            "from django.utils.text import slugify",
            "from tree_queries.models import TreeNode",
            "",
            "from nautobot.core.models.generics import PrimaryModel",
            "from nautobot.core.models.tree_queries import TreeModel",
            "from nautobot.core.templatetags import helpers",
            "from nautobot.core.testing import mixins, utils",
            "from nautobot.core.utils import lookup",
            "from nautobot.extras import choices as extras_choices, models as extras_models, querysets as extras_querysets",
            "from nautobot.extras.forms import CustomFieldModelFormMixin, RelationshipModelFormMixin",
            "from nautobot.extras.models import CustomFieldModel, RelationshipModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.ipam.models import Prefix",
            "from nautobot.users import models as users_models",
            "",
            "__all__ = (",
            "    \"TestCase\",",
            "    \"ModelTestCase\",",
            "    \"ModelViewTestCase\",",
            "    \"ViewTestCases\",",
            ")",
            "",
            "",
            "@tag(\"unit\")",
            "@override_settings(PAGINATE_COUNT=65000)",
            "class TestCase(mixins.NautobotTestCaseMixin, _TestCase):",
            "    \"\"\"Base class for all Nautobot-specific unit tests.\"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"Initialize user and client.\"\"\"",
            "        super().setUpNautobot()",
            "",
            "",
            "class ModelTestCase(TestCase):",
            "    \"\"\"",
            "    Parent class for TestCases which deal with models.",
            "    \"\"\"",
            "",
            "    model = None",
            "    # Optional, list of Relationships populated in setUpTestData for testing with this model",
            "    # Be sure to also create RelationshipAssociations using these Relationships!",
            "    relationships: Optional[Sequence[extras_models.Relationship]] = None",
            "    # Optional, list of CustomFields populated in setUpTestData for testing with this model",
            "    # Be sure to also populate these fields on your test data!",
            "    custom_fields: Optional[Sequence[extras_models.CustomField]] = None",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"",
            "        Return a base queryset suitable for use in test methods.",
            "        \"\"\"",
            "        return self.model.objects.all()",
            "",
            "",
            "#",
            "# UI Tests",
            "#",
            "",
            "",
            "@tag(\"performance\")",
            "class ModelViewTestCase(ModelTestCase):",
            "    \"\"\"",
            "    Base TestCase for model views. Subclass to test individual views.",
            "    \"\"\"",
            "",
            "    reverse_url_attribute = None",
            "    \"\"\"",
            "    Name of instance field to pass as a kwarg when looking up URLs for creating/editing/deleting a model instance.",
            "",
            "    If unspecified, \"pk\" and \"slug\" will be tried, in that order.",
            "    \"\"\"",
            "",
            "    def _get_base_url(self):",
            "        \"\"\"",
            "        Return the base format string for a view URL for the test.",
            "",
            "        Examples: \"dcim:device_{}\", \"plugins:example_app:example_model_{}\"",
            "",
            "        Override this if needed for testing of views that don't correspond directly to self.model,",
            "        for example the DCIM \"interface-connections\" and \"console-connections\" view tests.",
            "        \"\"\"",
            "        app_name = apps.get_app_config(app_label=self.model._meta.app_label).name",
            "        # AppConfig.name accounts for NautobotApps that are not built at the root of the package",
            "        if app_name in settings.PLUGINS:",
            "            return f\"plugins:{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "        return f\"{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "",
            "    def _get_url(self, action, instance=None):",
            "        \"\"\"",
            "        Return the URL string for a specific action and optionally a specific model instance.",
            "",
            "        Override this if needed for testing of views whose names don't follow",
            "        the [plugins]:<app_label>:<model_name>_<action> naming convention.",
            "        \"\"\"",
            "        url_format = self._get_base_url()",
            "",
            "        # If no instance was provided, assume we don't need a unique identifier",
            "        if instance is None:",
            "            return reverse(url_format.format(action))",
            "",
            "        if self.reverse_url_attribute:",
            "            return reverse(",
            "                url_format.format(action),",
            "                kwargs={self.reverse_url_attribute: getattr(instance, self.reverse_url_attribute)},",
            "            )",
            "",
            "        try:",
            "            # Default to using the PK to retrieve the URL for an object",
            "            return reverse(url_format.format(action), kwargs={\"pk\": instance.pk})",
            "        except NoReverseMatch:",
            "            # Attempt to resolve using slug as the unique identifier if one exists",
            "            if hasattr(self.model, \"slug\"):",
            "                return reverse(url_format.format(action), kwargs={\"slug\": instance.slug})",
            "            raise",
            "",
            "",
            "@tag(\"unit\")",
            "class ViewTestCases:",
            "    \"\"\"",
            "    We keep any TestCases with test_* methods inside a class to prevent unittest from trying to run them.",
            "    \"\"\"",
            "",
            "    class GetObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve a single instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_queryset().first().get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(",
            "                \"/login/?next=\" + self._get_queryset().first().get_absolute_url(), response_body, msg=response_body",
            "            )",
            "",
            "            # The \"Change Log\" tab should appear in the response since we have all exempt permissions",
            "            if issubclass(self.model, extras_models.ChangeLoggedModel):",
            "                response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "                self.assertIn(\"Change Log\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                response = self.client.get(instance.get_absolute_url())",
            "                self.assertHttpStatus(response, [403, 404])",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(instance.get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "",
            "            # The object's display name or string representation should appear in the response",
            "            self.assertIn(escape(getattr(instance, \"display\", str(instance))), response_body, msg=response_body)",
            "",
            "            # If any Relationships are defined, they should appear in the response",
            "            if self.relationships is not None:",
            "                for relationship in self.relationships:  # false positive pylint: disable=not-an-iterable",
            "                    content_type = ContentType.objects.get_for_model(instance)",
            "                    if content_type == relationship.source_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(extras_choices.RelationshipSideChoices.SIDE_SOURCE)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "                    if content_type == relationship.destination_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(extras_choices.RelationshipSideChoices.SIDE_DESTINATION)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "",
            "            # If any Custom Fields are defined, they should appear in the response",
            "            if self.custom_fields is not None:",
            "                for custom_field in self.custom_fields:  # false positive pylint: disable=not-an-iterable",
            "                    self.assertIn(escape(str(custom_field)), response_body, msg=response_body)",
            "                    if custom_field.type == extras_choices.CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "                        for value in instance.cf.get(custom_field.key):",
            "                            self.assertIn(escape(str(value)), response_body, msg=response_body)",
            "                    else:",
            "                        self.assertIn(",
            "                            escape(str(instance.cf.get(custom_field.key) or \"\")), response_body, msg=response_body",
            "                        )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                # To get a different rendering flow than the `test_get_object_with_permission` test above,",
            "                # enable additional permissions for this object so that add/edit/delete buttons are rendered.",
            "                actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET to permitted object",
            "            self.assertHttpStatus(self.client.get(instance1.get_absolute_url()), 200)",
            "",
            "            # Try GET to non-permitted object",
            "            self.assertHttpStatus(self.client.get(instance2.get_absolute_url()), 404)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_has_advanced_tab(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            response = self.client.get(instance.get_absolute_url())",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            advanced_tab_href = f\"{instance.get_absolute_url()}#advanced\"",
            "",
            "            self.assertIn(advanced_tab_href, response_body)",
            "            self.assertIn(\"Advanced\", response_body)",
            "",
            "    class GetObjectChangelogViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the changelog for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_changelog(self):",
            "            obj = self._get_queryset().first()",
            "            url = self._get_url(\"changelog\", obj)",
            "            response = self.client.get(url)",
            "            self.assertHttpStatus(response, 200)",
            "            response_data = response.content.decode(response.charset)",
            "            if type(obj) not in [extras_models.Contact, extras_models.Team]:",
            "                self.assertInHTML(",
            "                    f'<a href=\"{obj.get_absolute_url()}#contacts\" onclick=\"switch_tab(this.href)\" aria-controls=\"contacts\" role=\"tab\" data-toggle=\"tab\">Contacts</a>',",
            "                    response_data,",
            "                )",
            "",
            "    class GetObjectNotesViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the notes for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_notes(self):",
            "            if hasattr(self.model, \"notes\"):",
            "                obj = self._get_queryset().first()",
            "                url = self._get_url(\"notes\", obj)",
            "                response = self.client.get(url)",
            "                self.assertHttpStatus(response, 200)",
            "                response_data = response.content.decode(response.charset)",
            "                if type(obj) not in [extras_models.Contact, extras_models.Team]:",
            "                    self.assertInHTML(",
            "                        f'<a href=\"{obj.get_absolute_url()}#contacts\" onclick=\"switch_tab(this.href)\" aria-controls=\"contacts\" role=\"tab\" data-toggle=\"tab\">Contacts</a>',",
            "                        response_data,",
            "                    )",
            "",
            "    class CreateObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create a single new instance.",
            "",
            "        :form_data: Data to be used when creating a new object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "        slug_source = None",
            "        slugify_function = staticmethod(slugify)",
            "        slug_test_object = \"\"",
            "",
            "        def test_create_object_without_permission(self):",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 403)",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            response = self.client.post(**request)",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(response, 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\" or \"name\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                filter_by = self.slug_source if getattr(self, \"slug_source\", None) else \"name\"",
            "                instance = self._get_queryset().get(**{filter_by: self.form_data.get(filter_by)})",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    instance = self._get_queryset().order_by(\"last_updated\").last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "                else:",
            "                    instance = self._get_queryset().last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                # Assert that Created By table row is updated with the user that created the object",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_CREATE)",
            "                # Validate if detail view exists",
            "                validate = URLValidator()",
            "                try:",
            "                    detail_url = instance.get_absolute_url()",
            "                    validate(detail_url)",
            "                    response = self.client.get(detail_url)",
            "                    response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "                    advanced_tab_href = f\"{detail_url}#advanced\"",
            "                    self.assertIn(advanced_tab_href, response_body)",
            "                    self.assertIn(\"<td>Created By</td>\", response_body)",
            "                    self.assertIn(\"<td>nautobotuser</td>\", response_body)",
            "                except (AttributeError, ValidationError):",
            "                    # Instance does not have a valid detail view, do nothing here.",
            "                    pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try to create an object (not permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(initial_count, self._get_queryset().count())  # Check that no object was created",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}",
            "            obj_perm.save()",
            "",
            "            # Try to create an object (permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                filter_by = self.slug_source if getattr(self, \"slug_source\", None) else \"name\"",
            "                instance = self._get_queryset().get(**{filter_by: self.form_data.get(filter_by)})",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    self.assertInstanceEqual(self._get_queryset().order_by(\"last_updated\").last(), self.form_data)",
            "                else:",
            "                    self.assertInstanceEqual(self._get_queryset().last(), self.form_data)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_extra_feature_form_fields_present(self):",
            "            model_class = self.model",
            "            model_form = lookup.get_form_for_model(model_class)",
            "            fields = model_form.base_fields",
            "            if isinstance(model_class, CustomFieldModel):",
            "                self.assertTrue(issubclass(CustomFieldModelFormMixin, model_form))",
            "            if isinstance(model_class, RelationshipModel):",
            "                self.assertTrue(issubclass(RelationshipModelFormMixin, model_form))",
            "            if isinstance(model_class, NotesMixin):",
            "                self.assertIsNotNone(fields.get(\"object_note\"))",
            "            if isinstance(model_class, PrimaryModel):",
            "                self.assertIsNotNone(fields.get(\"tags\"))",
            "",
            "        def test_slug_autocreation(self):",
            "            \"\"\"Test that slug is autocreated through ORM.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if getattr(self.model, \"slug_source\", None) is not None:",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "        def test_slug_not_modified(self):",
            "            \"\"\"Ensure save method does not modify slug that is passed in.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if getattr(self.model, \"slug_source\", None) is not None:",
            "                new_slug_source_value = \"kwyjibo\"",
            "",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                # Update slug source field str",
            "                filter_ = self.slug_source + \"__exact\"",
            "                self.model.objects.filter(**{filter_: self.slug_test_object}).update(",
            "                    **{self.slug_source: new_slug_source_value}",
            "                )",
            "",
            "                obj.refresh_from_db()",
            "                self.assertEqual(getattr(obj, self.slug_source), new_slug_source_value)",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "    class EditObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit a single existing instance.",
            "",
            "        :form_data: Data to be used when updating the first existing object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "",
            "        def test_edit_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance.pk), self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_UPDATE)",
            "                # Validate if detail view exists",
            "                validate = URLValidator()",
            "                try:",
            "                    detail_url = instance.get_absolute_url()",
            "                    validate(detail_url)",
            "                    response = self.client.get(detail_url)",
            "                    response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "                    advanced_tab_href = f\"{detail_url}#advanced\"",
            "                    self.assertIn(advanced_tab_href, response_body)",
            "                    self.assertIn(\"<td>Last Updated By</td>\", response_body)",
            "                    self.assertIn(\"<td>nautobotuser</td>\", response_body)",
            "                except (AttributeError, ValidationError):",
            "                    # Instance does not have a valid detail view, do nothing here.",
            "                    pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance2)), 404)",
            "",
            "            # Try to edit a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance1),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance1.pk), self.form_data)",
            "",
            "            # Try to edit a non-permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance2),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "",
            "    class DeleteObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete a single instance.",
            "        \"\"\"",
            "",
            "        def get_deletable_object(self):",
            "            \"\"\"",
            "            Get an instance that can be deleted.",
            "",
            "            For some models this may just be any random object, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            instance = utils.get_deletable_objects(self.model, self._get_queryset()).first()",
            "            if instance is None:",
            "                self.fail(\"Couldn't find a single deletable object!\")",
            "            return instance",
            "",
            "        def test_delete_object_without_permission(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission(self):",
            "            instance = self.get_deletable_object()",
            "            instance_note_pk_list = []",
            "            assigned_object_type = ContentType.objects.get_for_model(self.model)",
            "            if hasattr(self.model, \"notes\") and isinstance(instance.notes, extras_querysets.NotesQuerySet):",
            "                notes = (",
            "                    extras_models.Note(",
            "                        assigned_object_type=assigned_object_type, assigned_object_id=instance.id, note=\"hello 1\"",
            "                    ),",
            "                    extras_models.Note(",
            "                        assigned_object_type=assigned_object_type, assigned_object_id=instance.id, note=\"hello 2\"",
            "                    ),",
            "                    extras_models.Note(",
            "                        assigned_object_type=assigned_object_type, assigned_object_id=instance.id, note=\"hello 3\"",
            "                    ),",
            "                )",
            "                for note in notes:",
            "                    note.validated_save()",
            "                    instance_note_pk_list.append(note.pk)",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(assigned_object_type)",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "            if hasattr(self.model, \"notes\") and isinstance(instance.notes, extras_querysets.NotesQuerySet):",
            "                # Verify Notes deletion",
            "                with self.assertRaises(ObjectDoesNotExist):",
            "                    extras_models.Note.objects.get(assigned_object_id=instance.pk)",
            "",
            "                note_objectchanges = extras_models.ObjectChange.objects.filter(",
            "                    changed_object_id__in=instance_note_pk_list",
            "                )",
            "                self.assertEqual(note_objectchanges.count(), 3)",
            "                for object_change in note_objectchanges:",
            "                    self.assertEqual(object_change.action, extras_choices.ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission_and_xwwwformurlencoded(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": urlencode({\"confirm\": True}),",
            "                \"content_type\": \"application/x-www-form-urlencoded\",",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_constrained_permission(self):",
            "            instance1 = self.get_deletable_object()",
            "            instance2 = self._get_queryset().exclude(pk=instance1.pk)[0]",
            "",
            "            # Assign object-level permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance2)), 404)",
            "",
            "            # Try to delete a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance1),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance1.pk)",
            "",
            "            # Try to delete a non-permitted object",
            "            # Note that in the case of tree models, deleting instance1 above may have cascade-deleted to instance2,",
            "            # so to be safe, we need to get another object instance that definitely exists:",
            "            instance3 = self._get_queryset().first()",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance3),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "            self.assertTrue(self._get_queryset().filter(pk=instance3.pk).exists())",
            "",
            "    class ListObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve multiple instances.",
            "        \"\"\"",
            "",
            "        filterset = None",
            "        filter_on_field = \"name\"",
            "        sort_on_field = \"tags\"",
            "",
            "        def get_filterset(self):",
            "            return self.filterset or lookup.get_filterset_for_model(self.model)",
            "",
            "        # Helper methods to be overriden by special cases.",
            "        # See ConsoleConnectionsTestCase, InterfaceConnectionsTestCase and PowerConnectionsTestCase",
            "        def get_list_url(self):",
            "            return reverse(helpers.validated_viewname(self.model, \"list\"))",
            "",
            "        def get_title(self):",
            "            return helpers.bettertitle(self.model._meta.verbose_name_plural)",
            "",
            "        def get_list_view(self):",
            "            return lookup.get_view_for_model(self.model, view_type=\"List\")",
            "",
            "        def test_list_view_has_filter_form(self):",
            "            view = self.get_list_view()",
            "            if hasattr(view, \"filterset_form\"):  # ObjectListView",
            "                self.assertIsNotNone(view.filterset_form, \"List view lacks a FilterForm\")",
            "            if hasattr(view, \"filterset_form_class\"):  # ObjectListViewMixin",
            "                self.assertIsNotNone(view.filterset_form_class, \"List viewset lacks a FilterForm\")",
            "",
            "        def test_table_with_indentation_is_removed_on_filter_or_sort(self):",
            "            self.user.is_superuser = True",
            "            self.user.save()",
            "",
            "            if not issubclass(self.model, (TreeModel)) and self.model is not Prefix:",
            "                self.skipTest(\"Skipping Non TreeModels\")",
            "",
            "            with self.subTest(\"Assert indentation is present\"):",
            "                response = self.client.get(f\"{self._get_url('list')}\")",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertInHTML('<i class=\"mdi mdi-circle-small\"></i>', response_body)",
            "",
            "            with self.subTest(\"Assert indentation is removed on filter\"):",
            "                queryset = (",
            "                    self._get_queryset().filter(parent__isnull=False).values_list(self.filter_on_field, flat=True)[:5]",
            "                )",
            "                filter_values = \"&\".join([f\"{self.filter_on_field}={instance_value}\" for instance_value in queryset])",
            "                response = self.client.get(f\"{self._get_url('list')}?{filter_values}\")",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn('<i class=\"mdi mdi-circle-small\"></i>', response_body)",
            "",
            "            with self.subTest(\"Assert indentation is removed on sort\"):",
            "                response = self.client.get(f\"{self._get_url('list')}?sort={self.sort_on_field}\")",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn('<i class=\"mdi mdi-circle-small\"></i>', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(\"/login/?next=\" + self._get_url(\"list\"), response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_filtered(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            response = self.client.get(f\"{self._get_url('list')}?id={instance1.pk}\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertNotRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            if instance1.get_absolute_url() in content:",
            "                self.assertNotIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=True)",
            "        def test_list_objects_unknown_filter_strict_filtering(self):",
            "            \"\"\"Verify that with STRICT_FILTERING, an unknown filter results in an error message and no matches.\"\"\"",
            "            response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertIn(\"Unknown filter field\", content, msg=content)",
            "            # There should be no table rows displayed except for the empty results row",
            "            self.assertIn(\"None\", content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=False)",
            "        def test_list_objects_unknown_filter_no_strict_filtering(self):",
            "            \"\"\"Verify that without STRICT_FILTERING, an unknown filter is ignored.\"\"\"",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            with self.assertLogs(\"nautobot.core.filters\") as cm:",
            "                response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            filterset = self.get_filterset()",
            "            if not filterset:",
            "                self.fail(",
            "                    f\"Couldn't find filterset for model {self.model}. The FilterSet class is expected to be in the \"",
            "                    \"filters module within the application associated with the model and its name is expected to be \"",
            "                    f\"{self.model.__name__}FilterSet.\"",
            "                )",
            "            self.assertEqual(",
            "                cm.output,",
            "                [",
            "                    f'WARNING:nautobot.core.filters:{filterset.__name__}: Unknown filter field \"ice_cream_flavor\"',",
            "                ],",
            "            )",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertNotIn(\"Unknown filter field\", content, msg=content)",
            "            self.assertIn(\"None\", content, msg=content)",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            if instance1.get_absolute_url() in content:",
            "                self.assertIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_without_permission(self):",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                response = self.client.get(self._get_url(\"list\"))",
            "                self.assertHttpStatus(response, 403)",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_permission(self):",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            list_url = self.get_list_url()",
            "            title = self.get_title()",
            "",
            "            # Check if breadcrumb is rendered correctly",
            "            self.assertIn(",
            "                f'<a href=\"{list_url}\">{title}</a>',",
            "                response_body,",
            "            )",
            "",
            "            # Check if import button is absent due to user permissions",
            "            self.assertNotIn(",
            "                reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": \"nautobot.core.jobs.ImportObjects\"}),",
            "                response_body,",
            "            )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"view\", \"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertNotRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            elif hasattr(self.model, \"get_absolute_url\"):",
            "                self.assertIn(instance1.get_absolute_url(), content, msg=content)",
            "                self.assertNotIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "            view = self.get_list_view()",
            "            if view and hasattr(view, \"action_buttons\") and \"import\" in view.action_buttons:",
            "                # Check if import button is present due to user permissions",
            "                self.assertIn(",
            "                    (",
            "                        reverse(",
            "                            \"extras:job_run_by_class_path\", kwargs={\"class_path\": \"nautobot.core.jobs.ImportObjects\"}",
            "                        )",
            "                        + f\"?content_type={ContentType.objects.get_for_model(self.model).pk}\"",
            "                    ),",
            "                    content,",
            "                )",
            "            else:",
            "                # Import not supported, no button should be present",
            "                self.assertNotIn(",
            "                    reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": \"nautobot.core.jobs.ImportObjects\"}),",
            "                    content,",
            "                )",
            "",
            "        @skipIf(",
            "            \"example_app\" not in settings.PLUGINS,",
            "            \"example_app not in settings.PLUGINS\",",
            "        )",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_view_app_banner(self):",
            "            \"\"\"",
            "            If example app is installed, check if the app banner is rendered correctly in ObjectListView.",
            "            \"\"\"",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            # Check app banner is rendered correctly",
            "            self.assertIn(",
            "                f\"<div>You are viewing a table of {self.model._meta.verbose_name_plural}</div>\", response_body",
            "            )",
            "",
            "    class CreateMultipleObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create multiple instances using a single form. Expects the creation of three new instances by default.",
            "",
            "        :bulk_create_count: The number of objects expected to be created (default: 3).",
            "        :bulk_create_data: A dictionary of data to be used for bulk object creation.",
            "        \"\"\"",
            "",
            "        bulk_create_count = 3",
            "        bulk_create_data = {}",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_without_permission(self):",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign non-constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Bulk create objects",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "                constraints={\"pk\": uuid.uuid4()},  # Match a non-existent pk (i.e., deny all)",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to make the request with unmet constraints",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Set constraint to allow all",
            "            obj_perm.save()",
            "",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "    class BulkImportObjectsViewTestCase(ModelViewTestCase):  # 3.0 TODO: remove this test mixin, no longer relevant.",
            "        \"\"\"",
            "        Vestigial test case, to be removed in 3.0.",
            "",
            "        This is vestigial since the introduction of the ImportObjects system Job to handle bulk-import of all",
            "        content-types via REST API serializers. The parsing of CSV data by the serializer is exercised by",
            "        APIViewTestCases.CreateObjectViewTestCase.test_recreate_object_csv(), and the basic operation of the Job is",
            "        exercised by nautobot.core.tests.test_jobs.",
            "        \"\"\"",
            "",
            "        csv_data = ()",
            "",
            "        def _get_csv_data(self):",
            "            return \"\\n\".join(self.csv_data)",
            "",
            "        # Just in case Apps are extending any of these tests and calling super() in them.",
            "        def test_bulk_import_objects_without_permission(self):",
            "            pass",
            "",
            "        def test_bulk_import_objects_with_permission(self):",
            "            pass",
            "",
            "        def test_bulk_import_objects_with_permission_csv_file(self):",
            "            pass",
            "",
            "        def test_bulk_import_objects_with_constrained_permission(self):",
            "            pass",
            "",
            "    class BulkEditObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit multiple instances.",
            "",
            "        :bulk_edit_data: A dictionary of data to be used when bulk editing a set of objects. This data should differ",
            "                         from that used for initial object creation within setUpTestData().",
            "        \"\"\"",
            "",
            "        bulk_edit_data = {}",
            "",
            "        def validate_object_data_after_bulk_edit(self, pk_list):",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertInstanceEqual(instance, self.bulk_edit_data)",
            "",
            "        def test_bulk_edit_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Append the form data to the request",
            "            data.update(utils.post_data(self.bulk_edit_data))",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            self.validate_object_data_after_bulk_edit(pk_list)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_edit with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pk\"",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"_all\": \"on\",",
            "            }",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk edit table.",
            "            # after pressing Edit Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkEditForm/BulkUpdateForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_form_contains_all_filtered(self):",
            "            # We are testing the intermediary step of bulk_edit with pagination applied and additional filter.",
            "            # i.e. \"_all\" passed in the form and filter using query params.",
            "            self.add_permissions(f\"{self.model._meta.app_label}.change_{self.model._meta.model_name}\")",
            "",
            "            pk_iter = iter(self._get_queryset().values_list(\"pk\", flat=True))",
            "            try:",
            "                first_pk = next(pk_iter)",
            "                second_pk = next(pk_iter)",
            "                third_pk = next(pk_iter)",
            "            except StopIteration:",
            "                self.fail(f\"Test requires at least three instances of {self.model._meta.model_name} to be defined.\")",
            "",
            "            post_data = utils.post_data(self.bulk_edit_data)",
            "",
            "            # Open bulk update form with first two objects",
            "            selected_data = {",
            "                \"pk\": third_pk,  # This is ignored when filtering with \"_all\"",
            "                \"_all\": \"on\",",
            "                **post_data,",
            "            }",
            "            query_string = urlencode({\"id\": (first_pk, second_pk)}, doseq=True)",
            "            response = self.client.post(f\"{self._get_url('bulk_edit')}?{query_string}\", selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk edit table after pressing Edit Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if the first and second pk is passed into the form.",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{first_pk}\"', response_body)",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{second_pk}\"', response_body)",
            "            self.assertIn(\"Editing 2 \", response_body)",
            "            # Check if the third pk is not passed into the form.",
            "            self.assertNotIn(f'<input type=\"hidden\" name=\"pk\" value=\"{third_pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_constrained_permission(self):",
            "            # Select some objects that are *not* already set to match the first value in self.bulk_edit_data or null.",
            "            # We have to exclude null cases because Django filter()/exclude() doesn't like `__in=[None]` as a case.",
            "            attr_name = next(iter(self.bulk_edit_data.keys()))",
            "            objects = (",
            "                self._get_queryset()",
            "                .exclude(**{attr_name: self.bulk_edit_data[attr_name]})",
            "                .exclude(**{f\"{attr_name}__isnull\": True})",
            "            )[:3]",
            "            self.assertEqual(objects.count(), 3)",
            "            pk_list = list(objects.values_list(\"pk\", flat=True))",
            "",
            "            # Define a permission that permits the above objects, but will not permit them after updating them.",
            "            field = self.model._meta.get_field(attr_name)",
            "            values = [field.value_from_object(obj) for obj in objects]",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={f\"{attr_name}__in\": values},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Build form data",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(utils.post_data(self.bulk_edit_data))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), data)",
            "            # 200 because we're sent back to the edit form to try again; if the update were successful it'd be a 302",
            "            self.assertHttpStatus(response, 200)",
            "            # Assert that the objects are NOT updated",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertIn(field.value_from_object(instance), values)",
            "                self.assertNotEqual(field.value_from_object(instance), self.bulk_edit_data[attr_name])",
            "",
            "            # Update permission constraints to permit all objects",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk edit permitted objects and expect a redirect back to the list view",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            # Assert that the objects were all updated correctly",
            "            self.validate_object_data_after_bulk_edit(pk_list)",
            "",
            "    class BulkDeleteObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete multiple instances.",
            "        \"\"\"",
            "",
            "        def get_deletable_object_pks(self):",
            "            \"\"\"",
            "            Get a list of PKs corresponding to objects that can be safely bulk-deleted.",
            "",
            "            For some models this may just be any random objects, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            return utils.get_deletable_objects(self.model, self._get_queryset()).values_list(\"pk\", flat=True)[:3]",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_without_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_delete with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pks\".",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"confirm\": True,",
            "                \"_all\": \"on\",",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with the selected data first. Emulating selecting all -> pressing Delete Selected button.",
            "            response = self.client.post(self._get_url(\"bulk_delete\"), selected_data)",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkDeleteForm/BulkDestroyForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_delete_form_contains_all_filtered(self):",
            "            # We are testing the intermediary step of bulk_delete with pagination applied and additional filter.",
            "            # i.e. \"_all\" passed in the form and filter using query params.",
            "            self.add_permissions(f\"{self.model._meta.app_label}.delete_{self.model._meta.model_name}\")",
            "",
            "            pk_iter = iter(self._get_queryset().values_list(\"pk\", flat=True))",
            "            try:",
            "                first_pk = next(pk_iter)",
            "                second_pk = next(pk_iter)",
            "                third_pk = next(pk_iter)",
            "            except StopIteration:",
            "                self.fail(f\"Test requires at least three instances of {self.model._meta.model_name} to be defined.\")",
            "",
            "            # Open bulk delete form with first two objects",
            "            selected_data = {",
            "                \"pk\": third_pk,  # This is ignored when filtering with \"_all\"",
            "                \"_all\": \"on\",",
            "            }",
            "            query_string = urlencode({\"id\": (first_pk, second_pk)}, doseq=True)",
            "            response = self.client.post(f\"{self._get_url('bulk_delete')}?{query_string}\", selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk delete table after pressing Delete Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if the first and second pk is passed into the form.",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{first_pk}\"', response_body)",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{second_pk}\"', response_body)",
            "            self.assertIn(\"<strong>Warning:</strong> The following operation will delete 2 \", response_body)",
            "            # Check if the third pk is not passed into the form.",
            "            self.assertNotIn(f'<input type=\"hidden\" name=\"pk\" value=\"{third_pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_constrained_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk delete non-permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Match a non-existent pk (i.e., allow all)",
            "            obj_perm.save()",
            "",
            "            # Bulk delete permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "    class BulkRenameObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Rename multiple instances.",
            "        \"\"\"",
            "",
            "        rename_data = {",
            "            \"find\": \"^(.*)$\",",
            "            \"replace\": \"\\\\1X\",  # Append an X to the original value",
            "            \"use_regex\": True,",
            "        }",
            "",
            "        def test_bulk_rename_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Test GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"bulk_rename\")), 403)",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_constrained_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"name__regex\": \"[^X]$\"},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk rename permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "    class PrimaryObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing all standard View functions for primary objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class OrganizationalObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for all organizational objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentTemplateViewTestCase(",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component template models (ConsolePortTemplates, InterfaceTemplates, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component models (ConsolePorts, Interfaces, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "        bulk_add_data = None",
            "        \"\"\"Used for bulk-add (distinct from bulk-create) view testing; self.bulk_create_data will be used if unset.\"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_add_component(self):",
            "            \"\"\"Test bulk-adding this component to devices/virtual-machines.\"\"\"",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            initial_count = self._get_queryset().count()",
            "",
            "            data = (self.bulk_add_data or self.bulk_create_data).copy()",
            "",
            "            # Load the device-bulk-add or virtualmachine-bulk-add form",
            "            if \"device\" in data:",
            "                url = reverse(f\"dcim:device_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": utils.post_data({\"pk\": data[\"device\"]}),",
            "                }",
            "            else:",
            "                url = reverse(f\"virtualization:virtualmachine_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": utils.post_data({\"pk\": data[\"virtual_machine\"]}),",
            "                }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "",
            "            # Post to the device-bulk-add or virtualmachine-bulk-add form to create records",
            "            if \"device\" in data:",
            "                data[\"pk\"] = data.pop(\"device\")",
            "            else:",
            "                data[\"pk\"] = data.pop(\"virtual_machine\")",
            "            data[\"_create\"] = \"\"",
            "            request[\"data\"] = utils.post_data(data)",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "            updated_count = self._get_queryset().count()",
            "            self.assertEqual(updated_count, initial_count + self.bulk_create_count)",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, (self.bulk_add_data or self.bulk_create_data))",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename(self):",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            objects = self.selected_objects",
            "            pk_list = [obj.pk for obj in objects]",
            "            # Apply button not yet clicked",
            "            data = {\"pk\": pk_list}",
            "            data.update(self.rename_data)",
            "            verbose_name_plural = self.model._meta.verbose_name_plural",
            "",
            "            with self.subTest(\"Assert device name in HTML\"):",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                message = (",
            "                    f\"Renaming {len(objects)} {helpers.bettertitle(verbose_name_plural)} \"",
            "                    f\"on {self.selected_objects_parent_name}\"",
            "                )",
            "                self.assertInHTML(message, response.content.decode(response.charset))",
            "",
            "            with self.subTest(\"Assert update successfully\"):",
            "                data[\"_apply\"] = True  # Form Apply button",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                self.assertHttpStatus(response, 302)",
            "                queryset = self._get_queryset().filter(pk__in=pk_list)",
            "                for instance in objects:",
            "                    self.assertEqual(queryset.get(pk=instance.pk).name, f\"{instance.name}X\")",
            "",
            "            with self.subTest(\"Assert if no valid objects selected return with error\"):",
            "                for values in ([], [str(uuid.uuid4())]):",
            "                    data[\"pk\"] = values",
            "                    response = self.client.post(self._get_url(\"bulk_rename\"), data, follow=True)",
            "                    expected_message = f\"No valid {verbose_name_plural} were selected.\"",
            "                    self.assertIn(expected_message, response.content.decode(response.charset))"
        ],
        "afterPatchFile": [
            "import re",
            "from typing import Optional, Sequence",
            "from unittest import skipIf",
            "import uuid",
            "",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.core.validators import URLValidator",
            "from django.test import override_settings, tag, TestCase as _TestCase",
            "from django.urls import NoReverseMatch, reverse",
            "from django.utils.html import escape",
            "from django.utils.http import urlencode",
            "from django.utils.text import slugify",
            "from tree_queries.models import TreeNode",
            "",
            "from nautobot.core.models.generics import PrimaryModel",
            "from nautobot.core.models.tree_queries import TreeModel",
            "from nautobot.core.templatetags import helpers",
            "from nautobot.core.testing import mixins, utils",
            "from nautobot.core.utils import lookup",
            "from nautobot.extras import choices as extras_choices, models as extras_models, querysets as extras_querysets",
            "from nautobot.extras.forms import CustomFieldModelFormMixin, RelationshipModelFormMixin",
            "from nautobot.extras.models import CustomFieldModel, RelationshipModel",
            "from nautobot.extras.models.mixins import NotesMixin",
            "from nautobot.ipam.models import Prefix",
            "from nautobot.users import models as users_models",
            "",
            "__all__ = (",
            "    \"TestCase\",",
            "    \"ModelTestCase\",",
            "    \"ModelViewTestCase\",",
            "    \"ViewTestCases\",",
            ")",
            "",
            "",
            "@tag(\"unit\")",
            "@override_settings(PAGINATE_COUNT=65000)",
            "class TestCase(mixins.NautobotTestCaseMixin, _TestCase):",
            "    \"\"\"Base class for all Nautobot-specific unit tests.\"\"\"",
            "",
            "    def setUp(self):",
            "        \"\"\"Initialize user and client.\"\"\"",
            "        super().setUpNautobot()",
            "",
            "",
            "class ModelTestCase(TestCase):",
            "    \"\"\"",
            "    Parent class for TestCases which deal with models.",
            "    \"\"\"",
            "",
            "    model = None",
            "    # Optional, list of Relationships populated in setUpTestData for testing with this model",
            "    # Be sure to also create RelationshipAssociations using these Relationships!",
            "    relationships: Optional[Sequence[extras_models.Relationship]] = None",
            "    # Optional, list of CustomFields populated in setUpTestData for testing with this model",
            "    # Be sure to also populate these fields on your test data!",
            "    custom_fields: Optional[Sequence[extras_models.CustomField]] = None",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"",
            "        Return a base queryset suitable for use in test methods.",
            "        \"\"\"",
            "        return self.model.objects.all()",
            "",
            "",
            "#",
            "# UI Tests",
            "#",
            "",
            "",
            "@tag(\"performance\")",
            "class ModelViewTestCase(ModelTestCase):",
            "    \"\"\"",
            "    Base TestCase for model views. Subclass to test individual views.",
            "    \"\"\"",
            "",
            "    reverse_url_attribute = None",
            "    \"\"\"",
            "    Name of instance field to pass as a kwarg when looking up URLs for creating/editing/deleting a model instance.",
            "",
            "    If unspecified, \"pk\" and \"slug\" will be tried, in that order.",
            "    \"\"\"",
            "",
            "    def _get_base_url(self):",
            "        \"\"\"",
            "        Return the base format string for a view URL for the test.",
            "",
            "        Examples: \"dcim:device_{}\", \"plugins:example_app:example_model_{}\"",
            "",
            "        Override this if needed for testing of views that don't correspond directly to self.model,",
            "        for example the DCIM \"interface-connections\" and \"console-connections\" view tests.",
            "        \"\"\"",
            "        app_name = apps.get_app_config(app_label=self.model._meta.app_label).name",
            "        # AppConfig.name accounts for NautobotApps that are not built at the root of the package",
            "        if app_name in settings.PLUGINS:",
            "            return f\"plugins:{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "        return f\"{self.model._meta.app_label}:{self.model._meta.model_name}_{{}}\"",
            "",
            "    def _get_url(self, action, instance=None):",
            "        \"\"\"",
            "        Return the URL string for a specific action and optionally a specific model instance.",
            "",
            "        Override this if needed for testing of views whose names don't follow",
            "        the [plugins]:<app_label>:<model_name>_<action> naming convention.",
            "        \"\"\"",
            "        url_format = self._get_base_url()",
            "",
            "        # If no instance was provided, assume we don't need a unique identifier",
            "        if instance is None:",
            "            return reverse(url_format.format(action))",
            "",
            "        if self.reverse_url_attribute:",
            "            return reverse(",
            "                url_format.format(action),",
            "                kwargs={self.reverse_url_attribute: getattr(instance, self.reverse_url_attribute)},",
            "            )",
            "",
            "        try:",
            "            # Default to using the PK to retrieve the URL for an object",
            "            return reverse(url_format.format(action), kwargs={\"pk\": instance.pk})",
            "        except NoReverseMatch:",
            "            # Attempt to resolve using slug as the unique identifier if one exists",
            "            if hasattr(self.model, \"slug\"):",
            "                return reverse(url_format.format(action), kwargs={\"slug\": instance.slug})",
            "            raise",
            "",
            "",
            "@tag(\"unit\")",
            "class ViewTestCases:",
            "    \"\"\"",
            "    We keep any TestCases with test_* methods inside a class to prevent unittest from trying to run them.",
            "    \"\"\"",
            "",
            "    class GetObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve a single instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_queryset().first().get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(",
            "                \"/login/?next=\" + self._get_queryset().first().get_absolute_url(), response_body, msg=response_body",
            "            )",
            "",
            "            # The \"Change Log\" tab should appear in the response since we have all exempt permissions",
            "            if issubclass(self.model, extras_models.ChangeLoggedModel):",
            "                response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "                self.assertIn(\"Change Log\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                response = self.client.get(instance.get_absolute_url())",
            "                self.assertHttpStatus(response, [403, 404])",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(instance.get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "",
            "            # The object's display name or string representation should appear in the response",
            "            self.assertIn(escape(getattr(instance, \"display\", str(instance))), response_body, msg=response_body)",
            "",
            "            # If any Relationships are defined, they should appear in the response",
            "            if self.relationships is not None:",
            "                for relationship in self.relationships:  # false positive pylint: disable=not-an-iterable",
            "                    content_type = ContentType.objects.get_for_model(instance)",
            "                    if content_type == relationship.source_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(extras_choices.RelationshipSideChoices.SIDE_SOURCE)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "                    if content_type == relationship.destination_type:",
            "                        self.assertIn(",
            "                            escape(relationship.get_label(extras_choices.RelationshipSideChoices.SIDE_DESTINATION)),",
            "                            response_body,",
            "                            msg=response_body,",
            "                        )",
            "",
            "            # If any Custom Fields are defined, they should appear in the response",
            "            if self.custom_fields is not None:",
            "                for custom_field in self.custom_fields:  # false positive pylint: disable=not-an-iterable",
            "                    self.assertIn(escape(str(custom_field)), response_body, msg=response_body)",
            "                    if custom_field.type == extras_choices.CustomFieldTypeChoices.TYPE_MULTISELECT:",
            "                        for value in instance.cf.get(custom_field.key):",
            "                            self.assertIn(escape(str(value)), response_body, msg=response_body)",
            "                    else:",
            "                        self.assertIn(",
            "                            escape(str(instance.cf.get(custom_field.key) or \"\")), response_body, msg=response_body",
            "                        )",
            "",
            "            return response  # for consumption by child test cases if desired",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_get_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                # To get a different rendering flow than the `test_get_object_with_permission` test above,",
            "                # enable additional permissions for this object so that add/edit/delete buttons are rendered.",
            "                actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET to permitted object",
            "            response = self.client.get(instance1.get_absolute_url())",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            # Try GET to non-permitted object",
            "            self.assertHttpStatus(self.client.get(instance2.get_absolute_url()), 404)",
            "",
            "            return response  # for consumption by child test cases if desired",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_has_advanced_tab(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            response = self.client.get(instance.get_absolute_url())",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            advanced_tab_href = f\"{instance.get_absolute_url()}#advanced\"",
            "",
            "            self.assertIn(advanced_tab_href, response_body)",
            "            self.assertIn(\"Advanced\", response_body)",
            "",
            "    class GetObjectChangelogViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the changelog for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_changelog(self):",
            "            obj = self._get_queryset().first()",
            "            url = self._get_url(\"changelog\", obj)",
            "            response = self.client.get(url)",
            "            self.assertHttpStatus(response, 200)",
            "            response_data = response.content.decode(response.charset)",
            "            if type(obj) not in [extras_models.Contact, extras_models.Team]:",
            "                self.assertInHTML(",
            "                    f'<a href=\"{obj.get_absolute_url()}#contacts\" onclick=\"switch_tab(this.href)\" aria-controls=\"contacts\" role=\"tab\" data-toggle=\"tab\">Contacts</a>',",
            "                    response_data,",
            "                )",
            "",
            "    class GetObjectNotesViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        View the notes for an instance.",
            "        \"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_get_object_notes(self):",
            "            if hasattr(self.model, \"notes\"):",
            "                obj = self._get_queryset().first()",
            "                url = self._get_url(\"notes\", obj)",
            "                response = self.client.get(url)",
            "                self.assertHttpStatus(response, 200)",
            "                response_data = response.content.decode(response.charset)",
            "                if type(obj) not in [extras_models.Contact, extras_models.Team]:",
            "                    self.assertInHTML(",
            "                        f'<a href=\"{obj.get_absolute_url()}#contacts\" onclick=\"switch_tab(this.href)\" aria-controls=\"contacts\" role=\"tab\" data-toggle=\"tab\">Contacts</a>',",
            "                        response_data,",
            "                    )",
            "",
            "    class CreateObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create a single new instance.",
            "",
            "        :form_data: Data to be used when creating a new object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "        slug_source = None",
            "        slugify_function = staticmethod(slugify)",
            "        slug_test_object = \"\"",
            "",
            "        def test_create_object_without_permission(self):",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 403)",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            response = self.client.post(**request)",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(response, 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\" or \"name\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                filter_by = self.slug_source if getattr(self, \"slug_source\", None) else \"name\"",
            "                instance = self._get_queryset().get(**{filter_by: self.form_data.get(filter_by)})",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    instance = self._get_queryset().order_by(\"last_updated\").last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "                else:",
            "                    instance = self._get_queryset().last()",
            "                    self.assertInstanceEqual(instance, self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                # Assert that Created By table row is updated with the user that created the object",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_CREATE)",
            "                # Validate if detail view exists",
            "                validate = URLValidator()",
            "                try:",
            "                    detail_url = instance.get_absolute_url()",
            "                    validate(detail_url)",
            "                    response = self.client.get(detail_url)",
            "                    response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "                    advanced_tab_href = f\"{detail_url}#advanced\"",
            "                    self.assertIn(advanced_tab_href, response_body)",
            "                    self.assertIn(\"<td>Created By</td>\", response_body)",
            "                    self.assertIn(\"<td>nautobotuser</td>\", response_body)",
            "                except (AttributeError, ValidationError):",
            "                    # Instance does not have a valid detail view, do nothing here.",
            "                    pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_create_object_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"add\")), 200)",
            "",
            "            # Try to create an object (not permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(initial_count, self._get_queryset().count())  # Check that no object was created",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}",
            "            obj_perm.save()",
            "",
            "            # Try to create an object (permitted)",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertEqual(initial_count + 1, self._get_queryset().count())",
            "            # order_by() is no supported by django TreeNode,",
            "            # So we directly retrieve the instance by \"slug\".",
            "            if isinstance(self._get_queryset().first(), TreeNode):",
            "                filter_by = self.slug_source if getattr(self, \"slug_source\", None) else \"name\"",
            "                instance = self._get_queryset().get(**{filter_by: self.form_data.get(filter_by)})",
            "                self.assertInstanceEqual(instance, self.form_data)",
            "            else:",
            "                if hasattr(self.model, \"last_updated\"):",
            "                    self.assertInstanceEqual(self._get_queryset().order_by(\"last_updated\").last(), self.form_data)",
            "                else:",
            "                    self.assertInstanceEqual(self._get_queryset().last(), self.form_data)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_extra_feature_form_fields_present(self):",
            "            model_class = self.model",
            "            model_form = lookup.get_form_for_model(model_class)",
            "            fields = model_form.base_fields",
            "            if isinstance(model_class, CustomFieldModel):",
            "                self.assertTrue(issubclass(CustomFieldModelFormMixin, model_form))",
            "            if isinstance(model_class, RelationshipModel):",
            "                self.assertTrue(issubclass(RelationshipModelFormMixin, model_form))",
            "            if isinstance(model_class, NotesMixin):",
            "                self.assertIsNotNone(fields.get(\"object_note\"))",
            "            if isinstance(model_class, PrimaryModel):",
            "                self.assertIsNotNone(fields.get(\"tags\"))",
            "",
            "        def test_slug_autocreation(self):",
            "            \"\"\"Test that slug is autocreated through ORM.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if getattr(self.model, \"slug_source\", None) is not None:",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "        def test_slug_not_modified(self):",
            "            \"\"\"Ensure save method does not modify slug that is passed in.\"\"\"",
            "            # This really should go on a models test page, but we don't have test structures for models.",
            "            if getattr(self.model, \"slug_source\", None) is not None:",
            "                new_slug_source_value = \"kwyjibo\"",
            "",
            "                obj = self.model.objects.get(**{self.slug_source: self.slug_test_object})",
            "                expected_slug = self.slugify_function(getattr(obj, self.slug_source))",
            "                # Update slug source field str",
            "                filter_ = self.slug_source + \"__exact\"",
            "                self.model.objects.filter(**{filter_: self.slug_test_object}).update(",
            "                    **{self.slug_source: new_slug_source_value}",
            "                )",
            "",
            "                obj.refresh_from_db()",
            "                self.assertEqual(getattr(obj, self.slug_source), new_slug_source_value)",
            "                self.assertEqual(obj.slug, expected_slug)",
            "",
            "    class EditObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit a single existing instance.",
            "",
            "        :form_data: Data to be used when updating the first existing object.",
            "        \"\"\"",
            "",
            "        form_data = {}",
            "",
            "        def test_edit_object_without_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_permission(self):",
            "            instance = self._get_queryset().first()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance.pk), self.form_data)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_UPDATE)",
            "                # Validate if detail view exists",
            "                validate = URLValidator()",
            "                try:",
            "                    detail_url = instance.get_absolute_url()",
            "                    validate(detail_url)",
            "                    response = self.client.get(detail_url)",
            "                    response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "                    advanced_tab_href = f\"{detail_url}#advanced\"",
            "                    self.assertIn(advanced_tab_href, response_body)",
            "                    self.assertIn(\"<td>Last Updated By</td>\", response_body)",
            "                    self.assertIn(\"<td>nautobotuser</td>\", response_body)",
            "                except (AttributeError, ValidationError):",
            "                    # Instance does not have a valid detail view, do nothing here.",
            "                    pass",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_edit_object_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"edit\", instance2)), 404)",
            "",
            "            # Try to edit a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance1),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            self.assertInstanceEqual(self._get_queryset().get(pk=instance1.pk), self.form_data)",
            "",
            "            # Try to edit a non-permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"edit\", instance2),",
            "                \"data\": utils.post_data(self.form_data),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "",
            "    class DeleteObjectViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete a single instance.",
            "        \"\"\"",
            "",
            "        def get_deletable_object(self):",
            "            \"\"\"",
            "            Get an instance that can be deleted.",
            "",
            "            For some models this may just be any random object, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            instance = utils.get_deletable_objects(self.model, self._get_queryset()).first()",
            "            if instance is None:",
            "                self.fail(\"Couldn't find a single deletable object!\")",
            "            return instance",
            "",
            "        def test_delete_object_without_permission(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), [403, 404])",
            "",
            "            # Try POST without permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), [403, 404])",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission(self):",
            "            instance = self.get_deletable_object()",
            "            instance_note_pk_list = []",
            "            assigned_object_type = ContentType.objects.get_for_model(self.model)",
            "            if hasattr(self.model, \"notes\") and isinstance(instance.notes, extras_querysets.NotesQuerySet):",
            "                notes = (",
            "                    extras_models.Note(",
            "                        assigned_object_type=assigned_object_type, assigned_object_id=instance.id, note=\"hello 1\"",
            "                    ),",
            "                    extras_models.Note(",
            "                        assigned_object_type=assigned_object_type, assigned_object_id=instance.id, note=\"hello 2\"",
            "                    ),",
            "                    extras_models.Note(",
            "                        assigned_object_type=assigned_object_type, assigned_object_id=instance.id, note=\"hello 3\"",
            "                    ),",
            "                )",
            "                for note in notes:",
            "                    note.validated_save()",
            "                    instance_note_pk_list.append(note.pk)",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(assigned_object_type)",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "            if hasattr(self.model, \"notes\") and isinstance(instance.notes, extras_querysets.NotesQuerySet):",
            "                # Verify Notes deletion",
            "                with self.assertRaises(ObjectDoesNotExist):",
            "                    extras_models.Note.objects.get(assigned_object_id=instance.pk)",
            "",
            "                note_objectchanges = extras_models.ObjectChange.objects.filter(",
            "                    changed_object_id__in=instance_note_pk_list",
            "                )",
            "                self.assertEqual(note_objectchanges.count(), 3)",
            "                for object_change in note_objectchanges:",
            "                    self.assertEqual(object_change.action, extras_choices.ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_permission_and_xwwwformurlencoded(self):",
            "            instance = self.get_deletable_object()",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance)), 200)",
            "",
            "            # Try POST with model-level permission",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance),",
            "                \"data\": urlencode({\"confirm\": True}),",
            "                \"content_type\": \"application/x-www-form-urlencoded\",",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance.pk)",
            "",
            "            if hasattr(self.model, \"to_objectchange\"):",
            "                # Verify ObjectChange creation",
            "                objectchanges = lookup.get_changes_for_model(instance)",
            "                self.assertEqual(len(objectchanges), 1)",
            "                self.assertEqual(objectchanges[0].action, extras_choices.ObjectChangeActionChoices.ACTION_DELETE)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_delete_object_with_constrained_permission(self):",
            "            instance1 = self.get_deletable_object()",
            "            instance2 = self._get_queryset().exclude(pk=instance1.pk)[0]",
            "",
            "            # Assign object-level permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with a permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance1)), 200)",
            "",
            "            # Try GET with a non-permitted object",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"delete\", instance2)), 404)",
            "",
            "            # Try to delete a permitted object",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance1),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "            with self.assertRaises(ObjectDoesNotExist):",
            "                self._get_queryset().get(pk=instance1.pk)",
            "",
            "            # Try to delete a non-permitted object",
            "            # Note that in the case of tree models, deleting instance1 above may have cascade-deleted to instance2,",
            "            # so to be safe, we need to get another object instance that definitely exists:",
            "            instance3 = self._get_queryset().first()",
            "            request = {",
            "                \"path\": self._get_url(\"delete\", instance3),",
            "                \"data\": utils.post_data({\"confirm\": True}),",
            "            }",
            "            self.assertHttpStatus(self.client.post(**request), 404)",
            "            self.assertTrue(self._get_queryset().filter(pk=instance3.pk).exists())",
            "",
            "    class ListObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Retrieve multiple instances.",
            "        \"\"\"",
            "",
            "        filterset = None",
            "        filter_on_field = \"name\"",
            "        sort_on_field = \"tags\"",
            "",
            "        def get_filterset(self):",
            "            return self.filterset or lookup.get_filterset_for_model(self.model)",
            "",
            "        # Helper methods to be overriden by special cases.",
            "        # See ConsoleConnectionsTestCase, InterfaceConnectionsTestCase and PowerConnectionsTestCase",
            "        def get_list_url(self):",
            "            return reverse(helpers.validated_viewname(self.model, \"list\"))",
            "",
            "        def get_title(self):",
            "            return helpers.bettertitle(self.model._meta.verbose_name_plural)",
            "",
            "        def get_list_view(self):",
            "            return lookup.get_view_for_model(self.model, view_type=\"List\")",
            "",
            "        def test_list_view_has_filter_form(self):",
            "            view = self.get_list_view()",
            "            if hasattr(view, \"filterset_form\"):  # ObjectListView",
            "                self.assertIsNotNone(view.filterset_form, \"List view lacks a FilterForm\")",
            "            if hasattr(view, \"filterset_form_class\"):  # ObjectListViewMixin",
            "                self.assertIsNotNone(view.filterset_form_class, \"List viewset lacks a FilterForm\")",
            "",
            "        def test_table_with_indentation_is_removed_on_filter_or_sort(self):",
            "            self.user.is_superuser = True",
            "            self.user.save()",
            "",
            "            if not issubclass(self.model, (TreeModel)) and self.model is not Prefix:",
            "                self.skipTest(\"Skipping Non TreeModels\")",
            "",
            "            with self.subTest(\"Assert indentation is present\"):",
            "                response = self.client.get(f\"{self._get_url('list')}\")",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertInHTML('<i class=\"mdi mdi-circle-small\"></i>', response_body)",
            "",
            "            with self.subTest(\"Assert indentation is removed on filter\"):",
            "                queryset = (",
            "                    self._get_queryset().filter(parent__isnull=False).values_list(self.filter_on_field, flat=True)[:5]",
            "                )",
            "                filter_values = \"&\".join([f\"{self.filter_on_field}={instance_value}\" for instance_value in queryset])",
            "                response = self.client.get(f\"{self._get_url('list')}?{filter_values}\")",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn('<i class=\"mdi mdi-circle-small\"></i>', response_body)",
            "",
            "            with self.subTest(\"Assert indentation is removed on sort\"):",
            "                response = self.client.get(f\"{self._get_url('list')}?sort={self.sort_on_field}\")",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn('<i class=\"mdi mdi-circle-small\"></i>', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_anonymous(self):",
            "            # Make the request as an unauthenticated user",
            "            self.client.logout()",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "            self.assertIn(\"/login/?next=\" + self._get_url(\"list\"), response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_list_objects_filtered(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            response = self.client.get(f\"{self._get_url('list')}?id={instance1.pk}\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertNotRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            if instance1.get_absolute_url() in content:",
            "                self.assertNotIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=True)",
            "        def test_list_objects_unknown_filter_strict_filtering(self):",
            "            \"\"\"Verify that with STRICT_FILTERING, an unknown filter results in an error message and no matches.\"\"\"",
            "            response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertIn(\"Unknown filter field\", content, msg=content)",
            "            # There should be no table rows displayed except for the empty results row",
            "            self.assertIn(\"None\", content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"], STRICT_FILTERING=False)",
            "        def test_list_objects_unknown_filter_no_strict_filtering(self):",
            "            \"\"\"Verify that without STRICT_FILTERING, an unknown filter is ignored.\"\"\"",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "            with self.assertLogs(\"nautobot.core.filters\") as cm:",
            "                response = self.client.get(f\"{self._get_url('list')}?ice_cream_flavor=chocolate\")",
            "            filterset = self.get_filterset()",
            "            if not filterset:",
            "                self.fail(",
            "                    f\"Couldn't find filterset for model {self.model}. The FilterSet class is expected to be in the \"",
            "                    \"filters module within the application associated with the model and its name is expected to be \"",
            "                    f\"{self.model.__name__}FilterSet.\"",
            "                )",
            "            self.assertEqual(",
            "                cm.output,",
            "                [",
            "                    f'WARNING:nautobot.core.filters:{filterset.__name__}: Unknown filter field \"ice_cream_flavor\"',",
            "                ],",
            "            )",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            self.assertNotIn(\"Unknown filter field\", content, msg=content)",
            "            self.assertIn(\"None\", content, msg=content)",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            if instance1.get_absolute_url() in content:",
            "                self.assertIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_without_permission(self):",
            "            # Try GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                response = self.client.get(self._get_url(\"list\"))",
            "                self.assertHttpStatus(response, 403)",
            "                response_body = response.content.decode(response.charset)",
            "                self.assertNotIn(\"/login/\", response_body, msg=response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_permission(self):",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            list_url = self.get_list_url()",
            "            title = self.get_title()",
            "",
            "            # Check if breadcrumb is rendered correctly",
            "            self.assertIn(",
            "                f'<a href=\"{list_url}\">{title}</a>',",
            "                response_body,",
            "            )",
            "",
            "            # Check if import button is absent due to user permissions",
            "            self.assertNotIn(",
            "                reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": \"nautobot.core.jobs.ImportObjects\"}),",
            "                response_body,",
            "            )",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_objects_with_constrained_permission(self):",
            "            instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "            # Add object-level permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": instance1.pk},",
            "                actions=[\"view\", \"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with object-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            content = utils.extract_page_body(response.content.decode(response.charset))",
            "            # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "            if hasattr(self.model, \"name\"):",
            "                self.assertRegex(content, r\">\\s*\" + re.escape(escape(instance1.name)) + r\"\\s*<\", msg=content)",
            "                self.assertNotRegex(content, r\">\\s*\" + re.escape(escape(instance2.name)) + r\"\\s*<\", msg=content)",
            "            elif hasattr(self.model, \"get_absolute_url\"):",
            "                self.assertIn(instance1.get_absolute_url(), content, msg=content)",
            "                self.assertNotIn(instance2.get_absolute_url(), content, msg=content)",
            "",
            "            view = self.get_list_view()",
            "            if view and hasattr(view, \"action_buttons\") and \"import\" in view.action_buttons:",
            "                # Check if import button is present due to user permissions",
            "                self.assertIn(",
            "                    (",
            "                        reverse(",
            "                            \"extras:job_run_by_class_path\", kwargs={\"class_path\": \"nautobot.core.jobs.ImportObjects\"}",
            "                        )",
            "                        + f\"?content_type={ContentType.objects.get_for_model(self.model).pk}\"",
            "                    ),",
            "                    content,",
            "                )",
            "            else:",
            "                # Import not supported, no button should be present",
            "                self.assertNotIn(",
            "                    reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": \"nautobot.core.jobs.ImportObjects\"}),",
            "                    content,",
            "                )",
            "",
            "        @skipIf(",
            "            \"example_app\" not in settings.PLUGINS,",
            "            \"example_app not in settings.PLUGINS\",",
            "        )",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_list_view_app_banner(self):",
            "            \"\"\"",
            "            If example app is installed, check if the app banner is rendered correctly in ObjectListView.",
            "            \"\"\"",
            "            # Add model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try GET with model-level permission",
            "            response = self.client.get(self._get_url(\"list\"))",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = response.content.decode(response.charset)",
            "",
            "            # Check app banner is rendered correctly",
            "            self.assertIn(",
            "                f\"<div>You are viewing a table of {self.model._meta.verbose_name_plural}</div>\", response_body",
            "            )",
            "",
            "    class CreateMultipleObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Create multiple instances using a single form. Expects the creation of three new instances by default.",
            "",
            "        :bulk_create_count: The number of objects expected to be created (default: 3).",
            "        :bulk_create_data: A dictionary of data to be used for bulk object creation.",
            "        \"\"\"",
            "",
            "        bulk_create_count = 3",
            "        bulk_create_data = {}",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_without_permission(self):",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(**request), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign non-constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Bulk create objects",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_create_multiple_objects_with_constrained_permission(self):",
            "            initial_count = self._get_queryset().count()",
            "            request = {",
            "                \"path\": self._get_url(\"add\"),",
            "                \"data\": utils.post_data(self.bulk_create_data),",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                actions=[\"add\"],",
            "                constraints={\"pk\": uuid.uuid4()},  # Match a non-existent pk (i.e., deny all)",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to make the request with unmet constraints",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update the ObjectPermission to allow creation",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Set constraint to allow all",
            "            obj_perm.save()",
            "",
            "            response = self.client.post(**request)",
            "            self.assertHttpStatus(response, 302)",
            "            self.assertEqual(initial_count + self.bulk_create_count, self._get_queryset().count())",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, self.bulk_create_data)",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "    class BulkImportObjectsViewTestCase(ModelViewTestCase):  # 3.0 TODO: remove this test mixin, no longer relevant.",
            "        \"\"\"",
            "        Vestigial test case, to be removed in 3.0.",
            "",
            "        This is vestigial since the introduction of the ImportObjects system Job to handle bulk-import of all",
            "        content-types via REST API serializers. The parsing of CSV data by the serializer is exercised by",
            "        APIViewTestCases.CreateObjectViewTestCase.test_recreate_object_csv(), and the basic operation of the Job is",
            "        exercised by nautobot.core.tests.test_jobs.",
            "        \"\"\"",
            "",
            "        csv_data = ()",
            "",
            "        def _get_csv_data(self):",
            "            return \"\\n\".join(self.csv_data)",
            "",
            "        # Just in case Apps are extending any of these tests and calling super() in them.",
            "        def test_bulk_import_objects_without_permission(self):",
            "            pass",
            "",
            "        def test_bulk_import_objects_with_permission(self):",
            "            pass",
            "",
            "        def test_bulk_import_objects_with_permission_csv_file(self):",
            "            pass",
            "",
            "        def test_bulk_import_objects_with_constrained_permission(self):",
            "            pass",
            "",
            "    class BulkEditObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Edit multiple instances.",
            "",
            "        :bulk_edit_data: A dictionary of data to be used when bulk editing a set of objects. This data should differ",
            "                         from that used for initial object creation within setUpTestData().",
            "        \"\"\"",
            "",
            "        bulk_edit_data = {}",
            "",
            "        def validate_object_data_after_bulk_edit(self, pk_list):",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertInstanceEqual(instance, self.bulk_edit_data)",
            "",
            "        def test_bulk_edit_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "",
            "            # Append the form data to the request",
            "            data.update(utils.post_data(self.bulk_edit_data))",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            self.validate_object_data_after_bulk_edit(pk_list)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_edit with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pk\"",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"_all\": \"on\",",
            "            }",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk edit table.",
            "            # after pressing Edit Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkEditForm/BulkUpdateForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_form_contains_all_filtered(self):",
            "            # We are testing the intermediary step of bulk_edit with pagination applied and additional filter.",
            "            # i.e. \"_all\" passed in the form and filter using query params.",
            "            self.add_permissions(f\"{self.model._meta.app_label}.change_{self.model._meta.model_name}\")",
            "",
            "            pk_iter = iter(self._get_queryset().values_list(\"pk\", flat=True))",
            "            try:",
            "                first_pk = next(pk_iter)",
            "                second_pk = next(pk_iter)",
            "                third_pk = next(pk_iter)",
            "            except StopIteration:",
            "                self.fail(f\"Test requires at least three instances of {self.model._meta.model_name} to be defined.\")",
            "",
            "            post_data = utils.post_data(self.bulk_edit_data)",
            "",
            "            # Open bulk update form with first two objects",
            "            selected_data = {",
            "                \"pk\": third_pk,  # This is ignored when filtering with \"_all\"",
            "                \"_all\": \"on\",",
            "                **post_data,",
            "            }",
            "            query_string = urlencode({\"id\": (first_pk, second_pk)}, doseq=True)",
            "            response = self.client.post(f\"{self._get_url('bulk_edit')}?{query_string}\", selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk edit table after pressing Edit Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if the first and second pk is passed into the form.",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{first_pk}\"', response_body)",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{second_pk}\"', response_body)",
            "            self.assertIn(\"Editing 2 \", response_body)",
            "            # Check if the third pk is not passed into the form.",
            "            self.assertNotIn(f'<input type=\"hidden\" name=\"pk\" value=\"{third_pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_edit_objects_with_constrained_permission(self):",
            "            # Select some objects that are *not* already set to match the first value in self.bulk_edit_data or null.",
            "            # We have to exclude null cases because Django filter()/exclude() doesn't like `__in=[None]` as a case.",
            "            attr_name = next(iter(self.bulk_edit_data.keys()))",
            "            objects = (",
            "                self._get_queryset()",
            "                .exclude(**{attr_name: self.bulk_edit_data[attr_name]})",
            "                .exclude(**{f\"{attr_name}__isnull\": True})",
            "            )[:3]",
            "            self.assertEqual(objects.count(), 3)",
            "            pk_list = list(objects.values_list(\"pk\", flat=True))",
            "",
            "            # Define a permission that permits the above objects, but will not permit them after updating them.",
            "            field = self.model._meta.get_field(attr_name)",
            "            values = [field.value_from_object(obj) for obj in objects]",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={f\"{attr_name}__in\": values},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Build form data",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(utils.post_data(self.bulk_edit_data))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_edit\"), data)",
            "            # 200 because we're sent back to the edit form to try again; if the update were successful it'd be a 302",
            "            self.assertHttpStatus(response, 200)",
            "            # Assert that the objects are NOT updated",
            "            for instance in self._get_queryset().filter(pk__in=pk_list):",
            "                self.assertIn(field.value_from_object(instance), values)",
            "                self.assertNotEqual(field.value_from_object(instance), self.bulk_edit_data[attr_name])",
            "",
            "            # Update permission constraints to permit all objects",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk edit permitted objects and expect a redirect back to the list view",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_edit\"), data), 302)",
            "            # Assert that the objects were all updated correctly",
            "            self.validate_object_data_after_bulk_edit(pk_list)",
            "",
            "    class BulkDeleteObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Delete multiple instances.",
            "        \"\"\"",
            "",
            "        def get_deletable_object_pks(self):",
            "            \"\"\"",
            "            Get a list of PKs corresponding to objects that can be safely bulk-deleted.",
            "",
            "            For some models this may just be any random objects, but when we have FKs with `on_delete=models.PROTECT`",
            "            (as is often the case) we need to find or create an instance that doesn't have such entanglements.",
            "            \"\"\"",
            "            return utils.get_deletable_objects(self.model, self._get_queryset()).values_list(\"pk\", flat=True)[:3]",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_without_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_form_contains_all_pks(self):",
            "            # We are testing the intermediary step of bulk_delete with pagination applied.",
            "            # i.e. \"_all\" passed in the form.",
            "            pk_list = self._get_queryset().values_list(\"pk\", flat=True)",
            "            # We only pass in one pk to test the functionality of \"_all\"",
            "            # which should grab all instance pks regardless of \"pks\".",
            "            selected_data = {",
            "                \"pk\": pk_list[:1],",
            "                \"confirm\": True,",
            "                \"_all\": \"on\",",
            "            }",
            "",
            "            # Assign unconstrained permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"delete\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with the selected data first. Emulating selecting all -> pressing Delete Selected button.",
            "            response = self.client.post(self._get_url(\"bulk_delete\"), selected_data)",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if all the pks are passed into the BulkDeleteForm/BulkDestroyForm",
            "            for pk in pk_list:",
            "                self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_delete_form_contains_all_filtered(self):",
            "            # We are testing the intermediary step of bulk_delete with pagination applied and additional filter.",
            "            # i.e. \"_all\" passed in the form and filter using query params.",
            "            self.add_permissions(f\"{self.model._meta.app_label}.delete_{self.model._meta.model_name}\")",
            "",
            "            pk_iter = iter(self._get_queryset().values_list(\"pk\", flat=True))",
            "            try:",
            "                first_pk = next(pk_iter)",
            "                second_pk = next(pk_iter)",
            "                third_pk = next(pk_iter)",
            "            except StopIteration:",
            "                self.fail(f\"Test requires at least three instances of {self.model._meta.model_name} to be defined.\")",
            "",
            "            # Open bulk delete form with first two objects",
            "            selected_data = {",
            "                \"pk\": third_pk,  # This is ignored when filtering with \"_all\"",
            "                \"_all\": \"on\",",
            "            }",
            "            query_string = urlencode({\"id\": (first_pk, second_pk)}, doseq=True)",
            "            response = self.client.post(f\"{self._get_url('bulk_delete')}?{query_string}\", selected_data)",
            "            # Expect a 200 status cause we are only rendering the bulk delete table after pressing Delete Selected button.",
            "            self.assertHttpStatus(response, 200)",
            "            response_body = utils.extract_page_body(response.content.decode(response.charset))",
            "            # Check if the first and second pk is passed into the form.",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{first_pk}\"', response_body)",
            "            self.assertIn(f'<input type=\"hidden\" name=\"pk\" value=\"{second_pk}\"', response_body)",
            "            self.assertIn(\"<strong>Warning:</strong> The following operation will delete 2 \", response_body)",
            "            # Check if the third pk is not passed into the form.",
            "            self.assertNotIn(f'<input type=\"hidden\" name=\"pk\" value=\"{third_pk}\"', response_body)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "        def test_bulk_delete_objects_with_constrained_permission(self):",
            "            pk_list = self.get_deletable_object_pks()",
            "            initial_count = self._get_queryset().count()",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"confirm\": True,",
            "                \"_confirm\": True,  # Form button",
            "            }",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"pk\": str(uuid.uuid4())},  # Match a non-existent pk (i.e., deny all)",
            "                actions=[\"delete\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk delete non-permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__isnull\": False}  # Match a non-existent pk (i.e., allow all)",
            "            obj_perm.save()",
            "",
            "            # Bulk delete permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_delete\"), data), 302)",
            "            self.assertEqual(self._get_queryset().count(), initial_count - len(pk_list))",
            "",
            "    class BulkRenameObjectsViewTestCase(ModelViewTestCase):",
            "        \"\"\"",
            "        Rename multiple instances.",
            "        \"\"\"",
            "",
            "        rename_data = {",
            "            \"find\": \"^(.*)$\",",
            "            \"replace\": \"\\\\1X\",  # Append an X to the original value",
            "            \"use_regex\": True,",
            "        }",
            "",
            "        def test_bulk_rename_objects_without_permission(self):",
            "            pk_list = list(self._get_queryset().values_list(\"pk\", flat=True)[:3])",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Test GET without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.get(self._get_url(\"bulk_rename\")), 403)",
            "",
            "            # Try POST without permission",
            "            with utils.disable_warnings(\"django.request\"):",
            "                self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 403)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign model-level permission",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Try POST with model-level permission",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename_objects_with_constrained_permission(self):",
            "            objects = list(self._get_queryset().all()[:3])",
            "            pk_list = [obj.pk for obj in objects]",
            "            data = {",
            "                \"pk\": pk_list,",
            "                \"_apply\": True,  # Form button",
            "            }",
            "            data.update(self.rename_data)",
            "",
            "            # Assign constrained permission",
            "            obj_perm = users_models.ObjectPermission(",
            "                name=\"Test permission\",",
            "                constraints={\"name__regex\": \"[^X]$\"},",
            "                actions=[\"change\"],",
            "            )",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            # Attempt to bulk edit permitted objects into a non-permitted state",
            "            response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "            self.assertHttpStatus(response, 200)",
            "",
            "            # Update permission constraints",
            "            obj_perm.constraints = {\"pk__gt\": 0}",
            "            obj_perm.save()",
            "",
            "            # Bulk rename permitted objects",
            "            self.assertHttpStatus(self.client.post(self._get_url(\"bulk_rename\"), data), 302)",
            "            for i, instance in enumerate(self._get_queryset().filter(pk__in=pk_list)):",
            "                self.assertEqual(instance.name, f\"{objects[i].name}X\")",
            "",
            "    class PrimaryObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing all standard View functions for primary objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class OrganizationalObjectViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        CreateObjectViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for all organizational objects",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentTemplateViewTestCase(",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component template models (ConsolePortTemplates, InterfaceTemplates, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "",
            "    class DeviceComponentViewTestCase(",
            "        GetObjectViewTestCase,",
            "        GetObjectChangelogViewTestCase,",
            "        GetObjectNotesViewTestCase,",
            "        EditObjectViewTestCase,",
            "        DeleteObjectViewTestCase,",
            "        ListObjectsViewTestCase,",
            "        CreateMultipleObjectsViewTestCase,",
            "        BulkEditObjectsViewTestCase,",
            "        BulkRenameObjectsViewTestCase,",
            "        BulkDeleteObjectsViewTestCase,",
            "    ):",
            "        \"\"\"",
            "        TestCase suitable for testing device component models (ConsolePorts, Interfaces, etc.)",
            "        \"\"\"",
            "",
            "        maxDiff = None",
            "        bulk_add_data = None",
            "        \"\"\"Used for bulk-add (distinct from bulk-create) view testing; self.bulk_create_data will be used if unset.\"\"\"",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_add_component(self):",
            "            \"\"\"Test bulk-adding this component to devices/virtual-machines.\"\"\"",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"add\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            initial_count = self._get_queryset().count()",
            "",
            "            data = (self.bulk_add_data or self.bulk_create_data).copy()",
            "",
            "            # Load the device-bulk-add or virtualmachine-bulk-add form",
            "            if \"device\" in data:",
            "                url = reverse(f\"dcim:device_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": utils.post_data({\"pk\": data[\"device\"]}),",
            "                }",
            "            else:",
            "                url = reverse(f\"virtualization:virtualmachine_bulk_add_{self.model._meta.model_name}\")",
            "                request = {",
            "                    \"path\": url,",
            "                    \"data\": utils.post_data({\"pk\": data[\"virtual_machine\"]}),",
            "                }",
            "            self.assertHttpStatus(self.client.post(**request), 200)",
            "",
            "            # Post to the device-bulk-add or virtualmachine-bulk-add form to create records",
            "            if \"device\" in data:",
            "                data[\"pk\"] = data.pop(\"device\")",
            "            else:",
            "                data[\"pk\"] = data.pop(\"virtual_machine\")",
            "            data[\"_create\"] = \"\"",
            "            request[\"data\"] = utils.post_data(data)",
            "            self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "            updated_count = self._get_queryset().count()",
            "            self.assertEqual(updated_count, initial_count + self.bulk_create_count)",
            "",
            "            matching_count = 0",
            "            for instance in self._get_queryset().all():",
            "                try:",
            "                    self.assertInstanceEqual(instance, (self.bulk_add_data or self.bulk_create_data))",
            "                    matching_count += 1",
            "                except AssertionError:",
            "                    pass",
            "            self.assertEqual(matching_count, self.bulk_create_count)",
            "",
            "        @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "        def test_bulk_rename(self):",
            "            obj_perm = users_models.ObjectPermission(name=\"Test permission\", actions=[\"change\"])",
            "            obj_perm.save()",
            "            obj_perm.users.add(self.user)",
            "            obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "            objects = self.selected_objects",
            "            pk_list = [obj.pk for obj in objects]",
            "            # Apply button not yet clicked",
            "            data = {\"pk\": pk_list}",
            "            data.update(self.rename_data)",
            "            verbose_name_plural = self.model._meta.verbose_name_plural",
            "",
            "            with self.subTest(\"Assert device name in HTML\"):",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                message = (",
            "                    f\"Renaming {len(objects)} {helpers.bettertitle(verbose_name_plural)} \"",
            "                    f\"on {self.selected_objects_parent_name}\"",
            "                )",
            "                self.assertInHTML(message, response.content.decode(response.charset))",
            "",
            "            with self.subTest(\"Assert update successfully\"):",
            "                data[\"_apply\"] = True  # Form Apply button",
            "                response = self.client.post(self._get_url(\"bulk_rename\"), data)",
            "                self.assertHttpStatus(response, 302)",
            "                queryset = self._get_queryset().filter(pk__in=pk_list)",
            "                for instance in objects:",
            "                    self.assertEqual(queryset.get(pk=instance.pk).name, f\"{instance.name}X\")",
            "",
            "            with self.subTest(\"Assert if no valid objects selected return with error\"):",
            "                for values in ([], [str(uuid.uuid4())]):",
            "                    data[\"pk\"] = values",
            "                    response = self.client.post(self._get_url(\"bulk_rename\"), data, follow=True)",
            "                    expected_message = f\"No valid {verbose_name_plural} were selected.\"",
            "                    self.assertIn(expected_message, response.content.decode(response.charset))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "233": [
                "ViewTestCases",
                "GetObjectViewTestCase",
                "test_get_object_with_constrained_permission"
            ]
        },
        "addLocation": [
            "tensorflow.python.kernel_tests.array_ops.array_ops_test.SliceAssignTest.testTensorStridedSliceUpdateNoInputForward",
            "nautobot.core.testing.views.ViewTestCases.GetObjectViewTestCase.self",
            "nautobot.core.testing.views.ModelTestCase.self"
        ]
    },
    "nautobot/extras/api/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "     # @extend_schema(methods=[\"get\"], responses={200: member_response})"
            },
            "1": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "     @action(detail=True, methods=[\"get\"])"
            },
            "2": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 306,
                "PatchRowcode": "     def members(self, request, pk, *args, **kwargs):"
            },
            "3": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"List member objects of the same type as the `content_type` for this dynamic group.\"\"\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        \"\"\"List the member objects of this dynamic group.\"\"\""
            },
            "5": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         instance = get_object_or_404(self.queryset, pk=pk)"
            },
            "6": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 309,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "         # Retrieve the serializer for the content_type and paginate the results"
            },
            "8": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "         member_model_class = instance.content_type.model_class()"
            },
            "9": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "         member_serializer_class = get_serializer_for_model(member_model_class)"
            },
            "10": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        members = self.paginate_queryset(instance.members)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+        members = self.paginate_queryset(instance.members.restrict(request.user, \"view\"))"
            },
            "12": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "         member_serializer = member_serializer_class(members, many=True, context={\"request\": request})"
            },
            "13": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "         return self.get_paginated_response(member_serializer.data)"
            },
            "14": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 316,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from datetime import timedelta",
            "",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.forms import ValidationError as FormsValidationError",
            "from django.http import FileResponse, Http404",
            "from django.shortcuts import get_object_or_404",
            "from django.utils import timezone",
            "from drf_spectacular.types import OpenApiTypes",
            "from drf_spectacular.utils import extend_schema, extend_schema_view, OpenApiParameter",
            "from graphene_django.views import GraphQLView",
            "from graphql import GraphQLError",
            "from rest_framework import mixins, status, viewsets",
            "from rest_framework.decorators import action",
            "from rest_framework.exceptions import MethodNotAllowed, PermissionDenied, ValidationError",
            "from rest_framework.parsers import JSONParser, MultiPartParser",
            "from rest_framework.permissions import IsAuthenticated",
            "from rest_framework.response import Response",
            "",
            "from nautobot.core.api.authentication import TokenPermissions",
            "from nautobot.core.api.utils import get_serializer_for_model",
            "from nautobot.core.api.views import (",
            "    BulkDestroyModelMixin,",
            "    BulkUpdateModelMixin,",
            "    ModelViewSet,",
            "    ModelViewSetMixin,",
            "    NautobotAPIVersionMixin,",
            "    ReadOnlyModelViewSet,",
            ")",
            "from nautobot.core.exceptions import CeleryWorkerNotRunningException",
            "from nautobot.core.graphql import execute_saved_query",
            "from nautobot.core.models.querysets import count_related",
            "from nautobot.extras import filters",
            "from nautobot.extras.choices import JobExecutionType",
            "from nautobot.extras.filters import RoleFilterSet",
            "from nautobot.extras.jobs import get_job",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomFieldChoice,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    FileProxy,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Team,",
            "    Webhook,",
            ")",
            "from nautobot.extras.secrets.exceptions import SecretError",
            "from nautobot.extras.utils import get_worker_count",
            "",
            "from . import serializers",
            "",
            "",
            "class NotesViewSetMixin:",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply \"view\" permissions on the POST /notes/ endpoint, otherwise as ModelViewSetMixin.",
            "        \"\"\"",
            "        if request.user.is_authenticated and self.action == \"notes\":",
            "            self.queryset = self.queryset.restrict(request.user, \"view\")",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class CreateNotePermissions(TokenPermissions):",
            "        \"\"\"As nautobot.core.api.authentication.TokenPermissions, but enforcing add_note permission.\"\"\"",
            "",
            "        perms_map = {",
            "            \"GET\": [\"%(app_label)s.view_%(model_name)s\", \"extras.view_note\"],",
            "            \"POST\": [\"%(app_label)s.view_%(model_name)s\", \"extras.add_note\"],",
            "        }",
            "",
            "    @extend_schema(methods=[\"get\"], filters=False, responses={200: serializers.NoteSerializer(many=True)})",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.NoteInputSerializer,",
            "        responses={201: serializers.NoteSerializer(many=False)},",
            "    )",
            "    @action(detail=True, url_path=\"notes\", methods=[\"get\", \"post\"], permission_classes=[CreateNotePermissions])",
            "    def notes(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        API methods for returning or creating notes on an object.",
            "        \"\"\"",
            "        obj = get_object_or_404(",
            "            self.queryset, **{self.lookup_field: self.kwargs[self.lookup_url_kwarg or self.lookup_field]}",
            "        )",
            "        if request.method == \"POST\":",
            "            content_type = ContentType.objects.get_for_model(obj)",
            "            data = request.data",
            "            data[\"assigned_object_id\"] = obj.pk",
            "            data[\"assigned_object_type\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            serializer = serializers.NoteSerializer(data=data, context={\"request\": request})",
            "",
            "            # Create the new Note.",
            "            serializer.is_valid(raise_exception=True)",
            "            serializer.save(user=request.user)",
            "            return Response(serializer.data, status=status.HTTP_201_CREATED)",
            "",
            "        else:",
            "            notes = self.paginate_queryset(obj.notes)",
            "            serializer = serializers.NoteSerializer(notes, many=True, context={\"request\": request})",
            "",
            "        return self.get_paginated_response(serializer.data)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = ComputedField.objects.all()",
            "    serializer_class = serializers.ComputedFieldSerializer",
            "    filterset_class = filters.ComputedFieldFilterSet",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextQuerySetMixin:",
            "    \"\"\"",
            "    Used by views that work with config context models (device and virtual machine).",
            "    Provides a get_queryset() method which deals with adding the config context",
            "    data annotation or not.",
            "    \"\"\"",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Build the proper queryset based on the request context",
            "",
            "        If the `include` query param includes `config_context`, return the queryset annotated with config context.",
            "",
            "        Else, return the base queryset.",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        request = self.get_serializer_context()[\"request\"]",
            "        if request is not None and \"config_context\" in request.query_params.get(\"include\", []):",
            "            return queryset.annotate_config_context_data()",
            "        return queryset",
            "",
            "",
            "class ConfigContextViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = ConfigContext.objects.prefetch_related(",
            "        \"locations\",",
            "        \"roles\",",
            "        \"device_types\",",
            "        \"platforms\",",
            "        \"tenant_groups\",",
            "        \"tenants\",",
            "    )",
            "    serializer_class = serializers.ConfigContextSerializer",
            "    filterset_class = filters.ConfigContextFilterSet",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    serializer_class = serializers.ConfigContextSchemaSerializer",
            "    filterset_class = filters.ConfigContextSchemaFilterSet",
            "",
            "",
            "#",
            "# ContentTypes",
            "#",
            "",
            "",
            "class ContentTypeViewSet(viewsets.ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Read-only list of ContentTypes. Limit results to ContentTypes pertinent to Nautobot objects.",
            "    \"\"\"",
            "",
            "    permission_classes = [IsAuthenticated]",
            "    queryset = ContentType.objects.order_by(\"app_label\", \"model\")",
            "    serializer_class = serializers.ContentTypeSerializer",
            "    filterset_class = filters.ContentTypeFilterSet",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "class CustomFieldViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = CustomField.objects.all()",
            "    serializer_class = serializers.CustomFieldSerializer",
            "    filterset_class = filters.CustomFieldFilterSet",
            "",
            "",
            "class CustomFieldChoiceViewSet(ModelViewSet):",
            "    queryset = CustomFieldChoice.objects.all()",
            "    serializer_class = serializers.CustomFieldChoiceSerializer",
            "    filterset_class = filters.CustomFieldChoiceFilterSet",
            "",
            "",
            "class CustomFieldModelViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Include the applicable set of CustomFields in the ModelViewSet context.",
            "    \"\"\"",
            "",
            "    def get_serializer_context(self):",
            "        # Gather all custom fields for the model",
            "        content_type = ContentType.objects.get_for_model(self.queryset.model)",
            "        custom_fields = content_type.custom_fields.all()",
            "",
            "        context = super().get_serializer_context()",
            "        context.update(",
            "            {",
            "                \"custom_fields\": custom_fields,",
            "            }",
            "        )",
            "        return context",
            "",
            "",
            "class NautobotModelViewSet(NotesViewSetMixin, CustomFieldModelViewSet):",
            "    \"\"\"Base class to use for API ViewSets based on OrganizationalModel or PrimaryModel.",
            "",
            "    Can also be used for models derived from BaseModel, so long as they support Notes.",
            "    \"\"\"",
            "",
            "",
            "#",
            "# Contacts",
            "#",
            "",
            "",
            "class ContactViewSet(NautobotModelViewSet):",
            "    queryset = Contact.objects.all()",
            "    serializer_class = serializers.ContactSerializer",
            "    filterset_class = filters.ContactFilterSet",
            "",
            "",
            "class ContactAssociationViewSet(NautobotModelViewSet):",
            "    queryset = ContactAssociation.objects.all()",
            "    serializer_class = serializers.ContactAssociationSerializer",
            "    filterset_class = filters.ContactAssociationFilterSet",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = CustomLink.objects.all()",
            "    serializer_class = serializers.CustomLinkSerializer",
            "    filterset_class = filters.CustomLinkFilterSet",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroup.objects.select_related(\"content_type\")",
            "    serializer_class = serializers.DynamicGroupSerializer",
            "    filterset_class = filters.DynamicGroupFilterSet",
            "",
            "    # FIXME(jathan): Figure out how to do dynamic `responses` serializer based on the `content_type`",
            "    # of the DynamicGroup? May not be possible or even desirable to have a \"dynamic schema\".",
            "    # @extend_schema(methods=[\"get\"], responses={200: member_response})",
            "    @action(detail=True, methods=[\"get\"])",
            "    def members(self, request, pk, *args, **kwargs):",
            "        \"\"\"List member objects of the same type as the `content_type` for this dynamic group.\"\"\"",
            "        instance = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        # Retrieve the serializer for the content_type and paginate the results",
            "        member_model_class = instance.content_type.model_class()",
            "        member_serializer_class = get_serializer_for_model(member_model_class)",
            "        members = self.paginate_queryset(instance.members)",
            "        member_serializer = member_serializer_class(members, many=True, context={\"request\": request})",
            "        return self.get_paginated_response(member_serializer.data)",
            "",
            "",
            "class DynamicGroupMembershipViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroupMembership.objects.select_related(\"group\", \"parent_group\")",
            "    serializer_class = serializers.DynamicGroupMembershipSerializer",
            "    filterset_class = filters.DynamicGroupMembershipFilterSet",
            "",
            "",
            "#",
            "# Export templates",
            "#",
            "",
            "",
            "class ExportTemplateViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = ExportTemplate.objects.all()",
            "    serializer_class = serializers.ExportTemplateSerializer",
            "    filterset_class = filters.ExportTemplateFilterSet",
            "",
            "",
            "#",
            "# External integrations",
            "#",
            "",
            "",
            "class ExternalIntegrationViewSet(NautobotModelViewSet):",
            "    queryset = ExternalIntegration.objects.select_related(\"secrets_group\")",
            "    serializer_class = serializers.ExternalIntegrationSerializer",
            "    filterset_class = filters.ExternalIntegrationFilterSet",
            "",
            "",
            "#",
            "# File proxies",
            "#",
            "",
            "",
            "class FileProxyViewSet(ReadOnlyModelViewSet):",
            "    queryset = FileProxy.objects.select_related(\"job_result\")",
            "    serializer_class = serializers.FileProxySerializer",
            "    filterset_class = filters.FileProxyFilterSet",
            "",
            "    @extend_schema(",
            "        methods=[\"get\"],",
            "        responses=OpenApiTypes.BINARY,",
            "    )",
            "    @action(",
            "        detail=True,",
            "        methods=[\"get\"],",
            "    )",
            "    def download(self, request, *args, **kwargs):",
            "        \"\"\"Download the specified FileProxy.\"\"\"",
            "        file_proxy = self.get_object()",
            "        return FileResponse(file_proxy.file.open(\"rb\"), as_attachment=True)",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage the use of Git repositories as external data sources.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    serializer_class = serializers.GitRepositorySerializer",
            "    filterset_class = filters.GitRepositoryFilterSet",
            "",
            "    @extend_schema(methods=[\"post\"], request=serializers.GitRepositorySerializer)",
            "    # Since we are explicitly checking for `extras:change_gitrepository` in the API sync() method",
            "    # We explicitly set the permission_classes to IsAuthenticated in the @action decorator",
            "    # bypassing the default DRF permission check for `extras:add_gitrepository` and the permission check fall through to the function itself.",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[IsAuthenticated])",
            "    def sync(self, request, pk):",
            "        \"\"\"",
            "        Enqueue pull git repository and refresh data.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "            raise PermissionDenied(\"This user does not have permission to make changes to Git repositories.\")",
            "",
            "        if not get_worker_count():",
            "            raise CeleryWorkerNotRunningException()",
            "",
            "        repository = get_object_or_404(GitRepository, id=pk)",
            "        repository.sync(user=request.user)",
            "        return Response({\"message\": f\"Repository {repository} sync job added to queue.\"})",
            "",
            "",
            "#",
            "# GraphQL Queries",
            "#",
            "",
            "",
            "class GraphQLQueryViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = GraphQLQuery.objects.all()",
            "    serializer_class = serializers.GraphQLQuerySerializer",
            "    filterset_class = filters.GraphQLQueryFilterSet",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.GraphQLQueryInputSerializer,",
            "        responses={\"200\": serializers.GraphQLQueryOutputSerializer},",
            "    )",
            "    @action(detail=True, methods=[\"post\"])",
            "    def run(self, request, pk):",
            "        try:",
            "            query = get_object_or_404(self.queryset, pk=pk)",
            "            result = execute_saved_query(query.name, variables=request.data.get(\"variables\"), request=request).to_dict()",
            "            return Response(result)",
            "        except GraphQLError as error:",
            "            return Response(",
            "                {\"errors\": [GraphQLView.format_error(error)]},",
            "                status=status.HTTP_400_BAD_REQUEST,",
            "            )",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentViewSet(ModelViewSet):",
            "    queryset = ImageAttachment.objects.all()",
            "    serializer_class = serializers.ImageAttachmentSerializer",
            "    filterset_class = filters.ImageAttachmentFilterSet",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "def _create_schedule(serializer, data, job_model, user, approval_required, task_queue=None):",
            "    \"\"\"",
            "    This is an internal function to create a scheduled job from API data.",
            "    It has to handle both once-offs (i.e. of type TYPE_FUTURE) and interval",
            "    jobs.",
            "    \"\"\"",
            "    type_ = serializer[\"interval\"]",
            "    if type_ == JobExecutionType.TYPE_IMMEDIATELY:",
            "        time = timezone.now()",
            "        name = serializer.get(\"name\") or f\"{job_model.name} - {time}\"",
            "    elif type_ == JobExecutionType.TYPE_CUSTOM:",
            "        time = serializer.get(\"start_time\")  # doing .get(\"key\", \"default\") returns None instead of \"default\"",
            "        if time is None:",
            "            # \"start_time\" is checked against models.ScheduledJob.earliest_possible_time()",
            "            # which returns timezone.now() + timedelta(seconds=15)",
            "            time = timezone.now() + timedelta(seconds=20)",
            "        name = serializer[\"name\"]",
            "    else:",
            "        time = serializer[\"start_time\"]",
            "        name = serializer[\"name\"]",
            "    crontab = serializer.get(\"crontab\", \"\")",
            "",
            "    celery_kwargs = {",
            "        \"nautobot_job_profile\": False,",
            "        \"queue\": task_queue,",
            "    }",
            "",
            "    # 2.0 TODO: To revisit this as part of a larger Jobs cleanup in 2.0.",
            "    #",
            "    # We pass in task and job_model here partly for forward/backward compatibility logic, and",
            "    # part fallback safety. It's mildly useful to store both the task module/class name and the JobModel",
            "    # FK on the ScheduledJob, as in the case where the JobModel gets deleted (and the FK becomes",
            "    # null) you still have a bit of context on the ScheduledJob as to what it was originally",
            "    # scheduled for.",
            "    scheduled_job = ScheduledJob(",
            "        name=name,",
            "        task=job_model.class_path,",
            "        job_model=job_model,",
            "        start_time=time,",
            "        description=f\"Nautobot job {name} scheduled by {user} for {time}\",",
            "        kwargs=data,",
            "        celery_kwargs=celery_kwargs,",
            "        interval=type_,",
            "        one_off=(type_ == JobExecutionType.TYPE_FUTURE),",
            "        user=user,",
            "        approval_required=approval_required,",
            "        crontab=crontab,",
            "        queue=task_queue,",
            "    )",
            "    scheduled_job.validated_save()",
            "    return scheduled_job",
            "",
            "",
            "class JobViewSetBase(",
            "    NautobotAPIVersionMixin,",
            "    # note no CreateModelMixin",
            "    mixins.RetrieveModelMixin,",
            "    mixins.UpdateModelMixin,",
            "    mixins.DestroyModelMixin,",
            "    NotesViewSetMixin,",
            "    ModelViewSetMixin,",
            "    viewsets.GenericViewSet,",
            "):",
            "    queryset = Job.objects.all()",
            "    serializer_class = serializers.JobSerializer",
            "    filterset_class = filters.JobFilterSet",
            "",
            "    @extend_schema(responses={\"200\": serializers.JobVariableSerializer(many=True)})",
            "    @action(detail=True, filterset_class=None)",
            "    def variables(self, request, *args, **kwargs):",
            "        \"\"\"Get details of the input variables that may/must be specified to run a particular Job.\"\"\"",
            "        job_model = self.get_object()",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        if job_class is None:",
            "            raise Http404",
            "        variables_dict = job_class._get_vars()",
            "        data = []",
            "        for name, instance in variables_dict.items():",
            "            entry = {\"name\": name, \"type\": instance.__class__.__name__}",
            "            for key in [",
            "                \"label\",",
            "                \"help_text\",",
            "                \"required\",",
            "                \"min_length\",",
            "                \"max_length\",",
            "                \"min_value\",",
            "                \"max_value\",",
            "                \"choices\",",
            "            ]:",
            "                if key in instance.field_attrs:",
            "                    entry[key] = instance.field_attrs[key]",
            "            if \"initial\" in instance.field_attrs:",
            "                entry[\"default\"] = instance.field_attrs[\"initial\"]",
            "            if \"queryset\" in instance.field_attrs:",
            "                content_type = ContentType.objects.get_for_model(instance.field_attrs[\"queryset\"].model)",
            "                entry[\"model\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            data.append(entry)",
            "        return Response(data)",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special \"run_job\" permission as queryset filter on the /run/ endpoint, otherwise as ModelViewSetMixin.",
            "        \"\"\"",
            "        if request.user.is_authenticated and self.action == \"run\":",
            "            self.queryset = self.queryset.restrict(request.user, \"run\")",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class JobRunTokenPermissions(TokenPermissions):",
            "        \"\"\"As nautobot.core.api.authentication.TokenPermissions, but enforcing run_job instead of add_job.\"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.run_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request={",
            "            \"application/json\": serializers.JobInputSerializer,",
            "            \"multipart/form-data\": serializers.JobMultiPartInputSerializer,",
            "        },",
            "        responses={\"201\": serializers.JobRunResponseSerializer},",
            "    )",
            "    @action(",
            "        detail=True,",
            "        methods=[\"post\"],",
            "        permission_classes=[JobRunTokenPermissions],",
            "        parser_classes=[JSONParser, MultiPartParser],",
            "    )",
            "    def run(self, request, *args, **kwargs):",
            "        \"\"\"Run the specified Job.\"\"\"",
            "        job_model = self.get_object()",
            "        if not request.user.has_perm(\"extras.run_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to run jobs.\")",
            "        if not job_model.enabled:",
            "            raise PermissionDenied(\"This job is not enabled to be run.\")",
            "        if not job_model.installed:",
            "            raise MethodNotAllowed(request.method, detail=\"This job is not presently installed and cannot be run\")",
            "        if job_model.has_sensitive_variables:",
            "            if (",
            "                \"schedule\" in request.data",
            "                and \"interval\" in request.data[\"schedule\"]",
            "                and request.data[\"schedule\"][\"interval\"] != JobExecutionType.TYPE_IMMEDIATELY",
            "            ):",
            "                raise ValidationError(",
            "                    {\"schedule\": {\"interval\": [\"Unable to schedule job: Job may have sensitive input variables\"]}}",
            "                )",
            "            if job_model.approval_required:",
            "                raise ValidationError(",
            "                    \"Unable to run or schedule job: \"",
            "                    \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                    \"One of these two flags must be removed before this job can be scheduled or run.\"",
            "                )",
            "",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        if job_class is None:",
            "            raise MethodNotAllowed(",
            "                request.method, detail=\"This job's source code could not be located and cannot be run\"",
            "            )",
            "",
            "        valid_queues = job_model.task_queues if job_model.task_queues else [settings.CELERY_TASK_DEFAULT_QUEUE]",
            "        # Get a default queue from either the job model's specified task queue or",
            "        # the system default to fall back on if request doesn't provide one",
            "        default_valid_queue = valid_queues[0]",
            "",
            "        # We need to call request.data for both cases as this is what pulls and caches the request data",
            "        data = request.data",
            "        files = None",
            "        schedule_data = None",
            "",
            "        # We must extract from the request:",
            "        # - Job Form data (for submission to the job itself)",
            "        # - Schedule data",
            "        # - Desired task queue",
            "        # Depending on request content type (largely for backwards compatibility) the keys at which these are found",
            "        # are different",
            "        if \"multipart/form-data\" in request.content_type:",
            "            data = request._data.dict()  # .data will return data and files, we just want the data",
            "            files = request.FILES",
            "",
            "            # JobMultiPartInputSerializer is a \"flattened\" version of JobInputSerializer",
            "            input_serializer = serializers.JobMultiPartInputSerializer(data=data, context={\"request\": request})",
            "            input_serializer.is_valid(raise_exception=True)",
            "",
            "            task_queue = input_serializer.validated_data.get(\"_task_queue\", default_valid_queue)",
            "",
            "            # JobMultiPartInputSerializer only has keys for executing job (task_queue, etc),",
            "            # everything else is a candidate for the job form's data.",
            "            # job_class.validate_data will throw an error for any unexpected key/value pairs.",
            "            non_job_keys = input_serializer.validated_data.keys()",
            "            for non_job_key in non_job_keys:",
            "                data.pop(non_job_key, None)",
            "",
            "            # List of keys in serializer that are effectively exploded versions of the schedule dictionary",
            "            # from JobInputSerializer",
            "            schedule_keys = (\"_schedule_name\", \"_schedule_start_time\", \"_schedule_interval\", \"_schedule_crontab\")",
            "",
            "            # Assign the key from the validated_data output to dictionary without prefixed \"_schedule_\"",
            "            # For all the keys that are schedule keys",
            "            # Assign only if the key is in the output since we don't want None's if not provided",
            "            if any(schedule_key in non_job_keys for schedule_key in schedule_keys):",
            "                schedule_data = {",
            "                    k.replace(\"_schedule_\", \"\"): input_serializer.validated_data[k]",
            "                    for k in schedule_keys",
            "                    if k in input_serializer.validated_data",
            "                }",
            "",
            "        else:",
            "            input_serializer = serializers.JobInputSerializer(data=data, context={\"request\": request})",
            "            input_serializer.is_valid(raise_exception=True)",
            "",
            "            data = input_serializer.validated_data.get(\"data\", {})",
            "            task_queue = input_serializer.validated_data.get(\"task_queue\", default_valid_queue)",
            "            schedule_data = input_serializer.validated_data.get(\"schedule\", None)",
            "",
            "        if task_queue not in valid_queues:",
            "            raise ValidationError({\"task_queue\": [f'\"{task_queue}\" is not a valid choice.']})",
            "",
            "        cleaned_data = None",
            "        try:",
            "            cleaned_data = job_class.validate_data(data, files=files)",
            "            cleaned_data = job_class.prepare_job_kwargs(cleaned_data)",
            "",
            "        except FormsValidationError as e:",
            "            # message_dict can only be accessed if ValidationError got a dict",
            "            # in the constructor (saved as error_dict). Otherwise we get a list",
            "            # of errors under messages",
            "            return Response({\"errors\": e.message_dict if hasattr(e, \"error_dict\") else e.messages}, status=400)",
            "",
            "        if not get_worker_count(queue=task_queue):",
            "            raise CeleryWorkerNotRunningException(queue=task_queue)",
            "",
            "        # Default to a null JobResult.",
            "        job_result = None",
            "",
            "        # Approval is not required for dryrun",
            "        if job_class.supports_dryrun:",
            "            dryrun = data.get(\"dryrun\", False)",
            "            approval_required = not dryrun and job_model.approval_required",
            "        else:",
            "            approval_required = job_model.approval_required",
            "",
            "        # Set schedule for jobs that require approval but request did not supply schedule data",
            "        if schedule_data is None and approval_required:",
            "            schedule_data = {\"interval\": JobExecutionType.TYPE_IMMEDIATELY}",
            "",
            "        # Skip creating a ScheduledJob when job can be executed immediately",
            "        elif schedule_data and schedule_data[\"interval\"] == JobExecutionType.TYPE_IMMEDIATELY and not approval_required:",
            "            schedule_data = None",
            "",
            "        # Try to create a ScheduledJob, or...",
            "        if schedule_data:",
            "            schedule = _create_schedule(",
            "                schedule_data,",
            "                job_class.serialize_data(cleaned_data),",
            "                job_model,",
            "                request.user,",
            "                approval_required,",
            "                task_queue=input_serializer.validated_data.get(\"task_queue\", None),",
            "            )",
            "        else:",
            "            schedule = None",
            "",
            "        # ... If we can't create one, create a JobResult instead.",
            "        if schedule is None:",
            "            job_result = JobResult.enqueue_job(",
            "                job_model,",
            "                request.user,",
            "                task_queue=task_queue,",
            "                **job_class.serialize_data(cleaned_data),",
            "            )",
            "",
            "        # New-style JobModelViewSet response - serialize the schedule or job_result as appropriate",
            "        data = {\"scheduled_job\": None, \"job_result\": None}",
            "        if schedule:",
            "            data[\"scheduled_job\"] = serializers.ScheduledJobSerializer(schedule, context={\"request\": request}).data",
            "        if job_result:",
            "            data[\"job_result\"] = serializers.JobResultSerializer(job_result, context={\"request\": request}).data",
            "        return Response(data, status=status.HTTP_201_CREATED)",
            "",
            "",
            "class JobViewSet(",
            "    JobViewSetBase,",
            "    mixins.ListModelMixin,",
            "    BulkUpdateModelMixin,",
            "    BulkDestroyModelMixin,",
            "):",
            "    lookup_value_regex = r\"[-0-9a-fA-F]+\"",
            "",
            "",
            "@extend_schema_view(",
            "    destroy=extend_schema(operation_id=\"extras_jobs_destroy_by_name\"),",
            "    partial_update=extend_schema(operation_id=\"extras_jobs_partial_update_by_name\"),",
            "    notes=extend_schema(methods=[\"get\"], operation_id=\"extras_jobs_notes_list_by_name\"),",
            "    retrieve=extend_schema(operation_id=\"extras_jobs_retrieve_by_name\"),",
            "    run=extend_schema(",
            "        methods=[\"post\"],",
            "        operation_id=\"extras_jobs_run_create_by_name\",",
            "        request={",
            "            \"application/json\": serializers.JobInputSerializer,",
            "            \"multipart/form-data\": serializers.JobMultiPartInputSerializer,",
            "        },",
            "        responses={\"201\": serializers.JobRunResponseSerializer},",
            "    ),",
            "    update=extend_schema(operation_id=\"extras_jobs_update_by_name\"),",
            "    variables=extend_schema(operation_id=\"extras_jobs_variables_list_by_name\"),",
            ")",
            "@extend_schema_view(",
            "    notes=extend_schema(methods=[\"post\"], operation_id=\"extras_jobs_notes_create_by_name\"),",
            ")",
            "class JobByNameViewSet(",
            "    JobViewSetBase,",
            "):",
            "    lookup_field = \"name\"",
            "    lookup_url_kwarg = \"name\"",
            "    lookup_value_regex = r\"[^/]+\"",
            "",
            "",
            "#",
            "# Job Hooks",
            "#",
            "",
            "",
            "class JobHooksViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobHook.objects.all()",
            "    serializer_class = serializers.JobHookSerializer",
            "    filterset_class = filters.JobHookFilterSet",
            "",
            "",
            "#",
            "# Job Results",
            "#",
            "",
            "",
            "class JobLogEntryViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of job log entries.",
            "    \"\"\"",
            "",
            "    queryset = JobLogEntry.objects.select_related(\"job_result\")",
            "    serializer_class = serializers.JobLogEntrySerializer",
            "    filterset_class = filters.JobLogEntryFilterSet",
            "",
            "",
            "class JobResultViewSet(",
            "    # DRF mixins:",
            "    # note no CreateModelMixin or UpdateModelMixin",
            "    mixins.DestroyModelMixin,",
            "    # Nautobot mixins:",
            "    BulkDestroyModelMixin,",
            "    # Base class",
            "    ReadOnlyModelViewSet,",
            "):",
            "    \"\"\"",
            "    Retrieve a list of job results",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.select_related(\"job_model\", \"user\")",
            "    serializer_class = serializers.JobResultSerializer",
            "    filterset_class = filters.JobResultFilterSet",
            "",
            "    @action(detail=True)",
            "    def logs(self, request, pk=None):",
            "        job_result = self.get_object()",
            "        logs = job_result.job_log_entries.all()",
            "        serializer = serializers.JobLogEntrySerializer(logs, context={\"request\": request}, many=True)",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    filterset_class = filters.JobButtonFilterSet",
            "",
            "",
            "#",
            "# Scheduled Jobs",
            "#",
            "",
            "",
            "class ScheduledJobViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of scheduled jobs",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.select_related(\"user\")",
            "    serializer_class = serializers.ScheduledJobSerializer",
            "    filterset_class = filters.ScheduledJobFilterSet",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special permissions as queryset filter on the /approve/, /deny/, and /dry-run/ endpoints.",
            "",
            "        Otherwise, same as ModelViewSetMixin.",
            "        \"\"\"",
            "        action_to_method = {\"approve\": \"change\", \"deny\": \"delete\", \"dry-run\": \"view\"}",
            "        if request.user.is_authenticated and self.action in action_to_method:",
            "            self.queryset = self.queryset.restrict(request.user, action_to_method[self.action])",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class ScheduledJobChangePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing change_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.change_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.ScheduledJobSerializer},",
            "        request=None,",
            "        parameters=[",
            "            OpenApiParameter(",
            "                \"force\",",
            "                location=OpenApiParameter.QUERY,",
            "                description=\"force execution even if start time has passed\",",
            "                type=OpenApiTypes.BOOL,",
            "            )",
            "        ],",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobChangePermissions])",
            "    def approve(self, request, pk):",
            "        scheduled_job = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to approve this request.\")",
            "",
            "        # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        if request.user == scheduled_job.user:",
            "            # The requestor *cannot* approve their own job",
            "            return Response(\"You cannot approve your own job request!\", status=403)",
            "",
            "        if (",
            "            scheduled_job.one_off",
            "            and scheduled_job.start_time < timezone.now()",
            "            and not request.query_params.get(\"force\")",
            "        ):",
            "            return Response(",
            "                \"The job's start time is in the past. If you want to force a run anyway, add the `force` query parameter.\",",
            "                status=400,",
            "            )",
            "",
            "        scheduled_job.approved_by_user = request.user",
            "        scheduled_job.approved_at = timezone.now()",
            "        scheduled_job.save()",
            "        serializer = serializers.ScheduledJobSerializer(scheduled_job, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    class ScheduledJobDeletePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing delete_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.delete_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=None,",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobDeletePermissions])",
            "    def deny(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to deny this request.\")",
            "",
            "        scheduled_job.delete()",
            "",
            "        return Response(None)",
            "",
            "    class ScheduledJobViewPermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing view_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.view_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.JobResultSerializer},",
            "        request=None,",
            "    )",
            "    @action(",
            "        detail=True,",
            "        name=\"Dry Run\",",
            "        url_path=\"dry-run\",",
            "        methods=[\"post\"],",
            "        permission_classes=[ScheduledJobViewPermissions],",
            "    )",
            "    def dry_run(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "        job_model = scheduled_job.job_model",
            "        if job_model is None or not job_model.runnable:",
            "            raise MethodNotAllowed(\"This job cannot be dry-run at this time.\")",
            "        if not job_model.supports_dryrun:",
            "            raise MethodNotAllowed(\"This job does not support dry-run.\")",
            "        if not Job.objects.check_perms(request.user, instance=job_model, action=\"run\"):",
            "            raise PermissionDenied(\"You do not have permission to run this job.\")",
            "",
            "        # Immediately enqueue the job",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        job_kwargs = job_class.prepare_job_kwargs(scheduled_job.kwargs or {})",
            "        job_kwargs[\"dryrun\"] = True",
            "        job_result = JobResult.enqueue_job(",
            "            job_model,",
            "            request.user,",
            "            celery_kwargs=scheduled_job.celery_kwargs or {},",
            "            **job_class.serialize_data(job_kwargs),",
            "        )",
            "        serializer = serializers.JobResultSerializer(job_result, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteViewSet(ModelViewSet):",
            "    queryset = Note.objects.select_related(\"user\")",
            "    serializer_class = serializers.NoteSerializer",
            "    filterset_class = filters.NoteFilterSet",
            "",
            "    # Assign user from request",
            "    def perform_create(self, serializer):",
            "        serializer.save(user=self.request.user)",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of recent changes.",
            "    \"\"\"",
            "",
            "    queryset = ObjectChange.objects.select_related(\"user\")",
            "    serializer_class = serializers.ObjectChangeSerializer",
            "    filterset_class = filters.ObjectChangeFilterSet",
            "",
            "",
            "#",
            "#  Relationships",
            "#",
            "",
            "",
            "class RelationshipViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = Relationship.objects.all()",
            "    serializer_class = serializers.RelationshipSerializer",
            "    filterset_class = filters.RelationshipFilterSet",
            "",
            "",
            "class RelationshipAssociationViewSet(ModelViewSet):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    serializer_class = serializers.RelationshipAssociationSerializer",
            "    filterset_class = filters.RelationshipAssociationFilterSet",
            "",
            "",
            "#",
            "# Roles",
            "#",
            "",
            "",
            "class RoleViewSet(NautobotModelViewSet):",
            "    queryset = Role.objects.all()",
            "    serializer_class = serializers.RoleSerializer",
            "    filterset_class = RoleFilterSet",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretsViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Secret.objects.all()",
            "    serializer_class = serializers.SecretSerializer",
            "    filterset_class = filters.SecretFilterSet",
            "",
            "    @extend_schema(",
            "        responses={",
            "            200: {",
            "                \"type\": \"object\",",
            "                \"properties\": {",
            "                    \"result\": {\"type\": \"boolean\"},",
            "                    \"message\": {\"type\": \"string\"},",
            "                },",
            "            }",
            "        },",
            "    )",
            "    @action(methods=[\"GET\"], detail=True)",
            "    def check(self, request, pk):",
            "        \"\"\"Check that a secret's value is accessible.\"\"\"",
            "        result = False",
            "        message = \"Unknown error\"",
            "        try:",
            "            self.get_object().get_value()",
            "            result = True",
            "            message = \"Passed\"",
            "        except SecretError as e:",
            "            message = str(e)",
            "        response = {\"result\": result, \"message\": message}",
            "        return Response(response)",
            "",
            "",
            "class SecretsGroupViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroup.objects.all()",
            "    serializer_class = serializers.SecretsGroupSerializer",
            "    filterset_class = filters.SecretsGroupFilterSet",
            "",
            "",
            "class SecretsGroupAssociationViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroupAssociation.objects.all()",
            "    serializer_class = serializers.SecretsGroupAssociationSerializer",
            "    filterset_class = filters.SecretsGroupAssociationFilterSet",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    View and manage custom status choices for objects with a `status` field.",
            "    \"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    serializer_class = serializers.StatusSerializer",
            "    filterset_class = filters.StatusFilterSet",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagViewSet(NautobotModelViewSet):",
            "    queryset = Tag.objects.annotate(tagged_items=count_related(TaggedItem, \"tag\"))",
            "    serializer_class = serializers.TagSerializer",
            "    filterset_class = filters.TagFilterSet",
            "",
            "",
            "#",
            "# Teams",
            "#",
            "",
            "",
            "class TeamViewSet(NautobotModelViewSet):",
            "    queryset = Team.objects.all()",
            "    serializer_class = serializers.TeamSerializer",
            "    filterset_class = filters.TeamFilterSet",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhooksViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Webhook.objects.all()",
            "    serializer_class = serializers.WebhookSerializer",
            "    filterset_class = filters.WebhookFilterSet"
        ],
        "afterPatchFile": [
            "from datetime import timedelta",
            "",
            "from django.conf import settings",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.forms import ValidationError as FormsValidationError",
            "from django.http import FileResponse, Http404",
            "from django.shortcuts import get_object_or_404",
            "from django.utils import timezone",
            "from drf_spectacular.types import OpenApiTypes",
            "from drf_spectacular.utils import extend_schema, extend_schema_view, OpenApiParameter",
            "from graphene_django.views import GraphQLView",
            "from graphql import GraphQLError",
            "from rest_framework import mixins, status, viewsets",
            "from rest_framework.decorators import action",
            "from rest_framework.exceptions import MethodNotAllowed, PermissionDenied, ValidationError",
            "from rest_framework.parsers import JSONParser, MultiPartParser",
            "from rest_framework.permissions import IsAuthenticated",
            "from rest_framework.response import Response",
            "",
            "from nautobot.core.api.authentication import TokenPermissions",
            "from nautobot.core.api.utils import get_serializer_for_model",
            "from nautobot.core.api.views import (",
            "    BulkDestroyModelMixin,",
            "    BulkUpdateModelMixin,",
            "    ModelViewSet,",
            "    ModelViewSetMixin,",
            "    NautobotAPIVersionMixin,",
            "    ReadOnlyModelViewSet,",
            ")",
            "from nautobot.core.exceptions import CeleryWorkerNotRunningException",
            "from nautobot.core.graphql import execute_saved_query",
            "from nautobot.core.models.querysets import count_related",
            "from nautobot.extras import filters",
            "from nautobot.extras.choices import JobExecutionType",
            "from nautobot.extras.filters import RoleFilterSet",
            "from nautobot.extras.jobs import get_job",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomFieldChoice,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    FileProxy,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Team,",
            "    Webhook,",
            ")",
            "from nautobot.extras.secrets.exceptions import SecretError",
            "from nautobot.extras.utils import get_worker_count",
            "",
            "from . import serializers",
            "",
            "",
            "class NotesViewSetMixin:",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply \"view\" permissions on the POST /notes/ endpoint, otherwise as ModelViewSetMixin.",
            "        \"\"\"",
            "        if request.user.is_authenticated and self.action == \"notes\":",
            "            self.queryset = self.queryset.restrict(request.user, \"view\")",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class CreateNotePermissions(TokenPermissions):",
            "        \"\"\"As nautobot.core.api.authentication.TokenPermissions, but enforcing add_note permission.\"\"\"",
            "",
            "        perms_map = {",
            "            \"GET\": [\"%(app_label)s.view_%(model_name)s\", \"extras.view_note\"],",
            "            \"POST\": [\"%(app_label)s.view_%(model_name)s\", \"extras.add_note\"],",
            "        }",
            "",
            "    @extend_schema(methods=[\"get\"], filters=False, responses={200: serializers.NoteSerializer(many=True)})",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.NoteInputSerializer,",
            "        responses={201: serializers.NoteSerializer(many=False)},",
            "    )",
            "    @action(detail=True, url_path=\"notes\", methods=[\"get\", \"post\"], permission_classes=[CreateNotePermissions])",
            "    def notes(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        API methods for returning or creating notes on an object.",
            "        \"\"\"",
            "        obj = get_object_or_404(",
            "            self.queryset, **{self.lookup_field: self.kwargs[self.lookup_url_kwarg or self.lookup_field]}",
            "        )",
            "        if request.method == \"POST\":",
            "            content_type = ContentType.objects.get_for_model(obj)",
            "            data = request.data",
            "            data[\"assigned_object_id\"] = obj.pk",
            "            data[\"assigned_object_type\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            serializer = serializers.NoteSerializer(data=data, context={\"request\": request})",
            "",
            "            # Create the new Note.",
            "            serializer.is_valid(raise_exception=True)",
            "            serializer.save(user=request.user)",
            "            return Response(serializer.data, status=status.HTTP_201_CREATED)",
            "",
            "        else:",
            "            notes = self.paginate_queryset(obj.notes)",
            "            serializer = serializers.NoteSerializer(notes, many=True, context={\"request\": request})",
            "",
            "        return self.get_paginated_response(serializer.data)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Computed Fields through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = ComputedField.objects.all()",
            "    serializer_class = serializers.ComputedFieldSerializer",
            "    filterset_class = filters.ComputedFieldFilterSet",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "",
            "class ConfigContextQuerySetMixin:",
            "    \"\"\"",
            "    Used by views that work with config context models (device and virtual machine).",
            "    Provides a get_queryset() method which deals with adding the config context",
            "    data annotation or not.",
            "    \"\"\"",
            "",
            "    def get_queryset(self):",
            "        \"\"\"",
            "        Build the proper queryset based on the request context",
            "",
            "        If the `include` query param includes `config_context`, return the queryset annotated with config context.",
            "",
            "        Else, return the base queryset.",
            "        \"\"\"",
            "        queryset = super().get_queryset()",
            "        request = self.get_serializer_context()[\"request\"]",
            "        if request is not None and \"config_context\" in request.query_params.get(\"include\", []):",
            "            return queryset.annotate_config_context_data()",
            "        return queryset",
            "",
            "",
            "class ConfigContextViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = ConfigContext.objects.prefetch_related(",
            "        \"locations\",",
            "        \"roles\",",
            "        \"device_types\",",
            "        \"platforms\",",
            "        \"tenant_groups\",",
            "        \"tenants\",",
            "    )",
            "    serializer_class = serializers.ConfigContextSerializer",
            "    filterset_class = filters.ConfigContextFilterSet",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "",
            "class ConfigContextSchemaViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    serializer_class = serializers.ConfigContextSchemaSerializer",
            "    filterset_class = filters.ConfigContextSchemaFilterSet",
            "",
            "",
            "#",
            "# ContentTypes",
            "#",
            "",
            "",
            "class ContentTypeViewSet(viewsets.ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Read-only list of ContentTypes. Limit results to ContentTypes pertinent to Nautobot objects.",
            "    \"\"\"",
            "",
            "    permission_classes = [IsAuthenticated]",
            "    queryset = ContentType.objects.order_by(\"app_label\", \"model\")",
            "    serializer_class = serializers.ContentTypeSerializer",
            "    filterset_class = filters.ContentTypeFilterSet",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "class CustomFieldViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = CustomField.objects.all()",
            "    serializer_class = serializers.CustomFieldSerializer",
            "    filterset_class = filters.CustomFieldFilterSet",
            "",
            "",
            "class CustomFieldChoiceViewSet(ModelViewSet):",
            "    queryset = CustomFieldChoice.objects.all()",
            "    serializer_class = serializers.CustomFieldChoiceSerializer",
            "    filterset_class = filters.CustomFieldChoiceFilterSet",
            "",
            "",
            "class CustomFieldModelViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Include the applicable set of CustomFields in the ModelViewSet context.",
            "    \"\"\"",
            "",
            "    def get_serializer_context(self):",
            "        # Gather all custom fields for the model",
            "        content_type = ContentType.objects.get_for_model(self.queryset.model)",
            "        custom_fields = content_type.custom_fields.all()",
            "",
            "        context = super().get_serializer_context()",
            "        context.update(",
            "            {",
            "                \"custom_fields\": custom_fields,",
            "            }",
            "        )",
            "        return context",
            "",
            "",
            "class NautobotModelViewSet(NotesViewSetMixin, CustomFieldModelViewSet):",
            "    \"\"\"Base class to use for API ViewSets based on OrganizationalModel or PrimaryModel.",
            "",
            "    Can also be used for models derived from BaseModel, so long as they support Notes.",
            "    \"\"\"",
            "",
            "",
            "#",
            "# Contacts",
            "#",
            "",
            "",
            "class ContactViewSet(NautobotModelViewSet):",
            "    queryset = Contact.objects.all()",
            "    serializer_class = serializers.ContactSerializer",
            "    filterset_class = filters.ContactFilterSet",
            "",
            "",
            "class ContactAssociationViewSet(NautobotModelViewSet):",
            "    queryset = ContactAssociation.objects.all()",
            "    serializer_class = serializers.ContactAssociationSerializer",
            "    filterset_class = filters.ContactAssociationFilterSet",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Custom Links through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = CustomLink.objects.all()",
            "    serializer_class = serializers.CustomLinkSerializer",
            "    filterset_class = filters.CustomLinkFilterSet",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Dynamic Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroup.objects.select_related(\"content_type\")",
            "    serializer_class = serializers.DynamicGroupSerializer",
            "    filterset_class = filters.DynamicGroupFilterSet",
            "",
            "    # FIXME(jathan): Figure out how to do dynamic `responses` serializer based on the `content_type`",
            "    # of the DynamicGroup? May not be possible or even desirable to have a \"dynamic schema\".",
            "    # @extend_schema(methods=[\"get\"], responses={200: member_response})",
            "    @action(detail=True, methods=[\"get\"])",
            "    def members(self, request, pk, *args, **kwargs):",
            "        \"\"\"List the member objects of this dynamic group.\"\"\"",
            "        instance = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        # Retrieve the serializer for the content_type and paginate the results",
            "        member_model_class = instance.content_type.model_class()",
            "        member_serializer_class = get_serializer_for_model(member_model_class)",
            "        members = self.paginate_queryset(instance.members.restrict(request.user, \"view\"))",
            "        member_serializer = member_serializer_class(members, many=True, context={\"request\": request})",
            "        return self.get_paginated_response(member_serializer.data)",
            "",
            "",
            "class DynamicGroupMembershipViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Dynamic Group Memberships through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = DynamicGroupMembership.objects.select_related(\"group\", \"parent_group\")",
            "    serializer_class = serializers.DynamicGroupMembershipSerializer",
            "    filterset_class = filters.DynamicGroupMembershipFilterSet",
            "",
            "",
            "#",
            "# Export templates",
            "#",
            "",
            "",
            "class ExportTemplateViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = ExportTemplate.objects.all()",
            "    serializer_class = serializers.ExportTemplateSerializer",
            "    filterset_class = filters.ExportTemplateFilterSet",
            "",
            "",
            "#",
            "# External integrations",
            "#",
            "",
            "",
            "class ExternalIntegrationViewSet(NautobotModelViewSet):",
            "    queryset = ExternalIntegration.objects.select_related(\"secrets_group\")",
            "    serializer_class = serializers.ExternalIntegrationSerializer",
            "    filterset_class = filters.ExternalIntegrationFilterSet",
            "",
            "",
            "#",
            "# File proxies",
            "#",
            "",
            "",
            "class FileProxyViewSet(ReadOnlyModelViewSet):",
            "    queryset = FileProxy.objects.select_related(\"job_result\")",
            "    serializer_class = serializers.FileProxySerializer",
            "    filterset_class = filters.FileProxyFilterSet",
            "",
            "    @extend_schema(",
            "        methods=[\"get\"],",
            "        responses=OpenApiTypes.BINARY,",
            "    )",
            "    @action(",
            "        detail=True,",
            "        methods=[\"get\"],",
            "    )",
            "    def download(self, request, *args, **kwargs):",
            "        \"\"\"Download the specified FileProxy.\"\"\"",
            "        file_proxy = self.get_object()",
            "        return FileResponse(file_proxy.file.open(\"rb\"), as_attachment=True)",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage the use of Git repositories as external data sources.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    serializer_class = serializers.GitRepositorySerializer",
            "    filterset_class = filters.GitRepositoryFilterSet",
            "",
            "    @extend_schema(methods=[\"post\"], request=serializers.GitRepositorySerializer)",
            "    # Since we are explicitly checking for `extras:change_gitrepository` in the API sync() method",
            "    # We explicitly set the permission_classes to IsAuthenticated in the @action decorator",
            "    # bypassing the default DRF permission check for `extras:add_gitrepository` and the permission check fall through to the function itself.",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[IsAuthenticated])",
            "    def sync(self, request, pk):",
            "        \"\"\"",
            "        Enqueue pull git repository and refresh data.",
            "        \"\"\"",
            "        if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "            raise PermissionDenied(\"This user does not have permission to make changes to Git repositories.\")",
            "",
            "        if not get_worker_count():",
            "            raise CeleryWorkerNotRunningException()",
            "",
            "        repository = get_object_or_404(GitRepository, id=pk)",
            "        repository.sync(user=request.user)",
            "        return Response({\"message\": f\"Repository {repository} sync job added to queue.\"})",
            "",
            "",
            "#",
            "# GraphQL Queries",
            "#",
            "",
            "",
            "class GraphQLQueryViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = GraphQLQuery.objects.all()",
            "    serializer_class = serializers.GraphQLQuerySerializer",
            "    filterset_class = filters.GraphQLQueryFilterSet",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=serializers.GraphQLQueryInputSerializer,",
            "        responses={\"200\": serializers.GraphQLQueryOutputSerializer},",
            "    )",
            "    @action(detail=True, methods=[\"post\"])",
            "    def run(self, request, pk):",
            "        try:",
            "            query = get_object_or_404(self.queryset, pk=pk)",
            "            result = execute_saved_query(query.name, variables=request.data.get(\"variables\"), request=request).to_dict()",
            "            return Response(result)",
            "        except GraphQLError as error:",
            "            return Response(",
            "                {\"errors\": [GraphQLView.format_error(error)]},",
            "                status=status.HTTP_400_BAD_REQUEST,",
            "            )",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentViewSet(ModelViewSet):",
            "    queryset = ImageAttachment.objects.all()",
            "    serializer_class = serializers.ImageAttachmentSerializer",
            "    filterset_class = filters.ImageAttachmentFilterSet",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "def _create_schedule(serializer, data, job_model, user, approval_required, task_queue=None):",
            "    \"\"\"",
            "    This is an internal function to create a scheduled job from API data.",
            "    It has to handle both once-offs (i.e. of type TYPE_FUTURE) and interval",
            "    jobs.",
            "    \"\"\"",
            "    type_ = serializer[\"interval\"]",
            "    if type_ == JobExecutionType.TYPE_IMMEDIATELY:",
            "        time = timezone.now()",
            "        name = serializer.get(\"name\") or f\"{job_model.name} - {time}\"",
            "    elif type_ == JobExecutionType.TYPE_CUSTOM:",
            "        time = serializer.get(\"start_time\")  # doing .get(\"key\", \"default\") returns None instead of \"default\"",
            "        if time is None:",
            "            # \"start_time\" is checked against models.ScheduledJob.earliest_possible_time()",
            "            # which returns timezone.now() + timedelta(seconds=15)",
            "            time = timezone.now() + timedelta(seconds=20)",
            "        name = serializer[\"name\"]",
            "    else:",
            "        time = serializer[\"start_time\"]",
            "        name = serializer[\"name\"]",
            "    crontab = serializer.get(\"crontab\", \"\")",
            "",
            "    celery_kwargs = {",
            "        \"nautobot_job_profile\": False,",
            "        \"queue\": task_queue,",
            "    }",
            "",
            "    # 2.0 TODO: To revisit this as part of a larger Jobs cleanup in 2.0.",
            "    #",
            "    # We pass in task and job_model here partly for forward/backward compatibility logic, and",
            "    # part fallback safety. It's mildly useful to store both the task module/class name and the JobModel",
            "    # FK on the ScheduledJob, as in the case where the JobModel gets deleted (and the FK becomes",
            "    # null) you still have a bit of context on the ScheduledJob as to what it was originally",
            "    # scheduled for.",
            "    scheduled_job = ScheduledJob(",
            "        name=name,",
            "        task=job_model.class_path,",
            "        job_model=job_model,",
            "        start_time=time,",
            "        description=f\"Nautobot job {name} scheduled by {user} for {time}\",",
            "        kwargs=data,",
            "        celery_kwargs=celery_kwargs,",
            "        interval=type_,",
            "        one_off=(type_ == JobExecutionType.TYPE_FUTURE),",
            "        user=user,",
            "        approval_required=approval_required,",
            "        crontab=crontab,",
            "        queue=task_queue,",
            "    )",
            "    scheduled_job.validated_save()",
            "    return scheduled_job",
            "",
            "",
            "class JobViewSetBase(",
            "    NautobotAPIVersionMixin,",
            "    # note no CreateModelMixin",
            "    mixins.RetrieveModelMixin,",
            "    mixins.UpdateModelMixin,",
            "    mixins.DestroyModelMixin,",
            "    NotesViewSetMixin,",
            "    ModelViewSetMixin,",
            "    viewsets.GenericViewSet,",
            "):",
            "    queryset = Job.objects.all()",
            "    serializer_class = serializers.JobSerializer",
            "    filterset_class = filters.JobFilterSet",
            "",
            "    @extend_schema(responses={\"200\": serializers.JobVariableSerializer(many=True)})",
            "    @action(detail=True, filterset_class=None)",
            "    def variables(self, request, *args, **kwargs):",
            "        \"\"\"Get details of the input variables that may/must be specified to run a particular Job.\"\"\"",
            "        job_model = self.get_object()",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        if job_class is None:",
            "            raise Http404",
            "        variables_dict = job_class._get_vars()",
            "        data = []",
            "        for name, instance in variables_dict.items():",
            "            entry = {\"name\": name, \"type\": instance.__class__.__name__}",
            "            for key in [",
            "                \"label\",",
            "                \"help_text\",",
            "                \"required\",",
            "                \"min_length\",",
            "                \"max_length\",",
            "                \"min_value\",",
            "                \"max_value\",",
            "                \"choices\",",
            "            ]:",
            "                if key in instance.field_attrs:",
            "                    entry[key] = instance.field_attrs[key]",
            "            if \"initial\" in instance.field_attrs:",
            "                entry[\"default\"] = instance.field_attrs[\"initial\"]",
            "            if \"queryset\" in instance.field_attrs:",
            "                content_type = ContentType.objects.get_for_model(instance.field_attrs[\"queryset\"].model)",
            "                entry[\"model\"] = f\"{content_type.app_label}.{content_type.model}\"",
            "            data.append(entry)",
            "        return Response(data)",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special \"run_job\" permission as queryset filter on the /run/ endpoint, otherwise as ModelViewSetMixin.",
            "        \"\"\"",
            "        if request.user.is_authenticated and self.action == \"run\":",
            "            self.queryset = self.queryset.restrict(request.user, \"run\")",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class JobRunTokenPermissions(TokenPermissions):",
            "        \"\"\"As nautobot.core.api.authentication.TokenPermissions, but enforcing run_job instead of add_job.\"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.run_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request={",
            "            \"application/json\": serializers.JobInputSerializer,",
            "            \"multipart/form-data\": serializers.JobMultiPartInputSerializer,",
            "        },",
            "        responses={\"201\": serializers.JobRunResponseSerializer},",
            "    )",
            "    @action(",
            "        detail=True,",
            "        methods=[\"post\"],",
            "        permission_classes=[JobRunTokenPermissions],",
            "        parser_classes=[JSONParser, MultiPartParser],",
            "    )",
            "    def run(self, request, *args, **kwargs):",
            "        \"\"\"Run the specified Job.\"\"\"",
            "        job_model = self.get_object()",
            "        if not request.user.has_perm(\"extras.run_job\"):",
            "            raise PermissionDenied(\"This user does not have permission to run jobs.\")",
            "        if not job_model.enabled:",
            "            raise PermissionDenied(\"This job is not enabled to be run.\")",
            "        if not job_model.installed:",
            "            raise MethodNotAllowed(request.method, detail=\"This job is not presently installed and cannot be run\")",
            "        if job_model.has_sensitive_variables:",
            "            if (",
            "                \"schedule\" in request.data",
            "                and \"interval\" in request.data[\"schedule\"]",
            "                and request.data[\"schedule\"][\"interval\"] != JobExecutionType.TYPE_IMMEDIATELY",
            "            ):",
            "                raise ValidationError(",
            "                    {\"schedule\": {\"interval\": [\"Unable to schedule job: Job may have sensitive input variables\"]}}",
            "                )",
            "            if job_model.approval_required:",
            "                raise ValidationError(",
            "                    \"Unable to run or schedule job: \"",
            "                    \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                    \"One of these two flags must be removed before this job can be scheduled or run.\"",
            "                )",
            "",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        if job_class is None:",
            "            raise MethodNotAllowed(",
            "                request.method, detail=\"This job's source code could not be located and cannot be run\"",
            "            )",
            "",
            "        valid_queues = job_model.task_queues if job_model.task_queues else [settings.CELERY_TASK_DEFAULT_QUEUE]",
            "        # Get a default queue from either the job model's specified task queue or",
            "        # the system default to fall back on if request doesn't provide one",
            "        default_valid_queue = valid_queues[0]",
            "",
            "        # We need to call request.data for both cases as this is what pulls and caches the request data",
            "        data = request.data",
            "        files = None",
            "        schedule_data = None",
            "",
            "        # We must extract from the request:",
            "        # - Job Form data (for submission to the job itself)",
            "        # - Schedule data",
            "        # - Desired task queue",
            "        # Depending on request content type (largely for backwards compatibility) the keys at which these are found",
            "        # are different",
            "        if \"multipart/form-data\" in request.content_type:",
            "            data = request._data.dict()  # .data will return data and files, we just want the data",
            "            files = request.FILES",
            "",
            "            # JobMultiPartInputSerializer is a \"flattened\" version of JobInputSerializer",
            "            input_serializer = serializers.JobMultiPartInputSerializer(data=data, context={\"request\": request})",
            "            input_serializer.is_valid(raise_exception=True)",
            "",
            "            task_queue = input_serializer.validated_data.get(\"_task_queue\", default_valid_queue)",
            "",
            "            # JobMultiPartInputSerializer only has keys for executing job (task_queue, etc),",
            "            # everything else is a candidate for the job form's data.",
            "            # job_class.validate_data will throw an error for any unexpected key/value pairs.",
            "            non_job_keys = input_serializer.validated_data.keys()",
            "            for non_job_key in non_job_keys:",
            "                data.pop(non_job_key, None)",
            "",
            "            # List of keys in serializer that are effectively exploded versions of the schedule dictionary",
            "            # from JobInputSerializer",
            "            schedule_keys = (\"_schedule_name\", \"_schedule_start_time\", \"_schedule_interval\", \"_schedule_crontab\")",
            "",
            "            # Assign the key from the validated_data output to dictionary without prefixed \"_schedule_\"",
            "            # For all the keys that are schedule keys",
            "            # Assign only if the key is in the output since we don't want None's if not provided",
            "            if any(schedule_key in non_job_keys for schedule_key in schedule_keys):",
            "                schedule_data = {",
            "                    k.replace(\"_schedule_\", \"\"): input_serializer.validated_data[k]",
            "                    for k in schedule_keys",
            "                    if k in input_serializer.validated_data",
            "                }",
            "",
            "        else:",
            "            input_serializer = serializers.JobInputSerializer(data=data, context={\"request\": request})",
            "            input_serializer.is_valid(raise_exception=True)",
            "",
            "            data = input_serializer.validated_data.get(\"data\", {})",
            "            task_queue = input_serializer.validated_data.get(\"task_queue\", default_valid_queue)",
            "            schedule_data = input_serializer.validated_data.get(\"schedule\", None)",
            "",
            "        if task_queue not in valid_queues:",
            "            raise ValidationError({\"task_queue\": [f'\"{task_queue}\" is not a valid choice.']})",
            "",
            "        cleaned_data = None",
            "        try:",
            "            cleaned_data = job_class.validate_data(data, files=files)",
            "            cleaned_data = job_class.prepare_job_kwargs(cleaned_data)",
            "",
            "        except FormsValidationError as e:",
            "            # message_dict can only be accessed if ValidationError got a dict",
            "            # in the constructor (saved as error_dict). Otherwise we get a list",
            "            # of errors under messages",
            "            return Response({\"errors\": e.message_dict if hasattr(e, \"error_dict\") else e.messages}, status=400)",
            "",
            "        if not get_worker_count(queue=task_queue):",
            "            raise CeleryWorkerNotRunningException(queue=task_queue)",
            "",
            "        # Default to a null JobResult.",
            "        job_result = None",
            "",
            "        # Approval is not required for dryrun",
            "        if job_class.supports_dryrun:",
            "            dryrun = data.get(\"dryrun\", False)",
            "            approval_required = not dryrun and job_model.approval_required",
            "        else:",
            "            approval_required = job_model.approval_required",
            "",
            "        # Set schedule for jobs that require approval but request did not supply schedule data",
            "        if schedule_data is None and approval_required:",
            "            schedule_data = {\"interval\": JobExecutionType.TYPE_IMMEDIATELY}",
            "",
            "        # Skip creating a ScheduledJob when job can be executed immediately",
            "        elif schedule_data and schedule_data[\"interval\"] == JobExecutionType.TYPE_IMMEDIATELY and not approval_required:",
            "            schedule_data = None",
            "",
            "        # Try to create a ScheduledJob, or...",
            "        if schedule_data:",
            "            schedule = _create_schedule(",
            "                schedule_data,",
            "                job_class.serialize_data(cleaned_data),",
            "                job_model,",
            "                request.user,",
            "                approval_required,",
            "                task_queue=input_serializer.validated_data.get(\"task_queue\", None),",
            "            )",
            "        else:",
            "            schedule = None",
            "",
            "        # ... If we can't create one, create a JobResult instead.",
            "        if schedule is None:",
            "            job_result = JobResult.enqueue_job(",
            "                job_model,",
            "                request.user,",
            "                task_queue=task_queue,",
            "                **job_class.serialize_data(cleaned_data),",
            "            )",
            "",
            "        # New-style JobModelViewSet response - serialize the schedule or job_result as appropriate",
            "        data = {\"scheduled_job\": None, \"job_result\": None}",
            "        if schedule:",
            "            data[\"scheduled_job\"] = serializers.ScheduledJobSerializer(schedule, context={\"request\": request}).data",
            "        if job_result:",
            "            data[\"job_result\"] = serializers.JobResultSerializer(job_result, context={\"request\": request}).data",
            "        return Response(data, status=status.HTTP_201_CREATED)",
            "",
            "",
            "class JobViewSet(",
            "    JobViewSetBase,",
            "    mixins.ListModelMixin,",
            "    BulkUpdateModelMixin,",
            "    BulkDestroyModelMixin,",
            "):",
            "    lookup_value_regex = r\"[-0-9a-fA-F]+\"",
            "",
            "",
            "@extend_schema_view(",
            "    destroy=extend_schema(operation_id=\"extras_jobs_destroy_by_name\"),",
            "    partial_update=extend_schema(operation_id=\"extras_jobs_partial_update_by_name\"),",
            "    notes=extend_schema(methods=[\"get\"], operation_id=\"extras_jobs_notes_list_by_name\"),",
            "    retrieve=extend_schema(operation_id=\"extras_jobs_retrieve_by_name\"),",
            "    run=extend_schema(",
            "        methods=[\"post\"],",
            "        operation_id=\"extras_jobs_run_create_by_name\",",
            "        request={",
            "            \"application/json\": serializers.JobInputSerializer,",
            "            \"multipart/form-data\": serializers.JobMultiPartInputSerializer,",
            "        },",
            "        responses={\"201\": serializers.JobRunResponseSerializer},",
            "    ),",
            "    update=extend_schema(operation_id=\"extras_jobs_update_by_name\"),",
            "    variables=extend_schema(operation_id=\"extras_jobs_variables_list_by_name\"),",
            ")",
            "@extend_schema_view(",
            "    notes=extend_schema(methods=[\"post\"], operation_id=\"extras_jobs_notes_create_by_name\"),",
            ")",
            "class JobByNameViewSet(",
            "    JobViewSetBase,",
            "):",
            "    lookup_field = \"name\"",
            "    lookup_url_kwarg = \"name\"",
            "    lookup_value_regex = r\"[^/]+\"",
            "",
            "",
            "#",
            "# Job Hooks",
            "#",
            "",
            "",
            "class JobHooksViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage job hooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobHook.objects.all()",
            "    serializer_class = serializers.JobHookSerializer",
            "    filterset_class = filters.JobHookFilterSet",
            "",
            "",
            "#",
            "# Job Results",
            "#",
            "",
            "",
            "class JobLogEntryViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of job log entries.",
            "    \"\"\"",
            "",
            "    queryset = JobLogEntry.objects.select_related(\"job_result\")",
            "    serializer_class = serializers.JobLogEntrySerializer",
            "    filterset_class = filters.JobLogEntryFilterSet",
            "",
            "",
            "class JobResultViewSet(",
            "    # DRF mixins:",
            "    # note no CreateModelMixin or UpdateModelMixin",
            "    mixins.DestroyModelMixin,",
            "    # Nautobot mixins:",
            "    BulkDestroyModelMixin,",
            "    # Base class",
            "    ReadOnlyModelViewSet,",
            "):",
            "    \"\"\"",
            "    Retrieve a list of job results",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.select_related(\"job_model\", \"user\")",
            "    serializer_class = serializers.JobResultSerializer",
            "    filterset_class = filters.JobResultFilterSet",
            "",
            "    @action(detail=True)",
            "    def logs(self, request, pk=None):",
            "        job_result = self.get_object()",
            "        logs = job_result.job_log_entries.all()",
            "        serializer = serializers.JobLogEntrySerializer(logs, context={\"request\": request}, many=True)",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Job Buttons through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    filterset_class = filters.JobButtonFilterSet",
            "",
            "",
            "#",
            "# Scheduled Jobs",
            "#",
            "",
            "",
            "class ScheduledJobViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of scheduled jobs",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.select_related(\"user\")",
            "    serializer_class = serializers.ScheduledJobSerializer",
            "    filterset_class = filters.ScheduledJobFilterSet",
            "",
            "    def restrict_queryset(self, request, *args, **kwargs):",
            "        \"\"\"",
            "        Apply special permissions as queryset filter on the /approve/, /deny/, and /dry-run/ endpoints.",
            "",
            "        Otherwise, same as ModelViewSetMixin.",
            "        \"\"\"",
            "        action_to_method = {\"approve\": \"change\", \"deny\": \"delete\", \"dry-run\": \"view\"}",
            "        if request.user.is_authenticated and self.action in action_to_method:",
            "            self.queryset = self.queryset.restrict(request.user, action_to_method[self.action])",
            "        else:",
            "            super().restrict_queryset(request, *args, **kwargs)",
            "",
            "    class ScheduledJobChangePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing change_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.change_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.ScheduledJobSerializer},",
            "        request=None,",
            "        parameters=[",
            "            OpenApiParameter(",
            "                \"force\",",
            "                location=OpenApiParameter.QUERY,",
            "                description=\"force execution even if start time has passed\",",
            "                type=OpenApiTypes.BOOL,",
            "            )",
            "        ],",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobChangePermissions])",
            "    def approve(self, request, pk):",
            "        scheduled_job = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to approve this request.\")",
            "",
            "        # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        if request.user == scheduled_job.user:",
            "            # The requestor *cannot* approve their own job",
            "            return Response(\"You cannot approve your own job request!\", status=403)",
            "",
            "        if (",
            "            scheduled_job.one_off",
            "            and scheduled_job.start_time < timezone.now()",
            "            and not request.query_params.get(\"force\")",
            "        ):",
            "            return Response(",
            "                \"The job's start time is in the past. If you want to force a run anyway, add the `force` query parameter.\",",
            "                status=400,",
            "            )",
            "",
            "        scheduled_job.approved_by_user = request.user",
            "        scheduled_job.approved_at = timezone.now()",
            "        scheduled_job.save()",
            "        serializer = serializers.ScheduledJobSerializer(scheduled_job, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "    class ScheduledJobDeletePermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing delete_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.delete_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        request=None,",
            "    )",
            "    @action(detail=True, methods=[\"post\"], permission_classes=[ScheduledJobDeletePermissions])",
            "    def deny(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        if not Job.objects.check_perms(request.user, instance=scheduled_job.job_model, action=\"approve\"):",
            "            raise PermissionDenied(\"You do not have permission to deny this request.\")",
            "",
            "        scheduled_job.delete()",
            "",
            "        return Response(None)",
            "",
            "    class ScheduledJobViewPermissions(TokenPermissions):",
            "        \"\"\"",
            "        As nautobot.core.api.authentication.TokenPermissions, but enforcing view_scheduledjob not add_scheduledjob.",
            "        \"\"\"",
            "",
            "        perms_map = {",
            "            \"POST\": [\"%(app_label)s.view_%(model_name)s\"],",
            "        }",
            "",
            "    @extend_schema(",
            "        methods=[\"post\"],",
            "        responses={\"200\": serializers.JobResultSerializer},",
            "        request=None,",
            "    )",
            "    @action(",
            "        detail=True,",
            "        name=\"Dry Run\",",
            "        url_path=\"dry-run\",",
            "        methods=[\"post\"],",
            "        permission_classes=[ScheduledJobViewPermissions],",
            "    )",
            "    def dry_run(self, request, pk):",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "        job_model = scheduled_job.job_model",
            "        if job_model is None or not job_model.runnable:",
            "            raise MethodNotAllowed(\"This job cannot be dry-run at this time.\")",
            "        if not job_model.supports_dryrun:",
            "            raise MethodNotAllowed(\"This job does not support dry-run.\")",
            "        if not Job.objects.check_perms(request.user, instance=job_model, action=\"run\"):",
            "            raise PermissionDenied(\"You do not have permission to run this job.\")",
            "",
            "        # Immediately enqueue the job",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        job_kwargs = job_class.prepare_job_kwargs(scheduled_job.kwargs or {})",
            "        job_kwargs[\"dryrun\"] = True",
            "        job_result = JobResult.enqueue_job(",
            "            job_model,",
            "            request.user,",
            "            celery_kwargs=scheduled_job.celery_kwargs or {},",
            "            **job_class.serialize_data(job_kwargs),",
            "        )",
            "        serializer = serializers.JobResultSerializer(job_result, context={\"request\": request})",
            "",
            "        return Response(serializer.data)",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteViewSet(ModelViewSet):",
            "    queryset = Note.objects.select_related(\"user\")",
            "    serializer_class = serializers.NoteSerializer",
            "    filterset_class = filters.NoteFilterSet",
            "",
            "    # Assign user from request",
            "    def perform_create(self, serializer):",
            "        serializer.save(user=self.request.user)",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeViewSet(ReadOnlyModelViewSet):",
            "    \"\"\"",
            "    Retrieve a list of recent changes.",
            "    \"\"\"",
            "",
            "    queryset = ObjectChange.objects.select_related(\"user\")",
            "    serializer_class = serializers.ObjectChangeSerializer",
            "    filterset_class = filters.ObjectChangeFilterSet",
            "",
            "",
            "#",
            "#  Relationships",
            "#",
            "",
            "",
            "class RelationshipViewSet(NotesViewSetMixin, ModelViewSet):",
            "    queryset = Relationship.objects.all()",
            "    serializer_class = serializers.RelationshipSerializer",
            "    filterset_class = filters.RelationshipFilterSet",
            "",
            "",
            "class RelationshipAssociationViewSet(ModelViewSet):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    serializer_class = serializers.RelationshipAssociationSerializer",
            "    filterset_class = filters.RelationshipAssociationFilterSet",
            "",
            "",
            "#",
            "# Roles",
            "#",
            "",
            "",
            "class RoleViewSet(NautobotModelViewSet):",
            "    queryset = Role.objects.all()",
            "    serializer_class = serializers.RoleSerializer",
            "    filterset_class = RoleFilterSet",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretsViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Secret.objects.all()",
            "    serializer_class = serializers.SecretSerializer",
            "    filterset_class = filters.SecretFilterSet",
            "",
            "    @extend_schema(",
            "        responses={",
            "            200: {",
            "                \"type\": \"object\",",
            "                \"properties\": {",
            "                    \"result\": {\"type\": \"boolean\"},",
            "                    \"message\": {\"type\": \"string\"},",
            "                },",
            "            }",
            "        },",
            "    )",
            "    @action(methods=[\"GET\"], detail=True)",
            "    def check(self, request, pk):",
            "        \"\"\"Check that a secret's value is accessible.\"\"\"",
            "        result = False",
            "        message = \"Unknown error\"",
            "        try:",
            "            self.get_object().get_value()",
            "            result = True",
            "            message = \"Passed\"",
            "        except SecretError as e:",
            "            message = str(e)",
            "        response = {\"result\": result, \"message\": message}",
            "        return Response(response)",
            "",
            "",
            "class SecretsGroupViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Groups through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroup.objects.all()",
            "    serializer_class = serializers.SecretsGroupSerializer",
            "    filterset_class = filters.SecretsGroupFilterSet",
            "",
            "",
            "class SecretsGroupAssociationViewSet(ModelViewSet):",
            "    \"\"\"",
            "    Manage Secrets Group Associations through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = SecretsGroupAssociation.objects.all()",
            "    serializer_class = serializers.SecretsGroupAssociationSerializer",
            "    filterset_class = filters.SecretsGroupAssociationFilterSet",
            "",
            "",
            "#",
            "# Statuses",
            "#",
            "",
            "",
            "class StatusViewSet(NautobotModelViewSet):",
            "    \"\"\"",
            "    View and manage custom status choices for objects with a `status` field.",
            "    \"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    serializer_class = serializers.StatusSerializer",
            "    filterset_class = filters.StatusFilterSet",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagViewSet(NautobotModelViewSet):",
            "    queryset = Tag.objects.annotate(tagged_items=count_related(TaggedItem, \"tag\"))",
            "    serializer_class = serializers.TagSerializer",
            "    filterset_class = filters.TagFilterSet",
            "",
            "",
            "#",
            "# Teams",
            "#",
            "",
            "",
            "class TeamViewSet(NautobotModelViewSet):",
            "    queryset = Team.objects.all()",
            "    serializer_class = serializers.TeamSerializer",
            "    filterset_class = filters.TeamFilterSet",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhooksViewSet(NotesViewSetMixin, ModelViewSet):",
            "    \"\"\"",
            "    Manage Webhooks through DELETE, GET, POST, PUT, and PATCH requests.",
            "    \"\"\"",
            "",
            "    queryset = Webhook.objects.all()",
            "    serializer_class = serializers.WebhookSerializer",
            "    filterset_class = filters.WebhookFilterSet"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "307": [
                "DynamicGroupViewSet",
                "members"
            ],
            "313": [
                "DynamicGroupViewSet",
                "members"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/tests/test_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from nautobot.core.testing import APITestCase, APIViewTestCases"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from nautobot.core.testing.utils import disable_warnings"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from nautobot.core.utils.lookup import get_route_for_model"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from nautobot.core.utils.permissions import get_permission_for_model"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from nautobot.dcim.models import ("
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     Controller,"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     Device,"
            },
            "7": {
                "beforePatchRowNumber": 768,
                "afterPatchRowNumber": 769,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 769,
                "afterPatchRowNumber": 770,
                "PatchRowcode": "         # Then the DynamicGroups."
            },
            "9": {
                "beforePatchRowNumber": 770,
                "afterPatchRowNumber": 771,
                "PatchRowcode": "         cls.content_type = ContentType.objects.get_for_model(Device)"
            },
            "10": {
                "beforePatchRowNumber": 771,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cls.groups = cls.groups = ["
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 772,
                "PatchRowcode": "+        cls.groups = ["
            },
            "12": {
                "beforePatchRowNumber": 772,
                "afterPatchRowNumber": 773,
                "PatchRowcode": "             DynamicGroup.objects.create("
            },
            "13": {
                "beforePatchRowNumber": 773,
                "afterPatchRowNumber": 774,
                "PatchRowcode": "                 name=\"API DynamicGroup 1\","
            },
            "14": {
                "beforePatchRowNumber": 774,
                "afterPatchRowNumber": 775,
                "PatchRowcode": "                 content_type=cls.content_type,"
            },
            "15": {
                "beforePatchRowNumber": 811,
                "afterPatchRowNumber": 812,
                "PatchRowcode": "     def test_get_members(self):"
            },
            "16": {
                "beforePatchRowNumber": 812,
                "afterPatchRowNumber": 813,
                "PatchRowcode": "         \"\"\"Test that the `/members/` API endpoint returns what is expected.\"\"\""
            },
            "17": {
                "beforePatchRowNumber": 813,
                "afterPatchRowNumber": 814,
                "PatchRowcode": "         self.add_permissions(\"extras.view_dynamicgroup\")"
            },
            "18": {
                "beforePatchRowNumber": 814,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        instance = DynamicGroup.objects.first()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 815,
                "PatchRowcode": "+        instance = self.groups[0]"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 816,
                "PatchRowcode": "+        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))"
            },
            "21": {
                "beforePatchRowNumber": 815,
                "afterPatchRowNumber": 817,
                "PatchRowcode": "         member_count = instance.members.count()"
            },
            "22": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": 818,
                "PatchRowcode": "         url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})"
            },
            "23": {
                "beforePatchRowNumber": 817,
                "afterPatchRowNumber": 819,
                "PatchRowcode": "         response = self.client.get(url, **self.header)"
            },
            "24": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": 820,
                "PatchRowcode": "         self.assertHttpStatus(response, status.HTTP_200_OK)"
            },
            "25": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": 821,
                "PatchRowcode": "         self.assertEqual(member_count, len(response.json()[\"results\"]))"
            },
            "26": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 822,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 823,
                "PatchRowcode": "+    def test_get_members_with_constrained_permission(self):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 824,
                "PatchRowcode": "+        \"\"\"Test that the `/members/` API endpoint enforces permissions on the member model.\"\"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 825,
                "PatchRowcode": "+        self.add_permissions(\"extras.view_dynamicgroup\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 826,
                "PatchRowcode": "+        instance = self.groups[0]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 827,
                "PatchRowcode": "+        obj1 = instance.members.first()"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 828,
                "PatchRowcode": "+        obj_perm = ObjectPermission("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 829,
                "PatchRowcode": "+            name=\"Test permission\","
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 830,
                "PatchRowcode": "+            constraints={\"pk__in\": [obj1.pk]},"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 831,
                "PatchRowcode": "+            actions=[\"view\"],"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 832,
                "PatchRowcode": "+        )"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 833,
                "PatchRowcode": "+        obj_perm.save()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 834,
                "PatchRowcode": "+        obj_perm.users.add(self.user)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 835,
                "PatchRowcode": "+        obj_perm.object_types.add(instance.content_type)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 836,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 837,
                "PatchRowcode": "+        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 838,
                "PatchRowcode": "+        response = self.client.get(url, **self.header)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 839,
                "PatchRowcode": "+        self.assertHttpStatus(response, status.HTTP_200_OK)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+        self.assertEqual(len(response.json()[\"results\"]), 1)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 841,
                "PatchRowcode": "+        self.assertEqual(response.json()[\"results\"][0][\"id\"], str(obj1.pk))"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": 821,
                "afterPatchRowNumber": 843,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 822,
                "afterPatchRowNumber": 844,
                "PatchRowcode": " class DynamicGroupMembershipTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):"
            },
            "49": {
                "beforePatchRowNumber": 823,
                "afterPatchRowNumber": 845,
                "PatchRowcode": "     model = DynamicGroupMembership"
            }
        },
        "frontPatchFile": [
            "from datetime import datetime, timedelta",
            "import tempfile",
            "from unittest import mock, skip",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils.timezone import make_aware, now",
            "from rest_framework import status",
            "",
            "from nautobot.core.choices import ColorChoices",
            "from nautobot.core.models.fields import slugify_dashes_to_underscores",
            "from nautobot.core.testing import APITestCase, APIViewTestCases",
            "from nautobot.core.testing.utils import disable_warnings",
            "from nautobot.core.utils.lookup import get_route_for_model",
            "from nautobot.dcim.models import (",
            "    Controller,",
            "    Device,",
            "    DeviceType,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    Rack,",
            "    RackGroup,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.api.serializers import ConfigContextSerializer, JobResultSerializer",
            "from nautobot.extras.choices import (",
            "    DynamicGroupOperatorChoices,",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    ObjectChangeActionChoices,",
            "    ObjectChangeEventContextChoices,",
            "    RelationshipTypeChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            "    WebhookHttpMethodChoices,",
            ")",
            "from nautobot.extras.jobs import get_job",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    FileProxy,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Team,",
            "    Webhook,",
            ")",
            "from nautobot.extras.models.jobs import JobButton, JobHook",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import TaggableClassesQuery",
            "from nautobot.ipam.models import IPAddress, Prefix, VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "",
            "User = get_user_model()",
            "",
            "",
            "class AppTest(APITestCase):",
            "    def test_root(self):",
            "        url = reverse(\"extras-api:api-root\")",
            "        response = self.client.get(f\"{url}?format=api\", **self.header)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldTest(APIViewTestCases.APIViewTestCase):",
            "    model = ComputedField",
            "    choices_fields = [\"content_type\"]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 4\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 5\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 6\",",
            "            \"template\": \"{{ obj.name }}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 7\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_type\": \"dcim.location\",",
            "        \"key\": \"cf1\",",
            "        \"label\": \"My Computed Field\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_ct = ContentType.objects.get_for_model(Location)",
            "",
            "        ComputedField.objects.create(",
            "            key=\"cf1\",",
            "            label=\"Computed Field One\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=location_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            key=\"cf2\",",
            "            label=\"Computed Field Two\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=location_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            key=\"cf3\",",
            "            label=\"Computed Field Three\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=location_ct,",
            "        )",
            "",
            "        cls.location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "",
            "    def test_computed_field_include(self):",
            "        \"\"\"Test that explicitly including a computed field behaves as expected.\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        url = reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.location.pk})",
            "",
            "        # First get the object without computed fields.",
            "        response = self.client.get(url, **self.header)",
            "        self.assertNotIn(\"computed_fields\", response.json())",
            "",
            "        # Now get it with computed fields.",
            "        params = {\"include\": \"computed_fields\"}",
            "        response = self.client.get(url, data=params, **self.header)",
            "        self.assertIn(\"computed_fields\", response.json())",
            "",
            "",
            "class ConfigContextTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContext",
            "    create_data = [",
            "        {",
            "            \"name\": \"Config Context 4\",",
            "            \"data\": {\"more_foo\": True},",
            "        },",
            "        {",
            "            \"name\": \"Config Context 5\",",
            "            \"data\": {\"more_bar\": False},",
            "        },",
            "        {",
            "            \"name\": \"Config Context 6\",",
            "            \"data\": {\"more_baz\": None},",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContext.objects.create(name=\"Config Context 1\", weight=100, data={\"foo\": 123})",
            "        ConfigContext.objects.create(name=\"Config Context 2\", weight=200, data={\"bar\": 456})",
            "        ConfigContext.objects.create(name=\"Config Context 3\", weight=300, data={\"baz\": 789})",
            "",
            "    def test_render_configcontext_for_object(self):",
            "        \"\"\"",
            "        Test rendering config context data for a device.",
            "        \"\"\"",
            "        manufacturer = Manufacturer.objects.first()",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\")",
            "        devicerole = Role.objects.get_for_model(Device).first()",
            "        devicestatus = Status.objects.get_for_model(Device).first()",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        device = Device.objects.create(",
            "            name=\"Device 1\", device_type=devicetype, role=devicerole, status=devicestatus, location=location",
            "        )",
            "",
            "        # Test default config contexts (created at test setup)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 123)",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        self.assertEqual(rendered_context[\"baz\"], 789)",
            "",
            "        # Test API response as well",
            "        self.add_permissions(\"dcim.view_device\")",
            "        device_url = reverse(\"dcim-api:device-detail\", kwargs={\"pk\": device.pk})",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"], {\"foo\": 123, \"bar\": 456, \"baz\": 789}, response.data)",
            "",
            "        # Add another context specific to the location",
            "        configcontext4 = ConfigContext(name=\"Config Context 4\", data={\"location_data\": \"ABC\"})",
            "        configcontext4.save()",
            "        configcontext4.locations.add(location)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"location_data\"], \"ABC\")",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"location_data\"], \"ABC\", response.data[\"config_context\"])",
            "",
            "        # Override one of the default contexts",
            "        configcontext5 = ConfigContext(name=\"Config Context 5\", weight=2000, data={\"foo\": 999})",
            "        configcontext5.save()",
            "        configcontext5.locations.add(location)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 999)",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"foo\"], 999, response.data[\"config_context\"])",
            "",
            "        # Add a context which does NOT match our device and ensure it does not apply",
            "        location2 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).last()",
            "        configcontext6 = ConfigContext(name=\"Config Context 6\", weight=2000, data={\"bar\": 999})",
            "        configcontext6.save()",
            "        configcontext6.locations.add(location2)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"bar\"], 456, response.data[\"config_context\"])",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {",
            "            \"name\": \"Config Context with schema\",",
            "            \"weight\": 100,",
            "            \"data\": {\"foo\": \"bar\"},",
            "            \"config_context_schema\": str(schema.pk),",
            "        }",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(response.data[\"config_context_schema\"][\"url\"], self.absolute_api_url(schema))",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 100,",
            "            \"data\": {\"foo\": \"bar\"},",
            "            \"config_context_schema\": str(schema.pk),",
            "        }",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=True)",
            "    def test_with_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is present when feature flag is enabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertIn(\"dynamic_groups\", serializer.fields)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=False)",
            "    def test_without_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is NOT present the when feature flag is disabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertNotIn(\"dynamic_groups\", serializer.fields)",
            "",
            "",
            "class ConfigContextSchemaTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContextSchema",
            "    create_data = [",
            "        {",
            "            \"name\": \"Schema 4\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 5\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 6\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 7\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "",
            "class ContentTypeTest(APITestCase):",
            "    \"\"\"",
            "    ContentTypeViewSet does not have permission checks,",
            "    So It should be accessible with or without permission override",
            "    e.g. @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"contenttypes.contenttype\"])",
            "    \"\"\"",
            "",
            "    def test_list_objects_with_or_without_permission(self):",
            "        contenttype_count = ContentType.objects.count()",
            "",
            "        response = self.client.get(reverse(\"extras-api:contenttype-list\"), **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], contenttype_count)",
            "",
            "    def test_get_object_with_or_without_permission(self):",
            "        contenttype = ContentType.objects.first()",
            "",
            "        url = reverse(\"extras-api:contenttype-detail\", kwargs={\"pk\": contenttype.pk})",
            "        self.assertHttpStatus(self.client.get(url, **self.header), status.HTTP_200_OK)",
            "",
            "",
            "#",
            "#  Contacts",
            "#",
            "",
            "",
            "class ContactTest(APIViewTestCases.APIViewTestCase):",
            "    model = Contact",
            "    bulk_update_data = {",
            "        \"address\": \"Carnegie Hall, New York, NY\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Contact 1\",",
            "                \"phone\": \"555-0121\",",
            "                \"email\": \"contact1@example.com\",",
            "                \"teams\": [Team.objects.first().pk, Team.objects.last().pk],",
            "            },",
            "            {",
            "                \"name\": \"Contact 2\",",
            "                \"phone\": \"555-0122\",",
            "                \"email\": \"contact2@example.com\",",
            "                \"address\": \"Bowser's Castle, Staten Island, NY\",",
            "            },",
            "            {",
            "                \"name\": \"Contact 3\",",
            "                \"phone\": \"555-0123\",",
            "            },",
            "            {",
            "                \"name\": \"Contact 4\",",
            "                \"email\": \"contact4@example.com\",",
            "            },",
            "        ]",
            "",
            "",
            "class ContactAssociationTestCase(APIViewTestCases.APIViewTestCase):",
            "    model = ContactAssociation",
            "    create_data = []",
            "    choices_fields = [\"associated_object_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        roles = Role.objects.get_for_model(ContactAssociation)",
            "        statuses = Status.objects.get_for_model(ContactAssociation)",
            "        ip_addresses = IPAddress.objects.all()",
            "        devices = Device.objects.all()",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[0].pk,",
            "            role=roles[0],",
            "            status=statuses[0],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[1].pk,",
            "            role=roles[1],",
            "            status=statuses[1],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[2].pk,",
            "            role=roles[1],",
            "            status=statuses[0],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[3].pk,",
            "            role=roles[2],",
            "            status=statuses[1],",
            "        )",
            "        cls.create_data = [",
            "            {",
            "                \"contact\": Contact.objects.first().pk,",
            "                \"team\": None,",
            "                \"associated_object_type\": \"ipam.ipaddress\",",
            "                \"associated_object_id\": ip_addresses[4].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[0].pk,",
            "            },",
            "            {",
            "                \"contact\": Contact.objects.last().pk,",
            "                \"team\": None,",
            "                \"associated_object_type\": \"dcim.device\",",
            "                \"associated_object_id\": devices[0].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[0].pk,",
            "            },",
            "            {",
            "                \"contact\": None,",
            "                \"team\": Team.objects.first().pk,",
            "                \"associated_object_type\": \"ipam.ipaddress\",",
            "                \"associated_object_id\": ip_addresses[5].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[2].pk,",
            "            },",
            "            {",
            "                \"contact\": None,",
            "                \"team\": Team.objects.last().pk,",
            "                \"associated_object_type\": \"dcim.device\",",
            "                \"associated_object_id\": devices[1].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[0].pk,",
            "            },",
            "        ]",
            "        cls.bulk_update_data = {",
            "            \"role\": roles[4].pk,",
            "            \"status\": statuses[1].pk,",
            "        }",
            "",
            "",
            "class CreatedUpdatedFilterTest(APITestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.location1 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        cls.rackgroup1 = RackGroup.objects.create(location=cls.location1, name=\"Test Rack Group 1\")",
            "        cls.rackrole1 = Role.objects.get_for_model(Rack).first()",
            "        cls.rackstatus1 = Status.objects.get_for_model(Rack).first()",
            "        cls.rack1 = Rack.objects.create(",
            "            location=cls.location1,",
            "            rack_group=cls.rackgroup1,",
            "            role=cls.rackrole1,",
            "            status=cls.rackstatus1,",
            "            name=\"Test Rack 1\",",
            "            u_height=42,",
            "        )",
            "        cls.rack2 = Rack.objects.create(",
            "            location=cls.location1,",
            "            rack_group=cls.rackgroup1,",
            "            role=cls.rackrole1,",
            "            status=cls.rackstatus1,",
            "            name=\"Test Rack 2\",",
            "            u_height=42,",
            "        )",
            "",
            "        # change the created and last_updated of one",
            "        Rack.objects.filter(pk=cls.rack2.pk).update(",
            "            created=make_aware(datetime(2001, 2, 3, 0, 1, 2, 3)),",
            "            last_updated=make_aware(datetime(2001, 2, 3, 1, 2, 3, 4)),",
            "        )",
            "",
            "    def test_get_rack_created(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created=2001-02-03%2000:01:02.000003\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_created_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "",
            "        response = self.client.get(f\"{url}?created__gte=2001-02-04\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "        response = self.client.get(f\"{url}?created__gte=2001-02-03%2000:01:03\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_created_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "",
            "        response = self.client.get(f\"{url}?created__lte=2001-02-04\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "        response = self.client.get(f\"{url}?created__lte=2001-02-03%2000:01:03\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated=2001-02-03%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__gte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_last_updated_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__lte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "",
            "class CustomFieldTest(APIViewTestCases.APIViewTestCase):",
            "    \"\"\"Tests for the CustomField REST API.\"\"\"",
            "",
            "    model = CustomField",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.location\"],",
            "            \"label\": \"Custom Field 4\",",
            "            \"key\": \"custom_field_4\",",
            "            \"type\": \"date\",",
            "            \"weight\": 100,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.location\", \"dcim.device\"],",
            "            \"label\": \"Custom Field 5\",",
            "            \"key\": \"custom_field_5\",",
            "            \"type\": \"url\",",
            "            \"default\": \"http://example.com\",",
            "            \"weight\": 200,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.location\"],",
            "            \"label\": \"Custom Field 6\",",
            "            \"key\": \"custom_field_6\",",
            "            \"type\": \"select\",",
            "            \"description\": \"A select custom field\",",
            "            \"weight\": 300,",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_types\": [\"dcim.location\"],",
            "        \"description\": \"New description\",",
            "        \"label\": \"Non-unique label\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"filter_logic\", \"type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_ct = ContentType.objects.get_for_model(Location)",
            "",
            "        custom_fields = (",
            "            CustomField(key=\"cf1\", label=\"Custom Field 1\", type=\"text\"),",
            "            CustomField(key=\"cf2\", label=\"Custom Field 2\", type=\"integer\"),",
            "            CustomField(key=\"cf3\", label=\"Custom Field 3\", type=\"boolean\"),",
            "        )",
            "        for cf in custom_fields:",
            "            cf.validated_save()",
            "            cf.content_types.add(location_ct)",
            "",
            "    def test_create_object_required_fields(self):",
            "        \"\"\"For this API version, `label` and `key` are required fields.\"\"\"",
            "        self.add_permissions(\"extras.add_customfield\")",
            "",
            "        incomplete_data = {",
            "            \"content_types\": [\"dcim.location\"],",
            "            \"type\": \"date\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), incomplete_data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            response.data,",
            "            # Since we are setting blank=True on the key field, we only need to check",
            "            # error messages from the label field.",
            "            {\"label\": [\"This field is required.\"]},",
            "        )",
            "",
            "",
            "class CustomLinkTest(APIViewTestCases.APIViewTestCase):",
            "    model = CustomLink",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"name\": \"api-test-4\",",
            "            \"text\": \"API customlink text 4\",",
            "            \"target_url\": \"http://api-test-4.com/test4\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"name\": \"api-test-5\",",
            "            \"text\": \"API customlink text 5\",",
            "            \"target_url\": \"http://api-test-5.com/test5\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"name\": \"api-test-6\",",
            "            \"text\": \"API customlink text 6\",",
            "            \"target_url\": \"http://api-test-6.com/test6\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "    ]",
            "    choices_fields = [\"button_class\", \"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-1\",",
            "            text=\"API customlink text 1\",",
            "            target_url=\"http://api-test-1.com/test1\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-2\",",
            "            text=\"API customlink text 2\",",
            "            target_url=\"http://api-test-2.com/test2\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-3\",",
            "            text=\"API customlink text 3\",",
            "            target_url=\"http://api-test-3.com/test3\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "",
            "",
            "class DynamicGroupTestMixin:",
            "    \"\"\"Mixin for Dynamic Group test cases to re-use the same set of common fixtures.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create the objects required for devices.",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        location_status = Status.objects.get_for_model(Location).first()",
            "        locations = (",
            "            Location.objects.create(name=\"Location 1\", location_type=location_type, status=location_status),",
            "            Location.objects.create(name=\"Location 2\", location_type=location_type, status=location_status),",
            "            Location.objects.create(name=\"Location 3\", location_type=location_type, status=location_status),",
            "        )",
            "",
            "        manufacturer = Manufacturer.objects.first()",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "        )",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        statuses = Status.objects.get_for_model(Device)",
            "        Device.objects.create(",
            "            name=\"device-location-1\",",
            "            status=statuses[0],",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=locations[0],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-location-2\",",
            "            status=statuses[0],",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=locations[1],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-location-3\",",
            "            status=statuses[1],",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=locations[2],",
            "        )",
            "",
            "        # Then the DynamicGroups.",
            "        cls.content_type = ContentType.objects.get_for_model(Device)",
            "        cls.groups = cls.groups = [",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 1\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [statuses[0].name]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 2\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [statuses[0].name]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 3\",",
            "                content_type=cls.content_type,",
            "                filter={\"location\": [f\"{locations[2].name}\"]},",
            "            ),",
            "        ]",
            "",
            "",
            "class DynamicGroupTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroup",
            "    choices_fields = [\"content_type\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"API DynamicGroup 4\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"location\": [\"Location 1\"]},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 5\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"has_interfaces\": False},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 6\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"location\": [\"Location 2\"]},",
            "        },",
            "    ]",
            "",
            "    def test_get_members(self):",
            "        \"\"\"Test that the `/members/` API endpoint returns what is expected.\"\"\"",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        instance = DynamicGroup.objects.first()",
            "        member_count = instance.members.count()",
            "        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(member_count, len(response.json()[\"results\"]))",
            "",
            "",
            "class DynamicGroupMembershipTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroupMembership",
            "    choices_fields = [\"operator\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super().setUpTestData()",
            "",
            "        parent = DynamicGroup.objects.create(",
            "            name=\"parent\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        parent2 = DynamicGroup.objects.create(",
            "            name=\"parent2\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        group1, group2, group3 = cls.groups",
            "",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group1,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            weight=10,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group2,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "            weight=20,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group3,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            weight=30,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group1.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "                \"weight\": 10,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group2.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "                \"weight\": 20,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group3.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                \"weight\": 30,",
            "            },",
            "        ]",
            "",
            "    # TODO: Either improve test base or or write a more specific test for this model.",
            "    @skip(\"DynamicGroupMembership has a `name` property but it's the Group name and not exposed on the API\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"DynamicGroupMembership has a `name` property but it's the Group name and not exposed on the API\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class ExportTemplateTest(APIViewTestCases.APIViewTestCase):",
            "    model = ExportTemplate",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 4\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 5\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 6\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\", \"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Device)",
            "",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 1\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 2\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 3\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "",
            "",
            "class ExternalIntegrationTest(APIViewTestCases.APIViewTestCase):",
            "    model = ExternalIntegration",
            "    create_data = [",
            "        {",
            "            \"name\": \"Test External Integration 1\",",
            "            \"remote_url\": \"ssh://example.com/test1/\",",
            "            \"verify_ssl\": False,",
            "            \"timeout\": 5,",
            "            \"extra_config\": \"{'foo': 'bar'}\",",
            "            \"http_method\": WebhookHttpMethodChoices.METHOD_DELETE,",
            "            \"headers\": \"{'header': 'fake header'}\",",
            "            \"ca_file_path\": \"/this/is/a/file/path\",",
            "        },",
            "        {",
            "            \"name\": \"Test External Integration 2\",",
            "            \"remote_url\": \"http://example.com/test2/\",",
            "            \"http_method\": WebhookHttpMethodChoices.METHOD_POST,",
            "        },",
            "        {",
            "            \"name\": \"Test External Integration 3\",",
            "            \"remote_url\": \"https://example.com/test3/\",",
            "            \"verify_ssl\": True,",
            "            \"timeout\": 30,",
            "            \"extra_config\": \"{'foo': ['bat', 'baz']}\",",
            "            \"headers\": \"{'new_header': 'fake header'}\",",
            "            \"ca_file_path\": \"/this/is/a/new/file/path\",",
            "        },",
            "    ]",
            "    bulk_update_data = {\"timeout\": 10, \"verify_ssl\": True, \"extra_config\": r\"{}\"}",
            "    choices_fields = [\"http_method\"]",
            "",
            "",
            "class FileProxyTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = FileProxy",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        job = Job.objects.first()",
            "        job_results = (",
            "            JobResult.objects.create(",
            "                job_model=job,",
            "                name=job.class_path,",
            "                date_done=now(),",
            "                status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            ),",
            "            JobResult.objects.create(",
            "                job_model=job,",
            "                name=job.class_path,",
            "                date_done=now(),",
            "                status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            ),",
            "            JobResult.objects.create(",
            "                job_model=job,",
            "                name=job.class_path,",
            "                date_done=now(),",
            "                status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            ),",
            "        )",
            "        cls.file_proxies = []",
            "        for i, job_result in enumerate(job_results):",
            "            file = SimpleUploadedFile(name=f\"Output {i}.txt\", content=f\"Content {i}\\n\".encode(\"utf-8\"))",
            "            file_proxy = FileProxy.objects.create(name=file.name, file=file, job_result=job_result)",
            "            cls.file_proxies.append(file_proxy)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_download_file_without_permission(self):",
            "        \"\"\"Test `download` action without permission.\"\"\"",
            "        url = reverse(\"extras-api:fileproxy-download\", kwargs={\"pk\": self.file_proxies[0].pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_download_file_with_permission(self):",
            "        \"\"\"Test `download` action with permission.\"\"\"",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\", constraints={\"pk\": self.file_proxies[0].pk}, actions=[\"view\"]",
            "        )",
            "        obj_perm.validated_save()",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "        obj_perm.users.add(self.user)",
            "",
            "        # FileProxy permitted by permission",
            "        url = reverse(\"extras-api:fileproxy-download\", kwargs={\"pk\": self.file_proxies[0].pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        content = b\"\".join(data for data in response)",
            "        self.assertEqual(content.decode(\"utf-8\"), \"Content 0\\n\")",
            "",
            "        # FileProxy not permitted by permission",
            "        url = reverse(\"extras-api:fileproxy-download\", kwargs={\"pk\": self.file_proxies[1].pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "",
            "class GitRepositoryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GitRepository",
            "    bulk_update_data = {",
            "        \"branch\": \"develop\",",
            "    }",
            "    choices_fields = [\"provided_contents\"]",
            "    slug_source = \"name\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\"),",
            "        )",
            "",
            "        cls.repos = (",
            "            GitRepository(",
            "                name=\"Repo 1\",",
            "                slug=\"repo_1\",",
            "                remote_url=\"https://example.com/repo1.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(",
            "                name=\"Repo 2\",",
            "                slug=\"repo_2\",",
            "                remote_url=\"https://example.com/repo2.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo_3\", remote_url=\"https://example.com/repo3.git\"),",
            "        )",
            "        for repo in cls.repos:",
            "            repo.save()",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"New Git Repository 1\",",
            "                \"slug\": \"new_git_repository_1\",",
            "                \"remote_url\": \"https://example.com/newrepo1.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "                \"provided_contents\": [\"extras.configcontext\", \"extras.exporttemplate\"],",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 2\",",
            "                \"slug\": \"new_git_repository_2\",",
            "                \"remote_url\": \"https://example.com/newrepo2.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 3\",",
            "                \"slug\": \"new_git_repository_3\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 4\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "        ]",
            "",
            "        # slug is enforced non-editable in clean because we want it to be providable by the user on creation",
            "        # but not modified afterward",
            "        cls.update_data = {",
            "            \"name\": \"A Different Repo Name\",",
            "            \"remote_url\": \"https://example.com/fake.git\",",
            "        }",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_no_celery_worker(self, mock_get_worker_count):",
            "        \"\"\"Git sync cannot be triggered if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_nonexistent_repo(self, mock_get_worker_count):",
            "        \"\"\"Git sync request handles case of a nonexistent repository.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": \"11111111-1111-1111-1111-111111111111\"})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_without_permissions(self, mock_get_worker_count):",
            "        \"\"\"Git sync request verifies user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_git_sync_with_permissions(self, _):",
            "        \"\"\"Git sync request can be submitted successfully.\"\"\"",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_create_with_app_provided_contents(self):",
            "        \"\"\"Test that `provided_contents` published by an App works.\"\"\"",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = self._get_list_url()",
            "        data = {",
            "            \"name\": \"app_test\",",
            "            \"slug\": \"app_test\",",
            "            \"remote_url\": \"https://localhost/app-test\",",
            "            \"provided_contents\": [\"example_app.textfile\"],",
            "        }",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(list(response.data[\"provided_contents\"]), data[\"provided_contents\"])",
            "",
            "",
            "class GraphQLQueryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GraphQLQuery",
            "    create_data = [",
            "        {",
            "            \"name\": \"graphql-query-4\",",
            "            \"query\": \"{ query: locations {name} }\",",
            "        },",
            "        {",
            "            \"name\": \"graphql-query-5\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, role { name } } }',",
            "        },",
            "        {",
            "            \"name\": \"Graphql Query 6\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, role { name } } }',",
            "        },",
            "    ]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                query=\"{ locations {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, role { name } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "        )",
            "",
            "        for query in cls.graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "    def test_run_saved_query(self):",
            "        \"\"\"Exercise the /run/ API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.add_graphqlquery\")",
            "        self.add_permissions(\"extras.change_graphqlquery\")",
            "        self.add_permissions(\"extras.view_graphqlquery\")",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[0].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"locations\": []}}, response.data)",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[2].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"devices\": []}}, response.data)",
            "",
            "",
            "# TODO(Glenn): Standardize to APIViewTestCase (needs create & update tests)",
            "class ImageAttachmentTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = ImageAttachment",
            "    choices_fields = [\"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Location)",
            "",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=location.pk,",
            "            name=\"Image Attachment 1\",",
            "            image=\"http://example.com/image1.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=location.pk,",
            "            name=\"Image Attachment 2\",",
            "            image=\"http://example.com/image2.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=location.pk,",
            "            name=\"Image Attachment 3\",",
            "            image=\"http://example.com/image3.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "",
            "    # TODO: Unskip after resolving #2908, #2909",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class JobTest(",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.UpdateObjectViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "    APIViewTestCases.NotesURLViewTestCase,",
            "):",
            "    \"\"\"Test cases for the Jobs REST API.\"\"\"",
            "",
            "    model = Job",
            "    choices_fields = None",
            "    update_data = {",
            "        # source, module_name, job_class_name, installed are NOT editable",
            "        \"grouping_override\": True,",
            "        \"grouping\": \"Overridden grouping\",",
            "        \"name_override\": True,",
            "        \"name\": \"Overridden name\",",
            "        \"description_override\": True,",
            "        \"description\": \"This is an overridden description.\",",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"dryrun_default_override\": True,",
            "        \"dryrun_default\": True,",
            "        \"hidden_override\": True,",
            "        \"hidden\": True,",
            "        \"soft_time_limit_override\": True,",
            "        \"soft_time_limit\": 350.1,",
            "        \"time_limit_override\": True,",
            "        \"time_limit\": 650,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "        \"task_queues\": [\"default\", \"priority\"],",
            "        \"task_queues_override\": True,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "    }",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.default_job_name = \"api_test_job.APITestJob\"",
            "        self.job_class = get_job(self.default_job_name)",
            "        self.assertIsNotNone(self.job_class)",
            "        self.job_model = Job.objects.get_for_class_path(self.default_job_name)",
            "        self.job_model.enabled = True",
            "        self.job_model.validated_save()",
            "",
            "    run_success_response_status = status.HTTP_201_CREATED",
            "",
            "    def get_run_url(self, class_path=\"api_test_job.APITestJob\"):",
            "        job_model = Job.objects.get_for_class_path(class_path)",
            "        return reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "",
            "    def test_get_job_variables(self):",
            "        \"\"\"Test the job/<pk>/variables API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.view_job\")",
            "        route = get_route_for_model(self.model, \"variables\", api=True)",
            "        response = self.client.get(reverse(route, kwargs={\"pk\": self.job_model.pk}), **self.header)",
            "        self.assertEqual(4, len(response.data))  # 4 variables, in order",
            "        self.assertEqual(response.data[0], {\"name\": \"var1\", \"type\": \"StringVar\", \"required\": True})",
            "        self.assertEqual(response.data[1], {\"name\": \"var2\", \"type\": \"IntegerVar\", \"required\": True})",
            "        self.assertEqual(response.data[2], {\"name\": \"var3\", \"type\": \"BooleanVar\", \"required\": False})",
            "        self.assertEqual(",
            "            response.data[3],",
            "            {\"name\": \"var4\", \"type\": \"ObjectVar\", \"required\": True, \"model\": \"extras.role\"},",
            "        )",
            "",
            "    def test_get_job_variables_by_name(self):",
            "        \"\"\"Test the job/<name>/variables API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.view_job\")",
            "        route = get_route_for_model(self.model, \"variables\", api=True)",
            "        response = self.client.get(reverse(route, kwargs={\"name\": self.job_model.name}), **self.header)",
            "        self.assertEqual(4, len(response.data))  # 4 variables, in order",
            "        self.assertEqual(response.data[0], {\"name\": \"var1\", \"type\": \"StringVar\", \"required\": True})",
            "        self.assertEqual(response.data[1], {\"name\": \"var2\", \"type\": \"IntegerVar\", \"required\": True})",
            "        self.assertEqual(response.data[2], {\"name\": \"var3\", \"type\": \"BooleanVar\", \"required\": False})",
            "        self.assertEqual(",
            "            response.data[3],",
            "            {\"name\": \"var4\", \"type\": \"ObjectVar\", \"required\": True, \"model\": \"extras.role\"},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_job_with_sensitive_variables_set_approval_required_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"api_test_job.APITestJob\")",
            "        job_model.has_sensitive_variables = True",
            "        job_model.has_sensitive_variables_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"approval_required\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_approval_required_job_set_has_sensitive_variables_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"api_test_job.APITestJob\")",
            "        job_model.approval_required = True",
            "        job_model.approval_required_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"has_sensitive_variables\": True,",
            "            \"has_sensitive_variables_override\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"has_sensitive_variables\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_anonymous_not_permitted(self):",
            "        \"\"\"The run_job endpoint should NOT allow anonymous users to submit jobs.\"\"\"",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_without_permission(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_permissions(self, mock_get_worker_count):",
            "        \"\"\"The run_job endpoint should enforce object-level permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"module_name__in\": [\"pass\", \"fail\"]},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try post to unpermitted job",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "        # Try post to permitted job",
            "        job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"pass.TestPass\")",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_enabled(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.enabled flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get_for_class_path(self.default_job_name)",
            "        job_model.enabled = False",
            "        job_model.save()",
            "",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_installed(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.installed flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job(",
            "            module_name=\"uninstalled_module\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Uninstalled Module\",",
            "            name=\"No such job\",",
            "            installed=False,",
            "            enabled=True,",
            "        )",
            "        job_model.validated_save()",
            "",
            "        url = self.get_run_url(\"uninstalled_module.NoSuchJob\")",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_405_METHOD_NOT_ALLOWED)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_no_worker(self, mock_get_worker_count):",
            "        \"\"\"Job run cannot be requested if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their primary keys.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"schedule\": {",
            "                \"name\": \"test\",",
            "                \"interval\": \"future\",",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertEqual(schedule.kwargs[\"var4\"], str(device_role.pk))",
            "",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"url\"], self.absolute_api_url(schedule))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"name\"], schedule.name)",
            "        # Python < 3.11 doesn't understand the datetime string \"2023-04-27T18:33:16.017865Z\",",
            "        # but it *does* understand the string \"2023-04-27T18:33:17.330836+00:00\"",
            "        self.assertEqual(",
            "            datetime.fromisoformat(response.data[\"scheduled_job\"][\"start_time\"].replace(\"Z\", \"+00:00\")),",
            "            schedule.start_time,",
            "        )",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var_no_schedule(self, mock_get_worker_count):",
            "        \"\"\"",
            "        Run a job with `approval_required` without providing a schedule.",
            "",
            "        Assert an immediate schedule that enforces it.",
            "        \"\"\"",
            "        # Set approval_required=True",
            "        self.job_model.approval_required = True",
            "        self.job_model.save()",
            "",
            "        # Do the stuff.",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            # schedule is omitted",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        # Assert that a JobResult for this job was NOT created.",
            "        self.assertFalse(JobResult.objects.filter(name=self.job_model.name).exists())",
            "",
            "        # Assert that we have an immediate ScheduledJob and that it matches the job_model.",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertIsNotNone(schedule)",
            "        self.assertEqual(schedule.interval, JobExecutionType.TYPE_IMMEDIATELY)",
            "        self.assertEqual(schedule.approval_required, self.job_model.approval_required)",
            "        self.assertEqual(schedule.kwargs[\"var4\"], str(device_role.pk))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    @mock.patch(\"nautobot.extras.models.jobs.JobResult.enqueue_job\")",
            "    def test_run_job_object_var_lookup(self, mock_enqueue_job, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        mock_enqueue_job.return_value = None",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": {\"name\": device_role.name},",
            "        }",
            "",
            "        # This handles things like ObjectVar fields looked up by non-UUID",
            "        # Jobs are executed with deserialized data",
            "        deserialized_data = self.job_class.deserialize_data(job_data)",
            "",
            "        self.assertEqual(",
            "            deserialized_data,",
            "            {\"var1\": \"FooBar\", \"var2\": 123, \"var3\": False, \"var4\": device_role},",
            "        )",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, {\"data\": job_data}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        # Ensure the enqueue_job args deserialize to the same as originally inputted",
            "        expected_enqueue_job_args = (self.job_model, self.user)",
            "        expected_enqueue_job_kwargs = {",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "            **self.job_class.serialize_data(deserialized_data),",
            "        }",
            "        mock_enqueue_job.assert_called_with(*expected_enqueue_job_args, **expected_enqueue_job_kwargs)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_response_job_result(self, mock_get_worker_count):",
            "        \"\"\"Test job run response contains nested job result.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": {\"name\": device_role.name},",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, {\"data\": job_data}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.get(name=self.job_model.name)",
            "",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertIsNone(response.data[\"scheduled_job\"])",
            "        data_job_result = response.data[\"job_result\"]",
            "        expected_data_job_result = JobResultSerializer(job_result, context={\"request\": response.wsgi_request}).data",
            "        self.assertEqual(data_job_result, expected_data_job_result)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_commit(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"field_order.TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"field_order.TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_only(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"field_order.TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"field_order.TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_schedule(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"field_order.TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "            \"_schedule_start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            \"_schedule_interval\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"field_order.TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future(self, mock_get_worker_count):",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"url\"], self.absolute_api_url(schedule))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"name\"], schedule.name)",
            "        # Python < 3.11 doesn't understand the datetime string \"2023-04-27T18:33:16.017865Z\",",
            "        # but it *does* understand the string \"2023-04-27T18:33:17.330836+00:00\"",
            "        self.assertEqual(",
            "            datetime.fromisoformat(response.data[\"scheduled_job\"][\"start_time\"].replace(\"Z\", \"+00:00\")),",
            "            schedule.start_time,",
            "        )",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_for_future(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        # url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"interval\"][0],",
            "            \"Unable to schedule job: Job may have sensitive input variables\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_and_requires_approval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.has_sensitive_variables = True",
            "        job_model.approval_required = True",
            "        job_model.save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0],",
            "            \"Unable to run or schedule job: \"",
            "            \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "            \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_a_job_with_sensitive_variables_immediately(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "        self.job_model.has_sensitive_variables = True",
            "        self.job_model.has_sensitive_variables_override = True",
            "        self.job_model.validated_save()",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.get(name=self.job_model.name)",
            "        self.assertEqual(job_result.task_kwargs, {})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future_past(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() - timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_interval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"hourly\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"url\"], self.absolute_api_url(schedule))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"name\"], schedule.name)",
            "        # Python < 3.11 doesn't understand the datetime string \"2023-04-27T18:33:16.017865Z\",",
            "        # but it *does* understand the string \"2023-04-27T18:33:17.330836+00:00\"",
            "        self.assertEqual(",
            "            datetime.fromisoformat(response.data[\"scheduled_job\"][\"start_time\"].replace(\"Z\", \"+00:00\")),",
            "            schedule.start_time,",
            "        )",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"data\": \"invalid\",",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": [\"Job data needs to be a dict\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_wrong_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var5\": \"wrong\",",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": {\"var5\": [\"Job data contained an unknown property\"]}})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_missing_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var3\": False,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data, {\"errors\": {\"var2\": [\"This field is required.\"], \"var4\": [\"This field is required.\"]}}",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_task_queue(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"task_queue\": \"invalid\",",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data,",
            "            {\"task_queue\": ['\"invalid\" is not a valid choice.']},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_valid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_default_queue_with_empty_job_model_task_queues(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        data = {",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"pass.TestPass\")",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    # TODO: Either improve test base or or write a more specific test for this model.",
            "    @skip(\"Job has a `name` property but grouping is also used to sort Jobs\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"Job has a `name` property but grouping is also used to sort Jobs\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class JobHookTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobHook",
            "    choices_fields = []",
            "    update_data = {",
            "        \"name\": \"Overridden name\",",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobHook4\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook5\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverChange\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook6\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverFail\").pk,",
            "                \"enabled\": False,",
            "            },",
            "        ]",
            "        cls.job_hooks = (",
            "            JobHook(",
            "                name=\"JobHook1\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverLog\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook2\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverChange\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook3\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverFail\"),",
            "                type_delete=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for job_hook in cls.job_hooks:",
            "            job_hook.save()",
            "            job_hook.content_types.set([obj_type])",
            "",
            "    def test_validate_post(self):",
            "        \"\"\"POST a job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"name\": \"JobHook4\",",
            "            \"content_types\": [\"dcim.devicetype\"],",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_create\": False,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_jobhook\")",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "    def test_validate_patch(self):",
            "        \"\"\"PATCH an existing job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_jobhook\")",
            "        job_hook2 = JobHook.objects.get(name=\"JobHook2\")",
            "        response = self.client.patch(self._get_detail_url(job_hook2), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "",
            "class JobButtonTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobButton",
            "    choices_fields = [\"button_class\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobButton4\",",
            "                \"text\": \"JobButton4\",",
            "                \"content_types\": [\"dcim.location\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\").pk,",
            "            },",
            "            {",
            "                \"name\": \"JobButton5\",",
            "                \"text\": \"JobButton5\",",
            "                \"content_types\": [\"circuits.circuit\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            },",
            "        ]",
            "        location_type = ContentType.objects.get_for_model(Location)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        location_jb = JobButton(",
            "            name=\"api-test-location\",",
            "            text=\"API job button location text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        location_jb.save()",
            "        location_jb.content_types.set([location_type])",
            "",
            "        device_jb = JobButton.objects.create(",
            "            name=\"api-test-device\",",
            "            text=\"API job button device text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        device_jb.save()",
            "        device_jb.content_types.set([device_type])",
            "",
            "        complex_jb = JobButton.objects.create(",
            "            name=\"api-test-complex\",",
            "            text=\"API job button complex text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        complex_jb.save()",
            "        complex_jb.content_types.set([device_type, location_type])",
            "",
            "",
            "class JobResultTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = JobResult",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        jobs = Job.objects.all()[:2]",
            "",
            "        JobResult.objects.create(",
            "            job_model=jobs[0],",
            "            name=jobs[0].class_path,",
            "            date_done=now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            task_kwargs={},",
            "            scheduled_job=None,",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=None,",
            "            name=\"deleted_module.deleted_job\",",
            "            date_done=now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            task_kwargs={\"repository_pk\": uuid.uuid4()},",
            "            scheduled_job=None,",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=jobs[1],",
            "            name=jobs[1].class_path,",
            "            date_done=None,",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_PENDING,",
            "            task_kwargs={\"data\": {\"device\": uuid.uuid4(), \"multichoices\": [\"red\", \"green\"], \"checkbox\": False}},",
            "            scheduled_job=None,",
            "        )",
            "",
            "",
            "class JobLogEntryTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobLogEntry",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.job_result = JobResult.objects.create(name=\"test\")",
            "",
            "        for log_level in (\"debug\", \"info\", \"success\", \"warning\"):",
            "            JobLogEntry.objects.create(",
            "                log_level=log_level,",
            "                grouping=\"run\",",
            "                job_result=cls.job_result,",
            "                message=f\"I am a {log_level} log.\",",
            "            )",
            "",
            "    def test_list_job_logs_from_job_results_detail(self):",
            "        \"\"\"Test `logs` endpoint from `JobResult` detail.\"\"\"",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "        url = reverse(\"extras-api:jobresult-logs\", kwargs={\"pk\": self.job_result.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertEqual(len(response.json()), JobLogEntry.objects.count())",
            "",
            "",
            "class ScheduledJobTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"pass.TestPass\",",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"pass.TestPass\",",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"pass.TestPass\",",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "    # TODO: Unskip after resolving #2908, #2909",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class JobApprovalTest(APITestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.additional_user = User.objects.create(username=\"user1\", is_active=True)",
            "        cls.job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        cls.job_model.enabled = True",
            "        cls.job_model.save()",
            "        cls.scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test pass\",",
            "            task=\"pass.TestPass\",",
            "            job_model=cls.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=cls.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        cls.dryrun_job_model = Job.objects.get_for_class_path(\"dry_run.TestDryRun\")",
            "        cls.dryrun_job_model.enabled = True",
            "        cls.dryrun_job_model.save()",
            "        cls.dryrun_scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test dryrun\",",
            "            task=\"dry_run.TestDryRun\",",
            "            job_model=cls.dryrun_job_model,",
            "            kwargs={\"value\": 1},",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=cls.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_anonymous(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_change_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_same_user(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past_force(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url + \"?force=true\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_delete_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIsNone(ScheduledJob.objects.filter(pk=self.scheduled_job.pk).first())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_dry_run_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.dryrun_scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job_without_run_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.dryrun_scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job(self):",
            "        self.add_permissions(\"extras.run_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.dryrun_scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        # The below fails because JobResult.task_kwargs doesn't get set until *after* the task begins executing.",
            "        # self.assertEqual(response.data[\"task_kwargs\"], {\"dryrun\": True, \"value\": 1}, response.data)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_not_supported(self):",
            "        self.add_permissions(\"extras.run_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_405_METHOD_NOT_ALLOWED)",
            "",
            "",
            "class NoteTest(APIViewTestCases.APIViewTestCase):",
            "    model = Note",
            "    choices_fields = [\"assigned_object_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.location1 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        location2 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).last()",
            "        cls.location_ct = ContentType.objects.get_for_model(Location)",
            "        user1 = User.objects.create(username=\"user1\", is_active=True)",
            "        user2 = User.objects.create(username=\"user2\", is_active=True)",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": cls.location1.pk,",
            "                \"assigned_object_type\": \"dcim.location\",",
            "            },",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": location2.pk,",
            "                \"assigned_object_type\": \"dcim.location\",",
            "            },",
            "            {",
            "                \"note\": \"This is a note on location 1.\",",
            "                \"assigned_object_id\": cls.location1.pk,",
            "                \"assigned_object_type\": \"dcim.location\",",
            "            },",
            "        ]",
            "        cls.bulk_update_data = {",
            "            \"note\": \"Bulk change.\",",
            "        }",
            "        Note.objects.create(",
            "            note=\"location has been placed on maintenance.\",",
            "            user=user1,",
            "            assigned_object_type=cls.location_ct,",
            "            assigned_object_id=cls.location1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"location maintenance has ended.\",",
            "            user=user1,",
            "            assigned_object_type=cls.location_ct,",
            "            assigned_object_id=cls.location1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"location is under duress.\",",
            "            user=user2,",
            "            assigned_object_type=cls.location_ct,",
            "            assigned_object_id=location2.pk,",
            "        )",
            "",
            "    def get_deletable_object(self):",
            "        \"\"\"",
            "        Users only create self-authored notes via the REST API; test_recreate_object_csv needs self.user as author.",
            "        \"\"\"",
            "        return Note.objects.create(",
            "            note=\"Delete me!\",",
            "            user=self.user,",
            "            assigned_object_type=self.location_ct,",
            "            assigned_object_id=self.location1.pk,",
            "        )",
            "",
            "",
            "class ObjectChangeTest(APIViewTestCases.GetObjectViewTestCase, APIViewTestCases.ListObjectsViewTestCase):",
            "    model = ObjectChange",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cc = ConfigContext.objects.create(name=\"Config Context 1\", weight=100, data={\"foo\": 123})",
            "        cc_oc = cc.to_objectchange(ObjectChangeActionChoices.ACTION_CREATE)",
            "        cc_oc.request_id = uuid.uuid4()",
            "        cc_oc.change_context = ObjectChangeEventContextChoices.CONTEXT_WEB",
            "        cc_oc.change_context_detail = \"extras:configcontext_edit\"",
            "        cc_oc.validated_save()",
            "",
            "        location_oc = Location.objects.first().to_objectchange(ObjectChangeActionChoices.ACTION_UPDATE)",
            "        location_oc.request_id = uuid.uuid4()",
            "        location_oc.change_context = ObjectChangeEventContextChoices.CONTEXT_ORM",
            "        location_oc.validated_save()",
            "",
            "        git_oc = ObjectChange.objects.create(",
            "            user=None,",
            "            user_name=\"deleted\",",
            "            request_id=cc_oc.request_id,",
            "            action=ObjectChangeActionChoices.ACTION_DELETE,",
            "            changed_object_type=ContentType.objects.get_for_model(GitRepository),",
            "            changed_object_id=uuid.UUID(\"7af2e8d5-6d53-4b79-b488-60448aaaa9e8\"),",
            "            change_context=ObjectChangeEventContextChoices.CONTEXT_WEB,",
            "            change_context_detail=\"extras:gitrepository_delete\",",
            "            related_object=cc_oc.changed_object,",
            "            object_repr=\"demo-git-datasource 2\",",
            "            object_data={",
            "                \"name\": \"demo-git-datasource 2\",",
            "                \"slug\": \"demo_git_datasource_2\",",
            "                \"tags\": [],",
            "                \"branch\": \"main\",",
            "                \"created\": \"2023-06-07T12:49:34.309Z\",",
            "                \"remote_url\": \"https://github.com/nautobot/demo-git-datasource.git\",",
            "                \"current_head\": \"94e88b76e87ccf1fdf48995d72ede86db4623d60\",",
            "                \"last_updated\": \"2023-06-07T12:49:36.368Z\",",
            "                \"custom_fields\": {},",
            "                \"secrets_group\": None,",
            "                \"provided_contents\": [\"extras.configcontext\", \"extras.configcontextschema\", \"extras.exporttemplate\"],",
            "            },",
            "            object_data_v2={",
            "                \"id\": \"7af2e8d5-6d53-4b79-b488-60448aaaa9e8\",",
            "                \"url\": \"/api/extras/git-repositories/7af2e8d5-6d53-4b79-b488-60448aaaa9e8/\",",
            "                \"name\": \"demo-git-datasource 2\",",
            "                \"slug\": \"demo_git_datasource_2\",",
            "                \"branch\": \"main\",",
            "                \"created\": \"2023-06-07T12:49:34.309312Z\",",
            "                \"display\": \"demo-git-datasource 2\",",
            "                \"notes_url\": \"/api/extras/git-repositories/7af2e8d5-6d53-4b79-b488-60448aaaa9e8/notes/\",",
            "                \"remote_url\": \"https://github.com/nautobot/demo-git-datasource.git\",",
            "                \"object_type\": \"extras.gitrepository\",",
            "                \"current_head\": \"94e88b76e87ccf1fdf48995d72ede86db4623d60\",",
            "                \"last_updated\": \"2023-06-07T12:49:36.368627Z\",",
            "                \"custom_fields\": {},",
            "                \"secrets_group\": None,",
            "                \"natural_key_slug\": \"demo-git-datasource+2\",",
            "                \"provided_contents\": [\"extras.configcontextschema\", \"extras.configcontext\", \"extras.exporttemplate\"],",
            "            },",
            "        )",
            "        git_oc.validated_save()",
            "",
            "",
            "class RelationshipTest(APIViewTestCases.APIViewTestCase, RequiredRelationshipTestMixin):",
            "    model = Relationship",
            "",
            "    create_data = [",
            "        {",
            "            \"label\": \"Device VLANs\",",
            "            \"key\": \"device_vlans\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"label\": \"Primary VLAN\",",
            "            \"key\": \"primary_vlan\",",
            "            \"type\": \"one-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"label\": \"Primary Interface\",",
            "            \"key\": \"primary_interface\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "        {",
            "            \"label\": \"Relationship 1\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "    ]",
            "",
            "    bulk_update_data = {",
            "        \"source_filter\": {\"name\": [\"some-name\"]},",
            "    }",
            "    choices_fields = [\"destination_type\", \"source_type\", \"type\", \"required_on\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_type = ContentType.objects.get_for_model(Location)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.relationships = (",
            "            Relationship(",
            "                label=\"Related locations\",",
            "                key=\"related_locations\",",
            "                type=\"symmetric-many-to-many\",",
            "                source_type=location_type,",
            "                destination_type=location_type,",
            "            ),",
            "            Relationship(",
            "                label=\"Unrelated locations\",",
            "                key=\"unrelated_locations\",",
            "                type=\"many-to-many\",",
            "                source_type=location_type,",
            "                source_label=\"Other locations (from source side)\",",
            "                destination_type=location_type,",
            "                destination_label=\"Other locations (from destination side)\",",
            "            ),",
            "            Relationship(",
            "                label=\"Devices found elsewhere\",",
            "                key=\"devices_elsewhere\",",
            "                type=\"many-to-many\",",
            "                source_type=location_type,",
            "                destination_type=device_type,",
            "            ),",
            "        )",
            "        for relationship in cls.relationships:",
            "            relationship.validated_save()",
            "        cls.lt = LocationType.objects.get(name=\"Campus\")",
            "        location_status = Status.objects.get_for_model(Location).first()",
            "        cls.location = Location.objects.create(name=\"Location 1\", status=location_status, location_type=cls.lt)",
            "",
            "    def test_get_all_relationships_on_location(self):",
            "        \"\"\"Verify that all relationships are accurately represented when requested.\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.location.pk}) + \"?include=relationships\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            {",
            "                self.relationships[0].key: {",
            "                    \"id\": str(self.relationships[0].pk),",
            "                    \"url\": self.absolute_api_url(self.relationships[0]),",
            "                    \"label\": self.relationships[0].label,",
            "                    \"type\": self.relationships[0].type,",
            "                    \"peer\": {",
            "                        \"label\": \"locations\",",
            "                        \"object_type\": \"dcim.location\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[1].key: {",
            "                    \"id\": str(self.relationships[1].pk),",
            "                    \"url\": self.absolute_api_url(self.relationships[1]),",
            "                    \"label\": self.relationships[1].label,",
            "                    \"type\": self.relationships[1].type,",
            "                    \"destination\": {",
            "                        \"label\": self.relationships[1].source_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.location\",",
            "                        \"objects\": [],",
            "                    },",
            "                    \"source\": {",
            "                        \"label\": self.relationships[1].destination_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.location\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[2].key: {",
            "                    \"id\": str(self.relationships[2].pk),",
            "                    \"url\": self.absolute_api_url(self.relationships[2]),",
            "                    \"label\": self.relationships[2].label,",
            "                    \"type\": self.relationships[2].type,",
            "                    \"destination\": {",
            "                        \"label\": \"devices\",",
            "                        \"object_type\": \"dcim.device\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "            },",
            "            response.data[\"relationships\"],",
            "        )",
            "",
            "    def test_populate_relationship_associations_on_location_create(self):",
            "        \"\"\"Verify that relationship associations can be populated at instance creation time.\"\"\"",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        existing_location_1 = Location.objects.create(",
            "            name=\"Existing Location 1\",",
            "            status=Status.objects.get_for_model(Location).first(),",
            "            location_type=location_type,",
            "        )",
            "        existing_location_2 = Location.objects.create(",
            "            name=\"Existing Location 2\",",
            "            status=Status.objects.get_for_model(Location).first(),",
            "            location_type=location_type,",
            "        )",
            "        manufacturer = Manufacturer.objects.first()",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "        )",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        device_status = Status.objects.get_for_model(Device).first()",
            "        existing_device_1 = Device.objects.create(",
            "            name=\"existing-device-location-1\",",
            "            status=device_status,",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=existing_location_1,",
            "        )",
            "        existing_device_2 = Device.objects.create(",
            "            name=\"existing-device-location-2\",",
            "            status=device_status,",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=existing_location_2,",
            "        )",
            "",
            "        self.add_permissions(\"dcim.view_location\", \"dcim.add_location\", \"extras.add_relationshipassociation\")",
            "        response = self.client.post(",
            "            reverse(\"dcim-api:location-list\"),",
            "            data={",
            "                \"name\": \"New location\",",
            "                \"status\": Status.objects.get_for_model(Location).first().pk,",
            "                \"location_type\": location_type.pk,",
            "                \"relationships\": {",
            "                    self.relationships[0].key: {",
            "                        \"peer\": {",
            "                            \"objects\": [str(existing_location_1.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[1].key: {",
            "                        \"source\": {",
            "                            \"objects\": [str(existing_location_2.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[2].key: {",
            "                        \"destination\": {",
            "                            \"objects\": [",
            "                                {\"name\": \"existing-device-location-1\"},",
            "                                {\"name\": \"existing-device-location-2\"},",
            "                            ],",
            "                        },",
            "                    },",
            "                },",
            "            },",
            "            format=\"json\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        new_location_id = response.data[\"id\"]",
            "        # Peer case - don't distinguish source/destination",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[0],",
            "                source_type=self.relationships[0].source_type,",
            "                source_id__in=[existing_location_1.pk, new_location_id],",
            "                destination_type=self.relationships[0].destination_type,",
            "                destination_id__in=[existing_location_1.pk, new_location_id],",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[1],",
            "                source_type=self.relationships[1].source_type,",
            "                source_id=existing_location_2.pk,",
            "                destination_type=self.relationships[1].destination_type,",
            "                destination_id=new_location_id,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_location_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_1.pk,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_location_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_2.pk,",
            "            ).exists()",
            "        )",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test various bulk create/edit scenarios",
            "        \"\"\"",
            "",
            "        # Delete existing factory generated objects that may interfere with this test",
            "        IPAddress.objects.all().delete()",
            "        Prefix.objects.update(parent=None)",
            "        Prefix.objects.all().delete()",
            "        VLAN.objects.all().delete()",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"api\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        # VLAN endpoint to POST, PATCH and PUT multiple objects to:",
            "        vlan_list_endpoint = reverse(get_route_for_model(VLAN, \"list\", api=True))",
            "",
            "        def send_bulk_data(http_method, data):",
            "            return getattr(self.client, http_method)(",
            "                vlan_list_endpoint,",
            "                data=data,",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "",
            "        device_status = Status.objects.get_for_model(Device).first()",
            "        vlan_groups = VLANGroup.objects.all()[:2]",
            "",
            "        # Try deleting all devices and then creating 2 VLANs (fails):",
            "        Controller.objects.filter(controller_device__isnull=False).delete()",
            "        Device.objects.all().delete()",
            "        response = send_bulk_data(",
            "            \"post\",",
            "            data=[",
            "                {\"vid\": \"7\", \"name\": \"7\", \"status\": device_status.pk, \"vlan_group\": vlan_groups[0].pk},",
            "                {\"vid\": \"8\", \"name\": \"8\", \"status\": device_status.pk, \"vlan_group\": vlan_groups[1].pk},",
            "            ],",
            "        )",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            {",
            "                \"relationships\": {",
            "                    \"vlans_devices_m2m\": [",
            "                        \"VLANs require at least one device, but no devices exist yet. \"",
            "                        \"Create a device by posting to /api/dcim/devices/\",",
            "                        'You need to specify [\"relationships\"][\"vlans_devices_m2m\"][\"source\"][\"objects\"].',",
            "                    ]",
            "                }",
            "            },",
            "            response.json(),",
            "        )",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "        required_relationship_json = {\"vlans_devices_m2m\": {\"source\": {\"objects\": [str(device_for_association.id)]}}}",
            "        expected_error_json = {",
            "            \"relationships\": {",
            "                \"vlans_devices_m2m\": [",
            "                    'You need to specify [\"relationships\"][\"vlans_devices_m2m\"][\"source\"][\"objects\"].'",
            "                ]",
            "            }",
            "        }",
            "",
            "        # Test POST, PATCH and PUT",
            "        for method in [\"post\", \"patch\", \"put\"]:",
            "            if method == \"post\":",
            "                vlan1_json_data = {",
            "                    \"vid\": \"13\",",
            "                    \"name\": \"1\",",
            "                    \"status\": device_status.pk,",
            "                    \"vlan_group\": vlan_groups[0].pk,",
            "                }",
            "                vlan2_json_data = {",
            "                    \"vid\": \"22\",",
            "                    \"name\": \"2\",",
            "                    \"status\": device_status.pk,",
            "                    \"vlan_group\": vlan_groups[1].pk,",
            "                }",
            "            else:",
            "                vlan1 = VLAN.objects.create(name=\"test_required_relationships1\", vid=1, status=device_status)",
            "                vlan2 = VLAN.objects.create(name=\"test_required_relationships2\", vid=2, status=device_status)",
            "                vlan1_json_data = {\"status\": device_status.pk, \"id\": str(vlan1.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan1_json_data.update({\"vid\": \"4\", \"name\": vlan1.name})",
            "",
            "                vlan2_json_data = {\"status\": device_status.pk, \"id\": str(vlan2.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan2_json_data.update({\"vid\": \"5\", \"name\": vlan2.name})",
            "",
            "            # Try method without specifying required relationships for either vlan1 or vlan2 (fails)",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for just vlan1 (fails)",
            "            vlan1_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for both vlan1 and vlan2 (succeeds)",
            "            vlan2_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            if method == \"post\":",
            "                self.assertHttpStatus(response, 201)",
            "            else:",
            "                self.assertHttpStatus(response, 200)",
            "",
            "            # Check the relationship associations were actually created",
            "            for vlan in response.json():",
            "                associated_device = vlan[\"relationships\"][\"vlans_devices_m2m\"][\"source\"][\"objects\"][0]",
            "                self.assertEqual(str(device_for_association.id), associated_device[\"id\"])",
            "",
            "",
            "class RelationshipAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = RelationshipAssociation",
            "    choices_fields = [\"destination_type\", \"source_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.location_type = ContentType.objects.get_for_model(Location)",
            "        cls.device_type = ContentType.objects.get_for_model(Device)",
            "        cls.location_status = Status.objects.get_for_model(Location).first()",
            "",
            "        cls.relationship = Relationship(",
            "            label=\"Devices found elsewhere\",",
            "            key=\"elsewhere_devices\",",
            "            type=\"many-to-many\",",
            "            source_type=cls.location_type,",
            "            destination_type=cls.device_type,",
            "        )",
            "        cls.relationship.validated_save()",
            "        cls.lt = LocationType.objects.get(name=\"Campus\")",
            "        cls.locations = (",
            "            Location.objects.create(name=\"Empty Location\", status=cls.location_status, location_type=cls.lt),",
            "            Location.objects.create(name=\"Occupied Location\", status=cls.location_status, location_type=cls.lt),",
            "            Location.objects.create(name=\"Another Empty Location\", status=cls.location_status, location_type=cls.lt),",
            "        )",
            "        manufacturer = Manufacturer.objects.first()",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\")",
            "        devicerole = Role.objects.get_for_model(Device).first()",
            "        device_status = Status.objects.get_for_model(Device).first()",
            "        cls.devices = [",
            "            Device.objects.create(",
            "                name=f\"Device {num}\",",
            "                device_type=devicetype,",
            "                role=devicerole,",
            "                location=cls.locations[1],",
            "                status=device_status,",
            "            )",
            "            for num in range(1, 5)",
            "        ]",
            "",
            "        cls.associations = (",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.location_type,",
            "                source_id=cls.locations[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[0].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.location_type,",
            "                source_id=cls.locations[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[1].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.location_type,",
            "                source_id=cls.locations[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[2].pk,",
            "            ),",
            "        )",
            "        for association in cls.associations:",
            "            association.validated_save()",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.location\",",
            "                \"source_id\": cls.locations[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[0].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.location\",",
            "                \"source_id\": cls.locations[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[1].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.location\",",
            "                \"source_id\": cls.locations[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[2].pk,",
            "            },",
            "        ]",
            "",
            "    def test_create_invalid_relationship_association(self):",
            "        \"\"\"Test creation of invalid relationship association restricted by destination/source filter.\"\"\"",
            "",
            "        relationship = Relationship.objects.create(",
            "            label=\"Device to location Rel 1\",",
            "            key=\"device_to_location_rel_1\",",
            "            source_type=self.device_type,",
            "            source_filter={\"name\": [self.devices[0].name]},",
            "            destination_type=self.location_type,",
            "            destination_label=\"Primary Rack\",",
            "            type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            destination_filter={\"name\": [self.locations[0].name]},",
            "        )",
            "",
            "        associations = [",
            "            (",
            "                \"destination\",  # side",
            "                self.locations[2].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[0].pk,",
            "                    \"destination_type\": \"dcim.location\",",
            "                    \"destination_id\": self.locations[2].pk,",
            "                },",
            "            ),",
            "            (",
            "                \"source\",  # side",
            "                self.devices[1].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[1].pk,",
            "                    \"destination_type\": \"dcim.location\",",
            "                    \"destination_id\": self.locations[0].pk,",
            "                },",
            "            ),",
            "        ]",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        for side, field_error_name, data in associations:",
            "            response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                response.data[side],",
            "                [f\"{field_error_name} violates {relationship.label} {side}_filter restriction\"],",
            "            )",
            "",
            "    def test_model_clean_method_is_called(self):",
            "        \"\"\"Validate RelationshipAssociation clean method is called\"\"\"",
            "",
            "        data = {",
            "            \"relationship\": self.relationship.pk,",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_id\": self.locations[2].pk,",
            "            \"destination_type\": \"dcim.device\",",
            "            \"destination_id\": self.devices[2].pk,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"source_type\"], [f\"source_type has a different value than defined in {self.relationship}\"]",
            "        )",
            "",
            "    def test_get_association_data_on_location(self):",
            "        \"\"\"",
            "        Check that `include=relationships` query parameter on a model endpoint includes relationships/associations.",
            "        \"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.locations[0].pk})",
            "            + \"?include=relationships\"",
            "            + \"&depth=1\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        # Ensure consistent ordering",
            "        response.data[\"relationships\"][self.relationship.key][\"destination\"][\"objects\"].sort(key=lambda v: v[\"name\"])",
            "        self.maxDiff = None",
            "        relationship_data = response.data[\"relationships\"][self.relationship.key]",
            "        self.assertEqual(relationship_data[\"id\"], str(self.relationship.pk))",
            "        self.assertEqual(relationship_data[\"url\"], self.absolute_api_url(self.relationship))",
            "        self.assertEqual(relationship_data[\"label\"], self.relationship.label)",
            "        self.assertEqual(relationship_data[\"type\"], \"many-to-many\")",
            "        self.assertEqual(relationship_data[\"destination\"][\"label\"], \"devices\")",
            "        self.assertEqual(relationship_data[\"destination\"][\"object_type\"], \"dcim.device\")",
            "",
            "        objects = response.data[\"relationships\"][self.relationship.key][\"destination\"][\"objects\"]",
            "        for i, obj in enumerate(objects):",
            "            self.assertEqual(obj[\"id\"], str(self.devices[i].pk))",
            "            self.assertEqual(obj[\"url\"], self.absolute_api_url(self.devices[i]))",
            "            self.assertEqual(",
            "                obj[\"display\"],",
            "                self.devices[i].display,",
            "            )",
            "            self.assertEqual(",
            "                obj[\"name\"],",
            "                self.devices[i].name,",
            "            )",
            "",
            "    def test_update_association_data_on_location(self):",
            "        \"\"\"",
            "        Check that relationship-associations can be updated via the 'relationships' field.",
            "        \"\"\"",
            "        self.add_permissions(",
            "            \"dcim.view_location\",",
            "            \"dcim.change_location\",",
            "            \"extras.add_relationshipassociation\",",
            "            \"extras.delete_relationshipassociation\",",
            "        )",
            "        initial_response = self.client.get(",
            "            reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.locations[0].pk}) + \"?include=relationships\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(initial_response, status.HTTP_200_OK)",
            "",
            "        url = reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.locations[0].pk})",
            "",
            "        with self.subTest(\"Round-trip of same relationships data is a no-op\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": initial_response.data[\"relationships\"]},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Omitting relationships data entirely is valid\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: nonexistent relationship\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"nonexistent-relationship\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]),",
            "                '\"nonexistent-relationship\" is not a relationship on dcim.Location',",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship\"):",
            "            Relationship.objects.create(",
            "                label=\"Device-to-Device\",",
            "                key=\"device_to_device\",",
            "                source_type=self.device_type,",
            "                destination_type=self.device_type,",
            "                type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            )",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"device_to_device\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]), '\"device_to_device\" is not a relationship on dcim.Location'",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship side\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {self.relationship.key: {\"source\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]),",
            "                '\"source\" is not a valid side for \"Devices found elsewhere\" on dcim.Location',",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Valid data: create/no-op/delete on RelationshipAssociations\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {",
            "                    \"relationships\": {",
            "                        self.relationship.key: {",
            "                            \"destination\": {",
            "                                \"objects\": [",
            "                                    # remove devices[0] by omission",
            "                                    str(self.devices[1].pk),  # existing device identified by PK",
            "                                    {\"name\": self.devices[2].name},  # existing device identified by attributes",
            "                                    {\"id\": self.devices[3].pk},  # new device association",
            "                                ]",
            "                            }",
            "                        }",
            "                    },",
            "                },",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            # Removed association",
            "            self.assertFalse(RelationshipAssociation.objects.filter(pk=self.associations[0].pk).exists())",
            "            # Unchanged associations",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[1].pk).exists())",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[2].pk).exists())",
            "            # Created association",
            "            self.assertTrue(RelationshipAssociation.objects.filter(destination_id=self.devices[3].pk).exists())",
            "",
            "",
            "class SecretTest(APIViewTestCases.APIViewTestCase):",
            "    model = Secret",
            "    bulk_update_data = {}",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"NAPALM Username\",",
            "            \"provider\": \"environment-variable\",",
            "            \"description\": \"Username for all NAPALM devices\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_USERNAME\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"NAPALM Password\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_PASSWORD\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"GitHub Token for My Repository\",",
            "            \"provider\": \"text-file\",",
            "            \"parameters\": {",
            "                \"path\": \"/github-tokens/user/myusername.txt\",",
            "            },",
            "        },",
            "    ]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"api-test-1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_1\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "    def test_secret_check(self):",
            "        \"\"\"",
            "        Ensure that we can check the validity of a secret.",
            "        \"\"\"",
            "",
            "        with self.subTest(\"Secret is not accessible\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-not-accessible\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-matter\"},  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "        self.add_permissions(\"extras.view_secret\")",
            "",
            "        with self.subTest(\"Secret check successful\"):",
            "            with tempfile.NamedTemporaryFile() as secret_file:",
            "                secret_file.write(b\"HELLO WORLD\")",
            "                test_secret = Secret.objects.create(",
            "                    name=\"secret-check-test-accessible\",",
            "                    provider=\"text-file\",",
            "                    parameters={\"path\": secret_file.name},",
            "                )",
            "                response = self.client.get(",
            "                    reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header",
            "                )",
            "                self.assertHttpStatus(response, status.HTTP_200_OK)",
            "                self.assertEqual(response.data[\"result\"], True)",
            "",
            "        with self.subTest(\"Secret check failed\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-failed\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-exist\"},  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(response.data[\"result\"], False)",
            "            self.assertIn(\"SecretValueNotFoundError\", response.data[\"message\"])",
            "",
            "",
            "class SecretsGroupTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroup",
            "    bulk_update_data = {}",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\"),",
            "            SecretsGroup.objects.create(name=\"Group B\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            secrets_group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            secrets_group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Secrets Group 1\",",
            "                \"description\": \"First Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 2\",",
            "                \"description\": \"Second Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 3\",",
            "                \"description\": \"Third Secrets Group\",",
            "            },",
            "        ]",
            "",
            "",
            "class SecretsGroupAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroupAssociation",
            "    bulk_update_data = {}",
            "    choices_fields = [\"access_type\", \"secret_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-3\", provider=\"environment-variable\", parameters={\"variable\": \"YET_ANOTHER\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\"),",
            "            SecretsGroup.objects.create(name=\"Group B\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            secrets_group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            secrets_group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[2],",
            "            secrets_group=secrets_groups[2],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"secrets_group\": secrets_groups[0].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[0].pk,",
            "            },",
            "            {",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[1].pk,",
            "            },",
            "            {",
            "                \"secrets_group\": secrets_groups[2].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[2].pk,",
            "            },",
            "        ]",
            "",
            "",
            "class StatusTest(APIViewTestCases.APIViewTestCase):",
            "    model = Status",
            "    bulk_update_data = {",
            "        \"color\": \"000000\",",
            "    }",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Pizza\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.device\", \"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Oysters\",",
            "            \"color\": \"00ff00\",",
            "            \"content_types\": [\"ipam.ipaddress\", \"ipam.prefix\"],",
            "        },",
            "        {",
            "            \"name\": \"Bad combinations\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "        {",
            "            \"name\": \"Status 1\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "    ]",
            "",
            "",
            "class TagTest(APIViewTestCases.APIViewTestCase):",
            "    model = Tag",
            "    create_data = [",
            "        {\"name\": \"Tag 4\", \"content_types\": [Location._meta.label_lower]},",
            "        {\"name\": \"Tag 5\", \"content_types\": [Location._meta.label_lower]},",
            "        {\"name\": \"Tag 6\", \"content_types\": [Location._meta.label_lower]},",
            "    ]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.update_data = {",
            "            \"name\": \"A new tag name\",",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "        cls.bulk_update_data = {",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()]",
            "        }",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "",
            "        # VLANGroup is an OrganizationalModel, not a PrimaryModel, and therefore does not support tags",
            "        data = {**self.create_data[0], \"content_types\": [VLANGroup._meta.label_lower]}",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "",
            "        tag = Tag.objects.filter(name=data[\"name\"])",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(f\"Invalid content type: {VLANGroup._meta.label_lower}\", response.data[\"content_types\"])",
            "",
            "    def test_create_tags_without_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        data = {",
            "            \"name\": \"Tag 8\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(str(response.data[\"content_types\"][0]), \"This field is required.\")",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.filter(content_types=ContentType.objects.get_for_model(Location)).first()",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        location.tags.add(tag_1)",
            "",
            "        tag_content_types = list(tag_1.content_types.all())",
            "        tag_content_types.remove(ContentType.objects.get_for_model(Location))",
            "",
            "        url = self._get_detail_url(tag_1)",
            "        data = {\"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types]}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            str(response.data[\"content_types\"][0]), \"Unable to remove dcim.location. Dependent objects were found.\"",
            "        )",
            "",
            "    def test_update_tag_content_type_unchanged(self):",
            "        \"\"\"Test updating a tag without changing its content-types.\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag = Tag.objects.exclude(content_types=ContentType.objects.get_for_model(Location)).first()",
            "        tag_content_types = list(tag.content_types.all())",
            "        url = self._get_detail_url(tag)",
            "        data = {\"color\": ColorChoices.COLOR_LIME}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"color\"], ColorChoices.COLOR_LIME)",
            "        self.assertEqual(",
            "            sorted(response.data[\"content_types\"]), sorted([f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types])",
            "        )",
            "",
            "        tag.refresh_from_db()",
            "        self.assertEqual(tag.color, ColorChoices.COLOR_LIME)",
            "        self.assertEqual(list(tag.content_types.all()), tag_content_types)",
            "",
            "",
            "#",
            "# Team",
            "#",
            "",
            "",
            "class TeamTest(APIViewTestCases.APIViewTestCase):",
            "    model = Team",
            "    bulk_update_data = {",
            "        \"address\": \"Carnegie Hall, New York, NY\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Team 1\",",
            "                \"phone\": \"555-0121\",",
            "                \"email\": \"team1@example.com\",",
            "                \"contacts\": [Contact.objects.first().pk, Contact.objects.last().pk],",
            "            },",
            "            {",
            "                \"name\": \"Team 2\",",
            "                \"phone\": \"555-0122\",",
            "                \"email\": \"team2@example.com\",",
            "                \"address\": \"Bowser's Castle, Staten Island, NY\",",
            "            },",
            "            {",
            "                \"name\": \"Team 3\",",
            "                \"phone\": \"555-0123\",",
            "            },",
            "            {",
            "                \"name\": \"Team 4\",",
            "                \"email\": \"team4@example.com\",",
            "                \"address\": \"Rainbow Bridge, Central NJ\",",
            "            },",
            "        ]",
            "",
            "",
            "class WebhookTest(APIViewTestCases.APIViewTestCase):",
            "    model = Webhook",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-4\",",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://example.com/test4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-5\",",
            "            \"type_update\": True,",
            "            \"payload_url\": \"http://example.com/test5\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-6\",",
            "            \"type_delete\": True,",
            "            \"payload_url\": \"http://example.com/test6\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "    ]",
            "    choices_fields = [\"http_method\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.webhooks = (",
            "            Webhook(",
            "                name=\"api-test-1\",",
            "                type_create=True,",
            "                payload_url=\"http://example.com/test1\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-2\",",
            "                type_update=True,",
            "                payload_url=\"http://example.com/test2\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-3\",",
            "                type_delete=True,",
            "                payload_url=\"http://example.com/test3\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for webhook in cls.webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "    def test_create_webhooks_with_diff_content_type_same_url_same_action(self):",
            "        \"\"\"",
            "        Create a new webhook with diffrent content_types, same url and same action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | console port, create, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_diff_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and diff action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, delete, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_common_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and common action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, create, update, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0][\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )",
            "",
            "    def test_patch_webhooks_with_same_content_type_same_url_common_action(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        self.webhooks[2].payload_url = self.webhooks[1].payload_url",
            "        self.webhooks[2].save()",
            "",
            "        data = {\"type_update\": True}",
            "",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            f\"A webhook already exists for update on dcim | device type to URL {self.webhooks[1].payload_url}\",",
            "        )",
            "",
            "    def test_patch_webhooks(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        instance = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=self.webhooks[1].payload_url,",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"type_delete\": True}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"content_types\": [\"dcim.device\"]}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"payload_url\": \"http://example.com/test4\"}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_invalid_webhooks_patch(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        # Test patch payload_url with conflicts",
            "        instance_1 = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=\"http://example.com/test4\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_1.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"payload_url\": \"http://example.com/test2\"}",
            "        response = self.client.patch(self._get_detail_url(instance_1), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            \"A webhook already exists for update on dcim | device type to URL http://example.com/test2\",",
            "        )",
            "",
            "        # Test patch content_types with conflicts",
            "        instance_2 = Webhook.objects.create(",
            "            name=\"api-test-5\",",
            "            type_create=True,",
            "            payload_url=\"http://example.com/test1\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_2.content_types.set([ContentType.objects.get_for_model(Device)])",
            "",
            "        data = {\"content_types\": [\"dcim.devicetype\"]}",
            "        response = self.client.patch(self._get_detail_url(instance_2), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )",
            "",
            "",
            "class RoleTest(APIViewTestCases.APIViewTestCase):",
            "    model = Role",
            "    bulk_update_data = {",
            "        \"color\": \"000000\",",
            "    }",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Role 1\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.device\", \"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Role 2\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Role 3\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"ipam.ipaddress\", \"ipam.vlan\"],",
            "        },",
            "    ]"
        ],
        "afterPatchFile": [
            "from datetime import datetime, timedelta",
            "import tempfile",
            "from unittest import mock, skip",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.files.uploadedfile import SimpleUploadedFile",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils.timezone import make_aware, now",
            "from rest_framework import status",
            "",
            "from nautobot.core.choices import ColorChoices",
            "from nautobot.core.models.fields import slugify_dashes_to_underscores",
            "from nautobot.core.testing import APITestCase, APIViewTestCases",
            "from nautobot.core.testing.utils import disable_warnings",
            "from nautobot.core.utils.lookup import get_route_for_model",
            "from nautobot.core.utils.permissions import get_permission_for_model",
            "from nautobot.dcim.models import (",
            "    Controller,",
            "    Device,",
            "    DeviceType,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            "    Rack,",
            "    RackGroup,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.api.serializers import ConfigContextSerializer, JobResultSerializer",
            "from nautobot.extras.choices import (",
            "    DynamicGroupOperatorChoices,",
            "    JobExecutionType,",
            "    JobResultStatusChoices,",
            "    ObjectChangeActionChoices,",
            "    ObjectChangeEventContextChoices,",
            "    RelationshipTypeChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            "    WebhookHttpMethodChoices,",
            ")",
            "from nautobot.extras.jobs import get_job",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    DynamicGroupMembership,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    FileProxy,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Team,",
            "    Webhook,",
            ")",
            "from nautobot.extras.models.jobs import JobButton, JobHook",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import TaggableClassesQuery",
            "from nautobot.ipam.models import IPAddress, Prefix, VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "",
            "User = get_user_model()",
            "",
            "",
            "class AppTest(APITestCase):",
            "    def test_root(self):",
            "        url = reverse(\"extras-api:api-root\")",
            "        response = self.client.get(f\"{url}?format=api\", **self.header)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "",
            "#",
            "#  Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldTest(APIViewTestCases.APIViewTestCase):",
            "    model = ComputedField",
            "    choices_fields = [\"content_type\"]",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 4\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 5\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 6\",",
            "            \"template\": \"{{ obj.name }}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"label\": \"Computed Field 7\",",
            "            \"template\": \"{{ obj.name }}\",",
            "            \"fallback_value\": \"error\",",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_type\": \"dcim.location\",",
            "        \"key\": \"cf1\",",
            "        \"label\": \"My Computed Field\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_ct = ContentType.objects.get_for_model(Location)",
            "",
            "        ComputedField.objects.create(",
            "            key=\"cf1\",",
            "            label=\"Computed Field One\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=location_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            key=\"cf2\",",
            "            label=\"Computed Field Two\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=location_ct,",
            "        )",
            "        ComputedField.objects.create(",
            "            key=\"cf3\",",
            "            label=\"Computed Field Three\",",
            "            template=\"{{ obj.name }}\",",
            "            fallback_value=\"error\",",
            "            content_type=location_ct,",
            "        )",
            "",
            "        cls.location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "",
            "    def test_computed_field_include(self):",
            "        \"\"\"Test that explicitly including a computed field behaves as expected.\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        url = reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.location.pk})",
            "",
            "        # First get the object without computed fields.",
            "        response = self.client.get(url, **self.header)",
            "        self.assertNotIn(\"computed_fields\", response.json())",
            "",
            "        # Now get it with computed fields.",
            "        params = {\"include\": \"computed_fields\"}",
            "        response = self.client.get(url, data=params, **self.header)",
            "        self.assertIn(\"computed_fields\", response.json())",
            "",
            "",
            "class ConfigContextTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContext",
            "    create_data = [",
            "        {",
            "            \"name\": \"Config Context 4\",",
            "            \"data\": {\"more_foo\": True},",
            "        },",
            "        {",
            "            \"name\": \"Config Context 5\",",
            "            \"data\": {\"more_bar\": False},",
            "        },",
            "        {",
            "            \"name\": \"Config Context 6\",",
            "            \"data\": {\"more_baz\": None},",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContext.objects.create(name=\"Config Context 1\", weight=100, data={\"foo\": 123})",
            "        ConfigContext.objects.create(name=\"Config Context 2\", weight=200, data={\"bar\": 456})",
            "        ConfigContext.objects.create(name=\"Config Context 3\", weight=300, data={\"baz\": 789})",
            "",
            "    def test_render_configcontext_for_object(self):",
            "        \"\"\"",
            "        Test rendering config context data for a device.",
            "        \"\"\"",
            "        manufacturer = Manufacturer.objects.first()",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\")",
            "        devicerole = Role.objects.get_for_model(Device).first()",
            "        devicestatus = Status.objects.get_for_model(Device).first()",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        device = Device.objects.create(",
            "            name=\"Device 1\", device_type=devicetype, role=devicerole, status=devicestatus, location=location",
            "        )",
            "",
            "        # Test default config contexts (created at test setup)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 123)",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        self.assertEqual(rendered_context[\"baz\"], 789)",
            "",
            "        # Test API response as well",
            "        self.add_permissions(\"dcim.view_device\")",
            "        device_url = reverse(\"dcim-api:device-detail\", kwargs={\"pk\": device.pk})",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"], {\"foo\": 123, \"bar\": 456, \"baz\": 789}, response.data)",
            "",
            "        # Add another context specific to the location",
            "        configcontext4 = ConfigContext(name=\"Config Context 4\", data={\"location_data\": \"ABC\"})",
            "        configcontext4.save()",
            "        configcontext4.locations.add(location)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"location_data\"], \"ABC\")",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"location_data\"], \"ABC\", response.data[\"config_context\"])",
            "",
            "        # Override one of the default contexts",
            "        configcontext5 = ConfigContext(name=\"Config Context 5\", weight=2000, data={\"foo\": 999})",
            "        configcontext5.save()",
            "        configcontext5.locations.add(location)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"foo\"], 999)",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"foo\"], 999, response.data[\"config_context\"])",
            "",
            "        # Add a context which does NOT match our device and ensure it does not apply",
            "        location2 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).last()",
            "        configcontext6 = ConfigContext(name=\"Config Context 6\", weight=2000, data={\"bar\": 999})",
            "        configcontext6.save()",
            "        configcontext6.locations.add(location2)",
            "        rendered_context = device.get_config_context()",
            "        self.assertEqual(rendered_context[\"bar\"], 456)",
            "        response = self.client.get(device_url + \"?include=config_context\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"config_context\", response.data)",
            "        self.assertEqual(response.data[\"config_context\"][\"bar\"], 456, response.data[\"config_context\"])",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {",
            "            \"name\": \"Config Context with schema\",",
            "            \"weight\": 100,",
            "            \"data\": {\"foo\": \"bar\"},",
            "            \"config_context_schema\": str(schema.pk),",
            "        }",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(response.data[\"config_context_schema\"][\"url\"], self.absolute_api_url(schema))",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "",
            "        data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 100,",
            "            \"data\": {\"foo\": \"bar\"},",
            "            \"config_context_schema\": str(schema.pk),",
            "        }",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=True)",
            "    def test_with_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is present when feature flag is enabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertIn(\"dynamic_groups\", serializer.fields)",
            "",
            "    @override_settings(CONFIG_CONTEXT_DYNAMIC_GROUPS_ENABLED=False)",
            "    def test_without_dynamic_groups_enabled(self):",
            "        \"\"\"Asserts that `ConfigContextSerializer.dynamic_group` is NOT present the when feature flag is disabled.\"\"\"",
            "        serializer = ConfigContextSerializer()",
            "        self.assertNotIn(\"dynamic_groups\", serializer.fields)",
            "",
            "",
            "class ConfigContextSchemaTest(APIViewTestCases.APIViewTestCase):",
            "    model = ConfigContextSchema",
            "    create_data = [",
            "        {",
            "            \"name\": \"Schema 4\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 5\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 6\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "        {",
            "            \"name\": \"Schema 7\",",
            "            \"data_schema\": {\"type\": \"object\", \"properties\": {\"buz\": {\"type\": \"string\"}}},",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "",
            "class ContentTypeTest(APITestCase):",
            "    \"\"\"",
            "    ContentTypeViewSet does not have permission checks,",
            "    So It should be accessible with or without permission override",
            "    e.g. @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"contenttypes.contenttype\"])",
            "    \"\"\"",
            "",
            "    def test_list_objects_with_or_without_permission(self):",
            "        contenttype_count = ContentType.objects.count()",
            "",
            "        response = self.client.get(reverse(\"extras-api:contenttype-list\"), **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], contenttype_count)",
            "",
            "    def test_get_object_with_or_without_permission(self):",
            "        contenttype = ContentType.objects.first()",
            "",
            "        url = reverse(\"extras-api:contenttype-detail\", kwargs={\"pk\": contenttype.pk})",
            "        self.assertHttpStatus(self.client.get(url, **self.header), status.HTTP_200_OK)",
            "",
            "",
            "#",
            "#  Contacts",
            "#",
            "",
            "",
            "class ContactTest(APIViewTestCases.APIViewTestCase):",
            "    model = Contact",
            "    bulk_update_data = {",
            "        \"address\": \"Carnegie Hall, New York, NY\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Contact 1\",",
            "                \"phone\": \"555-0121\",",
            "                \"email\": \"contact1@example.com\",",
            "                \"teams\": [Team.objects.first().pk, Team.objects.last().pk],",
            "            },",
            "            {",
            "                \"name\": \"Contact 2\",",
            "                \"phone\": \"555-0122\",",
            "                \"email\": \"contact2@example.com\",",
            "                \"address\": \"Bowser's Castle, Staten Island, NY\",",
            "            },",
            "            {",
            "                \"name\": \"Contact 3\",",
            "                \"phone\": \"555-0123\",",
            "            },",
            "            {",
            "                \"name\": \"Contact 4\",",
            "                \"email\": \"contact4@example.com\",",
            "            },",
            "        ]",
            "",
            "",
            "class ContactAssociationTestCase(APIViewTestCases.APIViewTestCase):",
            "    model = ContactAssociation",
            "    create_data = []",
            "    choices_fields = [\"associated_object_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        roles = Role.objects.get_for_model(ContactAssociation)",
            "        statuses = Status.objects.get_for_model(ContactAssociation)",
            "        ip_addresses = IPAddress.objects.all()",
            "        devices = Device.objects.all()",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[0].pk,",
            "            role=roles[0],",
            "            status=statuses[0],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[1].pk,",
            "            role=roles[1],",
            "            status=statuses[1],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[2].pk,",
            "            role=roles[1],",
            "            status=statuses[0],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[3].pk,",
            "            role=roles[2],",
            "            status=statuses[1],",
            "        )",
            "        cls.create_data = [",
            "            {",
            "                \"contact\": Contact.objects.first().pk,",
            "                \"team\": None,",
            "                \"associated_object_type\": \"ipam.ipaddress\",",
            "                \"associated_object_id\": ip_addresses[4].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[0].pk,",
            "            },",
            "            {",
            "                \"contact\": Contact.objects.last().pk,",
            "                \"team\": None,",
            "                \"associated_object_type\": \"dcim.device\",",
            "                \"associated_object_id\": devices[0].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[0].pk,",
            "            },",
            "            {",
            "                \"contact\": None,",
            "                \"team\": Team.objects.first().pk,",
            "                \"associated_object_type\": \"ipam.ipaddress\",",
            "                \"associated_object_id\": ip_addresses[5].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[2].pk,",
            "            },",
            "            {",
            "                \"contact\": None,",
            "                \"team\": Team.objects.last().pk,",
            "                \"associated_object_type\": \"dcim.device\",",
            "                \"associated_object_id\": devices[1].pk,",
            "                \"role\": roles[3].pk,",
            "                \"status\": statuses[0].pk,",
            "            },",
            "        ]",
            "        cls.bulk_update_data = {",
            "            \"role\": roles[4].pk,",
            "            \"status\": statuses[1].pk,",
            "        }",
            "",
            "",
            "class CreatedUpdatedFilterTest(APITestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.location1 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        cls.rackgroup1 = RackGroup.objects.create(location=cls.location1, name=\"Test Rack Group 1\")",
            "        cls.rackrole1 = Role.objects.get_for_model(Rack).first()",
            "        cls.rackstatus1 = Status.objects.get_for_model(Rack).first()",
            "        cls.rack1 = Rack.objects.create(",
            "            location=cls.location1,",
            "            rack_group=cls.rackgroup1,",
            "            role=cls.rackrole1,",
            "            status=cls.rackstatus1,",
            "            name=\"Test Rack 1\",",
            "            u_height=42,",
            "        )",
            "        cls.rack2 = Rack.objects.create(",
            "            location=cls.location1,",
            "            rack_group=cls.rackgroup1,",
            "            role=cls.rackrole1,",
            "            status=cls.rackstatus1,",
            "            name=\"Test Rack 2\",",
            "            u_height=42,",
            "        )",
            "",
            "        # change the created and last_updated of one",
            "        Rack.objects.filter(pk=cls.rack2.pk).update(",
            "            created=make_aware(datetime(2001, 2, 3, 0, 1, 2, 3)),",
            "            last_updated=make_aware(datetime(2001, 2, 3, 1, 2, 3, 4)),",
            "        )",
            "",
            "    def test_get_rack_created(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?created=2001-02-03%2000:01:02.000003\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_created_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "",
            "        response = self.client.get(f\"{url}?created__gte=2001-02-04\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "        response = self.client.get(f\"{url}?created__gte=2001-02-03%2000:01:03\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_created_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "",
            "        response = self.client.get(f\"{url}?created__lte=2001-02-04\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "        response = self.client.get(f\"{url}?created__lte=2001-02-03%2000:01:03\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated=2001-02-03%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "    def test_get_rack_last_updated_gte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__gte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack1.pk))",
            "",
            "    def test_get_rack_last_updated_lte(self):",
            "        self.add_permissions(\"dcim.view_rack\")",
            "        url = reverse(\"dcim-api:rack-list\")",
            "        response = self.client.get(f\"{url}?last_updated__lte=2001-02-04%2001:02:03.000004\", **self.header)",
            "",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"count\"], 1)",
            "        self.assertEqual(response.data[\"results\"][0][\"id\"], str(self.rack2.pk))",
            "",
            "",
            "class CustomFieldTest(APIViewTestCases.APIViewTestCase):",
            "    \"\"\"Tests for the CustomField REST API.\"\"\"",
            "",
            "    model = CustomField",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.location\"],",
            "            \"label\": \"Custom Field 4\",",
            "            \"key\": \"custom_field_4\",",
            "            \"type\": \"date\",",
            "            \"weight\": 100,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.location\", \"dcim.device\"],",
            "            \"label\": \"Custom Field 5\",",
            "            \"key\": \"custom_field_5\",",
            "            \"type\": \"url\",",
            "            \"default\": \"http://example.com\",",
            "            \"weight\": 200,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.location\"],",
            "            \"label\": \"Custom Field 6\",",
            "            \"key\": \"custom_field_6\",",
            "            \"type\": \"select\",",
            "            \"description\": \"A select custom field\",",
            "            \"weight\": 300,",
            "        },",
            "    ]",
            "    update_data = {",
            "        \"content_types\": [\"dcim.location\"],",
            "        \"description\": \"New description\",",
            "        \"label\": \"Non-unique label\",",
            "    }",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"filter_logic\", \"type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_ct = ContentType.objects.get_for_model(Location)",
            "",
            "        custom_fields = (",
            "            CustomField(key=\"cf1\", label=\"Custom Field 1\", type=\"text\"),",
            "            CustomField(key=\"cf2\", label=\"Custom Field 2\", type=\"integer\"),",
            "            CustomField(key=\"cf3\", label=\"Custom Field 3\", type=\"boolean\"),",
            "        )",
            "        for cf in custom_fields:",
            "            cf.validated_save()",
            "            cf.content_types.add(location_ct)",
            "",
            "    def test_create_object_required_fields(self):",
            "        \"\"\"For this API version, `label` and `key` are required fields.\"\"\"",
            "        self.add_permissions(\"extras.add_customfield\")",
            "",
            "        incomplete_data = {",
            "            \"content_types\": [\"dcim.location\"],",
            "            \"type\": \"date\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), incomplete_data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            response.data,",
            "            # Since we are setting blank=True on the key field, we only need to check",
            "            # error messages from the label field.",
            "            {\"label\": [\"This field is required.\"]},",
            "        )",
            "",
            "",
            "class CustomLinkTest(APIViewTestCases.APIViewTestCase):",
            "    model = CustomLink",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"name\": \"api-test-4\",",
            "            \"text\": \"API customlink text 4\",",
            "            \"target_url\": \"http://api-test-4.com/test4\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"name\": \"api-test-5\",",
            "            \"text\": \"API customlink text 5\",",
            "            \"target_url\": \"http://api-test-5.com/test5\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.location\",",
            "            \"name\": \"api-test-6\",",
            "            \"text\": \"API customlink text 6\",",
            "            \"target_url\": \"http://api-test-6.com/test6\",",
            "            \"weight\": 100,",
            "            \"new_window\": False,",
            "        },",
            "    ]",
            "    choices_fields = [\"button_class\", \"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-1\",",
            "            text=\"API customlink text 1\",",
            "            target_url=\"http://api-test-1.com/test1\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-2\",",
            "            text=\"API customlink text 2\",",
            "            target_url=\"http://api-test-2.com/test2\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "        CustomLink.objects.create(",
            "            content_type=obj_type,",
            "            name=\"api-test-3\",",
            "            text=\"API customlink text 3\",",
            "            target_url=\"http://api-test-3.com/test3\",",
            "            weight=100,",
            "            new_window=False,",
            "        )",
            "",
            "",
            "class DynamicGroupTestMixin:",
            "    \"\"\"Mixin for Dynamic Group test cases to re-use the same set of common fixtures.\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create the objects required for devices.",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        location_status = Status.objects.get_for_model(Location).first()",
            "        locations = (",
            "            Location.objects.create(name=\"Location 1\", location_type=location_type, status=location_status),",
            "            Location.objects.create(name=\"Location 2\", location_type=location_type, status=location_status),",
            "            Location.objects.create(name=\"Location 3\", location_type=location_type, status=location_status),",
            "        )",
            "",
            "        manufacturer = Manufacturer.objects.first()",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "        )",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        statuses = Status.objects.get_for_model(Device)",
            "        Device.objects.create(",
            "            name=\"device-location-1\",",
            "            status=statuses[0],",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=locations[0],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-location-2\",",
            "            status=statuses[0],",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=locations[1],",
            "        )",
            "        Device.objects.create(",
            "            name=\"device-location-3\",",
            "            status=statuses[1],",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=locations[2],",
            "        )",
            "",
            "        # Then the DynamicGroups.",
            "        cls.content_type = ContentType.objects.get_for_model(Device)",
            "        cls.groups = [",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 1\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [statuses[0].name]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 2\",",
            "                content_type=cls.content_type,",
            "                filter={\"status\": [statuses[0].name]},",
            "            ),",
            "            DynamicGroup.objects.create(",
            "                name=\"API DynamicGroup 3\",",
            "                content_type=cls.content_type,",
            "                filter={\"location\": [f\"{locations[2].name}\"]},",
            "            ),",
            "        ]",
            "",
            "",
            "class DynamicGroupTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroup",
            "    choices_fields = [\"content_type\"]",
            "    create_data = [",
            "        {",
            "            \"name\": \"API DynamicGroup 4\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"location\": [\"Location 1\"]},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 5\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"has_interfaces\": False},",
            "        },",
            "        {",
            "            \"name\": \"API DynamicGroup 6\",",
            "            \"content_type\": \"dcim.device\",",
            "            \"filter\": {\"location\": [\"Location 2\"]},",
            "        },",
            "    ]",
            "",
            "    def test_get_members(self):",
            "        \"\"\"Test that the `/members/` API endpoint returns what is expected.\"\"\"",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        instance = self.groups[0]",
            "        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))",
            "        member_count = instance.members.count()",
            "        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(member_count, len(response.json()[\"results\"]))",
            "",
            "    def test_get_members_with_constrained_permission(self):",
            "        \"\"\"Test that the `/members/` API endpoint enforces permissions on the member model.\"\"\"",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        instance = self.groups[0]",
            "        obj1 = instance.members.first()",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk__in\": [obj1.pk]},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(instance.content_type)",
            "",
            "        url = reverse(\"extras-api:dynamicgroup-members\", kwargs={\"pk\": instance.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(len(response.json()[\"results\"]), 1)",
            "        self.assertEqual(response.json()[\"results\"][0][\"id\"], str(obj1.pk))",
            "",
            "",
            "class DynamicGroupMembershipTest(DynamicGroupTestMixin, APIViewTestCases.APIViewTestCase):",
            "    model = DynamicGroupMembership",
            "    choices_fields = [\"operator\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super().setUpTestData()",
            "",
            "        parent = DynamicGroup.objects.create(",
            "            name=\"parent\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        parent2 = DynamicGroup.objects.create(",
            "            name=\"parent2\",",
            "            content_type=cls.content_type,",
            "            filter={},",
            "        )",
            "        group1, group2, group3 = cls.groups",
            "",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group1,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "            weight=10,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group2,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "            weight=20,",
            "        )",
            "        DynamicGroupMembership.objects.create(",
            "            parent_group=parent,",
            "            group=group3,",
            "            operator=DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "            weight=30,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group1.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_INTERSECTION,",
            "                \"weight\": 10,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group2.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_UNION,",
            "                \"weight\": 20,",
            "            },",
            "            {",
            "                \"parent_group\": parent2.pk,",
            "                \"group\": group3.pk,",
            "                \"operator\": DynamicGroupOperatorChoices.OPERATOR_DIFFERENCE,",
            "                \"weight\": 30,",
            "            },",
            "        ]",
            "",
            "    # TODO: Either improve test base or or write a more specific test for this model.",
            "    @skip(\"DynamicGroupMembership has a `name` property but it's the Group name and not exposed on the API\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"DynamicGroupMembership has a `name` property but it's the Group name and not exposed on the API\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class ExportTemplateTest(APIViewTestCases.APIViewTestCase):",
            "    model = ExportTemplate",
            "    create_data = [",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 4\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 5\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "        {",
            "            \"content_type\": \"dcim.device\",",
            "            \"name\": \"Test Export Template 6\",",
            "            \"template_code\": \"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        },",
            "    ]",
            "    bulk_update_data = {",
            "        \"description\": \"New description\",",
            "    }",
            "    choices_fields = [\"owner_content_type\", \"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Device)",
            "",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 1\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 2\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "        ExportTemplate.objects.create(",
            "            content_type=ct,",
            "            name=\"Export Template 3\",",
            "            template_code=\"{% for obj in queryset %}{{ obj.name }}\\n{% endfor %}\",",
            "        )",
            "",
            "",
            "class ExternalIntegrationTest(APIViewTestCases.APIViewTestCase):",
            "    model = ExternalIntegration",
            "    create_data = [",
            "        {",
            "            \"name\": \"Test External Integration 1\",",
            "            \"remote_url\": \"ssh://example.com/test1/\",",
            "            \"verify_ssl\": False,",
            "            \"timeout\": 5,",
            "            \"extra_config\": \"{'foo': 'bar'}\",",
            "            \"http_method\": WebhookHttpMethodChoices.METHOD_DELETE,",
            "            \"headers\": \"{'header': 'fake header'}\",",
            "            \"ca_file_path\": \"/this/is/a/file/path\",",
            "        },",
            "        {",
            "            \"name\": \"Test External Integration 2\",",
            "            \"remote_url\": \"http://example.com/test2/\",",
            "            \"http_method\": WebhookHttpMethodChoices.METHOD_POST,",
            "        },",
            "        {",
            "            \"name\": \"Test External Integration 3\",",
            "            \"remote_url\": \"https://example.com/test3/\",",
            "            \"verify_ssl\": True,",
            "            \"timeout\": 30,",
            "            \"extra_config\": \"{'foo': ['bat', 'baz']}\",",
            "            \"headers\": \"{'new_header': 'fake header'}\",",
            "            \"ca_file_path\": \"/this/is/a/new/file/path\",",
            "        },",
            "    ]",
            "    bulk_update_data = {\"timeout\": 10, \"verify_ssl\": True, \"extra_config\": r\"{}\"}",
            "    choices_fields = [\"http_method\"]",
            "",
            "",
            "class FileProxyTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = FileProxy",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        job = Job.objects.first()",
            "        job_results = (",
            "            JobResult.objects.create(",
            "                job_model=job,",
            "                name=job.class_path,",
            "                date_done=now(),",
            "                status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            ),",
            "            JobResult.objects.create(",
            "                job_model=job,",
            "                name=job.class_path,",
            "                date_done=now(),",
            "                status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            ),",
            "            JobResult.objects.create(",
            "                job_model=job,",
            "                name=job.class_path,",
            "                date_done=now(),",
            "                status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            ),",
            "        )",
            "        cls.file_proxies = []",
            "        for i, job_result in enumerate(job_results):",
            "            file = SimpleUploadedFile(name=f\"Output {i}.txt\", content=f\"Content {i}\\n\".encode(\"utf-8\"))",
            "            file_proxy = FileProxy.objects.create(name=file.name, file=file, job_result=job_result)",
            "            cls.file_proxies.append(file_proxy)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_download_file_without_permission(self):",
            "        \"\"\"Test `download` action without permission.\"\"\"",
            "        url = reverse(\"extras-api:fileproxy-download\", kwargs={\"pk\": self.file_proxies[0].pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_download_file_with_permission(self):",
            "        \"\"\"Test `download` action with permission.\"\"\"",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\", constraints={\"pk\": self.file_proxies[0].pk}, actions=[\"view\"]",
            "        )",
            "        obj_perm.validated_save()",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "        obj_perm.users.add(self.user)",
            "",
            "        # FileProxy permitted by permission",
            "        url = reverse(\"extras-api:fileproxy-download\", kwargs={\"pk\": self.file_proxies[0].pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        content = b\"\".join(data for data in response)",
            "        self.assertEqual(content.decode(\"utf-8\"), \"Content 0\\n\")",
            "",
            "        # FileProxy not permitted by permission",
            "        url = reverse(\"extras-api:fileproxy-download\", kwargs={\"pk\": self.file_proxies[1].pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "",
            "class GitRepositoryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GitRepository",
            "    bulk_update_data = {",
            "        \"branch\": \"develop\",",
            "    }",
            "    choices_fields = [\"provided_contents\"]",
            "    slug_source = \"name\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\"),",
            "        )",
            "",
            "        cls.repos = (",
            "            GitRepository(",
            "                name=\"Repo 1\",",
            "                slug=\"repo_1\",",
            "                remote_url=\"https://example.com/repo1.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(",
            "                name=\"Repo 2\",",
            "                slug=\"repo_2\",",
            "                remote_url=\"https://example.com/repo2.git\",",
            "                secrets_group=secrets_groups[0],",
            "            ),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo_3\", remote_url=\"https://example.com/repo3.git\"),",
            "        )",
            "        for repo in cls.repos:",
            "            repo.save()",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"New Git Repository 1\",",
            "                \"slug\": \"new_git_repository_1\",",
            "                \"remote_url\": \"https://example.com/newrepo1.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "                \"provided_contents\": [\"extras.configcontext\", \"extras.exporttemplate\"],",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 2\",",
            "                \"slug\": \"new_git_repository_2\",",
            "                \"remote_url\": \"https://example.com/newrepo2.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 3\",",
            "                \"slug\": \"new_git_repository_3\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "            {",
            "                \"name\": \"New Git Repository 4\",",
            "                \"remote_url\": \"https://example.com/newrepo3.git\",",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "            },",
            "        ]",
            "",
            "        # slug is enforced non-editable in clean because we want it to be providable by the user on creation",
            "        # but not modified afterward",
            "        cls.update_data = {",
            "            \"name\": \"A Different Repo Name\",",
            "            \"remote_url\": \"https://example.com/fake.git\",",
            "        }",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_no_celery_worker(self, mock_get_worker_count):",
            "        \"\"\"Git sync cannot be triggered if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_nonexistent_repo(self, mock_get_worker_count):",
            "        \"\"\"Git sync request handles case of a nonexistent repository.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": \"11111111-1111-1111-1111-111111111111\"})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_git_sync_without_permissions(self, mock_get_worker_count):",
            "        \"\"\"Git sync request verifies user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_git_sync_with_permissions(self, _):",
            "        \"\"\"Git sync request can be submitted successfully.\"\"\"",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = reverse(\"extras-api:gitrepository-sync\", kwargs={\"pk\": self.repos[0].id})",
            "        response = self.client.post(url, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_create_with_app_provided_contents(self):",
            "        \"\"\"Test that `provided_contents` published by an App works.\"\"\"",
            "        self.add_permissions(\"extras.add_gitrepository\")",
            "        self.add_permissions(\"extras.change_gitrepository\")",
            "        url = self._get_list_url()",
            "        data = {",
            "            \"name\": \"app_test\",",
            "            \"slug\": \"app_test\",",
            "            \"remote_url\": \"https://localhost/app-test\",",
            "            \"provided_contents\": [\"example_app.textfile\"],",
            "        }",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        self.assertEqual(list(response.data[\"provided_contents\"]), data[\"provided_contents\"])",
            "",
            "",
            "class GraphQLQueryTest(APIViewTestCases.APIViewTestCase):",
            "    model = GraphQLQuery",
            "    create_data = [",
            "        {",
            "            \"name\": \"graphql-query-4\",",
            "            \"query\": \"{ query: locations {name} }\",",
            "        },",
            "        {",
            "            \"name\": \"graphql-query-5\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, role { name } } }',",
            "        },",
            "        {",
            "            \"name\": \"Graphql Query 6\",",
            "            \"query\": '{ devices(role: \"edge\") { id, name, role { name } } }',",
            "        },",
            "    ]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                query=\"{ locations {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, role { name } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "        )",
            "",
            "        for query in cls.graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "    def test_run_saved_query(self):",
            "        \"\"\"Exercise the /run/ API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.add_graphqlquery\")",
            "        self.add_permissions(\"extras.change_graphqlquery\")",
            "        self.add_permissions(\"extras.view_graphqlquery\")",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[0].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"locations\": []}}, response.data)",
            "",
            "        url = reverse(\"extras-api:graphqlquery-run\", kwargs={\"pk\": self.graphqlqueries[2].pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual({\"data\": {\"devices\": []}}, response.data)",
            "",
            "",
            "# TODO(Glenn): Standardize to APIViewTestCase (needs create & update tests)",
            "class ImageAttachmentTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = ImageAttachment",
            "    choices_fields = [\"content_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        ct = ContentType.objects.get_for_model(Location)",
            "",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=location.pk,",
            "            name=\"Image Attachment 1\",",
            "            image=\"http://example.com/image1.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=location.pk,",
            "            name=\"Image Attachment 2\",",
            "            image=\"http://example.com/image2.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "        ImageAttachment.objects.create(",
            "            content_type=ct,",
            "            object_id=location.pk,",
            "            name=\"Image Attachment 3\",",
            "            image=\"http://example.com/image3.png\",",
            "            image_height=100,",
            "            image_width=100,",
            "        )",
            "",
            "    # TODO: Unskip after resolving #2908, #2909",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class JobTest(",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.UpdateObjectViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "    APIViewTestCases.NotesURLViewTestCase,",
            "):",
            "    \"\"\"Test cases for the Jobs REST API.\"\"\"",
            "",
            "    model = Job",
            "    choices_fields = None",
            "    update_data = {",
            "        # source, module_name, job_class_name, installed are NOT editable",
            "        \"grouping_override\": True,",
            "        \"grouping\": \"Overridden grouping\",",
            "        \"name_override\": True,",
            "        \"name\": \"Overridden name\",",
            "        \"description_override\": True,",
            "        \"description\": \"This is an overridden description.\",",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"dryrun_default_override\": True,",
            "        \"dryrun_default\": True,",
            "        \"hidden_override\": True,",
            "        \"hidden\": True,",
            "        \"soft_time_limit_override\": True,",
            "        \"soft_time_limit\": 350.1,",
            "        \"time_limit_override\": True,",
            "        \"time_limit\": 650,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "        \"task_queues\": [\"default\", \"priority\"],",
            "        \"task_queues_override\": True,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": True,",
            "        \"approval_required_override\": True,",
            "        \"approval_required\": True,",
            "        \"has_sensitive_variables\": False,",
            "        \"has_sensitive_variables_override\": True,",
            "    }",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.default_job_name = \"api_test_job.APITestJob\"",
            "        self.job_class = get_job(self.default_job_name)",
            "        self.assertIsNotNone(self.job_class)",
            "        self.job_model = Job.objects.get_for_class_path(self.default_job_name)",
            "        self.job_model.enabled = True",
            "        self.job_model.validated_save()",
            "",
            "    run_success_response_status = status.HTTP_201_CREATED",
            "",
            "    def get_run_url(self, class_path=\"api_test_job.APITestJob\"):",
            "        job_model = Job.objects.get_for_class_path(class_path)",
            "        return reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "",
            "    def test_get_job_variables(self):",
            "        \"\"\"Test the job/<pk>/variables API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.view_job\")",
            "        route = get_route_for_model(self.model, \"variables\", api=True)",
            "        response = self.client.get(reverse(route, kwargs={\"pk\": self.job_model.pk}), **self.header)",
            "        self.assertEqual(4, len(response.data))  # 4 variables, in order",
            "        self.assertEqual(response.data[0], {\"name\": \"var1\", \"type\": \"StringVar\", \"required\": True})",
            "        self.assertEqual(response.data[1], {\"name\": \"var2\", \"type\": \"IntegerVar\", \"required\": True})",
            "        self.assertEqual(response.data[2], {\"name\": \"var3\", \"type\": \"BooleanVar\", \"required\": False})",
            "        self.assertEqual(",
            "            response.data[3],",
            "            {\"name\": \"var4\", \"type\": \"ObjectVar\", \"required\": True, \"model\": \"extras.role\"},",
            "        )",
            "",
            "    def test_get_job_variables_by_name(self):",
            "        \"\"\"Test the job/<name>/variables API endpoint.\"\"\"",
            "        self.add_permissions(\"extras.view_job\")",
            "        route = get_route_for_model(self.model, \"variables\", api=True)",
            "        response = self.client.get(reverse(route, kwargs={\"name\": self.job_model.name}), **self.header)",
            "        self.assertEqual(4, len(response.data))  # 4 variables, in order",
            "        self.assertEqual(response.data[0], {\"name\": \"var1\", \"type\": \"StringVar\", \"required\": True})",
            "        self.assertEqual(response.data[1], {\"name\": \"var2\", \"type\": \"IntegerVar\", \"required\": True})",
            "        self.assertEqual(response.data[2], {\"name\": \"var3\", \"type\": \"BooleanVar\", \"required\": False})",
            "        self.assertEqual(",
            "            response.data[3],",
            "            {\"name\": \"var4\", \"type\": \"ObjectVar\", \"required\": True, \"model\": \"extras.role\"},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_job_with_sensitive_variables_set_approval_required_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"api_test_job.APITestJob\")",
            "        job_model.has_sensitive_variables = True",
            "        job_model.has_sensitive_variables_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"approval_required\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_update_approval_required_job_set_has_sensitive_variables_to_true(self):",
            "        job_model = Job.objects.get_for_class_path(\"api_test_job.APITestJob\")",
            "        job_model.approval_required = True",
            "        job_model.approval_required_override = True",
            "        job_model.validated_save()",
            "",
            "        url = self._get_detail_url(job_model)",
            "        data = {",
            "            \"has_sensitive_variables\": True,",
            "            \"has_sensitive_variables_override\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_job\")",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"has_sensitive_variables\"][0],",
            "            \"A job with sensitive variables cannot also be marked as requiring approval\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_run_job_anonymous_not_permitted(self):",
            "        \"\"\"The run_job endpoint should NOT allow anonymous users to submit jobs.\"\"\"",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_without_permission(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces user permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_permissions(self, mock_get_worker_count):",
            "        \"\"\"The run_job endpoint should enforce object-level permissions.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"module_name__in\": [\"pass\", \"fail\"]},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try post to unpermitted job",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_404_NOT_FOUND)",
            "",
            "        # Try post to permitted job",
            "        job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"pass.TestPass\")",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_enabled(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.enabled flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get_for_class_path(self.default_job_name)",
            "        job_model.enabled = False",
            "        job_model.save()",
            "",
            "        url = self.get_run_url()",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_not_installed(self, mock_get_worker_count):",
            "        \"\"\"Job run request enforces the Job.installed flag.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job(",
            "            module_name=\"uninstalled_module\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Uninstalled Module\",",
            "            name=\"No such job\",",
            "            installed=False,",
            "            enabled=True,",
            "        )",
            "        job_model.validated_save()",
            "",
            "        url = self.get_run_url(\"uninstalled_module.NoSuchJob\")",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, {}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_405_METHOD_NOT_ALLOWED)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_no_worker(self, mock_get_worker_count):",
            "        \"\"\"Job run cannot be requested if Celery is not running.\"\"\"",
            "        mock_get_worker_count.return_value = 0",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_503_SERVICE_UNAVAILABLE)",
            "        self.assertEqual(",
            "            response.data[\"detail\"], \"Unable to process request: No celery workers running on queue default.\"",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their primary keys.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            \"schedule\": {",
            "                \"name\": \"test\",",
            "                \"interval\": \"future\",",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertEqual(schedule.kwargs[\"var4\"], str(device_role.pk))",
            "",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"url\"], self.absolute_api_url(schedule))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"name\"], schedule.name)",
            "        # Python < 3.11 doesn't understand the datetime string \"2023-04-27T18:33:16.017865Z\",",
            "        # but it *does* understand the string \"2023-04-27T18:33:17.330836+00:00\"",
            "        self.assertEqual(",
            "            datetime.fromisoformat(response.data[\"scheduled_job\"][\"start_time\"].replace(\"Z\", \"+00:00\")),",
            "            schedule.start_time,",
            "        )",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_object_var_no_schedule(self, mock_get_worker_count):",
            "        \"\"\"",
            "        Run a job with `approval_required` without providing a schedule.",
            "",
            "        Assert an immediate schedule that enforces it.",
            "        \"\"\"",
            "        # Set approval_required=True",
            "        self.job_model.approval_required = True",
            "        self.job_model.save()",
            "",
            "        # Do the stuff.",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": device_role.pk,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "            # schedule is omitted",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        # Assert that a JobResult for this job was NOT created.",
            "        self.assertFalse(JobResult.objects.filter(name=self.job_model.name).exists())",
            "",
            "        # Assert that we have an immediate ScheduledJob and that it matches the job_model.",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertIsNotNone(schedule)",
            "        self.assertEqual(schedule.interval, JobExecutionType.TYPE_IMMEDIATELY)",
            "        self.assertEqual(schedule.approval_required, self.job_model.approval_required)",
            "        self.assertEqual(schedule.kwargs[\"var4\"], str(device_role.pk))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    @mock.patch(\"nautobot.extras.models.jobs.JobResult.enqueue_job\")",
            "    def test_run_job_object_var_lookup(self, mock_enqueue_job, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        mock_enqueue_job.return_value = None",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": {\"name\": device_role.name},",
            "        }",
            "",
            "        # This handles things like ObjectVar fields looked up by non-UUID",
            "        # Jobs are executed with deserialized data",
            "        deserialized_data = self.job_class.deserialize_data(job_data)",
            "",
            "        self.assertEqual(",
            "            deserialized_data,",
            "            {\"var1\": \"FooBar\", \"var2\": 123, \"var3\": False, \"var4\": device_role},",
            "        )",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, {\"data\": job_data}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        # Ensure the enqueue_job args deserialize to the same as originally inputted",
            "        expected_enqueue_job_args = (self.job_model, self.user)",
            "        expected_enqueue_job_kwargs = {",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "            **self.job_class.serialize_data(deserialized_data),",
            "        }",
            "        mock_enqueue_job.assert_called_with(*expected_enqueue_job_args, **expected_enqueue_job_kwargs)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_response_job_result(self, mock_get_worker_count):",
            "        \"\"\"Test job run response contains nested job result.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var4\": {\"name\": device_role.name},",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, {\"data\": job_data}, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.get(name=self.job_model.name)",
            "",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertIsNone(response.data[\"scheduled_job\"])",
            "        data_job_result = response.data[\"job_result\"]",
            "        expected_data_job_result = JobResultSerializer(job_result, context={\"request\": response.wsgi_request}).data",
            "        self.assertEqual(data_job_result, expected_data_job_result)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_commit(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"field_order.TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"field_order.TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_only(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"field_order.TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"field_order.TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_file_data_schedule(self, mock_get_worker_count):",
            "        \"\"\"Job run requests can reference objects by their attributes.\"\"\"",
            "",
            "        test_file = SimpleUploadedFile(name=\"test_file.txt\", content=b\"I am content.\\n\")",
            "",
            "        job_model = Job.objects.get_for_class_path(\"field_order.TestFieldOrder\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var2\": \"Ground control to Major Tom\",",
            "            \"var23\": \"Commencing countdown, engines on\",",
            "            \"var1\": test_file,",
            "            \"_schedule_start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "            \"_schedule_interval\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        url = self.get_run_url(class_path=\"field_order.TestFieldOrder\")",
            "        response = self.client.post(url, data=job_data, **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future(self, mock_get_worker_count):",
            "        \"\"\"In addition to the base test case provided by JobAPIRunTestMixin, also verify the JSON response data.\"\"\"",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"url\"], self.absolute_api_url(schedule))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"name\"], schedule.name)",
            "        # Python < 3.11 doesn't understand the datetime string \"2023-04-27T18:33:16.017865Z\",",
            "        # but it *does* understand the string \"2023-04-27T18:33:17.330836+00:00\"",
            "        self.assertEqual(",
            "            datetime.fromisoformat(response.data[\"scheduled_job\"][\"start_time\"].replace(\"Z\", \"+00:00\")),",
            "            schedule.start_time,",
            "        )",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_for_future(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        # url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"schedule\"][\"interval\"][0],",
            "            \"Unable to schedule job: Job may have sensitive input variables\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_a_job_with_sensitive_variables_and_requires_approval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_model = Job.objects.get(job_class_name=\"ExampleJob\")",
            "        job_model.enabled = True",
            "        job_model.has_sensitive_variables = True",
            "        job_model.approval_required = True",
            "        job_model.save()",
            "",
            "        url = reverse(\"extras-api:job-run\", kwargs={\"pk\": job_model.pk})",
            "        data = {",
            "            \"data\": {},",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0],",
            "            \"Unable to run or schedule job: \"",
            "            \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "            \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_a_job_with_sensitive_variables_immediately(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"interval\": \"immediately\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "        self.job_model.has_sensitive_variables = True",
            "        self.job_model.has_sensitive_variables_override = True",
            "        self.job_model.validated_save()",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        job_result = JobResult.objects.get(name=self.job_model.name)",
            "        self.assertEqual(job_result.task_kwargs, {})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_future_past(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() - timedelta(minutes=1)),",
            "                \"interval\": \"future\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\")",
            "    def test_run_job_interval(self, mock_get_worker_count):",
            "        mock_get_worker_count.return_value = 1",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"schedule\": {",
            "                \"start_time\": str(datetime.now() + timedelta(minutes=1)),",
            "                \"interval\": \"hourly\",",
            "                \"name\": \"test\",",
            "            },",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "        schedule = ScheduledJob.objects.last()",
            "",
            "        self.assertIn(\"scheduled_job\", response.data)",
            "        self.assertIn(\"job_result\", response.data)",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"id\"], str(schedule.pk))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"url\"], self.absolute_api_url(schedule))",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"name\"], schedule.name)",
            "        # Python < 3.11 doesn't understand the datetime string \"2023-04-27T18:33:16.017865Z\",",
            "        # but it *does* understand the string \"2023-04-27T18:33:17.330836+00:00\"",
            "        self.assertEqual(",
            "            datetime.fromisoformat(response.data[\"scheduled_job\"][\"start_time\"].replace(\"Z\", \"+00:00\")),",
            "            schedule.start_time,",
            "        )",
            "        self.assertEqual(response.data[\"scheduled_job\"][\"interval\"], schedule.interval)",
            "        self.assertIsNone(response.data[\"job_result\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"data\": \"invalid\",",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": [\"Job data needs to be a dict\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_wrong_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var2\": 123,",
            "            \"var3\": False,",
            "            \"var5\": \"wrong\",",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(response.data, {\"errors\": {\"var5\": [\"Job data contained an unknown property\"]}})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_missing_data(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        job_data = {",
            "            \"var1\": \"FooBar\",",
            "            \"var3\": False,",
            "        }",
            "",
            "        data = {",
            "            \"data\": job_data,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data, {\"errors\": {\"var2\": [\"This field is required.\"], \"var4\": [\"This field is required.\"]}}",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_job_with_invalid_task_queue(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"task_queue\": \"invalid\",",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data,",
            "            {\"task_queue\": ['\"invalid\" is not a valid choice.']},",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_valid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        d = Role.objects.get_for_model(Device).first()",
            "        data = {",
            "            \"data\": {\"var1\": \"x\", \"var2\": 1, \"var3\": False, \"var4\": d.pk},",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        url = self.get_run_url()",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    @mock.patch(\"nautobot.extras.api.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_default_queue_with_empty_job_model_task_queues(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        data = {",
            "            \"task_queue\": settings.CELERY_TASK_DEFAULT_QUEUE,",
            "        }",
            "",
            "        job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        job_model.enabled = True",
            "        job_model.validated_save()",
            "        url = self.get_run_url(\"pass.TestPass\")",
            "        response = self.client.post(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, self.run_success_response_status)",
            "",
            "    # TODO: Either improve test base or or write a more specific test for this model.",
            "    @skip(\"Job has a `name` property but grouping is also used to sort Jobs\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"Job has a `name` property but grouping is also used to sort Jobs\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class JobHookTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobHook",
            "    choices_fields = []",
            "    update_data = {",
            "        \"name\": \"Overridden name\",",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "    bulk_update_data = {",
            "        \"enabled\": False,",
            "        \"type_create\": True,",
            "        \"type_update\": True,",
            "        \"type_delete\": False,",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobHook4\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook5\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverChange\").pk,",
            "                \"enabled\": False,",
            "            },",
            "            {",
            "                \"name\": \"JobHook6\",",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"type_delete\": True,",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverFail\").pk,",
            "                \"enabled\": False,",
            "            },",
            "        ]",
            "        cls.job_hooks = (",
            "            JobHook(",
            "                name=\"JobHook1\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverLog\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook2\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverChange\"),",
            "                type_delete=True,",
            "            ),",
            "            JobHook(",
            "                name=\"JobHook3\",",
            "                type_create=True,",
            "                job=Job.objects.get(job_class_name=\"TestJobHookReceiverFail\"),",
            "                type_delete=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for job_hook in cls.job_hooks:",
            "            job_hook.save()",
            "            job_hook.content_types.set([obj_type])",
            "",
            "    def test_validate_post(self):",
            "        \"\"\"POST a job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"name\": \"JobHook4\",",
            "            \"content_types\": [\"dcim.devicetype\"],",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_create\": False,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_jobhook\")",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "    def test_validate_patch(self):",
            "        \"\"\"PATCH an existing job hook with values that duplicate another job hook\"\"\"",
            "",
            "        data = {",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobHookReceiverLog\").pk,",
            "            \"type_delete\": True,",
            "        }",
            "",
            "        self.add_permissions(\"extras.change_jobhook\")",
            "        job_hook2 = JobHook.objects.get(name=\"JobHook2\")",
            "        response = self.client.patch(self._get_detail_url(job_hook2), data, format=\"json\", **self.header)",
            "        self.assertContains(",
            "            response,",
            "            \"A job hook already exists for delete on dcim | device type to job TestJobHookReceiverLog\",",
            "            status_code=400,",
            "        )",
            "",
            "",
            "class JobButtonTest(APIViewTestCases.APIViewTestCase):",
            "    model = JobButton",
            "    choices_fields = [\"button_class\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"JobButton4\",",
            "                \"text\": \"JobButton4\",",
            "                \"content_types\": [\"dcim.location\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\").pk,",
            "            },",
            "            {",
            "                \"name\": \"JobButton5\",",
            "                \"text\": \"JobButton5\",",
            "                \"content_types\": [\"circuits.circuit\"],",
            "                \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            },",
            "        ]",
            "        location_type = ContentType.objects.get_for_model(Location)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        location_jb = JobButton(",
            "            name=\"api-test-location\",",
            "            text=\"API job button location text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        location_jb.save()",
            "        location_jb.content_types.set([location_type])",
            "",
            "        device_jb = JobButton.objects.create(",
            "            name=\"api-test-device\",",
            "            text=\"API job button device text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        device_jb.save()",
            "        device_jb.content_types.set([device_type])",
            "",
            "        complex_jb = JobButton.objects.create(",
            "            name=\"api-test-complex\",",
            "            text=\"API job button complex text\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            weight=100,",
            "            confirmation=True,",
            "        )",
            "        complex_jb.save()",
            "        complex_jb.content_types.set([device_type, location_type])",
            "",
            "",
            "class JobResultTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "    APIViewTestCases.DeleteObjectViewTestCase,",
            "):",
            "    model = JobResult",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        jobs = Job.objects.all()[:2]",
            "",
            "        JobResult.objects.create(",
            "            job_model=jobs[0],",
            "            name=jobs[0].class_path,",
            "            date_done=now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            task_kwargs={},",
            "            scheduled_job=None,",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=None,",
            "            name=\"deleted_module.deleted_job\",",
            "            date_done=now(),",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_SUCCESS,",
            "            task_kwargs={\"repository_pk\": uuid.uuid4()},",
            "            scheduled_job=None,",
            "        )",
            "        JobResult.objects.create(",
            "            job_model=jobs[1],",
            "            name=jobs[1].class_path,",
            "            date_done=None,",
            "            user=None,",
            "            status=JobResultStatusChoices.STATUS_PENDING,",
            "            task_kwargs={\"data\": {\"device\": uuid.uuid4(), \"multichoices\": [\"red\", \"green\"], \"checkbox\": False}},",
            "            scheduled_job=None,",
            "        )",
            "",
            "",
            "class JobLogEntryTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobLogEntry",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.job_result = JobResult.objects.create(name=\"test\")",
            "",
            "        for log_level in (\"debug\", \"info\", \"success\", \"warning\"):",
            "            JobLogEntry.objects.create(",
            "                log_level=log_level,",
            "                grouping=\"run\",",
            "                job_result=cls.job_result,",
            "                message=f\"I am a {log_level} log.\",",
            "            )",
            "",
            "    def test_list_job_logs_from_job_results_detail(self):",
            "        \"\"\"Test `logs` endpoint from `JobResult` detail.\"\"\"",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "        url = reverse(\"extras-api:jobresult-logs\", kwargs={\"pk\": self.job_result.pk})",
            "        response = self.client.get(url, **self.header)",
            "        self.assertEqual(len(response.json()), JobLogEntry.objects.count())",
            "",
            "",
            "class ScheduledJobTest(",
            "    APIViewTestCases.GetObjectViewTestCase,",
            "    APIViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    choices_fields = []",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"pass.TestPass\",",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"pass.TestPass\",",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"pass.TestPass\",",
            "            job_model=job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "    # TODO: Unskip after resolving #2908, #2909",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_ascending_ordered(self):",
            "        pass",
            "",
            "    @skip(\"DRF's built-in OrderingFilter triggering natural key attribute error in our base\")",
            "    def test_list_objects_descending_ordered(self):",
            "        pass",
            "",
            "",
            "class JobApprovalTest(APITestCase):",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.additional_user = User.objects.create(username=\"user1\", is_active=True)",
            "        cls.job_model = Job.objects.get_for_class_path(\"pass.TestPass\")",
            "        cls.job_model.enabled = True",
            "        cls.job_model.save()",
            "        cls.scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test pass\",",
            "            task=\"pass.TestPass\",",
            "            job_model=cls.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=cls.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        cls.dryrun_job_model = Job.objects.get_for_class_path(\"dry_run.TestDryRun\")",
            "        cls.dryrun_job_model.enabled = True",
            "        cls.dryrun_job_model.save()",
            "        cls.dryrun_scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test dryrun\",",
            "            task=\"dry_run.TestDryRun\",",
            "            job_model=cls.dryrun_job_model,",
            "            kwargs={\"value\": 1},",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=cls.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_anonymous(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_without_change_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_same_user(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_approve_job_in_past_force(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.change_scheduledjob\")",
            "        scheduled_job = ScheduledJob.objects.create(",
            "            name=\"test\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_FUTURE,",
            "            one_off=True,",
            "            user=self.additional_user,",
            "            approval_required=True,",
            "            start_time=now(),",
            "        )",
            "        url = reverse(\"extras-api:scheduledjob-approve\", kwargs={\"pk\": scheduled_job.pk})",
            "        response = self.client.post(url + \"?force=true\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_approve_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job_without_delete_scheduledjob_permission(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_deny_job(self):",
            "        self.add_permissions(\"extras.approve_job\", \"extras.view_scheduledjob\", \"extras.delete_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-deny\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIsNone(ScheduledJob.objects.filter(pk=self.scheduled_job.pk).first())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_dry_run_job_without_permission(self):",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.dryrun_scheduled_job.pk})",
            "        with disable_warnings(\"django.request\"):",
            "            response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job_without_run_job_permission(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.dryrun_scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_job(self):",
            "        self.add_permissions(\"extras.run_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.dryrun_scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        # The below fails because JobResult.task_kwargs doesn't get set until *after* the task begins executing.",
            "        # self.assertEqual(response.data[\"task_kwargs\"], {\"dryrun\": True, \"value\": 1}, response.data)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_dry_run_not_supported(self):",
            "        self.add_permissions(\"extras.run_job\", \"extras.view_scheduledjob\")",
            "        url = reverse(\"extras-api:scheduledjob-dry-run\", kwargs={\"pk\": self.scheduled_job.pk})",
            "        response = self.client.post(url, **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_405_METHOD_NOT_ALLOWED)",
            "",
            "",
            "class NoteTest(APIViewTestCases.APIViewTestCase):",
            "    model = Note",
            "    choices_fields = [\"assigned_object_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.location1 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        location2 = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).last()",
            "        cls.location_ct = ContentType.objects.get_for_model(Location)",
            "        user1 = User.objects.create(username=\"user1\", is_active=True)",
            "        user2 = User.objects.create(username=\"user2\", is_active=True)",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": cls.location1.pk,",
            "                \"assigned_object_type\": \"dcim.location\",",
            "            },",
            "            {",
            "                \"note\": \"This is a test.\",",
            "                \"assigned_object_id\": location2.pk,",
            "                \"assigned_object_type\": \"dcim.location\",",
            "            },",
            "            {",
            "                \"note\": \"This is a note on location 1.\",",
            "                \"assigned_object_id\": cls.location1.pk,",
            "                \"assigned_object_type\": \"dcim.location\",",
            "            },",
            "        ]",
            "        cls.bulk_update_data = {",
            "            \"note\": \"Bulk change.\",",
            "        }",
            "        Note.objects.create(",
            "            note=\"location has been placed on maintenance.\",",
            "            user=user1,",
            "            assigned_object_type=cls.location_ct,",
            "            assigned_object_id=cls.location1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"location maintenance has ended.\",",
            "            user=user1,",
            "            assigned_object_type=cls.location_ct,",
            "            assigned_object_id=cls.location1.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"location is under duress.\",",
            "            user=user2,",
            "            assigned_object_type=cls.location_ct,",
            "            assigned_object_id=location2.pk,",
            "        )",
            "",
            "    def get_deletable_object(self):",
            "        \"\"\"",
            "        Users only create self-authored notes via the REST API; test_recreate_object_csv needs self.user as author.",
            "        \"\"\"",
            "        return Note.objects.create(",
            "            note=\"Delete me!\",",
            "            user=self.user,",
            "            assigned_object_type=self.location_ct,",
            "            assigned_object_id=self.location1.pk,",
            "        )",
            "",
            "",
            "class ObjectChangeTest(APIViewTestCases.GetObjectViewTestCase, APIViewTestCases.ListObjectsViewTestCase):",
            "    model = ObjectChange",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cc = ConfigContext.objects.create(name=\"Config Context 1\", weight=100, data={\"foo\": 123})",
            "        cc_oc = cc.to_objectchange(ObjectChangeActionChoices.ACTION_CREATE)",
            "        cc_oc.request_id = uuid.uuid4()",
            "        cc_oc.change_context = ObjectChangeEventContextChoices.CONTEXT_WEB",
            "        cc_oc.change_context_detail = \"extras:configcontext_edit\"",
            "        cc_oc.validated_save()",
            "",
            "        location_oc = Location.objects.first().to_objectchange(ObjectChangeActionChoices.ACTION_UPDATE)",
            "        location_oc.request_id = uuid.uuid4()",
            "        location_oc.change_context = ObjectChangeEventContextChoices.CONTEXT_ORM",
            "        location_oc.validated_save()",
            "",
            "        git_oc = ObjectChange.objects.create(",
            "            user=None,",
            "            user_name=\"deleted\",",
            "            request_id=cc_oc.request_id,",
            "            action=ObjectChangeActionChoices.ACTION_DELETE,",
            "            changed_object_type=ContentType.objects.get_for_model(GitRepository),",
            "            changed_object_id=uuid.UUID(\"7af2e8d5-6d53-4b79-b488-60448aaaa9e8\"),",
            "            change_context=ObjectChangeEventContextChoices.CONTEXT_WEB,",
            "            change_context_detail=\"extras:gitrepository_delete\",",
            "            related_object=cc_oc.changed_object,",
            "            object_repr=\"demo-git-datasource 2\",",
            "            object_data={",
            "                \"name\": \"demo-git-datasource 2\",",
            "                \"slug\": \"demo_git_datasource_2\",",
            "                \"tags\": [],",
            "                \"branch\": \"main\",",
            "                \"created\": \"2023-06-07T12:49:34.309Z\",",
            "                \"remote_url\": \"https://github.com/nautobot/demo-git-datasource.git\",",
            "                \"current_head\": \"94e88b76e87ccf1fdf48995d72ede86db4623d60\",",
            "                \"last_updated\": \"2023-06-07T12:49:36.368Z\",",
            "                \"custom_fields\": {},",
            "                \"secrets_group\": None,",
            "                \"provided_contents\": [\"extras.configcontext\", \"extras.configcontextschema\", \"extras.exporttemplate\"],",
            "            },",
            "            object_data_v2={",
            "                \"id\": \"7af2e8d5-6d53-4b79-b488-60448aaaa9e8\",",
            "                \"url\": \"/api/extras/git-repositories/7af2e8d5-6d53-4b79-b488-60448aaaa9e8/\",",
            "                \"name\": \"demo-git-datasource 2\",",
            "                \"slug\": \"demo_git_datasource_2\",",
            "                \"branch\": \"main\",",
            "                \"created\": \"2023-06-07T12:49:34.309312Z\",",
            "                \"display\": \"demo-git-datasource 2\",",
            "                \"notes_url\": \"/api/extras/git-repositories/7af2e8d5-6d53-4b79-b488-60448aaaa9e8/notes/\",",
            "                \"remote_url\": \"https://github.com/nautobot/demo-git-datasource.git\",",
            "                \"object_type\": \"extras.gitrepository\",",
            "                \"current_head\": \"94e88b76e87ccf1fdf48995d72ede86db4623d60\",",
            "                \"last_updated\": \"2023-06-07T12:49:36.368627Z\",",
            "                \"custom_fields\": {},",
            "                \"secrets_group\": None,",
            "                \"natural_key_slug\": \"demo-git-datasource+2\",",
            "                \"provided_contents\": [\"extras.configcontextschema\", \"extras.configcontext\", \"extras.exporttemplate\"],",
            "            },",
            "        )",
            "        git_oc.validated_save()",
            "",
            "",
            "class RelationshipTest(APIViewTestCases.APIViewTestCase, RequiredRelationshipTestMixin):",
            "    model = Relationship",
            "",
            "    create_data = [",
            "        {",
            "            \"label\": \"Device VLANs\",",
            "            \"key\": \"device_vlans\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"label\": \"Primary VLAN\",",
            "            \"key\": \"primary_vlan\",",
            "            \"type\": \"one-to-many\",",
            "            \"source_type\": \"ipam.vlan\",",
            "            \"destination_type\": \"dcim.device\",",
            "        },",
            "        {",
            "            \"label\": \"Primary Interface\",",
            "            \"key\": \"primary_interface\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "        {",
            "            \"label\": \"Relationship 1\",",
            "            \"type\": \"one-to-one\",",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_label\": \"primary interface\",",
            "            \"destination_type\": \"dcim.interface\",",
            "            \"destination_hidden\": True,",
            "        },",
            "    ]",
            "",
            "    bulk_update_data = {",
            "        \"source_filter\": {\"name\": [\"some-name\"]},",
            "    }",
            "    choices_fields = [\"destination_type\", \"source_type\", \"type\", \"required_on\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_type = ContentType.objects.get_for_model(Location)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.relationships = (",
            "            Relationship(",
            "                label=\"Related locations\",",
            "                key=\"related_locations\",",
            "                type=\"symmetric-many-to-many\",",
            "                source_type=location_type,",
            "                destination_type=location_type,",
            "            ),",
            "            Relationship(",
            "                label=\"Unrelated locations\",",
            "                key=\"unrelated_locations\",",
            "                type=\"many-to-many\",",
            "                source_type=location_type,",
            "                source_label=\"Other locations (from source side)\",",
            "                destination_type=location_type,",
            "                destination_label=\"Other locations (from destination side)\",",
            "            ),",
            "            Relationship(",
            "                label=\"Devices found elsewhere\",",
            "                key=\"devices_elsewhere\",",
            "                type=\"many-to-many\",",
            "                source_type=location_type,",
            "                destination_type=device_type,",
            "            ),",
            "        )",
            "        for relationship in cls.relationships:",
            "            relationship.validated_save()",
            "        cls.lt = LocationType.objects.get(name=\"Campus\")",
            "        location_status = Status.objects.get_for_model(Location).first()",
            "        cls.location = Location.objects.create(name=\"Location 1\", status=location_status, location_type=cls.lt)",
            "",
            "    def test_get_all_relationships_on_location(self):",
            "        \"\"\"Verify that all relationships are accurately represented when requested.\"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.location.pk}) + \"?include=relationships\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        self.maxDiff = None",
            "        self.assertEqual(",
            "            {",
            "                self.relationships[0].key: {",
            "                    \"id\": str(self.relationships[0].pk),",
            "                    \"url\": self.absolute_api_url(self.relationships[0]),",
            "                    \"label\": self.relationships[0].label,",
            "                    \"type\": self.relationships[0].type,",
            "                    \"peer\": {",
            "                        \"label\": \"locations\",",
            "                        \"object_type\": \"dcim.location\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[1].key: {",
            "                    \"id\": str(self.relationships[1].pk),",
            "                    \"url\": self.absolute_api_url(self.relationships[1]),",
            "                    \"label\": self.relationships[1].label,",
            "                    \"type\": self.relationships[1].type,",
            "                    \"destination\": {",
            "                        \"label\": self.relationships[1].source_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.location\",",
            "                        \"objects\": [],",
            "                    },",
            "                    \"source\": {",
            "                        \"label\": self.relationships[1].destination_label,  # yes -- it's a bit confusing",
            "                        \"object_type\": \"dcim.location\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "                self.relationships[2].key: {",
            "                    \"id\": str(self.relationships[2].pk),",
            "                    \"url\": self.absolute_api_url(self.relationships[2]),",
            "                    \"label\": self.relationships[2].label,",
            "                    \"type\": self.relationships[2].type,",
            "                    \"destination\": {",
            "                        \"label\": \"devices\",",
            "                        \"object_type\": \"dcim.device\",",
            "                        \"objects\": [],",
            "                    },",
            "                },",
            "            },",
            "            response.data[\"relationships\"],",
            "        )",
            "",
            "    def test_populate_relationship_associations_on_location_create(self):",
            "        \"\"\"Verify that relationship associations can be populated at instance creation time.\"\"\"",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        existing_location_1 = Location.objects.create(",
            "            name=\"Existing Location 1\",",
            "            status=Status.objects.get_for_model(Location).first(),",
            "            location_type=location_type,",
            "        )",
            "        existing_location_2 = Location.objects.create(",
            "            name=\"Existing Location 2\",",
            "            status=Status.objects.get_for_model(Location).first(),",
            "            location_type=location_type,",
            "        )",
            "        manufacturer = Manufacturer.objects.first()",
            "        device_type = DeviceType.objects.create(",
            "            manufacturer=manufacturer,",
            "            model=\"device Type 1\",",
            "        )",
            "        device_role = Role.objects.get_for_model(Device).first()",
            "        device_status = Status.objects.get_for_model(Device).first()",
            "        existing_device_1 = Device.objects.create(",
            "            name=\"existing-device-location-1\",",
            "            status=device_status,",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=existing_location_1,",
            "        )",
            "        existing_device_2 = Device.objects.create(",
            "            name=\"existing-device-location-2\",",
            "            status=device_status,",
            "            role=device_role,",
            "            device_type=device_type,",
            "            location=existing_location_2,",
            "        )",
            "",
            "        self.add_permissions(\"dcim.view_location\", \"dcim.add_location\", \"extras.add_relationshipassociation\")",
            "        response = self.client.post(",
            "            reverse(\"dcim-api:location-list\"),",
            "            data={",
            "                \"name\": \"New location\",",
            "                \"status\": Status.objects.get_for_model(Location).first().pk,",
            "                \"location_type\": location_type.pk,",
            "                \"relationships\": {",
            "                    self.relationships[0].key: {",
            "                        \"peer\": {",
            "                            \"objects\": [str(existing_location_1.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[1].key: {",
            "                        \"source\": {",
            "                            \"objects\": [str(existing_location_2.pk)],",
            "                        },",
            "                    },",
            "                    self.relationships[2].key: {",
            "                        \"destination\": {",
            "                            \"objects\": [",
            "                                {\"name\": \"existing-device-location-1\"},",
            "                                {\"name\": \"existing-device-location-2\"},",
            "                            ],",
            "                        },",
            "                    },",
            "                },",
            "            },",
            "            format=\"json\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "        new_location_id = response.data[\"id\"]",
            "        # Peer case - don't distinguish source/destination",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[0],",
            "                source_type=self.relationships[0].source_type,",
            "                source_id__in=[existing_location_1.pk, new_location_id],",
            "                destination_type=self.relationships[0].destination_type,",
            "                destination_id__in=[existing_location_1.pk, new_location_id],",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[1],",
            "                source_type=self.relationships[1].source_type,",
            "                source_id=existing_location_2.pk,",
            "                destination_type=self.relationships[1].destination_type,",
            "                destination_id=new_location_id,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_location_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_1.pk,",
            "            ).exists()",
            "        )",
            "        self.assertTrue(",
            "            RelationshipAssociation.objects.filter(",
            "                relationship=self.relationships[2],",
            "                source_type=self.relationships[2].source_type,",
            "                source_id=new_location_id,",
            "                destination_type=self.relationships[2].destination_type,",
            "                destination_id=existing_device_2.pk,",
            "            ).exists()",
            "        )",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test various bulk create/edit scenarios",
            "        \"\"\"",
            "",
            "        # Delete existing factory generated objects that may interfere with this test",
            "        IPAddress.objects.all().delete()",
            "        Prefix.objects.update(parent=None)",
            "        Prefix.objects.all().delete()",
            "        VLAN.objects.all().delete()",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"api\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        # VLAN endpoint to POST, PATCH and PUT multiple objects to:",
            "        vlan_list_endpoint = reverse(get_route_for_model(VLAN, \"list\", api=True))",
            "",
            "        def send_bulk_data(http_method, data):",
            "            return getattr(self.client, http_method)(",
            "                vlan_list_endpoint,",
            "                data=data,",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "",
            "        device_status = Status.objects.get_for_model(Device).first()",
            "        vlan_groups = VLANGroup.objects.all()[:2]",
            "",
            "        # Try deleting all devices and then creating 2 VLANs (fails):",
            "        Controller.objects.filter(controller_device__isnull=False).delete()",
            "        Device.objects.all().delete()",
            "        response = send_bulk_data(",
            "            \"post\",",
            "            data=[",
            "                {\"vid\": \"7\", \"name\": \"7\", \"status\": device_status.pk, \"vlan_group\": vlan_groups[0].pk},",
            "                {\"vid\": \"8\", \"name\": \"8\", \"status\": device_status.pk, \"vlan_group\": vlan_groups[1].pk},",
            "            ],",
            "        )",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            {",
            "                \"relationships\": {",
            "                    \"vlans_devices_m2m\": [",
            "                        \"VLANs require at least one device, but no devices exist yet. \"",
            "                        \"Create a device by posting to /api/dcim/devices/\",",
            "                        'You need to specify [\"relationships\"][\"vlans_devices_m2m\"][\"source\"][\"objects\"].',",
            "                    ]",
            "                }",
            "            },",
            "            response.json(),",
            "        )",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "        required_relationship_json = {\"vlans_devices_m2m\": {\"source\": {\"objects\": [str(device_for_association.id)]}}}",
            "        expected_error_json = {",
            "            \"relationships\": {",
            "                \"vlans_devices_m2m\": [",
            "                    'You need to specify [\"relationships\"][\"vlans_devices_m2m\"][\"source\"][\"objects\"].'",
            "                ]",
            "            }",
            "        }",
            "",
            "        # Test POST, PATCH and PUT",
            "        for method in [\"post\", \"patch\", \"put\"]:",
            "            if method == \"post\":",
            "                vlan1_json_data = {",
            "                    \"vid\": \"13\",",
            "                    \"name\": \"1\",",
            "                    \"status\": device_status.pk,",
            "                    \"vlan_group\": vlan_groups[0].pk,",
            "                }",
            "                vlan2_json_data = {",
            "                    \"vid\": \"22\",",
            "                    \"name\": \"2\",",
            "                    \"status\": device_status.pk,",
            "                    \"vlan_group\": vlan_groups[1].pk,",
            "                }",
            "            else:",
            "                vlan1 = VLAN.objects.create(name=\"test_required_relationships1\", vid=1, status=device_status)",
            "                vlan2 = VLAN.objects.create(name=\"test_required_relationships2\", vid=2, status=device_status)",
            "                vlan1_json_data = {\"status\": device_status.pk, \"id\": str(vlan1.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan1_json_data.update({\"vid\": \"4\", \"name\": vlan1.name})",
            "",
            "                vlan2_json_data = {\"status\": device_status.pk, \"id\": str(vlan2.id)}",
            "                # Add required fields for PUT method:",
            "                if method == \"put\":",
            "                    vlan2_json_data.update({\"vid\": \"5\", \"name\": vlan2.name})",
            "",
            "            # Try method without specifying required relationships for either vlan1 or vlan2 (fails)",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for just vlan1 (fails)",
            "            vlan1_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            self.assertHttpStatus(response, 400)",
            "            self.assertEqual(response.json(), expected_error_json)",
            "",
            "            # Try method specifying required relationships for both vlan1 and vlan2 (succeeds)",
            "            vlan2_json_data[\"relationships\"] = required_relationship_json",
            "            json_data = [vlan1_json_data, vlan2_json_data]",
            "            response = send_bulk_data(method, json_data)",
            "            if method == \"post\":",
            "                self.assertHttpStatus(response, 201)",
            "            else:",
            "                self.assertHttpStatus(response, 200)",
            "",
            "            # Check the relationship associations were actually created",
            "            for vlan in response.json():",
            "                associated_device = vlan[\"relationships\"][\"vlans_devices_m2m\"][\"source\"][\"objects\"][0]",
            "                self.assertEqual(str(device_for_association.id), associated_device[\"id\"])",
            "",
            "",
            "class RelationshipAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = RelationshipAssociation",
            "    choices_fields = [\"destination_type\", \"source_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.location_type = ContentType.objects.get_for_model(Location)",
            "        cls.device_type = ContentType.objects.get_for_model(Device)",
            "        cls.location_status = Status.objects.get_for_model(Location).first()",
            "",
            "        cls.relationship = Relationship(",
            "            label=\"Devices found elsewhere\",",
            "            key=\"elsewhere_devices\",",
            "            type=\"many-to-many\",",
            "            source_type=cls.location_type,",
            "            destination_type=cls.device_type,",
            "        )",
            "        cls.relationship.validated_save()",
            "        cls.lt = LocationType.objects.get(name=\"Campus\")",
            "        cls.locations = (",
            "            Location.objects.create(name=\"Empty Location\", status=cls.location_status, location_type=cls.lt),",
            "            Location.objects.create(name=\"Occupied Location\", status=cls.location_status, location_type=cls.lt),",
            "            Location.objects.create(name=\"Another Empty Location\", status=cls.location_status, location_type=cls.lt),",
            "        )",
            "        manufacturer = Manufacturer.objects.first()",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\")",
            "        devicerole = Role.objects.get_for_model(Device).first()",
            "        device_status = Status.objects.get_for_model(Device).first()",
            "        cls.devices = [",
            "            Device.objects.create(",
            "                name=f\"Device {num}\",",
            "                device_type=devicetype,",
            "                role=devicerole,",
            "                location=cls.locations[1],",
            "                status=device_status,",
            "            )",
            "            for num in range(1, 5)",
            "        ]",
            "",
            "        cls.associations = (",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.location_type,",
            "                source_id=cls.locations[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[0].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.location_type,",
            "                source_id=cls.locations[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[1].pk,",
            "            ),",
            "            RelationshipAssociation(",
            "                relationship=cls.relationship,",
            "                source_type=cls.location_type,",
            "                source_id=cls.locations[0].pk,",
            "                destination_type=cls.device_type,",
            "                destination_id=cls.devices[2].pk,",
            "            ),",
            "        )",
            "        for association in cls.associations:",
            "            association.validated_save()",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.location\",",
            "                \"source_id\": cls.locations[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[0].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.location\",",
            "                \"source_id\": cls.locations[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[1].pk,",
            "            },",
            "            {",
            "                \"relationship\": cls.relationship.pk,",
            "                \"source_type\": \"dcim.location\",",
            "                \"source_id\": cls.locations[2].pk,",
            "                \"destination_type\": \"dcim.device\",",
            "                \"destination_id\": cls.devices[2].pk,",
            "            },",
            "        ]",
            "",
            "    def test_create_invalid_relationship_association(self):",
            "        \"\"\"Test creation of invalid relationship association restricted by destination/source filter.\"\"\"",
            "",
            "        relationship = Relationship.objects.create(",
            "            label=\"Device to location Rel 1\",",
            "            key=\"device_to_location_rel_1\",",
            "            source_type=self.device_type,",
            "            source_filter={\"name\": [self.devices[0].name]},",
            "            destination_type=self.location_type,",
            "            destination_label=\"Primary Rack\",",
            "            type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            destination_filter={\"name\": [self.locations[0].name]},",
            "        )",
            "",
            "        associations = [",
            "            (",
            "                \"destination\",  # side",
            "                self.locations[2].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[0].pk,",
            "                    \"destination_type\": \"dcim.location\",",
            "                    \"destination_id\": self.locations[2].pk,",
            "                },",
            "            ),",
            "            (",
            "                \"source\",  # side",
            "                self.devices[1].name,  # field name with an error",
            "                {",
            "                    \"relationship\": relationship.pk,",
            "                    \"source_type\": \"dcim.device\",",
            "                    \"source_id\": self.devices[1].pk,",
            "                    \"destination_type\": \"dcim.location\",",
            "                    \"destination_id\": self.locations[0].pk,",
            "                },",
            "            ),",
            "        ]",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        for side, field_error_name, data in associations:",
            "            response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                response.data[side],",
            "                [f\"{field_error_name} violates {relationship.label} {side}_filter restriction\"],",
            "            )",
            "",
            "    def test_model_clean_method_is_called(self):",
            "        \"\"\"Validate RelationshipAssociation clean method is called\"\"\"",
            "",
            "        data = {",
            "            \"relationship\": self.relationship.pk,",
            "            \"source_type\": \"dcim.device\",",
            "            \"source_id\": self.locations[2].pk,",
            "            \"destination_type\": \"dcim.device\",",
            "            \"destination_id\": self.devices[2].pk,",
            "        }",
            "",
            "        self.add_permissions(\"extras.add_relationshipassociation\")",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"source_type\"], [f\"source_type has a different value than defined in {self.relationship}\"]",
            "        )",
            "",
            "    def test_get_association_data_on_location(self):",
            "        \"\"\"",
            "        Check that `include=relationships` query parameter on a model endpoint includes relationships/associations.",
            "        \"\"\"",
            "        self.add_permissions(\"dcim.view_location\")",
            "        response = self.client.get(",
            "            reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.locations[0].pk})",
            "            + \"?include=relationships\"",
            "            + \"&depth=1\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertIn(\"relationships\", response.data)",
            "        self.assertIsInstance(response.data[\"relationships\"], dict)",
            "        # Ensure consistent ordering",
            "        response.data[\"relationships\"][self.relationship.key][\"destination\"][\"objects\"].sort(key=lambda v: v[\"name\"])",
            "        self.maxDiff = None",
            "        relationship_data = response.data[\"relationships\"][self.relationship.key]",
            "        self.assertEqual(relationship_data[\"id\"], str(self.relationship.pk))",
            "        self.assertEqual(relationship_data[\"url\"], self.absolute_api_url(self.relationship))",
            "        self.assertEqual(relationship_data[\"label\"], self.relationship.label)",
            "        self.assertEqual(relationship_data[\"type\"], \"many-to-many\")",
            "        self.assertEqual(relationship_data[\"destination\"][\"label\"], \"devices\")",
            "        self.assertEqual(relationship_data[\"destination\"][\"object_type\"], \"dcim.device\")",
            "",
            "        objects = response.data[\"relationships\"][self.relationship.key][\"destination\"][\"objects\"]",
            "        for i, obj in enumerate(objects):",
            "            self.assertEqual(obj[\"id\"], str(self.devices[i].pk))",
            "            self.assertEqual(obj[\"url\"], self.absolute_api_url(self.devices[i]))",
            "            self.assertEqual(",
            "                obj[\"display\"],",
            "                self.devices[i].display,",
            "            )",
            "            self.assertEqual(",
            "                obj[\"name\"],",
            "                self.devices[i].name,",
            "            )",
            "",
            "    def test_update_association_data_on_location(self):",
            "        \"\"\"",
            "        Check that relationship-associations can be updated via the 'relationships' field.",
            "        \"\"\"",
            "        self.add_permissions(",
            "            \"dcim.view_location\",",
            "            \"dcim.change_location\",",
            "            \"extras.add_relationshipassociation\",",
            "            \"extras.delete_relationshipassociation\",",
            "        )",
            "        initial_response = self.client.get(",
            "            reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.locations[0].pk}) + \"?include=relationships\",",
            "            **self.header,",
            "        )",
            "        self.assertHttpStatus(initial_response, status.HTTP_200_OK)",
            "",
            "        url = reverse(\"dcim-api:location-detail\", kwargs={\"pk\": self.locations[0].pk})",
            "",
            "        with self.subTest(\"Round-trip of same relationships data is a no-op\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": initial_response.data[\"relationships\"]},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Omitting relationships data entirely is valid\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: nonexistent relationship\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"nonexistent-relationship\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]),",
            "                '\"nonexistent-relationship\" is not a relationship on dcim.Location',",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship\"):",
            "            Relationship.objects.create(",
            "                label=\"Device-to-Device\",",
            "                key=\"device_to_device\",",
            "                source_type=self.device_type,",
            "                destination_type=self.device_type,",
            "                type=RelationshipTypeChoices.TYPE_ONE_TO_ONE,",
            "            )",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {\"device_to_device\": {\"peer\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]), '\"device_to_device\" is not a relationship on dcim.Location'",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Error handling: wrong relationship side\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {\"relationships\": {self.relationship.key: {\"source\": {\"objects\": []}}}},",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "            self.assertEqual(",
            "                str(response.data[\"relationships\"][0]),",
            "                '\"source\" is not a valid side for \"Devices found elsewhere\" on dcim.Location',",
            "            )",
            "            self.assertEqual(3, RelationshipAssociation.objects.filter(relationship=self.relationship).count())",
            "            for association in self.associations:",
            "                self.assertTrue(RelationshipAssociation.objects.filter(pk=association.pk).exists())",
            "",
            "        with self.subTest(\"Valid data: create/no-op/delete on RelationshipAssociations\"):",
            "            response = self.client.patch(",
            "                url,",
            "                {",
            "                    \"relationships\": {",
            "                        self.relationship.key: {",
            "                            \"destination\": {",
            "                                \"objects\": [",
            "                                    # remove devices[0] by omission",
            "                                    str(self.devices[1].pk),  # existing device identified by PK",
            "                                    {\"name\": self.devices[2].name},  # existing device identified by attributes",
            "                                    {\"id\": self.devices[3].pk},  # new device association",
            "                                ]",
            "                            }",
            "                        }",
            "                    },",
            "                },",
            "                format=\"json\",",
            "                **self.header,",
            "            )",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            # Removed association",
            "            self.assertFalse(RelationshipAssociation.objects.filter(pk=self.associations[0].pk).exists())",
            "            # Unchanged associations",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[1].pk).exists())",
            "            self.assertTrue(RelationshipAssociation.objects.filter(pk=self.associations[2].pk).exists())",
            "            # Created association",
            "            self.assertTrue(RelationshipAssociation.objects.filter(destination_id=self.devices[3].pk).exists())",
            "",
            "",
            "class SecretTest(APIViewTestCases.APIViewTestCase):",
            "    model = Secret",
            "    bulk_update_data = {}",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"NAPALM Username\",",
            "            \"provider\": \"environment-variable\",",
            "            \"description\": \"Username for all NAPALM devices\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_USERNAME\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"NAPALM Password\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": {",
            "                \"variable\": \"NAPALM_PASSWORD\",",
            "            },",
            "        },",
            "        {",
            "            \"name\": \"GitHub Token for My Repository\",",
            "            \"provider\": \"text-file\",",
            "            \"parameters\": {",
            "                \"path\": \"/github-tokens/user/myusername.txt\",",
            "            },",
            "        },",
            "    ]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"api-test-1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_1\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"api-test-3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"API_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "    def test_secret_check(self):",
            "        \"\"\"",
            "        Ensure that we can check the validity of a secret.",
            "        \"\"\"",
            "",
            "        with self.subTest(\"Secret is not accessible\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-not-accessible\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-matter\"},  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_403_FORBIDDEN)",
            "",
            "        self.add_permissions(\"extras.view_secret\")",
            "",
            "        with self.subTest(\"Secret check successful\"):",
            "            with tempfile.NamedTemporaryFile() as secret_file:",
            "                secret_file.write(b\"HELLO WORLD\")",
            "                test_secret = Secret.objects.create(",
            "                    name=\"secret-check-test-accessible\",",
            "                    provider=\"text-file\",",
            "                    parameters={\"path\": secret_file.name},",
            "                )",
            "                response = self.client.get(",
            "                    reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header",
            "                )",
            "                self.assertHttpStatus(response, status.HTTP_200_OK)",
            "                self.assertEqual(response.data[\"result\"], True)",
            "",
            "        with self.subTest(\"Secret check failed\"):",
            "            test_secret = Secret.objects.create(",
            "                name=\"secret-check-test-failed\",",
            "                provider=\"text-file\",",
            "                parameters={\"path\": \"/tmp/does-not-exist\"},  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            )",
            "            response = self.client.get(reverse(\"extras-api:secret-check\", kwargs={\"pk\": test_secret.pk}), **self.header)",
            "            self.assertHttpStatus(response, status.HTTP_200_OK)",
            "            self.assertEqual(response.data[\"result\"], False)",
            "            self.assertIn(\"SecretValueNotFoundError\", response.data[\"message\"])",
            "",
            "",
            "class SecretsGroupTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroup",
            "    bulk_update_data = {}",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\"),",
            "            SecretsGroup.objects.create(name=\"Group B\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            secrets_group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            secrets_group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Secrets Group 1\",",
            "                \"description\": \"First Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 2\",",
            "                \"description\": \"Second Secrets Group\",",
            "            },",
            "            {",
            "                \"name\": \"Secrets Group 3\",",
            "                \"description\": \"Third Secrets Group\",",
            "            },",
            "        ]",
            "",
            "",
            "class SecretsGroupAssociationTest(APIViewTestCases.APIViewTestCase):",
            "    model = SecretsGroupAssociation",
            "    bulk_update_data = {}",
            "    choices_fields = [\"access_type\", \"secret_type\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret.objects.create(",
            "                name=\"secret-1\", provider=\"environment-variable\", parameters={\"variable\": \"SOME_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-2\", provider=\"environment-variable\", parameters={\"variable\": \"ANOTHER_VAR\"}",
            "            ),",
            "            Secret.objects.create(",
            "                name=\"secret-3\", provider=\"environment-variable\", parameters={\"variable\": \"YET_ANOTHER\"}",
            "            ),",
            "        )",
            "",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group A\"),",
            "            SecretsGroup.objects.create(name=\"Group B\"),",
            "            SecretsGroup.objects.create(name=\"Group C\", description=\"Some group\"),",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[0],",
            "            secrets_group=secrets_groups[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[1],",
            "            secrets_group=secrets_groups[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secret=secrets[2],",
            "            secrets_group=secrets_groups[2],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_SECRET,",
            "        )",
            "",
            "        cls.create_data = [",
            "            {",
            "                \"secrets_group\": secrets_groups[0].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[0].pk,",
            "            },",
            "            {",
            "                \"secrets_group\": secrets_groups[1].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[1].pk,",
            "            },",
            "            {",
            "                \"secrets_group\": secrets_groups[2].pk,",
            "                \"access_type\": SecretsGroupAccessTypeChoices.TYPE_SSH,",
            "                \"secret_type\": SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "                \"secret\": secrets[2].pk,",
            "            },",
            "        ]",
            "",
            "",
            "class StatusTest(APIViewTestCases.APIViewTestCase):",
            "    model = Status",
            "    bulk_update_data = {",
            "        \"color\": \"000000\",",
            "    }",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Pizza\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.device\", \"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Oysters\",",
            "            \"color\": \"00ff00\",",
            "            \"content_types\": [\"ipam.ipaddress\", \"ipam.prefix\"],",
            "        },",
            "        {",
            "            \"name\": \"Bad combinations\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "        {",
            "            \"name\": \"Status 1\",",
            "            \"color\": \"ff0000\",",
            "            \"content_types\": [\"dcim.device\"],",
            "        },",
            "    ]",
            "",
            "",
            "class TagTest(APIViewTestCases.APIViewTestCase):",
            "    model = Tag",
            "    create_data = [",
            "        {\"name\": \"Tag 4\", \"content_types\": [Location._meta.label_lower]},",
            "        {\"name\": \"Tag 5\", \"content_types\": [Location._meta.label_lower]},",
            "        {\"name\": \"Tag 6\", \"content_types\": [Location._meta.label_lower]},",
            "    ]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.update_data = {",
            "            \"name\": \"A new tag name\",",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "        cls.bulk_update_data = {",
            "            \"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in TaggableClassesQuery().as_queryset()]",
            "        }",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "",
            "        # VLANGroup is an OrganizationalModel, not a PrimaryModel, and therefore does not support tags",
            "        data = {**self.create_data[0], \"content_types\": [VLANGroup._meta.label_lower]}",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "",
            "        tag = Tag.objects.filter(name=data[\"name\"])",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(f\"Invalid content type: {VLANGroup._meta.label_lower}\", response.data[\"content_types\"])",
            "",
            "    def test_create_tags_without_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        data = {",
            "            \"name\": \"Tag 8\",",
            "        }",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(str(response.data[\"content_types\"][0]), \"This field is required.\")",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.filter(content_types=ContentType.objects.get_for_model(Location)).first()",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        location.tags.add(tag_1)",
            "",
            "        tag_content_types = list(tag_1.content_types.all())",
            "        tag_content_types.remove(ContentType.objects.get_for_model(Location))",
            "",
            "        url = self._get_detail_url(tag_1)",
            "        data = {\"content_types\": [f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types]}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, 400)",
            "        self.assertEqual(",
            "            str(response.data[\"content_types\"][0]), \"Unable to remove dcim.location. Dependent objects were found.\"",
            "        )",
            "",
            "    def test_update_tag_content_type_unchanged(self):",
            "        \"\"\"Test updating a tag without changing its content-types.\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag = Tag.objects.exclude(content_types=ContentType.objects.get_for_model(Location)).first()",
            "        tag_content_types = list(tag.content_types.all())",
            "        url = self._get_detail_url(tag)",
            "        data = {\"color\": ColorChoices.COLOR_LIME}",
            "",
            "        response = self.client.patch(url, data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "        self.assertEqual(response.data[\"color\"], ColorChoices.COLOR_LIME)",
            "        self.assertEqual(",
            "            sorted(response.data[\"content_types\"]), sorted([f\"{ct.app_label}.{ct.model}\" for ct in tag_content_types])",
            "        )",
            "",
            "        tag.refresh_from_db()",
            "        self.assertEqual(tag.color, ColorChoices.COLOR_LIME)",
            "        self.assertEqual(list(tag.content_types.all()), tag_content_types)",
            "",
            "",
            "#",
            "# Team",
            "#",
            "",
            "",
            "class TeamTest(APIViewTestCases.APIViewTestCase):",
            "    model = Team",
            "    bulk_update_data = {",
            "        \"address\": \"Carnegie Hall, New York, NY\",",
            "    }",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.create_data = [",
            "            {",
            "                \"name\": \"Team 1\",",
            "                \"phone\": \"555-0121\",",
            "                \"email\": \"team1@example.com\",",
            "                \"contacts\": [Contact.objects.first().pk, Contact.objects.last().pk],",
            "            },",
            "            {",
            "                \"name\": \"Team 2\",",
            "                \"phone\": \"555-0122\",",
            "                \"email\": \"team2@example.com\",",
            "                \"address\": \"Bowser's Castle, Staten Island, NY\",",
            "            },",
            "            {",
            "                \"name\": \"Team 3\",",
            "                \"phone\": \"555-0123\",",
            "            },",
            "            {",
            "                \"name\": \"Team 4\",",
            "                \"email\": \"team4@example.com\",",
            "                \"address\": \"Rainbow Bridge, Central NJ\",",
            "            },",
            "        ]",
            "",
            "",
            "class WebhookTest(APIViewTestCases.APIViewTestCase):",
            "    model = Webhook",
            "    create_data = [",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-4\",",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://example.com/test4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-5\",",
            "            \"type_update\": True,",
            "            \"payload_url\": \"http://example.com/test5\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "        {",
            "            \"content_types\": [\"dcim.consoleport\"],",
            "            \"name\": \"api-test-6\",",
            "            \"type_delete\": True,",
            "            \"payload_url\": \"http://example.com/test6\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "            \"ssl_verification\": True,",
            "        },",
            "    ]",
            "    choices_fields = [\"http_method\"]",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.webhooks = (",
            "            Webhook(",
            "                name=\"api-test-1\",",
            "                type_create=True,",
            "                payload_url=\"http://example.com/test1\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-2\",",
            "                type_update=True,",
            "                payload_url=\"http://example.com/test2\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "            Webhook(",
            "                name=\"api-test-3\",",
            "                type_delete=True,",
            "                payload_url=\"http://example.com/test3\",",
            "                http_method=\"POST\",",
            "                http_content_type=\"application/json\",",
            "                ssl_verification=True,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(DeviceType)",
            "",
            "        for webhook in cls.webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "    def test_create_webhooks_with_diff_content_type_same_url_same_action(self):",
            "        \"\"\"",
            "        Create a new webhook with diffrent content_types, same url and same action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | console port, create, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.consoleport\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_diff_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and diff action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, delete, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_201_CREATED)",
            "",
            "    def test_create_webhooks_with_same_content_type_same_url_common_action(self):",
            "        \"\"\"",
            "        Create a new webhook with same content_types, same url and common action with a webhook that exists",
            "",
            "        Example:",
            "            Webhook 1: dcim | device type, create, http://localhost",
            "            Webhook 2: dcim | device type, create, update, http://localhost",
            "        \"\"\"",
            "        self.add_permissions(\"extras.add_webhook\")",
            "",
            "        data = (",
            "            {",
            "                \"content_types\": [\"dcim.devicetype\"],",
            "                \"name\": \"api-test-7\",",
            "                \"type_create\": self.webhooks[0].type_create,",
            "                \"type_update\": True,",
            "                \"payload_url\": self.webhooks[0].payload_url,",
            "                \"http_method\": self.webhooks[0].http_method,",
            "                \"http_content_type\": self.webhooks[0].http_content_type,",
            "                \"ssl_verification\": self.webhooks[0].ssl_verification,",
            "            },",
            "        )",
            "",
            "        response = self.client.post(self._get_list_url(), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[0][\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )",
            "",
            "    def test_patch_webhooks_with_same_content_type_same_url_common_action(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        self.webhooks[2].payload_url = self.webhooks[1].payload_url",
            "        self.webhooks[2].save()",
            "",
            "        data = {\"type_update\": True}",
            "",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_400_BAD_REQUEST)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            f\"A webhook already exists for update on dcim | device type to URL {self.webhooks[1].payload_url}\",",
            "        )",
            "",
            "    def test_patch_webhooks(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        instance = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=self.webhooks[1].payload_url,",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"type_delete\": True}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"content_types\": [\"dcim.device\"]}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "        data = {\"payload_url\": \"http://example.com/test4\"}",
            "        response = self.client.patch(self._get_detail_url(self.webhooks[2]), data, format=\"json\", **self.header)",
            "        self.assertHttpStatus(response, status.HTTP_200_OK)",
            "",
            "    def test_invalid_webhooks_patch(self):",
            "        self.add_permissions(\"extras.change_webhook\")",
            "",
            "        # Test patch payload_url with conflicts",
            "        instance_1 = Webhook.objects.create(",
            "            name=\"api-test-4\",",
            "            type_update=True,",
            "            payload_url=\"http://example.com/test4\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_1.content_types.set([ContentType.objects.get_for_model(DeviceType)])",
            "",
            "        data = {\"payload_url\": \"http://example.com/test2\"}",
            "        response = self.client.patch(self._get_detail_url(instance_1), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_update\"][0],",
            "            \"A webhook already exists for update on dcim | device type to URL http://example.com/test2\",",
            "        )",
            "",
            "        # Test patch content_types with conflicts",
            "        instance_2 = Webhook.objects.create(",
            "            name=\"api-test-5\",",
            "            type_create=True,",
            "            payload_url=\"http://example.com/test1\",",
            "            http_method=\"POST\",",
            "            http_content_type=\"application/json\",",
            "            ssl_verification=True,",
            "        )",
            "        instance_2.content_types.set([ContentType.objects.get_for_model(Device)])",
            "",
            "        data = {\"content_types\": [\"dcim.devicetype\"]}",
            "        response = self.client.patch(self._get_detail_url(instance_2), data, format=\"json\", **self.header)",
            "        self.assertEqual(",
            "            response.data[\"type_create\"][0],",
            "            \"A webhook already exists for create on dcim | device type to URL http://example.com/test1\",",
            "        )",
            "",
            "",
            "class RoleTest(APIViewTestCases.APIViewTestCase):",
            "    model = Role",
            "    bulk_update_data = {",
            "        \"color\": \"000000\",",
            "    }",
            "",
            "    create_data = [",
            "        {",
            "            \"name\": \"Role 1\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.device\", \"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Role 2\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"dcim.rack\"],",
            "        },",
            "        {",
            "            \"name\": \"Role 3\",",
            "            \"color\": \"0000ff\",",
            "            \"content_types\": [\"ipam.ipaddress\", \"ipam.vlan\"],",
            "        },",
            "    ]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "771": [
                "DynamicGroupTestMixin",
                "setUpTestData"
            ],
            "814": [
                "DynamicGroupTest",
                "test_get_members"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/tests/test_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from nautobot.core.models.fields import slugify_dashes_to_underscores"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from nautobot.core.testing import extract_form_failures, extract_page_body, TestCase, ViewTestCases"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from nautobot.core.testing.utils import disable_warnings, post_data"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from nautobot.core.utils.permissions import get_permission_for_model"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from nautobot.dcim.models import ("
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     ConsolePort,"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     Controller,"
            },
            "7": {
                "beforePatchRowNumber": 777,
                "afterPatchRowNumber": 778,
                "PatchRowcode": "         content_type = ContentType.objects.get_for_model(Device)"
            },
            "8": {
                "beforePatchRowNumber": 778,
                "afterPatchRowNumber": 779,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 779,
                "afterPatchRowNumber": 780,
                "PatchRowcode": "         # DynamicGroup objects to test."
            },
            "10": {
                "beforePatchRowNumber": 780,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DynamicGroup.objects.create(name=\"DG 1\", content_type=content_type)"
            },
            "11": {
                "beforePatchRowNumber": 781,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DynamicGroup.objects.create(name=\"DG 2\", content_type=content_type)"
            },
            "12": {
                "beforePatchRowNumber": 782,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        DynamicGroup.objects.create(name=\"DG 3\", content_type=content_type)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 781,
                "PatchRowcode": "+        cls.dynamic_groups = ["
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 782,
                "PatchRowcode": "+            DynamicGroup.objects.create(name=\"DG 1\", content_type=content_type),"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 783,
                "PatchRowcode": "+            DynamicGroup.objects.create(name=\"DG 2\", content_type=content_type),"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 784,
                "PatchRowcode": "+            DynamicGroup.objects.create(name=\"DG 3\", content_type=content_type),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 785,
                "PatchRowcode": "+        ]"
            },
            "18": {
                "beforePatchRowNumber": 783,
                "afterPatchRowNumber": 786,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 784,
                "afterPatchRowNumber": 787,
                "PatchRowcode": "         cls.form_data = {"
            },
            "20": {
                "beforePatchRowNumber": 785,
                "afterPatchRowNumber": 788,
                "PatchRowcode": "             \"name\": \"new_dynamic_group\","
            },
            "21": {
                "beforePatchRowNumber": 792,
                "afterPatchRowNumber": 795,
                "PatchRowcode": "             \"dynamic_group_memberships-MAX_NUM_FORMS\": \"1000\","
            },
            "22": {
                "beforePatchRowNumber": 793,
                "afterPatchRowNumber": 796,
                "PatchRowcode": "         }"
            },
            "23": {
                "beforePatchRowNumber": 794,
                "afterPatchRowNumber": 797,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 798,
                "PatchRowcode": "+    def test_get_object_with_permission(self):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 799,
                "PatchRowcode": "+        instance = self._get_queryset().first()"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 800,
                "PatchRowcode": "+        # Add view permissions for the group's members:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 801,
                "PatchRowcode": "+        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 802,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 803,
                "PatchRowcode": "+        response = super().test_get_object_with_permission()"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 804,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 805,
                "PatchRowcode": "+        response_body = extract_page_body(response.content.decode(response.charset))"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 806,
                "PatchRowcode": "+        # Check that the \"members\" table in the detail view includes all appropriate member objects"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 807,
                "PatchRowcode": "+        for member in instance.members:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 808,
                "PatchRowcode": "+            self.assertIn(str(member.pk), response_body)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 809,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 810,
                "PatchRowcode": "+    def test_get_object_with_constrained_permission(self):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 811,
                "PatchRowcode": "+        instance = self._get_queryset().first()"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 812,
                "PatchRowcode": "+        # Add view permission for one of the group's members but not the others:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 813,
                "PatchRowcode": "+        member1, member2 = instance.members[:2]"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 814,
                "PatchRowcode": "+        obj_perm = ObjectPermission("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 815,
                "PatchRowcode": "+            name=\"Members permission\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 816,
                "PatchRowcode": "+            constraints={\"pk\": member1.pk},"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 817,
                "PatchRowcode": "+            actions=[\"view\"],"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 818,
                "PatchRowcode": "+        )"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 819,
                "PatchRowcode": "+        obj_perm.save()"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 820,
                "PatchRowcode": "+        obj_perm.users.add(self.user)"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 821,
                "PatchRowcode": "+        obj_perm.object_types.add(instance.content_type)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 822,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 823,
                "PatchRowcode": "+        response = super().test_get_object_with_constrained_permission()"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 824,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 825,
                "PatchRowcode": "+        response_body = extract_page_body(response.content.decode(response.charset))"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 826,
                "PatchRowcode": "+        # Check that the \"members\" table in the detail view includes all permitted member objects"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 827,
                "PatchRowcode": "+        self.assertIn(str(member1.pk), response_body)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 828,
                "PatchRowcode": "+        self.assertNotIn(str(member2.pk), response_body)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 829,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 795,
                "afterPatchRowNumber": 830,
                "PatchRowcode": "     def test_get_object_dynamic_groups_anonymous(self):"
            },
            "57": {
                "beforePatchRowNumber": 796,
                "afterPatchRowNumber": 831,
                "PatchRowcode": "         url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})"
            },
            "58": {
                "beforePatchRowNumber": 797,
                "afterPatchRowNumber": 832,
                "PatchRowcode": "         self.client.logout()"
            },
            "59": {
                "beforePatchRowNumber": 815,
                "afterPatchRowNumber": 850,
                "PatchRowcode": "         self.assertIn(\"DG 3\", response_body, msg=response_body)"
            },
            "60": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": 851,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 817,
                "afterPatchRowNumber": 852,
                "PatchRowcode": "     def test_get_object_dynamic_groups_with_constrained_permission(self):"
            },
            "62": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.add_permissions(\"extras.view_dynamicgroup\")"
            },
            "63": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": 853,
                "PatchRowcode": "         obj_perm = ObjectPermission("
            },
            "64": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 854,
                "PatchRowcode": "             name=\"View a device\","
            },
            "65": {
                "beforePatchRowNumber": 821,
                "afterPatchRowNumber": 855,
                "PatchRowcode": "             constraints={\"pk\": Device.objects.first().pk},"
            },
            "66": {
                "beforePatchRowNumber": 824,
                "afterPatchRowNumber": 858,
                "PatchRowcode": "         obj_perm.save()"
            },
            "67": {
                "beforePatchRowNumber": 825,
                "afterPatchRowNumber": 859,
                "PatchRowcode": "         obj_perm.users.add(self.user)"
            },
            "68": {
                "beforePatchRowNumber": 826,
                "afterPatchRowNumber": 860,
                "PatchRowcode": "         obj_perm.object_types.add(ContentType.objects.get_for_model(Device))"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 861,
                "PatchRowcode": "+        obj_perm_2 = ObjectPermission("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 862,
                "PatchRowcode": "+            name=\"View a Dynamic Group\","
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 863,
                "PatchRowcode": "+            constraints={\"pk\": self.dynamic_groups[0].pk},"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+            actions=[\"view\"],"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 865,
                "PatchRowcode": "+        )"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 866,
                "PatchRowcode": "+        obj_perm_2.save()"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 867,
                "PatchRowcode": "+        obj_perm_2.users.add(self.user)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 868,
                "PatchRowcode": "+        obj_perm_2.object_types.add(ContentType.objects.get_for_model(DynamicGroup))"
            },
            "77": {
                "beforePatchRowNumber": 827,
                "afterPatchRowNumber": 869,
                "PatchRowcode": " "
            },
            "78": {
                "beforePatchRowNumber": 828,
                "afterPatchRowNumber": 870,
                "PatchRowcode": "         url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})"
            },
            "79": {
                "beforePatchRowNumber": 829,
                "afterPatchRowNumber": 871,
                "PatchRowcode": "         response = self.client.get(url)"
            },
            "80": {
                "beforePatchRowNumber": 830,
                "afterPatchRowNumber": 872,
                "PatchRowcode": "         self.assertHttpStatus(response, 200)"
            },
            "81": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": 873,
                "PatchRowcode": "         response_body = response.content.decode(response.charset)"
            },
            "82": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 874,
                "PatchRowcode": "         self.assertIn(\"DG 1\", response_body, msg=response_body)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 875,
                "PatchRowcode": "+        self.assertNotIn(\"DG 2\", response_body, msg=response_body)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+        self.assertNotIn(\"DG 3\", response_body, msg=response_body)"
            },
            "85": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": 877,
                "PatchRowcode": " "
            },
            "86": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": 878,
                "PatchRowcode": "         url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.last().pk})"
            },
            "87": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": 879,
                "PatchRowcode": "         response = self.client.get(url)"
            }
        },
        "frontPatchFile": [
            "from datetime import timedelta",
            "from unittest import mock",
            "import urllib.parse",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.html import format_html",
            "",
            "from nautobot.circuits.models import Circuit",
            "from nautobot.core.choices import ColorChoices",
            "from nautobot.core.models.fields import slugify_dashes_to_underscores",
            "from nautobot.core.testing import extract_form_failures, extract_page_body, TestCase, ViewTestCases",
            "from nautobot.core.testing.utils import disable_warnings, post_data",
            "from nautobot.dcim.models import (",
            "    ConsolePort,",
            "    Controller,",
            "    Device,",
            "    DeviceType,",
            "    Interface,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.choices import (",
            "    CustomFieldTypeChoices,",
            "    JobExecutionType,",
            "    LogLevelChoices,",
            "    ObjectChangeActionChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            "    WebhookHttpMethodChoices,",
            ")",
            "from nautobot.extras.constants import HTTP_CONTENT_TYPE_JSON, JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    Job,",
            "    JobButton,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Team,",
            "    Webhook,",
            ")",
            "from nautobot.extras.templatetags.job_buttons import NO_CONFIRM_BUTTON",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import RoleModelsQuery, TaggableClassesQuery",
            "from nautobot.ipam.models import IPAddress, Prefix, VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "",
            "# Use the proper swappable User model",
            "User = get_user_model()",
            "",
            "",
            "class ComputedFieldTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ComputedField",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        computed_fields = (",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field One\",",
            "                key=\"computed_field_one\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                key=\"computed_field_two\",",
            "                label=\"Computed Field Two\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                key=\"computed_field_three\",",
            "                label=\"Computed Field Three\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field Five\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "        )",
            "        cls.location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        cls.location1 = Location(name=\"NYC\", location_type=cls.location_type, status=status)",
            "        cls.location1.save()",
            "",
            "        for cf in computed_fields:",
            "            cf.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"key\": \"computed_field_four\",",
            "            \"label\": \"Computed Field Four\",",
            "            \"template\": \"{{ obj.name }} is the best Location!\",",
            "            \"fallback_value\": \":skull_emoji:\",",
            "            \"weight\": 100,",
            "        }",
            "",
            "        cls.slug_test_object = \"Computed Field Five\"",
            "",
            "",
            "class ComputedFieldRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of ComputedFields, distinct from tests of the ComputedField views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.computedfield = ComputedField(",
            "            content_type=ContentType.objects.get_for_model(LocationType),",
            "            key=\"test\",",
            "            label=\"Computed Field\",",
            "            template=\"FOO {{ obj.name }} BAR\",",
            "            fallback_value=\"Fallback Value\",",
            "            weight=100,",
            "        )",
            "        self.computedfield.validated_save()",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_computed_field(self):",
            "        \"\"\"Ensure that the computed field template is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {self.location_type.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_computed_field_fallback_value(self):",
            "        \"\"\"Ensure that the fallback_value is rendered if the template fails to render.\"\"\"",
            "        # Make the template invalid to demonstrate the fallback value",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"Fallback Value\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_template(self):",
            "        \"\"\"Ensure that computed field templates can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_fallback_value(self):",
            "        \"\"\"Ensure that computed field fallback values can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.fallback_value = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "# TODO: Change base class to PrimaryObjectViewTestCase",
            "# Blocked by absence of standard create/edit, bulk create views",
            "class ConfigContextTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ConfigContext",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "",
            "        # Create three ConfigContexts",
            "        for i in range(1, 4):",
            "            configcontext = ConfigContext(name=f\"Config Context {i}\", data={\"foo\": i})",
            "            configcontext.save()",
            "            configcontext.locations.add(location)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Config Context X\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"locations\": [location.pk],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": 123}',",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"weight\": 300,",
            "            \"is_active\": False,",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"locations\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"config_context_schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(",
            "            self._get_queryset().get(name=\"Config Context with schema\").config_context_schema.pk, schema.pk",
            "        )",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"locations\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"config_context_schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 200)",
            "        self.assertEqual(self._get_queryset().filter(name=\"Config Context with schema\").count(), 0)",
            "",
            "",
            "class ConfigContextSchemaTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = ConfigContextSchema",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create three ConfigContextSchema records",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 4\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Schema X\",",
            "            \"data_schema\": '{\"type\": \"object\",\"properties\": {\"baz\": {\"type\": \"string\"}}}',  # Intentionally misformatted (missing space) to ensure proper formatting on output",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "",
            "class ContactTestCase(ViewTestCases.PrimaryObjectViewTestCase):",
            "    model = Contact",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"new contact\",",
            "            \"phone\": \"555-0121\",",
            "            \"email\": \"new-contact@example.com\",",
            "            \"address\": \"Rainbow Road, Ramus NJ\",",
            "        }",
            "        cls.bulk_edit_data = {\"address\": \"Carnegie Hall, New York, NY\", \"phone\": \"555-0125\"}",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_create_new_contact_and_assign_contact_to_object(self):",
            "        initial_contact_count = Contact.objects.count()",
            "        initial_contact_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_contact\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_contact_add\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        contact_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = contact_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_contact_count + 1, Contact.objects.count())",
            "        self.assertEqual(initial_contact_association_count + 1, ContactAssociation.objects.count())",
            "        contact = Contact.objects.get(name=\"new contact\", phone=\"555-0121\")",
            "        self.assertEqual(contact.name, \"new contact\")",
            "        self.assertEqual(contact.phone, \"555-0121\")",
            "        self.assertEqual(contact.email, \"new-contact@example.com\")",
            "        self.assertEqual(contact.address, \"Rainbow Road, Ramus NJ\")",
            "        contact_association = ContactAssociation.objects.get(contact=contact)",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "",
            "class ContactAssociationTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "):",
            "    model = ContactAssociation",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        roles = Role.objects.get_for_model(ContactAssociation)",
            "        statuses = Status.objects.get_for_model(ContactAssociation)",
            "        ip_addresses = IPAddress.objects.all()",
            "        cls.form_data = {",
            "            \"contact\": Contact.objects.first().pk,",
            "            \"team\": None,",
            "            \"associated_object_type\": ContentType.objects.get_for_model(Circuit).pk,",
            "            \"associated_object_id\": Circuit.objects.first().pk,",
            "            \"role\": roles[0].pk,",
            "            \"status\": statuses[0].pk,",
            "        }",
            "        cls.bulk_edit_data = {",
            "            \"role\": roles[1].pk,",
            "            \"status\": statuses[1].pk,",
            "        }",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[0].pk,",
            "            role=roles[2],",
            "            status=statuses[1],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[1].pk,",
            "            role=roles[1],",
            "            status=statuses[2],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[2].pk,",
            "            role=roles[0],",
            "            status=statuses[0],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[3].pk,",
            "            role=roles[0],",
            "            status=statuses[1],",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_assign_existing_contact_to_object(self):",
            "        contact = Contact.objects.first()",
            "        initial_contact_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_contact\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_contact_team_assign\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        contact_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = contact_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_contact_association_count + 1, ContactAssociation.objects.count())",
            "        self.assertEqual(contact.pk, self.form_data[\"contact\"])",
            "        contact_association = ContactAssociation.objects.get(",
            "            contact=contact, associated_object_id=contact_associated_circuit.pk",
            "        )",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_assign_existing_team_to_object(self):",
            "        team = Team.objects.first()",
            "        initial_contact_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_team\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_contact_team_assign\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        contact_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"team\"] = team.pk",
            "        self.form_data[\"contact\"] = None",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = contact_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_contact_association_count + 1, ContactAssociation.objects.count())",
            "        self.assertEqual(team.pk, self.form_data[\"team\"])",
            "        contact_association = ContactAssociation.objects.get(",
            "            team=team, associated_object_id=contact_associated_circuit.pk",
            "        )",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "",
            "class CustomLinkTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomLink",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        customlinks = (",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-1\",",
            "                text=\"customlink text 1\",",
            "                target_url=\"http://customlink1.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-2\",",
            "                text=\"customlink text 2\",",
            "                target_url=\"http://customlink2.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-3\",",
            "                text=\"customlink text 3\",",
            "                target_url=\"http://customlink3.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "        )",
            "",
            "        for link in customlinks:",
            "            link.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"name\": \"customlink-4\",",
            "            \"text\": \"customlink text 4\",",
            "            \"target_url\": \"http://customlink4.com\",",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"new_window\": False,",
            "        }",
            "",
            "",
            "class CustomFieldTestCase(",
            "    # No NotesViewTestCase, at least for now",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomField",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        custom_fields = [",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_BOOLEAN,",
            "                label=\"Custom Field Boolean Type\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                label=\"Custom Field Text\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_INTEGER,",
            "                label=\"Custom Field Integer\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                # https://github.com/nautobot/nautobot/issues/1962",
            "                label=\"Custom field? With special / unusual characters!\",",
            "                default=\"\",",
            "            ),",
            "        ]",
            "",
            "        cls.slug_test_object = \"Custom Field Integer\"",
            "",
            "        for custom_field in custom_fields:",
            "            custom_field.validated_save()",
            "            custom_field.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [obj_type.pk],",
            "            \"type\": CustomFieldTypeChoices.TYPE_BOOLEAN,  # type is mandatory but cannot be changed once set.",
            "            \"key\": \"custom_field_boolean_type\",  # key is mandatory but cannot be changed once set.",
            "            \"label\": \"Custom Field Boolean\",",
            "            \"default\": None,",
            "            \"filter_logic\": \"loose\",",
            "            \"weight\": 100,",
            "            # These are the \"management_form\" fields required by the dynamic CustomFieldChoice formsets.",
            "            \"custom_field_choices-TOTAL_FORMS\": \"0\",  # Set to 0 so validation succeeds until we need it",
            "            \"custom_field_choices-INITIAL_FORMS\": \"1\",",
            "            \"custom_field_choices-MIN_NUM_FORMS\": \"0\",",
            "            \"custom_field_choices-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_create_object_without_permission(self):",
            "        # Can't have two CustomFields with the same \"key\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"key\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_without_permission()",
            "",
            "    def test_create_object_with_permission(self):",
            "        # Can't have two CustomFields with the same \"key\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"key\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_permission()",
            "",
            "    def test_create_object_with_constrained_permission(self):",
            "        # Can't have two CustomFields with the same \"key\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"key\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_constrained_permission()",
            "",
            "",
            "class CustomLinkRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of CustomLinks, distinct from tests of the CustomLink views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_location\"]",
            "",
            "    def test_view_object_with_custom_link(self):",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name=\"Test\",",
            "            text=\"FOO {{ obj.name }} BAR\",",
            "            target_url=\"http://example.com/?location={{ obj.name }}\",",
            "            new_window=False,",
            "        )",
            "        customlink.save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {location.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_text(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name=\"Test\",",
            "            text='<script>alert(\"Hello world!\")</script>',",
            "            target_url=\"http://example.com/?location=None\",",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_url(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name=\"Test\",",
            "            text=\"Hello\",",
            "            target_url='\"><script>alert(\"Hello world!\")</script><a href=\"',",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_name(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name='<script>alert(\"Hello World\")</script>',",
            "            text=\"Hello\",",
            "            target_url=\"http://example.com/?location={{ obj.name \",  # intentionally bad jinja2 to trigger error case",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "class DynamicGroupTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # NOTE: This isn't using `ViewTestCases.PrimaryObjectViewTestCase` because bulk-import/edit",
            "    # views for DynamicGroup do not make sense at this time, primarily because `content_type` is",
            "    # immutable after create.",
            "):",
            "    model = DynamicGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        # DynamicGroup objects to test.",
            "        DynamicGroup.objects.create(name=\"DG 1\", content_type=content_type)",
            "        DynamicGroup.objects.create(name=\"DG 2\", content_type=content_type)",
            "        DynamicGroup.objects.create(name=\"DG 3\", content_type=content_type)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_dynamic_group\",",
            "            \"description\": \"I am a new dynamic group object.\",",
            "            \"content_type\": content_type.pk,",
            "            # Management form fields required for the dynamic formset",
            "            \"dynamic_group_memberships-TOTAL_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-INITIAL_FORMS\": \"1\",",
            "            \"dynamic_group_memberships-MIN_NUM_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_get_object_dynamic_groups_anonymous(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_object_dynamic_groups_without_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_object_dynamic_groups_with_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.add_permissions(\"dcim.view_device\", \"extras.view_dynamicgroup\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 2\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 3\", response_body, msg=response_body)",
            "",
            "    def test_get_object_dynamic_groups_with_constrained_permission(self):",
            "        self.add_permissions(\"extras.view_dynamicgroup\")",
            "        obj_perm = ObjectPermission(",
            "            name=\"View a device\",",
            "            constraints={\"pk\": Device.objects.first().pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Device))",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.last().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_edit_saved_filter(self):",
            "        \"\"\"Test that editing a filter works using the edit view.\"\"\"",
            "        self.add_permissions(\"extras.add_dynamicgroup\", \"extras.change_dynamicgroup\")",
            "",
            "        # Create the object first.",
            "        data = self.form_data.copy()",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        # Now update it.",
            "        instance = self._get_queryset().get(name=data[\"name\"])",
            "        data[\"filter-serial\"] = [\"abc123\"]",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", instance),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.filter, {\"serial\": data[\"filter-serial\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_filter_by_content_type(self):",
            "        \"\"\"",
            "        Test that filtering by `content_type` in the UI succeeds.",
            "",
            "        This is a regression test for https://github.com/nautobot/nautobot/issues/3612",
            "        \"\"\"",
            "        path = self._get_url(\"list\")",
            "        response = self.client.get(path + \"?content_type=dcim.device\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class ExportTemplateTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ExportTemplate",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        templates = (",
            "            ExportTemplate(",
            "                name=\"template-1\",",
            "                template_code=\"template-1 test1\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-2\",",
            "                template_code=\"template-2 test2\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-3\",",
            "                template_code=\"template-3 test3\",",
            "                content_type=obj_type,",
            "            ),",
            "        )",
            "",
            "        for template in templates:",
            "            template.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"template-4\",",
            "            \"content_type\": obj_type.pk,",
            "            \"template_code\": \"template-4 test4\",",
            "        }",
            "",
            "",
            "class ExternalIntegrationTestCase(ViewTestCases.PrimaryObjectViewTestCase):",
            "    model = ExternalIntegration",
            "    bulk_edit_data = {\"timeout\": 10, \"verify_ssl\": True, \"extra_config\": r\"{}\", \"headers\": r\"{}\"}",
            "    form_data = {",
            "        \"name\": \"Test External Integration\",",
            "        \"remote_url\": \"https://example.com/test1/\",",
            "        \"verify_ssl\": False,",
            "        \"secrets_group\": None,",
            "        \"timeout\": 10,",
            "        \"extra_config\": '{\"foo\": \"bar\"}',",
            "        \"http_method\": WebhookHttpMethodChoices.METHOD_GET,",
            "        \"headers\": '{\"header\": \"fake header\"}',",
            "        \"ca_file_path\": \"this/is/a/file/path\",",
            "    }",
            "",
            "",
            "class GitRepositoryTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GitRepository",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\"),",
            "        )",
            "",
            "        # Create four GitRepository records",
            "        repos = (",
            "            GitRepository(name=\"Repo 1\", slug=\"repo_1\", remote_url=\"https://example.com/repo1.git\"),",
            "            GitRepository(name=\"Repo 2\", slug=\"repo_2\", remote_url=\"https://example.com/repo2.git\"),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo_3\", remote_url=\"https://example.com/repo3.git\"),",
            "            GitRepository(name=\"Repo 4\", remote_url=\"https://example.com/repo4.git\", secrets_group=secrets_groups[0]),",
            "        )",
            "        for repo in repos:",
            "            repo.validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"A new Git repository\",",
            "            \"slug\": \"a_new_git_repository\",",
            "            \"remote_url\": \"http://example.com/a_new_git_repository.git\",",
            "            \"branch\": \"develop\",",
            "            \"_token\": \"1234567890abcdef1234567890abcdef\",",
            "            \"secrets_group\": secrets_groups[1].pk,",
            "            \"provided_contents\": [",
            "                \"extras.configcontext\",",
            "                \"extras.job\",",
            "                \"extras.exporttemplate\",",
            "            ],",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Repo 4\"",
            "",
            "    def test_edit_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "        form_data = self.form_data.copy()",
            "        form_data[\"slug\"] = instance.slug  # Slug is not editable",
            "        self.form_data = form_data",
            "        super().test_edit_object_with_permission()",
            "",
            "    def test_edit_object_with_constrained_permission(self):",
            "        instance = self._get_queryset().first()",
            "        form_data = self.form_data.copy()",
            "        form_data[\"slug\"] = instance.slug  # Slug is not editable",
            "        self.form_data = form_data",
            "        super().test_edit_object_with_constrained_permission()",
            "",
            "    def test_post_sync_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_sync_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_pull_git_repository_and_refresh_data` and test successful POST with permissions",
            "",
            "    def test_post_dryrun_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_dryrun_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_git_repository_diff_origin_and_local` and test successful POST with permissions",
            "",
            "",
            "class NoteTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "):",
            "    model = Note",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Location)",
            "        cls.location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        user = User.objects.first()",
            "",
            "        # Notes Objects to test",
            "        Note.objects.create(",
            "            note=\"Location has been placed on maintenance.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.location.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Location maintenance has ended.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.location.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Location is under duress.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.location.pk,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"note\": \"This is Location note.\",",
            "            \"assigned_object_type\": content_type.pk,",
            "            \"assigned_object_id\": cls.location.pk,",
            "        }",
            "        cls.expected_object_note = '<textarea name=\"object_note\" cols=\"40\" rows=\"10\" class=\"form-control\" placeholder=\"Note\" id=\"id_object_note\"></textarea>'",
            "",
            "    def test_note_on_bulk_update_perms(self):",
            "        self.add_permissions(\"dcim.add_location\", \"extras.add_note\")",
            "        response = self.client.get(reverse(\"dcim:location_add\"))",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_bulk_update_no_perms(self):",
            "        self.add_permissions(\"dcim.add_location\")",
            "        response = self.client.get(reverse(\"dcim:location_add\"))",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_perms(self):",
            "        self.add_permissions(\"dcim.change_location\", \"extras.add_note\")",
            "        response = self.client.post(reverse(\"dcim:location_bulk_edit\"), data={\"pk\": self.location.pk})",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_no_perms(self):",
            "        self.add_permissions(\"dcim.change_location\")",
            "        response = self.client.post(reverse(\"dcim:location_bulk_edit\"), data={\"pk\": self.location.pk})",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "",
            "# Not a full-fledged PrimaryObjectViewTestCase as there's no BulkEditView for Secrets",
            "class SecretTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = Secret",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"View Test 1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_1\"},",
            "                tags=[t.pk for t in Tag.objects.get_for_model(Secret)],",
            "            ),",
            "            Secret(",
            "                name=\"View Test 2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"View Test 3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"View Test 4\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": '{\"variable\": \"VIEW_TEST_4\"}',",
            "        }",
            "",
            "",
            "class SecretsGroupTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = SecretsGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group 1\", description=\"First Group\"),",
            "            SecretsGroup.objects.create(name=\"Group 2\"),",
            "            SecretsGroup.objects.create(name=\"Group 3\"),",
            "        )",
            "",
            "        secrets = (",
            "            Secret.objects.create(name=\"secret 1\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            Secret.objects.create(name=\"secret 2\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            Secret.objects.create(name=\"secret 3\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),  # noqa: S108  # hardcoded-temp-file -- false positive",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secrets_group=secrets_groups[0],",
            "            secret=secrets[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secrets_group=secrets_groups[0],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secrets_group=secrets_groups[1],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Group 4\",",
            "            \"description\": \"Some description\",",
            "            # Management form fields required for the dynamic Secret formset",
            "            \"secrets_group_associations-TOTAL_FORMS\": \"0\",",
            "            \"secrets_group_associations-INITIAL_FORMS\": \"1\",",
            "            \"secrets_group_associations-MIN_NUM_FORMS\": \"0\",",
            "            \"secrets_group_associations-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "",
            "class GraphQLQueriesTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GraphQLQuery",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                query=\"{ query: locations {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"Graphql Query 5\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name } } }',",
            "            ),",
            "        )",
            "",
            "        for query in graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"graphql-query-4\",",
            "            \"query\": \"{query: locations {name}}\",",
            "        }",
            "",
            "",
            "#",
            "# Jobs, Scheduling, and Approvals",
            "#",
            "",
            "",
            "class ScheduledJobTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=timezone.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=timezone.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "    def test_only_enabled_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        # this should not appear, since it's not enabled",
            "        ScheduledJob.objects.create(",
            "            enabled=False,",
            "            name=\"test4\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    def test_non_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        def scheduled_job_factory(name, crontab):",
            "            ScheduledJob.objects.create(",
            "                enabled=True,",
            "                name=name,",
            "                task=\"pass.TestPass\",",
            "                interval=JobExecutionType.TYPE_CUSTOM,",
            "                user=self.user,",
            "                start_time=timezone.now(),",
            "                crontab=crontab,",
            "            )",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test5\", None)",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test6\", \"\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test7\", \"not_enough_values_to_unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test8\", \"one too many values to unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test9\", \"-1 * * * *\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test10\", \"invalid literal * * *\")",
            "",
            "    def test_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            enabled=True,",
            "            name=\"test11\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_CUSTOM,",
            "            user=self.user,",
            "            start_time=timezone.now(),",
            "            crontab=\"*/15 9,17 3 * 1-5\",",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(\"test11\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "",
            "class ApprovalQueueTestCase(",
            "    # It would be nice to use ViewTestCases.GetObjectViewTestCase as well,",
            "    # but we can't directly use it as it uses instance.get_absolute_url() rather than self._get_url(\"view\", instance)",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    # Many interactions with a ScheduledJob also require permissions to view the associated Job",
            "    user_permissions = (\"extras.view_job\",)",
            "",
            "    def _get_url(self, action, instance=None):",
            "        if action == \"list\":",
            "            return reverse(\"extras:scheduledjob_approval_queue_list\")",
            "        if action == \"view\" and instance is not None:",
            "            return reverse(\"extras:scheduledjob_approval_request_view\", kwargs={\"pk\": instance.pk})",
            "        raise ValueError(\"This override is only valid for list and view test cases\")",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job_model = Job.objects.get_for_class_path(\"dry_run.TestDryRun\")",
            "        self.job_model_2 = Job.objects.get_for_class_path(\"fail.TestFail\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"dry_run.TestDryRun\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=timezone.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"fail.TestFail\",",
            "            job_model=self.job_model_2,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "    def test_only_approvable_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test4\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=False,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    #",
            "    # Reimplementations of ViewTestCases.GetObjectViewTestCase test functions.",
            "    # Needed because those use instance.get_absolute_url() instead of self._get_url(\"view\", instance)...",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_get_object_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_without_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        with disable_warnings(\"django.request\"):",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance)), 403)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        # Add model-level permission",
            "        obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET with model-level permission",
            "        response = self.client.get(self._get_url(\"view\", instance))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "",
            "        # The object's display name or string representation should appear in the response",
            "        self.assertIn(getattr(instance, \"display\", str(instance)), response_body, msg=response_body)",
            "",
            "        # skip GetObjectViewTestCase checks for Relationships and Custom Fields since this isn't actually a detail view",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_constrained_permission(self):",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "        # Add object-level permission",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": instance1.pk},",
            "            # To get a different rendering flow than the \"test_get_object_with_permission\" test above,",
            "            # enable additional permissions for this object so that interaction buttons are rendered.",
            "            actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET to permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance1)), 200)",
            "",
            "        # Try GET to non-permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance2)), 404)",
            "",
            "    #",
            "    # Additional test cases specific to the job approval view",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_anonymous(self):",
            "        \"\"\"Anonymous users may not take any action with regard to job approval requests.\"\"\"",
            "        self.client.logout()",
            "        response = self.client.post(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run jobs\", response_body)",
            "        # No job was submitted",
            "        self.assertFalse(JobResult.objects.filter(name=self.job_model.name).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_not_runnable(self):",
            "        \"\"\"A non-enabled job cannot be dry-run.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"This job cannot be run at this time\", response_body)",
            "        # No job was submitted",
            "        self.assertFalse(JobResult.objects.filter(name=instance.job_model.name).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_job_run_permission(self):",
            "        \"\"\"A user without run_job permission cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        self.assertFalse(JobResult.objects.filter(name=instance.job_model.name).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_specific_job_run_permission(self):",
            "        \"\"\"A user without run_job permission FOR THAT SPECIFIC JOB cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "        data = {\"_dry_run\": True}",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance1.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        instance1.job_model.enabled = True",
            "        instance1.job_model.save()",
            "        instance2.job_model.enabled = True",
            "        instance2.job_model.save()",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance2), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        job_names = [instance1.job_model.name, instance2.job_model.name]",
            "        self.assertFalse(JobResult.objects.filter(name__in=job_names).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_post_dry_run_not_supported(self, _):",
            "        \"\"\"Request a dry run on a job that doesn't support dryrun.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = ScheduledJob.objects.filter(name=\"test2\").first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        # Job was not submitted",
            "        self.assertFalse(JobResult.objects.filter(name=instance.job_model.class_path).exists())",
            "        self.assertContains(response, \"This job does not support dryrun\")",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    @mock.patch(\"nautobot.extras.models.jobs.JobResult.enqueue_job\")",
            "    def test_post_dry_run_success(self, mock_enqueue_job, _):",
            "        \"\"\"Successfully request a dry run based on object-based run_job permissions.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = ScheduledJob.objects.filter(name=\"test1\").first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        data = {\"_dry_run\": True}",
            "",
            "        mock_enqueue_job.side_effect = lambda job_model, *args, **kwargs: JobResult.objects.create(name=job_model.name)",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        # Job was submitted",
            "        mock_enqueue_job.assert_called_once()",
            "        job_result = JobResult.objects.get(name=instance.job_model.name)",
            "        self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": job_result.pk}))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both delete_scheduledjob and approve_job permissions to deny a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 delete_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Delete\", actions=[\"delete\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not delete_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_deny\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Request was not deleted",
            "            self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can deny a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and delete_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"delete\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_deny\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Request was deleted",
            "        self.assertEqual(0, len(ScheduledJob.objects.filter(pk=instance.pk)))",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().first()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Request was not deleted",
            "        self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_cannot_self_approve(self):",
            "        self.add_permissions(\"extras.change_scheduledjob\")",
            "        self.add_permissions(\"extras.approve_job\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You cannot approve your own job request\", response_body)",
            "        # Job was not approved",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both change_scheduledjob and approve_job permissions to approve a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 change_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Change\", actions=[\"change\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not change_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Job was not approved",
            "            instance.refresh_from_db()",
            "            self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can approve a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and change_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"change\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_approve\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Job was scheduled",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.approved_by_user, user)",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().last()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Job was not scheduled",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "",
            "class JobResultTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = JobResult",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        JobResult.objects.create(name=\"pass.TestPass\")",
            "        JobResult.objects.create(name=\"fail.TestFail\")",
            "        JobLogEntry.objects.create(",
            "            log_level=LogLevelChoices.LOG_INFO,",
            "            job_result=JobResult.objects.first(),",
            "            grouping=\"run\",",
            "            message=\"This is a test\",",
            "        )",
            "",
            "    def test_get_joblogentrytable_anonymous(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_joblogentrytable_without_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_joblogentrytable_with_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.add_permissions(\"extras.view_jobresult\", \"extras.view_joblogentry\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"This is a test\", response_body)",
            "",
            "    # TODO test with constrained permissions on both JobResult and JobLogEntry records",
            "",
            "",
            "class JobTestCase(",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    \"\"\"",
            "    The Job view test cases.",
            "    \"\"\"",
            "",
            "    model = Job",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"Don't include hidden Jobs or non-installed Jobs, as they won't appear in the UI by default.\"\"\"",
            "        return self.model.objects.filter(installed=True, hidden=False)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Job model objects are automatically created during database migrations",
            "",
            "        # But we do need to make sure the ones we're testing are flagged appropriately",
            "        cls.test_pass = Job.objects.get(job_class_name=\"TestPass\")",
            "        cls.test_pass.enabled = True",
            "        cls.test_pass.save()",
            "",
            "        cls.run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": cls.test_pass.class_path}),",
            "            # Current URL (job model pk based)",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": cls.test_pass.pk}),",
            "        )",
            "",
            "        cls.test_required_args = Job.objects.get(job_class_name=\"TestRequired\")",
            "        cls.test_required_args.enabled = True",
            "        cls.test_required_args.save()",
            "",
            "        cls.extra_run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": cls.test_required_args.class_path}),",
            "            # Current URL (job model pk based)",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": cls.test_required_args.pk}),",
            "        )",
            "",
            "        # Create an entry for a non-installed Job as well",
            "        cls.test_not_installed = Job(",
            "            module_name=\"nonexistent\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Nonexistent Jobs\",",
            "            name=\"No such job\",",
            "            enabled=True,",
            "            installed=False,",
            "        )",
            "        cls.test_not_installed.validated_save()",
            "",
            "        cls.data_run_immediately = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "",
            "        cls.form_data = {",
            "            \"enabled\": True,",
            "            \"grouping_override\": True,",
            "            \"grouping\": \"Overridden Grouping\",",
            "            \"name_override\": True,",
            "            \"name\": \"Overridden Name\",",
            "            \"description_override\": True,",
            "            \"description\": \"This is an overridden description of a job.\",",
            "            \"dryrun_default_override\": True,",
            "            \"dryrun_default\": True,",
            "            \"hidden_override\": True,",
            "            \"hidden\": False,",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "            \"soft_time_limit_override\": True,",
            "            \"soft_time_limit\": 350,",
            "            \"time_limit_override\": True,",
            "            \"time_limit\": 650,",
            "            \"has_sensitive_variables\": False,",
            "            \"has_sensitive_variables_override\": True,",
            "            \"task_queues\": \"overridden,priority\",",
            "            \"task_queues_override\": True,",
            "        }",
            "        # This form is emulating the non-conventional JobBulkEditForm",
            "        cls.bulk_edit_data = {",
            "            \"enabled\": True,",
            "            \"clear_grouping_override\": True,",
            "            \"grouping\": \"\",",
            "            \"clear_description_override\": False,",
            "            \"description\": \"Overridden Description\",",
            "            \"clear_dryrun_default_override\": False,",
            "            \"dryrun_default\": \"\",",
            "            \"clear_hidden_override\": True,",
            "            \"hidden\": False,",
            "            \"clear_approval_required_override\": True,",
            "            \"approval_required\": True,",
            "            \"clear_soft_time_limit_override\": False,",
            "            \"soft_time_limit\": 350,",
            "            \"clear_time_limit_override\": True,",
            "            \"time_limit\": \"\",",
            "            \"has_sensitive_variables\": False,",
            "            \"clear_has_sensitive_variables_override\": False,",
            "            \"task_queues\": \"overridden,priority\",",
            "            \"clear_task_queues_override\": False,",
            "        }",
            "",
            "    def validate_job_data_after_bulk_edit(self, pk_list, old_data):",
            "        # Name is bulk-editable",
            "        overridable_fields = [field for field in JOB_OVERRIDABLE_FIELDS if field != \"name\"]",
            "        for instance in self._get_queryset().filter(pk__in=pk_list):",
            "            self.assertEqual(instance.enabled, True)",
            "            job_class = instance.job_class",
            "            if job_class is not None:",
            "                for overridable_field in overridable_fields:",
            "                    # clear_override_field is obtained from adding \"clear_\" to the front and \"_override\" to the back of overridable_field",
            "                    # e.g grouping -> clear_grouping_override",
            "                    clear_override_field = \"clear_\" + overridable_field + \"_override\"",
            "                    # override_field is obtained from adding \"_override\" to the back of overridable_field",
            "                    # e.g grouping -> grouping_override",
            "                    override_field = overridable_field + \"_override\"",
            "                    reset_override = self.bulk_edit_data.get(clear_override_field, False)",
            "                    if overridable_field == \"task_queues\":",
            "                        override_value = self.bulk_edit_data.get(overridable_field).split(\",\")",
            "                    else:",
            "                        override_value = self.bulk_edit_data.get(overridable_field)",
            "                    # if clear_override is true, assert that values are reverted back to default values",
            "                    if reset_override is True:",
            "                        self.assertEqual(getattr(instance, overridable_field), getattr(job_class, overridable_field))",
            "                        self.assertEqual(getattr(instance, override_field), False)",
            "                    # if clear_override is false, assert that job attribute is set to the new value from the form",
            "                    elif reset_override is False and (override_value is False or override_value):",
            "                        self.assertEqual(getattr(instance, overridable_field), override_value)",
            "                        self.assertEqual(getattr(instance, override_field), True)",
            "                    # if clear_override is false and no new value is entered, assert that value of the job is unchanged",
            "                    else:",
            "                        self.assertEqual(getattr(instance, overridable_field), old_data[instance.pk][overridable_field])",
            "                        self.assertEqual(getattr(instance, override_field), old_data[instance.pk][overridable_field])",
            "",
            "    def validate_object_data_after_bulk_edit(self, pk_list):",
            "        instances = self._get_queryset().filter(pk__in=pk_list)",
            "        overridable_fields = [field for field in JOB_OVERRIDABLE_FIELDS if field != \"name\"]",
            "        old_data = {}",
            "        for instance in instances:",
            "            old_data[instance.pk] = {}",
            "            job_class = instance.job_class",
            "            if job_class is not None:",
            "                for field in overridable_fields:",
            "                    old_data[instance.pk][field] = getattr(job_class, field)",
            "        self.validate_job_data_after_bulk_edit(pk_list, old_data)",
            "",
            "    #",
            "    # Additional test cases for the \"job\" (legacy run) and \"job_run\" (updated run) views follow",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 403, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_permission(self):",
            "        \"\"\"",
            "        Get view with appropriate global permissions.",
            "",
            "        Note that this view is conditional on run_job permission, not view_job permission,",
            "        so EXEMPT_VIEW_PERMISSIONS=[\"*\"] does NOT apply here.",
            "        \"\"\"",
            "        self.add_permissions(\"extras.run_job\")",
            "        for run_url in self.run_urls:",
            "            response = self.client.get(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"TestPass\", response_body)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_constrained_permission(self):",
            "        \"\"\"Get view with appropriate object-based permissions.\"\"\"",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try GET with a permitted object",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 200, msg=run_url)",
            "",
            "        # Try GET with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 404, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url), 403, msg=run_url)",
            "",
            "    def test_run_missing_schedule(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_type: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=0)",
            "    def test_run_now_no_worker(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Celery worker process not running.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_constrained_permissions(self, _):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        # Try POST with a permitted object",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertIsNotNone(result, msg=run_url)",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "        # Try POST with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url, self.data_run_immediately), 404, msg=run_url)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_installed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": self.test_not_installed.class_path}),",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": self.test_not_installed.pk}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not presently installed\", response_body)",
            "",
            "            self.assertFalse(JobResult.objects.filter(name=self.test_not_installed.name).exists())",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_enabled(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": \"fail.TestFail\"}),",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": Job.objects.get(job_class_name=\"TestFail\").pk}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not enabled to be run\", response_body)",
            "            self.assertFalse(JobResult.objects.filter(name=\"fail.TestFail\").exists())",
            "",
            "    def test_run_now_missing_args(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"var: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_with_args(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"var\": \"12\",",
            "        }",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, data)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.jobs.task_queues_as_choices\")",
            "    def test_rerun_job(self, mock_task_queues_as_choices):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        mock_task_queues_as_choices.return_value = [(\"default\", \"\"), (\"queue1\", \"\"), (\"uniquequeue\", \"\")]",
            "        job_celery_kwargs = {",
            "            \"nautobot_job_job_model_id\": self.test_required_args.id,",
            "            \"nautobot_job_profile\": True,",
            "            \"nautobot_job_user_id\": self.user.id,",
            "            \"queue\": \"uniquequeue\",",
            "        }",
            "",
            "        previous_result = JobResult.objects.create(",
            "            job_model=self.test_required_args,",
            "            user=self.user,",
            "            task_kwargs={\"var\": \"456\"},",
            "            celery_kwargs=job_celery_kwargs,",
            "        )",
            "",
            "        run_url = reverse(\"extras:job_run\", kwargs={\"pk\": self.test_required_args.pk})",
            "        response = self.client.get(f\"{run_url}?kwargs_from_job_result={previous_result.pk!s}\")",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "",
            "        self.assertInHTML('<option value=\"uniquequeue\" selected>', content)",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"var\" value=\"456\" class=\"form-control form-control\" required placeholder=\"None\" id=\"id_var\">',",
            "            content,",
            "        )",
            "        self.assertInHTML('<input type=\"hidden\" name=\"_profile\" value=\"True\" id=\"id__profile\">', content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_name(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_name: Please provide a name for the job schedule.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_date(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_date_passed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(timezone.now() - timedelta(minutes=1)),",
            "        }",
            "",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertRedirects(response, reverse(\"extras:scheduledjob_list\"))",
            "",
            "            scheduled = ScheduledJob.objects.get(name=f\"test {i}\")",
            "            self.assertEqual(scheduled.start_time, start_time)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_for_future(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.has_sensitive_variables_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Unable to schedule job: Job may have sensitive input variables.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_invalid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        self.test_pass.task_queues = []",
            "        self.test_pass.task_queues_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"_task_queue\": \"invalid\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [\"_task_queue: Select a valid choice. invalid is not one of the available choices.\"],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_and_requires_approval(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.approval_required = True",
            "        self.test_pass.save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "        for run_url in self.run_urls:",
            "            # Assert warning message shows in get",
            "            response = self.client.get(run_url)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\",",
            "                content,",
            "            )",
            "",
            "            # Assert run button is disabled",
            "            self.assertInHTML(",
            "                \"\"\"",
            "                <button type=\"submit\" name=\"_run\" id=\"id__run\" class=\"btn btn-primary\" disabled=\"disabled\">",
            "                    <i class=\"mdi mdi-play\"></i> Run Job Now",
            "                </button>",
            "                \"\"\",",
            "                content,",
            "            )",
            "            # Assert error message shows after post",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "                content,",
            "            )",
            "",
            "    def test_job_object_change_log_view(self):",
            "        \"\"\"Assert Job change log view displays appropriate header\"\"\"",
            "        instance = self.test_pass",
            "        self.add_permissions(\"extras.view_objectchange\", \"extras.view_job\")",
            "        response = self.client.get(instance.get_changelog_url())",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(f\"{instance.name} - Change Log\", content)",
            "",
            "",
            "class JobButtonTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobButton",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        job_buttons = (",
            "            JobButton.objects.create(",
            "                name=\"JobButton1\",",
            "                text=\"JobButton1\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=True,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton2\",",
            "                text=\"JobButton2\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=False,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton3\",",
            "                text=\"JobButton3\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "                confirmation=True,",
            "                weight=50,",
            "            ),",
            "        )",
            "",
            "        location_ct = ContentType.objects.get_for_model(Location)",
            "        for jb in job_buttons:",
            "            jb.content_types.set([location_ct])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [location_ct.pk],",
            "            \"name\": \"jobbutton-4\",",
            "            \"text\": \"jobbutton text 4\",",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"confirmation\": False,",
            "        }",
            "",
            "",
            "class JobButtonRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the rendering of JobButtons, distinct from tests of the JobButton views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job = Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\")",
            "        self.job_button_1 = JobButton(",
            "            name=\"JobButton 1\",",
            "            text=\"JobButton {{ obj.name }}\",",
            "            job=self.job,",
            "            confirmation=False,",
            "        )",
            "        self.job_button_1.validated_save()",
            "        self.job_button_1.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.job_button_2 = JobButton(",
            "            name=\"JobButton 2\",",
            "            text=\"Click me!\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            confirmation=False,",
            "        )",
            "        self.job_button_2.validated_save()",
            "        self.job_button_2.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_job_button(self):",
            "        \"\"\"Ensure that the job button is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"JobButton {self.location_type.name}\", content, content)",
            "        self.assertIn(\"Click me!\", content, content)",
            "",
            "    def test_task_queue_hidden_input_is_present(self):",
            "        \"\"\"",
            "        Ensure that the job button respects the job class' task_queues and the job class task_queues[0]/default is passed as a hidden form input.",
            "        \"\"\"",
            "        self.job.task_queues_override = True",
            "        self.job.task_queues = [\"overriden_queue\", \"default\", \"priority\"]",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f'<input type=\"hidden\" name=\"_task_queue\" value=\"{self.job.task_queues[0]}\">', content, content)",
            "        self.job.task_queues_override = False",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(",
            "            f'<input type=\"hidden\" name=\"_task_queue\" value=\"{settings.CELERY_TASK_DEFAULT_QUEUE}\">', content, content",
            "        )",
            "",
            "    def test_view_object_with_unsafe_text(self):",
            "        \"\"\"Ensure that JobButton text can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = '<script>alert(\"Hello world!\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "        # Make sure grouped rendering is safe too",
            "        self.job_button_1.group_name = '<script>alert(\"Goodbye\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_unsafe_name(self):",
            "        \"\"\"Ensure that JobButton names can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = \"JobButton {{ obj\"",
            "        self.job_button_1.name = '<script>alert(\"Yo\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_render_constrained_run_permissions(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.job_button_1.job.pk},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        with self.subTest(\"Ungrouped buttons\"):",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=self.job_button_1.button_class,",
            "                    disabled=\"\",",
            "                ),",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=self.job_button_2.button_class,",
            "                    disabled=\"disabled\",",
            "                ),",
            "                content,",
            "            )",
            "",
            "        with self.subTest(\"Grouped buttons\"):",
            "            self.job_button_1.group_name = \"Grouping\"",
            "            self.job_button_1.validated_save()",
            "            self.job_button_2.group_name = \"Grouping\"",
            "            self.job_button_2.validated_save()",
            "",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=\"link\",",
            "                    disabled=\"\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=\"link\",",
            "                    disabled=\"disabled\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "",
            "",
            "# TODO: Convert to StandardTestCases.Views",
            "class ObjectChangeTestCase(TestCase):",
            "    user_permissions = (\"extras.view_objectchange\",)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        location_status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Location 1\", location_type=location_type, status=location_status)",
            "        location.save()",
            "",
            "        # Create three ObjectChanges",
            "        user = User.objects.create_user(username=\"testuser2\")",
            "        for _ in range(1, 4):",
            "            oc = location.to_objectchange(action=ObjectChangeActionChoices.ACTION_UPDATE)",
            "            oc.user = user",
            "            oc.request_id = uuid.uuid4()",
            "            oc.save()",
            "",
            "    def test_objectchange_list(self):",
            "        url = reverse(\"extras:objectchange_list\")",
            "        params = {",
            "            \"user\": User.objects.first().pk,",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_objectchange(self):",
            "        objectchange = ObjectChange.objects.first()",
            "        response = self.client.get(objectchange.get_absolute_url())",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class RelationshipTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    RequiredRelationshipTestMixin,",
            "):",
            "    model = Relationship",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        interface_type = ContentType.objects.get_for_model(Interface)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "        status = Status.objects.get_for_model(Interface).first()",
            "",
            "        Relationship(",
            "            label=\"Device VLANs\",",
            "            key=\"device_vlans\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            label=\"Primary VLAN\",",
            "            key=\"primary_vlan\",",
            "            type=\"one-to-many\",",
            "            source_type=vlan_type,",
            "            destination_type=device_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            label=\"Primary Interface\",",
            "            type=\"one-to-one\",",
            "            source_type=device_type,",
            "            destination_type=interface_type,",
            "        ).validated_save()",
            "",
            "        cls.form_data = {",
            "            \"label\": \"VLAN-to-Interface\",",
            "            \"key\": \"vlan_to_interface\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": vlan_type.pk,",
            "            \"source_label\": \"Interfaces\",",
            "            \"source_hidden\": False,",
            "            \"source_filter\": '{\"status\": [\"' + status.name + '\"]}',",
            "            \"destination_type\": interface_type.pk,",
            "            \"destination_label\": \"VLANs\",",
            "            \"destination_hidden\": True,",
            "            \"destination_filter\": None,",
            "        }",
            "",
            "        cls.slug_test_object = \"Primary Interface\"",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test bulk edit",
            "        \"\"\"",
            "",
            "        # Delete existing factory generated objects that may interfere with this test",
            "        IPAddress.objects.all().delete()",
            "        Prefix.objects.update(parent=None)",
            "        Prefix.objects.all().delete()",
            "        VLAN.objects.all().delete()",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"ui\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        vlan_status = Status.objects.get_for_model(VLAN).first()",
            "        vlans = (",
            "            VLAN.objects.create(name=\"test_required_relationships1\", vid=1, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships2\", vid=2, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships3\", vid=3, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships4\", vid=4, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships5\", vid=5, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships6\", vid=6, status=vlan_status),",
            "        )",
            "",
            "        # Try deleting all devices and then editing the 6 VLANs (fails):",
            "        Controller.objects.filter(controller_device__isnull=False).delete()",
            "        Device.objects.all().delete()",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(response, \"VLANs require at least one device, but no devices exist yet.\")",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "",
            "        # Try editing all 6 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "        # Try editing 3 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans[:3]], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"These VLANs require a device for the required \"",
            "            \"relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "        for vlan in vlans[:3]:",
            "            self.assertContains(response, str(vlan))",
            "",
            "        # Try editing 6 VLANs and adding the required device (succeeds):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"add_cr_vlans_devices_m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertContains(response, \"Updated 6 VLANs\")",
            "",
            "        # Try editing 6 VLANs and removing the required device (fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"remove_cr_vlans_devices_m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "",
            "class RelationshipAssociationTestCase(",
            "    # TODO? ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    # TODO? ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # TODO? ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = RelationshipAssociation",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "",
            "        # Since RelationshipAssociation.get_absolute_url() is actually the Relationship's URL,",
            "        # we want to have separate Relationships as well to allow distinguishing between them.",
            "        relationship_1 = Relationship(",
            "            label=\"Device VLANs 1\",",
            "            key=\"device_vlans_1\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        relationship_2 = Relationship(",
            "            label=\"Device VLANs 2\",",
            "            key=\"device_vlans_2\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        relationship_3 = Relationship(",
            "            label=\"Device VLANs 3\",",
            "            key=\"device_vlans_3\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        cls.relationship = relationship_1",
            "        relationship_1.validated_save()",
            "        relationship_2.validated_save()",
            "        relationship_3.validated_save()",
            "        manufacturer = Manufacturer.objects.first()",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\")",
            "        devicerole = Role.objects.get_for_model(Device).first()",
            "        devicestatus = Status.objects.get_for_model(Device).first()",
            "        location = Location.objects.first()",
            "        devices = (",
            "            Device.objects.create(",
            "                name=\"Device 1\", device_type=devicetype, role=devicerole, location=location, status=devicestatus",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 2\", device_type=devicetype, role=devicerole, location=location, status=devicestatus",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 3\", device_type=devicetype, role=devicerole, location=location, status=devicestatus",
            "            ),",
            "        )",
            "        vlan_status = Status.objects.get_for_model(VLAN).first()",
            "        vlan_group = VLANGroup.objects.create(name=\"Test VLANGroup 1\")",
            "        vlans = (",
            "            VLAN.objects.create(vid=1, name=\"VLAN 1\", status=vlan_status, vlan_group=vlan_group),",
            "            VLAN.objects.create(vid=2, name=\"VLAN 2\", status=vlan_status, vlan_group=vlan_group),",
            "            VLAN.objects.create(vid=3, name=\"VLAN 3\", status=vlan_status, vlan_group=vlan_group),",
            "        )",
            "",
            "        RelationshipAssociation(",
            "            relationship=relationship_1,",
            "            source_type=device_type,",
            "            source_id=devices[0].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[0].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship_2,",
            "            source_type=device_type,",
            "            source_id=devices[1].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[1].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship_3,",
            "            source_type=device_type,",
            "            source_id=devices[2].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[2].pk,",
            "        ).validated_save()",
            "",
            "    def test_list_objects_with_constrained_permission(self):",
            "        instance1, instance2 = RelationshipAssociation.objects.all()[:2]",
            "",
            "        # Add object-level permission",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": instance1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "        self.assertIn(instance1.source.name, content, msg=content)",
            "        self.assertIn(instance1.destination.name, content, msg=content)",
            "        self.assertNotIn(instance2.source.name, content, msg=content)",
            "        self.assertNotIn(instance2.destination.name, content, msg=content)",
            "",
            "",
            "class StatusTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Status",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Status objects to test.",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_status\",",
            "            \"description\": \"I am a new status object.\",",
            "            \"color\": \"ffcc00\",",
            "            \"content_types\": [content_type.pk],",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"000000\",",
            "        }",
            "",
            "",
            "class TeamTestCase(ViewTestCases.PrimaryObjectViewTestCase):",
            "    model = Team",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"new team\",",
            "            \"phone\": \"555-0122\",",
            "            \"email\": \"new-team@example.com\",",
            "            \"address\": \"Rainbow Road, Ramus NJ\",",
            "        }",
            "        cls.bulk_edit_data = {\"address\": \"Carnegie Hall, New York, NY\"}",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_create_new_team_and_assign_team_to_object(self):",
            "        initial_team_count = Team.objects.count()",
            "        initial_team_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_team\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_team_add\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        team_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = team_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_team_count + 1, Team.objects.count())",
            "        self.assertEqual(initial_team_association_count + 1, ContactAssociation.objects.count())",
            "        team = Team.objects.get(name=\"new team\", phone=\"555-0122\")",
            "        self.assertEqual(team.name, \"new team\")",
            "        self.assertEqual(team.phone, \"555-0122\")",
            "        self.assertEqual(team.email, \"new-team@example.com\")",
            "        self.assertEqual(team.address, \"Rainbow Road, Ramus NJ\")",
            "        contact_association = ContactAssociation.objects.get(team=team)",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "",
            "class TagTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = Tag",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"Tag X\",",
            "            \"color\": \"c0c0c0\",",
            "            \"comments\": \"Some comments\",",
            "            \"content_types\": [ct.id for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"00ff00\",",
            "        }",
            "",
            "    def test_create_tags_with_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        location_content_type = ContentType.objects.get_for_model(Location)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [location_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        tag = Tag.objects.filter(name=self.form_data[\"name\"])",
            "        self.assertTrue(tag.exists())",
            "        self.assertEqual(tag[0].content_types.first(), location_content_type)",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        vlangroup_content_type = ContentType.objects.get_for_model(VLANGroup)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [vlangroup_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        tag = Tag.objects.filter(name=self.form_data[\"name\"])",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(\"content_types: Select a valid choice\", str(response.content))",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.get_for_model(Location).first()",
            "        location = Location.objects.first()",
            "        location.tags.add(tag_1)",
            "",
            "        form_data = {",
            "            \"name\": tag_1.name,",
            "            \"color\": \"c0c0c0\",",
            "            \"content_types\": [ContentType.objects.get_for_model(Device).id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", tag_1),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        self.assertHttpStatus(",
            "            response, 200, [\"content_types: Unable to remove dcim.location. Dependent objects were found.\"]",
            "        )",
            "",
            "",
            "class WebhookTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Webhook",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        webhooks = (",
            "            Webhook(",
            "                name=\"webhook-1\",",
            "                enabled=True,",
            "                type_create=True,",
            "                payload_url=\"http://test-url.com/test-1\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-2\",",
            "                enabled=True,",
            "                type_update=True,",
            "                payload_url=\"http://test-url.com/test-2\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-3\",",
            "                enabled=True,",
            "                type_delete=True,",
            "                payload_url=\"http://test-url.com/test-3\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(ConsolePort)",
            "",
            "        for webhook in webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"name\": \"webhook-4\",",
            "            \"content_types\": [obj_type.pk],",
            "            \"enabled\": True,",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://test-url.com/test-4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "        }",
            "",
            "",
            "class RoleTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = Role",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Status objects to test.",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"New Role\",",
            "            \"description\": \"I am a new role object.\",",
            "            \"color\": ColorChoices.COLOR_GREY,",
            "            \"content_types\": [content_type.pk],",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"000000\",",
            "        }",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_view_with_content_types(self):",
            "        \"\"\"",
            "        Check that the expected panel headings are rendered and unexpected panel headings are not rendered",
            "        \"\"\"",
            "        eligible_ct_model_classes = RoleModelsQuery().list_subclasses()",
            "        for instance in self._get_queryset().all():",
            "            response = self.client.get(instance.get_absolute_url())",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            role_content_types = instance.content_types.all()",
            "            for model_class in eligible_ct_model_classes:",
            "                verbose_name_plural = model_class._meta.verbose_name_plural",
            "                content_type = ContentType.objects.get_for_model(model_class)",
            "                result = \" \".join(elem.capitalize() for elem in verbose_name_plural.split())",
            "                if result == \"Ip Addresses\":",
            "                    result = \"IP Addresses\"",
            "                elif result == \"Vlans\":",
            "                    result = \"VLANs\"",
            "                # Assert tables are correctly rendered",
            "                if content_type not in role_content_types:",
            "                    if result == \"Contact Associations\":",
            "                        # AssociationContact Table in the contact tab should be there.",
            "                        self.assertIn(",
            "                            f'<strong>{result}</strong>\\n                                    <div class=\"pull-right noprint\">\\n',",
            "                            response_body,",
            "                        )",
            "                        # ContactAssociationTable related to this role instances should not be there.",
            "                        self.assertNotIn(",
            "                            f'<strong>{result}</strong>\\n            </div>\\n            \\n\\n<table class=\"table table-hover table-headings\">\\n',",
            "                            response_body,",
            "                        )",
            "                    else:",
            "                        self.assertNotIn(f\"<strong>{result}</strong>\", response_body)",
            "                else:",
            "                    self.assertIn(f\"<strong>{result}</strong>\", response_body)"
        ],
        "afterPatchFile": [
            "from datetime import timedelta",
            "from unittest import mock",
            "import urllib.parse",
            "import uuid",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ValidationError",
            "from django.test import override_settings",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.html import format_html",
            "",
            "from nautobot.circuits.models import Circuit",
            "from nautobot.core.choices import ColorChoices",
            "from nautobot.core.models.fields import slugify_dashes_to_underscores",
            "from nautobot.core.testing import extract_form_failures, extract_page_body, TestCase, ViewTestCases",
            "from nautobot.core.testing.utils import disable_warnings, post_data",
            "from nautobot.core.utils.permissions import get_permission_for_model",
            "from nautobot.dcim.models import (",
            "    ConsolePort,",
            "    Controller,",
            "    Device,",
            "    DeviceType,",
            "    Interface,",
            "    Location,",
            "    LocationType,",
            "    Manufacturer,",
            ")",
            "from nautobot.dcim.tests import test_views",
            "from nautobot.extras.choices import (",
            "    CustomFieldTypeChoices,",
            "    JobExecutionType,",
            "    LogLevelChoices,",
            "    ObjectChangeActionChoices,",
            "    SecretsGroupAccessTypeChoices,",
            "    SecretsGroupSecretTypeChoices,",
            "    WebhookHttpMethodChoices,",
            ")",
            "from nautobot.extras.constants import HTTP_CONTENT_TYPE_JSON, JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    Job,",
            "    JobButton,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    Team,",
            "    Webhook,",
            ")",
            "from nautobot.extras.templatetags.job_buttons import NO_CONFIRM_BUTTON",
            "from nautobot.extras.tests.constants import BIG_GRAPHQL_DEVICE_QUERY",
            "from nautobot.extras.tests.test_relationships import RequiredRelationshipTestMixin",
            "from nautobot.extras.utils import RoleModelsQuery, TaggableClassesQuery",
            "from nautobot.ipam.models import IPAddress, Prefix, VLAN, VLANGroup",
            "from nautobot.users.models import ObjectPermission",
            "",
            "# Use the proper swappable User model",
            "User = get_user_model()",
            "",
            "",
            "class ComputedFieldTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ComputedField",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        computed_fields = (",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field One\",",
            "                key=\"computed_field_one\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                key=\"computed_field_two\",",
            "                label=\"Computed Field Two\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                key=\"computed_field_three\",",
            "                label=\"Computed Field Three\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                weight=100,",
            "            ),",
            "            ComputedField(",
            "                content_type=obj_type,",
            "                label=\"Computed Field Five\",",
            "                template=\"Location name is {{ obj.name }}\",",
            "                fallback_value=\"Template error\",",
            "                weight=100,",
            "            ),",
            "        )",
            "        cls.location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        cls.location1 = Location(name=\"NYC\", location_type=cls.location_type, status=status)",
            "        cls.location1.save()",
            "",
            "        for cf in computed_fields:",
            "            cf.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"key\": \"computed_field_four\",",
            "            \"label\": \"Computed Field Four\",",
            "            \"template\": \"{{ obj.name }} is the best Location!\",",
            "            \"fallback_value\": \":skull_emoji:\",",
            "            \"weight\": 100,",
            "        }",
            "",
            "        cls.slug_test_object = \"Computed Field Five\"",
            "",
            "",
            "class ComputedFieldRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of ComputedFields, distinct from tests of the ComputedField views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.computedfield = ComputedField(",
            "            content_type=ContentType.objects.get_for_model(LocationType),",
            "            key=\"test\",",
            "            label=\"Computed Field\",",
            "            template=\"FOO {{ obj.name }} BAR\",",
            "            fallback_value=\"Fallback Value\",",
            "            weight=100,",
            "        )",
            "        self.computedfield.validated_save()",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_computed_field(self):",
            "        \"\"\"Ensure that the computed field template is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {self.location_type.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_computed_field_fallback_value(self):",
            "        \"\"\"Ensure that the fallback_value is rendered if the template fails to render.\"\"\"",
            "        # Make the template invalid to demonstrate the fallback value",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"Fallback Value\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_template(self):",
            "        \"\"\"Ensure that computed field templates can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_computed_field_unsafe_fallback_value(self):",
            "        \"\"\"Ensure that computed field fallback values can't be used as an XSS vector.\"\"\"",
            "        self.computedfield.template = \"FOO {{ obj.\"",
            "        self.computedfield.fallback_value = '<script>alert(\"Hello world!\"</script>'",
            "        self.computedfield.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "# TODO: Change base class to PrimaryObjectViewTestCase",
            "# Blocked by absence of standard create/edit, bulk create views",
            "class ConfigContextTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ConfigContext",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "",
            "        # Create three ConfigContexts",
            "        for i in range(1, 4):",
            "            configcontext = ConfigContext(name=f\"Config Context {i}\", data={\"foo\": i})",
            "            configcontext.save()",
            "            configcontext.locations.add(location)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Config Context X\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"locations\": [location.pk],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": 123}',",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"weight\": 300,",
            "            \"is_active\": False,",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "    def test_schema_validation_pass(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that conforms to that schema",
            "        Assert that the config context passes schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"locations\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"config_context_schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(",
            "            self._get_queryset().get(name=\"Config Context with schema\").config_context_schema.pk, schema.pk",
            "        )",
            "",
            "    def test_schema_validation_fails(self):",
            "        \"\"\"",
            "        Given a config context schema",
            "        And a config context that *does not* conform to that schema",
            "        Assert that the config context fails schema validation via full_clean()",
            "        \"\"\"",
            "        schema = ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"integer\"}}}",
            "        )",
            "        self.add_permissions(\"extras.add_configcontext\")",
            "        self.add_permissions(\"extras.view_configcontextschema\")",
            "",
            "        form_data = {",
            "            \"name\": \"Config Context with bad schema\",",
            "            \"weight\": 200,",
            "            \"description\": \"A new config context\",",
            "            \"is_active\": True,",
            "            \"regions\": [],",
            "            \"locations\": [],",
            "            \"roles\": [],",
            "            \"device_types\": [],",
            "            \"platforms\": [],",
            "            \"tenant_groups\": [],",
            "            \"tenants\": [],",
            "            \"tags\": [],",
            "            \"data\": '{\"foo\": \"bar\"}',",
            "            \"config_context_schema\": schema.pk,",
            "        }",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 200)",
            "        self.assertEqual(self._get_queryset().filter(name=\"Config Context with schema\").count(), 0)",
            "",
            "",
            "class ConfigContextSchemaTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = ConfigContextSchema",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Create three ConfigContextSchema records",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 1\", data_schema={\"type\": \"object\", \"properties\": {\"foo\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 2\", data_schema={\"type\": \"object\", \"properties\": {\"bar\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 3\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "        ConfigContextSchema.objects.create(",
            "            name=\"Schema 4\", data_schema={\"type\": \"object\", \"properties\": {\"baz\": {\"type\": \"string\"}}}",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Schema X\",",
            "            \"data_schema\": '{\"type\": \"object\",\"properties\": {\"baz\": {\"type\": \"string\"}}}',  # Intentionally misformatted (missing space) to ensure proper formatting on output",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"description\": \"New description\",",
            "        }",
            "",
            "",
            "class ContactTestCase(ViewTestCases.PrimaryObjectViewTestCase):",
            "    model = Contact",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"new contact\",",
            "            \"phone\": \"555-0121\",",
            "            \"email\": \"new-contact@example.com\",",
            "            \"address\": \"Rainbow Road, Ramus NJ\",",
            "        }",
            "        cls.bulk_edit_data = {\"address\": \"Carnegie Hall, New York, NY\", \"phone\": \"555-0125\"}",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_create_new_contact_and_assign_contact_to_object(self):",
            "        initial_contact_count = Contact.objects.count()",
            "        initial_contact_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_contact\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_contact_add\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        contact_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = contact_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_contact_count + 1, Contact.objects.count())",
            "        self.assertEqual(initial_contact_association_count + 1, ContactAssociation.objects.count())",
            "        contact = Contact.objects.get(name=\"new contact\", phone=\"555-0121\")",
            "        self.assertEqual(contact.name, \"new contact\")",
            "        self.assertEqual(contact.phone, \"555-0121\")",
            "        self.assertEqual(contact.email, \"new-contact@example.com\")",
            "        self.assertEqual(contact.address, \"Rainbow Road, Ramus NJ\")",
            "        contact_association = ContactAssociation.objects.get(contact=contact)",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "",
            "class ContactAssociationTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "):",
            "    model = ContactAssociation",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        roles = Role.objects.get_for_model(ContactAssociation)",
            "        statuses = Status.objects.get_for_model(ContactAssociation)",
            "        ip_addresses = IPAddress.objects.all()",
            "        cls.form_data = {",
            "            \"contact\": Contact.objects.first().pk,",
            "            \"team\": None,",
            "            \"associated_object_type\": ContentType.objects.get_for_model(Circuit).pk,",
            "            \"associated_object_id\": Circuit.objects.first().pk,",
            "            \"role\": roles[0].pk,",
            "            \"status\": statuses[0].pk,",
            "        }",
            "        cls.bulk_edit_data = {",
            "            \"role\": roles[1].pk,",
            "            \"status\": statuses[1].pk,",
            "        }",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[0].pk,",
            "            role=roles[2],",
            "            status=statuses[1],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            contact=Contact.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[1].pk,",
            "            role=roles[1],",
            "            status=statuses[2],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.first(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[2].pk,",
            "            role=roles[0],",
            "            status=statuses[0],",
            "        )",
            "        ContactAssociation.objects.create(",
            "            team=Team.objects.last(),",
            "            associated_object_type=ContentType.objects.get_for_model(IPAddress),",
            "            associated_object_id=ip_addresses[3].pk,",
            "            role=roles[0],",
            "            status=statuses[1],",
            "        )",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_assign_existing_contact_to_object(self):",
            "        contact = Contact.objects.first()",
            "        initial_contact_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_contact\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_contact_team_assign\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        contact_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = contact_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_contact_association_count + 1, ContactAssociation.objects.count())",
            "        self.assertEqual(contact.pk, self.form_data[\"contact\"])",
            "        contact_association = ContactAssociation.objects.get(",
            "            contact=contact, associated_object_id=contact_associated_circuit.pk",
            "        )",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_assign_existing_team_to_object(self):",
            "        team = Team.objects.first()",
            "        initial_contact_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_team\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_contact_team_assign\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        contact_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"team\"] = team.pk",
            "        self.form_data[\"contact\"] = None",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = contact_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_contact_association_count + 1, ContactAssociation.objects.count())",
            "        self.assertEqual(team.pk, self.form_data[\"team\"])",
            "        contact_association = ContactAssociation.objects.get(",
            "            team=team, associated_object_id=contact_associated_circuit.pk",
            "        )",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "",
            "class CustomLinkTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomLink",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        customlinks = (",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-1\",",
            "                text=\"customlink text 1\",",
            "                target_url=\"http://customlink1.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-2\",",
            "                text=\"customlink text 2\",",
            "                target_url=\"http://customlink2.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "            CustomLink(",
            "                content_type=obj_type,",
            "                name=\"customlink-3\",",
            "                text=\"customlink text 3\",",
            "                target_url=\"http://customlink3.com\",",
            "                weight=100,",
            "                button_class=\"default\",",
            "                new_window=False,",
            "            ),",
            "        )",
            "",
            "        for link in customlinks:",
            "            link.save()",
            "",
            "        cls.form_data = {",
            "            \"content_type\": obj_type.pk,",
            "            \"name\": \"customlink-4\",",
            "            \"text\": \"customlink text 4\",",
            "            \"target_url\": \"http://customlink4.com\",",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"new_window\": False,",
            "        }",
            "",
            "",
            "class CustomFieldTestCase(",
            "    # No NotesViewTestCase, at least for now",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = CustomField",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        custom_fields = [",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_BOOLEAN,",
            "                label=\"Custom Field Boolean Type\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                label=\"Custom Field Text\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_INTEGER,",
            "                label=\"Custom Field Integer\",",
            "                default=\"\",",
            "            ),",
            "            CustomField(",
            "                type=CustomFieldTypeChoices.TYPE_TEXT,",
            "                # https://github.com/nautobot/nautobot/issues/1962",
            "                label=\"Custom field? With special / unusual characters!\",",
            "                default=\"\",",
            "            ),",
            "        ]",
            "",
            "        cls.slug_test_object = \"Custom Field Integer\"",
            "",
            "        for custom_field in custom_fields:",
            "            custom_field.validated_save()",
            "            custom_field.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [obj_type.pk],",
            "            \"type\": CustomFieldTypeChoices.TYPE_BOOLEAN,  # type is mandatory but cannot be changed once set.",
            "            \"key\": \"custom_field_boolean_type\",  # key is mandatory but cannot be changed once set.",
            "            \"label\": \"Custom Field Boolean\",",
            "            \"default\": None,",
            "            \"filter_logic\": \"loose\",",
            "            \"weight\": 100,",
            "            # These are the \"management_form\" fields required by the dynamic CustomFieldChoice formsets.",
            "            \"custom_field_choices-TOTAL_FORMS\": \"0\",  # Set to 0 so validation succeeds until we need it",
            "            \"custom_field_choices-INITIAL_FORMS\": \"1\",",
            "            \"custom_field_choices-MIN_NUM_FORMS\": \"0\",",
            "            \"custom_field_choices-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_create_object_without_permission(self):",
            "        # Can't have two CustomFields with the same \"key\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"key\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_without_permission()",
            "",
            "    def test_create_object_with_permission(self):",
            "        # Can't have two CustomFields with the same \"key\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"key\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_permission()",
            "",
            "    def test_create_object_with_constrained_permission(self):",
            "        # Can't have two CustomFields with the same \"key\"",
            "        self.form_data = self.form_data.copy()",
            "        self.form_data[\"key\"] = \"custom_field_boolean_2\"",
            "        super().test_create_object_with_constrained_permission()",
            "",
            "",
            "class CustomLinkRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the inclusion of CustomLinks, distinct from tests of the CustomLink views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_location\"]",
            "",
            "    def test_view_object_with_custom_link(self):",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name=\"Test\",",
            "            text=\"FOO {{ obj.name }} BAR\",",
            "            target_url=\"http://example.com/?location={{ obj.name }}\",",
            "            new_window=False,",
            "        )",
            "        customlink.save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"FOO {location.name} BAR\", content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_text(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name=\"Test\",",
            "            text='<script>alert(\"Hello world!\")</script>',",
            "            target_url=\"http://example.com/?location=None\",",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_url(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name=\"Test\",",
            "            text=\"Hello\",",
            "            target_url='\"><script>alert(\"Hello world!\")</script><a href=\"',",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "        self.assertIn(format_html('<a href=\"{}\"', customlink.target_url), content, content)",
            "",
            "    def test_view_object_with_unsafe_custom_link_name(self):",
            "        \"\"\"Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.\"\"\"",
            "        customlink = CustomLink(",
            "            content_type=ContentType.objects.get_for_model(Location),",
            "            name='<script>alert(\"Hello World\")</script>',",
            "            text=\"Hello\",",
            "            target_url=\"http://example.com/?location={{ obj.name \",  # intentionally bad jinja2 to trigger error case",
            "            new_window=False,",
            "        )",
            "        customlink.validated_save()",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Test Location\", location_type=location_type, status=status)",
            "        location.save()",
            "",
            "        response = self.client.get(location.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "",
            "class DynamicGroupTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # NOTE: This isn't using `ViewTestCases.PrimaryObjectViewTestCase` because bulk-import/edit",
            "    # views for DynamicGroup do not make sense at this time, primarily because `content_type` is",
            "    # immutable after create.",
            "):",
            "    model = DynamicGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        # DynamicGroup objects to test.",
            "        cls.dynamic_groups = [",
            "            DynamicGroup.objects.create(name=\"DG 1\", content_type=content_type),",
            "            DynamicGroup.objects.create(name=\"DG 2\", content_type=content_type),",
            "            DynamicGroup.objects.create(name=\"DG 3\", content_type=content_type),",
            "        ]",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_dynamic_group\",",
            "            \"description\": \"I am a new dynamic group object.\",",
            "            \"content_type\": content_type.pk,",
            "            # Management form fields required for the dynamic formset",
            "            \"dynamic_group_memberships-TOTAL_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-INITIAL_FORMS\": \"1\",",
            "            \"dynamic_group_memberships-MIN_NUM_FORMS\": \"0\",",
            "            \"dynamic_group_memberships-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "    def test_get_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "        # Add view permissions for the group's members:",
            "        self.add_permissions(get_permission_for_model(instance.content_type.model_class(), \"view\"))",
            "",
            "        response = super().test_get_object_with_permission()",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        # Check that the \"members\" table in the detail view includes all appropriate member objects",
            "        for member in instance.members:",
            "            self.assertIn(str(member.pk), response_body)",
            "",
            "    def test_get_object_with_constrained_permission(self):",
            "        instance = self._get_queryset().first()",
            "        # Add view permission for one of the group's members but not the others:",
            "        member1, member2 = instance.members[:2]",
            "        obj_perm = ObjectPermission(",
            "            name=\"Members permission\",",
            "            constraints={\"pk\": member1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(instance.content_type)",
            "",
            "        response = super().test_get_object_with_constrained_permission()",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        # Check that the \"members\" table in the detail view includes all permitted member objects",
            "        self.assertIn(str(member1.pk), response_body)",
            "        self.assertNotIn(str(member2.pk), response_body)",
            "",
            "    def test_get_object_dynamic_groups_anonymous(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_object_dynamic_groups_without_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_object_dynamic_groups_with_permission(self):",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        self.add_permissions(\"dcim.view_device\", \"extras.view_dynamicgroup\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 2\", response_body, msg=response_body)",
            "        self.assertIn(\"DG 3\", response_body, msg=response_body)",
            "",
            "    def test_get_object_dynamic_groups_with_constrained_permission(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"View a device\",",
            "            constraints={\"pk\": Device.objects.first().pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Device))",
            "        obj_perm_2 = ObjectPermission(",
            "            name=\"View a Dynamic Group\",",
            "            constraints={\"pk\": self.dynamic_groups[0].pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm_2.save()",
            "        obj_perm_2.users.add(self.user)",
            "        obj_perm_2.object_types.add(ContentType.objects.get_for_model(DynamicGroup))",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"DG 1\", response_body, msg=response_body)",
            "        self.assertNotIn(\"DG 2\", response_body, msg=response_body)",
            "        self.assertNotIn(\"DG 3\", response_body, msg=response_body)",
            "",
            "        url = reverse(\"dcim:device_dynamicgroups\", kwargs={\"pk\": Device.objects.last().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 404)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_edit_saved_filter(self):",
            "        \"\"\"Test that editing a filter works using the edit view.\"\"\"",
            "        self.add_permissions(\"extras.add_dynamicgroup\", \"extras.change_dynamicgroup\")",
            "",
            "        # Create the object first.",
            "        data = self.form_data.copy()",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        # Now update it.",
            "        instance = self._get_queryset().get(name=data[\"name\"])",
            "        data[\"filter-serial\"] = [\"abc123\"]",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", instance),",
            "            \"data\": post_data(data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.filter, {\"serial\": data[\"filter-serial\"]})",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_filter_by_content_type(self):",
            "        \"\"\"",
            "        Test that filtering by `content_type` in the UI succeeds.",
            "",
            "        This is a regression test for https://github.com/nautobot/nautobot/issues/3612",
            "        \"\"\"",
            "        path = self._get_url(\"list\")",
            "        response = self.client.get(path + \"?content_type=dcim.device\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class ExportTemplateTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ExportTemplate",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        obj_type = ContentType.objects.get_for_model(Location)",
            "",
            "        templates = (",
            "            ExportTemplate(",
            "                name=\"template-1\",",
            "                template_code=\"template-1 test1\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-2\",",
            "                template_code=\"template-2 test2\",",
            "                content_type=obj_type,",
            "            ),",
            "            ExportTemplate(",
            "                name=\"template-3\",",
            "                template_code=\"template-3 test3\",",
            "                content_type=obj_type,",
            "            ),",
            "        )",
            "",
            "        for template in templates:",
            "            template.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"template-4\",",
            "            \"content_type\": obj_type.pk,",
            "            \"template_code\": \"template-4 test4\",",
            "        }",
            "",
            "",
            "class ExternalIntegrationTestCase(ViewTestCases.PrimaryObjectViewTestCase):",
            "    model = ExternalIntegration",
            "    bulk_edit_data = {\"timeout\": 10, \"verify_ssl\": True, \"extra_config\": r\"{}\", \"headers\": r\"{}\"}",
            "    form_data = {",
            "        \"name\": \"Test External Integration\",",
            "        \"remote_url\": \"https://example.com/test1/\",",
            "        \"verify_ssl\": False,",
            "        \"secrets_group\": None,",
            "        \"timeout\": 10,",
            "        \"extra_config\": '{\"foo\": \"bar\"}',",
            "        \"http_method\": WebhookHttpMethodChoices.METHOD_GET,",
            "        \"headers\": '{\"header\": \"fake header\"}',",
            "        \"ca_file_path\": \"this/is/a/file/path\",",
            "    }",
            "",
            "",
            "class GitRepositoryTestCase(",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GitRepository",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Secrets Group 1\"),",
            "            SecretsGroup.objects.create(name=\"Secrets Group 2\"),",
            "        )",
            "",
            "        # Create four GitRepository records",
            "        repos = (",
            "            GitRepository(name=\"Repo 1\", slug=\"repo_1\", remote_url=\"https://example.com/repo1.git\"),",
            "            GitRepository(name=\"Repo 2\", slug=\"repo_2\", remote_url=\"https://example.com/repo2.git\"),",
            "            GitRepository(name=\"Repo 3\", slug=\"repo_3\", remote_url=\"https://example.com/repo3.git\"),",
            "            GitRepository(name=\"Repo 4\", remote_url=\"https://example.com/repo4.git\", secrets_group=secrets_groups[0]),",
            "        )",
            "        for repo in repos:",
            "            repo.validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"A new Git repository\",",
            "            \"slug\": \"a_new_git_repository\",",
            "            \"remote_url\": \"http://example.com/a_new_git_repository.git\",",
            "            \"branch\": \"develop\",",
            "            \"_token\": \"1234567890abcdef1234567890abcdef\",",
            "            \"secrets_group\": secrets_groups[1].pk,",
            "            \"provided_contents\": [",
            "                \"extras.configcontext\",",
            "                \"extras.job\",",
            "                \"extras.exporttemplate\",",
            "            ],",
            "        }",
            "",
            "        cls.slug_source = \"name\"",
            "        cls.slug_test_object = \"Repo 4\"",
            "",
            "    def test_edit_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "        form_data = self.form_data.copy()",
            "        form_data[\"slug\"] = instance.slug  # Slug is not editable",
            "        self.form_data = form_data",
            "        super().test_edit_object_with_permission()",
            "",
            "    def test_edit_object_with_constrained_permission(self):",
            "        instance = self._get_queryset().first()",
            "        form_data = self.form_data.copy()",
            "        form_data[\"slug\"] = instance.slug  # Slug is not editable",
            "        self.form_data = form_data",
            "        super().test_edit_object_with_constrained_permission()",
            "",
            "    def test_post_sync_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_sync_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_sync\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_pull_git_repository_and_refresh_data` and test successful POST with permissions",
            "",
            "    def test_post_dryrun_repo_anonymous(self):",
            "        self.client.logout()",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_post_dryrun_repo_without_permission(self):",
            "        url = reverse(\"extras:gitrepository_dryrun\", kwargs={\"pk\": self._get_queryset().first().pk})",
            "        response = self.client.post(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    # TODO: mock/stub out `enqueue_git_repository_diff_origin_and_local` and test successful POST with permissions",
            "",
            "",
            "class NoteTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "):",
            "    model = Note",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        content_type = ContentType.objects.get_for_model(Location)",
            "        cls.location = Location.objects.filter(location_type=LocationType.objects.get(name=\"Campus\")).first()",
            "        user = User.objects.first()",
            "",
            "        # Notes Objects to test",
            "        Note.objects.create(",
            "            note=\"Location has been placed on maintenance.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.location.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Location maintenance has ended.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.location.pk,",
            "        )",
            "        Note.objects.create(",
            "            note=\"Location is under duress.\",",
            "            user=user,",
            "            assigned_object_type=content_type,",
            "            assigned_object_id=cls.location.pk,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"note\": \"This is Location note.\",",
            "            \"assigned_object_type\": content_type.pk,",
            "            \"assigned_object_id\": cls.location.pk,",
            "        }",
            "        cls.expected_object_note = '<textarea name=\"object_note\" cols=\"40\" rows=\"10\" class=\"form-control\" placeholder=\"Note\" id=\"id_object_note\"></textarea>'",
            "",
            "    def test_note_on_bulk_update_perms(self):",
            "        self.add_permissions(\"dcim.add_location\", \"extras.add_note\")",
            "        response = self.client.get(reverse(\"dcim:location_add\"))",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_bulk_update_no_perms(self):",
            "        self.add_permissions(\"dcim.add_location\")",
            "        response = self.client.get(reverse(\"dcim:location_add\"))",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_perms(self):",
            "        self.add_permissions(\"dcim.change_location\", \"extras.add_note\")",
            "        response = self.client.post(reverse(\"dcim:location_bulk_edit\"), data={\"pk\": self.location.pk})",
            "        self.assertContains(response, self.expected_object_note, html=True)",
            "",
            "    def test_note_on_create_edit_no_perms(self):",
            "        self.add_permissions(\"dcim.change_location\")",
            "        response = self.client.post(reverse(\"dcim:location_bulk_edit\"), data={\"pk\": self.location.pk})",
            "        self.assertNotContains(response, self.expected_object_note, html=True)",
            "",
            "",
            "# Not a full-fledged PrimaryObjectViewTestCase as there's no BulkEditView for Secrets",
            "class SecretTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = Secret",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets = (",
            "            Secret(",
            "                name=\"View Test 1\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_1\"},",
            "                tags=[t.pk for t in Tag.objects.get_for_model(Secret)],",
            "            ),",
            "            Secret(",
            "                name=\"View Test 2\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_2\"},",
            "            ),",
            "            Secret(",
            "                name=\"View Test 3\",",
            "                provider=\"environment-variable\",",
            "                parameters={\"variable\": \"VIEW_TEST_3\"},",
            "            ),",
            "        )",
            "",
            "        for secret in secrets:",
            "            secret.validated_save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"View Test 4\",",
            "            \"provider\": \"environment-variable\",",
            "            \"parameters\": '{\"variable\": \"VIEW_TEST_4\"}',",
            "        }",
            "",
            "",
            "class SecretsGroupTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = SecretsGroup",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        secrets_groups = (",
            "            SecretsGroup.objects.create(name=\"Group 1\", description=\"First Group\"),",
            "            SecretsGroup.objects.create(name=\"Group 2\"),",
            "            SecretsGroup.objects.create(name=\"Group 3\"),",
            "        )",
            "",
            "        secrets = (",
            "            Secret.objects.create(name=\"secret 1\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            Secret.objects.create(name=\"secret 2\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),  # noqa: S108  # hardcoded-temp-file -- false positive",
            "            Secret.objects.create(name=\"secret 3\", provider=\"text-file\", parameters={\"path\": \"/tmp\"}),  # noqa: S108  # hardcoded-temp-file -- false positive",
            "        )",
            "",
            "        SecretsGroupAssociation.objects.create(",
            "            secrets_group=secrets_groups[0],",
            "            secret=secrets[0],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_USERNAME,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secrets_group=secrets_groups[0],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "        SecretsGroupAssociation.objects.create(",
            "            secrets_group=secrets_groups[1],",
            "            secret=secrets[1],",
            "            access_type=SecretsGroupAccessTypeChoices.TYPE_GENERIC,",
            "            secret_type=SecretsGroupSecretTypeChoices.TYPE_PASSWORD,",
            "        )",
            "",
            "        cls.form_data = {",
            "            \"name\": \"Group 4\",",
            "            \"description\": \"Some description\",",
            "            # Management form fields required for the dynamic Secret formset",
            "            \"secrets_group_associations-TOTAL_FORMS\": \"0\",",
            "            \"secrets_group_associations-INITIAL_FORMS\": \"1\",",
            "            \"secrets_group_associations-MIN_NUM_FORMS\": \"0\",",
            "            \"secrets_group_associations-MAX_NUM_FORMS\": \"1000\",",
            "        }",
            "",
            "",
            "class GraphQLQueriesTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = GraphQLQuery",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        graphqlqueries = (",
            "            GraphQLQuery(",
            "                name=\"graphql-query-1\",",
            "                query=\"{ query: locations {name} }\",",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-2\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name } } }',",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"graphql-query-3\",",
            "                query=BIG_GRAPHQL_DEVICE_QUERY,",
            "            ),",
            "            GraphQLQuery(",
            "                name=\"Graphql Query 5\",",
            "                query='{ devices(role: \"edge\") { id, name, device_role { name } } }',",
            "            ),",
            "        )",
            "",
            "        for query in graphqlqueries:",
            "            query.full_clean()",
            "            query.save()",
            "",
            "        cls.form_data = {",
            "            \"name\": \"graphql-query-4\",",
            "            \"query\": \"{query: locations {name}}\",",
            "        }",
            "",
            "",
            "#",
            "# Jobs, Scheduling, and Approvals",
            "#",
            "",
            "",
            "class ScheduledJobTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        user = User.objects.create(username=\"user1\", is_active=True)",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=timezone.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=timezone.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test3\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=user,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "    def test_only_enabled_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        # this should not appear, since it's not enabled",
            "        ScheduledJob.objects.create(",
            "            enabled=False,",
            "            name=\"test4\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    def test_non_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        def scheduled_job_factory(name, crontab):",
            "            ScheduledJob.objects.create(",
            "                enabled=True,",
            "                name=name,",
            "                task=\"pass.TestPass\",",
            "                interval=JobExecutionType.TYPE_CUSTOM,",
            "                user=self.user,",
            "                start_time=timezone.now(),",
            "                crontab=crontab,",
            "            )",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test5\", None)",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test6\", \"\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test7\", \"not_enough_values_to_unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test8\", \"one too many values to unpack\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test9\", \"-1 * * * *\")",
            "",
            "        with self.assertRaises(ValidationError):",
            "            scheduled_job_factory(\"test10\", \"invalid literal * * *\")",
            "",
            "    def test_valid_crontab_syntax(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            enabled=True,",
            "            name=\"test11\",",
            "            task=\"pass.TestPass\",",
            "            interval=JobExecutionType.TYPE_CUSTOM,",
            "            user=self.user,",
            "            start_time=timezone.now(),",
            "            crontab=\"*/15 9,17 3 * 1-5\",",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(\"test11\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "",
            "class ApprovalQueueTestCase(",
            "    # It would be nice to use ViewTestCases.GetObjectViewTestCase as well,",
            "    # but we can't directly use it as it uses instance.get_absolute_url() rather than self._get_url(\"view\", instance)",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = ScheduledJob",
            "    # Many interactions with a ScheduledJob also require permissions to view the associated Job",
            "    user_permissions = (\"extras.view_job\",)",
            "",
            "    def _get_url(self, action, instance=None):",
            "        if action == \"list\":",
            "            return reverse(\"extras:scheduledjob_approval_queue_list\")",
            "        if action == \"view\" and instance is not None:",
            "            return reverse(\"extras:scheduledjob_approval_request_view\", kwargs={\"pk\": instance.pk})",
            "        raise ValueError(\"This override is only valid for list and view test cases\")",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job_model = Job.objects.get_for_class_path(\"dry_run.TestDryRun\")",
            "        self.job_model_2 = Job.objects.get_for_class_path(\"fail.TestFail\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test1\",",
            "            task=\"dry_run.TestDryRun\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=timezone.now(),",
            "        )",
            "        ScheduledJob.objects.create(",
            "            name=\"test2\",",
            "            task=\"fail.TestFail\",",
            "            job_model=self.job_model_2,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=True,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "    def test_only_approvable_is_listed(self):",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        ScheduledJob.objects.create(",
            "            name=\"test4\",",
            "            task=\"pass.TestPass\",",
            "            job_model=self.job_model,",
            "            interval=JobExecutionType.TYPE_IMMEDIATELY,",
            "            user=self.user,",
            "            approval_required=False,",
            "            start_time=timezone.now(),",
            "        )",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertNotIn(\"test4\", extract_page_body(response.content.decode(response.charset)))",
            "",
            "    #",
            "    # Reimplementations of ViewTestCases.GetObjectViewTestCase test functions.",
            "    # Needed because those use instance.get_absolute_url() instead of self._get_url(\"view\", instance)...",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_get_object_anonymous(self):",
            "        self.client.logout()",
            "        response = self.client.get(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_without_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        with disable_warnings(\"django.request\"):",
            "            self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance)), 403)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_permission(self):",
            "        instance = self._get_queryset().first()",
            "",
            "        # Add model-level permission",
            "        obj_perm = ObjectPermission(name=\"Test permission\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET with model-level permission",
            "        response = self.client.get(self._get_url(\"view\", instance))",
            "        self.assertHttpStatus(response, 200)",
            "",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "",
            "        # The object's display name or string representation should appear in the response",
            "        self.assertIn(getattr(instance, \"display\", str(instance)), response_body, msg=response_body)",
            "",
            "        # skip GetObjectViewTestCase checks for Relationships and Custom Fields since this isn't actually a detail view",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_object_with_constrained_permission(self):",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "",
            "        # Add object-level permission",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": instance1.pk},",
            "            # To get a different rendering flow than the \"test_get_object_with_permission\" test above,",
            "            # enable additional permissions for this object so that interaction buttons are rendered.",
            "            actions=[\"view\", \"add\", \"change\", \"delete\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        # Try GET to permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance1)), 200)",
            "",
            "        # Try GET to non-permitted object",
            "        self.assertHttpStatus(self.client.get(self._get_url(\"view\", instance2)), 404)",
            "",
            "    #",
            "    # Additional test cases specific to the job approval view",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_anonymous(self):",
            "        \"\"\"Anonymous users may not take any action with regard to job approval requests.\"\"\"",
            "        self.client.logout()",
            "        response = self.client.post(self._get_url(\"view\", self._get_queryset().first()))",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run jobs\", response_body)",
            "        # No job was submitted",
            "        self.assertFalse(JobResult.objects.filter(name=self.job_model.name).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_not_runnable(self):",
            "        \"\"\"A non-enabled job cannot be dry-run.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"This job cannot be run at this time\", response_body)",
            "        # No job was submitted",
            "        self.assertFalse(JobResult.objects.filter(name=instance.job_model.name).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_job_run_permission(self):",
            "        \"\"\"A user without run_job permission cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = self._get_queryset().first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        self.assertFalse(JobResult.objects.filter(name=instance.job_model.name).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_post_dry_run_needs_specific_job_run_permission(self):",
            "        \"\"\"A user without run_job permission FOR THAT SPECIFIC JOB cannot dry-run a job.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance1, instance2 = self._get_queryset().all()[:2]",
            "        data = {\"_dry_run\": True}",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance1.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        instance1.job_model.enabled = True",
            "        instance1.job_model.save()",
            "        instance2.job_model.enabled = True",
            "        instance2.job_model.save()",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance2), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission to run this job\", response_body)",
            "        # No job was submitted",
            "        job_names = [instance1.job_model.name, instance2.job_model.name]",
            "        self.assertFalse(JobResult.objects.filter(name__in=job_names).exists())",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_post_dry_run_not_supported(self, _):",
            "        \"\"\"Request a dry run on a job that doesn't support dryrun.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = ScheduledJob.objects.filter(name=\"test2\").first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        data = {\"_dry_run\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        # Job was not submitted",
            "        self.assertFalse(JobResult.objects.filter(name=instance.job_model.class_path).exists())",
            "        self.assertContains(response, \"This job does not support dryrun\")",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    @mock.patch(\"nautobot.extras.models.jobs.JobResult.enqueue_job\")",
            "    def test_post_dry_run_success(self, mock_enqueue_job, _):",
            "        \"\"\"Successfully request a dry run based on object-based run_job permissions.\"\"\"",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "        instance = ScheduledJob.objects.filter(name=\"test1\").first()",
            "        instance.job_model.enabled = True",
            "        instance.job_model.save()",
            "        obj_perm = ObjectPermission(name=\"Test permission\", constraints={\"pk\": instance.job_model.pk}, actions=[\"run\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "        data = {\"_dry_run\": True}",
            "",
            "        mock_enqueue_job.side_effect = lambda job_model, *args, **kwargs: JobResult.objects.create(name=job_model.name)",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        # Job was submitted",
            "        mock_enqueue_job.assert_called_once()",
            "        job_result = JobResult.objects.get(name=instance.job_model.name)",
            "        self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": job_result.pk}))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both delete_scheduledjob and approve_job permissions to deny a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 delete_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Delete\", actions=[\"delete\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not delete_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_deny\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Request was not deleted",
            "            self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_deny_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can deny a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and delete_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"delete\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_deny\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Request was deleted",
            "        self.assertEqual(0, len(ScheduledJob.objects.filter(pk=instance.pk)))",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().first()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Request was not deleted",
            "        self.assertEqual(1, len(ScheduledJob.objects.filter(pk=instance.pk)), msg=str(user))",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_cannot_self_approve(self):",
            "        self.add_permissions(\"extras.change_scheduledjob\")",
            "        self.add_permissions(\"extras.approve_job\")",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You cannot approve your own job request\", response_body)",
            "        # Job was not approved",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_lacking_permissions(self):",
            "        \"\"\"A user needs both change_scheduledjob and approve_job permissions to approve a job request.\"\"\"",
            "        user1 = User.objects.create_user(username=\"testuser1\")",
            "        user2 = User.objects.create_user(username=\"testuser2\")",
            "",
            "        # Give both users view_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1, user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user1 change_scheduledjob permission but not approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Change\", actions=[\"change\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user1)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user2 approve_job permission but not change_scheduledjob permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"])",
            "        obj_perm.save()",
            "        obj_perm.users.add(user2)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        instance = self._get_queryset().first()",
            "        data = {\"_approve\": True}",
            "",
            "        for user in (user1, user2):",
            "            self.client.force_login(user)",
            "            response = self.client.post(self._get_url(\"view\", instance), data)",
            "            self.assertHttpStatus(response, 200, msg=str(user))",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "            # Job was not approved",
            "            instance.refresh_from_db()",
            "            self.assertIsNone(instance.approved_by_user)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_post_approve_different_user_permitted(self):",
            "        \"\"\"A user with appropriate permissions can approve a job request.\"\"\"",
            "        user = User.objects.create_user(username=\"testuser1\")",
            "        instance = self._get_queryset().first()",
            "",
            "        # Give user view_scheduledjob and change_scheduledjob permissions",
            "        obj_perm = ObjectPermission(name=\"View\", actions=[\"view\", \"change\"], constraints={\"pk\": instance.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(ScheduledJob))",
            "",
            "        # Give user approve_job permission",
            "        obj_perm = ObjectPermission(name=\"Approve\", actions=[\"approve\"], constraints={\"pk\": instance.job_model.pk})",
            "        obj_perm.save()",
            "        obj_perm.users.add(user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        data = {\"_approve\": True}",
            "",
            "        self.client.force_login(user)",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertRedirects(response, reverse(\"extras:scheduledjob_approval_queue_list\"))",
            "        # Job was scheduled",
            "        instance.refresh_from_db()",
            "        self.assertEqual(instance.approved_by_user, user)",
            "",
            "        # Check object-based permissions are enforced for a different instance",
            "        instance = self._get_queryset().last()",
            "        response = self.client.post(self._get_url(\"view\", instance), data)",
            "        self.assertHttpStatus(response, 200, msg=str(user))",
            "        response_body = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(\"You do not have permission\", response_body, msg=str(user))",
            "        # Job was not scheduled",
            "        instance.refresh_from_db()",
            "        self.assertIsNone(instance.approved_by_user)",
            "",
            "",
            "class JobResultTestCase(",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "):",
            "    model = JobResult",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        JobResult.objects.create(name=\"pass.TestPass\")",
            "        JobResult.objects.create(name=\"fail.TestFail\")",
            "        JobLogEntry.objects.create(",
            "            log_level=LogLevelChoices.LOG_INFO,",
            "            job_result=JobResult.objects.first(),",
            "            grouping=\"run\",",
            "            message=\"This is a test\",",
            "        )",
            "",
            "    def test_get_joblogentrytable_anonymous(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.client.logout()",
            "        response = self.client.get(url, follow=True)",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertRedirects(response, f\"/login/?next={url}\")",
            "",
            "    def test_get_joblogentrytable_without_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, [403, 404])",
            "",
            "    def test_get_joblogentrytable_with_permission(self):",
            "        url = reverse(\"extras:jobresult_log-table\", kwargs={\"pk\": JobResult.objects.first().pk})",
            "        self.add_permissions(\"extras.view_jobresult\", \"extras.view_joblogentry\")",
            "        response = self.client.get(url)",
            "        self.assertHttpStatus(response, 200)",
            "        response_body = response.content.decode(response.charset)",
            "        self.assertIn(\"This is a test\", response_body)",
            "",
            "    # TODO test with constrained permissions on both JobResult and JobLogEntry records",
            "",
            "",
            "class JobTestCase(",
            "    # note no CreateObjectViewTestCase - we do not support user creation of Job records",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.BulkEditObjectsViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    \"\"\"",
            "    The Job view test cases.",
            "    \"\"\"",
            "",
            "    model = Job",
            "",
            "    def _get_queryset(self):",
            "        \"\"\"Don't include hidden Jobs or non-installed Jobs, as they won't appear in the UI by default.\"\"\"",
            "        return self.model.objects.filter(installed=True, hidden=False)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Job model objects are automatically created during database migrations",
            "",
            "        # But we do need to make sure the ones we're testing are flagged appropriately",
            "        cls.test_pass = Job.objects.get(job_class_name=\"TestPass\")",
            "        cls.test_pass.enabled = True",
            "        cls.test_pass.save()",
            "",
            "        cls.run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": cls.test_pass.class_path}),",
            "            # Current URL (job model pk based)",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": cls.test_pass.pk}),",
            "        )",
            "",
            "        cls.test_required_args = Job.objects.get(job_class_name=\"TestRequired\")",
            "        cls.test_required_args.enabled = True",
            "        cls.test_required_args.save()",
            "",
            "        cls.extra_run_urls = (",
            "            # Legacy URL (job class path based)",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": cls.test_required_args.class_path}),",
            "            # Current URL (job model pk based)",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": cls.test_required_args.pk}),",
            "        )",
            "",
            "        # Create an entry for a non-installed Job as well",
            "        cls.test_not_installed = Job(",
            "            module_name=\"nonexistent\",",
            "            job_class_name=\"NoSuchJob\",",
            "            grouping=\"Nonexistent Jobs\",",
            "            name=\"No such job\",",
            "            enabled=True,",
            "            installed=False,",
            "        )",
            "        cls.test_not_installed.validated_save()",
            "",
            "        cls.data_run_immediately = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "",
            "        cls.form_data = {",
            "            \"enabled\": True,",
            "            \"grouping_override\": True,",
            "            \"grouping\": \"Overridden Grouping\",",
            "            \"name_override\": True,",
            "            \"name\": \"Overridden Name\",",
            "            \"description_override\": True,",
            "            \"description\": \"This is an overridden description of a job.\",",
            "            \"dryrun_default_override\": True,",
            "            \"dryrun_default\": True,",
            "            \"hidden_override\": True,",
            "            \"hidden\": False,",
            "            \"approval_required_override\": True,",
            "            \"approval_required\": True,",
            "            \"soft_time_limit_override\": True,",
            "            \"soft_time_limit\": 350,",
            "            \"time_limit_override\": True,",
            "            \"time_limit\": 650,",
            "            \"has_sensitive_variables\": False,",
            "            \"has_sensitive_variables_override\": True,",
            "            \"task_queues\": \"overridden,priority\",",
            "            \"task_queues_override\": True,",
            "        }",
            "        # This form is emulating the non-conventional JobBulkEditForm",
            "        cls.bulk_edit_data = {",
            "            \"enabled\": True,",
            "            \"clear_grouping_override\": True,",
            "            \"grouping\": \"\",",
            "            \"clear_description_override\": False,",
            "            \"description\": \"Overridden Description\",",
            "            \"clear_dryrun_default_override\": False,",
            "            \"dryrun_default\": \"\",",
            "            \"clear_hidden_override\": True,",
            "            \"hidden\": False,",
            "            \"clear_approval_required_override\": True,",
            "            \"approval_required\": True,",
            "            \"clear_soft_time_limit_override\": False,",
            "            \"soft_time_limit\": 350,",
            "            \"clear_time_limit_override\": True,",
            "            \"time_limit\": \"\",",
            "            \"has_sensitive_variables\": False,",
            "            \"clear_has_sensitive_variables_override\": False,",
            "            \"task_queues\": \"overridden,priority\",",
            "            \"clear_task_queues_override\": False,",
            "        }",
            "",
            "    def validate_job_data_after_bulk_edit(self, pk_list, old_data):",
            "        # Name is bulk-editable",
            "        overridable_fields = [field for field in JOB_OVERRIDABLE_FIELDS if field != \"name\"]",
            "        for instance in self._get_queryset().filter(pk__in=pk_list):",
            "            self.assertEqual(instance.enabled, True)",
            "            job_class = instance.job_class",
            "            if job_class is not None:",
            "                for overridable_field in overridable_fields:",
            "                    # clear_override_field is obtained from adding \"clear_\" to the front and \"_override\" to the back of overridable_field",
            "                    # e.g grouping -> clear_grouping_override",
            "                    clear_override_field = \"clear_\" + overridable_field + \"_override\"",
            "                    # override_field is obtained from adding \"_override\" to the back of overridable_field",
            "                    # e.g grouping -> grouping_override",
            "                    override_field = overridable_field + \"_override\"",
            "                    reset_override = self.bulk_edit_data.get(clear_override_field, False)",
            "                    if overridable_field == \"task_queues\":",
            "                        override_value = self.bulk_edit_data.get(overridable_field).split(\",\")",
            "                    else:",
            "                        override_value = self.bulk_edit_data.get(overridable_field)",
            "                    # if clear_override is true, assert that values are reverted back to default values",
            "                    if reset_override is True:",
            "                        self.assertEqual(getattr(instance, overridable_field), getattr(job_class, overridable_field))",
            "                        self.assertEqual(getattr(instance, override_field), False)",
            "                    # if clear_override is false, assert that job attribute is set to the new value from the form",
            "                    elif reset_override is False and (override_value is False or override_value):",
            "                        self.assertEqual(getattr(instance, overridable_field), override_value)",
            "                        self.assertEqual(getattr(instance, override_field), True)",
            "                    # if clear_override is false and no new value is entered, assert that value of the job is unchanged",
            "                    else:",
            "                        self.assertEqual(getattr(instance, overridable_field), old_data[instance.pk][overridable_field])",
            "                        self.assertEqual(getattr(instance, override_field), old_data[instance.pk][overridable_field])",
            "",
            "    def validate_object_data_after_bulk_edit(self, pk_list):",
            "        instances = self._get_queryset().filter(pk__in=pk_list)",
            "        overridable_fields = [field for field in JOB_OVERRIDABLE_FIELDS if field != \"name\"]",
            "        old_data = {}",
            "        for instance in instances:",
            "            old_data[instance.pk] = {}",
            "            job_class = instance.job_class",
            "            if job_class is not None:",
            "                for field in overridable_fields:",
            "                    old_data[instance.pk][field] = getattr(job_class, field)",
            "        self.validate_job_data_after_bulk_edit(pk_list, old_data)",
            "",
            "    #",
            "    # Additional test cases for the \"job\" (legacy run) and \"job_run\" (updated run) views follow",
            "    #",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 403, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_permission(self):",
            "        \"\"\"",
            "        Get view with appropriate global permissions.",
            "",
            "        Note that this view is conditional on run_job permission, not view_job permission,",
            "        so EXEMPT_VIEW_PERMISSIONS=[\"*\"] does NOT apply here.",
            "        \"\"\"",
            "        self.add_permissions(\"extras.run_job\")",
            "        for run_url in self.run_urls:",
            "            response = self.client.get(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"TestPass\", response_body)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_get_run_with_constrained_permission(self):",
            "        \"\"\"Get view with appropriate object-based permissions.\"\"\"",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        # Try GET with a permitted object",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 200, msg=run_url)",
            "",
            "        # Try GET with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.get(run_url), 404, msg=run_url)",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[])",
            "    def test_run_without_permission(self):",
            "        for run_url in self.run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url), 403, msg=run_url)",
            "",
            "    def test_run_missing_schedule(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_type: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=0)",
            "    def test_run_now_no_worker(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Celery worker process not running.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_constrained_permissions(self, _):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Job permission\",",
            "            constraints={\"module_name\": self.test_pass.module_name},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        # Try POST with a permitted object",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertIsNotNone(result, msg=run_url)",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "        # Try POST with a non-permitted object",
            "        for run_url in self.extra_run_urls:",
            "            self.assertHttpStatus(self.client.post(run_url, self.data_run_immediately), 404, msg=run_url)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_installed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": self.test_not_installed.class_path}),",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": self.test_not_installed.pk}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not presently installed\", response_body)",
            "",
            "            self.assertFalse(JobResult.objects.filter(name=self.test_not_installed.name).exists())",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_not_enabled(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in (",
            "            reverse(\"extras:job_run_by_class_path\", kwargs={\"class_path\": \"fail.TestFail\"}),",
            "            reverse(\"extras:job_run\", kwargs={\"pk\": Job.objects.get(job_class_name=\"TestFail\").pk}),",
            "        ):",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertEqual(response.status_code, 200, msg=run_url)",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Job is not enabled to be run\", response_body)",
            "            self.assertFalse(JobResult.objects.filter(name=\"fail.TestFail\").exists())",
            "",
            "    def test_run_now_missing_args(self):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, self.data_run_immediately)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"var: This field is required.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_now_with_args(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"var\": \"12\",",
            "        }",
            "",
            "        for run_url in self.extra_run_urls:",
            "            response = self.client.post(run_url, data)",
            "",
            "            result = JobResult.objects.latest()",
            "            self.assertRedirects(response, reverse(\"extras:jobresult\", kwargs={\"pk\": result.pk}))",
            "",
            "    @mock.patch(\"nautobot.extras.jobs.task_queues_as_choices\")",
            "    def test_rerun_job(self, mock_task_queues_as_choices):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        mock_task_queues_as_choices.return_value = [(\"default\", \"\"), (\"queue1\", \"\"), (\"uniquequeue\", \"\")]",
            "        job_celery_kwargs = {",
            "            \"nautobot_job_job_model_id\": self.test_required_args.id,",
            "            \"nautobot_job_profile\": True,",
            "            \"nautobot_job_user_id\": self.user.id,",
            "            \"queue\": \"uniquequeue\",",
            "        }",
            "",
            "        previous_result = JobResult.objects.create(",
            "            job_model=self.test_required_args,",
            "            user=self.user,",
            "            task_kwargs={\"var\": \"456\"},",
            "            celery_kwargs=job_celery_kwargs,",
            "        )",
            "",
            "        run_url = reverse(\"extras:job_run\", kwargs={\"pk\": self.test_required_args.pk})",
            "        response = self.client.get(f\"{run_url}?kwargs_from_job_result={previous_result.pk!s}\")",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "",
            "        self.assertInHTML('<option value=\"uniquequeue\" selected>', content)",
            "        self.assertInHTML(",
            "            '<input type=\"text\" name=\"var\" value=\"456\" class=\"form-control form-control\" required placeholder=\"None\" id=\"id_var\">',",
            "            content,",
            "        )",
            "        self.assertInHTML('<input type=\"hidden\" name=\"_profile\" value=\"True\" id=\"id__profile\">', content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_name(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(errors, [\"_schedule_name: Please provide a name for the job schedule.\"])",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_missing_date(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "        }",
            "",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later_date_passed(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(timezone.now() - timedelta(minutes=1)),",
            "        }",
            "",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [",
            "                    \"_schedule_start_time: Please enter a valid date and time greater than or equal to the current date and time.\"",
            "                ],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_later(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertRedirects(response, reverse(\"extras:scheduledjob_list\"))",
            "",
            "            scheduled = ScheduledJob.objects.get(name=f\"test {i}\")",
            "            self.assertEqual(scheduled.start_time, start_time)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_for_future(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.has_sensitive_variables_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        start_time = timezone.now() + timedelta(minutes=1)",
            "        data = {",
            "            \"_schedule_type\": \"future\",",
            "            \"_schedule_name\": \"test\",",
            "            \"_schedule_start_time\": str(start_time),",
            "        }",
            "        for i, run_url in enumerate(self.run_urls):",
            "            data[\"_schedule_name\"] = f\"test {i}\"",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(\"Unable to schedule job: Job may have sensitive input variables.\", content)",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_invalid_task_queue(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_jobresult\")",
            "",
            "        self.test_pass.task_queues = []",
            "        self.test_pass.task_queues_override = True",
            "        self.test_pass.validated_save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "            \"_task_queue\": \"invalid\",",
            "        }",
            "",
            "        for run_url in self.run_urls:",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=run_url)",
            "",
            "            errors = extract_form_failures(response.content.decode(response.charset))",
            "            self.assertEqual(",
            "                errors,",
            "                [\"_task_queue: Select a valid choice. invalid is not one of the available choices.\"],",
            "            )",
            "",
            "    @mock.patch(\"nautobot.extras.views.get_worker_count\", return_value=1)",
            "    def test_run_job_with_sensitive_variables_and_requires_approval(self, _):",
            "        self.add_permissions(\"extras.run_job\")",
            "        self.add_permissions(\"extras.view_scheduledjob\")",
            "",
            "        self.test_pass.has_sensitive_variables = True",
            "        self.test_pass.approval_required = True",
            "        self.test_pass.save()",
            "",
            "        data = {",
            "            \"_schedule_type\": \"immediately\",",
            "        }",
            "        for run_url in self.run_urls:",
            "            # Assert warning message shows in get",
            "            response = self.client.get(run_url)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\",",
            "                content,",
            "            )",
            "",
            "            # Assert run button is disabled",
            "            self.assertInHTML(",
            "                \"\"\"",
            "                <button type=\"submit\" name=\"_run\" id=\"id__run\" class=\"btn btn-primary\" disabled=\"disabled\">",
            "                    <i class=\"mdi mdi-play\"></i> Run Job Now",
            "                </button>",
            "                \"\"\",",
            "                content,",
            "            )",
            "            # Assert error message shows after post",
            "            response = self.client.post(run_url, data)",
            "            self.assertHttpStatus(response, 200, msg=self.run_urls[1])",
            "",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertIn(",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "                content,",
            "            )",
            "",
            "    def test_job_object_change_log_view(self):",
            "        \"\"\"Assert Job change log view displays appropriate header\"\"\"",
            "        instance = self.test_pass",
            "        self.add_permissions(\"extras.view_objectchange\", \"extras.view_job\")",
            "        response = self.client.get(instance.get_changelog_url())",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "",
            "        self.assertHttpStatus(response, 200)",
            "        self.assertIn(f\"{instance.name} - Change Log\", content)",
            "",
            "",
            "class JobButtonTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = JobButton",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        job_buttons = (",
            "            JobButton.objects.create(",
            "                name=\"JobButton1\",",
            "                text=\"JobButton1\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=True,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton2\",",
            "                text=\"JobButton2\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\"),",
            "                confirmation=False,",
            "            ),",
            "            JobButton.objects.create(",
            "                name=\"JobButton3\",",
            "                text=\"JobButton3\",",
            "                job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "                confirmation=True,",
            "                weight=50,",
            "            ),",
            "        )",
            "",
            "        location_ct = ContentType.objects.get_for_model(Location)",
            "        for jb in job_buttons:",
            "            jb.content_types.set([location_ct])",
            "",
            "        cls.form_data = {",
            "            \"content_types\": [location_ct.pk],",
            "            \"name\": \"jobbutton-4\",",
            "            \"text\": \"jobbutton text 4\",",
            "            \"job\": Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\").pk,",
            "            \"weight\": 100,",
            "            \"button_class\": \"default\",",
            "            \"confirmation\": False,",
            "        }",
            "",
            "",
            "class JobButtonRenderingTestCase(TestCase):",
            "    \"\"\"Tests for the rendering of JobButtons, distinct from tests of the JobButton views themselves.\"\"\"",
            "",
            "    user_permissions = [\"dcim.view_locationtype\"]",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.job = Job.objects.get(job_class_name=\"TestJobButtonReceiverSimple\")",
            "        self.job_button_1 = JobButton(",
            "            name=\"JobButton 1\",",
            "            text=\"JobButton {{ obj.name }}\",",
            "            job=self.job,",
            "            confirmation=False,",
            "        )",
            "        self.job_button_1.validated_save()",
            "        self.job_button_1.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.job_button_2 = JobButton(",
            "            name=\"JobButton 2\",",
            "            text=\"Click me!\",",
            "            job=Job.objects.get(job_class_name=\"TestJobButtonReceiverComplex\"),",
            "            confirmation=False,",
            "        )",
            "        self.job_button_2.validated_save()",
            "        self.job_button_2.content_types.add(ContentType.objects.get_for_model(LocationType))",
            "",
            "        self.location_type = LocationType.objects.get(name=\"Campus\")",
            "",
            "    def test_view_object_with_job_button(self):",
            "        \"\"\"Ensure that the job button is rendered.\"\"\"",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f\"JobButton {self.location_type.name}\", content, content)",
            "        self.assertIn(\"Click me!\", content, content)",
            "",
            "    def test_task_queue_hidden_input_is_present(self):",
            "        \"\"\"",
            "        Ensure that the job button respects the job class' task_queues and the job class task_queues[0]/default is passed as a hidden form input.",
            "        \"\"\"",
            "        self.job.task_queues_override = True",
            "        self.job.task_queues = [\"overriden_queue\", \"default\", \"priority\"]",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(f'<input type=\"hidden\" name=\"_task_queue\" value=\"{self.job.task_queues[0]}\">', content, content)",
            "        self.job.task_queues_override = False",
            "        self.job.save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertIn(",
            "            f'<input type=\"hidden\" name=\"_task_queue\" value=\"{settings.CELERY_TASK_DEFAULT_QUEUE}\">', content, content",
            "        )",
            "",
            "    def test_view_object_with_unsafe_text(self):",
            "        \"\"\"Ensure that JobButton text can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = '<script>alert(\"Hello world!\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "        # Make sure grouped rendering is safe too",
            "        self.job_button_1.group_name = '<script>alert(\"Goodbye\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_view_object_with_unsafe_name(self):",
            "        \"\"\"Ensure that JobButton names can't be used as a vector for XSS.\"\"\"",
            "        self.job_button_1.text = \"JobButton {{ obj\"",
            "        self.job_button_1.name = '<script>alert(\"Yo\")</script>'",
            "        self.job_button_1.validated_save()",
            "        response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "        self.assertEqual(response.status_code, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        self.assertNotIn(\"<script>alert\", content, content)",
            "        self.assertIn(\"&lt;script&gt;alert\", content, content)",
            "",
            "    def test_render_constrained_run_permissions(self):",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": self.job_button_1.job.pk},",
            "            actions=[\"run\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(Job))",
            "",
            "        with self.subTest(\"Ungrouped buttons\"):",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=self.job_button_1.button_class,",
            "                    disabled=\"\",",
            "                ),",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=self.job_button_2.button_class,",
            "                    disabled=\"disabled\",",
            "                ),",
            "                content,",
            "            )",
            "",
            "        with self.subTest(\"Grouped buttons\"):",
            "            self.job_button_1.group_name = \"Grouping\"",
            "            self.job_button_1.validated_save()",
            "            self.job_button_2.group_name = \"Grouping\"",
            "            self.job_button_2.validated_save()",
            "",
            "            response = self.client.get(self.location_type.get_absolute_url(), follow=True)",
            "            self.assertEqual(response.status_code, 200)",
            "            content = extract_page_body(response.content.decode(response.charset))",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_1.pk,",
            "                    button_text=f\"JobButton {self.location_type.name}\",",
            "                    button_class=\"link\",",
            "                    disabled=\"\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "            self.assertInHTML(",
            "                \"<li>\"",
            "                + NO_CONFIRM_BUTTON.format(",
            "                    button_id=self.job_button_2.pk,",
            "                    button_text=\"Click me!\",",
            "                    button_class=\"link\",",
            "                    disabled=\"disabled\",",
            "                )",
            "                + \"</li>\",",
            "                content,",
            "            )",
            "",
            "",
            "# TODO: Convert to StandardTestCases.Views",
            "class ObjectChangeTestCase(TestCase):",
            "    user_permissions = (\"extras.view_objectchange\",)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        location_type = LocationType.objects.get(name=\"Campus\")",
            "        location_status = Status.objects.get_for_model(Location).first()",
            "        location = Location(name=\"Location 1\", location_type=location_type, status=location_status)",
            "        location.save()",
            "",
            "        # Create three ObjectChanges",
            "        user = User.objects.create_user(username=\"testuser2\")",
            "        for _ in range(1, 4):",
            "            oc = location.to_objectchange(action=ObjectChangeActionChoices.ACTION_UPDATE)",
            "            oc.user = user",
            "            oc.request_id = uuid.uuid4()",
            "            oc.save()",
            "",
            "    def test_objectchange_list(self):",
            "        url = reverse(\"extras:objectchange_list\")",
            "        params = {",
            "            \"user\": User.objects.first().pk,",
            "        }",
            "",
            "        response = self.client.get(f\"{url}?{urllib.parse.urlencode(params)}\")",
            "        self.assertHttpStatus(response, 200)",
            "",
            "    def test_objectchange(self):",
            "        objectchange = ObjectChange.objects.first()",
            "        response = self.client.get(objectchange.get_absolute_url())",
            "        self.assertHttpStatus(response, 200)",
            "",
            "",
            "class RelationshipTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "    RequiredRelationshipTestMixin,",
            "):",
            "    model = Relationship",
            "    slug_source = \"label\"",
            "    slugify_function = staticmethod(slugify_dashes_to_underscores)",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        interface_type = ContentType.objects.get_for_model(Interface)",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "        status = Status.objects.get_for_model(Interface).first()",
            "",
            "        Relationship(",
            "            label=\"Device VLANs\",",
            "            key=\"device_vlans\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            label=\"Primary VLAN\",",
            "            key=\"primary_vlan\",",
            "            type=\"one-to-many\",",
            "            source_type=vlan_type,",
            "            destination_type=device_type,",
            "        ).validated_save()",
            "        Relationship(",
            "            label=\"Primary Interface\",",
            "            type=\"one-to-one\",",
            "            source_type=device_type,",
            "            destination_type=interface_type,",
            "        ).validated_save()",
            "",
            "        cls.form_data = {",
            "            \"label\": \"VLAN-to-Interface\",",
            "            \"key\": \"vlan_to_interface\",",
            "            \"type\": \"many-to-many\",",
            "            \"source_type\": vlan_type.pk,",
            "            \"source_label\": \"Interfaces\",",
            "            \"source_hidden\": False,",
            "            \"source_filter\": '{\"status\": [\"' + status.name + '\"]}',",
            "            \"destination_type\": interface_type.pk,",
            "            \"destination_label\": \"VLANs\",",
            "            \"destination_hidden\": True,",
            "            \"destination_filter\": None,",
            "        }",
            "",
            "        cls.slug_test_object = \"Primary Interface\"",
            "",
            "    def test_required_relationships(self):",
            "        \"\"\"",
            "        1. Try creating an object when no required target object exists",
            "        2. Try creating an object without specifying required target object(s)",
            "        3. Try creating an object when all required data is present",
            "        4. Test bulk edit",
            "        \"\"\"",
            "",
            "        # Delete existing factory generated objects that may interfere with this test",
            "        IPAddress.objects.all().delete()",
            "        Prefix.objects.update(parent=None)",
            "        Prefix.objects.all().delete()",
            "        VLAN.objects.all().delete()",
            "",
            "        # Parameterized tests (for creating and updating single objects):",
            "        self.required_relationships_test(interact_with=\"ui\")",
            "",
            "        # 4. Bulk create/edit tests:",
            "",
            "        vlan_status = Status.objects.get_for_model(VLAN).first()",
            "        vlans = (",
            "            VLAN.objects.create(name=\"test_required_relationships1\", vid=1, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships2\", vid=2, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships3\", vid=3, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships4\", vid=4, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships5\", vid=5, status=vlan_status),",
            "            VLAN.objects.create(name=\"test_required_relationships6\", vid=6, status=vlan_status),",
            "        )",
            "",
            "        # Try deleting all devices and then editing the 6 VLANs (fails):",
            "        Controller.objects.filter(controller_device__isnull=False).delete()",
            "        Device.objects.all().delete()",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(response, \"VLANs require at least one device, but no devices exist yet.\")",
            "",
            "        # Create test device for association",
            "        device_for_association = test_views.create_test_device(\"VLAN Required Device\")",
            "",
            "        # Try editing all 6 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "        # Try editing 3 VLANs without adding the required device(fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"), data={\"pk\": [str(vlan.id) for vlan in vlans[:3]], \"_apply\": [\"\"]}",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"These VLANs require a device for the required \"",
            "            \"relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "        for vlan in vlans[:3]:",
            "            self.assertContains(response, str(vlan))",
            "",
            "        # Try editing 6 VLANs and adding the required device (succeeds):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"add_cr_vlans_devices_m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "            follow=True,",
            "        )",
            "        self.assertContains(response, \"Updated 6 VLANs\")",
            "",
            "        # Try editing 6 VLANs and removing the required device (fails):",
            "        response = self.client.post(",
            "            reverse(\"ipam:vlan_bulk_edit\"),",
            "            data={",
            "                \"pk\": [str(vlan.id) for vlan in vlans],",
            "                \"remove_cr_vlans_devices_m2m__source\": [str(device_for_association.id)],",
            "                \"_apply\": [\"\"],",
            "            },",
            "        )",
            "        self.assertContains(",
            "            response,",
            "            \"6 VLANs require a device for the required relationship &quot;VLANs require at least one Device&quot;\",",
            "        )",
            "",
            "",
            "class RelationshipAssociationTestCase(",
            "    # TODO? ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    # TODO? ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.BulkDeleteObjectsViewTestCase,",
            "    # TODO? ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = RelationshipAssociation",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        device_type = ContentType.objects.get_for_model(Device)",
            "        vlan_type = ContentType.objects.get_for_model(VLAN)",
            "",
            "        # Since RelationshipAssociation.get_absolute_url() is actually the Relationship's URL,",
            "        # we want to have separate Relationships as well to allow distinguishing between them.",
            "        relationship_1 = Relationship(",
            "            label=\"Device VLANs 1\",",
            "            key=\"device_vlans_1\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        relationship_2 = Relationship(",
            "            label=\"Device VLANs 2\",",
            "            key=\"device_vlans_2\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        relationship_3 = Relationship(",
            "            label=\"Device VLANs 3\",",
            "            key=\"device_vlans_3\",",
            "            type=\"many-to-many\",",
            "            source_type=device_type,",
            "            destination_type=vlan_type,",
            "        )",
            "        cls.relationship = relationship_1",
            "        relationship_1.validated_save()",
            "        relationship_2.validated_save()",
            "        relationship_3.validated_save()",
            "        manufacturer = Manufacturer.objects.first()",
            "        devicetype = DeviceType.objects.create(manufacturer=manufacturer, model=\"Device Type 1\")",
            "        devicerole = Role.objects.get_for_model(Device).first()",
            "        devicestatus = Status.objects.get_for_model(Device).first()",
            "        location = Location.objects.first()",
            "        devices = (",
            "            Device.objects.create(",
            "                name=\"Device 1\", device_type=devicetype, role=devicerole, location=location, status=devicestatus",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 2\", device_type=devicetype, role=devicerole, location=location, status=devicestatus",
            "            ),",
            "            Device.objects.create(",
            "                name=\"Device 3\", device_type=devicetype, role=devicerole, location=location, status=devicestatus",
            "            ),",
            "        )",
            "        vlan_status = Status.objects.get_for_model(VLAN).first()",
            "        vlan_group = VLANGroup.objects.create(name=\"Test VLANGroup 1\")",
            "        vlans = (",
            "            VLAN.objects.create(vid=1, name=\"VLAN 1\", status=vlan_status, vlan_group=vlan_group),",
            "            VLAN.objects.create(vid=2, name=\"VLAN 2\", status=vlan_status, vlan_group=vlan_group),",
            "            VLAN.objects.create(vid=3, name=\"VLAN 3\", status=vlan_status, vlan_group=vlan_group),",
            "        )",
            "",
            "        RelationshipAssociation(",
            "            relationship=relationship_1,",
            "            source_type=device_type,",
            "            source_id=devices[0].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[0].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship_2,",
            "            source_type=device_type,",
            "            source_id=devices[1].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[1].pk,",
            "        ).validated_save()",
            "        RelationshipAssociation(",
            "            relationship=relationship_3,",
            "            source_type=device_type,",
            "            source_id=devices[2].pk,",
            "            destination_type=vlan_type,",
            "            destination_id=vlans[2].pk,",
            "        ).validated_save()",
            "",
            "    def test_list_objects_with_constrained_permission(self):",
            "        instance1, instance2 = RelationshipAssociation.objects.all()[:2]",
            "",
            "        # Add object-level permission",
            "        obj_perm = ObjectPermission(",
            "            name=\"Test permission\",",
            "            constraints={\"pk\": instance1.pk},",
            "            actions=[\"view\"],",
            "        )",
            "        obj_perm.save()",
            "        obj_perm.users.add(self.user)",
            "        obj_perm.object_types.add(ContentType.objects.get_for_model(self.model))",
            "",
            "        response = self.client.get(self._get_url(\"list\"))",
            "        self.assertHttpStatus(response, 200)",
            "        content = extract_page_body(response.content.decode(response.charset))",
            "        # TODO: it'd make test failures more readable if we strip the page headers/footers from the content",
            "        self.assertIn(instance1.source.name, content, msg=content)",
            "        self.assertIn(instance1.destination.name, content, msg=content)",
            "        self.assertNotIn(instance2.source.name, content, msg=content)",
            "        self.assertNotIn(instance2.destination.name, content, msg=content)",
            "",
            "",
            "class StatusTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Status",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Status objects to test.",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"new_status\",",
            "            \"description\": \"I am a new status object.\",",
            "            \"color\": \"ffcc00\",",
            "            \"content_types\": [content_type.pk],",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"000000\",",
            "        }",
            "",
            "",
            "class TeamTestCase(ViewTestCases.PrimaryObjectViewTestCase):",
            "    model = Team",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"new team\",",
            "            \"phone\": \"555-0122\",",
            "            \"email\": \"new-team@example.com\",",
            "            \"address\": \"Rainbow Road, Ramus NJ\",",
            "        }",
            "        cls.bulk_edit_data = {\"address\": \"Carnegie Hall, New York, NY\"}",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_create_new_team_and_assign_team_to_object(self):",
            "        initial_team_count = Team.objects.count()",
            "        initial_team_association_count = ContactAssociation.objects.count()",
            "        self.add_permissions(\"extras.add_team\")",
            "        self.add_permissions(\"extras.add_contactassociation\")",
            "",
            "        # Try GET with model-level permission",
            "        url = reverse(\"extras:object_team_add\")",
            "        self.assertHttpStatus(self.client.get(url), 200)",
            "        team_associated_circuit = Circuit.objects.first()",
            "        self.form_data[\"associated_object_type\"] = ContentType.objects.get_for_model(Circuit).pk",
            "        self.form_data[\"associated_object_id\"] = team_associated_circuit.pk",
            "        self.form_data[\"role\"] = Role.objects.get_for_model(ContactAssociation).first().pk",
            "        self.form_data[\"status\"] = Status.objects.get_for_model(ContactAssociation).first().pk",
            "",
            "        # Try POST with model-level permission",
            "        request = {",
            "            \"path\": url,",
            "            \"data\": post_data(self.form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "        self.assertEqual(initial_team_count + 1, Team.objects.count())",
            "        self.assertEqual(initial_team_association_count + 1, ContactAssociation.objects.count())",
            "        team = Team.objects.get(name=\"new team\", phone=\"555-0122\")",
            "        self.assertEqual(team.name, \"new team\")",
            "        self.assertEqual(team.phone, \"555-0122\")",
            "        self.assertEqual(team.email, \"new-team@example.com\")",
            "        self.assertEqual(team.address, \"Rainbow Road, Ramus NJ\")",
            "        contact_association = ContactAssociation.objects.get(team=team)",
            "        self.assertEqual(contact_association.associated_object_type.pk, self.form_data[\"associated_object_type\"])",
            "        self.assertEqual(contact_association.associated_object_id, self.form_data[\"associated_object_id\"])",
            "        self.assertEqual(contact_association.role.pk, self.form_data[\"role\"])",
            "        self.assertEqual(contact_association.status.pk, self.form_data[\"status\"])",
            "",
            "",
            "class TagTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = Tag",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.form_data = {",
            "            \"name\": \"Tag X\",",
            "            \"color\": \"c0c0c0\",",
            "            \"comments\": \"Some comments\",",
            "            \"content_types\": [ct.id for ct in TaggableClassesQuery().as_queryset()],",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"00ff00\",",
            "        }",
            "",
            "    def test_create_tags_with_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        location_content_type = ContentType.objects.get_for_model(Location)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [location_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "        self.assertHttpStatus(self.client.post(**request), 302)",
            "",
            "        tag = Tag.objects.filter(name=self.form_data[\"name\"])",
            "        self.assertTrue(tag.exists())",
            "        self.assertEqual(tag[0].content_types.first(), location_content_type)",
            "",
            "    def test_create_tags_with_invalid_content_types(self):",
            "        self.add_permissions(\"extras.add_tag\")",
            "        vlangroup_content_type = ContentType.objects.get_for_model(VLANGroup)",
            "",
            "        form_data = {",
            "            **self.form_data,",
            "            \"content_types\": [vlangroup_content_type.id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"add\"),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        tag = Tag.objects.filter(name=self.form_data[\"name\"])",
            "        self.assertFalse(tag.exists())",
            "        self.assertIn(\"content_types: Select a valid choice\", str(response.content))",
            "",
            "    def test_update_tags_remove_content_type(self):",
            "        \"\"\"Test removing a tag content_type that is been tagged to a model\"\"\"",
            "        self.add_permissions(\"extras.change_tag\")",
            "",
            "        tag_1 = Tag.objects.get_for_model(Location).first()",
            "        location = Location.objects.first()",
            "        location.tags.add(tag_1)",
            "",
            "        form_data = {",
            "            \"name\": tag_1.name,",
            "            \"color\": \"c0c0c0\",",
            "            \"content_types\": [ContentType.objects.get_for_model(Device).id],",
            "        }",
            "",
            "        request = {",
            "            \"path\": self._get_url(\"edit\", tag_1),",
            "            \"data\": post_data(form_data),",
            "        }",
            "",
            "        response = self.client.post(**request)",
            "        self.assertHttpStatus(",
            "            response, 200, [\"content_types: Unable to remove dcim.location. Dependent objects were found.\"]",
            "        )",
            "",
            "",
            "class WebhookTestCase(",
            "    ViewTestCases.CreateObjectViewTestCase,",
            "    ViewTestCases.DeleteObjectViewTestCase,",
            "    ViewTestCases.EditObjectViewTestCase,",
            "    ViewTestCases.GetObjectViewTestCase,",
            "    ViewTestCases.GetObjectChangelogViewTestCase,",
            "    ViewTestCases.ListObjectsViewTestCase,",
            "):",
            "    model = Webhook",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        webhooks = (",
            "            Webhook(",
            "                name=\"webhook-1\",",
            "                enabled=True,",
            "                type_create=True,",
            "                payload_url=\"http://test-url.com/test-1\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-2\",",
            "                enabled=True,",
            "                type_update=True,",
            "                payload_url=\"http://test-url.com/test-2\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "            Webhook(",
            "                name=\"webhook-3\",",
            "                enabled=True,",
            "                type_delete=True,",
            "                payload_url=\"http://test-url.com/test-3\",",
            "                http_content_type=HTTP_CONTENT_TYPE_JSON,",
            "            ),",
            "        )",
            "",
            "        obj_type = ContentType.objects.get_for_model(ConsolePort)",
            "",
            "        for webhook in webhooks:",
            "            webhook.save()",
            "            webhook.content_types.set([obj_type])",
            "",
            "        cls.form_data = {",
            "            \"name\": \"webhook-4\",",
            "            \"content_types\": [obj_type.pk],",
            "            \"enabled\": True,",
            "            \"type_create\": True,",
            "            \"payload_url\": \"http://test-url.com/test-4\",",
            "            \"http_method\": \"POST\",",
            "            \"http_content_type\": \"application/json\",",
            "        }",
            "",
            "",
            "class RoleTestCase(ViewTestCases.OrganizationalObjectViewTestCase):",
            "    model = Role",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        # Status objects to test.",
            "        content_type = ContentType.objects.get_for_model(Device)",
            "",
            "        cls.form_data = {",
            "            \"name\": \"New Role\",",
            "            \"description\": \"I am a new role object.\",",
            "            \"color\": ColorChoices.COLOR_GREY,",
            "            \"content_types\": [content_type.pk],",
            "        }",
            "",
            "        cls.bulk_edit_data = {",
            "            \"color\": \"000000\",",
            "        }",
            "",
            "    @override_settings(EXEMPT_VIEW_PERMISSIONS=[\"*\"])",
            "    def test_view_with_content_types(self):",
            "        \"\"\"",
            "        Check that the expected panel headings are rendered and unexpected panel headings are not rendered",
            "        \"\"\"",
            "        eligible_ct_model_classes = RoleModelsQuery().list_subclasses()",
            "        for instance in self._get_queryset().all():",
            "            response = self.client.get(instance.get_absolute_url())",
            "            response_body = extract_page_body(response.content.decode(response.charset))",
            "            role_content_types = instance.content_types.all()",
            "            for model_class in eligible_ct_model_classes:",
            "                verbose_name_plural = model_class._meta.verbose_name_plural",
            "                content_type = ContentType.objects.get_for_model(model_class)",
            "                result = \" \".join(elem.capitalize() for elem in verbose_name_plural.split())",
            "                if result == \"Ip Addresses\":",
            "                    result = \"IP Addresses\"",
            "                elif result == \"Vlans\":",
            "                    result = \"VLANs\"",
            "                # Assert tables are correctly rendered",
            "                if content_type not in role_content_types:",
            "                    if result == \"Contact Associations\":",
            "                        # AssociationContact Table in the contact tab should be there.",
            "                        self.assertIn(",
            "                            f'<strong>{result}</strong>\\n                                    <div class=\"pull-right noprint\">\\n',",
            "                            response_body,",
            "                        )",
            "                        # ContactAssociationTable related to this role instances should not be there.",
            "                        self.assertNotIn(",
            "                            f'<strong>{result}</strong>\\n            </div>\\n            \\n\\n<table class=\"table table-hover table-headings\">\\n',",
            "                            response_body,",
            "                        )",
            "                    else:",
            "                        self.assertNotIn(f\"<strong>{result}</strong>\", response_body)",
            "                else:",
            "                    self.assertIn(f\"<strong>{result}</strong>\", response_body)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "780": [
                "DynamicGroupTestCase",
                "setUpTestData"
            ],
            "781": [
                "DynamicGroupTestCase",
                "setUpTestData"
            ],
            "782": [
                "DynamicGroupTestCase",
                "setUpTestData"
            ],
            "818": [
                "DynamicGroupTestCase",
                "test_get_object_dynamic_groups_with_constrained_permission"
            ]
        },
        "addLocation": []
    },
    "nautobot/extras/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 704,
                "afterPatchRowNumber": 704,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 705,
                "afterPatchRowNumber": 705,
                "PatchRowcode": "         if table_class is not None:"
            },
            "2": {
                "beforePatchRowNumber": 706,
                "afterPatchRowNumber": 706,
                "PatchRowcode": "             # Members table (for display on Members nav tab)"
            },
            "3": {
                "beforePatchRowNumber": 707,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            members_table = table_class(instance.members, orderable=False)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 707,
                "PatchRowcode": "+            members_table = table_class(instance.members.restrict(request.user, \"view\"), orderable=False)"
            },
            "5": {
                "beforePatchRowNumber": 708,
                "afterPatchRowNumber": 708,
                "PatchRowcode": "             paginate = {"
            },
            "6": {
                "beforePatchRowNumber": 709,
                "afterPatchRowNumber": 709,
                "PatchRowcode": "                 \"paginator_class\": EnhancedPaginator,"
            },
            "7": {
                "beforePatchRowNumber": 710,
                "afterPatchRowNumber": 710,
                "PatchRowcode": "                 \"per_page\": get_paginate_count(request),"
            },
            "8": {
                "beforePatchRowNumber": 884,
                "afterPatchRowNumber": 884,
                "PatchRowcode": "             obj = get_object_or_404(model, **kwargs)"
            },
            "9": {
                "beforePatchRowNumber": 885,
                "afterPatchRowNumber": 885,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 886,
                "afterPatchRowNumber": 886,
                "PatchRowcode": "         # Gather all dynamic groups for this object (and its related objects)"
            },
            "11": {
                "beforePatchRowNumber": 887,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        dynamicsgroups_table = tables.DynamicGroupTable(data=obj.dynamic_groups_cached, orderable=False)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+        dynamicsgroups_table = tables.DynamicGroupTable("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 888,
                "PatchRowcode": "+            data=obj.dynamic_groups_cached.restrict(request.user, \"view\"), orderable=False"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 889,
                "PatchRowcode": "+        )"
            },
            "15": {
                "beforePatchRowNumber": 888,
                "afterPatchRowNumber": 890,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 889,
                "afterPatchRowNumber": 891,
                "PatchRowcode": "         # Apply the request context"
            },
            "17": {
                "beforePatchRowNumber": 890,
                "afterPatchRowNumber": 892,
                "PatchRowcode": "         paginate = {"
            }
        },
        "frontPatchFile": [
            "from datetime import timedelta",
            "import logging",
            "",
            "from celery import chain",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.db import transaction",
            "from django.db.models import ProtectedError, Q",
            "from django.forms.utils import pretty_name",
            "from django.http import Http404, HttpResponse, HttpResponseForbidden",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.template.loader import get_template, TemplateDoesNotExist",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.encoding import iri_to_uri",
            "from django.utils.html import format_html",
            "from django.utils.http import url_has_allowed_host_and_scheme",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "from jsonschema.validators import Draft7Validator",
            "",
            "from nautobot.core.forms import restrict_form_fields",
            "from nautobot.core.models.querysets import count_related",
            "from nautobot.core.models.utils import pretty_print_query",
            "from nautobot.core.tables import ButtonsColumn",
            "from nautobot.core.utils.lookup import get_table_for_model",
            "from nautobot.core.utils.requests import normalize_querydict",
            "from nautobot.core.views import generic, viewsets",
            "from nautobot.core.views.mixins import (",
            "    ObjectBulkDestroyViewMixin,",
            "    ObjectBulkUpdateViewMixin,",
            "    ObjectDestroyViewMixin,",
            "    ObjectEditViewMixin,",
            "    ObjectPermissionRequiredMixin,",
            ")",
            "from nautobot.core.views.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.core.views.utils import prepare_cloned_fields",
            "from nautobot.core.views.viewsets import NautobotUIViewSet",
            "from nautobot.dcim.models import Controller, Device, Interface, Location, Rack",
            "from nautobot.dcim.tables import ControllerTable, DeviceTable, RackTable",
            "from nautobot.extras.constants import JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.signals import change_context_state",
            "from nautobot.extras.tasks import delete_custom_field_data",
            "from nautobot.extras.utils import get_base_template, get_worker_count",
            "from nautobot.ipam.models import IPAddress, Prefix, VLAN",
            "from nautobot.ipam.tables import IPAddressTable, PrefixTable, VLANTable",
            "from nautobot.virtualization.models import VirtualMachine, VMInterface",
            "from nautobot.virtualization.tables import VirtualMachineTable",
            "",
            "from . import filters, forms, tables",
            "from .api import serializers",
            "from .choices import JobExecutionType, JobResultStatusChoices, LogLevelChoices",
            "from .datasources import (",
            "    enqueue_git_repository_diff_origin_and_local,",
            "    enqueue_pull_git_repository_and_refresh_data,",
            "    get_datasource_contents,",
            ")",
            "from .jobs import get_job",
            "from .models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job as JobModel,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Team,",
            "    Webhook,",
            ")",
            "from .registry import registry",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldListView(generic.ObjectListView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "    filterset = filters.ComputedFieldFilterSet",
            "    filterset_form = forms.ComputedFieldFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ComputedFieldView(generic.ObjectView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldEditView(generic.ObjectEditView):",
            "    queryset = ComputedField.objects.all()",
            "    model_form = forms.ComputedFieldForm",
            "    template_name = \"extras/computedfield_edit.html\"",
            "",
            "",
            "class ComputedFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "    filterset = filters.ComputedFieldFilterSet",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config contexts that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextListView(generic.ObjectListView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    filterset_form = forms.ConfigContextFilterForm",
            "    table = tables.ConfigContextTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextView(generic.ObjectView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            context[\"format\"] = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", context[\"format\"], commit=True)",
            "        elif request.user.is_authenticated:",
            "            context[\"format\"] = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            context[\"format\"] = \"json\"",
            "",
            "        return context",
            "",
            "",
            "class ConfigContextEditView(generic.ObjectEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    model_form = forms.ConfigContextForm",
            "    template_name = \"extras/configcontext_edit.html\"",
            "",
            "",
            "class ConfigContextBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    table = tables.ConfigContextTable",
            "    form = forms.ConfigContextBulkEditForm",
            "",
            "",
            "class ConfigContextDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "",
            "class ConfigContextBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "    table = tables.ConfigContextTable",
            "    filterset = filters.ConfigContextFilterSet",
            "",
            "",
            "class ObjectConfigContextView(generic.ObjectView):",
            "    base_template = None",
            "    template_name = \"extras/object_configcontext.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        source_contexts = ConfigContext.objects.restrict(request.user, \"view\").get_for_object(instance)",
            "",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"rendered_context\": instance.get_config_context(),",
            "            \"source_contexts\": source_contexts,",
            "            \"format\": format_,",
            "            \"base_template\": self.base_template,",
            "            \"active_tab\": \"config-context\",",
            "        }",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config context schemas that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextSchemaListView(generic.ObjectListView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    filterset_form = forms.ConfigContextSchemaFilterForm",
            "    table = tables.ConfigContextSchemaTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextSchemaView(generic.ObjectView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            context[\"format\"] = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontextschema.format\", context[\"format\"], commit=True)",
            "        elif request.user.is_authenticated:",
            "            context[\"format\"] = request.user.get_config(\"extras.configcontextschema.format\", \"json\")",
            "        else:",
            "            context[\"format\"] = \"json\"",
            "",
            "        return context",
            "",
            "",
            "class ConfigContextSchemaObjectValidationView(generic.ObjectView):",
            "    \"\"\"",
            "    This view renders a detail tab that shows tables of objects that utilize the given schema object",
            "    and their validation state.",
            "    \"\"\"",
            "",
            "    queryset = ConfigContextSchema.objects.all()",
            "    template_name = \"extras/configcontextschema_validation.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Reuse the model tables for config context, device, and virtual machine but inject",
            "        the `ConfigContextSchemaValidationStateColumn` and an object edit action button.",
            "        \"\"\"",
            "        # Prep the validator with the schema so it can be reused for all records",
            "        validator = Draft7Validator(instance.data_schema)",
            "",
            "        # Config context table",
            "        config_context_table = tables.ConfigContextTable(",
            "            data=instance.config_contexts.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=ConfigContext, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(config_context_table)",
            "",
            "        # Device table",
            "        device_table = DeviceTable(",
            "            data=instance.devices.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(",
            "                        validator, \"local_config_context_data\", empty_values=()",
            "                    ),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=Device, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        # Virtual machine table",
            "        virtual_machine_table = VirtualMachineTable(",
            "            data=instance.virtual_machines.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(",
            "                        validator, \"local_config_context_data\", empty_values=()",
            "                    ),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=VirtualMachine, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(virtual_machine_table)",
            "",
            "        return {",
            "            \"config_context_table\": config_context_table,",
            "            \"device_table\": device_table,",
            "            \"virtual_machine_table\": virtual_machine_table,",
            "            \"active_tab\": \"validation\",",
            "        }",
            "",
            "",
            "class ConfigContextSchemaEditView(generic.ObjectEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    model_form = forms.ConfigContextSchemaForm",
            "    template_name = \"extras/configcontextschema_edit.html\"",
            "",
            "",
            "class ConfigContextSchemaBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    table = tables.ConfigContextSchemaTable",
            "    form = forms.ConfigContextSchemaBulkEditForm",
            "",
            "",
            "class ConfigContextSchemaDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "",
            "class ConfigContextSchemaBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    table = tables.ConfigContextSchemaTable",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "",
            "",
            "#",
            "# Contacts",
            "#",
            "",
            "",
            "class ContactUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.ContactBulkEditForm",
            "    filterset_class = filters.ContactFilterSet",
            "    filterset_form_class = forms.ContactFilterForm",
            "    form_class = forms.ContactForm",
            "    queryset = Contact.objects.all()",
            "    serializer_class = serializers.ContactSerializer",
            "    table_class = tables.ContactTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        if self.action == \"retrieve\":",
            "            teams = instance.teams.restrict(request.user, \"view\")",
            "            teams_table = tables.TeamTable(teams, orderable=False)",
            "            teams_table.columns.hide(\"actions\")",
            "            paginate = {\"paginator_class\": EnhancedPaginator, \"per_page\": get_paginate_count(request)}",
            "            RequestConfig(request, paginate).configure(teams_table)",
            "            context[\"teams_table\"] = teams_table",
            "",
            "            # TODO: need some consistent ordering of contact_associations",
            "            associations = instance.contact_associations.restrict(request.user, \"view\")",
            "            associations_table = tables.ContactAssociationTable(associations, orderable=False)",
            "            RequestConfig(request, paginate).configure(associations_table)",
            "            context[\"contact_associations_table\"] = associations_table",
            "        return context",
            "",
            "",
            "class ContactAssociationUIViewSet(",
            "    ObjectBulkDestroyViewMixin,",
            "    ObjectBulkUpdateViewMixin,",
            "    ObjectDestroyViewMixin,",
            "    ObjectEditViewMixin,",
            "):",
            "    bulk_update_form_class = forms.ContactAssociationBulkEditForm",
            "    form_class = forms.ContactAssociationForm",
            "    filterset_class = filters.ContactAssociationFilterSet",
            "    queryset = ContactAssociation.objects.all()",
            "    serializer_class = serializers.ContactAssociationSerializer",
            "    table_class = tables.AssociatedContactsTable",
            "    non_filter_params = (\"export\", \"page\", \"per_page\", \"sort\")",
            "",
            "",
            "class ObjectContactTeamMixin:",
            "    \"\"\"Mixin that contains a custom post() method to create a new contact/team and assign it to an existing object\"\"\"",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "                if isinstance(obj, Contact):",
            "                    association = ContactAssociation(",
            "                        contact=obj,",
            "                        associated_object_type=ContentType.objects.get(id=request.POST.get(\"associated_object_type\")),",
            "                        associated_object_id=request.POST.get(\"associated_object_id\"),",
            "                        status=Status.objects.get(id=request.POST.get(\"status\")),",
            "                        role=Role.objects.get(id=request.POST.get(\"role\")) if request.POST.get(\"role\") else None,",
            "                    )",
            "                else:",
            "                    association = ContactAssociation(",
            "                        team=obj,",
            "                        associated_object_type=ContentType.objects.get(id=request.POST.get(\"associated_object_type\")),",
            "                        associated_object_id=request.POST.get(\"associated_object_id\"),",
            "                        status=Status.objects.get(id=request.POST.get(\"status\")),",
            "                        role=Role.objects.get(id=request.POST.get(\"role\")) if request.POST.get(\"role\") else None,",
            "                    )",
            "                association.validated_save()",
            "                self.successful_post(request, obj, object_created, logger)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectNewContactView(ObjectContactTeamMixin, generic.ObjectEditView):",
            "    queryset = Contact.objects.all()",
            "    model_form = forms.ObjectNewContactForm",
            "    template_name = \"extras/object_new_contact.html\"",
            "",
            "",
            "class ObjectNewTeamView(ObjectContactTeamMixin, generic.ObjectEditView):",
            "    queryset = Team.objects.all()",
            "    model_form = forms.ObjectNewTeamForm",
            "    template_name = \"extras/object_new_team.html\"",
            "",
            "",
            "class ObjectAssignContactOrTeamView(generic.ObjectEditView):",
            "    queryset = ContactAssociation.objects.all()",
            "    model_form = forms.ContactAssociationForm",
            "    template_name = \"extras/object_assign_contact_or_team.html\"",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "class CustomFieldListView(generic.ObjectListView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "    filterset = filters.CustomFieldFilterSet",
            "    filterset_form = forms.CustomFieldFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomFieldView(generic.ObjectView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldEditView(generic.ObjectEditView):",
            "    queryset = CustomField.objects.all()",
            "    model_form = forms.CustomFieldForm",
            "    template_name = \"extras/customfield_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # ---> BEGIN difference from ObjectEditView.post()",
            "                    # Process the formsets for choices",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    choices = ctx[\"choices\"]",
            "                    if choices.is_valid():",
            "                        choices.save()",
            "                    else:",
            "                        raise RuntimeError(choices.errors)",
            "                    # <--- END difference from ObjectEditView.post()",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                try:",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                except AttributeError:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # ---> BEGIN difference from ObjectEditView.post()",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving custom field choices. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # <--- END difference from ObjectEditView.post()",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class CustomFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "    filterset = filters.CustomFieldFilterSet",
            "",
            "    def construct_custom_field_delete_tasks(self, queryset):",
            "        \"\"\"",
            "        Helper method to construct a list of celery tasks to execute when bulk deleting custom fields.",
            "        \"\"\"",
            "        change_context = change_context_state.get()",
            "        if change_context is None:",
            "            context = None",
            "        else:",
            "            context = change_context.as_dict(queryset)",
            "            context[\"context_detail\"] = \"bulk delete custom field data\"",
            "        tasks = [",
            "            delete_custom_field_data.si(obj.key, set(obj.content_types.values_list(\"pk\", flat=True)), context)",
            "            for obj in queryset",
            "        ]",
            "        return tasks",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        \"\"\"",
            "        Remove all Custom Field Keys/Values from _custom_field_data of the related ContentType in the background.",
            "        \"\"\"",
            "        if not get_worker_count():",
            "            messages.error(",
            "                request, \"Celery worker process not running. Object custom fields may fail to reflect this deletion.\"",
            "            )",
            "            return",
            "        tasks = self.construct_custom_field_delete_tasks(queryset)",
            "        # Executing the tasks in the background sequentially using chain() aligns with how a single",
            "        # CustomField object is deleted.  We decided to not check the result because it needs at least one worker",
            "        # to be active and comes with extra performance penalty.",
            "        chain(*tasks).apply_async()",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkListView(generic.ObjectListView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "    filterset = filters.CustomLinkFilterSet",
            "    filterset_form = forms.CustomLinkFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomLinkView(generic.ObjectView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkEditView(generic.ObjectEditView):",
            "    queryset = CustomLink.objects.all()",
            "    model_form = forms.CustomLinkForm",
            "",
            "",
            "class CustomLinkDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupListView(generic.ObjectListView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "    filterset = filters.DynamicGroupFilterSet",
            "    filterset_form = forms.DynamicGroupFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class DynamicGroupView(generic.ObjectView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        model = instance.content_type.model_class()",
            "        table_class = get_table_for_model(model)",
            "",
            "        if table_class is not None:",
            "            # Members table (for display on Members nav tab)",
            "            members_table = table_class(instance.members, orderable=False)",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(members_table)",
            "",
            "            # Descendants table",
            "            descendants_memberships = instance.membership_tree()",
            "            descendants_table = tables.NestedDynamicGroupDescendantsTable(",
            "                descendants_memberships,",
            "                orderable=False,",
            "            )",
            "            descendants_tree = {m.pk: m.depth for m in descendants_memberships}",
            "",
            "            # Ancestors table",
            "            ancestors = instance.get_ancestors()",
            "            ancestors_table = tables.NestedDynamicGroupAncestorsTable(ancestors, orderable=False)",
            "            ancestors_tree = instance.flatten_ancestors_tree(instance.ancestors_tree())",
            "",
            "            context[\"raw_query\"] = pretty_print_query(instance.generate_query())",
            "            context[\"members_table\"] = members_table",
            "            context[\"ancestors_table\"] = ancestors_table",
            "            context[\"ancestors_tree\"] = ancestors_tree",
            "            context[\"descendants_table\"] = descendants_table",
            "            context[\"descendants_tree\"] = descendants_tree",
            "",
            "        return context",
            "",
            "",
            "class DynamicGroupEditView(generic.ObjectEditView):",
            "    queryset = DynamicGroup.objects.all()",
            "    model_form = forms.DynamicGroupForm",
            "    template_name = \"extras/dynamicgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        filterform_class = instance.generate_filter_form()",
            "",
            "        if filterform_class is None:",
            "            filter_form = None",
            "        elif request.POST:",
            "            filter_form = filterform_class(data=request.POST)",
            "        else:",
            "            initial = instance.get_initial()",
            "            filter_form = filterform_class(initial=initial)",
            "",
            "        ctx[\"filter_form\"] = filter_form",
            "",
            "        formset_kwargs = {\"instance\": instance}",
            "        if request.POST:",
            "            formset_kwargs[\"data\"] = request.POST",
            "",
            "        ctx[\"children\"] = forms.DynamicGroupMembershipFormSet(**formset_kwargs)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    # Obtain the instance, but do not yet `save()` it to the database.",
            "                    obj = form.save(commit=False)",
            "",
            "                    # Process the filter form and save the query filters to `obj.filter`.",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    filter_form = ctx[\"filter_form\"]",
            "                    if filter_form.is_valid():",
            "                        obj.set_filter(filter_form.cleaned_data)",
            "                    else:",
            "                        raise RuntimeError(filter_form.errors)",
            "",
            "                    # After filters have been set, now we save the object to the database.",
            "                    obj.save()",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for children",
            "                    children = ctx[\"children\"]",
            "                    if children.is_valid():",
            "                        children.save()",
            "                    else:",
            "                        raise RuntimeError(children.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                try:",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                except AttributeError:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving Dynamic Group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a something that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ValidationError as err:",
            "                msg = \"Invalid filter detected in existing DynamicGroup filter data.\"",
            "                logger.debug(msg)",
            "                err_messages = err.args[0].split(\"\\n\")",
            "                for message in err_messages:",
            "                    if message:",
            "                        form.add_error(None, message)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class DynamicGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "",
            "class DynamicGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "    filterset = filters.DynamicGroupFilterSet",
            "",
            "",
            "class ObjectDynamicGroupsView(generic.GenericView):",
            "    \"\"\"",
            "    Present a list of dynamic groups associated to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all dynamic groups for this object (and its related objects)",
            "        dynamicsgroups_table = tables.DynamicGroupTable(data=obj.dynamic_groups_cached, orderable=False)",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(dynamicsgroups_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_dynamicgroups.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": dynamicsgroups_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"dynamic-groups\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateListView(generic.ObjectListView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "    filterset = filters.ExportTemplateFilterSet",
            "    filterset_form = forms.ExportTemplateFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ExportTemplateView(generic.ObjectView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateEditView(generic.ObjectEditView):",
            "    queryset = ExportTemplate.objects.all()",
            "    model_form = forms.ExportTemplateForm",
            "",
            "",
            "class ExportTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "",
            "",
            "#",
            "# External integrations",
            "#",
            "",
            "",
            "class ExternalIntegrationUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.ExternalIntegrationBulkEditForm",
            "    filterset_class = filters.ExternalIntegrationFilterSet",
            "    filterset_form_class = forms.ExternalIntegrationFilterForm",
            "    form_class = forms.ExternalIntegrationForm",
            "    queryset = ExternalIntegration.objects.select_related(\"secrets_group\")",
            "    serializer_class = serializers.ExternalIntegrationSerializer",
            "    table_class = tables.ExternalIntegrationTable",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryListView(generic.ObjectListView):",
            "    queryset = GitRepository.objects.all()",
            "    filterset = filters.GitRepositoryFilterSet",
            "    filterset_form = forms.GitRepositoryFilterForm",
            "    table = tables.GitRepositoryTable",
            "    template_name = \"extras/gitrepository_list.html\"",
            "",
            "    def extra_context(self):",
            "        # Get the newest results for each repository name",
            "        results = {",
            "            r.task_kwargs[\"repository\"]: r",
            "            for r in JobResult.objects.filter(",
            "                task_name__startswith=\"nautobot.core.jobs.GitRepository\",",
            "                task_kwargs__repository__isnull=False,",
            "                status__in=JobResultStatusChoices.READY_STATES,",
            "            )",
            "            .order_by(\"date_done\")",
            "            .defer(\"result\")",
            "        }",
            "        return {",
            "            \"job_results\": results,",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryView(generic.ObjectView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class GitRepositoryEditView(generic.ObjectEditView):",
            "    queryset = GitRepository.objects.all()",
            "    model_form = forms.GitRepositoryForm",
            "    template_name = \"extras/gitrepository_object_edit.html\"",
            "",
            "    # TODO(jathan): Align with changes for v2 where we're not stashing the user on the instance for",
            "    # magical calls and instead discretely calling `repo.sync(user=user, dry_run=dry_run)`, but",
            "    # again, this will be moved to the API calls, so just something to keep in mind.",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.user = request.user",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def get_return_url(self, request, obj):",
            "        if request.method == \"POST\":",
            "            return reverse(\"extras:gitrepository_result\", kwargs={\"pk\": obj.pk})",
            "        return super().get_return_url(request, obj)",
            "",
            "",
            "class GitRepositoryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "",
            "class GitRepositoryBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    queryset = GitRepository.objects.all()",
            "    table = tables.GitRepositoryBulkTable",
            "",
            "",
            "class GitRepositoryBulkEditView(generic.BulkEditView):",
            "    queryset = GitRepository.objects.select_related(\"secrets_group\")",
            "    filterset = filters.GitRepositoryFilterSet",
            "    table = tables.GitRepositoryBulkTable",
            "    form = forms.GitRepositoryBulkEditForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.request = request",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "    table = tables.GitRepositoryBulkTable",
            "    filterset = filters.GitRepositoryFilterSet",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "def check_and_call_git_repository_function(request, pk, func):",
            "    \"\"\"Helper for checking Git permissions and worker availability, then calling provided function if all is well",
            "    Args:",
            "        request (HttpRequest): request object.",
            "        pk (UUID): GitRepository pk value.",
            "        func (function): Enqueue git repo function.",
            "    Returns:",
            "        (Union[HttpResponseForbidden,redirect]): HttpResponseForbidden if user does not have permission to run the job,",
            "            otherwise redirect to the job result page.",
            "    \"\"\"",
            "    if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "        return HttpResponseForbidden()",
            "",
            "    # Allow execution only if a worker process is running.",
            "    if not get_worker_count():",
            "        messages.error(request, \"Unable to run job: Celery worker process not running.\")",
            "        return redirect(request.get_full_path(), permanent=False)",
            "    else:",
            "        repository = get_object_or_404(GitRepository.objects.restrict(request.user, \"change\"), pk=pk)",
            "        job_result = func(repository, request.user)",
            "",
            "    return redirect(job_result.get_absolute_url())",
            "",
            "",
            "class GitRepositorySyncView(generic.GenericView):",
            "    def post(self, request, pk):",
            "        return check_and_call_git_repository_function(request, pk, enqueue_pull_git_repository_and_refresh_data)",
            "",
            "",
            "class GitRepositoryDryRunView(generic.GenericView):",
            "    def post(self, request, pk):",
            "        return check_and_call_git_repository_function(request, pk, enqueue_git_repository_diff_origin_and_local)",
            "",
            "",
            "class GitRepositoryResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    template_name = \"extras/gitrepository_result.html\"",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.view_gitrepository\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        job_result = instance.get_latest_sync()",
            "",
            "        return {",
            "            \"result\": job_result,",
            "            \"base_template\": \"extras/gitrepository.html\",",
            "            \"object\": instance,",
            "            \"active_tab\": \"result\",",
            "        }",
            "",
            "",
            "#",
            "# Saved GraphQL queries",
            "#",
            "",
            "",
            "class GraphQLQueryListView(generic.ObjectListView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "    filterset = filters.GraphQLQueryFilterSet",
            "    filterset_form = forms.GraphQLQueryFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class GraphQLQueryView(generic.ObjectView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryEditView(generic.ObjectEditView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    model_form = forms.GraphQLQueryForm",
            "",
            "",
            "class GraphQLQueryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentEditView(generic.ObjectEditView):",
            "    \"\"\"",
            "    View for creating and editing ImageAttachments.",
            "",
            "    Note that a URL kwargs parameter of \"pk\" identifies an existing ImageAttachment to edit,",
            "    while kwargs of \"object_id\" or \"slug\" identify the parent model instance to attach an ImageAttachment to.",
            "    \"\"\"",
            "",
            "    queryset = ImageAttachment.objects.all()",
            "    model_form = forms.ImageAttachmentForm",
            "",
            "    def get_object(self, kwargs):",
            "        if \"pk\" in kwargs:",
            "            return get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        return self.queryset.model()",
            "",
            "    def alter_obj(self, imageattachment, request, args, kwargs):",
            "        if not imageattachment.present_in_database:",
            "            # Assign the parent object based on URL kwargs",
            "            model = kwargs.get(\"model\")",
            "            if \"object_id\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, pk=kwargs[\"object_id\"])",
            "            elif \"slug\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, slug=kwargs[\"slug\"])",
            "            else:",
            "                raise RuntimeError(\"Neither object_id nor slug were provided?\")",
            "        return imageattachment",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "class ImageAttachmentDeleteView(generic.ObjectDeleteView):",
            "    queryset = ImageAttachment.objects.all()",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobListView(generic.ObjectListView):",
            "    \"\"\"",
            "    Retrieve all of the available jobs from disk and the recorded JobResult (if any) for each.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "    table = tables.JobTable",
            "    filterset = filters.JobFilterSet",
            "    filterset_form = forms.JobFilterForm",
            "    action_buttons = ()",
            "    non_filter_params = (",
            "        *generic.ObjectListView.non_filter_params,",
            "        \"display\",",
            "    )",
            "    template_name = \"extras/job_list.html\"",
            "",
            "    def alter_queryset(self, request):",
            "        queryset = super().alter_queryset(request)",
            "        # Default to hiding \"hidden\" and non-installed jobs",
            "        if \"hidden\" not in request.GET:",
            "            queryset = queryset.filter(hidden=False)",
            "        if \"installed\" not in request.GET:",
            "            queryset = queryset.filter(installed=True)",
            "        return queryset",
            "",
            "    def extra_context(self):",
            "        # Determine user's preferred display",
            "        if self.request.GET.get(\"display\") in [\"list\", \"tiles\"]:",
            "            display = self.request.GET.get(\"display\")",
            "            if self.request.user.is_authenticated:",
            "                self.request.user.set_config(\"extras.job.display\", display, commit=True)",
            "        elif self.request.user.is_authenticated:",
            "            display = self.request.user.get_config(\"extras.job.display\", \"list\")",
            "        else:",
            "            display = \"list\"",
            "",
            "        return {",
            "            \"table_inc_template\": \"extras/inc/job_tiles.html\" if display == \"tiles\" else \"extras/inc/job_table.html\",",
            "            \"display\": display,",
            "        }",
            "",
            "",
            "class JobRunView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    View the parameters of a Job and enqueue it if desired.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.run_job\"",
            "",
            "    def _get_job_model_or_404(self, class_path=None, pk=None):",
            "        \"\"\"Helper function for get() and post().\"\"\"",
            "        if class_path:",
            "            try:",
            "                job_model = self.queryset.get_for_class_path(class_path)",
            "            except JobModel.DoesNotExist:",
            "                raise Http404",
            "        else:",
            "            job_model = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        return job_model",
            "",
            "    def get(self, request, class_path=None, pk=None):",
            "        job_model = self._get_job_model_or_404(class_path, pk)",
            "",
            "        try:",
            "            job_class = get_job(job_model.class_path, reload=True)",
            "            if job_class is None:",
            "                raise RuntimeError(\"Job code for this job is not currently installed or loadable\")",
            "            initial = normalize_querydict(request.GET, form_class=job_class.as_form_class())",
            "            if \"kwargs_from_job_result\" in initial:",
            "                job_result_pk = initial.pop(\"kwargs_from_job_result\")",
            "                try:",
            "                    job_result = job_model.job_results.get(pk=job_result_pk)",
            "                    # Allow explicitly specified arg values in request.GET to take precedence over the saved task_kwargs,",
            "                    # for example \"?kwargs_from_job_result=<UUID>&integervar=22\"",
            "                    explicit_initial = initial",
            "                    initial = job_result.task_kwargs.copy()",
            "                    task_queue = job_result.celery_kwargs.get(\"queue\", None)",
            "                    if task_queue is not None:",
            "                        initial[\"_task_queue\"] = task_queue",
            "                    initial[\"_profile\"] = job_result.celery_kwargs.get(\"nautobot_job_profile\", False)",
            "                    initial.update(explicit_initial)",
            "                except JobResult.DoesNotExist:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"JobResult {job_result_pk} not found, cannot use it to pre-populate inputs.\",",
            "                    )",
            "",
            "            template_name = \"extras/job.html\"",
            "            job_form = job_class.as_form(initial=initial)",
            "            if hasattr(job_class, \"template_name\"):",
            "                try:",
            "                    get_template(job_class.template_name)",
            "                    template_name = job_class.template_name",
            "                except TemplateDoesNotExist as err:",
            "                    messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "        except RuntimeError as err:",
            "            messages.error(request, f\"Unable to run or schedule '{job_model}': {err}\")",
            "            return redirect(\"extras:job_list\")",
            "",
            "        schedule_form = forms.JobScheduleForm(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            template_name,  # 2.0 TODO: extras/job_submission.html",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "    def post(self, request, class_path=None, pk=None):",
            "        job_model = self._get_job_model_or_404(class_path, pk)",
            "",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        job_form = job_class.as_form(request.POST, request.FILES) if job_class is not None else None",
            "        schedule_form = forms.JobScheduleForm(request.POST)",
            "        task_queue = request.POST.get(\"_task_queue\")",
            "",
            "        return_url = request.POST.get(\"_return_url\")",
            "        if return_url is not None and url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "            return_url = iri_to_uri(return_url)",
            "        else:",
            "            return_url = None",
            "",
            "        # Allow execution only if a worker process is running and the job is runnable.",
            "        if not get_worker_count(queue=task_queue):",
            "            messages.error(request, \"Unable to run or schedule job: Celery worker process not running.\")",
            "        elif not job_model.installed or job_class is None:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not presently installed.\")",
            "        elif not job_model.enabled:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not enabled to be run.\")",
            "        elif (",
            "            job_model.has_sensitive_variables",
            "            and request.POST.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY",
            "        ):",
            "            messages.error(request, \"Unable to schedule job: Job may have sensitive input variables.\")",
            "        elif job_model.has_sensitive_variables and job_model.approval_required:",
            "            messages.error(",
            "                request,",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "            )",
            "        elif job_form is not None and job_form.is_valid() and schedule_form.is_valid():",
            "            task_queue = job_form.cleaned_data.pop(\"_task_queue\", None)",
            "            dryrun = job_form.cleaned_data.get(\"dryrun\", False)",
            "            # Run the job. A new JobResult is created.",
            "            profile = job_form.cleaned_data.pop(\"_profile\")",
            "            schedule_type = schedule_form.cleaned_data[\"_schedule_type\"]",
            "",
            "            if (not dryrun and job_model.approval_required) or schedule_type in JobExecutionType.SCHEDULE_CHOICES:",
            "                crontab = \"\"",
            "",
            "                if schedule_type == JobExecutionType.TYPE_IMMEDIATELY:",
            "                    # The job must be approved.",
            "                    # If the schedule_type is immediate, we still create the task, but mark it for approval",
            "                    # as a once in the future task with the due date set to the current time. This means",
            "                    # when approval is granted, the task is immediately due for execution.",
            "                    schedule_type = JobExecutionType.TYPE_FUTURE",
            "                    schedule_datetime = timezone.now()",
            "                    schedule_name = f\"{job_model} - {schedule_datetime}\"",
            "",
            "                else:",
            "                    schedule_name = schedule_form.cleaned_data[\"_schedule_name\"]",
            "",
            "                    if schedule_type == JobExecutionType.TYPE_CUSTOM:",
            "                        crontab = schedule_form.cleaned_data[\"_recurrence_custom_time\"]",
            "                        # doing .get(\"key\", \"default\") returns None instead of \"default\" here for some reason",
            "                        schedule_datetime = schedule_form.cleaned_data.get(\"_schedule_start_time\")",
            "                        if schedule_datetime is None:",
            "                            # \"_schedule_start_time\" is checked against ScheduledJob.earliest_possible_time()",
            "                            # which returns timezone.now() + timedelta(seconds=15)",
            "                            schedule_datetime = timezone.now() + timedelta(seconds=20)",
            "                    else:",
            "                        schedule_datetime = schedule_form.cleaned_data[\"_schedule_start_time\"]",
            "",
            "                celery_kwargs = {\"nautobot_job_profile\": profile, \"queue\": task_queue}",
            "                scheduled_job = ScheduledJob(",
            "                    name=schedule_name,",
            "                    task=job_model.class_path,",
            "                    job_model=job_model,",
            "                    start_time=schedule_datetime,",
            "                    description=f\"Nautobot job {schedule_name} scheduled by {request.user} for {schedule_datetime}\",",
            "                    kwargs=job_class.serialize_data(job_form.cleaned_data),",
            "                    celery_kwargs=celery_kwargs,",
            "                    interval=schedule_type,",
            "                    one_off=schedule_type == JobExecutionType.TYPE_FUTURE,",
            "                    queue=task_queue,",
            "                    user=request.user,",
            "                    approval_required=job_model.approval_required,",
            "                    crontab=crontab,",
            "                )",
            "                scheduled_job.validated_save()",
            "",
            "                if job_model.approval_required:",
            "                    messages.success(request, f\"Job {schedule_name} successfully submitted for approval\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_approval_queue_list\")",
            "                else:",
            "                    messages.success(request, f\"Job {schedule_name} successfully scheduled\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_list\")",
            "",
            "            else:",
            "                # Enqueue job for immediate execution",
            "                job_kwargs = job_class.prepare_job_kwargs(job_form.cleaned_data)",
            "                job_result = JobResult.enqueue_job(",
            "                    job_model,",
            "                    request.user,",
            "                    profile=profile,",
            "                    task_queue=task_queue,",
            "                    **job_class.serialize_data(job_kwargs),",
            "                )",
            "",
            "                if return_url:",
            "                    messages.info(",
            "                        request,",
            "                        format_html(",
            "                            'Job enqueued. <a href=\"{}\">Click here for the results.</a>',",
            "                            job_result.get_absolute_url(),",
            "                        ),",
            "                    )",
            "                    return redirect(return_url)",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "",
            "        if return_url:",
            "            return redirect(return_url)",
            "",
            "        template_name = \"extras/job.html\"",
            "        if job_class is not None and hasattr(job_class, \"template_name\"):",
            "            try:",
            "                get_template(job_class.template_name)",
            "                template_name = job_class.template_name",
            "            except TemplateDoesNotExist as err:",
            "                messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "",
            "        return render(",
            "            request,",
            "            template_name,",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "",
            "class JobView(generic.ObjectView):",
            "    queryset = JobModel.objects.all()",
            "    template_name = \"extras/job_detail.html\"",
            "",
            "",
            "class JobEditView(generic.ObjectEditView):",
            "    queryset = JobModel.objects.all()",
            "    model_form = forms.JobEditForm",
            "    template_name = \"extras/job_edit.html\"",
            "",
            "",
            "class JobBulkEditView(generic.BulkEditView):",
            "    queryset = JobModel.objects.all()",
            "    filterset = filters.JobFilterSet",
            "    table = tables.JobTable",
            "    form = forms.JobBulkEditForm",
            "    template_name = \"extras/job_bulk_edit.html\"",
            "",
            "    def extra_post_save_action(self, obj, form):",
            "        cleaned_data = form.cleaned_data",
            "",
            "        # Handle text related fields",
            "        for overridable_field in JOB_OVERRIDABLE_FIELDS:",
            "            override_field = overridable_field + \"_override\"",
            "            clear_override_field = \"clear_\" + overridable_field + \"_override\"",
            "            reset_override = cleaned_data.get(clear_override_field, False)",
            "            override_value = cleaned_data.get(overridable_field)",
            "            if reset_override:",
            "                setattr(obj, override_field, False)",
            "            elif not reset_override and override_value not in [None, \"\"]:",
            "                setattr(obj, override_field, True)",
            "                setattr(obj, overridable_field, override_value)",
            "",
            "        obj.validated_save()",
            "",
            "",
            "class JobDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobModel.objects.all()",
            "",
            "",
            "class JobBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobModel.objects.all()",
            "    filterset = filters.JobFilterSet",
            "    table = tables.JobTable",
            "",
            "",
            "class JobApprovalRequestView(generic.ObjectView):",
            "    \"\"\"",
            "    This view handles requests to view and approve a Job execution request.",
            "    It renders the Job's form in much the same way as `JobView` except all",
            "    form fields are disabled and actions on the form relate to approval of the",
            "    job's execution, rather than initial job form input.",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.needs_approved()",
            "    template_name = \"extras/job_approval_request.html\"",
            "    additional_permissions = (\"extras.view_job\",)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Render the job form with data from the scheduled_job instance, but mark all fields as disabled.",
            "        We don't care to actually get any data back from the form as we will not ever change it.",
            "        Instead, we offer the user three submit buttons, dry-run, approve, and deny, which we act upon in the post.",
            "        \"\"\"",
            "        job_model = instance.job_model",
            "        if job_model is not None:",
            "            job_class = get_job(job_model.class_path, reload=True)",
            "        else:",
            "            # 2.0 TODO: remove this fallback?",
            "            job_class = get_job(instance.job_class)",
            "",
            "        if job_class is not None:",
            "            # Render the form with all fields disabled",
            "            initial = instance.kwargs",
            "            initial[\"_task_queue\"] = instance.queue",
            "            initial[\"_profile\"] = instance.celery_kwargs.get(\"profile\", False)",
            "            job_form = job_class().as_form(initial=initial, approval_view=True)",
            "        else:",
            "            job_form = None",
            "",
            "        return {\"job_form\": job_form, **super().get_extra_context(request, instance)}",
            "",
            "    def post(self, request, pk):",
            "        \"\"\"",
            "        Act upon one of the 3 submit button actions from the user.",
            "",
            "        dry-run will immediately enqueue the job with commit=False and send the user to the normal JobResult view",
            "        deny will delete the scheduled_job instance",
            "        approve will mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        \"\"\"",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        post_data = request.POST",
            "",
            "        deny = \"_deny\" in post_data",
            "        approve = \"_approve\" in post_data",
            "        force_approve = \"_force_approve\" in post_data",
            "        dry_run = \"_dry_run\" in post_data",
            "",
            "        job_model = scheduled_job.job_model",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "",
            "        if dry_run:",
            "            # To dry-run a job, a user needs the same permissions that would be needed to run the job directly",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not job_model.runnable:",
            "                messages.error(request, \"This job cannot be run at this time\")",
            "            elif not JobModel.objects.check_perms(self.request.user, instance=job_model, action=\"run\"):",
            "                messages.error(request, \"You do not have permission to run this job\")",
            "            elif not job_model.supports_dryrun:",
            "                messages.error(request, \"This job does not support dryrun\")",
            "            else:",
            "                # Immediately enqueue the job and send the user to the normal JobResult view",
            "                job_kwargs = job_class.prepare_job_kwargs(scheduled_job.kwargs or {})",
            "                job_kwargs[\"dryrun\"] = True",
            "                job_result = JobResult.enqueue_job(",
            "                    job_model,",
            "                    request.user,",
            "                    celery_kwargs=scheduled_job.celery_kwargs,",
            "                    **job_class.serialize_data(job_kwargs),",
            "                )",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "        elif deny:",
            "            if not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"delete\")",
            "                and job_model is not None",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to deny this request.\")",
            "            else:",
            "                # Delete the scheduled_job instance",
            "                scheduled_job.delete()",
            "                if request.user == scheduled_job.user:",
            "                    messages.error(request, f\"Approval request for {scheduled_job.name} was revoked\")",
            "                else:",
            "                    messages.error(request, f\"Approval of {scheduled_job.name} was denied\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        elif approve or force_approve:",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"change\")",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to approve this request.\")",
            "            elif request.user == scheduled_job.user:",
            "                # The requestor *cannot* approve their own job",
            "                messages.error(request, \"You cannot approve your own job request!\")",
            "            else:",
            "                # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "                if scheduled_job.one_off and scheduled_job.start_time < timezone.now() and not force_approve:",
            "                    return render(request, \"extras/job_approval_confirmation.html\", {\"scheduled_job\": scheduled_job})",
            "                scheduled_job.approved_by_user = request.user",
            "                scheduled_job.approved_at = timezone.now()",
            "                scheduled_job.save()",
            "",
            "                messages.success(request, f\"{scheduled_job.name} was approved and will now begin execution\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        return render(",
            "            request,",
            "            self.get_template_name(),",
            "            {",
            "                \"object\": scheduled_job,",
            "                **self.get_extra_context(request, scheduled_job),",
            "            },",
            "        )",
            "",
            "",
            "class ScheduledJobListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.enabled()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "",
            "",
            "class ScheduledJobBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "",
            "",
            "class ScheduledJobApprovalQueueListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.needs_approved()",
            "    table = tables.ScheduledJobApprovalQueueTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "    template_name = \"extras/scheduled_jobs_approval_queue_list.html\"",
            "",
            "",
            "class ScheduledJobView(generic.ObjectView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        job_class = get_job(instance.task)",
            "        labels = {}",
            "        if job_class is not None:",
            "            for name, var in job_class._get_vars().items():",
            "                field = var.as_field()",
            "                if field.label:",
            "                    labels[name] = field.label",
            "                else:",
            "                    labels[name] = pretty_name(name)",
            "        return {",
            "            \"labels\": labels,",
            "            \"job_class_found\": (job_class is not None),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class ScheduledJobDeleteView(generic.ObjectDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "",
            "#",
            "# Job hooks",
            "#",
            "",
            "",
            "class JobHookListView(generic.ObjectListView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "    filterset = filters.JobHookFilterSet",
            "    filterset_form = forms.JobHookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class JobHookView(generic.ObjectView):",
            "    queryset = JobHook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class JobHookEditView(generic.ObjectEditView):",
            "    queryset = JobHook.objects.all()",
            "    model_form = forms.JobHookForm",
            "",
            "",
            "class JobHookDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobHook.objects.all()",
            "",
            "",
            "class JobHookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "",
            "",
            "#",
            "# JobResult",
            "#",
            "",
            "",
            "def get_annotated_jobresult_queryset():",
            "    return (",
            "        JobResult.objects.defer(\"result\")",
            "        .select_related(\"job_model\", \"user\")",
            "        .annotate(",
            "            debug_log_count=count_related(",
            "                JobLogEntry, \"job_result\", filter_dict={\"log_level\": LogLevelChoices.LOG_DEBUG}",
            "            ),",
            "            info_log_count=count_related(",
            "                JobLogEntry, \"job_result\", filter_dict={\"log_level\": LogLevelChoices.LOG_INFO}",
            "            ),",
            "            warning_log_count=count_related(",
            "                JobLogEntry, \"job_result\", filter_dict={\"log_level\": LogLevelChoices.LOG_WARNING}",
            "            ),",
            "            error_log_count=count_related(",
            "                JobLogEntry,",
            "                \"job_result\",",
            "                filter_dict={\"log_level__in\": [LogLevelChoices.LOG_ERROR, LogLevelChoices.LOG_CRITICAL]},",
            "            ),",
            "        )",
            "    )",
            "",
            "",
            "class JobResultListView(generic.ObjectListView):",
            "    \"\"\"",
            "    List JobResults",
            "    \"\"\"",
            "",
            "    queryset = get_annotated_jobresult_queryset()",
            "    filterset = filters.JobResultFilterSet",
            "    filterset_form = forms.JobResultFilterForm",
            "    table = tables.JobResultTable",
            "    action_buttons = ()",
            "",
            "",
            "class JobResultDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobResult.objects.all()",
            "",
            "",
            "class JobResultBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = get_annotated_jobresult_queryset()",
            "    table = tables.JobResultTable",
            "    filterset = filters.JobResultFilterSet",
            "",
            "",
            "class JobResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.prefetch_related(\"job_model\", \"user\")",
            "    template_name = \"extras/jobresult.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        associated_record = None",
            "        job_class = None",
            "        if instance.job_model is not None:",
            "            job_class = instance.job_model.job_class",
            "",
            "        return {",
            "            \"job\": job_class,",
            "            \"associated_record\": associated_record,",
            "            \"result\": instance,",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class JobLogEntryTableView(generic.GenericView):",
            "    \"\"\"",
            "    Display a table of `JobLogEntry` objects for a given `JobResult` instance.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.all()",
            "",
            "    def get(self, request, pk=None):",
            "        instance = get_object_or_404(self.queryset.restrict(request.user, \"view\"), pk=pk)",
            "        filter_q = request.GET.get(\"q\")",
            "        if filter_q:",
            "            queryset = instance.job_log_entries.filter(",
            "                Q(message__icontains=filter_q) | Q(log_level__icontains=filter_q)",
            "            )",
            "        else:",
            "            queryset = instance.job_log_entries.all()",
            "        log_table = tables.JobLogEntryTable(data=queryset, user=request.user)",
            "        RequestConfig(request).configure(log_table)",
            "        return HttpResponse(log_table.as_html(request))",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.JobButtonBulkEditForm",
            "    filterset_class = filters.JobButtonFilterSet",
            "    filterset_form_class = forms.JobButtonFilterForm",
            "    form_class = forms.JobButtonForm",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    table_class = tables.JobButtonTable",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeListView(generic.ObjectListView):",
            "    queryset = ObjectChange.objects.all()",
            "    filterset = filters.ObjectChangeFilterSet",
            "    filterset_form = forms.ObjectChangeFilterForm",
            "    table = tables.ObjectChangeTable",
            "    template_name = \"extras/objectchange_list.html\"",
            "    action_buttons = (\"export\",)",
            "",
            "    # 2.0 TODO: Remove this remapping and solve it at the `BaseFilterSet` as it is addressing a breaking change.",
            "    def get(self, request, **kwargs):",
            "        # Remappings below allow previous queries of time_before and time_after to use",
            "        # newer methods specifying the lookup method.",
            "",
            "        # They will only use the previous arguments if the newer ones are undefined",
            "",
            "        if request.GET.get(\"time_after\") and request.GET.get(\"time__gte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__gte\": request.GET.get(\"time_after\")})",
            "            request.GET._mutable = False",
            "",
            "        if request.GET.get(\"time_before\") and request.GET.get(\"time__lte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__lte\": request.GET.get(\"time_before\")})",
            "            request.GET._mutable = False",
            "",
            "        return super().get(request=request, **kwargs)",
            "",
            "",
            "class ObjectChangeView(generic.ObjectView):",
            "    queryset = ObjectChange.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_changes = instance.get_related_changes(user=request.user).filter(request_id=instance.request_id)",
            "        related_changes_table = tables.ObjectChangeTable(data=related_changes[:50], orderable=False)",
            "",
            "        snapshots = instance.get_snapshots()",
            "        return {",
            "            \"diff_added\": snapshots[\"differences\"][\"added\"],",
            "            \"diff_removed\": snapshots[\"differences\"][\"removed\"],",
            "            \"next_change\": instance.get_next_change(request.user),",
            "            \"prev_change\": instance.get_prev_change(request.user),",
            "            \"related_changes_table\": related_changes_table,",
            "            \"related_changes_count\": related_changes.count(),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class ObjectChangeLogView(generic.GenericView):",
            "    \"\"\"",
            "    Present a history of changes made to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all changes for this object (and its related objects)",
            "        content_type = ContentType.objects.get_for_model(model)",
            "        objectchanges = (",
            "            ObjectChange.objects.restrict(request.user, \"view\")",
            "            .select_related(\"user\", \"changed_object_type\")",
            "            .filter(",
            "                Q(changed_object_type=content_type, changed_object_id=obj.pk)",
            "                | Q(related_object_type=content_type, related_object_id=obj.pk)",
            "            )",
            "        )",
            "        objectchanges_table = tables.ObjectChangeTable(data=objectchanges, orderable=False)",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(objectchanges_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_changelog.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": objectchanges_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"changelog\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteView(generic.ObjectView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class NoteListView(generic.ObjectListView):",
            "    \"\"\"",
            "    List Notes",
            "    \"\"\"",
            "",
            "    queryset = Note.objects.all()",
            "    filterset = filters.NoteFilterSet",
            "    filterset_form = forms.NoteFilterForm",
            "    table = tables.NoteTable",
            "    action_buttons = ()",
            "",
            "",
            "class NoteEditView(generic.ObjectEditView):",
            "    queryset = Note.objects.all()",
            "    model_form = forms.NoteForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        obj.user = request.user",
            "        return obj",
            "",
            "",
            "class NoteDeleteView(generic.ObjectDeleteView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class ObjectNotesView(generic.GenericView):",
            "    \"\"\"",
            "    Present a list of notes associated to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        notes_form = forms.NoteForm(",
            "            initial={",
            "                \"assigned_object_type\": ContentType.objects.get_for_model(obj),",
            "                \"assigned_object_id\": obj.pk,",
            "            }",
            "        )",
            "        notes_table = tables.NoteTable(obj.notes.restrict(request.user, \"view\"))",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(notes_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_notes.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": notes_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"notes\",",
            "                \"form\": notes_form,",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipListView(generic.ObjectListView):",
            "    queryset = Relationship.objects.all()",
            "    filterset = filters.RelationshipFilterSet",
            "    filterset_form = forms.RelationshipFilterForm",
            "    table = tables.RelationshipTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class RelationshipView(generic.ObjectView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipEditView(generic.ObjectEditView):",
            "    queryset = Relationship.objects.all()",
            "    model_form = forms.RelationshipForm",
            "    template_name = \"extras/relationship_edit.html\"",
            "",
            "",
            "class RelationshipBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Relationship.objects.all()",
            "    table = tables.RelationshipTable",
            "    filterset = filters.RelationshipFilterSet",
            "",
            "",
            "class RelationshipDeleteView(generic.ObjectDeleteView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipAssociationListView(generic.ObjectListView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    filterset = filters.RelationshipAssociationFilterSet",
            "    filterset_form = forms.RelationshipAssociationFilterForm",
            "    table = tables.RelationshipAssociationTable",
            "    action_buttons = ()",
            "",
            "",
            "class RelationshipAssociationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    table = tables.RelationshipAssociationTable",
            "    filterset = filters.RelationshipAssociationFilterSet",
            "",
            "",
            "class RelationshipAssociationDeleteView(generic.ObjectDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "",
            "",
            "#",
            "# Roles",
            "#",
            "",
            "",
            "class RoleUIViewSet(viewsets.NautobotUIViewSet):",
            "    \"\"\"`Roles` UIViewSet.\"\"\"",
            "",
            "    queryset = Role.objects.all()",
            "    bulk_update_form_class = forms.RoleBulkEditForm",
            "    filterset_class = filters.RoleFilterSet",
            "    filterset_form_class = forms.RoleFilterForm",
            "    form_class = forms.RoleForm",
            "    serializer_class = serializers.RoleSerializer",
            "    table_class = tables.RoleTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        if self.action == \"retrieve\":",
            "            context[\"content_types\"] = instance.content_types.order_by(\"app_label\", \"model\")",
            "",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "",
            "            if ContentType.objects.get_for_model(Device) in context[\"content_types\"]:",
            "                devices = instance.devices.select_related(",
            "                    \"status\",",
            "                    \"location\",",
            "                    \"tenant\",",
            "                    \"role\",",
            "                    \"rack\",",
            "                    \"device_type\",",
            "                ).restrict(request.user, \"view\")",
            "                device_table = DeviceTable(devices)",
            "                device_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(device_table)",
            "                context[\"device_table\"] = device_table",
            "",
            "            if ContentType.objects.get_for_model(Controller) in context[\"content_types\"]:",
            "                controllers = instance.controllers.select_related(",
            "                    \"status\",",
            "                    \"location\",",
            "                    \"tenant\",",
            "                    \"role\",",
            "                ).restrict(request.user, \"view\")",
            "                controller_table = ControllerTable(controllers)",
            "                controller_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(controller_table)",
            "                context[\"controller_table\"] = controller_table",
            "",
            "            if ContentType.objects.get_for_model(IPAddress) in context[\"content_types\"]:",
            "                ipaddress = (",
            "                    instance.ip_addresses.select_related(\"status\", \"tenant\")",
            "                    .restrict(request.user, \"view\")",
            "                    .annotate(",
            "                        interface_count=count_related(Interface, \"ip_addresses\"),",
            "                        interface_parent_count=count_related(Device, \"interfaces__ip_addresses\", distinct=True),",
            "                        vm_interface_count=count_related(VMInterface, \"ip_addresses\"),",
            "                        vm_interface_parent_count=count_related(",
            "                            VirtualMachine, \"interfaces__ip_addresses\", distinct=True",
            "                        ),",
            "                    )",
            "                )",
            "                ipaddress_table = IPAddressTable(ipaddress)",
            "                ipaddress_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(ipaddress_table)",
            "                context[\"ipaddress_table\"] = ipaddress_table",
            "",
            "            if ContentType.objects.get_for_model(Prefix) in context[\"content_types\"]:",
            "                prefixes = (",
            "                    instance.prefixes.select_related(",
            "                        \"status\",",
            "                        \"tenant\",",
            "                        \"vlan\",",
            "                        \"namespace\",",
            "                    )",
            "                    .restrict(request.user, \"view\")",
            "                    .annotate(location_count=count_related(Location, \"prefixes\"))",
            "                )",
            "                prefix_table = PrefixTable(prefixes)",
            "                prefix_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(prefix_table)",
            "                context[\"prefix_table\"] = prefix_table",
            "            if ContentType.objects.get_for_model(Rack) in context[\"content_types\"]:",
            "                racks = instance.racks.select_related(",
            "                    \"location\",",
            "                    \"status\",",
            "                    \"tenant\",",
            "                    \"rack_group\",",
            "                ).restrict(request.user, \"view\")",
            "                rack_table = RackTable(racks)",
            "                rack_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(rack_table)",
            "                context[\"rack_table\"] = rack_table",
            "            if ContentType.objects.get_for_model(VirtualMachine) in context[\"content_types\"]:",
            "                virtual_machines = instance.virtual_machines.select_related(",
            "                    \"cluster\",",
            "                    \"role\",",
            "                    \"status\",",
            "                    \"tenant\",",
            "                ).restrict(request.user, \"view\")",
            "                virtual_machine_table = VirtualMachineTable(virtual_machines)",
            "                virtual_machine_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(virtual_machine_table)",
            "                context[\"virtual_machine_table\"] = virtual_machine_table",
            "",
            "            if ContentType.objects.get_for_model(VLAN) in context[\"content_types\"]:",
            "                vlans = (",
            "                    instance.vlans.annotate(location_count=count_related(Location, \"vlans\"))",
            "                    .select_related(",
            "                        \"vlan_group\",",
            "                        \"status\",",
            "                        \"tenant\",",
            "                    )",
            "                    .restrict(request.user, \"view\")",
            "                )",
            "                vlan_table = VLANTable(vlans)",
            "                vlan_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(vlan_table)",
            "                context[\"vlan_table\"] = vlan_table",
            "        return context",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretListView(generic.ObjectListView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    filterset_form = forms.SecretFilterForm",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretView(generic.ObjectView):",
            "    queryset = Secret.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        provider = registry[\"secrets_providers\"].get(instance.provider)",
            "",
            "        groups = instance.secrets_groups.distinct()",
            "        groups_table = tables.SecretsGroupTable(groups, orderable=False)",
            "",
            "        return {",
            "            \"format\": format_,",
            "            \"provider_name\": provider.name if provider else instance.provider,",
            "            \"groups_table\": groups_table,",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class SecretProviderParametersFormView(generic.GenericView):",
            "    \"\"\"",
            "    Helper view to SecretView; retrieve the HTML form appropriate for entering parameters for a given SecretsProvider.",
            "    \"\"\"",
            "",
            "    def get(self, request, provider_slug):",
            "        provider = registry[\"secrets_providers\"].get(provider_slug)",
            "        if not provider:",
            "            raise Http404",
            "        return render(",
            "            request,",
            "            \"extras/inc/secret_provider_parameters_form.html\",",
            "            {\"form\": provider.ParametersForm(initial=request.GET)},",
            "        )",
            "",
            "",
            "class SecretEditView(generic.ObjectEditView):",
            "    queryset = Secret.objects.all()",
            "    model_form = forms.SecretForm",
            "    template_name = \"extras/secret_edit.html\"",
            "",
            "",
            "class SecretDeleteView(generic.ObjectDeleteView):",
            "    queryset = Secret.objects.all()",
            "",
            "",
            "class SecretBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    queryset = Secret.objects.all()",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretsGroupListView(generic.ObjectListView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    filterset_form = forms.SecretsGroupFilterForm",
            "    table = tables.SecretsGroupTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class SecretsGroupView(generic.ObjectView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"secrets_group_associations\": SecretsGroupAssociation.objects.filter(secrets_group=instance)}",
            "",
            "",
            "class SecretsGroupEditView(generic.ObjectEditView):",
            "    queryset = SecretsGroup.objects.all()",
            "    model_form = forms.SecretsGroupForm",
            "    template_name = \"extras/secretsgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for secrets",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    secrets = ctx[\"secrets\"]",
            "                    if secrets.is_valid():",
            "                        secrets.save()",
            "                    else:",
            "                        raise RuntimeError(secrets.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                try:",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                except AttributeError:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving secrets group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class SecretsGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "",
            "class SecretsGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    table = tables.SecretsGroupTable",
            "",
            "",
            "#",
            "# Custom statuses",
            "#",
            "",
            "",
            "class StatusListView(generic.ObjectListView):",
            "    \"\"\"List `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    filterset = filters.StatusFilterSet",
            "    filterset_form = forms.StatusFilterForm",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusEditView(generic.ObjectEditView):",
            "    \"\"\"Edit a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    model_form = forms.StatusForm",
            "",
            "",
            "class StatusBulkEditView(generic.BulkEditView):",
            "    \"\"\"Edit multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "    form = forms.StatusBulkEditForm",
            "",
            "",
            "class StatusBulkDeleteView(generic.BulkDeleteView):",
            "    \"\"\"Delete multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusDeleteView(generic.ObjectDeleteView):",
            "    \"\"\"Delete a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "",
            "class StatusBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    \"\"\"Bulk CSV import of multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusView(generic.ObjectView):",
            "    \"\"\"Detail view for a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"Return ordered content types.\"\"\"",
            "        return {",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagListView(generic.ObjectListView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    filterset = filters.TagFilterSet",
            "    filterset_form = forms.TagFilterForm",
            "    table = tables.TagTable",
            "",
            "",
            "class TagView(generic.ObjectView):",
            "    queryset = Tag.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        tagged_items = (",
            "            TaggedItem.objects.filter(tag=instance).select_related(\"content_type\").prefetch_related(\"content_object\")",
            "        )",
            "",
            "        # Generate a table of all items tagged with this Tag",
            "        items_table = tables.TaggedItemTable(tagged_items)",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(items_table)",
            "",
            "        return {",
            "            \"items_count\": tagged_items.count(),",
            "            \"items_table\": items_table,",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class TagEditView(generic.ObjectEditView):",
            "    queryset = Tag.objects.all()",
            "    model_form = forms.TagForm",
            "    template_name = \"extras/tag_edit.html\"",
            "",
            "",
            "class TagDeleteView(generic.ObjectDeleteView):",
            "    queryset = Tag.objects.all()",
            "",
            "",
            "class TagBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    queryset = Tag.objects.all()",
            "    table = tables.TagTable",
            "",
            "",
            "class TagBulkEditView(generic.BulkEditView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "    form = forms.TagBulkEditForm",
            "    filterset = filters.TagFilterSet",
            "",
            "",
            "class TagBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "    filterset = filters.TagFilterSet",
            "",
            "",
            "#",
            "# Teams",
            "#",
            "",
            "",
            "class TeamUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.TeamBulkEditForm",
            "    filterset_class = filters.TeamFilterSet",
            "    filterset_form_class = forms.TeamFilterForm",
            "    form_class = forms.TeamForm",
            "    queryset = Team.objects.all()",
            "    serializer_class = serializers.TeamSerializer",
            "    table_class = tables.TeamTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        if self.action == \"retrieve\":",
            "            contacts = instance.contacts.restrict(request.user, \"view\")",
            "            contacts_table = tables.ContactTable(contacts, orderable=False)",
            "            contacts_table.columns.hide(\"actions\")",
            "            paginate = {\"paginator_class\": EnhancedPaginator, \"per_page\": get_paginate_count(request)}",
            "            RequestConfig(request, paginate).configure(contacts_table)",
            "            context[\"contacts_table\"] = contacts_table",
            "",
            "            # TODO: need some consistent ordering of contact_associations",
            "            associations = instance.contact_associations.restrict(request.user, \"view\")",
            "            associations_table = tables.ContactAssociationTable(associations, orderable=False)",
            "            RequestConfig(request, paginate).configure(associations_table)",
            "            context[\"contact_associations_table\"] = associations_table",
            "        return context",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookListView(generic.ObjectListView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "    filterset = filters.WebhookFilterSet",
            "    filterset_form = forms.WebhookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class WebhookView(generic.ObjectView):",
            "    queryset = Webhook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class WebhookEditView(generic.ObjectEditView):",
            "    queryset = Webhook.objects.all()",
            "    model_form = forms.WebhookForm",
            "",
            "",
            "class WebhookDeleteView(generic.ObjectDeleteView):",
            "    queryset = Webhook.objects.all()",
            "",
            "",
            "class WebhookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "",
            "",
            "#",
            "# Job Extra Views",
            "#",
            "# NOTE: Due to inheritance, JobObjectChangeLogView and JobObjectNotesView can only be",
            "# constructed below # ObjectChangeLogView and ObjectNotesView.",
            "",
            "",
            "class JobObjectChangeLogView(ObjectChangeLogView):",
            "    base_template = \"extras/job_detail.html\"",
            "",
            "",
            "class JobObjectNotesView(ObjectNotesView):",
            "    base_template = \"extras/job_detail.html\""
        ],
        "afterPatchFile": [
            "from datetime import timedelta",
            "import logging",
            "",
            "from celery import chain",
            "from django.contrib import messages",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core.exceptions import ObjectDoesNotExist, ValidationError",
            "from django.db import transaction",
            "from django.db.models import ProtectedError, Q",
            "from django.forms.utils import pretty_name",
            "from django.http import Http404, HttpResponse, HttpResponseForbidden",
            "from django.shortcuts import get_object_or_404, redirect, render",
            "from django.template.loader import get_template, TemplateDoesNotExist",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.encoding import iri_to_uri",
            "from django.utils.html import format_html",
            "from django.utils.http import url_has_allowed_host_and_scheme",
            "from django.views.generic import View",
            "from django_tables2 import RequestConfig",
            "from jsonschema.validators import Draft7Validator",
            "",
            "from nautobot.core.forms import restrict_form_fields",
            "from nautobot.core.models.querysets import count_related",
            "from nautobot.core.models.utils import pretty_print_query",
            "from nautobot.core.tables import ButtonsColumn",
            "from nautobot.core.utils.lookup import get_table_for_model",
            "from nautobot.core.utils.requests import normalize_querydict",
            "from nautobot.core.views import generic, viewsets",
            "from nautobot.core.views.mixins import (",
            "    ObjectBulkDestroyViewMixin,",
            "    ObjectBulkUpdateViewMixin,",
            "    ObjectDestroyViewMixin,",
            "    ObjectEditViewMixin,",
            "    ObjectPermissionRequiredMixin,",
            ")",
            "from nautobot.core.views.paginator import EnhancedPaginator, get_paginate_count",
            "from nautobot.core.views.utils import prepare_cloned_fields",
            "from nautobot.core.views.viewsets import NautobotUIViewSet",
            "from nautobot.dcim.models import Controller, Device, Interface, Location, Rack",
            "from nautobot.dcim.tables import ControllerTable, DeviceTable, RackTable",
            "from nautobot.extras.constants import JOB_OVERRIDABLE_FIELDS",
            "from nautobot.extras.signals import change_context_state",
            "from nautobot.extras.tasks import delete_custom_field_data",
            "from nautobot.extras.utils import get_base_template, get_worker_count",
            "from nautobot.ipam.models import IPAddress, Prefix, VLAN",
            "from nautobot.ipam.tables import IPAddressTable, PrefixTable, VLANTable",
            "from nautobot.virtualization.models import VirtualMachine, VMInterface",
            "from nautobot.virtualization.tables import VirtualMachineTable",
            "",
            "from . import filters, forms, tables",
            "from .api import serializers",
            "from .choices import JobExecutionType, JobResultStatusChoices, LogLevelChoices",
            "from .datasources import (",
            "    enqueue_git_repository_diff_origin_and_local,",
            "    enqueue_pull_git_repository_and_refresh_data,",
            "    get_datasource_contents,",
            ")",
            "from .jobs import get_job",
            "from .models import (",
            "    ComputedField,",
            "    ConfigContext,",
            "    ConfigContextSchema,",
            "    Contact,",
            "    ContactAssociation,",
            "    CustomField,",
            "    CustomLink,",
            "    DynamicGroup,",
            "    ExportTemplate,",
            "    ExternalIntegration,",
            "    GitRepository,",
            "    GraphQLQuery,",
            "    ImageAttachment,",
            "    Job as JobModel,",
            "    JobButton,",
            "    JobHook,",
            "    JobLogEntry,",
            "    JobResult,",
            "    Note,",
            "    ObjectChange,",
            "    Relationship,",
            "    RelationshipAssociation,",
            "    Role,",
            "    ScheduledJob,",
            "    Secret,",
            "    SecretsGroup,",
            "    SecretsGroupAssociation,",
            "    Status,",
            "    Tag,",
            "    TaggedItem,",
            "    Team,",
            "    Webhook,",
            ")",
            "from .registry import registry",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "#",
            "# Computed Fields",
            "#",
            "",
            "",
            "class ComputedFieldListView(generic.ObjectListView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "    filterset = filters.ComputedFieldFilterSet",
            "    filterset_form = forms.ComputedFieldFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ComputedFieldView(generic.ObjectView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldEditView(generic.ObjectEditView):",
            "    queryset = ComputedField.objects.all()",
            "    model_form = forms.ComputedFieldForm",
            "    template_name = \"extras/computedfield_edit.html\"",
            "",
            "",
            "class ComputedFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "",
            "",
            "class ComputedFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ComputedField.objects.all()",
            "    table = tables.ComputedFieldTable",
            "    filterset = filters.ComputedFieldFilterSet",
            "",
            "",
            "#",
            "# Config contexts",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config contexts that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextListView(generic.ObjectListView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    filterset_form = forms.ConfigContextFilterForm",
            "    table = tables.ConfigContextTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextView(generic.ObjectView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            context[\"format\"] = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", context[\"format\"], commit=True)",
            "        elif request.user.is_authenticated:",
            "            context[\"format\"] = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            context[\"format\"] = \"json\"",
            "",
            "        return context",
            "",
            "",
            "class ConfigContextEditView(generic.ObjectEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    model_form = forms.ConfigContextForm",
            "    template_name = \"extras/configcontext_edit.html\"",
            "",
            "",
            "class ConfigContextBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContext.objects.all()",
            "    filterset = filters.ConfigContextFilterSet",
            "    table = tables.ConfigContextTable",
            "    form = forms.ConfigContextBulkEditForm",
            "",
            "",
            "class ConfigContextDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "",
            "",
            "class ConfigContextBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContext.objects.all()",
            "    table = tables.ConfigContextTable",
            "    filterset = filters.ConfigContextFilterSet",
            "",
            "",
            "class ObjectConfigContextView(generic.ObjectView):",
            "    base_template = None",
            "    template_name = \"extras/object_configcontext.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        source_contexts = ConfigContext.objects.restrict(request.user, \"view\").get_for_object(instance)",
            "",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        return {",
            "            \"rendered_context\": instance.get_config_context(),",
            "            \"source_contexts\": source_contexts,",
            "            \"format\": format_,",
            "            \"base_template\": self.base_template,",
            "            \"active_tab\": \"config-context\",",
            "        }",
            "",
            "",
            "#",
            "# Config context schemas",
            "#",
            "",
            "# TODO(Glenn): disallow (or at least warn) user from manually editing config context schemas that",
            "# have an associated owner, such as a Git repository",
            "",
            "",
            "class ConfigContextSchemaListView(generic.ObjectListView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    filterset_form = forms.ConfigContextSchemaFilterForm",
            "    table = tables.ConfigContextSchemaTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ConfigContextSchemaView(generic.ObjectView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            context[\"format\"] = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontextschema.format\", context[\"format\"], commit=True)",
            "        elif request.user.is_authenticated:",
            "            context[\"format\"] = request.user.get_config(\"extras.configcontextschema.format\", \"json\")",
            "        else:",
            "            context[\"format\"] = \"json\"",
            "",
            "        return context",
            "",
            "",
            "class ConfigContextSchemaObjectValidationView(generic.ObjectView):",
            "    \"\"\"",
            "    This view renders a detail tab that shows tables of objects that utilize the given schema object",
            "    and their validation state.",
            "    \"\"\"",
            "",
            "    queryset = ConfigContextSchema.objects.all()",
            "    template_name = \"extras/configcontextschema_validation.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Reuse the model tables for config context, device, and virtual machine but inject",
            "        the `ConfigContextSchemaValidationStateColumn` and an object edit action button.",
            "        \"\"\"",
            "        # Prep the validator with the schema so it can be reused for all records",
            "        validator = Draft7Validator(instance.data_schema)",
            "",
            "        # Config context table",
            "        config_context_table = tables.ConfigContextTable(",
            "            data=instance.config_contexts.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(validator, \"data\", empty_values=()),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=ConfigContext, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(config_context_table)",
            "",
            "        # Device table",
            "        device_table = DeviceTable(",
            "            data=instance.devices.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(",
            "                        validator, \"local_config_context_data\", empty_values=()",
            "                    ),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=Device, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(device_table)",
            "",
            "        # Virtual machine table",
            "        virtual_machine_table = VirtualMachineTable(",
            "            data=instance.virtual_machines.all(),",
            "            orderable=False,",
            "            extra_columns=[",
            "                (",
            "                    \"validation_state\",",
            "                    tables.ConfigContextSchemaValidationStateColumn(",
            "                        validator, \"local_config_context_data\", empty_values=()",
            "                    ),",
            "                ),",
            "                (\"actions\", ButtonsColumn(model=VirtualMachine, buttons=[\"edit\"])),",
            "            ],",
            "        )",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(virtual_machine_table)",
            "",
            "        return {",
            "            \"config_context_table\": config_context_table,",
            "            \"device_table\": device_table,",
            "            \"virtual_machine_table\": virtual_machine_table,",
            "            \"active_tab\": \"validation\",",
            "        }",
            "",
            "",
            "class ConfigContextSchemaEditView(generic.ObjectEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    model_form = forms.ConfigContextSchemaForm",
            "    template_name = \"extras/configcontextschema_edit.html\"",
            "",
            "",
            "class ConfigContextSchemaBulkEditView(generic.BulkEditView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "    table = tables.ConfigContextSchemaTable",
            "    form = forms.ConfigContextSchemaBulkEditForm",
            "",
            "",
            "class ConfigContextSchemaDeleteView(generic.ObjectDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "",
            "",
            "class ConfigContextSchemaBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ConfigContextSchema.objects.all()",
            "    table = tables.ConfigContextSchemaTable",
            "    filterset = filters.ConfigContextSchemaFilterSet",
            "",
            "",
            "#",
            "# Contacts",
            "#",
            "",
            "",
            "class ContactUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.ContactBulkEditForm",
            "    filterset_class = filters.ContactFilterSet",
            "    filterset_form_class = forms.ContactFilterForm",
            "    form_class = forms.ContactForm",
            "    queryset = Contact.objects.all()",
            "    serializer_class = serializers.ContactSerializer",
            "    table_class = tables.ContactTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        if self.action == \"retrieve\":",
            "            teams = instance.teams.restrict(request.user, \"view\")",
            "            teams_table = tables.TeamTable(teams, orderable=False)",
            "            teams_table.columns.hide(\"actions\")",
            "            paginate = {\"paginator_class\": EnhancedPaginator, \"per_page\": get_paginate_count(request)}",
            "            RequestConfig(request, paginate).configure(teams_table)",
            "            context[\"teams_table\"] = teams_table",
            "",
            "            # TODO: need some consistent ordering of contact_associations",
            "            associations = instance.contact_associations.restrict(request.user, \"view\")",
            "            associations_table = tables.ContactAssociationTable(associations, orderable=False)",
            "            RequestConfig(request, paginate).configure(associations_table)",
            "            context[\"contact_associations_table\"] = associations_table",
            "        return context",
            "",
            "",
            "class ContactAssociationUIViewSet(",
            "    ObjectBulkDestroyViewMixin,",
            "    ObjectBulkUpdateViewMixin,",
            "    ObjectDestroyViewMixin,",
            "    ObjectEditViewMixin,",
            "):",
            "    bulk_update_form_class = forms.ContactAssociationBulkEditForm",
            "    form_class = forms.ContactAssociationForm",
            "    filterset_class = filters.ContactAssociationFilterSet",
            "    queryset = ContactAssociation.objects.all()",
            "    serializer_class = serializers.ContactAssociationSerializer",
            "    table_class = tables.AssociatedContactsTable",
            "    non_filter_params = (\"export\", \"page\", \"per_page\", \"sort\")",
            "",
            "",
            "class ObjectContactTeamMixin:",
            "    \"\"\"Mixin that contains a custom post() method to create a new contact/team and assign it to an existing object\"\"\"",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                if hasattr(form, \"save_note\") and callable(form.save_note):",
            "                    form.save_note(instance=obj, user=request.user)",
            "",
            "                if isinstance(obj, Contact):",
            "                    association = ContactAssociation(",
            "                        contact=obj,",
            "                        associated_object_type=ContentType.objects.get(id=request.POST.get(\"associated_object_type\")),",
            "                        associated_object_id=request.POST.get(\"associated_object_id\"),",
            "                        status=Status.objects.get(id=request.POST.get(\"status\")),",
            "                        role=Role.objects.get(id=request.POST.get(\"role\")) if request.POST.get(\"role\") else None,",
            "                    )",
            "                else:",
            "                    association = ContactAssociation(",
            "                        team=obj,",
            "                        associated_object_type=ContentType.objects.get(id=request.POST.get(\"associated_object_type\")),",
            "                        associated_object_id=request.POST.get(\"associated_object_id\"),",
            "                        status=Status.objects.get(id=request.POST.get(\"status\")),",
            "                        role=Role.objects.get(id=request.POST.get(\"role\")) if request.POST.get(\"role\") else None,",
            "                    )",
            "                association.validated_save()",
            "                self.successful_post(request, obj, object_created, logger)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class ObjectNewContactView(ObjectContactTeamMixin, generic.ObjectEditView):",
            "    queryset = Contact.objects.all()",
            "    model_form = forms.ObjectNewContactForm",
            "    template_name = \"extras/object_new_contact.html\"",
            "",
            "",
            "class ObjectNewTeamView(ObjectContactTeamMixin, generic.ObjectEditView):",
            "    queryset = Team.objects.all()",
            "    model_form = forms.ObjectNewTeamForm",
            "    template_name = \"extras/object_new_team.html\"",
            "",
            "",
            "class ObjectAssignContactOrTeamView(generic.ObjectEditView):",
            "    queryset = ContactAssociation.objects.all()",
            "    model_form = forms.ContactAssociationForm",
            "    template_name = \"extras/object_assign_contact_or_team.html\"",
            "",
            "",
            "#",
            "# Custom fields",
            "#",
            "",
            "",
            "class CustomFieldListView(generic.ObjectListView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "    filterset = filters.CustomFieldFilterSet",
            "    filterset_form = forms.CustomFieldFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomFieldView(generic.ObjectView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldEditView(generic.ObjectEditView):",
            "    queryset = CustomField.objects.all()",
            "    model_form = forms.CustomFieldForm",
            "    template_name = \"extras/customfield_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"choices\"] = forms.CustomFieldChoiceFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # ---> BEGIN difference from ObjectEditView.post()",
            "                    # Process the formsets for choices",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    choices = ctx[\"choices\"]",
            "                    if choices.is_valid():",
            "                        choices.save()",
            "                    else:",
            "                        raise RuntimeError(choices.errors)",
            "                    # <--- END difference from ObjectEditView.post()",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                try:",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                except AttributeError:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # ---> BEGIN difference from ObjectEditView.post()",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving custom field choices. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            # <--- END difference from ObjectEditView.post()",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class CustomFieldDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomField.objects.all()",
            "",
            "",
            "class CustomFieldBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomField.objects.all()",
            "    table = tables.CustomFieldTable",
            "    filterset = filters.CustomFieldFilterSet",
            "",
            "    def construct_custom_field_delete_tasks(self, queryset):",
            "        \"\"\"",
            "        Helper method to construct a list of celery tasks to execute when bulk deleting custom fields.",
            "        \"\"\"",
            "        change_context = change_context_state.get()",
            "        if change_context is None:",
            "            context = None",
            "        else:",
            "            context = change_context.as_dict(queryset)",
            "            context[\"context_detail\"] = \"bulk delete custom field data\"",
            "        tasks = [",
            "            delete_custom_field_data.si(obj.key, set(obj.content_types.values_list(\"pk\", flat=True)), context)",
            "            for obj in queryset",
            "        ]",
            "        return tasks",
            "",
            "    def perform_pre_delete(self, request, queryset):",
            "        \"\"\"",
            "        Remove all Custom Field Keys/Values from _custom_field_data of the related ContentType in the background.",
            "        \"\"\"",
            "        if not get_worker_count():",
            "            messages.error(",
            "                request, \"Celery worker process not running. Object custom fields may fail to reflect this deletion.\"",
            "            )",
            "            return",
            "        tasks = self.construct_custom_field_delete_tasks(queryset)",
            "        # Executing the tasks in the background sequentially using chain() aligns with how a single",
            "        # CustomField object is deleted.  We decided to not check the result because it needs at least one worker",
            "        # to be active and comes with extra performance penalty.",
            "        chain(*tasks).apply_async()",
            "",
            "",
            "#",
            "# Custom Links",
            "#",
            "",
            "",
            "class CustomLinkListView(generic.ObjectListView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "    filterset = filters.CustomLinkFilterSet",
            "    filterset_form = forms.CustomLinkFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class CustomLinkView(generic.ObjectView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkEditView(generic.ObjectEditView):",
            "    queryset = CustomLink.objects.all()",
            "    model_form = forms.CustomLinkForm",
            "",
            "",
            "class CustomLinkDeleteView(generic.ObjectDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "",
            "",
            "class CustomLinkBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = CustomLink.objects.all()",
            "    table = tables.CustomLinkTable",
            "",
            "",
            "#",
            "# Dynamic Groups",
            "#",
            "",
            "",
            "class DynamicGroupListView(generic.ObjectListView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "    filterset = filters.DynamicGroupFilterSet",
            "    filterset_form = forms.DynamicGroupFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class DynamicGroupView(generic.ObjectView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        model = instance.content_type.model_class()",
            "        table_class = get_table_for_model(model)",
            "",
            "        if table_class is not None:",
            "            # Members table (for display on Members nav tab)",
            "            members_table = table_class(instance.members.restrict(request.user, \"view\"), orderable=False)",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "            RequestConfig(request, paginate).configure(members_table)",
            "",
            "            # Descendants table",
            "            descendants_memberships = instance.membership_tree()",
            "            descendants_table = tables.NestedDynamicGroupDescendantsTable(",
            "                descendants_memberships,",
            "                orderable=False,",
            "            )",
            "            descendants_tree = {m.pk: m.depth for m in descendants_memberships}",
            "",
            "            # Ancestors table",
            "            ancestors = instance.get_ancestors()",
            "            ancestors_table = tables.NestedDynamicGroupAncestorsTable(ancestors, orderable=False)",
            "            ancestors_tree = instance.flatten_ancestors_tree(instance.ancestors_tree())",
            "",
            "            context[\"raw_query\"] = pretty_print_query(instance.generate_query())",
            "            context[\"members_table\"] = members_table",
            "            context[\"ancestors_table\"] = ancestors_table",
            "            context[\"ancestors_tree\"] = ancestors_tree",
            "            context[\"descendants_table\"] = descendants_table",
            "            context[\"descendants_tree\"] = descendants_tree",
            "",
            "        return context",
            "",
            "",
            "class DynamicGroupEditView(generic.ObjectEditView):",
            "    queryset = DynamicGroup.objects.all()",
            "    model_form = forms.DynamicGroupForm",
            "    template_name = \"extras/dynamicgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        filterform_class = instance.generate_filter_form()",
            "",
            "        if filterform_class is None:",
            "            filter_form = None",
            "        elif request.POST:",
            "            filter_form = filterform_class(data=request.POST)",
            "        else:",
            "            initial = instance.get_initial()",
            "            filter_form = filterform_class(initial=initial)",
            "",
            "        ctx[\"filter_form\"] = filter_form",
            "",
            "        formset_kwargs = {\"instance\": instance}",
            "        if request.POST:",
            "            formset_kwargs[\"data\"] = request.POST",
            "",
            "        ctx[\"children\"] = forms.DynamicGroupMembershipFormSet(**formset_kwargs)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    # Obtain the instance, but do not yet `save()` it to the database.",
            "                    obj = form.save(commit=False)",
            "",
            "                    # Process the filter form and save the query filters to `obj.filter`.",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    filter_form = ctx[\"filter_form\"]",
            "                    if filter_form.is_valid():",
            "                        obj.set_filter(filter_form.cleaned_data)",
            "                    else:",
            "                        raise RuntimeError(filter_form.errors)",
            "",
            "                    # After filters have been set, now we save the object to the database.",
            "                    obj.save()",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for children",
            "                    children = ctx[\"children\"]",
            "                    if children.is_valid():",
            "                        children.save()",
            "                    else:",
            "                        raise RuntimeError(children.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                try:",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                except AttributeError:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving Dynamic Group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a something that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ValidationError as err:",
            "                msg = \"Invalid filter detected in existing DynamicGroup filter data.\"",
            "                logger.debug(msg)",
            "                err_messages = err.args[0].split(\"\\n\")",
            "                for message in err_messages:",
            "                    if message:",
            "                        form.add_error(None, message)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class DynamicGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "",
            "",
            "class DynamicGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = DynamicGroup.objects.all()",
            "    table = tables.DynamicGroupTable",
            "    filterset = filters.DynamicGroupFilterSet",
            "",
            "",
            "class ObjectDynamicGroupsView(generic.GenericView):",
            "    \"\"\"",
            "    Present a list of dynamic groups associated to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all dynamic groups for this object (and its related objects)",
            "        dynamicsgroups_table = tables.DynamicGroupTable(",
            "            data=obj.dynamic_groups_cached.restrict(request.user, \"view\"), orderable=False",
            "        )",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(dynamicsgroups_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_dynamicgroups.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": dynamicsgroups_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"dynamic-groups\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Export Templates",
            "#",
            "",
            "",
            "class ExportTemplateListView(generic.ObjectListView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "    filterset = filters.ExportTemplateFilterSet",
            "    filterset_form = forms.ExportTemplateFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class ExportTemplateView(generic.ObjectView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateEditView(generic.ObjectEditView):",
            "    queryset = ExportTemplate.objects.all()",
            "    model_form = forms.ExportTemplateForm",
            "",
            "",
            "class ExportTemplateDeleteView(generic.ObjectDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "",
            "",
            "class ExportTemplateBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ExportTemplate.objects.all()",
            "    table = tables.ExportTemplateTable",
            "",
            "",
            "#",
            "# External integrations",
            "#",
            "",
            "",
            "class ExternalIntegrationUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.ExternalIntegrationBulkEditForm",
            "    filterset_class = filters.ExternalIntegrationFilterSet",
            "    filterset_form_class = forms.ExternalIntegrationFilterForm",
            "    form_class = forms.ExternalIntegrationForm",
            "    queryset = ExternalIntegration.objects.select_related(\"secrets_group\")",
            "    serializer_class = serializers.ExternalIntegrationSerializer",
            "    table_class = tables.ExternalIntegrationTable",
            "",
            "",
            "#",
            "# Git repositories",
            "#",
            "",
            "",
            "class GitRepositoryListView(generic.ObjectListView):",
            "    queryset = GitRepository.objects.all()",
            "    filterset = filters.GitRepositoryFilterSet",
            "    filterset_form = forms.GitRepositoryFilterForm",
            "    table = tables.GitRepositoryTable",
            "    template_name = \"extras/gitrepository_list.html\"",
            "",
            "    def extra_context(self):",
            "        # Get the newest results for each repository name",
            "        results = {",
            "            r.task_kwargs[\"repository\"]: r",
            "            for r in JobResult.objects.filter(",
            "                task_name__startswith=\"nautobot.core.jobs.GitRepository\",",
            "                task_kwargs__repository__isnull=False,",
            "                status__in=JobResultStatusChoices.READY_STATES,",
            "            )",
            "            .order_by(\"date_done\")",
            "            .defer(\"result\")",
            "        }",
            "        return {",
            "            \"job_results\": results,",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryView(generic.ObjectView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class GitRepositoryEditView(generic.ObjectEditView):",
            "    queryset = GitRepository.objects.all()",
            "    model_form = forms.GitRepositoryForm",
            "    template_name = \"extras/gitrepository_object_edit.html\"",
            "",
            "    # TODO(jathan): Align with changes for v2 where we're not stashing the user on the instance for",
            "    # magical calls and instead discretely calling `repo.sync(user=user, dry_run=dry_run)`, but",
            "    # again, this will be moved to the API calls, so just something to keep in mind.",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.user = request.user",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def get_return_url(self, request, obj):",
            "        if request.method == \"POST\":",
            "            return reverse(\"extras:gitrepository_result\", kwargs={\"pk\": obj.pk})",
            "        return super().get_return_url(request, obj)",
            "",
            "",
            "class GitRepositoryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "",
            "",
            "class GitRepositoryBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    queryset = GitRepository.objects.all()",
            "    table = tables.GitRepositoryBulkTable",
            "",
            "",
            "class GitRepositoryBulkEditView(generic.BulkEditView):",
            "    queryset = GitRepository.objects.select_related(\"secrets_group\")",
            "    filterset = filters.GitRepositoryFilterSet",
            "    table = tables.GitRepositoryBulkTable",
            "    form = forms.GitRepositoryBulkEditForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        # A GitRepository needs to know the originating request when it's saved so that it can enqueue using it",
            "        obj.request = request",
            "        return super().alter_obj(obj, request, url_args, url_kwargs)",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "class GitRepositoryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GitRepository.objects.all()",
            "    table = tables.GitRepositoryBulkTable",
            "    filterset = filters.GitRepositoryFilterSet",
            "",
            "    def extra_context(self):",
            "        return {",
            "            \"datasource_contents\": get_datasource_contents(\"extras.gitrepository\"),",
            "        }",
            "",
            "",
            "def check_and_call_git_repository_function(request, pk, func):",
            "    \"\"\"Helper for checking Git permissions and worker availability, then calling provided function if all is well",
            "    Args:",
            "        request (HttpRequest): request object.",
            "        pk (UUID): GitRepository pk value.",
            "        func (function): Enqueue git repo function.",
            "    Returns:",
            "        (Union[HttpResponseForbidden,redirect]): HttpResponseForbidden if user does not have permission to run the job,",
            "            otherwise redirect to the job result page.",
            "    \"\"\"",
            "    if not request.user.has_perm(\"extras.change_gitrepository\"):",
            "        return HttpResponseForbidden()",
            "",
            "    # Allow execution only if a worker process is running.",
            "    if not get_worker_count():",
            "        messages.error(request, \"Unable to run job: Celery worker process not running.\")",
            "        return redirect(request.get_full_path(), permanent=False)",
            "    else:",
            "        repository = get_object_or_404(GitRepository.objects.restrict(request.user, \"change\"), pk=pk)",
            "        job_result = func(repository, request.user)",
            "",
            "    return redirect(job_result.get_absolute_url())",
            "",
            "",
            "class GitRepositorySyncView(generic.GenericView):",
            "    def post(self, request, pk):",
            "        return check_and_call_git_repository_function(request, pk, enqueue_pull_git_repository_and_refresh_data)",
            "",
            "",
            "class GitRepositoryDryRunView(generic.GenericView):",
            "    def post(self, request, pk):",
            "        return check_and_call_git_repository_function(request, pk, enqueue_git_repository_diff_origin_and_local)",
            "",
            "",
            "class GitRepositoryResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = GitRepository.objects.all()",
            "    template_name = \"extras/gitrepository_result.html\"",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.view_gitrepository\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        job_result = instance.get_latest_sync()",
            "",
            "        return {",
            "            \"result\": job_result,",
            "            \"base_template\": \"extras/gitrepository.html\",",
            "            \"object\": instance,",
            "            \"active_tab\": \"result\",",
            "        }",
            "",
            "",
            "#",
            "# Saved GraphQL queries",
            "#",
            "",
            "",
            "class GraphQLQueryListView(generic.ObjectListView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "    filterset = filters.GraphQLQueryFilterSet",
            "    filterset_form = forms.GraphQLQueryFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class GraphQLQueryView(generic.ObjectView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryEditView(generic.ObjectEditView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    model_form = forms.GraphQLQueryForm",
            "",
            "",
            "class GraphQLQueryDeleteView(generic.ObjectDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "",
            "",
            "class GraphQLQueryBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = GraphQLQuery.objects.all()",
            "    table = tables.GraphQLQueryTable",
            "",
            "",
            "#",
            "# Image attachments",
            "#",
            "",
            "",
            "class ImageAttachmentEditView(generic.ObjectEditView):",
            "    \"\"\"",
            "    View for creating and editing ImageAttachments.",
            "",
            "    Note that a URL kwargs parameter of \"pk\" identifies an existing ImageAttachment to edit,",
            "    while kwargs of \"object_id\" or \"slug\" identify the parent model instance to attach an ImageAttachment to.",
            "    \"\"\"",
            "",
            "    queryset = ImageAttachment.objects.all()",
            "    model_form = forms.ImageAttachmentForm",
            "",
            "    def get_object(self, kwargs):",
            "        if \"pk\" in kwargs:",
            "            return get_object_or_404(self.queryset, pk=kwargs[\"pk\"])",
            "        return self.queryset.model()",
            "",
            "    def alter_obj(self, imageattachment, request, args, kwargs):",
            "        if not imageattachment.present_in_database:",
            "            # Assign the parent object based on URL kwargs",
            "            model = kwargs.get(\"model\")",
            "            if \"object_id\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, pk=kwargs[\"object_id\"])",
            "            elif \"slug\" in kwargs:",
            "                imageattachment.parent = get_object_or_404(model, slug=kwargs[\"slug\"])",
            "            else:",
            "                raise RuntimeError(\"Neither object_id nor slug were provided?\")",
            "        return imageattachment",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "class ImageAttachmentDeleteView(generic.ObjectDeleteView):",
            "    queryset = ImageAttachment.objects.all()",
            "",
            "    def get_return_url(self, request, imageattachment):",
            "        return imageattachment.parent.get_absolute_url()",
            "",
            "",
            "#",
            "# Jobs",
            "#",
            "",
            "",
            "class JobListView(generic.ObjectListView):",
            "    \"\"\"",
            "    Retrieve all of the available jobs from disk and the recorded JobResult (if any) for each.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "    table = tables.JobTable",
            "    filterset = filters.JobFilterSet",
            "    filterset_form = forms.JobFilterForm",
            "    action_buttons = ()",
            "    non_filter_params = (",
            "        *generic.ObjectListView.non_filter_params,",
            "        \"display\",",
            "    )",
            "    template_name = \"extras/job_list.html\"",
            "",
            "    def alter_queryset(self, request):",
            "        queryset = super().alter_queryset(request)",
            "        # Default to hiding \"hidden\" and non-installed jobs",
            "        if \"hidden\" not in request.GET:",
            "            queryset = queryset.filter(hidden=False)",
            "        if \"installed\" not in request.GET:",
            "            queryset = queryset.filter(installed=True)",
            "        return queryset",
            "",
            "    def extra_context(self):",
            "        # Determine user's preferred display",
            "        if self.request.GET.get(\"display\") in [\"list\", \"tiles\"]:",
            "            display = self.request.GET.get(\"display\")",
            "            if self.request.user.is_authenticated:",
            "                self.request.user.set_config(\"extras.job.display\", display, commit=True)",
            "        elif self.request.user.is_authenticated:",
            "            display = self.request.user.get_config(\"extras.job.display\", \"list\")",
            "        else:",
            "            display = \"list\"",
            "",
            "        return {",
            "            \"table_inc_template\": \"extras/inc/job_tiles.html\" if display == \"tiles\" else \"extras/inc/job_table.html\",",
            "            \"display\": display,",
            "        }",
            "",
            "",
            "class JobRunView(ObjectPermissionRequiredMixin, View):",
            "    \"\"\"",
            "    View the parameters of a Job and enqueue it if desired.",
            "    \"\"\"",
            "",
            "    queryset = JobModel.objects.all()",
            "",
            "    def get_required_permission(self):",
            "        return \"extras.run_job\"",
            "",
            "    def _get_job_model_or_404(self, class_path=None, pk=None):",
            "        \"\"\"Helper function for get() and post().\"\"\"",
            "        if class_path:",
            "            try:",
            "                job_model = self.queryset.get_for_class_path(class_path)",
            "            except JobModel.DoesNotExist:",
            "                raise Http404",
            "        else:",
            "            job_model = get_object_or_404(self.queryset, pk=pk)",
            "",
            "        return job_model",
            "",
            "    def get(self, request, class_path=None, pk=None):",
            "        job_model = self._get_job_model_or_404(class_path, pk)",
            "",
            "        try:",
            "            job_class = get_job(job_model.class_path, reload=True)",
            "            if job_class is None:",
            "                raise RuntimeError(\"Job code for this job is not currently installed or loadable\")",
            "            initial = normalize_querydict(request.GET, form_class=job_class.as_form_class())",
            "            if \"kwargs_from_job_result\" in initial:",
            "                job_result_pk = initial.pop(\"kwargs_from_job_result\")",
            "                try:",
            "                    job_result = job_model.job_results.get(pk=job_result_pk)",
            "                    # Allow explicitly specified arg values in request.GET to take precedence over the saved task_kwargs,",
            "                    # for example \"?kwargs_from_job_result=<UUID>&integervar=22\"",
            "                    explicit_initial = initial",
            "                    initial = job_result.task_kwargs.copy()",
            "                    task_queue = job_result.celery_kwargs.get(\"queue\", None)",
            "                    if task_queue is not None:",
            "                        initial[\"_task_queue\"] = task_queue",
            "                    initial[\"_profile\"] = job_result.celery_kwargs.get(\"nautobot_job_profile\", False)",
            "                    initial.update(explicit_initial)",
            "                except JobResult.DoesNotExist:",
            "                    messages.warning(",
            "                        request,",
            "                        f\"JobResult {job_result_pk} not found, cannot use it to pre-populate inputs.\",",
            "                    )",
            "",
            "            template_name = \"extras/job.html\"",
            "            job_form = job_class.as_form(initial=initial)",
            "            if hasattr(job_class, \"template_name\"):",
            "                try:",
            "                    get_template(job_class.template_name)",
            "                    template_name = job_class.template_name",
            "                except TemplateDoesNotExist as err:",
            "                    messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "        except RuntimeError as err:",
            "            messages.error(request, f\"Unable to run or schedule '{job_model}': {err}\")",
            "            return redirect(\"extras:job_list\")",
            "",
            "        schedule_form = forms.JobScheduleForm(initial=initial)",
            "",
            "        return render(",
            "            request,",
            "            template_name,  # 2.0 TODO: extras/job_submission.html",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "    def post(self, request, class_path=None, pk=None):",
            "        job_model = self._get_job_model_or_404(class_path, pk)",
            "",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "        job_form = job_class.as_form(request.POST, request.FILES) if job_class is not None else None",
            "        schedule_form = forms.JobScheduleForm(request.POST)",
            "        task_queue = request.POST.get(\"_task_queue\")",
            "",
            "        return_url = request.POST.get(\"_return_url\")",
            "        if return_url is not None and url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "            return_url = iri_to_uri(return_url)",
            "        else:",
            "            return_url = None",
            "",
            "        # Allow execution only if a worker process is running and the job is runnable.",
            "        if not get_worker_count(queue=task_queue):",
            "            messages.error(request, \"Unable to run or schedule job: Celery worker process not running.\")",
            "        elif not job_model.installed or job_class is None:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not presently installed.\")",
            "        elif not job_model.enabled:",
            "            messages.error(request, \"Unable to run or schedule job: Job is not enabled to be run.\")",
            "        elif (",
            "            job_model.has_sensitive_variables",
            "            and request.POST.get(\"_schedule_type\") != JobExecutionType.TYPE_IMMEDIATELY",
            "        ):",
            "            messages.error(request, \"Unable to schedule job: Job may have sensitive input variables.\")",
            "        elif job_model.has_sensitive_variables and job_model.approval_required:",
            "            messages.error(",
            "                request,",
            "                \"Unable to run or schedule job: \"",
            "                \"This job is flagged as possibly having sensitive variables but is also flagged as requiring approval.\"",
            "                \"One of these two flags must be removed before this job can be scheduled or run.\",",
            "            )",
            "        elif job_form is not None and job_form.is_valid() and schedule_form.is_valid():",
            "            task_queue = job_form.cleaned_data.pop(\"_task_queue\", None)",
            "            dryrun = job_form.cleaned_data.get(\"dryrun\", False)",
            "            # Run the job. A new JobResult is created.",
            "            profile = job_form.cleaned_data.pop(\"_profile\")",
            "            schedule_type = schedule_form.cleaned_data[\"_schedule_type\"]",
            "",
            "            if (not dryrun and job_model.approval_required) or schedule_type in JobExecutionType.SCHEDULE_CHOICES:",
            "                crontab = \"\"",
            "",
            "                if schedule_type == JobExecutionType.TYPE_IMMEDIATELY:",
            "                    # The job must be approved.",
            "                    # If the schedule_type is immediate, we still create the task, but mark it for approval",
            "                    # as a once in the future task with the due date set to the current time. This means",
            "                    # when approval is granted, the task is immediately due for execution.",
            "                    schedule_type = JobExecutionType.TYPE_FUTURE",
            "                    schedule_datetime = timezone.now()",
            "                    schedule_name = f\"{job_model} - {schedule_datetime}\"",
            "",
            "                else:",
            "                    schedule_name = schedule_form.cleaned_data[\"_schedule_name\"]",
            "",
            "                    if schedule_type == JobExecutionType.TYPE_CUSTOM:",
            "                        crontab = schedule_form.cleaned_data[\"_recurrence_custom_time\"]",
            "                        # doing .get(\"key\", \"default\") returns None instead of \"default\" here for some reason",
            "                        schedule_datetime = schedule_form.cleaned_data.get(\"_schedule_start_time\")",
            "                        if schedule_datetime is None:",
            "                            # \"_schedule_start_time\" is checked against ScheduledJob.earliest_possible_time()",
            "                            # which returns timezone.now() + timedelta(seconds=15)",
            "                            schedule_datetime = timezone.now() + timedelta(seconds=20)",
            "                    else:",
            "                        schedule_datetime = schedule_form.cleaned_data[\"_schedule_start_time\"]",
            "",
            "                celery_kwargs = {\"nautobot_job_profile\": profile, \"queue\": task_queue}",
            "                scheduled_job = ScheduledJob(",
            "                    name=schedule_name,",
            "                    task=job_model.class_path,",
            "                    job_model=job_model,",
            "                    start_time=schedule_datetime,",
            "                    description=f\"Nautobot job {schedule_name} scheduled by {request.user} for {schedule_datetime}\",",
            "                    kwargs=job_class.serialize_data(job_form.cleaned_data),",
            "                    celery_kwargs=celery_kwargs,",
            "                    interval=schedule_type,",
            "                    one_off=schedule_type == JobExecutionType.TYPE_FUTURE,",
            "                    queue=task_queue,",
            "                    user=request.user,",
            "                    approval_required=job_model.approval_required,",
            "                    crontab=crontab,",
            "                )",
            "                scheduled_job.validated_save()",
            "",
            "                if job_model.approval_required:",
            "                    messages.success(request, f\"Job {schedule_name} successfully submitted for approval\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_approval_queue_list\")",
            "                else:",
            "                    messages.success(request, f\"Job {schedule_name} successfully scheduled\")",
            "                    return redirect(return_url if return_url else \"extras:scheduledjob_list\")",
            "",
            "            else:",
            "                # Enqueue job for immediate execution",
            "                job_kwargs = job_class.prepare_job_kwargs(job_form.cleaned_data)",
            "                job_result = JobResult.enqueue_job(",
            "                    job_model,",
            "                    request.user,",
            "                    profile=profile,",
            "                    task_queue=task_queue,",
            "                    **job_class.serialize_data(job_kwargs),",
            "                )",
            "",
            "                if return_url:",
            "                    messages.info(",
            "                        request,",
            "                        format_html(",
            "                            'Job enqueued. <a href=\"{}\">Click here for the results.</a>',",
            "                            job_result.get_absolute_url(),",
            "                        ),",
            "                    )",
            "                    return redirect(return_url)",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "",
            "        if return_url:",
            "            return redirect(return_url)",
            "",
            "        template_name = \"extras/job.html\"",
            "        if job_class is not None and hasattr(job_class, \"template_name\"):",
            "            try:",
            "                get_template(job_class.template_name)",
            "                template_name = job_class.template_name",
            "            except TemplateDoesNotExist as err:",
            "                messages.error(request, f'Unable to render requested custom job template \"{template_name}\": {err}')",
            "",
            "        return render(",
            "            request,",
            "            template_name,",
            "            {",
            "                \"job_model\": job_model,",
            "                \"job_form\": job_form,",
            "                \"schedule_form\": schedule_form,",
            "            },",
            "        )",
            "",
            "",
            "class JobView(generic.ObjectView):",
            "    queryset = JobModel.objects.all()",
            "    template_name = \"extras/job_detail.html\"",
            "",
            "",
            "class JobEditView(generic.ObjectEditView):",
            "    queryset = JobModel.objects.all()",
            "    model_form = forms.JobEditForm",
            "    template_name = \"extras/job_edit.html\"",
            "",
            "",
            "class JobBulkEditView(generic.BulkEditView):",
            "    queryset = JobModel.objects.all()",
            "    filterset = filters.JobFilterSet",
            "    table = tables.JobTable",
            "    form = forms.JobBulkEditForm",
            "    template_name = \"extras/job_bulk_edit.html\"",
            "",
            "    def extra_post_save_action(self, obj, form):",
            "        cleaned_data = form.cleaned_data",
            "",
            "        # Handle text related fields",
            "        for overridable_field in JOB_OVERRIDABLE_FIELDS:",
            "            override_field = overridable_field + \"_override\"",
            "            clear_override_field = \"clear_\" + overridable_field + \"_override\"",
            "            reset_override = cleaned_data.get(clear_override_field, False)",
            "            override_value = cleaned_data.get(overridable_field)",
            "            if reset_override:",
            "                setattr(obj, override_field, False)",
            "            elif not reset_override and override_value not in [None, \"\"]:",
            "                setattr(obj, override_field, True)",
            "                setattr(obj, overridable_field, override_value)",
            "",
            "        obj.validated_save()",
            "",
            "",
            "class JobDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobModel.objects.all()",
            "",
            "",
            "class JobBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobModel.objects.all()",
            "    filterset = filters.JobFilterSet",
            "    table = tables.JobTable",
            "",
            "",
            "class JobApprovalRequestView(generic.ObjectView):",
            "    \"\"\"",
            "    This view handles requests to view and approve a Job execution request.",
            "    It renders the Job's form in much the same way as `JobView` except all",
            "    form fields are disabled and actions on the form relate to approval of the",
            "    job's execution, rather than initial job form input.",
            "    \"\"\"",
            "",
            "    queryset = ScheduledJob.objects.needs_approved()",
            "    template_name = \"extras/job_approval_request.html\"",
            "    additional_permissions = (\"extras.view_job\",)",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"",
            "        Render the job form with data from the scheduled_job instance, but mark all fields as disabled.",
            "        We don't care to actually get any data back from the form as we will not ever change it.",
            "        Instead, we offer the user three submit buttons, dry-run, approve, and deny, which we act upon in the post.",
            "        \"\"\"",
            "        job_model = instance.job_model",
            "        if job_model is not None:",
            "            job_class = get_job(job_model.class_path, reload=True)",
            "        else:",
            "            # 2.0 TODO: remove this fallback?",
            "            job_class = get_job(instance.job_class)",
            "",
            "        if job_class is not None:",
            "            # Render the form with all fields disabled",
            "            initial = instance.kwargs",
            "            initial[\"_task_queue\"] = instance.queue",
            "            initial[\"_profile\"] = instance.celery_kwargs.get(\"profile\", False)",
            "            job_form = job_class().as_form(initial=initial, approval_view=True)",
            "        else:",
            "            job_form = None",
            "",
            "        return {\"job_form\": job_form, **super().get_extra_context(request, instance)}",
            "",
            "    def post(self, request, pk):",
            "        \"\"\"",
            "        Act upon one of the 3 submit button actions from the user.",
            "",
            "        dry-run will immediately enqueue the job with commit=False and send the user to the normal JobResult view",
            "        deny will delete the scheduled_job instance",
            "        approve will mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "        \"\"\"",
            "        scheduled_job = get_object_or_404(ScheduledJob, pk=pk)",
            "",
            "        post_data = request.POST",
            "",
            "        deny = \"_deny\" in post_data",
            "        approve = \"_approve\" in post_data",
            "        force_approve = \"_force_approve\" in post_data",
            "        dry_run = \"_dry_run\" in post_data",
            "",
            "        job_model = scheduled_job.job_model",
            "        job_class = get_job(job_model.class_path, reload=True)",
            "",
            "        if dry_run:",
            "            # To dry-run a job, a user needs the same permissions that would be needed to run the job directly",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not job_model.runnable:",
            "                messages.error(request, \"This job cannot be run at this time\")",
            "            elif not JobModel.objects.check_perms(self.request.user, instance=job_model, action=\"run\"):",
            "                messages.error(request, \"You do not have permission to run this job\")",
            "            elif not job_model.supports_dryrun:",
            "                messages.error(request, \"This job does not support dryrun\")",
            "            else:",
            "                # Immediately enqueue the job and send the user to the normal JobResult view",
            "                job_kwargs = job_class.prepare_job_kwargs(scheduled_job.kwargs or {})",
            "                job_kwargs[\"dryrun\"] = True",
            "                job_result = JobResult.enqueue_job(",
            "                    job_model,",
            "                    request.user,",
            "                    celery_kwargs=scheduled_job.celery_kwargs,",
            "                    **job_class.serialize_data(job_kwargs),",
            "                )",
            "",
            "                return redirect(\"extras:jobresult\", pk=job_result.pk)",
            "        elif deny:",
            "            if not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"delete\")",
            "                and job_model is not None",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to deny this request.\")",
            "            else:",
            "                # Delete the scheduled_job instance",
            "                scheduled_job.delete()",
            "                if request.user == scheduled_job.user:",
            "                    messages.error(request, f\"Approval request for {scheduled_job.name} was revoked\")",
            "                else:",
            "                    messages.error(request, f\"Approval of {scheduled_job.name} was denied\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        elif approve or force_approve:",
            "            if job_model is None:",
            "                messages.error(request, \"There is no job associated with this request? Cannot run it!\")",
            "            elif not (",
            "                self.queryset.check_perms(request.user, instance=scheduled_job, action=\"change\")",
            "                and JobModel.objects.check_perms(request.user, instance=job_model, action=\"approve\")",
            "            ):",
            "                messages.error(request, \"You do not have permission to approve this request.\")",
            "            elif request.user == scheduled_job.user:",
            "                # The requestor *cannot* approve their own job",
            "                messages.error(request, \"You cannot approve your own job request!\")",
            "            else:",
            "                # Mark the scheduled_job as approved, allowing the schedular to schedule the job execution task",
            "                if scheduled_job.one_off and scheduled_job.start_time < timezone.now() and not force_approve:",
            "                    return render(request, \"extras/job_approval_confirmation.html\", {\"scheduled_job\": scheduled_job})",
            "                scheduled_job.approved_by_user = request.user",
            "                scheduled_job.approved_at = timezone.now()",
            "                scheduled_job.save()",
            "",
            "                messages.success(request, f\"{scheduled_job.name} was approved and will now begin execution\")",
            "",
            "                return redirect(\"extras:scheduledjob_approval_queue_list\")",
            "",
            "        return render(",
            "            request,",
            "            self.get_template_name(),",
            "            {",
            "                \"object\": scheduled_job,",
            "                **self.get_extra_context(request, scheduled_job),",
            "            },",
            "        )",
            "",
            "",
            "class ScheduledJobListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.enabled()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "",
            "",
            "class ScheduledJobBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "    table = tables.ScheduledJobTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "",
            "",
            "class ScheduledJobApprovalQueueListView(generic.ObjectListView):",
            "    queryset = ScheduledJob.objects.needs_approved()",
            "    table = tables.ScheduledJobApprovalQueueTable",
            "    filterset = filters.ScheduledJobFilterSet",
            "    filterset_form = forms.ScheduledJobFilterForm",
            "    action_buttons = ()",
            "    template_name = \"extras/scheduled_jobs_approval_queue_list.html\"",
            "",
            "",
            "class ScheduledJobView(generic.ObjectView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        job_class = get_job(instance.task)",
            "        labels = {}",
            "        if job_class is not None:",
            "            for name, var in job_class._get_vars().items():",
            "                field = var.as_field()",
            "                if field.label:",
            "                    labels[name] = field.label",
            "                else:",
            "                    labels[name] = pretty_name(name)",
            "        return {",
            "            \"labels\": labels,",
            "            \"job_class_found\": (job_class is not None),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class ScheduledJobDeleteView(generic.ObjectDeleteView):",
            "    queryset = ScheduledJob.objects.all()",
            "",
            "",
            "#",
            "# Job hooks",
            "#",
            "",
            "",
            "class JobHookListView(generic.ObjectListView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "    filterset = filters.JobHookFilterSet",
            "    filterset_form = forms.JobHookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class JobHookView(generic.ObjectView):",
            "    queryset = JobHook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class JobHookEditView(generic.ObjectEditView):",
            "    queryset = JobHook.objects.all()",
            "    model_form = forms.JobHookForm",
            "",
            "",
            "class JobHookDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobHook.objects.all()",
            "",
            "",
            "class JobHookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = JobHook.objects.all()",
            "    table = tables.JobHookTable",
            "",
            "",
            "#",
            "# JobResult",
            "#",
            "",
            "",
            "def get_annotated_jobresult_queryset():",
            "    return (",
            "        JobResult.objects.defer(\"result\")",
            "        .select_related(\"job_model\", \"user\")",
            "        .annotate(",
            "            debug_log_count=count_related(",
            "                JobLogEntry, \"job_result\", filter_dict={\"log_level\": LogLevelChoices.LOG_DEBUG}",
            "            ),",
            "            info_log_count=count_related(",
            "                JobLogEntry, \"job_result\", filter_dict={\"log_level\": LogLevelChoices.LOG_INFO}",
            "            ),",
            "            warning_log_count=count_related(",
            "                JobLogEntry, \"job_result\", filter_dict={\"log_level\": LogLevelChoices.LOG_WARNING}",
            "            ),",
            "            error_log_count=count_related(",
            "                JobLogEntry,",
            "                \"job_result\",",
            "                filter_dict={\"log_level__in\": [LogLevelChoices.LOG_ERROR, LogLevelChoices.LOG_CRITICAL]},",
            "            ),",
            "        )",
            "    )",
            "",
            "",
            "class JobResultListView(generic.ObjectListView):",
            "    \"\"\"",
            "    List JobResults",
            "    \"\"\"",
            "",
            "    queryset = get_annotated_jobresult_queryset()",
            "    filterset = filters.JobResultFilterSet",
            "    filterset_form = forms.JobResultFilterForm",
            "    table = tables.JobResultTable",
            "    action_buttons = ()",
            "",
            "",
            "class JobResultDeleteView(generic.ObjectDeleteView):",
            "    queryset = JobResult.objects.all()",
            "",
            "",
            "class JobResultBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = get_annotated_jobresult_queryset()",
            "    table = tables.JobResultTable",
            "    filterset = filters.JobResultFilterSet",
            "",
            "",
            "class JobResultView(generic.ObjectView):",
            "    \"\"\"",
            "    Display a JobResult and its Job data.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.prefetch_related(\"job_model\", \"user\")",
            "    template_name = \"extras/jobresult.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        associated_record = None",
            "        job_class = None",
            "        if instance.job_model is not None:",
            "            job_class = instance.job_model.job_class",
            "",
            "        return {",
            "            \"job\": job_class,",
            "            \"associated_record\": associated_record,",
            "            \"result\": instance,",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class JobLogEntryTableView(generic.GenericView):",
            "    \"\"\"",
            "    Display a table of `JobLogEntry` objects for a given `JobResult` instance.",
            "    \"\"\"",
            "",
            "    queryset = JobResult.objects.all()",
            "",
            "    def get(self, request, pk=None):",
            "        instance = get_object_or_404(self.queryset.restrict(request.user, \"view\"), pk=pk)",
            "        filter_q = request.GET.get(\"q\")",
            "        if filter_q:",
            "            queryset = instance.job_log_entries.filter(",
            "                Q(message__icontains=filter_q) | Q(log_level__icontains=filter_q)",
            "            )",
            "        else:",
            "            queryset = instance.job_log_entries.all()",
            "        log_table = tables.JobLogEntryTable(data=queryset, user=request.user)",
            "        RequestConfig(request).configure(log_table)",
            "        return HttpResponse(log_table.as_html(request))",
            "",
            "",
            "#",
            "# Job Button",
            "#",
            "",
            "",
            "class JobButtonUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.JobButtonBulkEditForm",
            "    filterset_class = filters.JobButtonFilterSet",
            "    filterset_form_class = forms.JobButtonFilterForm",
            "    form_class = forms.JobButtonForm",
            "    queryset = JobButton.objects.all()",
            "    serializer_class = serializers.JobButtonSerializer",
            "    table_class = tables.JobButtonTable",
            "",
            "",
            "#",
            "# Change logging",
            "#",
            "",
            "",
            "class ObjectChangeListView(generic.ObjectListView):",
            "    queryset = ObjectChange.objects.all()",
            "    filterset = filters.ObjectChangeFilterSet",
            "    filterset_form = forms.ObjectChangeFilterForm",
            "    table = tables.ObjectChangeTable",
            "    template_name = \"extras/objectchange_list.html\"",
            "    action_buttons = (\"export\",)",
            "",
            "    # 2.0 TODO: Remove this remapping and solve it at the `BaseFilterSet` as it is addressing a breaking change.",
            "    def get(self, request, **kwargs):",
            "        # Remappings below allow previous queries of time_before and time_after to use",
            "        # newer methods specifying the lookup method.",
            "",
            "        # They will only use the previous arguments if the newer ones are undefined",
            "",
            "        if request.GET.get(\"time_after\") and request.GET.get(\"time__gte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__gte\": request.GET.get(\"time_after\")})",
            "            request.GET._mutable = False",
            "",
            "        if request.GET.get(\"time_before\") and request.GET.get(\"time__lte\") is None:",
            "            request.GET._mutable = True",
            "            request.GET.update({\"time__lte\": request.GET.get(\"time_before\")})",
            "            request.GET._mutable = False",
            "",
            "        return super().get(request=request, **kwargs)",
            "",
            "",
            "class ObjectChangeView(generic.ObjectView):",
            "    queryset = ObjectChange.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        related_changes = instance.get_related_changes(user=request.user).filter(request_id=instance.request_id)",
            "        related_changes_table = tables.ObjectChangeTable(data=related_changes[:50], orderable=False)",
            "",
            "        snapshots = instance.get_snapshots()",
            "        return {",
            "            \"diff_added\": snapshots[\"differences\"][\"added\"],",
            "            \"diff_removed\": snapshots[\"differences\"][\"removed\"],",
            "            \"next_change\": instance.get_next_change(request.user),",
            "            \"prev_change\": instance.get_prev_change(request.user),",
            "            \"related_changes_table\": related_changes_table,",
            "            \"related_changes_count\": related_changes.count(),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class ObjectChangeLogView(generic.GenericView):",
            "    \"\"\"",
            "    Present a history of changes made to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        # Gather all changes for this object (and its related objects)",
            "        content_type = ContentType.objects.get_for_model(model)",
            "        objectchanges = (",
            "            ObjectChange.objects.restrict(request.user, \"view\")",
            "            .select_related(\"user\", \"changed_object_type\")",
            "            .filter(",
            "                Q(changed_object_type=content_type, changed_object_id=obj.pk)",
            "                | Q(related_object_type=content_type, related_object_id=obj.pk)",
            "            )",
            "        )",
            "        objectchanges_table = tables.ObjectChangeTable(data=objectchanges, orderable=False)",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(objectchanges_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_changelog.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": objectchanges_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"changelog\",",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Notes",
            "#",
            "",
            "",
            "class NoteView(generic.ObjectView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class NoteListView(generic.ObjectListView):",
            "    \"\"\"",
            "    List Notes",
            "    \"\"\"",
            "",
            "    queryset = Note.objects.all()",
            "    filterset = filters.NoteFilterSet",
            "    filterset_form = forms.NoteFilterForm",
            "    table = tables.NoteTable",
            "    action_buttons = ()",
            "",
            "",
            "class NoteEditView(generic.ObjectEditView):",
            "    queryset = Note.objects.all()",
            "    model_form = forms.NoteForm",
            "",
            "    def alter_obj(self, obj, request, url_args, url_kwargs):",
            "        obj.user = request.user",
            "        return obj",
            "",
            "",
            "class NoteDeleteView(generic.ObjectDeleteView):",
            "    queryset = Note.objects.all()",
            "",
            "",
            "class ObjectNotesView(generic.GenericView):",
            "    \"\"\"",
            "    Present a list of notes associated to a particular object.",
            "    base_template: The name of the template to extend. If not provided, \"<app>/<model>.html\" will be used.",
            "    \"\"\"",
            "",
            "    base_template = None",
            "",
            "    def get(self, request, model, **kwargs):",
            "        # Handle QuerySet restriction of parent object if needed",
            "        if hasattr(model.objects, \"restrict\"):",
            "            obj = get_object_or_404(model.objects.restrict(request.user, \"view\"), **kwargs)",
            "        else:",
            "            obj = get_object_or_404(model, **kwargs)",
            "",
            "        notes_form = forms.NoteForm(",
            "            initial={",
            "                \"assigned_object_type\": ContentType.objects.get_for_model(obj),",
            "                \"assigned_object_id\": obj.pk,",
            "            }",
            "        )",
            "        notes_table = tables.NoteTable(obj.notes.restrict(request.user, \"view\"))",
            "",
            "        # Apply the request context",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(notes_table)",
            "",
            "        self.base_template = get_base_template(self.base_template, model)",
            "",
            "        return render(",
            "            request,",
            "            \"extras/object_notes.html\",",
            "            {",
            "                \"object\": obj,",
            "                \"verbose_name\": obj._meta.verbose_name,",
            "                \"verbose_name_plural\": obj._meta.verbose_name_plural,",
            "                \"table\": notes_table,",
            "                \"base_template\": self.base_template,",
            "                \"active_tab\": \"notes\",",
            "                \"form\": notes_form,",
            "            },",
            "        )",
            "",
            "",
            "#",
            "# Relationship",
            "#",
            "",
            "",
            "class RelationshipListView(generic.ObjectListView):",
            "    queryset = Relationship.objects.all()",
            "    filterset = filters.RelationshipFilterSet",
            "    filterset_form = forms.RelationshipFilterForm",
            "    table = tables.RelationshipTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class RelationshipView(generic.ObjectView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipEditView(generic.ObjectEditView):",
            "    queryset = Relationship.objects.all()",
            "    model_form = forms.RelationshipForm",
            "    template_name = \"extras/relationship_edit.html\"",
            "",
            "",
            "class RelationshipBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Relationship.objects.all()",
            "    table = tables.RelationshipTable",
            "    filterset = filters.RelationshipFilterSet",
            "",
            "",
            "class RelationshipDeleteView(generic.ObjectDeleteView):",
            "    queryset = Relationship.objects.all()",
            "",
            "",
            "class RelationshipAssociationListView(generic.ObjectListView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    filterset = filters.RelationshipAssociationFilterSet",
            "    filterset_form = forms.RelationshipAssociationFilterForm",
            "    table = tables.RelationshipAssociationTable",
            "    action_buttons = ()",
            "",
            "",
            "class RelationshipAssociationBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "    table = tables.RelationshipAssociationTable",
            "    filterset = filters.RelationshipAssociationFilterSet",
            "",
            "",
            "class RelationshipAssociationDeleteView(generic.ObjectDeleteView):",
            "    queryset = RelationshipAssociation.objects.all()",
            "",
            "",
            "#",
            "# Roles",
            "#",
            "",
            "",
            "class RoleUIViewSet(viewsets.NautobotUIViewSet):",
            "    \"\"\"`Roles` UIViewSet.\"\"\"",
            "",
            "    queryset = Role.objects.all()",
            "    bulk_update_form_class = forms.RoleBulkEditForm",
            "    filterset_class = filters.RoleFilterSet",
            "    filterset_form_class = forms.RoleFilterForm",
            "    form_class = forms.RoleForm",
            "    serializer_class = serializers.RoleSerializer",
            "    table_class = tables.RoleTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        if self.action == \"retrieve\":",
            "            context[\"content_types\"] = instance.content_types.order_by(\"app_label\", \"model\")",
            "",
            "            paginate = {",
            "                \"paginator_class\": EnhancedPaginator,",
            "                \"per_page\": get_paginate_count(request),",
            "            }",
            "",
            "            if ContentType.objects.get_for_model(Device) in context[\"content_types\"]:",
            "                devices = instance.devices.select_related(",
            "                    \"status\",",
            "                    \"location\",",
            "                    \"tenant\",",
            "                    \"role\",",
            "                    \"rack\",",
            "                    \"device_type\",",
            "                ).restrict(request.user, \"view\")",
            "                device_table = DeviceTable(devices)",
            "                device_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(device_table)",
            "                context[\"device_table\"] = device_table",
            "",
            "            if ContentType.objects.get_for_model(Controller) in context[\"content_types\"]:",
            "                controllers = instance.controllers.select_related(",
            "                    \"status\",",
            "                    \"location\",",
            "                    \"tenant\",",
            "                    \"role\",",
            "                ).restrict(request.user, \"view\")",
            "                controller_table = ControllerTable(controllers)",
            "                controller_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(controller_table)",
            "                context[\"controller_table\"] = controller_table",
            "",
            "            if ContentType.objects.get_for_model(IPAddress) in context[\"content_types\"]:",
            "                ipaddress = (",
            "                    instance.ip_addresses.select_related(\"status\", \"tenant\")",
            "                    .restrict(request.user, \"view\")",
            "                    .annotate(",
            "                        interface_count=count_related(Interface, \"ip_addresses\"),",
            "                        interface_parent_count=count_related(Device, \"interfaces__ip_addresses\", distinct=True),",
            "                        vm_interface_count=count_related(VMInterface, \"ip_addresses\"),",
            "                        vm_interface_parent_count=count_related(",
            "                            VirtualMachine, \"interfaces__ip_addresses\", distinct=True",
            "                        ),",
            "                    )",
            "                )",
            "                ipaddress_table = IPAddressTable(ipaddress)",
            "                ipaddress_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(ipaddress_table)",
            "                context[\"ipaddress_table\"] = ipaddress_table",
            "",
            "            if ContentType.objects.get_for_model(Prefix) in context[\"content_types\"]:",
            "                prefixes = (",
            "                    instance.prefixes.select_related(",
            "                        \"status\",",
            "                        \"tenant\",",
            "                        \"vlan\",",
            "                        \"namespace\",",
            "                    )",
            "                    .restrict(request.user, \"view\")",
            "                    .annotate(location_count=count_related(Location, \"prefixes\"))",
            "                )",
            "                prefix_table = PrefixTable(prefixes)",
            "                prefix_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(prefix_table)",
            "                context[\"prefix_table\"] = prefix_table",
            "            if ContentType.objects.get_for_model(Rack) in context[\"content_types\"]:",
            "                racks = instance.racks.select_related(",
            "                    \"location\",",
            "                    \"status\",",
            "                    \"tenant\",",
            "                    \"rack_group\",",
            "                ).restrict(request.user, \"view\")",
            "                rack_table = RackTable(racks)",
            "                rack_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(rack_table)",
            "                context[\"rack_table\"] = rack_table",
            "            if ContentType.objects.get_for_model(VirtualMachine) in context[\"content_types\"]:",
            "                virtual_machines = instance.virtual_machines.select_related(",
            "                    \"cluster\",",
            "                    \"role\",",
            "                    \"status\",",
            "                    \"tenant\",",
            "                ).restrict(request.user, \"view\")",
            "                virtual_machine_table = VirtualMachineTable(virtual_machines)",
            "                virtual_machine_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(virtual_machine_table)",
            "                context[\"virtual_machine_table\"] = virtual_machine_table",
            "",
            "            if ContentType.objects.get_for_model(VLAN) in context[\"content_types\"]:",
            "                vlans = (",
            "                    instance.vlans.annotate(location_count=count_related(Location, \"vlans\"))",
            "                    .select_related(",
            "                        \"vlan_group\",",
            "                        \"status\",",
            "                        \"tenant\",",
            "                    )",
            "                    .restrict(request.user, \"view\")",
            "                )",
            "                vlan_table = VLANTable(vlans)",
            "                vlan_table.columns.hide(\"role\")",
            "                RequestConfig(request, paginate).configure(vlan_table)",
            "                context[\"vlan_table\"] = vlan_table",
            "        return context",
            "",
            "",
            "#",
            "# Secrets",
            "#",
            "",
            "",
            "class SecretListView(generic.ObjectListView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    filterset_form = forms.SecretFilterForm",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretView(generic.ObjectView):",
            "    queryset = Secret.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        # Determine user's preferred output format",
            "        if request.GET.get(\"format\") in [\"json\", \"yaml\"]:",
            "            format_ = request.GET.get(\"format\")",
            "            if request.user.is_authenticated:",
            "                request.user.set_config(\"extras.configcontext.format\", format_, commit=True)",
            "        elif request.user.is_authenticated:",
            "            format_ = request.user.get_config(\"extras.configcontext.format\", \"json\")",
            "        else:",
            "            format_ = \"json\"",
            "",
            "        provider = registry[\"secrets_providers\"].get(instance.provider)",
            "",
            "        groups = instance.secrets_groups.distinct()",
            "        groups_table = tables.SecretsGroupTable(groups, orderable=False)",
            "",
            "        return {",
            "            \"format\": format_,",
            "            \"provider_name\": provider.name if provider else instance.provider,",
            "            \"groups_table\": groups_table,",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class SecretProviderParametersFormView(generic.GenericView):",
            "    \"\"\"",
            "    Helper view to SecretView; retrieve the HTML form appropriate for entering parameters for a given SecretsProvider.",
            "    \"\"\"",
            "",
            "    def get(self, request, provider_slug):",
            "        provider = registry[\"secrets_providers\"].get(provider_slug)",
            "        if not provider:",
            "            raise Http404",
            "        return render(",
            "            request,",
            "            \"extras/inc/secret_provider_parameters_form.html\",",
            "            {\"form\": provider.ParametersForm(initial=request.GET)},",
            "        )",
            "",
            "",
            "class SecretEditView(generic.ObjectEditView):",
            "    queryset = Secret.objects.all()",
            "    model_form = forms.SecretForm",
            "    template_name = \"extras/secret_edit.html\"",
            "",
            "",
            "class SecretDeleteView(generic.ObjectDeleteView):",
            "    queryset = Secret.objects.all()",
            "",
            "",
            "class SecretBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    queryset = Secret.objects.all()",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Secret.objects.all()",
            "    filterset = filters.SecretFilterSet",
            "    table = tables.SecretTable",
            "",
            "",
            "class SecretsGroupListView(generic.ObjectListView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    filterset_form = forms.SecretsGroupFilterForm",
            "    table = tables.SecretsGroupTable",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class SecretsGroupView(generic.ObjectView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {\"secrets_group_associations\": SecretsGroupAssociation.objects.filter(secrets_group=instance)}",
            "",
            "",
            "class SecretsGroupEditView(generic.ObjectEditView):",
            "    queryset = SecretsGroup.objects.all()",
            "    model_form = forms.SecretsGroupForm",
            "    template_name = \"extras/secretsgroup_edit.html\"",
            "",
            "    def get_extra_context(self, request, instance):",
            "        ctx = super().get_extra_context(request, instance)",
            "",
            "        if request.POST:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(data=request.POST, instance=instance)",
            "        else:",
            "            ctx[\"secrets\"] = forms.SecretsGroupAssociationFormSet(instance=instance)",
            "",
            "        return ctx",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        obj = self.alter_obj(self.get_object(kwargs), request, args, kwargs)",
            "        form = self.model_form(data=request.POST, files=request.FILES, instance=obj)",
            "        restrict_form_fields(form, request.user)",
            "",
            "        if form.is_valid():",
            "            logger.debug(\"Form validation was successful\")",
            "",
            "            try:",
            "                with transaction.atomic():",
            "                    object_created = not form.instance.present_in_database",
            "                    obj = form.save()",
            "",
            "                    # Check that the new object conforms with any assigned object-level permissions",
            "                    self.queryset.get(pk=obj.pk)",
            "",
            "                    # Process the formsets for secrets",
            "                    ctx = self.get_extra_context(request, obj)",
            "                    secrets = ctx[\"secrets\"]",
            "                    if secrets.is_valid():",
            "                        secrets.save()",
            "                    else:",
            "                        raise RuntimeError(secrets.errors)",
            "                verb = \"Created\" if object_created else \"Modified\"",
            "                msg = f\"{verb} {self.queryset.model._meta.verbose_name}\"",
            "                logger.info(f\"{msg} {obj} (PK: {obj.pk})\")",
            "                try:",
            "                    msg = format_html('{} <a href=\"{}\">{}</a>', msg, obj.get_absolute_url(), obj)",
            "                except AttributeError:",
            "                    msg = format_html(\"{} {}\", msg, obj)",
            "                messages.success(request, msg)",
            "",
            "                if \"_addanother\" in request.POST:",
            "                    # If the object has clone_fields, pre-populate a new instance of the form",
            "                    if hasattr(obj, \"clone_fields\"):",
            "                        url = f\"{request.path}?{prepare_cloned_fields(obj)}\"",
            "                        return redirect(url)",
            "",
            "                    return redirect(request.get_full_path())",
            "",
            "                return_url = form.cleaned_data.get(\"return_url\")",
            "                if url_has_allowed_host_and_scheme(url=return_url, allowed_hosts=request.get_host()):",
            "                    return redirect(iri_to_uri(return_url))",
            "                else:",
            "                    return redirect(self.get_return_url(request, obj))",
            "",
            "            except ObjectDoesNotExist:",
            "                msg = \"Object save failed due to object-level permissions violation.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except RuntimeError:",
            "                msg = \"Errors encountered when saving secrets group associations. See below.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "            except ProtectedError as err:",
            "                # e.g. Trying to delete a choice that is in use.",
            "                err_msg = err.args[0]",
            "                protected_obj = err.protected_objects[0]",
            "                msg = f\"{protected_obj.value}: {err_msg} Please cancel this edit and start again.\"",
            "                logger.debug(msg)",
            "                form.add_error(None, msg)",
            "",
            "        else:",
            "            logger.debug(\"Form validation failed\")",
            "",
            "        return render(",
            "            request,",
            "            self.template_name,",
            "            {",
            "                \"obj\": obj,",
            "                \"obj_type\": self.queryset.model._meta.verbose_name,",
            "                \"form\": form,",
            "                \"return_url\": self.get_return_url(request, obj),",
            "                \"editing\": obj.present_in_database,",
            "                **self.get_extra_context(request, obj),",
            "            },",
            "        )",
            "",
            "",
            "class SecretsGroupDeleteView(generic.ObjectDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "",
            "",
            "class SecretsGroupBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = SecretsGroup.objects.all()",
            "    filterset = filters.SecretsGroupFilterSet",
            "    table = tables.SecretsGroupTable",
            "",
            "",
            "#",
            "# Custom statuses",
            "#",
            "",
            "",
            "class StatusListView(generic.ObjectListView):",
            "    \"\"\"List `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    filterset = filters.StatusFilterSet",
            "    filterset_form = forms.StatusFilterForm",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusEditView(generic.ObjectEditView):",
            "    \"\"\"Edit a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    model_form = forms.StatusForm",
            "",
            "",
            "class StatusBulkEditView(generic.BulkEditView):",
            "    \"\"\"Edit multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "    form = forms.StatusBulkEditForm",
            "",
            "",
            "class StatusBulkDeleteView(generic.BulkDeleteView):",
            "    \"\"\"Delete multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusDeleteView(generic.ObjectDeleteView):",
            "    \"\"\"Delete a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "",
            "class StatusBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    \"\"\"Bulk CSV import of multiple `Status` objects.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "    table = tables.StatusTable",
            "",
            "",
            "class StatusView(generic.ObjectView):",
            "    \"\"\"Detail view for a single `Status` object.\"\"\"",
            "",
            "    queryset = Status.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        \"\"\"Return ordered content types.\"\"\"",
            "        return {",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "#",
            "# Tags",
            "#",
            "",
            "",
            "class TagListView(generic.ObjectListView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    filterset = filters.TagFilterSet",
            "    filterset_form = forms.TagFilterForm",
            "    table = tables.TagTable",
            "",
            "",
            "class TagView(generic.ObjectView):",
            "    queryset = Tag.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        tagged_items = (",
            "            TaggedItem.objects.filter(tag=instance).select_related(\"content_type\").prefetch_related(\"content_object\")",
            "        )",
            "",
            "        # Generate a table of all items tagged with this Tag",
            "        items_table = tables.TaggedItemTable(tagged_items)",
            "        paginate = {",
            "            \"paginator_class\": EnhancedPaginator,",
            "            \"per_page\": get_paginate_count(request),",
            "        }",
            "        RequestConfig(request, paginate).configure(items_table)",
            "",
            "        return {",
            "            \"items_count\": tagged_items.count(),",
            "            \"items_table\": items_table,",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class TagEditView(generic.ObjectEditView):",
            "    queryset = Tag.objects.all()",
            "    model_form = forms.TagForm",
            "    template_name = \"extras/tag_edit.html\"",
            "",
            "",
            "class TagDeleteView(generic.ObjectDeleteView):",
            "    queryset = Tag.objects.all()",
            "",
            "",
            "class TagBulkImportView(generic.BulkImportView):  # 3.0 TODO: remove, unused",
            "    queryset = Tag.objects.all()",
            "    table = tables.TagTable",
            "",
            "",
            "class TagBulkEditView(generic.BulkEditView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "    form = forms.TagBulkEditForm",
            "    filterset = filters.TagFilterSet",
            "",
            "",
            "class TagBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Tag.objects.annotate(items=count_related(TaggedItem, \"tag\"))",
            "    table = tables.TagTable",
            "    filterset = filters.TagFilterSet",
            "",
            "",
            "#",
            "# Teams",
            "#",
            "",
            "",
            "class TeamUIViewSet(NautobotUIViewSet):",
            "    bulk_update_form_class = forms.TeamBulkEditForm",
            "    filterset_class = filters.TeamFilterSet",
            "    filterset_form_class = forms.TeamFilterForm",
            "    form_class = forms.TeamForm",
            "    queryset = Team.objects.all()",
            "    serializer_class = serializers.TeamSerializer",
            "    table_class = tables.TeamTable",
            "",
            "    def get_extra_context(self, request, instance):",
            "        context = super().get_extra_context(request, instance)",
            "        if self.action == \"retrieve\":",
            "            contacts = instance.contacts.restrict(request.user, \"view\")",
            "            contacts_table = tables.ContactTable(contacts, orderable=False)",
            "            contacts_table.columns.hide(\"actions\")",
            "            paginate = {\"paginator_class\": EnhancedPaginator, \"per_page\": get_paginate_count(request)}",
            "            RequestConfig(request, paginate).configure(contacts_table)",
            "            context[\"contacts_table\"] = contacts_table",
            "",
            "            # TODO: need some consistent ordering of contact_associations",
            "            associations = instance.contact_associations.restrict(request.user, \"view\")",
            "            associations_table = tables.ContactAssociationTable(associations, orderable=False)",
            "            RequestConfig(request, paginate).configure(associations_table)",
            "            context[\"contact_associations_table\"] = associations_table",
            "        return context",
            "",
            "",
            "#",
            "# Webhooks",
            "#",
            "",
            "",
            "class WebhookListView(generic.ObjectListView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "    filterset = filters.WebhookFilterSet",
            "    filterset_form = forms.WebhookFilterForm",
            "    action_buttons = (\"add\",)",
            "",
            "",
            "class WebhookView(generic.ObjectView):",
            "    queryset = Webhook.objects.all()",
            "",
            "    def get_extra_context(self, request, instance):",
            "        return {",
            "            \"content_types\": instance.content_types.order_by(\"app_label\", \"model\"),",
            "            **super().get_extra_context(request, instance),",
            "        }",
            "",
            "",
            "class WebhookEditView(generic.ObjectEditView):",
            "    queryset = Webhook.objects.all()",
            "    model_form = forms.WebhookForm",
            "",
            "",
            "class WebhookDeleteView(generic.ObjectDeleteView):",
            "    queryset = Webhook.objects.all()",
            "",
            "",
            "class WebhookBulkDeleteView(generic.BulkDeleteView):",
            "    queryset = Webhook.objects.all()",
            "    table = tables.WebhookTable",
            "",
            "",
            "#",
            "# Job Extra Views",
            "#",
            "# NOTE: Due to inheritance, JobObjectChangeLogView and JobObjectNotesView can only be",
            "# constructed below # ObjectChangeLogView and ObjectNotesView.",
            "",
            "",
            "class JobObjectChangeLogView(ObjectChangeLogView):",
            "    base_template = \"extras/job_detail.html\"",
            "",
            "",
            "class JobObjectNotesView(ObjectNotesView):",
            "    base_template = \"extras/job_detail.html\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "707": [
                "DynamicGroupView",
                "get_extra_context"
            ],
            "887": [
                "ObjectDynamicGroupsView",
                "get"
            ]
        },
        "addLocation": []
    }
}