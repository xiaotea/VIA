{
    "scipy/weave/catalog.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " import sys"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+import stat"
            },
            "4": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " import pickle"
            },
            "5": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " import socket"
            },
            "6": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " import tempfile"
            },
            "7": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "     # Do NOT use a hardcoded name here due to the danger from race conditions"
            },
            "9": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     # on NFS when multiple processes are accessing the same base directory in"
            },
            "10": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # parallel.  We use both hostname and pocess id for the prefix in an"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    # parallel.  We use both hostname and process id for the prefix in an"
            },
            "12": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     # attempt to ensure that there can really be no name collisions (tempfile"
            },
            "13": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     # appends 6 random chars to this prefix)."
            },
            "14": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     prefix = 'dummy_%s_%s_' % (socket.gethostname(),os.getpid())"
            },
            "15": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "     \"\"\"return a string identifying the user.\"\"\""
            },
            "16": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "     return os.environ.get(\"USER\") or os.environ.get(\"USERNAME\") or \"unknown\""
            },
            "17": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+def _create_dirs(path):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+    \"\"\" create provided path, ignore errors \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    try:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        os.makedirs(path, mode=0o700)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    except OSError:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        pass"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+def default_dir_posix(tmp_dir=None):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    \"\"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    Create or find default catalog store for posix systems"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+    purpose of 'tmp_dir' is to enable way how to test this function easily"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    \"\"\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+    path_candidates = []"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    if tmp_dir:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        home_dir = tmp_dir"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    else:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        home_dir = os.path.expanduser('~')"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    tmp_dir = tmp_dir or tempfile.gettempdir()"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    home_temp_dir_name = '.' + python_name"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    home_temp_dir = os.path.join(home_dir, home_temp_dir_name)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+    path_candidates.append(home_temp_dir)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+    temp_dir_name = repr(os.getuid()) + '_' + python_name"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+    temp_dir_path = os.path.join(tmp_dir, temp_dir_name)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    path_candidates.append(temp_dir_path)"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+    for path in path_candidates:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        _create_dirs(path)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        if check_dir(path):"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            return path"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+    # since we got here, both dirs are not useful"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    tmp_dir_path = find_valid_temp_dir(temp_dir_name, tmp_dir)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+    if not tmp_dir_path:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+        tmp_dir_path = create_temp_dir(temp_dir_name, tmp_dir=tmp_dir)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+    return tmp_dir_path"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+def default_dir_win(tmp_dir=None):"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+    \"\"\""
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+    Create or find default catalog store for Windows systems"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+    purpose of 'tmp_dir' is to enable way how to test this function easily"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+    \"\"\""
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+    def create_win_temp_dir(prefix, inner_dir=None, tmp_dir=None):"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+        \"\"\""
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        create temp dir starting with 'prefix' in 'tmp_dir' or"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        'tempfile.gettempdir'; if 'inner_dir' is specified, it should be"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        created inside"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        \"\"\""
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        tmp_dir_path = find_valid_temp_dir(prefix, tmp_dir)"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+        if tmp_dir_path:"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            if inner_dir:"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+                if not os.path.isdir(tmp_dir_path):"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+                    os.mkdir(tmp_dir_path, 0o700)"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        else:"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            tmp_dir_path = create_temp_dir(prefix, inner_dir, tmp_dir)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        return tmp_dir_path"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    tmp_dir = tmp_dir or tempfile.gettempdir()"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+    temp_dir_name = \"%s\" % whoami()"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+    temp_root_dir = os.path.join(tmp_dir, temp_dir_name)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+    temp_dir_path = os.path.join(temp_root_dir, python_name)"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+    _create_dirs(temp_dir_path)"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+    if check_dir(temp_dir_path) and check_dir(temp_root_dir):"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        return temp_dir_path"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    else:"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        if check_dir(temp_root_dir):"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+            return create_win_temp_dir(python_name, tmp_dir=temp_root_dir)"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+        else:"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+            return create_win_temp_dir(temp_dir_name, python_name, tmp_dir)"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " def default_dir():"
            },
            "101": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     \"\"\" Return a default location to store compiled files and catalogs."
            },
            "102": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "         in the user's home, /tmp/<uid>_pythonXX_compiled is used.  If it"
            },
            "104": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         doesn't exist, it is created.  The directory is marked rwx------"
            },
            "105": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         to try and keep people from being able to sneak a bad module"
            },
            "106": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        in on you."
            },
            "107": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        in on you. If the directory already exists in /tmp/ and is not"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        secure, new one is created."
            },
            "110": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "     \"\"\""
            },
            "111": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "112": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     # Use a cached value for fast return if possible"
            },
            "113": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if hasattr(default_dir,\"cached_path\") and \\"
            },
            "114": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-       os.path.exists(default_dir.cached_path) and \\"
            },
            "115": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-       os.access(default_dir.cached_path, os.W_OK):"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+    if hasattr(default_dir, \"cached_path\") and \\"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+       check_dir(default_dir.cached_path):"
            },
            "118": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         return default_dir.cached_path"
            },
            "119": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 257,
                "PatchRowcode": " "
            },
            "120": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])"
            },
            "121": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    path_candidates = []"
            },
            "122": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if sys.platform != 'win32':"
            },
            "123": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "124": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path_candidates.append(os.path.join(os.environ['HOME'],"
            },
            "125": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                '.' + python_name))"
            },
            "126": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except KeyError:"
            },
            "127": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            pass"
            },
            "128": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "129": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        temp_dir = repr(os.getuid()) + '_' + python_name"
            },
            "130": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path_candidates.append(os.path.join(tempfile.gettempdir(), temp_dir))"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+    if sys.platform == 'win32':"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+        path = default_dir_win()"
            },
            "133": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     else:"
            },
            "134": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path_candidates.append(os.path.join(tempfile.gettempdir(),"
            },
            "135": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                           \"%s\" % whoami(), python_name))"
            },
            "136": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "137": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    writable = False"
            },
            "138": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for path in path_candidates:"
            },
            "139": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not os.path.exists(path):"
            },
            "140": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            try:"
            },
            "141": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                os.makedirs(path, mode=0o700)"
            },
            "142": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except OSError:"
            },
            "143": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                continue"
            },
            "144": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if is_writable(path):"
            },
            "145": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            writable = True"
            },
            "146": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            break"
            },
            "147": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "148": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not writable:"
            },
            "149": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        print('warning: default directory is not write accessible.')"
            },
            "150": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        print('default:', path)"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        path = default_dir_posix()"
            },
            "152": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "153": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "     # Cache the default dir path so that this function returns quickly after"
            },
            "154": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "     # being called once (nothing in it should change after the first call)"
            },
            "155": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "     default_dir.cached_path = path"
            },
            "156": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 266,
                "PatchRowcode": " "
            },
            "157": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "     return path"
            },
            "158": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 268,
                "PatchRowcode": " "
            },
            "159": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def intermediate_dir():"
            },
            "160": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\" Location in temp dir for storing .cpp and .o  files during"
            },
            "161": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        builds."
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+def check_dir(im_dir):"
            },
            "164": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "     \"\"\""
            },
            "165": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    python_name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])"
            },
            "166": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    path = os.path.join(tempfile.gettempdir(),\"%s\"%whoami(),python_name)"
            },
            "167": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not os.path.exists(path):"
            },
            "168": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os.makedirs(path, mode=0o700)"
            },
            "169": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return path"
            },
            "170": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+    Check if dir is safe; if it is, return True."
            },
            "171": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    These checks make sense only on posix:"
            },
            "172": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+     * directory has correct owner"
            },
            "173": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+     * directory has correct permissions (0700)"
            },
            "174": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+     * directory is not a symlink"
            },
            "175": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    \"\"\""
            },
            "176": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+    def check_is_dir():"
            },
            "177": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+        return os.path.isdir(im_dir)"
            },
            "178": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+    def check_permissions():"
            },
            "180": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+        \"\"\" If on posix, permissions should be 0700. \"\"\""
            },
            "181": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+        writable = is_writable(im_dir)"
            },
            "182": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        if sys.platform != 'win32':"
            },
            "183": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+            try:"
            },
            "184": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+                im_dir_stat = os.stat(im_dir)"
            },
            "185": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            except OSError:"
            },
            "186": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+                return False"
            },
            "187": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            writable &= stat.S_IMODE(im_dir_stat.st_mode) == 0o0700"
            },
            "188": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        return writable"
            },
            "189": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+"
            },
            "190": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+    def check_ownership():"
            },
            "191": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+        \"\"\" Intermediate dir owner should be same as owner of process. \"\"\""
            },
            "192": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+        if sys.platform != 'win32':"
            },
            "193": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+            try:"
            },
            "194": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+                im_dir_stat = os.stat(im_dir)"
            },
            "195": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+            except OSError:"
            },
            "196": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+                return False"
            },
            "197": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+            proc_uid = os.getuid()"
            },
            "198": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+            return proc_uid == im_dir_stat.st_uid"
            },
            "199": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+        return True"
            },
            "200": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+"
            },
            "201": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+    def check_is_symlink():"
            },
            "202": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        \"\"\" Check if intermediate dir is symlink. \"\"\""
            },
            "203": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        try:"
            },
            "204": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+            return not os.path.islink(im_dir)"
            },
            "205": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+        except OSError:"
            },
            "206": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+            return False"
            },
            "207": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+"
            },
            "208": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+    checks = [check_is_dir, check_permissions,"
            },
            "209": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+              check_ownership, check_is_symlink]"
            },
            "210": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+"
            },
            "211": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+    for check in checks:"
            },
            "212": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+        if not check():"
            },
            "213": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+            return False"
            },
            "214": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+"
            },
            "215": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+    return True"
            },
            "216": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+"
            },
            "217": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+"
            },
            "218": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+def create_temp_dir(prefix, inner_dir=None, tmp_dir=None):"
            },
            "219": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+    \"\"\""
            },
            "220": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+    Create intermediate dirs <tmp>/<prefix+random suffix>/<inner_dir>/"
            },
            "221": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+"
            },
            "222": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+    argument 'tmp_dir' is used in unit tests"
            },
            "223": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+    \"\"\""
            },
            "224": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+    if not tmp_dir:"
            },
            "225": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+        tmp_dir_path = tempfile.mkdtemp(prefix=prefix)"
            },
            "226": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+    else:"
            },
            "227": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 329,
                "PatchRowcode": "+        tmp_dir_path = tempfile.mkdtemp(prefix=prefix, dir=tmp_dir)"
            },
            "228": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 330,
                "PatchRowcode": "+    if inner_dir:"
            },
            "229": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 331,
                "PatchRowcode": "+        tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)"
            },
            "230": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+        os.mkdir(tmp_dir_path, 0o700)"
            },
            "231": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+    return tmp_dir_path"
            },
            "232": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+"
            },
            "233": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+"
            },
            "234": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+def intermediate_dir_prefix():"
            },
            "235": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 337,
                "PatchRowcode": "+    \"\"\" Prefix of root intermediate dir (<tmp>/<root_im_dir>). \"\"\""
            },
            "236": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 338,
                "PatchRowcode": "+    return \"%s-%s-\" % (\"scipy\", whoami())"
            },
            "237": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+"
            },
            "238": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+"
            },
            "239": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+def find_temp_dir(prefix, tmp_dir=None):"
            },
            "240": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+    \"\"\" Find temp dirs in 'tmp_dir' starting with 'prefix'\"\"\""
            },
            "241": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+    matches = []"
            },
            "242": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+    tmp_dir = tmp_dir or tempfile.gettempdir()"
            },
            "243": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+    for tmp_file in os.listdir(tmp_dir):"
            },
            "244": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+        if tmp_file.startswith(prefix):"
            },
            "245": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+            matches.append(os.path.join(tmp_dir, tmp_file))"
            },
            "246": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+    return matches"
            },
            "247": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+"
            },
            "248": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+"
            },
            "249": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+def find_valid_temp_dir(prefix, tmp_dir=None):"
            },
            "250": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+    \"\"\""
            },
            "251": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    Try to look for existing temp dirs."
            },
            "252": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+    If there is one suitable found, return it, otherwise return None."
            },
            "253": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+    \"\"\""
            },
            "254": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+    matches = find_temp_dir(prefix, tmp_dir)"
            },
            "255": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+    for match in matches:"
            },
            "256": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        if check_dir(match):"
            },
            "257": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+            # as soon as we find correct dir, we can stop searching"
            },
            "258": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+            return match"
            },
            "259": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+"
            },
            "260": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+"
            },
            "261": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+def py_intermediate_dir():"
            },
            "262": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+    \"\"\""
            },
            "263": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+    Name of intermediate dir for current python interpreter:"
            },
            "264": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+    <temp dir>/<name>/pythonXY_intermediate/"
            },
            "265": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+    \"\"\""
            },
            "266": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+    name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])"
            },
            "267": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+    return name"
            },
            "268": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+"
            },
            "269": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+"
            },
            "270": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+def create_intermediate_dir(tmp_dir=None):"
            },
            "271": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+    py_im_dir = py_intermediate_dir()"
            },
            "272": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+    return create_temp_dir(intermediate_dir_prefix(), py_im_dir, tmp_dir)"
            },
            "273": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+"
            },
            "274": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+"
            },
            "275": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+def intermediate_dir(tmp_dir=None):"
            },
            "276": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+    \"\"\""
            },
            "277": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+    Temporary directory for storing .cpp and .o files during builds."
            },
            "278": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+"
            },
            "279": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+    First, try to find the dir and if it exists, verify it is safe."
            },
            "280": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+    Otherwise, create it."
            },
            "281": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+    \"\"\""
            },
            "282": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+    im_dir = find_valid_temp_dir(intermediate_dir_prefix(), tmp_dir)"
            },
            "283": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+    py_im_dir = py_intermediate_dir()"
            },
            "284": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+    if im_dir is None:"
            },
            "285": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+        py_im_dir = py_intermediate_dir()"
            },
            "286": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+        im_dir = create_intermediate_dir(tmp_dir)"
            },
            "287": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+    else:"
            },
            "288": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+        im_dir = os.path.join(im_dir, py_im_dir)"
            },
            "289": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+        if not os.path.isdir(im_dir):"
            },
            "290": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+            os.mkdir(im_dir, 0o700)"
            },
            "291": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+    return im_dir"
            },
            "292": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+"
            },
            "293": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 395,
                "PatchRowcode": " "
            },
            "294": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 396,
                "PatchRowcode": " def default_temp_dir():"
            },
            "295": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "     path = os.path.join(default_dir(),'temp')"
            }
        },
        "frontPatchFile": [
            "\"\"\" Track relationships between compiled extension functions & code fragments",
            "",
            "    catalog keeps track of which compiled(or even standard) functions are",
            "    related to which code fragments.  It also stores these relationships",
            "    to disk so they are remembered between Python sessions.  When",
            "",
            "        a = 1",
            "        compiler.inline('printf(\"printed from C: %d\",a);',['a'] )",
            "",
            "    is called, inline() first looks to see if it has seen the code",
            "    'printf(\"printed from C\");' before.  If not, it calls",
            "",
            "        catalog.get_functions('printf(\"printed from C: %d\", a);')",
            "",
            "    which returns a list of all the function objects that have been compiled",
            "    for the code fragment.  Multiple functions can occur because the code",
            "    could be compiled for different types for 'a' (although not likely in",
            "    this case). The catalog first looks in its cache and quickly returns",
            "    a list of the functions if possible.  If the cache lookup fails, it then",
            "    looks through possibly multiple catalog files on disk and fills its",
            "    cache with all the functions that match the code fragment.",
            "",
            "    In case where the code fragment hasn't been compiled, inline() compiles",
            "    the code and then adds it to the catalog:",
            "",
            "        function = <code to compile function>",
            "        catalog.add_function('printf(\"printed from C: %d\", a);',function)",
            "",
            "    add_function() adds function to the front of the cache.  function,",
            "    along with the path information to its module, are also stored in a",
            "    persistent catalog for future use by python sessions.",
            "\"\"\"",
            "from __future__ import absolute_import, print_function",
            "",
            "import os",
            "import sys",
            "import pickle",
            "import socket",
            "import tempfile",
            "",
            "try:",
            "    import dbhash",
            "    import shelve",
            "    dumb = 0",
            "except ImportError:",
            "    from . import _dumb_shelve as shelve",
            "    dumb = 1",
            "",
            "#For testing...",
            "#import scipy.io.dumb_shelve as shelve",
            "#dumb = 1",
            "",
            "#import shelve",
            "#dumb = 0",
            "",
            "def getmodule(object):",
            "    \"\"\" Discover the name of the module where object was defined.",
            "",
            "        This is an augmented version of inspect.getmodule that can discover",
            "        the parent module for extension functions.",
            "    \"\"\"",
            "    import inspect",
            "    value = inspect.getmodule(object)",
            "    if value is None:",
            "        #walk trough all modules looking for function",
            "        for name,mod in sys.modules.items():",
            "            # try except used because of some comparison failures",
            "            # in wxPoint code.  Need to review this",
            "            try:",
            "                if mod and object in mod.__dict__.values():",
            "                    value = mod",
            "                    # if it is a built-in module, keep looking to see",
            "                    # if a non-builtin also has it.  Otherwise quit and",
            "                    # consider the module found. (ain't perfect, but will",
            "                    # have to do for now).",
            "                    if str(mod) not in '(built-in)':",
            "                        break",
            "",
            "            except (TypeError, KeyError, ImportError):",
            "                pass",
            "    return value",
            "",
            "def expr_to_filename(expr):",
            "    \"\"\" Convert an arbitrary expr string to a valid file name.",
            "",
            "        The name is based on the md5 check sum for the string and",
            "        Something that was a little more human readable would be",
            "        nice, but the computer doesn't seem to care.",
            "    \"\"\"",
            "    import scipy.weave.md5_load as md5",
            "    base = 'sc_'",
            "    return base + md5.new(expr).hexdigest()",
            "",
            "def unique_file(d,expr):",
            "    \"\"\" Generate a unqiue file name based on expr in directory d",
            "",
            "        This is meant for use with building extension modules, so",
            "        a file name is considered unique if none of the following",
            "        extension '.cpp','.o','.so','module.so','.py', or '.pyd'",
            "        exists in directory d.  The fully qualified path to the",
            "        new name is returned.  You'll need to append your own",
            "        extension to it before creating files.",
            "    \"\"\"",
            "    files = os.listdir(d)",
            "    #base = 'scipy_compile'",
            "    base = expr_to_filename(expr)",
            "    for i in xrange(1000000):",
            "        fname = base + repr(i)",
            "        if not (fname+'.cpp' in files or",
            "                fname+'.o' in files or",
            "                fname+'.so' in files or",
            "                fname+'module.so' in files or",
            "                fname+'.py' in files or",
            "                fname+'.pyd' in files):",
            "            break",
            "    return os.path.join(d,fname)",
            "",
            "def is_writable(dir):",
            "    \"\"\"Determine whether a given directory is writable in a portable manner.",
            "",
            "    Parameters",
            "    ----------",
            "    dir : str",
            "        A string represeting a path to a directory on the filesystem.",
            "",
            "    Returns",
            "    -------",
            "    res : bool",
            "        True or False.",
            "    \"\"\"",
            "    if not os.path.isdir(dir):",
            "        return False",
            "",
            "    # Do NOT use a hardcoded name here due to the danger from race conditions",
            "    # on NFS when multiple processes are accessing the same base directory in",
            "    # parallel.  We use both hostname and pocess id for the prefix in an",
            "    # attempt to ensure that there can really be no name collisions (tempfile",
            "    # appends 6 random chars to this prefix).",
            "    prefix = 'dummy_%s_%s_' % (socket.gethostname(),os.getpid())",
            "    try:",
            "        tmp = tempfile.TemporaryFile(prefix=prefix,dir=dir)",
            "    except OSError:",
            "        return False",
            "    # The underlying file is destroyed upon closing the file object (under",
            "    # *nix, it was unlinked at creation time)",
            "    tmp.close()",
            "    return True",
            "",
            "def whoami():",
            "    \"\"\"return a string identifying the user.\"\"\"",
            "    return os.environ.get(\"USER\") or os.environ.get(\"USERNAME\") or \"unknown\"",
            "",
            "def default_dir():",
            "    \"\"\" Return a default location to store compiled files and catalogs.",
            "",
            "        XX is the Python version number in all paths listed below",
            "        On windows, the default location is the temporary directory",
            "        returned by gettempdir()/pythonXX.",
            "",
            "        On Unix, ~/.pythonXX_compiled is the default location.  If it doesn't",
            "        exist, it is created.  The directory is marked rwx------.",
            "",
            "        If for some reason it isn't possible to build a default directory",
            "        in the user's home, /tmp/<uid>_pythonXX_compiled is used.  If it",
            "        doesn't exist, it is created.  The directory is marked rwx------",
            "        to try and keep people from being able to sneak a bad module",
            "        in on you.",
            "",
            "    \"\"\"",
            "",
            "    # Use a cached value for fast return if possible",
            "    if hasattr(default_dir,\"cached_path\") and \\",
            "       os.path.exists(default_dir.cached_path) and \\",
            "       os.access(default_dir.cached_path, os.W_OK):",
            "        return default_dir.cached_path",
            "",
            "    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])",
            "    path_candidates = []",
            "    if sys.platform != 'win32':",
            "        try:",
            "            path_candidates.append(os.path.join(os.environ['HOME'],",
            "                                                '.' + python_name))",
            "        except KeyError:",
            "            pass",
            "",
            "        temp_dir = repr(os.getuid()) + '_' + python_name",
            "        path_candidates.append(os.path.join(tempfile.gettempdir(), temp_dir))",
            "    else:",
            "        path_candidates.append(os.path.join(tempfile.gettempdir(),",
            "                                           \"%s\" % whoami(), python_name))",
            "",
            "    writable = False",
            "    for path in path_candidates:",
            "        if not os.path.exists(path):",
            "            try:",
            "                os.makedirs(path, mode=0o700)",
            "            except OSError:",
            "                continue",
            "        if is_writable(path):",
            "            writable = True",
            "            break",
            "",
            "    if not writable:",
            "        print('warning: default directory is not write accessible.')",
            "        print('default:', path)",
            "",
            "    # Cache the default dir path so that this function returns quickly after",
            "    # being called once (nothing in it should change after the first call)",
            "    default_dir.cached_path = path",
            "",
            "    return path",
            "",
            "def intermediate_dir():",
            "    \"\"\" Location in temp dir for storing .cpp and .o  files during",
            "        builds.",
            "    \"\"\"",
            "    python_name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])",
            "    path = os.path.join(tempfile.gettempdir(),\"%s\"%whoami(),python_name)",
            "    if not os.path.exists(path):",
            "        os.makedirs(path, mode=0o700)",
            "    return path",
            "",
            "def default_temp_dir():",
            "    path = os.path.join(default_dir(),'temp')",
            "    if not os.path.exists(path):",
            "        os.makedirs(path, mode=0o700)",
            "    if not is_writable(path):",
            "        print('warning: default directory is not write accessible.')",
            "        print('default:', path)",
            "    return path",
            "",
            "",
            "def os_dependent_catalog_name():",
            "    \"\"\" Generate catalog name dependent on OS and Python version being used.",
            "",
            "        This allows multiple platforms to have catalog files in the",
            "        same directory without stepping on each other.  For now, it",
            "        bases the name of the value returned by sys.platform and the",
            "        version of python being run.  If this isn't enough to descriminate",
            "        on some platforms, we can try to add other info.  It has",
            "        occurred to me that if we get fancy enough to optimize for different",
            "        architectures, then chip type might be added to the catalog name also.",
            "    \"\"\"",
            "    version = '%d%d' % sys.version_info[:2]",
            "    return sys.platform+version+'compiled_catalog'",
            "",
            "def catalog_path(module_path):",
            "    \"\"\" Return the full path name for the catalog file in the given directory.",
            "",
            "        module_path can either be a file name or a path name.  If it is a",
            "        file name, the catalog file name in its parent directory is returned.",
            "        If it is a directory, the catalog file in that directory is returned.",
            "",
            "        If module_path doesn't exist, None is returned.  Note though, that the",
            "        catalog file does *not* have to exist, only its parent.  '~', shell",
            "        variables, and relative ('.' and '..') paths are all acceptable.",
            "",
            "        catalog file names are os dependent (based on sys.platform), so this",
            "        should support multiple platforms sharing the same disk space",
            "        (NFS mounts). See os_dependent_catalog_name() for more info.",
            "    \"\"\"",
            "    module_path = os.path.expanduser(module_path)",
            "    module_path = os.path.expandvars(module_path)",
            "    module_path = os.path.abspath(module_path)",
            "    if not os.path.exists(module_path):",
            "        catalog_file = None",
            "    elif not os.path.isdir(module_path):",
            "        module_path,dummy = os.path.split(module_path)",
            "        catalog_file = os.path.join(module_path,os_dependent_catalog_name())",
            "    else:",
            "        catalog_file = os.path.join(module_path,os_dependent_catalog_name())",
            "    return catalog_file",
            "",
            "def get_catalog(module_path,mode='r'):",
            "    \"\"\" Return a function catalog (shelve object) from the path module_path",
            "",
            "        If module_path is a directory, the function catalog returned is",
            "        from that directory.  If module_path is an actual module_name,",
            "        then the function catalog returned is from its parent directory.",
            "        mode uses the standard 'c' = create, 'n' = new, 'r' = read,",
            "        'w' = write file open modes available for anydbm databases.",
            "",
            "        Well... it should be.  Stuck with dumbdbm for now and the modes",
            "        almost don't matter.  We do some checking for 'r' mode, but that",
            "        is about it.",
            "",
            "        See catalog_path() for more information on module_path.",
            "    \"\"\"",
            "    if mode not in ['c','r','w','n']:",
            "        msg = \" mode must be 'c', 'n', 'r', or 'w'.  See anydbm for more info\"",
            "        raise ValueError(msg)",
            "    catalog_file = catalog_path(module_path)",
            "    if (catalog_file is not None) \\",
            "           and ((dumb and os.path.exists(catalog_file+'.dat')) \\",
            "                or os.path.exists(catalog_file)):",
            "        sh = shelve.open(catalog_file,mode)",
            "    else:",
            "        if mode=='r':",
            "            sh = None",
            "        else:",
            "            sh = shelve.open(catalog_file,mode)",
            "    return sh",
            "",
            "class catalog(object):",
            "    \"\"\" Stores information about compiled functions both in cache and on disk.",
            "",
            "        catalog stores (code, list_of_function) pairs so that all the functions",
            "        that have been compiled for code are available for calling (usually in",
            "        inline or blitz).",
            "",
            "        catalog keeps a dictionary of previously accessed code values cached",
            "        for quick access.  It also handles the looking up of functions compiled",
            "        in previously called Python sessions on disk in function catalogs.",
            "        catalog searches the directories in the PYTHONCOMPILED environment",
            "        variable in order loading functions that correspond to the given code",
            "        fragment.  A default directory is also searched for catalog functions.",
            "        On unix, the default directory is usually '~/.pythonxx_compiled' where",
            "        xx is the version of Python used. On windows, it is the directory",
            "        returned by temfile.gettempdir().  Functions closer to the front are of",
            "        the variable list are guaranteed to be closer to the front of the",
            "        function list so that they will be called first.  See",
            "        get_cataloged_functions() for more info on how the search order is",
            "        traversed.",
            "",
            "        Catalog also handles storing information about compiled functions to",
            "        a catalog.  When writing this information, the first writable catalog",
            "        file in PYTHONCOMPILED path is used.  If a writable catalog is not",
            "        found, it is written to the catalog in the default directory.  This",
            "        directory should always be writable.",
            "    \"\"\"",
            "    def __init__(self,user_path_list=None):",
            "        \"\"\" Create a catalog for storing/searching for compiled functions.",
            "",
            "            user_path_list contains directories that should be searched",
            "            first for function catalogs.  They will come before the path",
            "            entries in the PYTHONCOMPILED environment varilable.",
            "        \"\"\"",
            "        if isinstance(user_path_list, str):",
            "            self.user_path_list = [user_path_list]",
            "        elif user_path_list:",
            "            self.user_path_list = user_path_list",
            "        else:",
            "            self.user_path_list = []",
            "        self.cache = {}",
            "        self.module_dir = None",
            "        self.paths_added = 0",
            "        # unconditionally append the default dir for auto-generated compiled",
            "        # extension modules, so that pickle.load()s don't fail.",
            "        sys.path.append(default_dir())",
            "",
            "    def set_module_directory(self,module_dir):",
            "        \"\"\" Set the path that will replace 'MODULE' in catalog searches.",
            "",
            "            You should call clear_module_directory() when your finished",
            "            working with it.",
            "        \"\"\"",
            "        self.module_dir = module_dir",
            "    def get_module_directory(self):",
            "        \"\"\" Return the path used to replace the 'MODULE' in searches.",
            "        \"\"\"",
            "        return self.module_dir",
            "    def clear_module_directory(self):",
            "        \"\"\" Reset 'MODULE' path to None so that it is ignored in searches.",
            "        \"\"\"",
            "        self.module_dir = None",
            "",
            "    def get_environ_path(self):",
            "        \"\"\" Return list of paths from 'PYTHONCOMPILED' environment variable.",
            "",
            "            On Unix the path in PYTHONCOMPILED is a ':' separated list of",
            "            directories.  On Windows, a ';' separated list is used.",
            "        \"\"\"",
            "        paths = []",
            "        if 'PYTHONCOMPILED' in os.environ:",
            "            path_string = os.environ['PYTHONCOMPILED']",
            "            paths = path_string.split(os.path.pathsep)",
            "        return paths",
            "",
            "    def build_search_order(self):",
            "        \"\"\" Returns a list of paths that are searched for catalogs.",
            "",
            "            Values specified in the catalog constructor are searched first,",
            "            then values found in the PYTHONCOMPILED environment variable.",
            "            The directory returned by default_dir() is always returned at",
            "            the end of the list.",
            "",
            "            There is a 'magic' path name called 'MODULE' that is replaced",
            "            by the directory defined by set_module_directory().  If the",
            "            module directory hasn't been set, 'MODULE' is ignored.",
            "        \"\"\"",
            "",
            "        paths = self.user_path_list + self.get_environ_path()",
            "        search_order = []",
            "        for path in paths:",
            "            if path == 'MODULE':",
            "                if self.module_dir:",
            "                    search_order.append(self.module_dir)",
            "            else:",
            "                search_order.append(path)",
            "        search_order.append(default_dir())",
            "        return search_order",
            "",
            "    def get_catalog_files(self):",
            "        \"\"\" Returns catalog file list in correct search order.",
            "",
            "            Some of the catalog files may not currently exists.",
            "            However, all will be valid locations for a catalog",
            "            to be created (if you have write permission).",
            "        \"\"\"",
            "        files = map(catalog_path,self.build_search_order())",
            "        files = filter(lambda x: x is not None,files)",
            "        return files",
            "",
            "    def get_existing_files(self):",
            "        \"\"\" Returns all existing catalog file list in correct search order.",
            "        \"\"\"",
            "        files = self.get_catalog_files()",
            "        # open every stinking file to check if it exists.",
            "        # This is because anydbm doesn't provide a consistent naming",
            "        # convention across platforms for its files",
            "        existing_files = []",
            "        for file in files:",
            "            cat = get_catalog(os.path.dirname(file),'r')",
            "            if cat is not None:",
            "                existing_files.append(file)",
            "                cat.close()",
            "        # This is the non-portable (and much faster) old code",
            "        #existing_files = filter(os.path.exists,files)",
            "        return existing_files",
            "",
            "    def get_writable_file(self,existing_only=0):",
            "        \"\"\" Return the name of the first writable catalog file.",
            "",
            "            Its parent directory must also be writable.  This is so that",
            "            compiled modules can be written to the same directory.",
            "        \"\"\"",
            "        # note: both file and its parent directory must be writeable",
            "        if existing_only:",
            "            files = self.get_existing_files()",
            "        else:",
            "            files = self.get_catalog_files()",
            "        # filter for (file exists and is writable) OR directory is writable",
            "        def file_test(x):",
            "            from os import access, F_OK, W_OK",
            "            return (access(x,F_OK) and access(x,W_OK) or",
            "                    access(os.path.dirname(x),W_OK))",
            "        writable = filter(file_test,files)",
            "        if writable:",
            "            file = writable[0]",
            "        else:",
            "            file = None",
            "        return file",
            "",
            "    def get_writable_dir(self):",
            "        \"\"\" Return the parent directory of first writable catalog file.",
            "",
            "            The returned directory has write access.",
            "        \"\"\"",
            "        return os.path.dirname(self.get_writable_file())",
            "",
            "    def unique_module_name(self,code,module_dir=None):",
            "        \"\"\" Return full path to unique file name that in writable location.",
            "",
            "            The directory for the file is the first writable directory in",
            "            the catalog search path.  The unique file name is derived from",
            "            the code fragment.  If, module_dir is specified, it is used",
            "            to replace 'MODULE' in the search path.",
            "        \"\"\"",
            "        if module_dir is not None:",
            "            self.set_module_directory(module_dir)",
            "        try:",
            "            d = self.get_writable_dir()",
            "        finally:",
            "            if module_dir is not None:",
            "                self.clear_module_directory()",
            "        return unique_file(d, code)",
            "",
            "    def path_key(self,code):",
            "        \"\"\" Return key for path information for functions associated with code.",
            "        \"\"\"",
            "        return '__path__' + code",
            "",
            "    def configure_path(self,cat,code):",
            "        \"\"\" Add the python path for the given code to the sys.path",
            "",
            "            unconfigure_path() should be called as soon as possible after",
            "            imports associated with code are finished so that sys.path",
            "            is restored to normal.",
            "        \"\"\"",
            "        try:",
            "            paths = cat[self.path_key(code)]",
            "            self.paths_added = len(paths)",
            "            sys.path = paths + sys.path",
            "        except:",
            "            self.paths_added = 0",
            "",
            "    def unconfigure_path(self):",
            "        \"\"\" Restores sys.path to normal after calls to configure_path()",
            "",
            "            Remove the previously added paths from sys.path",
            "        \"\"\"",
            "        sys.path = sys.path[self.paths_added:]",
            "        self.paths_added = 0",
            "",
            "    def get_cataloged_functions(self,code):",
            "        \"\"\" Load all functions associated with code from catalog search path.",
            "",
            "            Sometimes there can be trouble loading a function listed in a",
            "            catalog file because the actual module that holds the function",
            "            has been moved or deleted.  When this happens, that catalog file",
            "            is \"repaired\", meaning the entire entry for this function is",
            "            removed from the file.  This only affects the catalog file that",
            "            has problems -- not the others in the search path.",
            "",
            "            The \"repair\" behavior may not be needed, but I'll keep it for now.",
            "        \"\"\"",
            "        mode = 'r'",
            "        cat = None",
            "        function_list = []",
            "        for path in self.build_search_order():",
            "            cat = get_catalog(path,mode)",
            "            if cat is not None and code in cat:",
            "                # set up the python path so that modules for this",
            "                # function can be loaded.",
            "                self.configure_path(cat,code)",
            "                try:",
            "                    function_list += cat[code]",
            "                except: #SystemError and ImportError so far seen",
            "                    # problems loading a function from the catalog.  Try to",
            "                    # repair the cause.",
            "                    cat.close()",
            "                    self.repair_catalog(path,code)",
            "                self.unconfigure_path()",
            "            if cat is not None:",
            "                # ensure that the catalog is properly closed",
            "                cat.close()",
            "        return function_list",
            "",
            "",
            "    def repair_catalog(self,catalog_path,code):",
            "        \"\"\" Remove entry for code from catalog_path",
            "",
            "            Occasionally catalog entries could get corrupted. An example",
            "            would be when a module that had functions in the catalog was",
            "            deleted or moved on the disk.  The best current repair method is",
            "            just to trash the entire catalog entry for this piece of code.",
            "            This may loose function entries that are valid, but thats life.",
            "",
            "            catalog_path must be writable for repair.  If it isn't, the",
            "            function exists with a warning.",
            "        \"\"\"",
            "        writable_cat = None",
            "        if (catalog_path is not None) and (not os.path.exists(catalog_path)):",
            "            return",
            "        try:",
            "            writable_cat = get_catalog(catalog_path,'w')",
            "        except:",
            "            print('warning: unable to repair catalog entry\\n %s\\n in\\n %s' % \\",
            "                  (code,catalog_path))",
            "            # shelve doesn't guarantee flushing, so it's safest to explicitly",
            "            # close the catalog",
            "            writable_cat.close()",
            "            return",
            "        if code in writable_cat:",
            "            print('repairing catalog by removing key')",
            "            del writable_cat[code]",
            "",
            "        # it is possible that the path key doesn't exist (if the function",
            "        # registered was a built-in function), so we have to check if the path",
            "        # exists before arbitrarily deleting it.",
            "        path_key = self.path_key(code)",
            "        if path_key in writable_cat:",
            "            del writable_cat[path_key]",
            "        writable_cat.close()",
            "",
            "    def get_functions_fast(self,code):",
            "        \"\"\" Return list of functions for code from the cache.",
            "",
            "            Return an empty list if the code entry is not found.",
            "        \"\"\"",
            "        return self.cache.get(code,[])",
            "",
            "    def get_functions(self,code,module_dir=None):",
            "        \"\"\" Return the list of functions associated with this code fragment.",
            "",
            "            The cache is first searched for the function.  If an entry",
            "            in the cache is not found, then catalog files on disk are",
            "            searched for the entry.  This is slooooow, but only happens",
            "            once per code object.  All the functions found in catalog files",
            "            on a cache miss are loaded into the cache to speed up future calls.",
            "            The search order is as follows:",
            "",
            "                1. user specified path (from catalog initialization)",
            "                2. directories from the PYTHONCOMPILED environment variable",
            "                3. The temporary directory on your platform.",
            "",
            "            The path specified by module_dir will replace the 'MODULE'",
            "            place holder in the catalog search path. See build_search_order()",
            "            for more info on the search path.",
            "        \"\"\"",
            "        # Fast!! try cache first.",
            "        if code in self.cache:",
            "            return self.cache[code]",
            "",
            "        # 2. Slow!! read previously compiled functions from disk.",
            "        try:",
            "            self.set_module_directory(module_dir)",
            "            function_list = self.get_cataloged_functions(code)",
            "            # put function_list in cache to save future lookups.",
            "            if function_list:",
            "                self.cache[code] = function_list",
            "            # return function_list, empty or otherwise.",
            "        finally:",
            "            self.clear_module_directory()",
            "        return function_list",
            "",
            "    def add_function(self,code,function,module_dir=None):",
            "        \"\"\" Adds a function to the catalog.",
            "",
            "            The function is added to the cache as well as the first",
            "            writable file catalog found in the search path.  If no",
            "            code entry exists in the cache, the on disk catalogs",
            "            are loaded into the cache and function is added to the",
            "            beginning of the function list.",
            "",
            "            The path specified by module_dir will replace the 'MODULE'",
            "            place holder in the catalog search path. See build_search_order()",
            "            for more info on the search path.",
            "        \"\"\"",
            "",
            "        # 1. put it in the cache.",
            "        if code in self.cache:",
            "            if function not in self.cache[code]:",
            "                self.cache[code].insert(0,function)",
            "            else:",
            "                # if it is in the cache, then it is also",
            "                # been persisted",
            "                return",
            "        else:",
            "            # Load functions and put this one up front",
            "            self.cache[code] = self.get_functions(code)",
            "            self.fast_cache(code,function)",
            "        # 2. Store the function entry to disk.",
            "        try:",
            "            self.set_module_directory(module_dir)",
            "            self.add_function_persistent(code,function)",
            "        finally:",
            "            self.clear_module_directory()",
            "",
            "    def add_function_persistent(self,code,function):",
            "        \"\"\" Store the code->function relationship to disk.",
            "",
            "            Two pieces of information are needed for loading functions",
            "            from disk -- the function pickle (which conveniently stores",
            "            the module name, etc.) and the path to its module's directory.",
            "            The latter is needed so that the function can be loaded no",
            "            matter what the user's Python path is.",
            "        \"\"\"",
            "        # add function to data in first writable catalog",
            "        mode = 'c' # create if doesn't exist, otherwise, use existing",
            "        cat_dir = self.get_writable_dir()",
            "        cat = get_catalog(cat_dir,mode)",
            "        if cat is None:",
            "            cat_dir = default_dir()",
            "            cat = get_catalog(cat_dir,mode)",
            "        if cat is None:",
            "            cat_dir = default_dir()",
            "            cat_file = catalog_path(cat_dir)",
            "            print('problems with default catalog -- removing')",
            "            import glob",
            "            files = glob.glob(cat_file+'*')",
            "            for f in files:",
            "                os.remove(f)",
            "            cat = get_catalog(cat_dir,mode)",
            "        if cat is None:",
            "            raise ValueError('Failed to access a catalog for storing functions')",
            "        # Prabhu was getting some corrupt catalog errors.  I'll put a try/except",
            "        # to protect against this, but should really try and track down the issue.",
            "        function_list = [function]",
            "        try:",
            "            function_list = function_list + cat.get(code,[])",
            "        except pickle.UnpicklingError:",
            "            pass",
            "        cat[code] = function_list",
            "        # now add needed path information for loading function",
            "        module = getmodule(function)",
            "        try:",
            "            # built in modules don't have the __file__ extension, so this",
            "            # will fail.  Just pass in this case since path additions aren't",
            "            # needed for built-in modules.",
            "            mod_path,f=os.path.split(os.path.abspath(module.__file__))",
            "            pkey = self.path_key(code)",
            "            cat[pkey] = [mod_path] + cat.get(pkey,[])",
            "        except:",
            "            pass",
            "        cat.close()",
            "",
            "    def fast_cache(self,code,function):",
            "        \"\"\" Move function to the front of the cache entry for code",
            "",
            "            If future calls to the function have the same type signature,",
            "            this will speed up access significantly because the first",
            "            function call is correct.",
            "",
            "            Note:  The cache added to the inline_tools module is significantly",
            "                   faster than always calling get_functions, so this isn't",
            "                   as necessary as it used to be.  Still, it's probably worth",
            "                   doing.",
            "        \"\"\"",
            "        try:",
            "            if self.cache[code][0] == function:",
            "                return",
            "        except: # KeyError, IndexError",
            "            pass",
            "        try:",
            "            self.cache[code].remove(function)",
            "        except ValueError:",
            "            pass",
            "        # put new function at the beginning of the list to search.",
            "        self.cache[code].insert(0,function)"
        ],
        "afterPatchFile": [
            "\"\"\" Track relationships between compiled extension functions & code fragments",
            "",
            "    catalog keeps track of which compiled(or even standard) functions are",
            "    related to which code fragments.  It also stores these relationships",
            "    to disk so they are remembered between Python sessions.  When",
            "",
            "        a = 1",
            "        compiler.inline('printf(\"printed from C: %d\",a);',['a'] )",
            "",
            "    is called, inline() first looks to see if it has seen the code",
            "    'printf(\"printed from C\");' before.  If not, it calls",
            "",
            "        catalog.get_functions('printf(\"printed from C: %d\", a);')",
            "",
            "    which returns a list of all the function objects that have been compiled",
            "    for the code fragment.  Multiple functions can occur because the code",
            "    could be compiled for different types for 'a' (although not likely in",
            "    this case). The catalog first looks in its cache and quickly returns",
            "    a list of the functions if possible.  If the cache lookup fails, it then",
            "    looks through possibly multiple catalog files on disk and fills its",
            "    cache with all the functions that match the code fragment.",
            "",
            "    In case where the code fragment hasn't been compiled, inline() compiles",
            "    the code and then adds it to the catalog:",
            "",
            "        function = <code to compile function>",
            "        catalog.add_function('printf(\"printed from C: %d\", a);',function)",
            "",
            "    add_function() adds function to the front of the cache.  function,",
            "    along with the path information to its module, are also stored in a",
            "    persistent catalog for future use by python sessions.",
            "\"\"\"",
            "from __future__ import absolute_import, print_function",
            "",
            "import os",
            "import sys",
            "import stat",
            "import pickle",
            "import socket",
            "import tempfile",
            "",
            "try:",
            "    import dbhash",
            "    import shelve",
            "    dumb = 0",
            "except ImportError:",
            "    from . import _dumb_shelve as shelve",
            "    dumb = 1",
            "",
            "#For testing...",
            "#import scipy.io.dumb_shelve as shelve",
            "#dumb = 1",
            "",
            "#import shelve",
            "#dumb = 0",
            "",
            "def getmodule(object):",
            "    \"\"\" Discover the name of the module where object was defined.",
            "",
            "        This is an augmented version of inspect.getmodule that can discover",
            "        the parent module for extension functions.",
            "    \"\"\"",
            "    import inspect",
            "    value = inspect.getmodule(object)",
            "    if value is None:",
            "        #walk trough all modules looking for function",
            "        for name,mod in sys.modules.items():",
            "            # try except used because of some comparison failures",
            "            # in wxPoint code.  Need to review this",
            "            try:",
            "                if mod and object in mod.__dict__.values():",
            "                    value = mod",
            "                    # if it is a built-in module, keep looking to see",
            "                    # if a non-builtin also has it.  Otherwise quit and",
            "                    # consider the module found. (ain't perfect, but will",
            "                    # have to do for now).",
            "                    if str(mod) not in '(built-in)':",
            "                        break",
            "",
            "            except (TypeError, KeyError, ImportError):",
            "                pass",
            "    return value",
            "",
            "def expr_to_filename(expr):",
            "    \"\"\" Convert an arbitrary expr string to a valid file name.",
            "",
            "        The name is based on the md5 check sum for the string and",
            "        Something that was a little more human readable would be",
            "        nice, but the computer doesn't seem to care.",
            "    \"\"\"",
            "    import scipy.weave.md5_load as md5",
            "    base = 'sc_'",
            "    return base + md5.new(expr).hexdigest()",
            "",
            "def unique_file(d,expr):",
            "    \"\"\" Generate a unqiue file name based on expr in directory d",
            "",
            "        This is meant for use with building extension modules, so",
            "        a file name is considered unique if none of the following",
            "        extension '.cpp','.o','.so','module.so','.py', or '.pyd'",
            "        exists in directory d.  The fully qualified path to the",
            "        new name is returned.  You'll need to append your own",
            "        extension to it before creating files.",
            "    \"\"\"",
            "    files = os.listdir(d)",
            "    #base = 'scipy_compile'",
            "    base = expr_to_filename(expr)",
            "    for i in xrange(1000000):",
            "        fname = base + repr(i)",
            "        if not (fname+'.cpp' in files or",
            "                fname+'.o' in files or",
            "                fname+'.so' in files or",
            "                fname+'module.so' in files or",
            "                fname+'.py' in files or",
            "                fname+'.pyd' in files):",
            "            break",
            "    return os.path.join(d,fname)",
            "",
            "def is_writable(dir):",
            "    \"\"\"Determine whether a given directory is writable in a portable manner.",
            "",
            "    Parameters",
            "    ----------",
            "    dir : str",
            "        A string represeting a path to a directory on the filesystem.",
            "",
            "    Returns",
            "    -------",
            "    res : bool",
            "        True or False.",
            "    \"\"\"",
            "    if not os.path.isdir(dir):",
            "        return False",
            "",
            "    # Do NOT use a hardcoded name here due to the danger from race conditions",
            "    # on NFS when multiple processes are accessing the same base directory in",
            "    # parallel.  We use both hostname and process id for the prefix in an",
            "    # attempt to ensure that there can really be no name collisions (tempfile",
            "    # appends 6 random chars to this prefix).",
            "    prefix = 'dummy_%s_%s_' % (socket.gethostname(),os.getpid())",
            "    try:",
            "        tmp = tempfile.TemporaryFile(prefix=prefix,dir=dir)",
            "    except OSError:",
            "        return False",
            "    # The underlying file is destroyed upon closing the file object (under",
            "    # *nix, it was unlinked at creation time)",
            "    tmp.close()",
            "    return True",
            "",
            "def whoami():",
            "    \"\"\"return a string identifying the user.\"\"\"",
            "    return os.environ.get(\"USER\") or os.environ.get(\"USERNAME\") or \"unknown\"",
            "",
            "",
            "def _create_dirs(path):",
            "    \"\"\" create provided path, ignore errors \"\"\"",
            "    try:",
            "        os.makedirs(path, mode=0o700)",
            "    except OSError:",
            "        pass",
            "",
            "",
            "def default_dir_posix(tmp_dir=None):",
            "    \"\"\"",
            "    Create or find default catalog store for posix systems",
            "",
            "    purpose of 'tmp_dir' is to enable way how to test this function easily",
            "    \"\"\"",
            "    path_candidates = []",
            "    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])",
            "",
            "    if tmp_dir:",
            "        home_dir = tmp_dir",
            "    else:",
            "        home_dir = os.path.expanduser('~')",
            "    tmp_dir = tmp_dir or tempfile.gettempdir()",
            "",
            "    home_temp_dir_name = '.' + python_name",
            "    home_temp_dir = os.path.join(home_dir, home_temp_dir_name)",
            "    path_candidates.append(home_temp_dir)",
            "",
            "    temp_dir_name = repr(os.getuid()) + '_' + python_name",
            "    temp_dir_path = os.path.join(tmp_dir, temp_dir_name)",
            "    path_candidates.append(temp_dir_path)",
            "",
            "    for path in path_candidates:",
            "        _create_dirs(path)",
            "        if check_dir(path):",
            "            return path",
            "",
            "    # since we got here, both dirs are not useful",
            "    tmp_dir_path = find_valid_temp_dir(temp_dir_name, tmp_dir)",
            "    if not tmp_dir_path:",
            "        tmp_dir_path = create_temp_dir(temp_dir_name, tmp_dir=tmp_dir)",
            "    return tmp_dir_path",
            "",
            "",
            "def default_dir_win(tmp_dir=None):",
            "    \"\"\"",
            "    Create or find default catalog store for Windows systems",
            "",
            "    purpose of 'tmp_dir' is to enable way how to test this function easily",
            "    \"\"\"",
            "    def create_win_temp_dir(prefix, inner_dir=None, tmp_dir=None):",
            "        \"\"\"",
            "        create temp dir starting with 'prefix' in 'tmp_dir' or",
            "        'tempfile.gettempdir'; if 'inner_dir' is specified, it should be",
            "        created inside",
            "        \"\"\"",
            "        tmp_dir_path = find_valid_temp_dir(prefix, tmp_dir)",
            "        if tmp_dir_path:",
            "            if inner_dir:",
            "                tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)",
            "                if not os.path.isdir(tmp_dir_path):",
            "                    os.mkdir(tmp_dir_path, 0o700)",
            "        else:",
            "            tmp_dir_path = create_temp_dir(prefix, inner_dir, tmp_dir)",
            "        return tmp_dir_path",
            "",
            "    python_name = \"python%d%d_compiled\" % tuple(sys.version_info[:2])",
            "    tmp_dir = tmp_dir or tempfile.gettempdir()",
            "",
            "    temp_dir_name = \"%s\" % whoami()",
            "    temp_root_dir = os.path.join(tmp_dir, temp_dir_name)",
            "    temp_dir_path = os.path.join(temp_root_dir, python_name)",
            "    _create_dirs(temp_dir_path)",
            "    if check_dir(temp_dir_path) and check_dir(temp_root_dir):",
            "        return temp_dir_path",
            "    else:",
            "        if check_dir(temp_root_dir):",
            "            return create_win_temp_dir(python_name, tmp_dir=temp_root_dir)",
            "        else:",
            "            return create_win_temp_dir(temp_dir_name, python_name, tmp_dir)",
            "",
            "",
            "def default_dir():",
            "    \"\"\" Return a default location to store compiled files and catalogs.",
            "",
            "        XX is the Python version number in all paths listed below",
            "        On windows, the default location is the temporary directory",
            "        returned by gettempdir()/pythonXX.",
            "",
            "        On Unix, ~/.pythonXX_compiled is the default location.  If it doesn't",
            "        exist, it is created.  The directory is marked rwx------.",
            "",
            "        If for some reason it isn't possible to build a default directory",
            "        in the user's home, /tmp/<uid>_pythonXX_compiled is used.  If it",
            "        doesn't exist, it is created.  The directory is marked rwx------",
            "        to try and keep people from being able to sneak a bad module",
            "        in on you. If the directory already exists in /tmp/ and is not",
            "        secure, new one is created.",
            "    \"\"\"",
            "    # Use a cached value for fast return if possible",
            "    if hasattr(default_dir, \"cached_path\") and \\",
            "       check_dir(default_dir.cached_path):",
            "        return default_dir.cached_path",
            "",
            "    if sys.platform == 'win32':",
            "        path = default_dir_win()",
            "    else:",
            "        path = default_dir_posix()",
            "",
            "    # Cache the default dir path so that this function returns quickly after",
            "    # being called once (nothing in it should change after the first call)",
            "    default_dir.cached_path = path",
            "",
            "    return path",
            "",
            "",
            "def check_dir(im_dir):",
            "    \"\"\"",
            "    Check if dir is safe; if it is, return True.",
            "    These checks make sense only on posix:",
            "     * directory has correct owner",
            "     * directory has correct permissions (0700)",
            "     * directory is not a symlink",
            "    \"\"\"",
            "    def check_is_dir():",
            "        return os.path.isdir(im_dir)",
            "",
            "    def check_permissions():",
            "        \"\"\" If on posix, permissions should be 0700. \"\"\"",
            "        writable = is_writable(im_dir)",
            "        if sys.platform != 'win32':",
            "            try:",
            "                im_dir_stat = os.stat(im_dir)",
            "            except OSError:",
            "                return False",
            "            writable &= stat.S_IMODE(im_dir_stat.st_mode) == 0o0700",
            "        return writable",
            "",
            "    def check_ownership():",
            "        \"\"\" Intermediate dir owner should be same as owner of process. \"\"\"",
            "        if sys.platform != 'win32':",
            "            try:",
            "                im_dir_stat = os.stat(im_dir)",
            "            except OSError:",
            "                return False",
            "            proc_uid = os.getuid()",
            "            return proc_uid == im_dir_stat.st_uid",
            "        return True",
            "",
            "    def check_is_symlink():",
            "        \"\"\" Check if intermediate dir is symlink. \"\"\"",
            "        try:",
            "            return not os.path.islink(im_dir)",
            "        except OSError:",
            "            return False",
            "",
            "    checks = [check_is_dir, check_permissions,",
            "              check_ownership, check_is_symlink]",
            "",
            "    for check in checks:",
            "        if not check():",
            "            return False",
            "",
            "    return True",
            "",
            "",
            "def create_temp_dir(prefix, inner_dir=None, tmp_dir=None):",
            "    \"\"\"",
            "    Create intermediate dirs <tmp>/<prefix+random suffix>/<inner_dir>/",
            "",
            "    argument 'tmp_dir' is used in unit tests",
            "    \"\"\"",
            "    if not tmp_dir:",
            "        tmp_dir_path = tempfile.mkdtemp(prefix=prefix)",
            "    else:",
            "        tmp_dir_path = tempfile.mkdtemp(prefix=prefix, dir=tmp_dir)",
            "    if inner_dir:",
            "        tmp_dir_path = os.path.join(tmp_dir_path, inner_dir)",
            "        os.mkdir(tmp_dir_path, 0o700)",
            "    return tmp_dir_path",
            "",
            "",
            "def intermediate_dir_prefix():",
            "    \"\"\" Prefix of root intermediate dir (<tmp>/<root_im_dir>). \"\"\"",
            "    return \"%s-%s-\" % (\"scipy\", whoami())",
            "",
            "",
            "def find_temp_dir(prefix, tmp_dir=None):",
            "    \"\"\" Find temp dirs in 'tmp_dir' starting with 'prefix'\"\"\"",
            "    matches = []",
            "    tmp_dir = tmp_dir or tempfile.gettempdir()",
            "    for tmp_file in os.listdir(tmp_dir):",
            "        if tmp_file.startswith(prefix):",
            "            matches.append(os.path.join(tmp_dir, tmp_file))",
            "    return matches",
            "",
            "",
            "def find_valid_temp_dir(prefix, tmp_dir=None):",
            "    \"\"\"",
            "    Try to look for existing temp dirs.",
            "    If there is one suitable found, return it, otherwise return None.",
            "    \"\"\"",
            "    matches = find_temp_dir(prefix, tmp_dir)",
            "    for match in matches:",
            "        if check_dir(match):",
            "            # as soon as we find correct dir, we can stop searching",
            "            return match",
            "",
            "",
            "def py_intermediate_dir():",
            "    \"\"\"",
            "    Name of intermediate dir for current python interpreter:",
            "    <temp dir>/<name>/pythonXY_intermediate/",
            "    \"\"\"",
            "    name = \"python%d%d_intermediate\" % tuple(sys.version_info[:2])",
            "    return name",
            "",
            "",
            "def create_intermediate_dir(tmp_dir=None):",
            "    py_im_dir = py_intermediate_dir()",
            "    return create_temp_dir(intermediate_dir_prefix(), py_im_dir, tmp_dir)",
            "",
            "",
            "def intermediate_dir(tmp_dir=None):",
            "    \"\"\"",
            "    Temporary directory for storing .cpp and .o files during builds.",
            "",
            "    First, try to find the dir and if it exists, verify it is safe.",
            "    Otherwise, create it.",
            "    \"\"\"",
            "    im_dir = find_valid_temp_dir(intermediate_dir_prefix(), tmp_dir)",
            "    py_im_dir = py_intermediate_dir()",
            "    if im_dir is None:",
            "        py_im_dir = py_intermediate_dir()",
            "        im_dir = create_intermediate_dir(tmp_dir)",
            "    else:",
            "        im_dir = os.path.join(im_dir, py_im_dir)",
            "        if not os.path.isdir(im_dir):",
            "            os.mkdir(im_dir, 0o700)",
            "    return im_dir",
            "",
            "",
            "def default_temp_dir():",
            "    path = os.path.join(default_dir(),'temp')",
            "    if not os.path.exists(path):",
            "        os.makedirs(path, mode=0o700)",
            "    if not is_writable(path):",
            "        print('warning: default directory is not write accessible.')",
            "        print('default:', path)",
            "    return path",
            "",
            "",
            "def os_dependent_catalog_name():",
            "    \"\"\" Generate catalog name dependent on OS and Python version being used.",
            "",
            "        This allows multiple platforms to have catalog files in the",
            "        same directory without stepping on each other.  For now, it",
            "        bases the name of the value returned by sys.platform and the",
            "        version of python being run.  If this isn't enough to descriminate",
            "        on some platforms, we can try to add other info.  It has",
            "        occurred to me that if we get fancy enough to optimize for different",
            "        architectures, then chip type might be added to the catalog name also.",
            "    \"\"\"",
            "    version = '%d%d' % sys.version_info[:2]",
            "    return sys.platform+version+'compiled_catalog'",
            "",
            "def catalog_path(module_path):",
            "    \"\"\" Return the full path name for the catalog file in the given directory.",
            "",
            "        module_path can either be a file name or a path name.  If it is a",
            "        file name, the catalog file name in its parent directory is returned.",
            "        If it is a directory, the catalog file in that directory is returned.",
            "",
            "        If module_path doesn't exist, None is returned.  Note though, that the",
            "        catalog file does *not* have to exist, only its parent.  '~', shell",
            "        variables, and relative ('.' and '..') paths are all acceptable.",
            "",
            "        catalog file names are os dependent (based on sys.platform), so this",
            "        should support multiple platforms sharing the same disk space",
            "        (NFS mounts). See os_dependent_catalog_name() for more info.",
            "    \"\"\"",
            "    module_path = os.path.expanduser(module_path)",
            "    module_path = os.path.expandvars(module_path)",
            "    module_path = os.path.abspath(module_path)",
            "    if not os.path.exists(module_path):",
            "        catalog_file = None",
            "    elif not os.path.isdir(module_path):",
            "        module_path,dummy = os.path.split(module_path)",
            "        catalog_file = os.path.join(module_path,os_dependent_catalog_name())",
            "    else:",
            "        catalog_file = os.path.join(module_path,os_dependent_catalog_name())",
            "    return catalog_file",
            "",
            "def get_catalog(module_path,mode='r'):",
            "    \"\"\" Return a function catalog (shelve object) from the path module_path",
            "",
            "        If module_path is a directory, the function catalog returned is",
            "        from that directory.  If module_path is an actual module_name,",
            "        then the function catalog returned is from its parent directory.",
            "        mode uses the standard 'c' = create, 'n' = new, 'r' = read,",
            "        'w' = write file open modes available for anydbm databases.",
            "",
            "        Well... it should be.  Stuck with dumbdbm for now and the modes",
            "        almost don't matter.  We do some checking for 'r' mode, but that",
            "        is about it.",
            "",
            "        See catalog_path() for more information on module_path.",
            "    \"\"\"",
            "    if mode not in ['c','r','w','n']:",
            "        msg = \" mode must be 'c', 'n', 'r', or 'w'.  See anydbm for more info\"",
            "        raise ValueError(msg)",
            "    catalog_file = catalog_path(module_path)",
            "    if (catalog_file is not None) \\",
            "           and ((dumb and os.path.exists(catalog_file+'.dat')) \\",
            "                or os.path.exists(catalog_file)):",
            "        sh = shelve.open(catalog_file,mode)",
            "    else:",
            "        if mode=='r':",
            "            sh = None",
            "        else:",
            "            sh = shelve.open(catalog_file,mode)",
            "    return sh",
            "",
            "class catalog(object):",
            "    \"\"\" Stores information about compiled functions both in cache and on disk.",
            "",
            "        catalog stores (code, list_of_function) pairs so that all the functions",
            "        that have been compiled for code are available for calling (usually in",
            "        inline or blitz).",
            "",
            "        catalog keeps a dictionary of previously accessed code values cached",
            "        for quick access.  It also handles the looking up of functions compiled",
            "        in previously called Python sessions on disk in function catalogs.",
            "        catalog searches the directories in the PYTHONCOMPILED environment",
            "        variable in order loading functions that correspond to the given code",
            "        fragment.  A default directory is also searched for catalog functions.",
            "        On unix, the default directory is usually '~/.pythonxx_compiled' where",
            "        xx is the version of Python used. On windows, it is the directory",
            "        returned by temfile.gettempdir().  Functions closer to the front are of",
            "        the variable list are guaranteed to be closer to the front of the",
            "        function list so that they will be called first.  See",
            "        get_cataloged_functions() for more info on how the search order is",
            "        traversed.",
            "",
            "        Catalog also handles storing information about compiled functions to",
            "        a catalog.  When writing this information, the first writable catalog",
            "        file in PYTHONCOMPILED path is used.  If a writable catalog is not",
            "        found, it is written to the catalog in the default directory.  This",
            "        directory should always be writable.",
            "    \"\"\"",
            "    def __init__(self,user_path_list=None):",
            "        \"\"\" Create a catalog for storing/searching for compiled functions.",
            "",
            "            user_path_list contains directories that should be searched",
            "            first for function catalogs.  They will come before the path",
            "            entries in the PYTHONCOMPILED environment varilable.",
            "        \"\"\"",
            "        if isinstance(user_path_list, str):",
            "            self.user_path_list = [user_path_list]",
            "        elif user_path_list:",
            "            self.user_path_list = user_path_list",
            "        else:",
            "            self.user_path_list = []",
            "        self.cache = {}",
            "        self.module_dir = None",
            "        self.paths_added = 0",
            "        # unconditionally append the default dir for auto-generated compiled",
            "        # extension modules, so that pickle.load()s don't fail.",
            "        sys.path.append(default_dir())",
            "",
            "    def set_module_directory(self,module_dir):",
            "        \"\"\" Set the path that will replace 'MODULE' in catalog searches.",
            "",
            "            You should call clear_module_directory() when your finished",
            "            working with it.",
            "        \"\"\"",
            "        self.module_dir = module_dir",
            "    def get_module_directory(self):",
            "        \"\"\" Return the path used to replace the 'MODULE' in searches.",
            "        \"\"\"",
            "        return self.module_dir",
            "    def clear_module_directory(self):",
            "        \"\"\" Reset 'MODULE' path to None so that it is ignored in searches.",
            "        \"\"\"",
            "        self.module_dir = None",
            "",
            "    def get_environ_path(self):",
            "        \"\"\" Return list of paths from 'PYTHONCOMPILED' environment variable.",
            "",
            "            On Unix the path in PYTHONCOMPILED is a ':' separated list of",
            "            directories.  On Windows, a ';' separated list is used.",
            "        \"\"\"",
            "        paths = []",
            "        if 'PYTHONCOMPILED' in os.environ:",
            "            path_string = os.environ['PYTHONCOMPILED']",
            "            paths = path_string.split(os.path.pathsep)",
            "        return paths",
            "",
            "    def build_search_order(self):",
            "        \"\"\" Returns a list of paths that are searched for catalogs.",
            "",
            "            Values specified in the catalog constructor are searched first,",
            "            then values found in the PYTHONCOMPILED environment variable.",
            "            The directory returned by default_dir() is always returned at",
            "            the end of the list.",
            "",
            "            There is a 'magic' path name called 'MODULE' that is replaced",
            "            by the directory defined by set_module_directory().  If the",
            "            module directory hasn't been set, 'MODULE' is ignored.",
            "        \"\"\"",
            "",
            "        paths = self.user_path_list + self.get_environ_path()",
            "        search_order = []",
            "        for path in paths:",
            "            if path == 'MODULE':",
            "                if self.module_dir:",
            "                    search_order.append(self.module_dir)",
            "            else:",
            "                search_order.append(path)",
            "        search_order.append(default_dir())",
            "        return search_order",
            "",
            "    def get_catalog_files(self):",
            "        \"\"\" Returns catalog file list in correct search order.",
            "",
            "            Some of the catalog files may not currently exists.",
            "            However, all will be valid locations for a catalog",
            "            to be created (if you have write permission).",
            "        \"\"\"",
            "        files = map(catalog_path,self.build_search_order())",
            "        files = filter(lambda x: x is not None,files)",
            "        return files",
            "",
            "    def get_existing_files(self):",
            "        \"\"\" Returns all existing catalog file list in correct search order.",
            "        \"\"\"",
            "        files = self.get_catalog_files()",
            "        # open every stinking file to check if it exists.",
            "        # This is because anydbm doesn't provide a consistent naming",
            "        # convention across platforms for its files",
            "        existing_files = []",
            "        for file in files:",
            "            cat = get_catalog(os.path.dirname(file),'r')",
            "            if cat is not None:",
            "                existing_files.append(file)",
            "                cat.close()",
            "        # This is the non-portable (and much faster) old code",
            "        #existing_files = filter(os.path.exists,files)",
            "        return existing_files",
            "",
            "    def get_writable_file(self,existing_only=0):",
            "        \"\"\" Return the name of the first writable catalog file.",
            "",
            "            Its parent directory must also be writable.  This is so that",
            "            compiled modules can be written to the same directory.",
            "        \"\"\"",
            "        # note: both file and its parent directory must be writeable",
            "        if existing_only:",
            "            files = self.get_existing_files()",
            "        else:",
            "            files = self.get_catalog_files()",
            "        # filter for (file exists and is writable) OR directory is writable",
            "        def file_test(x):",
            "            from os import access, F_OK, W_OK",
            "            return (access(x,F_OK) and access(x,W_OK) or",
            "                    access(os.path.dirname(x),W_OK))",
            "        writable = filter(file_test,files)",
            "        if writable:",
            "            file = writable[0]",
            "        else:",
            "            file = None",
            "        return file",
            "",
            "    def get_writable_dir(self):",
            "        \"\"\" Return the parent directory of first writable catalog file.",
            "",
            "            The returned directory has write access.",
            "        \"\"\"",
            "        return os.path.dirname(self.get_writable_file())",
            "",
            "    def unique_module_name(self,code,module_dir=None):",
            "        \"\"\" Return full path to unique file name that in writable location.",
            "",
            "            The directory for the file is the first writable directory in",
            "            the catalog search path.  The unique file name is derived from",
            "            the code fragment.  If, module_dir is specified, it is used",
            "            to replace 'MODULE' in the search path.",
            "        \"\"\"",
            "        if module_dir is not None:",
            "            self.set_module_directory(module_dir)",
            "        try:",
            "            d = self.get_writable_dir()",
            "        finally:",
            "            if module_dir is not None:",
            "                self.clear_module_directory()",
            "        return unique_file(d, code)",
            "",
            "    def path_key(self,code):",
            "        \"\"\" Return key for path information for functions associated with code.",
            "        \"\"\"",
            "        return '__path__' + code",
            "",
            "    def configure_path(self,cat,code):",
            "        \"\"\" Add the python path for the given code to the sys.path",
            "",
            "            unconfigure_path() should be called as soon as possible after",
            "            imports associated with code are finished so that sys.path",
            "            is restored to normal.",
            "        \"\"\"",
            "        try:",
            "            paths = cat[self.path_key(code)]",
            "            self.paths_added = len(paths)",
            "            sys.path = paths + sys.path",
            "        except:",
            "            self.paths_added = 0",
            "",
            "    def unconfigure_path(self):",
            "        \"\"\" Restores sys.path to normal after calls to configure_path()",
            "",
            "            Remove the previously added paths from sys.path",
            "        \"\"\"",
            "        sys.path = sys.path[self.paths_added:]",
            "        self.paths_added = 0",
            "",
            "    def get_cataloged_functions(self,code):",
            "        \"\"\" Load all functions associated with code from catalog search path.",
            "",
            "            Sometimes there can be trouble loading a function listed in a",
            "            catalog file because the actual module that holds the function",
            "            has been moved or deleted.  When this happens, that catalog file",
            "            is \"repaired\", meaning the entire entry for this function is",
            "            removed from the file.  This only affects the catalog file that",
            "            has problems -- not the others in the search path.",
            "",
            "            The \"repair\" behavior may not be needed, but I'll keep it for now.",
            "        \"\"\"",
            "        mode = 'r'",
            "        cat = None",
            "        function_list = []",
            "        for path in self.build_search_order():",
            "            cat = get_catalog(path,mode)",
            "            if cat is not None and code in cat:",
            "                # set up the python path so that modules for this",
            "                # function can be loaded.",
            "                self.configure_path(cat,code)",
            "                try:",
            "                    function_list += cat[code]",
            "                except: #SystemError and ImportError so far seen",
            "                    # problems loading a function from the catalog.  Try to",
            "                    # repair the cause.",
            "                    cat.close()",
            "                    self.repair_catalog(path,code)",
            "                self.unconfigure_path()",
            "            if cat is not None:",
            "                # ensure that the catalog is properly closed",
            "                cat.close()",
            "        return function_list",
            "",
            "",
            "    def repair_catalog(self,catalog_path,code):",
            "        \"\"\" Remove entry for code from catalog_path",
            "",
            "            Occasionally catalog entries could get corrupted. An example",
            "            would be when a module that had functions in the catalog was",
            "            deleted or moved on the disk.  The best current repair method is",
            "            just to trash the entire catalog entry for this piece of code.",
            "            This may loose function entries that are valid, but thats life.",
            "",
            "            catalog_path must be writable for repair.  If it isn't, the",
            "            function exists with a warning.",
            "        \"\"\"",
            "        writable_cat = None",
            "        if (catalog_path is not None) and (not os.path.exists(catalog_path)):",
            "            return",
            "        try:",
            "            writable_cat = get_catalog(catalog_path,'w')",
            "        except:",
            "            print('warning: unable to repair catalog entry\\n %s\\n in\\n %s' % \\",
            "                  (code,catalog_path))",
            "            # shelve doesn't guarantee flushing, so it's safest to explicitly",
            "            # close the catalog",
            "            writable_cat.close()",
            "            return",
            "        if code in writable_cat:",
            "            print('repairing catalog by removing key')",
            "            del writable_cat[code]",
            "",
            "        # it is possible that the path key doesn't exist (if the function",
            "        # registered was a built-in function), so we have to check if the path",
            "        # exists before arbitrarily deleting it.",
            "        path_key = self.path_key(code)",
            "        if path_key in writable_cat:",
            "            del writable_cat[path_key]",
            "        writable_cat.close()",
            "",
            "    def get_functions_fast(self,code):",
            "        \"\"\" Return list of functions for code from the cache.",
            "",
            "            Return an empty list if the code entry is not found.",
            "        \"\"\"",
            "        return self.cache.get(code,[])",
            "",
            "    def get_functions(self,code,module_dir=None):",
            "        \"\"\" Return the list of functions associated with this code fragment.",
            "",
            "            The cache is first searched for the function.  If an entry",
            "            in the cache is not found, then catalog files on disk are",
            "            searched for the entry.  This is slooooow, but only happens",
            "            once per code object.  All the functions found in catalog files",
            "            on a cache miss are loaded into the cache to speed up future calls.",
            "            The search order is as follows:",
            "",
            "                1. user specified path (from catalog initialization)",
            "                2. directories from the PYTHONCOMPILED environment variable",
            "                3. The temporary directory on your platform.",
            "",
            "            The path specified by module_dir will replace the 'MODULE'",
            "            place holder in the catalog search path. See build_search_order()",
            "            for more info on the search path.",
            "        \"\"\"",
            "        # Fast!! try cache first.",
            "        if code in self.cache:",
            "            return self.cache[code]",
            "",
            "        # 2. Slow!! read previously compiled functions from disk.",
            "        try:",
            "            self.set_module_directory(module_dir)",
            "            function_list = self.get_cataloged_functions(code)",
            "            # put function_list in cache to save future lookups.",
            "            if function_list:",
            "                self.cache[code] = function_list",
            "            # return function_list, empty or otherwise.",
            "        finally:",
            "            self.clear_module_directory()",
            "        return function_list",
            "",
            "    def add_function(self,code,function,module_dir=None):",
            "        \"\"\" Adds a function to the catalog.",
            "",
            "            The function is added to the cache as well as the first",
            "            writable file catalog found in the search path.  If no",
            "            code entry exists in the cache, the on disk catalogs",
            "            are loaded into the cache and function is added to the",
            "            beginning of the function list.",
            "",
            "            The path specified by module_dir will replace the 'MODULE'",
            "            place holder in the catalog search path. See build_search_order()",
            "            for more info on the search path.",
            "        \"\"\"",
            "",
            "        # 1. put it in the cache.",
            "        if code in self.cache:",
            "            if function not in self.cache[code]:",
            "                self.cache[code].insert(0,function)",
            "            else:",
            "                # if it is in the cache, then it is also",
            "                # been persisted",
            "                return",
            "        else:",
            "            # Load functions and put this one up front",
            "            self.cache[code] = self.get_functions(code)",
            "            self.fast_cache(code,function)",
            "        # 2. Store the function entry to disk.",
            "        try:",
            "            self.set_module_directory(module_dir)",
            "            self.add_function_persistent(code,function)",
            "        finally:",
            "            self.clear_module_directory()",
            "",
            "    def add_function_persistent(self,code,function):",
            "        \"\"\" Store the code->function relationship to disk.",
            "",
            "            Two pieces of information are needed for loading functions",
            "            from disk -- the function pickle (which conveniently stores",
            "            the module name, etc.) and the path to its module's directory.",
            "            The latter is needed so that the function can be loaded no",
            "            matter what the user's Python path is.",
            "        \"\"\"",
            "        # add function to data in first writable catalog",
            "        mode = 'c' # create if doesn't exist, otherwise, use existing",
            "        cat_dir = self.get_writable_dir()",
            "        cat = get_catalog(cat_dir,mode)",
            "        if cat is None:",
            "            cat_dir = default_dir()",
            "            cat = get_catalog(cat_dir,mode)",
            "        if cat is None:",
            "            cat_dir = default_dir()",
            "            cat_file = catalog_path(cat_dir)",
            "            print('problems with default catalog -- removing')",
            "            import glob",
            "            files = glob.glob(cat_file+'*')",
            "            for f in files:",
            "                os.remove(f)",
            "            cat = get_catalog(cat_dir,mode)",
            "        if cat is None:",
            "            raise ValueError('Failed to access a catalog for storing functions')",
            "        # Prabhu was getting some corrupt catalog errors.  I'll put a try/except",
            "        # to protect against this, but should really try and track down the issue.",
            "        function_list = [function]",
            "        try:",
            "            function_list = function_list + cat.get(code,[])",
            "        except pickle.UnpicklingError:",
            "            pass",
            "        cat[code] = function_list",
            "        # now add needed path information for loading function",
            "        module = getmodule(function)",
            "        try:",
            "            # built in modules don't have the __file__ extension, so this",
            "            # will fail.  Just pass in this case since path additions aren't",
            "            # needed for built-in modules.",
            "            mod_path,f=os.path.split(os.path.abspath(module.__file__))",
            "            pkey = self.path_key(code)",
            "            cat[pkey] = [mod_path] + cat.get(pkey,[])",
            "        except:",
            "            pass",
            "        cat.close()",
            "",
            "    def fast_cache(self,code,function):",
            "        \"\"\" Move function to the front of the cache entry for code",
            "",
            "            If future calls to the function have the same type signature,",
            "            this will speed up access significantly because the first",
            "            function call is correct.",
            "",
            "            Note:  The cache added to the inline_tools module is significantly",
            "                   faster than always calling get_functions, so this isn't",
            "                   as necessary as it used to be.  Still, it's probably worth",
            "                   doing.",
            "        \"\"\"",
            "        try:",
            "            if self.cache[code][0] == function:",
            "                return",
            "        except: # KeyError, IndexError",
            "            pass",
            "        try:",
            "            self.cache[code].remove(function)",
            "        except ValueError:",
            "            pass",
            "        # put new function at the beginning of the list to search.",
            "        self.cache[code].insert(0,function)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "136": [
                "is_writable"
            ],
            "167": [
                "default_dir"
            ],
            "168": [
                "default_dir"
            ],
            "170": [
                "default_dir"
            ],
            "172": [
                "default_dir"
            ],
            "173": [
                "default_dir"
            ],
            "174": [
                "default_dir"
            ],
            "177": [
                "default_dir"
            ],
            "178": [
                "default_dir"
            ],
            "179": [
                "default_dir"
            ],
            "180": [
                "default_dir"
            ],
            "181": [
                "default_dir"
            ],
            "182": [
                "default_dir"
            ],
            "183": [
                "default_dir"
            ],
            "184": [
                "default_dir"
            ],
            "185": [
                "default_dir"
            ],
            "186": [
                "default_dir"
            ],
            "187": [
                "default_dir"
            ],
            "189": [
                "default_dir"
            ],
            "190": [
                "default_dir"
            ],
            "191": [
                "default_dir"
            ],
            "192": [
                "default_dir"
            ],
            "193": [
                "default_dir"
            ],
            "194": [
                "default_dir"
            ],
            "195": [
                "default_dir"
            ],
            "196": [
                "default_dir"
            ],
            "197": [
                "default_dir"
            ],
            "198": [
                "default_dir"
            ],
            "199": [
                "default_dir"
            ],
            "200": [
                "default_dir"
            ],
            "201": [
                "default_dir"
            ],
            "202": [
                "default_dir"
            ],
            "203": [
                "default_dir"
            ],
            "204": [
                "default_dir"
            ],
            "205": [
                "default_dir"
            ],
            "213": [
                "intermediate_dir"
            ],
            "214": [
                "intermediate_dir"
            ],
            "215": [
                "intermediate_dir"
            ],
            "217": [
                "intermediate_dir"
            ],
            "218": [
                "intermediate_dir"
            ],
            "219": [
                "intermediate_dir"
            ],
            "220": [
                "intermediate_dir"
            ],
            "221": [
                "intermediate_dir"
            ]
        },
        "addLocation": []
    }
}