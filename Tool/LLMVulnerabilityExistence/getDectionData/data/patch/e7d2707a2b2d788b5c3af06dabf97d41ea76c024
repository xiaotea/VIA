{
    "langchain/chains/pal/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     ):"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         \"\"\"Initialize an PALValidation instance"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         Args:"
            },
            "3": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            solution_expression_name (str): Name of the expected solution expressions. If passed, solution_expression_type must be passed as well"
            },
            "4": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            solution_expression_type (str): ast type of the expected solution expression. If passed, solution_expression_name must be passed as well. Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION, PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            solution_expression_name (str): Name of the expected solution expressions."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+                If passed, solution_expression_type must be passed as well"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+            solution_expression_type (str): ast type of the expected solution "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+                expression. If passed, solution_expression_name must be passed as well."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "11": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "             allow_imports (bool): Allow import statements"
            },
            "12": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             allow_command_exec (bool): Allow using known command execution functions."
            },
            "13": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         if solution_expression_name is not None:"
            },
            "15": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "             if not isinstance(self.solution_expression_name, str):"
            },
            "16": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                 raise ValueError("
            },
            "17": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\"Expected solution_expression_name to be str, instead found {type(self.solution_expression_name)}\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+                    f\"Expected solution_expression_name to be str, "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                    instead found {type(self.solution_expression_name)}\""
            },
            "20": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "                 )"
            },
            "21": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         if solution_expression_type is not None:"
            },
            "22": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "             if ("
            },
            "23": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                not self.solution_expression_type"
            },
            "24": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                is self.SOLUTION_EXPRESSION_TYPE_FUNCTION"
            },
            "25": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and not self.solution_expression_type"
            },
            "26": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                is self.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                self.solution_expression_type"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+                and self.solution_expression_type"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE"
            },
            "31": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             ):"
            },
            "32": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "                 raise ValueError("
            },
            "33": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    f\"Expected solution_expression_type to be one of ({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}), instead found {self.solution_expression_type}\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                    f\"Expected solution_expression_type to be one of "
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                    ({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+                    {self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                    instead found {self.solution_expression_type}\""
            },
            "38": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "                 )"
            },
            "39": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         if solution_expression_name is not None and solution_expression_type is None:"
            },
            "41": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             raise TypeError("
            },
            "42": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"solution_expression_name requires solution_expression_type to be passed as well\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                \"solution_expression_name "
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+                requires solution_expression_type to be passed as well\""
            },
            "45": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             )"
            },
            "46": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         if solution_expression_name is None and solution_expression_type is not None:"
            },
            "47": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             raise TypeError("
            },
            "48": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"solution_expression_type requires solution_expression_name to be passed as well\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                \"solution_expression_type "
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                requires solution_expression_name to be passed as well\""
            },
            "51": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "             )"
            },
            "52": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "53": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         self.allow_imports = allow_imports"
            },
            "54": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "             raise ValueError(f\"Generated code is not valid python code: {code}\")"
            },
            "55": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         except TypeError:"
            },
            "56": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "             raise ValueError("
            },
            "57": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Generated code is expected to be a string, instead found {type(code)}\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+                f\"Generated code is expected to be a string, "
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                instead found {type(code)}\""
            },
            "60": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "             )"
            },
            "61": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         except OverflowError:"
            },
            "62": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             raise ValueError("
            },
            "63": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 206,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         if not found_solution_expr:"
            },
            "65": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "             raise ValueError("
            },
            "66": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"Generated code is missing the solution expression: {code_validations.solution_expression_name} of type: {code_validations.solution_expression_type}\""
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                f\"Generated code is missing the solution expression: "
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                {code_validations.solution_expression_name} of type:"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                {code_validations.solution_expression_type}\""
            },
            "70": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "             )"
            },
            "71": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 213,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         if not code_validations.allow_imports and has_imports:"
            },
            "73": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "                     and node.func.id in COMMAND_EXECUTION_FUNCTIONS"
            },
            "74": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "                 ):"
            },
            "75": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "                     raise ValueError("
            },
            "76": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        f\"Found illegal command execution function {node.func.id} in code {code}\""
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+                        f\"Found illegal command execution function"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                        {node.func.id} in code {code}\""
            },
            "79": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "                     )"
            },
            "80": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "     @classmethod"
            }
        },
        "frontPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "As in https://arxiv.org/pdf/2211.10435.pdf.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import ast",
            "import warnings",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import Extra, root_validator",
            "",
            "from langchain.base_language import BaseLanguageModel",
            "from langchain.callbacks.manager import CallbackManagerForChainRun",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.chains.pal.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain.chains.pal.math_prompt import MATH_PROMPT",
            "from langchain.prompts.base import BasePromptTemplate",
            "from langchain.utilities import PythonREPL",
            "",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]",
            "",
            "",
            "class PALValidation(object):",
            "    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef",
            "    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name",
            "",
            "    def __init__(",
            "        self,",
            "        solution_expression_name: Optional[str] = None,",
            "        solution_expression_type: Optional[type] = None,",
            "        allow_imports: bool = False,",
            "        allow_command_exec: bool = False,",
            "    ):",
            "        \"\"\"Initialize an PALValidation instance",
            "        Args:",
            "            solution_expression_name (str): Name of the expected solution expressions. If passed, solution_expression_type must be passed as well",
            "            solution_expression_type (str): ast type of the expected solution expression. If passed, solution_expression_name must be passed as well. Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION, PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            allow_imports (bool): Allow import statements",
            "            allow_command_exec (bool): Allow using known command execution functions.",
            "        \"\"\"",
            "        self.solution_expression_name = solution_expression_name",
            "        self.solution_expression_type = solution_expression_type",
            "",
            "        if solution_expression_name is not None:",
            "            if not isinstance(self.solution_expression_name, str):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_name to be str, instead found {type(self.solution_expression_name)}\"",
            "                )",
            "        if solution_expression_type is not None:",
            "            if (",
            "                not self.solution_expression_type",
            "                is self.SOLUTION_EXPRESSION_TYPE_FUNCTION",
            "                and not self.solution_expression_type",
            "                is self.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            ):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_type to be one of ({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}), instead found {self.solution_expression_type}\"",
            "                )",
            "",
            "        if solution_expression_name is not None and solution_expression_type is None:",
            "            raise TypeError(",
            "                f\"solution_expression_name requires solution_expression_type to be passed as well\"",
            "            )",
            "        if solution_expression_name is None and solution_expression_type is not None:",
            "            raise TypeError(",
            "                f\"solution_expression_type requires solution_expression_name to be passed as well\"",
            "            )",
            "",
            "        self.allow_imports = allow_imports",
            "        self.allow_command_exec = allow_command_exec",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Implements Program-Aided Language Models.\"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    llm: Optional[BaseLanguageModel] = None",
            "    \"\"\"[Deprecated]\"\"\"",
            "    prompt: BasePromptTemplate = MATH_PROMPT",
            "    \"\"\"[Deprecated]\"\"\"",
            "    stop: str = \"\\n\\n\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    code_validations: PALValidation = PALValidation()",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @root_validator(pre=True)",
            "    def raise_deprecation(cls, values: Dict) -> Dict:",
            "        if \"llm\" in values:",
            "            warnings.warn(",
            "                \"Directly instantiating an PALChain with an llm is deprecated. \"",
            "                \"Please instantiate with llm_chain argument or using the one of \"",
            "                \"the class method constructors from_math_prompt, \"",
            "                \"from_colored_object_prompt.\"",
            "            )",
            "            if \"llm_chain\" not in values and values[\"llm\"] is not None:",
            "                values[\"llm_chain\"] = LLMChain(llm=values[\"llm\"], prompt=MATH_PROMPT)",
            "        return values",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=10)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: PALValidation) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        found_solution_expr = False",
            "        if code_validations.solution_expression_name is None:",
            "            # Skip validation if no solution_expression_name was given",
            "            found_solution_expr = True",
            "",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            if (",
            "                code_validations.solution_expression_name is not None",
            "                and code_validations.solution_expression_type is not None",
            "            ):",
            "                # Check root nodes (like func def)",
            "                if (",
            "                    isinstance(node, code_validations.solution_expression_type)",
            "                    and hasattr(node, \"name\")",
            "                    and node.name == code_validations.solution_expression_name",
            "                ):",
            "                    found_solution_expr = True",
            "                # Check assigned nodes (like answer variable)",
            "                if isinstance(node, ast.Assign):",
            "                    for target_node in node.targets:",
            "                        if (",
            "                            isinstance(",
            "                                target_node, code_validations.solution_expression_type",
            "                            )",
            "                            and hasattr(target_node, \"id\")",
            "                            and target_node.id",
            "                            == code_validations.solution_expression_name",
            "                        ):",
            "                            found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression: {code_validations.solution_expression_name} of type: {code_validations.solution_expression_type}\"",
            "            )",
            "",
            "        if not code_validations.allow_imports and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if not code_validations.allow_command_exec:",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    isinstance(node, ast.Call)",
            "                    and hasattr(node.func, \"id\")",
            "                    and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function {node.func.id} in code {code}\"",
            "                    )",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"solution\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "        )",
            "",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"answer\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "afterPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "As in https://arxiv.org/pdf/2211.10435.pdf.",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "import ast",
            "import warnings",
            "from typing import Any, Dict, List, Optional",
            "",
            "from pydantic import Extra, root_validator",
            "",
            "from langchain.base_language import BaseLanguageModel",
            "from langchain.callbacks.manager import CallbackManagerForChainRun",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain.chains.pal.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain.chains.pal.math_prompt import MATH_PROMPT",
            "from langchain.prompts.base import BasePromptTemplate",
            "from langchain.utilities import PythonREPL",
            "",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\"]",
            "",
            "",
            "class PALValidation(object):",
            "    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef",
            "    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name",
            "",
            "    def __init__(",
            "        self,",
            "        solution_expression_name: Optional[str] = None,",
            "        solution_expression_type: Optional[type] = None,",
            "        allow_imports: bool = False,",
            "        allow_command_exec: bool = False,",
            "    ):",
            "        \"\"\"Initialize an PALValidation instance",
            "        Args:",
            "            solution_expression_name (str): Name of the expected solution expressions.",
            "                If passed, solution_expression_type must be passed as well",
            "            solution_expression_type (str): ast type of the expected solution ",
            "                expression. If passed, solution_expression_name must be passed as well.",
            "                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            allow_imports (bool): Allow import statements",
            "            allow_command_exec (bool): Allow using known command execution functions.",
            "        \"\"\"",
            "        self.solution_expression_name = solution_expression_name",
            "        self.solution_expression_type = solution_expression_type",
            "",
            "        if solution_expression_name is not None:",
            "            if not isinstance(self.solution_expression_name, str):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_name to be str, ",
            "                    instead found {type(self.solution_expression_name)}\"",
            "                )",
            "        if solution_expression_type is not None:",
            "            if (",
            "                self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION",
            "                and self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            ):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_type to be one of ",
            "                    ({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},",
            "                    {self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),",
            "                    instead found {self.solution_expression_type}\"",
            "                )",
            "",
            "        if solution_expression_name is not None and solution_expression_type is None:",
            "            raise TypeError(",
            "                \"solution_expression_name ",
            "                requires solution_expression_type to be passed as well\"",
            "            )",
            "        if solution_expression_name is None and solution_expression_type is not None:",
            "            raise TypeError(",
            "                \"solution_expression_type ",
            "                requires solution_expression_name to be passed as well\"",
            "            )",
            "",
            "        self.allow_imports = allow_imports",
            "        self.allow_command_exec = allow_command_exec",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Implements Program-Aided Language Models.\"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    llm: Optional[BaseLanguageModel] = None",
            "    \"\"\"[Deprecated]\"\"\"",
            "    prompt: BasePromptTemplate = MATH_PROMPT",
            "    \"\"\"[Deprecated]\"\"\"",
            "    stop: str = \"\\n\\n\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    code_validations: PALValidation = PALValidation()",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @root_validator(pre=True)",
            "    def raise_deprecation(cls, values: Dict) -> Dict:",
            "        if \"llm\" in values:",
            "            warnings.warn(",
            "                \"Directly instantiating an PALChain with an llm is deprecated. \"",
            "                \"Please instantiate with llm_chain argument or using the one of \"",
            "                \"the class method constructors from_math_prompt, \"",
            "                \"from_colored_object_prompt.\"",
            "            )",
            "            if \"llm_chain\" not in values and values[\"llm\"] is not None:",
            "                values[\"llm_chain\"] = LLMChain(llm=values[\"llm\"], prompt=MATH_PROMPT)",
            "        return values",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "        repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=10)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: PALValidation) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, ",
            "                instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        found_solution_expr = False",
            "        if code_validations.solution_expression_name is None:",
            "            # Skip validation if no solution_expression_name was given",
            "            found_solution_expr = True",
            "",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            if (",
            "                code_validations.solution_expression_name is not None",
            "                and code_validations.solution_expression_type is not None",
            "            ):",
            "                # Check root nodes (like func def)",
            "                if (",
            "                    isinstance(node, code_validations.solution_expression_type)",
            "                    and hasattr(node, \"name\")",
            "                    and node.name == code_validations.solution_expression_name",
            "                ):",
            "                    found_solution_expr = True",
            "                # Check assigned nodes (like answer variable)",
            "                if isinstance(node, ast.Assign):",
            "                    for target_node in node.targets:",
            "                        if (",
            "                            isinstance(",
            "                                target_node, code_validations.solution_expression_type",
            "                            )",
            "                            and hasattr(target_node, \"id\")",
            "                            and target_node.id",
            "                            == code_validations.solution_expression_name",
            "                        ):",
            "                            found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression: ",
            "                {code_validations.solution_expression_name} of type:",
            "                {code_validations.solution_expression_type}\"",
            "            )",
            "",
            "        if not code_validations.allow_imports and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if not code_validations.allow_command_exec:",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    isinstance(node, ast.Call)",
            "                    and hasattr(node.func, \"id\")",
            "                    and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function",
            "                        {node.func.id} in code {code}\"",
            "                    )",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"solution\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "        )",
            "",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.\"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"answer\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": [
                "PALValidation",
                "__init__"
            ],
            "39": [
                "PALValidation",
                "__init__"
            ],
            "49": [
                "PALValidation",
                "__init__"
            ],
            "53": [
                "PALValidation",
                "__init__"
            ],
            "54": [
                "PALValidation",
                "__init__"
            ],
            "55": [
                "PALValidation",
                "__init__"
            ],
            "56": [
                "PALValidation",
                "__init__"
            ],
            "59": [
                "PALValidation",
                "__init__"
            ],
            "64": [
                "PALValidation",
                "__init__"
            ],
            "68": [
                "PALValidation",
                "__init__"
            ],
            "155": [
                "PALChain",
                "validate_code"
            ],
            "198": [
                "PALChain",
                "validate_code"
            ],
            "212": [
                "PALChain",
                "validate_code"
            ]
        },
        "addLocation": []
    },
    "langchain/utilities/python.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import multiprocessing"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import sys"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from io import StringIO"
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from multiprocessing import Pool"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Dict, Optional"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from pydantic import BaseModel, Field"
            },
            "7": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "             queue.put(repr(e))"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     def run(self, command: str, timeout: Optional[int] = None) -> str:"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"Run command with own globals/locals and returns anything printed. Timeout after the specified number of seconds.\"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        \"\"\"Run command with own globals/locals and returns anything printed."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        Timeout after the specified number of seconds.\"\"\""
            },
            "13": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         # Warn against dangers of PythonREPL"
            },
            "15": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         warn_once()"
            }
        },
        "frontPatchFile": [
            "import functools",
            "import logging",
            "import multiprocessing",
            "import sys",
            "from io import StringIO",
            "from multiprocessing import Pool",
            "from typing import Dict, Optional",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def warn_once() -> None:",
            "    # Warn that the PythonREPL",
            "    logger.warning(\"Python REPL can execute arbitrary code. Use with caution.\")",
            "",
            "",
            "class PythonREPL(BaseModel):",
            "    \"\"\"Simulates a standalone Python REPL.\"\"\"",
            "",
            "    globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")",
            "    locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")",
            "",
            "    @classmethod",
            "    def worker(",
            "        cls,",
            "        command: str,",
            "        globals: Optional[Dict],",
            "        locals: Optional[Dict],",
            "        queue: multiprocessing.Queue,",
            "    ) -> None:",
            "        old_stdout = sys.stdout",
            "        sys.stdout = mystdout = StringIO()",
            "        try:",
            "            exec(command, globals, locals)",
            "            sys.stdout = old_stdout",
            "            queue.put(mystdout.getvalue())",
            "        except Exception as e:",
            "            sys.stdout = old_stdout",
            "            queue.put(repr(e))",
            "",
            "    def run(self, command: str, timeout: Optional[int] = None) -> str:",
            "        \"\"\"Run command with own globals/locals and returns anything printed. Timeout after the specified number of seconds.\"\"\"",
            "",
            "        # Warn against dangers of PythonREPL",
            "        warn_once()",
            "",
            "        queue: multiprocessing.Queue = multiprocessing.Queue()",
            "",
            "        # Only use multiprocessing if we are enforcing a timeout",
            "        if timeout is not None:",
            "            # create a Process",
            "            p = multiprocessing.Process(",
            "                target=self.worker, args=(command, self.globals, self.locals, queue)",
            "            )",
            "",
            "            # start it",
            "            p.start()",
            "",
            "            # wait for the process to finish or kill it after timeout seconds",
            "            p.join(timeout)",
            "",
            "            if p.is_alive():",
            "                p.terminate()",
            "                return \"Execution timed out\"",
            "        else:",
            "            self.worker(command, self.globals, self.locals, queue)",
            "        # get the result from the worker function",
            "        return queue.get()"
        ],
        "afterPatchFile": [
            "import functools",
            "import logging",
            "import multiprocessing",
            "import sys",
            "from io import StringIO",
            "from typing import Dict, Optional",
            "",
            "from pydantic import BaseModel, Field",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "@functools.lru_cache(maxsize=None)",
            "def warn_once() -> None:",
            "    # Warn that the PythonREPL",
            "    logger.warning(\"Python REPL can execute arbitrary code. Use with caution.\")",
            "",
            "",
            "class PythonREPL(BaseModel):",
            "    \"\"\"Simulates a standalone Python REPL.\"\"\"",
            "",
            "    globals: Optional[Dict] = Field(default_factory=dict, alias=\"_globals\")",
            "    locals: Optional[Dict] = Field(default_factory=dict, alias=\"_locals\")",
            "",
            "    @classmethod",
            "    def worker(",
            "        cls,",
            "        command: str,",
            "        globals: Optional[Dict],",
            "        locals: Optional[Dict],",
            "        queue: multiprocessing.Queue,",
            "    ) -> None:",
            "        old_stdout = sys.stdout",
            "        sys.stdout = mystdout = StringIO()",
            "        try:",
            "            exec(command, globals, locals)",
            "            sys.stdout = old_stdout",
            "            queue.put(mystdout.getvalue())",
            "        except Exception as e:",
            "            sys.stdout = old_stdout",
            "            queue.put(repr(e))",
            "",
            "    def run(self, command: str, timeout: Optional[int] = None) -> str:",
            "        \"\"\"Run command with own globals/locals and returns anything printed.",
            "        Timeout after the specified number of seconds.\"\"\"",
            "",
            "        # Warn against dangers of PythonREPL",
            "        warn_once()",
            "",
            "        queue: multiprocessing.Queue = multiprocessing.Queue()",
            "",
            "        # Only use multiprocessing if we are enforcing a timeout",
            "        if timeout is not None:",
            "            # create a Process",
            "            p = multiprocessing.Process(",
            "                target=self.worker, args=(command, self.globals, self.locals, queue)",
            "            )",
            "",
            "            # start it",
            "            p.start()",
            "",
            "            # wait for the process to finish or kill it after timeout seconds",
            "            p.join(timeout)",
            "",
            "            if p.is_alive():",
            "                p.terminate()",
            "                return \"Execution timed out\"",
            "        else:",
            "            self.worker(command, self.globals, self.locals, queue)",
            "        # get the result from the worker function",
            "        return queue.get()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "45": [
                "PythonREPL",
                "run"
            ]
        },
        "addLocation": []
    }
}