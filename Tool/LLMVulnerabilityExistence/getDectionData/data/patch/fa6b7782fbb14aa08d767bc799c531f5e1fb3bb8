{
    "tensorflow/python/ops/ragged/ragged_cross_op_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import numpy as np"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from tensorflow.python.eager import def_function"
            },
            "4": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from tensorflow.python.framework import dtypes"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from tensorflow.python.framework import errors"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from tensorflow.python.framework import ops"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from tensorflow.python.framework import sparse_tensor"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from tensorflow.python.framework import tensor_spec"
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from tensorflow.python.framework import test_util"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from tensorflow.python.ops import sparse_ops"
            },
            "11": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from tensorflow.python.ops.ragged import ragged_array_ops"
            },
            "12": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "                   dense_const([[2], [3]])],"
            },
            "13": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "           exception=(ValueError, errors.InvalidArgumentError),"
            },
            "14": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "           message='inputs must all have the same batch dimension size'),"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+      dict("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+          testcase_name='3DDenseTensor',"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+          inputs=[dense_const([[[1]]])],"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+          exception=(ValueError, errors.InvalidArgumentError),"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+          message='tf.ragged.cross only supports inputs with rank=2'),"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+      dict("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+          testcase_name='0DDenseTensor',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+          inputs=[dense_const(1)],"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+          exception=(ValueError, errors.InvalidArgumentError),"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+          message='tf.ragged.cross only supports inputs with rank=2'),"
            },
            "25": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 373,
                "PatchRowcode": "   ])"
            },
            "26": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 374,
                "PatchRowcode": "   def testStaticError(self, inputs, exception=ValueError, message=None):"
            },
            "27": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "     with self.assertRaisesRegex(exception, message):"
            },
            "28": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "           testcase_name='3DRaggedTensor',"
            },
            "29": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "           inputs=[ragged_const([[[1]]], ragged_rank=1)],"
            },
            "30": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "           message='tf.ragged.cross only supports inputs with rank=2'),"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+      dict("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+          testcase_name='0DDenseTensor',"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+          inputs=[dense_const(1)],"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+          signature=[[tensor_spec.TensorSpec(None, dtypes.int32)]],"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+          exception=(ValueError, errors.InvalidArgumentError),"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 388,
                "PatchRowcode": "+          message='tf.ragged.cross only supports inputs with rank=2'),"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 389,
                "PatchRowcode": "+      dict("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 390,
                "PatchRowcode": "+          testcase_name='1DDenseTensor',"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 391,
                "PatchRowcode": "+          inputs=[dense_const([1])],"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 392,
                "PatchRowcode": "+          signature=[[tensor_spec.TensorSpec(None, dtypes.int32)]],"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 393,
                "PatchRowcode": "+          exception=(ValueError, errors.InvalidArgumentError),"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 394,
                "PatchRowcode": "+          message='tf.ragged.cross only supports inputs with rank=2'),"
            },
            "43": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "       dict("
            },
            "44": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "           testcase_name='3DDenseTensor',"
            },
            "45": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "           inputs=[dense_const([[[1]]])],"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+          signature=[[tensor_spec.TensorSpec(None, dtypes.int32)]],"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+          exception=(ValueError, errors.InvalidArgumentError),"
            },
            "48": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "           message='tf.ragged.cross only supports inputs with rank=2'),"
            },
            "49": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "   ])"
            },
            "50": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "   def testRuntimeError(self,"
            },
            "51": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "                        inputs,"
            },
            "52": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "                        exception=errors.InvalidArgumentError,"
            },
            "53": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                       message=None):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+                       message=None,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+                       signature=None):"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+    @def_function.function(input_signature=signature)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+    def fn(x):"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+      return ragged_array_ops.cross(x)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "     with self.assertRaisesRegex(exception, message):"
            },
            "61": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-      self.evaluate(ragged_array_ops.cross(inputs))"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+      self.evaluate(fn(inputs))"
            },
            "63": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 413,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 414,
                "PatchRowcode": "   def _ragged_to_sparse(self, t):"
            },
            "65": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 415,
                "PatchRowcode": "     if ragged_tensor.is_ragged(t):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for tf.ragged.cross and tf.ragged.cross_hashed.\"\"\"",
            "",
            "from absl.testing import parameterized",
            "",
            "import numpy as np",
            "",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import sparse_ops",
            "from tensorflow.python.ops.ragged import ragged_array_ops",
            "from tensorflow.python.ops.ragged import ragged_factory_ops",
            "from tensorflow.python.ops.ragged import ragged_tensor",
            "from tensorflow.python.platform import googletest",
            "",
            "ragged_const = ragged_factory_ops.constant_value",
            "dense_const = np.array",
            "",
            "",
            "def sparse_const(matrix):",
            "  indices = []",
            "  values = []",
            "  for i, row in enumerate(matrix):",
            "    for j, val in enumerate(row):",
            "      indices.append([i, j])",
            "      values.append(val)",
            "  shape = [len(matrix), max(len(row) for row in matrix)] if matrix else [0, 0]",
            "  if not values:",
            "    indices = np.zeros([0, 2], dtype=np.int64)",
            "    values = np.zeros([0], dtype=np.int64)",
            "  return sparse_tensor.SparseTensorValue(indices, values, shape)",
            "",
            "",
            "@test_util.run_all_in_graph_and_eager_modes",
            "class RaggedCrossOpTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
            "",
            "  @parameterized.named_parameters([",
            "      dict(",
            "          testcase_name='NoInputs',",
            "          inputs=[],",
            "          expected=ragged_const([], ragged_rank=1, dtype=dtypes.int32)),",
            "      dict(",
            "          testcase_name='OneInput_RaggedStr',",
            "          inputs=[ragged_const([['a', 'b'], [], ['c']])],",
            "          expected=ragged_const([[b'a', b'b'], [], [b'c']])),",
            "      dict(",
            "          testcase_name='OneInput_RaggedInt',",
            "          inputs=[ragged_const([[1, 2, 3], [4, 5]])],",
            "          expected=ragged_const([[b'1', b'2', b'3'], [b'4', b'5']])),",
            "      dict(",
            "          testcase_name='OneInput_DenseInt',",
            "          inputs=[dense_const([[1, 2, 3], [4, 5, 6]])],",
            "          expected=ragged_const([[b'1', b'2', b'3'], [b'4', b'5', b'6']])),",
            "      dict(",
            "          testcase_name='OneInput_SparseStr',",
            "          inputs=[sparse_const([['a', 'b'], [], ['c']])],",
            "          expected=ragged_const([[b'a', b'b'], [], [b'c']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedStr_RaggedStr',",
            "          inputs=[",
            "              ragged_const([['a', 'b'], [], ['c']]),",
            "              ragged_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'a_X_d', b'a_X_e', b'b_X_d', b'b_X_e'], [],",
            "                                 [b'c_X_g']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedInt_RaggedInt',",
            "          inputs=[",
            "              ragged_const([[1, 2], [], [3]]),",
            "              ragged_const([[4, 5, 6], [], [7]])",
            "          ],",
            "          expected=ragged_const(",
            "              [[b'1_X_4', b'1_X_5', b'1_X_6', b'2_X_4', b'2_X_5', b'2_X_6'], [],",
            "               [b'3_X_7']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedStr_RaggedInt',",
            "          inputs=[",
            "              ragged_const([['a', 'b'], [], ['c']]),",
            "              ragged_const([['1', '2'], ['3'], ['4']])",
            "          ],",
            "          expected=ragged_const([[b'a_X_1', b'a_X_2', b'b_X_1', b'b_X_2'], [],",
            "                                 [b'c_X_4']])),",
            "      dict(",
            "          testcase_name='TwoInputs_SparseStr_SparseStr',",
            "          inputs=[",
            "              sparse_const([['a', 'b'], [], ['c']]),",
            "              sparse_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'a_X_d', b'a_X_e', b'b_X_d', b'b_X_e'], [],",
            "                                 [b'c_X_g']])),",
            "      dict(",
            "          testcase_name='TwoInputs_DenseInt_DenseInt',",
            "          inputs=[dense_const([[1, 2], [3, 4]]),",
            "                  dense_const([[5, 6], [7, 8]])],",
            "          expected=ragged_const([[b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],",
            "                                 [b'3_X_7', b'3_X_8', b'4_X_7', b'4_X_8']])),",
            "      dict(",
            "          testcase_name='TwoInputs_DenseInt_DenseStr',",
            "          inputs=[",
            "              dense_const([[1, 2], [3, 4]]),",
            "              dense_const([[b'5', b'6'], [b'7', b'8']])",
            "          ],",
            "          expected=ragged_const([[b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],",
            "                                 [b'3_X_7', b'3_X_8', b'4_X_7', b'4_X_8']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedInt_DenseInt',",
            "          inputs=[",
            "              ragged_const([[], [], [1, 2], [3]]),",
            "              dense_const([[1, 2], [3, 4], [5, 6], [7, 8]])",
            "          ],",
            "          expected=ragged_const([[], [],",
            "                                 [b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],",
            "                                 [b'3_X_7', b'3_X_8']])),",
            "      dict(",
            "          # This test exercises `input_order`.",
            "          testcase_name='TwoInputs_DenseInt_RaggedStr',",
            "          inputs=[",
            "              dense_const([[1, 2], [3, 4], [5, 6]]),",
            "              ragged_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'1_X_d', b'1_X_e', b'2_X_d', b'2_X_e'],",
            "                                 [b'3_X_f', b'4_X_f'], [b'5_X_g', b'6_X_g']]),",
            "          matches_sparse_cross=False  # sparse doesn't preserve input order.",
            "      ),",
            "      dict(",
            "          # This test exercises `input_order`.",
            "          testcase_name='TwoInputs_SparseInt_RaggedStr',",
            "          inputs=[",
            "              sparse_const([[1, 2], [3, 4], [5, 6]]),",
            "              ragged_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'1_X_d', b'1_X_e', b'2_X_d', b'2_X_e'],",
            "                                 [b'3_X_f', b'4_X_f'], [b'5_X_g', b'6_X_g']]),",
            "          matches_sparse_cross=False  # sparse doesn't preserve input order.",
            "      ),",
            "      dict(",
            "          testcase_name='ThreeInputs_RaggedInt_RaggedInt_RaggedInt',",
            "          inputs=[",
            "              ragged_const([[11], [12, 13], [], [14, 15]]),",
            "              ragged_const([[21, 22], [23], [24, 25], [26, 27]]),",
            "              ragged_const([[31], [32, 33], [34, 35], [36, 37]])",
            "          ],",
            "          expected=ragged_const([[b'11_X_21_X_31', b'11_X_22_X_31'],",
            "                                 [",
            "                                     b'12_X_23_X_32', b'12_X_23_X_33',",
            "                                     b'13_X_23_X_32', b'13_X_23_X_33'",
            "                                 ], [],",
            "                                 [",
            "                                     b'14_X_26_X_36', b'14_X_26_X_37',",
            "                                     b'14_X_27_X_36', b'14_X_27_X_37',",
            "                                     b'15_X_26_X_36', b'15_X_26_X_37',",
            "                                     b'15_X_27_X_36', b'15_X_27_X_37'",
            "                                 ]])),",
            "      dict(",
            "          testcase_name='ThreeInputs_RaggedInt_SparseInt_DenseInt',",
            "          inputs=[",
            "              ragged_const([[11], [12, 13], [], [14, 15]]),",
            "              sparse_const([[21, 22], [23], [24, 25], [26, 27]]),",
            "              dense_const([[31], [32], [33], [34]])",
            "          ],",
            "          expected=ragged_const([[b'11_X_21_X_31', b'11_X_22_X_31'],",
            "                                 [",
            "                                     b'12_X_23_X_32',",
            "                                     b'13_X_23_X_32',",
            "                                 ], [],",
            "                                 [",
            "                                     b'14_X_26_X_34',",
            "                                     b'14_X_27_X_34',",
            "                                     b'15_X_26_X_34',",
            "                                     b'15_X_27_X_34',",
            "                                 ]])),",
            "      dict(",
            "          testcase_name='FiveInputs',",
            "          inputs=[",
            "              ragged_const([[1]]),",
            "              dense_const([[2]]),",
            "              ragged_const([[3]]),",
            "              sparse_const([[4]]),",
            "              ragged_const([[5]])",
            "          ],",
            "          expected=ragged_const([[b'1_X_2_X_3_X_4_X_5']]),",
            "          matches_sparse_cross=False  # sparse doesn't preserve input order.",
            "      ),",
            "      dict(",
            "          testcase_name='Permutation_3x3x3',",
            "          inputs=[[['11', '12', '13']], [['21', '22', '23']],",
            "                  [['31', '32', '33']]],",
            "          expected=[[",
            "              b'11_X_21_X_31', b'11_X_21_X_32', b'11_X_21_X_33',",
            "              b'11_X_22_X_31', b'11_X_22_X_32', b'11_X_22_X_33',",
            "              b'11_X_23_X_31', b'11_X_23_X_32', b'11_X_23_X_33',",
            "              b'12_X_21_X_31', b'12_X_21_X_32', b'12_X_21_X_33',",
            "              b'12_X_22_X_31', b'12_X_22_X_32', b'12_X_22_X_33',",
            "              b'12_X_23_X_31', b'12_X_23_X_32', b'12_X_23_X_33',",
            "              b'13_X_21_X_31', b'13_X_21_X_32', b'13_X_21_X_33',",
            "              b'13_X_22_X_31', b'13_X_22_X_32', b'13_X_22_X_33',",
            "              b'13_X_23_X_31', b'13_X_23_X_32', b'13_X_23_X_33'",
            "          ]]),",
            "      dict(",
            "          testcase_name='BatchSizeZero',",
            "          inputs=[",
            "              ragged_const([], ragged_rank=1, dtype=dtypes.int32),",
            "              sparse_const([]),",
            "              np.zeros([0, 3], dtype=np.int32),",
            "          ],",
            "          expected=ragged_const([], ragged_rank=1, dtype=dtypes.int32)),",
            "      dict(",
            "          testcase_name='ThreeInputs_OneEmpty',",
            "          inputs=[",
            "              ragged_const([[1, 2]]),",
            "              ragged_const([[]], dtype=dtypes.int32),",
            "              ragged_const([[3, 4]])",
            "          ],",
            "          expected=ragged_const([[]], dtype=dtypes.string)),",
            "      dict(",
            "          testcase_name='ThreeInputs_AllEmpty',",
            "          inputs=[",
            "              ragged_const([[]], dtype=dtypes.int64),",
            "              ragged_const([[]], dtype=dtypes.string),",
            "              ragged_const([[]], dtype=dtypes.int32)",
            "          ],",
            "          expected=ragged_const([[]], ragged_rank=1, dtype=dtypes.string)),",
            "      dict(",
            "          testcase_name='HashedZeroBucketsDefaultKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          expected_hashed=ragged_const([[1971693436396284976]])),",
            "      dict(",
            "          testcase_name='Hashed100BucketsDefaultKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          num_buckets=100,",
            "          expected_hashed=ragged_const([[83]])),",
            "      dict(",
            "          testcase_name='HashedZeroBucketsCustomKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          hash_key=ragged_array_ops._DEFAULT_CROSS_HASH_KEY + 1,",
            "          expected_hashed=ragged_const([[4847552627144134031]])),",
            "      dict(",
            "          testcase_name='Hashed100BucketsCustomKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          num_buckets=100,",
            "          hash_key=ragged_array_ops._DEFAULT_CROSS_HASH_KEY + 1,",
            "          expected_hashed=ragged_const([[31]])),",
            "      dict(",
            "          testcase_name='HashedZeroKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          hash_key=0,",
            "          expected_hashed=ragged_const([[9077905385164735582]]),",
            "          matches_sparse_cross=False  # sparse treats hash_key=0 as None.",
            "      ),",
            "      dict(",
            "          testcase_name='UInt64',",
            "          inputs=[ragged_const([[2**64 - 1]], dtype=dtypes.uint64)],",
            "          expected=ragged_const([[b'-1']])),",
            "  ])",
            "  def testRaggedCross(self,",
            "                      inputs,",
            "                      num_buckets=0,",
            "                      hash_key=None,",
            "                      expected=None,",
            "                      expected_hashed=None,",
            "                      matches_sparse_cross=True):",
            "    ragged_cross = ragged_array_ops.cross(inputs)",
            "    ragged_cross_hashed = ragged_array_ops.cross_hashed(inputs, num_buckets,",
            "                                                        hash_key)",
            "",
            "    if expected is not None:",
            "      self.assertAllEqual(ragged_cross, expected)",
            "    if expected_hashed is not None:",
            "      self.assertAllEqual(ragged_cross_hashed, expected_hashed)",
            "",
            "    if matches_sparse_cross:",
            "      # Check that ragged.cross & sparse.cross match.",
            "      sparse_inputs = [self._ragged_to_sparse(t) for t in inputs]",
            "      sparse_cross = sparse_ops.sparse_cross(sparse_inputs)",
            "      self.assertAllEqual(ragged_cross,",
            "                          ragged_tensor.RaggedTensor.from_sparse(sparse_cross))",
            "",
            "      # Check that ragged.cross_hashed & sparse.cross_hashed match.",
            "      sparse_inputs = [self._ragged_to_sparse(t) for t in inputs]",
            "      sparse_cross_hashed = sparse_ops.sparse_cross_hashed(",
            "          sparse_inputs, num_buckets, hash_key)",
            "      self.assertAllEqual(",
            "          ragged_cross_hashed,",
            "          ragged_tensor.RaggedTensor.from_sparse(sparse_cross_hashed))",
            "",
            "  def testRaggedCrossLargeBatch(self):",
            "    batch_size = 5000",
            "    inputs = [",
            "        ragged_const([[1, 2, 3]] * batch_size),",
            "        ragged_const([[b'4']] * batch_size),",
            "        dense_const([[5]] * batch_size),",
            "        sparse_const([[6, 7]] * batch_size)",
            "    ]",
            "",
            "    expected = [[",
            "        b'1_X_4_X_5_X_6', b'1_X_4_X_5_X_7', b'2_X_4_X_5_X_6', b'2_X_4_X_5_X_7',",
            "        b'3_X_4_X_5_X_6', b'3_X_4_X_5_X_7'",
            "    ]] * batch_size",
            "",
            "    ragged_cross = ragged_array_ops.cross(inputs)",
            "",
            "    # Note: we don't use assertAllEqual here because if they don't match,",
            "    # then the code in assertAllEqual that tries to build the error message",
            "    # is very slow, causing the test to timeout.",
            "    # pylint: disable=g-generic-assert",
            "    self.assertTrue(self.evaluate(ragged_cross).to_list() == expected)",
            "",
            "  @parameterized.named_parameters([",
            "      dict(",
            "          testcase_name='BadDType',",
            "          inputs=[ragged_const([[1.1], [2.2, 3.3]])],",
            "          message=r'Unexpected dtype for inputs\\[0\\]'),",
            "      dict(",
            "          testcase_name='StaticBatchSizeMismatch1',",
            "          inputs=[ragged_const([[1]]),",
            "                  ragged_const([[2], [3]])],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='inputs must all have the same batch dimension size'),",
            "      dict(",
            "          testcase_name='StaticBatchSizeMismatch2',",
            "          inputs=[ragged_const([[1]]),",
            "                  dense_const([[2], [3]])],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='inputs must all have the same batch dimension size'),",
            "  ])",
            "  def testStaticError(self, inputs, exception=ValueError, message=None):",
            "    with self.assertRaisesRegex(exception, message):",
            "      ragged_array_ops.cross(inputs)",
            "",
            "  @parameterized.named_parameters([",
            "      dict(",
            "          testcase_name='3DRaggedTensor',",
            "          inputs=[ragged_const([[[1]]], ragged_rank=1)],",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "      dict(",
            "          testcase_name='3DDenseTensor',",
            "          inputs=[dense_const([[[1]]])],",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "  ])",
            "  def testRuntimeError(self,",
            "                       inputs,",
            "                       exception=errors.InvalidArgumentError,",
            "                       message=None):",
            "    with self.assertRaisesRegex(exception, message):",
            "      self.evaluate(ragged_array_ops.cross(inputs))",
            "",
            "  def _ragged_to_sparse(self, t):",
            "    if ragged_tensor.is_ragged(t):",
            "      return ragged_tensor.convert_to_tensor_or_ragged_tensor(t).to_sparse()",
            "    elif sparse_tensor.is_sparse(t):",
            "      return sparse_tensor.SparseTensor.from_value(t)",
            "    else:",
            "      return ops.convert_to_tensor(t)",
            "",
            "",
            "if __name__ == '__main__':",
            "  googletest.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for tf.ragged.cross and tf.ragged.cross_hashed.\"\"\"",
            "",
            "from absl.testing import parameterized",
            "",
            "import numpy as np",
            "",
            "from tensorflow.python.eager import def_function",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.framework import tensor_spec",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import sparse_ops",
            "from tensorflow.python.ops.ragged import ragged_array_ops",
            "from tensorflow.python.ops.ragged import ragged_factory_ops",
            "from tensorflow.python.ops.ragged import ragged_tensor",
            "from tensorflow.python.platform import googletest",
            "",
            "ragged_const = ragged_factory_ops.constant_value",
            "dense_const = np.array",
            "",
            "",
            "def sparse_const(matrix):",
            "  indices = []",
            "  values = []",
            "  for i, row in enumerate(matrix):",
            "    for j, val in enumerate(row):",
            "      indices.append([i, j])",
            "      values.append(val)",
            "  shape = [len(matrix), max(len(row) for row in matrix)] if matrix else [0, 0]",
            "  if not values:",
            "    indices = np.zeros([0, 2], dtype=np.int64)",
            "    values = np.zeros([0], dtype=np.int64)",
            "  return sparse_tensor.SparseTensorValue(indices, values, shape)",
            "",
            "",
            "@test_util.run_all_in_graph_and_eager_modes",
            "class RaggedCrossOpTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
            "",
            "  @parameterized.named_parameters([",
            "      dict(",
            "          testcase_name='NoInputs',",
            "          inputs=[],",
            "          expected=ragged_const([], ragged_rank=1, dtype=dtypes.int32)),",
            "      dict(",
            "          testcase_name='OneInput_RaggedStr',",
            "          inputs=[ragged_const([['a', 'b'], [], ['c']])],",
            "          expected=ragged_const([[b'a', b'b'], [], [b'c']])),",
            "      dict(",
            "          testcase_name='OneInput_RaggedInt',",
            "          inputs=[ragged_const([[1, 2, 3], [4, 5]])],",
            "          expected=ragged_const([[b'1', b'2', b'3'], [b'4', b'5']])),",
            "      dict(",
            "          testcase_name='OneInput_DenseInt',",
            "          inputs=[dense_const([[1, 2, 3], [4, 5, 6]])],",
            "          expected=ragged_const([[b'1', b'2', b'3'], [b'4', b'5', b'6']])),",
            "      dict(",
            "          testcase_name='OneInput_SparseStr',",
            "          inputs=[sparse_const([['a', 'b'], [], ['c']])],",
            "          expected=ragged_const([[b'a', b'b'], [], [b'c']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedStr_RaggedStr',",
            "          inputs=[",
            "              ragged_const([['a', 'b'], [], ['c']]),",
            "              ragged_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'a_X_d', b'a_X_e', b'b_X_d', b'b_X_e'], [],",
            "                                 [b'c_X_g']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedInt_RaggedInt',",
            "          inputs=[",
            "              ragged_const([[1, 2], [], [3]]),",
            "              ragged_const([[4, 5, 6], [], [7]])",
            "          ],",
            "          expected=ragged_const(",
            "              [[b'1_X_4', b'1_X_5', b'1_X_6', b'2_X_4', b'2_X_5', b'2_X_6'], [],",
            "               [b'3_X_7']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedStr_RaggedInt',",
            "          inputs=[",
            "              ragged_const([['a', 'b'], [], ['c']]),",
            "              ragged_const([['1', '2'], ['3'], ['4']])",
            "          ],",
            "          expected=ragged_const([[b'a_X_1', b'a_X_2', b'b_X_1', b'b_X_2'], [],",
            "                                 [b'c_X_4']])),",
            "      dict(",
            "          testcase_name='TwoInputs_SparseStr_SparseStr',",
            "          inputs=[",
            "              sparse_const([['a', 'b'], [], ['c']]),",
            "              sparse_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'a_X_d', b'a_X_e', b'b_X_d', b'b_X_e'], [],",
            "                                 [b'c_X_g']])),",
            "      dict(",
            "          testcase_name='TwoInputs_DenseInt_DenseInt',",
            "          inputs=[dense_const([[1, 2], [3, 4]]),",
            "                  dense_const([[5, 6], [7, 8]])],",
            "          expected=ragged_const([[b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],",
            "                                 [b'3_X_7', b'3_X_8', b'4_X_7', b'4_X_8']])),",
            "      dict(",
            "          testcase_name='TwoInputs_DenseInt_DenseStr',",
            "          inputs=[",
            "              dense_const([[1, 2], [3, 4]]),",
            "              dense_const([[b'5', b'6'], [b'7', b'8']])",
            "          ],",
            "          expected=ragged_const([[b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],",
            "                                 [b'3_X_7', b'3_X_8', b'4_X_7', b'4_X_8']])),",
            "      dict(",
            "          testcase_name='TwoInputs_RaggedInt_DenseInt',",
            "          inputs=[",
            "              ragged_const([[], [], [1, 2], [3]]),",
            "              dense_const([[1, 2], [3, 4], [5, 6], [7, 8]])",
            "          ],",
            "          expected=ragged_const([[], [],",
            "                                 [b'1_X_5', b'1_X_6', b'2_X_5', b'2_X_6'],",
            "                                 [b'3_X_7', b'3_X_8']])),",
            "      dict(",
            "          # This test exercises `input_order`.",
            "          testcase_name='TwoInputs_DenseInt_RaggedStr',",
            "          inputs=[",
            "              dense_const([[1, 2], [3, 4], [5, 6]]),",
            "              ragged_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'1_X_d', b'1_X_e', b'2_X_d', b'2_X_e'],",
            "                                 [b'3_X_f', b'4_X_f'], [b'5_X_g', b'6_X_g']]),",
            "          matches_sparse_cross=False  # sparse doesn't preserve input order.",
            "      ),",
            "      dict(",
            "          # This test exercises `input_order`.",
            "          testcase_name='TwoInputs_SparseInt_RaggedStr',",
            "          inputs=[",
            "              sparse_const([[1, 2], [3, 4], [5, 6]]),",
            "              ragged_const([['d', 'e'], ['f'], ['g']])",
            "          ],",
            "          expected=ragged_const([[b'1_X_d', b'1_X_e', b'2_X_d', b'2_X_e'],",
            "                                 [b'3_X_f', b'4_X_f'], [b'5_X_g', b'6_X_g']]),",
            "          matches_sparse_cross=False  # sparse doesn't preserve input order.",
            "      ),",
            "      dict(",
            "          testcase_name='ThreeInputs_RaggedInt_RaggedInt_RaggedInt',",
            "          inputs=[",
            "              ragged_const([[11], [12, 13], [], [14, 15]]),",
            "              ragged_const([[21, 22], [23], [24, 25], [26, 27]]),",
            "              ragged_const([[31], [32, 33], [34, 35], [36, 37]])",
            "          ],",
            "          expected=ragged_const([[b'11_X_21_X_31', b'11_X_22_X_31'],",
            "                                 [",
            "                                     b'12_X_23_X_32', b'12_X_23_X_33',",
            "                                     b'13_X_23_X_32', b'13_X_23_X_33'",
            "                                 ], [],",
            "                                 [",
            "                                     b'14_X_26_X_36', b'14_X_26_X_37',",
            "                                     b'14_X_27_X_36', b'14_X_27_X_37',",
            "                                     b'15_X_26_X_36', b'15_X_26_X_37',",
            "                                     b'15_X_27_X_36', b'15_X_27_X_37'",
            "                                 ]])),",
            "      dict(",
            "          testcase_name='ThreeInputs_RaggedInt_SparseInt_DenseInt',",
            "          inputs=[",
            "              ragged_const([[11], [12, 13], [], [14, 15]]),",
            "              sparse_const([[21, 22], [23], [24, 25], [26, 27]]),",
            "              dense_const([[31], [32], [33], [34]])",
            "          ],",
            "          expected=ragged_const([[b'11_X_21_X_31', b'11_X_22_X_31'],",
            "                                 [",
            "                                     b'12_X_23_X_32',",
            "                                     b'13_X_23_X_32',",
            "                                 ], [],",
            "                                 [",
            "                                     b'14_X_26_X_34',",
            "                                     b'14_X_27_X_34',",
            "                                     b'15_X_26_X_34',",
            "                                     b'15_X_27_X_34',",
            "                                 ]])),",
            "      dict(",
            "          testcase_name='FiveInputs',",
            "          inputs=[",
            "              ragged_const([[1]]),",
            "              dense_const([[2]]),",
            "              ragged_const([[3]]),",
            "              sparse_const([[4]]),",
            "              ragged_const([[5]])",
            "          ],",
            "          expected=ragged_const([[b'1_X_2_X_3_X_4_X_5']]),",
            "          matches_sparse_cross=False  # sparse doesn't preserve input order.",
            "      ),",
            "      dict(",
            "          testcase_name='Permutation_3x3x3',",
            "          inputs=[[['11', '12', '13']], [['21', '22', '23']],",
            "                  [['31', '32', '33']]],",
            "          expected=[[",
            "              b'11_X_21_X_31', b'11_X_21_X_32', b'11_X_21_X_33',",
            "              b'11_X_22_X_31', b'11_X_22_X_32', b'11_X_22_X_33',",
            "              b'11_X_23_X_31', b'11_X_23_X_32', b'11_X_23_X_33',",
            "              b'12_X_21_X_31', b'12_X_21_X_32', b'12_X_21_X_33',",
            "              b'12_X_22_X_31', b'12_X_22_X_32', b'12_X_22_X_33',",
            "              b'12_X_23_X_31', b'12_X_23_X_32', b'12_X_23_X_33',",
            "              b'13_X_21_X_31', b'13_X_21_X_32', b'13_X_21_X_33',",
            "              b'13_X_22_X_31', b'13_X_22_X_32', b'13_X_22_X_33',",
            "              b'13_X_23_X_31', b'13_X_23_X_32', b'13_X_23_X_33'",
            "          ]]),",
            "      dict(",
            "          testcase_name='BatchSizeZero',",
            "          inputs=[",
            "              ragged_const([], ragged_rank=1, dtype=dtypes.int32),",
            "              sparse_const([]),",
            "              np.zeros([0, 3], dtype=np.int32),",
            "          ],",
            "          expected=ragged_const([], ragged_rank=1, dtype=dtypes.int32)),",
            "      dict(",
            "          testcase_name='ThreeInputs_OneEmpty',",
            "          inputs=[",
            "              ragged_const([[1, 2]]),",
            "              ragged_const([[]], dtype=dtypes.int32),",
            "              ragged_const([[3, 4]])",
            "          ],",
            "          expected=ragged_const([[]], dtype=dtypes.string)),",
            "      dict(",
            "          testcase_name='ThreeInputs_AllEmpty',",
            "          inputs=[",
            "              ragged_const([[]], dtype=dtypes.int64),",
            "              ragged_const([[]], dtype=dtypes.string),",
            "              ragged_const([[]], dtype=dtypes.int32)",
            "          ],",
            "          expected=ragged_const([[]], ragged_rank=1, dtype=dtypes.string)),",
            "      dict(",
            "          testcase_name='HashedZeroBucketsDefaultKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          expected_hashed=ragged_const([[1971693436396284976]])),",
            "      dict(",
            "          testcase_name='Hashed100BucketsDefaultKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          num_buckets=100,",
            "          expected_hashed=ragged_const([[83]])),",
            "      dict(",
            "          testcase_name='HashedZeroBucketsCustomKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          hash_key=ragged_array_ops._DEFAULT_CROSS_HASH_KEY + 1,",
            "          expected_hashed=ragged_const([[4847552627144134031]])),",
            "      dict(",
            "          testcase_name='Hashed100BucketsCustomKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          num_buckets=100,",
            "          hash_key=ragged_array_ops._DEFAULT_CROSS_HASH_KEY + 1,",
            "          expected_hashed=ragged_const([[31]])),",
            "      dict(",
            "          testcase_name='HashedZeroKey',",
            "          inputs=[",
            "              ragged_const([['batch1-FC1-F1']]),",
            "              ragged_const([['batch1-FC2-F1']]),",
            "              ragged_const([['batch1-FC3-F1']])",
            "          ],",
            "          hash_key=0,",
            "          expected_hashed=ragged_const([[9077905385164735582]]),",
            "          matches_sparse_cross=False  # sparse treats hash_key=0 as None.",
            "      ),",
            "      dict(",
            "          testcase_name='UInt64',",
            "          inputs=[ragged_const([[2**64 - 1]], dtype=dtypes.uint64)],",
            "          expected=ragged_const([[b'-1']])),",
            "  ])",
            "  def testRaggedCross(self,",
            "                      inputs,",
            "                      num_buckets=0,",
            "                      hash_key=None,",
            "                      expected=None,",
            "                      expected_hashed=None,",
            "                      matches_sparse_cross=True):",
            "    ragged_cross = ragged_array_ops.cross(inputs)",
            "    ragged_cross_hashed = ragged_array_ops.cross_hashed(inputs, num_buckets,",
            "                                                        hash_key)",
            "",
            "    if expected is not None:",
            "      self.assertAllEqual(ragged_cross, expected)",
            "    if expected_hashed is not None:",
            "      self.assertAllEqual(ragged_cross_hashed, expected_hashed)",
            "",
            "    if matches_sparse_cross:",
            "      # Check that ragged.cross & sparse.cross match.",
            "      sparse_inputs = [self._ragged_to_sparse(t) for t in inputs]",
            "      sparse_cross = sparse_ops.sparse_cross(sparse_inputs)",
            "      self.assertAllEqual(ragged_cross,",
            "                          ragged_tensor.RaggedTensor.from_sparse(sparse_cross))",
            "",
            "      # Check that ragged.cross_hashed & sparse.cross_hashed match.",
            "      sparse_inputs = [self._ragged_to_sparse(t) for t in inputs]",
            "      sparse_cross_hashed = sparse_ops.sparse_cross_hashed(",
            "          sparse_inputs, num_buckets, hash_key)",
            "      self.assertAllEqual(",
            "          ragged_cross_hashed,",
            "          ragged_tensor.RaggedTensor.from_sparse(sparse_cross_hashed))",
            "",
            "  def testRaggedCrossLargeBatch(self):",
            "    batch_size = 5000",
            "    inputs = [",
            "        ragged_const([[1, 2, 3]] * batch_size),",
            "        ragged_const([[b'4']] * batch_size),",
            "        dense_const([[5]] * batch_size),",
            "        sparse_const([[6, 7]] * batch_size)",
            "    ]",
            "",
            "    expected = [[",
            "        b'1_X_4_X_5_X_6', b'1_X_4_X_5_X_7', b'2_X_4_X_5_X_6', b'2_X_4_X_5_X_7',",
            "        b'3_X_4_X_5_X_6', b'3_X_4_X_5_X_7'",
            "    ]] * batch_size",
            "",
            "    ragged_cross = ragged_array_ops.cross(inputs)",
            "",
            "    # Note: we don't use assertAllEqual here because if they don't match,",
            "    # then the code in assertAllEqual that tries to build the error message",
            "    # is very slow, causing the test to timeout.",
            "    # pylint: disable=g-generic-assert",
            "    self.assertTrue(self.evaluate(ragged_cross).to_list() == expected)",
            "",
            "  @parameterized.named_parameters([",
            "      dict(",
            "          testcase_name='BadDType',",
            "          inputs=[ragged_const([[1.1], [2.2, 3.3]])],",
            "          message=r'Unexpected dtype for inputs\\[0\\]'),",
            "      dict(",
            "          testcase_name='StaticBatchSizeMismatch1',",
            "          inputs=[ragged_const([[1]]),",
            "                  ragged_const([[2], [3]])],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='inputs must all have the same batch dimension size'),",
            "      dict(",
            "          testcase_name='StaticBatchSizeMismatch2',",
            "          inputs=[ragged_const([[1]]),",
            "                  dense_const([[2], [3]])],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='inputs must all have the same batch dimension size'),",
            "      dict(",
            "          testcase_name='3DDenseTensor',",
            "          inputs=[dense_const([[[1]]])],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "      dict(",
            "          testcase_name='0DDenseTensor',",
            "          inputs=[dense_const(1)],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "  ])",
            "  def testStaticError(self, inputs, exception=ValueError, message=None):",
            "    with self.assertRaisesRegex(exception, message):",
            "      ragged_array_ops.cross(inputs)",
            "",
            "  @parameterized.named_parameters([",
            "      dict(",
            "          testcase_name='3DRaggedTensor',",
            "          inputs=[ragged_const([[[1]]], ragged_rank=1)],",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "      dict(",
            "          testcase_name='0DDenseTensor',",
            "          inputs=[dense_const(1)],",
            "          signature=[[tensor_spec.TensorSpec(None, dtypes.int32)]],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "      dict(",
            "          testcase_name='1DDenseTensor',",
            "          inputs=[dense_const([1])],",
            "          signature=[[tensor_spec.TensorSpec(None, dtypes.int32)]],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "      dict(",
            "          testcase_name='3DDenseTensor',",
            "          inputs=[dense_const([[[1]]])],",
            "          signature=[[tensor_spec.TensorSpec(None, dtypes.int32)]],",
            "          exception=(ValueError, errors.InvalidArgumentError),",
            "          message='tf.ragged.cross only supports inputs with rank=2'),",
            "  ])",
            "  def testRuntimeError(self,",
            "                       inputs,",
            "                       exception=errors.InvalidArgumentError,",
            "                       message=None,",
            "                       signature=None):",
            "    @def_function.function(input_signature=signature)",
            "    def fn(x):",
            "      return ragged_array_ops.cross(x)",
            "",
            "    with self.assertRaisesRegex(exception, message):",
            "      self.evaluate(fn(inputs))",
            "",
            "  def _ragged_to_sparse(self, t):",
            "    if ragged_tensor.is_ragged(t):",
            "      return ragged_tensor.convert_to_tensor_or_ragged_tensor(t).to_sparse()",
            "    elif sparse_tensor.is_sparse(t):",
            "      return sparse_tensor.SparseTensor.from_value(t)",
            "    else:",
            "      return ops.convert_to_tensor(t)",
            "",
            "",
            "if __name__ == '__main__':",
            "  googletest.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "379": [
                "RaggedCrossOpTest",
                "testRuntimeError"
            ],
            "381": [
                "RaggedCrossOpTest",
                "testRuntimeError"
            ]
        },
        "addLocation": [
            "tensorflow.python.ops.ragged.ragged_cross_op_test.RaggedCrossOpTest.self",
            "tensorflow.python.ops.ragged.ragged_cross_op_test.sparse_const.matrix"
        ]
    }
}