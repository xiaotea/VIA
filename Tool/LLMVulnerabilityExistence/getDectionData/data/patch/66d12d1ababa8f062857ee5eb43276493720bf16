{
    "django/contrib/sessions/backends/cache.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "             session_data = None"
            },
            "1": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         if session_data is not None:"
            },
            "2": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             return session_data"
            },
            "3": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         return {}"
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     def create(self):"
            },
            "8": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             \"It is likely that the cache is unavailable.\")"
            },
            "9": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "     def save(self, must_create=False):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        if self.session_key is None:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            return self.create()"
            },
            "13": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         if must_create:"
            },
            "14": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "             func = self._cache.add"
            },
            "15": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         else:"
            },
            "16": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             raise CreateError"
            },
            "17": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def exists(self, session_key):"
            },
            "19": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return (KEY_PREFIX + session_key) in self._cache"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        return session_key and (KEY_PREFIX + session_key) in self._cache"
            },
            "21": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     def delete(self, session_key=None):"
            },
            "23": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         if session_key is None:"
            }
        },
        "frontPatchFile": [
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import CreateError, SessionBase",
            "from django.core.cache import caches",
            "from django.utils.six.moves import range",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cache\"",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    A cache-based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            session_data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            session_data = None",
            "        if session_data is not None:",
            "            return session_data",
            "        self.create()",
            "        return {}",
            "",
            "    def create(self):",
            "        # Because a cache can fail silently (e.g. memcache), we don't know if",
            "        # we are failing to create a new session because of a key collision or",
            "        # because the cache is missing. So we try for a (large) number of times",
            "        # and then raise an exception. That's the risk you shoulder if using",
            "        # cache backing.",
            "        for i in range(10000):",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            return",
            "        raise RuntimeError(",
            "            \"Unable to create a new session key. \"",
            "            \"It is likely that the cache is unavailable.\")",
            "",
            "    def save(self, must_create=False):",
            "        if must_create:",
            "            func = self._cache.add",
            "        else:",
            "            func = self._cache.set",
            "        result = func(self.cache_key,",
            "                      self._get_session(no_load=must_create),",
            "                      self.get_expiry_age())",
            "        if must_create and not result:",
            "            raise CreateError",
            "",
            "    def exists(self, session_key):",
            "        return (KEY_PREFIX + session_key) in self._cache",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        pass"
        ],
        "afterPatchFile": [
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import CreateError, SessionBase",
            "from django.core.cache import caches",
            "from django.utils.six.moves import range",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cache\"",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    A cache-based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            session_data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            session_data = None",
            "        if session_data is not None:",
            "            return session_data",
            "        self._session_key = None",
            "        return {}",
            "",
            "    def create(self):",
            "        # Because a cache can fail silently (e.g. memcache), we don't know if",
            "        # we are failing to create a new session because of a key collision or",
            "        # because the cache is missing. So we try for a (large) number of times",
            "        # and then raise an exception. That's the risk you shoulder if using",
            "        # cache backing.",
            "        for i in range(10000):",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            return",
            "        raise RuntimeError(",
            "            \"Unable to create a new session key. \"",
            "            \"It is likely that the cache is unavailable.\")",
            "",
            "    def save(self, must_create=False):",
            "        if self.session_key is None:",
            "            return self.create()",
            "        if must_create:",
            "            func = self._cache.add",
            "        else:",
            "            func = self._cache.set",
            "        result = func(self.cache_key,",
            "                      self._get_session(no_load=must_create),",
            "                      self.get_expiry_age())",
            "        if must_create and not result:",
            "            raise CreateError",
            "",
            "    def exists(self, session_key):",
            "        return session_key and (KEY_PREFIX + session_key) in self._cache",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "30": [
                "SessionStore",
                "load"
            ],
            "63": [
                "SessionStore",
                "exists"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/backends/cached_db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                     logger = logging.getLogger('django.security.%s' %"
            },
            "1": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "                             e.__class__.__name__)"
            },
            "2": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "                     logger.warning(force_text(e))"
            },
            "3": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+                self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "                 data = {}"
            },
            "6": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         return data"
            },
            "7": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     def exists(self, session_key):"
            },
            "9": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if (KEY_PREFIX + session_key) in self._cache:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        if session_key and (KEY_PREFIX + session_key) in self._cache:"
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "             return True"
            },
            "12": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         return super(SessionStore, self).exists(session_key)"
            },
            "13": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "import logging",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import caches",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "",
            "        if data is None:",
            "            # Duplicate DBStore.load, because we need to keep track",
            "            # of the expiry date to set it properly in the cache.",
            "            try:",
            "                s = Session.objects.get(",
            "                    session_key=self.session_key,",
            "                    expire_date__gt=timezone.now()",
            "                )",
            "                data = self.decode(s.session_data)",
            "                self._cache.set(self.cache_key, data,",
            "                    self.get_expiry_age(expiry=s.expire_date))",
            "            except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "                if isinstance(e, SuspiciousOperation):",
            "                    logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "                    logger.warning(force_text(e))",
            "                self.create()",
            "                data = {}",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if (KEY_PREFIX + session_key) in self._cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        self._cache.set(self.cache_key, self._session, self.get_expiry_age())",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self._session_key = None",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session  # isort:skip"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Cached, database-backed sessions.",
            "\"\"\"",
            "",
            "import logging",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.db import SessionStore as DBStore",
            "from django.core.cache import caches",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "KEY_PREFIX = \"django.contrib.sessions.cached_db\"",
            "",
            "",
            "class SessionStore(DBStore):",
            "    \"\"\"",
            "    Implements cached, database backed sessions.",
            "    \"\"\"",
            "",
            "    def __init__(self, session_key=None):",
            "        self._cache = caches[settings.SESSION_CACHE_ALIAS]",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @property",
            "    def cache_key(self):",
            "        return KEY_PREFIX + self._get_or_create_session_key()",
            "",
            "    def load(self):",
            "        try:",
            "            data = self._cache.get(self.cache_key, None)",
            "        except Exception:",
            "            # Some backends (e.g. memcache) raise an exception on invalid",
            "            # cache keys. If this happens, reset the session. See #17810.",
            "            data = None",
            "",
            "        if data is None:",
            "            # Duplicate DBStore.load, because we need to keep track",
            "            # of the expiry date to set it properly in the cache.",
            "            try:",
            "                s = Session.objects.get(",
            "                    session_key=self.session_key,",
            "                    expire_date__gt=timezone.now()",
            "                )",
            "                data = self.decode(s.session_data)",
            "                self._cache.set(self.cache_key, data,",
            "                    self.get_expiry_age(expiry=s.expire_date))",
            "            except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "                if isinstance(e, SuspiciousOperation):",
            "                    logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "                    logger.warning(force_text(e))",
            "                self._session_key = None",
            "                data = {}",
            "        return data",
            "",
            "    def exists(self, session_key):",
            "        if session_key and (KEY_PREFIX + session_key) in self._cache:",
            "            return True",
            "        return super(SessionStore, self).exists(session_key)",
            "",
            "    def save(self, must_create=False):",
            "        super(SessionStore, self).save(must_create)",
            "        self._cache.set(self.cache_key, self._session, self.get_expiry_age())",
            "",
            "    def delete(self, session_key=None):",
            "        super(SessionStore, self).delete(session_key)",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        self._cache.delete(KEY_PREFIX + session_key)",
            "",
            "    def flush(self):",
            "        \"\"\"",
            "        Removes the current session data from the database and regenerates the",
            "        key.",
            "        \"\"\"",
            "        self.clear()",
            "        self.delete(self.session_key)",
            "        self._session_key = None",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session  # isort:skip"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "54": [
                "SessionStore",
                "load"
            ],
            "59": [
                "SessionStore",
                "exists"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/backends/db.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "                 logger = logging.getLogger('django.security.%s' %"
            },
            "1": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "                         e.__class__.__name__)"
            },
            "2": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "                 logger.warning(force_text(e))"
            },
            "3": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+            self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "             return {}"
            },
            "6": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     def exists(self, session_key):"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "                 # Key wasn't unique. Try again."
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "                 continue"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             self.modified = True"
            },
            "11": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._session_cache = {}"
            },
            "12": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "             return"
            },
            "13": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     def save(self, must_create=False):"
            },
            "15": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         create a *new* entry (as opposed to possibly updating an existing"
            },
            "16": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "         entry)."
            },
            "17": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         \"\"\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        if self.session_key is None:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            return self.create()"
            },
            "20": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         obj = Session("
            },
            "21": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "             session_key=self._get_or_create_session_key(),"
            },
            "22": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             session_data=self.encode(self._get_session(no_load=must_create)),"
            }
        },
        "frontPatchFile": [
            "import logging",
            "",
            "from django.contrib.sessions.backends.base import CreateError, SessionBase",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.db import IntegrityError, router, transaction",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements database session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    def load(self):",
            "        try:",
            "            s = Session.objects.get(",
            "                session_key=self.session_key,",
            "                expire_date__gt=timezone.now()",
            "            )",
            "            return self.decode(s.session_data)",
            "        except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "            if isinstance(e, SuspiciousOperation):",
            "                logger = logging.getLogger('django.security.%s' %",
            "                        e.__class__.__name__)",
            "                logger.warning(force_text(e))",
            "            self.create()",
            "            return {}",
            "",
            "    def exists(self, session_key):",
            "        return Session.objects.filter(session_key=session_key).exists()",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                # Save immediately to ensure we have a unique entry in the",
            "                # database.",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                # Key wasn't unique. Try again.",
            "                continue",
            "            self.modified = True",
            "            self._session_cache = {}",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the current session data to the database. If 'must_create' is",
            "        True, a database error will be raised if the saving operation doesn't",
            "        create a *new* entry (as opposed to possibly updating an existing",
            "        entry).",
            "        \"\"\"",
            "        obj = Session(",
            "            session_key=self._get_or_create_session_key(),",
            "            session_data=self.encode(self._get_session(no_load=must_create)),",
            "            expire_date=self.get_expiry_date()",
            "        )",
            "        using = router.db_for_write(Session, instance=obj)",
            "        try:",
            "            with transaction.atomic(using=using):",
            "                obj.save(force_insert=must_create, using=using)",
            "        except IntegrityError:",
            "            if must_create:",
            "                raise CreateError",
            "            raise",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            Session.objects.get(session_key=session_key).delete()",
            "        except Session.DoesNotExist:",
            "            pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        Session.objects.filter(expire_date__lt=timezone.now()).delete()",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session  # isort:skip"
        ],
        "afterPatchFile": [
            "import logging",
            "",
            "from django.contrib.sessions.backends.base import CreateError, SessionBase",
            "from django.core.exceptions import SuspiciousOperation",
            "from django.db import IntegrityError, router, transaction",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements database session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    def load(self):",
            "        try:",
            "            s = Session.objects.get(",
            "                session_key=self.session_key,",
            "                expire_date__gt=timezone.now()",
            "            )",
            "            return self.decode(s.session_data)",
            "        except (Session.DoesNotExist, SuspiciousOperation) as e:",
            "            if isinstance(e, SuspiciousOperation):",
            "                logger = logging.getLogger('django.security.%s' %",
            "                        e.__class__.__name__)",
            "                logger.warning(force_text(e))",
            "            self._session_key = None",
            "            return {}",
            "",
            "    def exists(self, session_key):",
            "        return Session.objects.filter(session_key=session_key).exists()",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                # Save immediately to ensure we have a unique entry in the",
            "                # database.",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                # Key wasn't unique. Try again.",
            "                continue",
            "            self.modified = True",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        \"\"\"",
            "        Saves the current session data to the database. If 'must_create' is",
            "        True, a database error will be raised if the saving operation doesn't",
            "        create a *new* entry (as opposed to possibly updating an existing",
            "        entry).",
            "        \"\"\"",
            "        if self.session_key is None:",
            "            return self.create()",
            "        obj = Session(",
            "            session_key=self._get_or_create_session_key(),",
            "            session_data=self.encode(self._get_session(no_load=must_create)),",
            "            expire_date=self.get_expiry_date()",
            "        )",
            "        using = router.db_for_write(Session, instance=obj)",
            "        try:",
            "            with transaction.atomic(using=using):",
            "                obj.save(force_insert=must_create, using=using)",
            "        except IntegrityError:",
            "            if must_create:",
            "                raise CreateError",
            "            raise",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            Session.objects.get(session_key=session_key).delete()",
            "        except Session.DoesNotExist:",
            "            pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        Session.objects.filter(expire_date__lt=timezone.now()).delete()",
            "",
            "# At bottom to avoid circular import",
            "from django.contrib.sessions.models import Session  # isort:skip"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "29": [
                "SessionStore",
                "load"
            ],
            "46": [
                "SessionStore",
                "create"
            ]
        },
        "addLocation": []
    },
    "django/contrib/sessions/backends/file.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "                     self.delete()"
            },
            "1": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "                     self.create()"
            },
            "2": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         except (IOError, SuspiciousOperation):"
            },
            "3": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.create()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            self._session_key = None"
            },
            "5": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         return session_data"
            },
            "6": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     def create(self):"
            },
            "8": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "             except CreateError:"
            },
            "9": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "                 continue"
            },
            "10": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             self.modified = True"
            },
            "11": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._session_cache = {}"
            },
            "12": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             return"
            },
            "13": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "     def save(self, must_create=False):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        if self.session_key is None:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+            return self.create()"
            },
            "17": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         # Get the session data now, before we start messing"
            },
            "18": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         # with the file it is stored within."
            },
            "19": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         session_data = self._get_session(no_load=must_create)"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "import errno",
            "import logging",
            "import os",
            "import shutil",
            "import tempfile",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import (",
            "    VALID_KEY_CHARS, CreateError, SessionBase,",
            ")",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements a file based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self.storage_path = type(self)._get_storage_path()",
            "        self.file_prefix = settings.SESSION_COOKIE_NAME",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @classmethod",
            "    def _get_storage_path(cls):",
            "        try:",
            "            return cls._storage_path",
            "        except AttributeError:",
            "            storage_path = getattr(settings, \"SESSION_FILE_PATH\", None)",
            "            if not storage_path:",
            "                storage_path = tempfile.gettempdir()",
            "",
            "            # Make sure the storage path is valid.",
            "            if not os.path.isdir(storage_path):",
            "                raise ImproperlyConfigured(",
            "                    \"The session storage path %r doesn't exist. Please set your\"",
            "                    \" SESSION_FILE_PATH setting to an existing directory in which\"",
            "                    \" Django can store session data.\" % storage_path)",
            "",
            "            cls._storage_path = storage_path",
            "            return storage_path",
            "",
            "    def _key_to_file(self, session_key=None):",
            "        \"\"\"",
            "        Get the file associated with this session key.",
            "        \"\"\"",
            "        if session_key is None:",
            "            session_key = self._get_or_create_session_key()",
            "",
            "        # Make sure we're not vulnerable to directory traversal. Session keys",
            "        # should always be md5s, so they should never contain directory",
            "        # components.",
            "        if not set(session_key).issubset(set(VALID_KEY_CHARS)):",
            "            raise InvalidSessionKey(",
            "                \"Invalid characters in session key\")",
            "",
            "        return os.path.join(self.storage_path, self.file_prefix + session_key)",
            "",
            "    def _last_modification(self):",
            "        \"\"\"",
            "        Return the modification time of the file storing the session's content.",
            "        \"\"\"",
            "        modification = os.stat(self._key_to_file()).st_mtime",
            "        if settings.USE_TZ:",
            "            modification = datetime.datetime.utcfromtimestamp(modification)",
            "            modification = modification.replace(tzinfo=timezone.utc)",
            "        else:",
            "            modification = datetime.datetime.fromtimestamp(modification)",
            "        return modification",
            "",
            "    def load(self):",
            "        session_data = {}",
            "        try:",
            "            with open(self._key_to_file(), \"rb\") as session_file:",
            "                file_data = session_file.read()",
            "            # Don't fail if there is no data in the session file.",
            "            # We may have opened the empty placeholder file.",
            "            if file_data:",
            "                try:",
            "                    session_data = self.decode(file_data)",
            "                except (EOFError, SuspiciousOperation) as e:",
            "                    if isinstance(e, SuspiciousOperation):",
            "                        logger = logging.getLogger('django.security.%s' %",
            "                                e.__class__.__name__)",
            "                        logger.warning(force_text(e))",
            "                    self.create()",
            "",
            "                # Remove expired sessions.",
            "                expiry_age = self.get_expiry_age(",
            "                    modification=self._last_modification(),",
            "                    expiry=session_data.get('_session_expiry'))",
            "                if expiry_age < 0:",
            "                    session_data = {}",
            "                    self.delete()",
            "                    self.create()",
            "        except (IOError, SuspiciousOperation):",
            "            self.create()",
            "        return session_data",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            self._session_cache = {}",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        # Get the session data now, before we start messing",
            "        # with the file it is stored within.",
            "        session_data = self._get_session(no_load=must_create)",
            "",
            "        session_file_name = self._key_to_file()",
            "",
            "        try:",
            "            # Make sure the file exists.  If it does not already exist, an",
            "            # empty placeholder file is created.",
            "            flags = os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0)",
            "            if must_create:",
            "                flags |= os.O_EXCL",
            "            fd = os.open(session_file_name, flags)",
            "            os.close(fd)",
            "",
            "        except OSError as e:",
            "            if must_create and e.errno == errno.EEXIST:",
            "                raise CreateError",
            "            raise",
            "",
            "        # Write the session file without interfering with other threads",
            "        # or processes.  By writing to an atomically generated temporary",
            "        # file and then using the atomic os.rename() to make the complete",
            "        # file visible, we avoid having to lock the session file, while",
            "        # still maintaining its integrity.",
            "        #",
            "        # Note: Locking the session file was explored, but rejected in part",
            "        # because in order to be atomic and cross-platform, it required a",
            "        # long-lived lock file for each session, doubling the number of",
            "        # files in the session storage directory at any given time.  This",
            "        # rename solution is cleaner and avoids any additional overhead",
            "        # when reading the session data, which is the more common case",
            "        # unless SESSION_SAVE_EVERY_REQUEST = True.",
            "        #",
            "        # See ticket #8616.",
            "        dir, prefix = os.path.split(session_file_name)",
            "",
            "        try:",
            "            output_file_fd, output_file_name = tempfile.mkstemp(dir=dir,",
            "                prefix=prefix + '_out_')",
            "            renamed = False",
            "            try:",
            "                try:",
            "                    os.write(output_file_fd, self.encode(session_data).encode())",
            "                finally:",
            "                    os.close(output_file_fd)",
            "",
            "                # This will atomically rename the file (os.rename) if the OS",
            "                # supports it. Otherwise this will result in a shutil.copy2",
            "                # and os.unlink (for example on Windows). See #9084.",
            "                shutil.move(output_file_name, session_file_name)",
            "                renamed = True",
            "            finally:",
            "                if not renamed:",
            "                    os.unlink(output_file_name)",
            "",
            "        except (OSError, IOError, EOFError):",
            "            pass",
            "",
            "    def exists(self, session_key):",
            "        return os.path.exists(self._key_to_file(session_key))",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            os.unlink(self._key_to_file(session_key))",
            "        except OSError:",
            "            pass",
            "",
            "    def clean(self):",
            "        pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        storage_path = cls._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        for session_file in os.listdir(storage_path):",
            "            if not session_file.startswith(file_prefix):",
            "                continue",
            "            session_key = session_file[len(file_prefix):]",
            "            session = cls(session_key)",
            "            # When an expired session is loaded, its file is removed, and a",
            "            # new file is immediately created. Prevent this by disabling",
            "            # the create() method.",
            "            session.create = lambda: None",
            "            session.load()"
        ],
        "afterPatchFile": [
            "import datetime",
            "import errno",
            "import logging",
            "import os",
            "import shutil",
            "import tempfile",
            "",
            "from django.conf import settings",
            "from django.contrib.sessions.backends.base import (",
            "    VALID_KEY_CHARS, CreateError, SessionBase,",
            ")",
            "from django.contrib.sessions.exceptions import InvalidSessionKey",
            "from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation",
            "from django.utils import timezone",
            "from django.utils.encoding import force_text",
            "",
            "",
            "class SessionStore(SessionBase):",
            "    \"\"\"",
            "    Implements a file based session store.",
            "    \"\"\"",
            "    def __init__(self, session_key=None):",
            "        self.storage_path = type(self)._get_storage_path()",
            "        self.file_prefix = settings.SESSION_COOKIE_NAME",
            "        super(SessionStore, self).__init__(session_key)",
            "",
            "    @classmethod",
            "    def _get_storage_path(cls):",
            "        try:",
            "            return cls._storage_path",
            "        except AttributeError:",
            "            storage_path = getattr(settings, \"SESSION_FILE_PATH\", None)",
            "            if not storage_path:",
            "                storage_path = tempfile.gettempdir()",
            "",
            "            # Make sure the storage path is valid.",
            "            if not os.path.isdir(storage_path):",
            "                raise ImproperlyConfigured(",
            "                    \"The session storage path %r doesn't exist. Please set your\"",
            "                    \" SESSION_FILE_PATH setting to an existing directory in which\"",
            "                    \" Django can store session data.\" % storage_path)",
            "",
            "            cls._storage_path = storage_path",
            "            return storage_path",
            "",
            "    def _key_to_file(self, session_key=None):",
            "        \"\"\"",
            "        Get the file associated with this session key.",
            "        \"\"\"",
            "        if session_key is None:",
            "            session_key = self._get_or_create_session_key()",
            "",
            "        # Make sure we're not vulnerable to directory traversal. Session keys",
            "        # should always be md5s, so they should never contain directory",
            "        # components.",
            "        if not set(session_key).issubset(set(VALID_KEY_CHARS)):",
            "            raise InvalidSessionKey(",
            "                \"Invalid characters in session key\")",
            "",
            "        return os.path.join(self.storage_path, self.file_prefix + session_key)",
            "",
            "    def _last_modification(self):",
            "        \"\"\"",
            "        Return the modification time of the file storing the session's content.",
            "        \"\"\"",
            "        modification = os.stat(self._key_to_file()).st_mtime",
            "        if settings.USE_TZ:",
            "            modification = datetime.datetime.utcfromtimestamp(modification)",
            "            modification = modification.replace(tzinfo=timezone.utc)",
            "        else:",
            "            modification = datetime.datetime.fromtimestamp(modification)",
            "        return modification",
            "",
            "    def load(self):",
            "        session_data = {}",
            "        try:",
            "            with open(self._key_to_file(), \"rb\") as session_file:",
            "                file_data = session_file.read()",
            "            # Don't fail if there is no data in the session file.",
            "            # We may have opened the empty placeholder file.",
            "            if file_data:",
            "                try:",
            "                    session_data = self.decode(file_data)",
            "                except (EOFError, SuspiciousOperation) as e:",
            "                    if isinstance(e, SuspiciousOperation):",
            "                        logger = logging.getLogger('django.security.%s' %",
            "                                e.__class__.__name__)",
            "                        logger.warning(force_text(e))",
            "                    self.create()",
            "",
            "                # Remove expired sessions.",
            "                expiry_age = self.get_expiry_age(",
            "                    modification=self._last_modification(),",
            "                    expiry=session_data.get('_session_expiry'))",
            "                if expiry_age < 0:",
            "                    session_data = {}",
            "                    self.delete()",
            "                    self.create()",
            "        except (IOError, SuspiciousOperation):",
            "            self._session_key = None",
            "        return session_data",
            "",
            "    def create(self):",
            "        while True:",
            "            self._session_key = self._get_new_session_key()",
            "            try:",
            "                self.save(must_create=True)",
            "            except CreateError:",
            "                continue",
            "            self.modified = True",
            "            return",
            "",
            "    def save(self, must_create=False):",
            "        if self.session_key is None:",
            "            return self.create()",
            "        # Get the session data now, before we start messing",
            "        # with the file it is stored within.",
            "        session_data = self._get_session(no_load=must_create)",
            "",
            "        session_file_name = self._key_to_file()",
            "",
            "        try:",
            "            # Make sure the file exists.  If it does not already exist, an",
            "            # empty placeholder file is created.",
            "            flags = os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0)",
            "            if must_create:",
            "                flags |= os.O_EXCL",
            "            fd = os.open(session_file_name, flags)",
            "            os.close(fd)",
            "",
            "        except OSError as e:",
            "            if must_create and e.errno == errno.EEXIST:",
            "                raise CreateError",
            "            raise",
            "",
            "        # Write the session file without interfering with other threads",
            "        # or processes.  By writing to an atomically generated temporary",
            "        # file and then using the atomic os.rename() to make the complete",
            "        # file visible, we avoid having to lock the session file, while",
            "        # still maintaining its integrity.",
            "        #",
            "        # Note: Locking the session file was explored, but rejected in part",
            "        # because in order to be atomic and cross-platform, it required a",
            "        # long-lived lock file for each session, doubling the number of",
            "        # files in the session storage directory at any given time.  This",
            "        # rename solution is cleaner and avoids any additional overhead",
            "        # when reading the session data, which is the more common case",
            "        # unless SESSION_SAVE_EVERY_REQUEST = True.",
            "        #",
            "        # See ticket #8616.",
            "        dir, prefix = os.path.split(session_file_name)",
            "",
            "        try:",
            "            output_file_fd, output_file_name = tempfile.mkstemp(dir=dir,",
            "                prefix=prefix + '_out_')",
            "            renamed = False",
            "            try:",
            "                try:",
            "                    os.write(output_file_fd, self.encode(session_data).encode())",
            "                finally:",
            "                    os.close(output_file_fd)",
            "",
            "                # This will atomically rename the file (os.rename) if the OS",
            "                # supports it. Otherwise this will result in a shutil.copy2",
            "                # and os.unlink (for example on Windows). See #9084.",
            "                shutil.move(output_file_name, session_file_name)",
            "                renamed = True",
            "            finally:",
            "                if not renamed:",
            "                    os.unlink(output_file_name)",
            "",
            "        except (OSError, IOError, EOFError):",
            "            pass",
            "",
            "    def exists(self, session_key):",
            "        return os.path.exists(self._key_to_file(session_key))",
            "",
            "    def delete(self, session_key=None):",
            "        if session_key is None:",
            "            if self.session_key is None:",
            "                return",
            "            session_key = self.session_key",
            "        try:",
            "            os.unlink(self._key_to_file(session_key))",
            "        except OSError:",
            "            pass",
            "",
            "    def clean(self):",
            "        pass",
            "",
            "    @classmethod",
            "    def clear_expired(cls):",
            "        storage_path = cls._get_storage_path()",
            "        file_prefix = settings.SESSION_COOKIE_NAME",
            "",
            "        for session_file in os.listdir(storage_path):",
            "            if not session_file.startswith(file_prefix):",
            "                continue",
            "            session_key = session_file[len(file_prefix):]",
            "            session = cls(session_key)",
            "            # When an expired session is loaded, its file is removed, and a",
            "            # new file is immediately created. Prevent this by disabling",
            "            # the create() method.",
            "            session.create = lambda: None",
            "            session.load()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "100": [
                "SessionStore",
                "load"
            ],
            "111": [
                "SessionStore",
                "create"
            ]
        },
        "addLocation": []
    }
}