{
    "pygments/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     except TypeError as err:"
            },
            "1": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         if isinstance(err.args[0], str) and \\"
            },
            "2": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "            ('unbound method get_tokens' in err.args[0] or"
            },
            "3": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'missing 1 required positional argument' in err.args[0]):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            'missing 1 required positional argument' in err.args[0]):"
            },
            "5": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "             raise TypeError('lex() argument must be a lexer instance, '"
            },
            "6": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                             'not a class')"
            },
            "7": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "         raise"
            },
            "8": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def format(tokens, formatter, outfile=None):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+def format(tokens, formatter, outfile=None):  # pylint: disable=redefined-builtin"
            },
            "12": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     Format a tokenlist ``tokens`` with the formatter ``formatter``."
            },
            "14": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     except TypeError as err:"
            },
            "16": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         if isinstance(err.args[0], str) and \\"
            },
            "17": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "            ('unbound method format' in err.args[0] or"
            },
            "18": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'missing 1 required positional argument' in err.args[0]):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            'missing 1 required positional argument' in err.args[0]):"
            },
            "20": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             raise TypeError('format() argument must be a formatter instance, '"
            },
            "21": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "                             'not a class')"
            },
            "22": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         raise"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    Pygments",
            "    ~~~~~~~~",
            "",
            "    Pygments is a syntax highlighting package written in Python.",
            "",
            "    It is a generic syntax highlighter for general use in all kinds of software",
            "    such as forum systems, wikis or other applications that need to prettify",
            "    source code. Highlights are:",
            "",
            "    * a wide range of common languages and markup formats is supported",
            "    * special attention is paid to details, increasing quality by a fair amount",
            "    * support for new languages and formats are added easily",
            "    * a number of output formats, presently HTML, LaTeX, RTF, SVG, all image",
            "      formats that PIL supports, and ANSI sequences",
            "    * it is usable as a command-line tool and as a library",
            "    * ... and it highlights even Brainfuck!",
            "",
            "    The `Pygments tip`_ is installable with ``easy_install Pygments==dev``.",
            "",
            "    .. _Pygments tip:",
            "       http://bitbucket.org/birkenfeld/pygments-main/get/tip.zip#egg=Pygments-dev",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "__version__ = '2.1a0'",
            "__docformat__ = 'restructuredtext'",
            "",
            "__all__ = ['lex', 'format', 'highlight']",
            "",
            "",
            "import sys",
            "",
            "from pygments.util import StringIO, BytesIO",
            "",
            "",
            "def lex(code, lexer):",
            "    \"\"\"",
            "    Lex ``code`` with ``lexer`` and return an iterable of tokens.",
            "    \"\"\"",
            "    try:",
            "        return lexer.get_tokens(code)",
            "    except TypeError as err:",
            "        if isinstance(err.args[0], str) and \\",
            "           ('unbound method get_tokens' in err.args[0] or",
            "                'missing 1 required positional argument' in err.args[0]):",
            "            raise TypeError('lex() argument must be a lexer instance, '",
            "                            'not a class')",
            "        raise",
            "",
            "",
            "def format(tokens, formatter, outfile=None):",
            "    \"\"\"",
            "    Format a tokenlist ``tokens`` with the formatter ``formatter``.",
            "",
            "    If ``outfile`` is given and a valid file object (an object",
            "    with a ``write`` method), the result will be written to it, otherwise",
            "    it is returned as a string.",
            "    \"\"\"",
            "    try:",
            "        if not outfile:",
            "            realoutfile = getattr(formatter, 'encoding', None) and BytesIO() or StringIO()",
            "            formatter.format(tokens, realoutfile)",
            "            return realoutfile.getvalue()",
            "        else:",
            "            formatter.format(tokens, outfile)",
            "    except TypeError as err:",
            "        if isinstance(err.args[0], str) and \\",
            "           ('unbound method format' in err.args[0] or",
            "                'missing 1 required positional argument' in err.args[0]):",
            "            raise TypeError('format() argument must be a formatter instance, '",
            "                            'not a class')",
            "        raise",
            "",
            "",
            "def highlight(code, lexer, formatter, outfile=None):",
            "    \"\"\"",
            "    Lex ``code`` with ``lexer`` and format it with the formatter ``formatter``.",
            "",
            "    If ``outfile`` is given and a valid file object (an object",
            "    with a ``write`` method), the result will be written to it, otherwise",
            "    it is returned as a string.",
            "    \"\"\"",
            "    return format(lex(code, lexer), formatter, outfile)",
            "",
            "",
            "if __name__ == '__main__':  # pragma: no cover",
            "    from pygments.cmdline import main",
            "    sys.exit(main(sys.argv))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    Pygments",
            "    ~~~~~~~~",
            "",
            "    Pygments is a syntax highlighting package written in Python.",
            "",
            "    It is a generic syntax highlighter for general use in all kinds of software",
            "    such as forum systems, wikis or other applications that need to prettify",
            "    source code. Highlights are:",
            "",
            "    * a wide range of common languages and markup formats is supported",
            "    * special attention is paid to details, increasing quality by a fair amount",
            "    * support for new languages and formats are added easily",
            "    * a number of output formats, presently HTML, LaTeX, RTF, SVG, all image",
            "      formats that PIL supports, and ANSI sequences",
            "    * it is usable as a command-line tool and as a library",
            "    * ... and it highlights even Brainfuck!",
            "",
            "    The `Pygments tip`_ is installable with ``easy_install Pygments==dev``.",
            "",
            "    .. _Pygments tip:",
            "       http://bitbucket.org/birkenfeld/pygments-main/get/tip.zip#egg=Pygments-dev",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "__version__ = '2.1a0'",
            "__docformat__ = 'restructuredtext'",
            "",
            "__all__ = ['lex', 'format', 'highlight']",
            "",
            "",
            "import sys",
            "",
            "from pygments.util import StringIO, BytesIO",
            "",
            "",
            "def lex(code, lexer):",
            "    \"\"\"",
            "    Lex ``code`` with ``lexer`` and return an iterable of tokens.",
            "    \"\"\"",
            "    try:",
            "        return lexer.get_tokens(code)",
            "    except TypeError as err:",
            "        if isinstance(err.args[0], str) and \\",
            "           ('unbound method get_tokens' in err.args[0] or",
            "            'missing 1 required positional argument' in err.args[0]):",
            "            raise TypeError('lex() argument must be a lexer instance, '",
            "                            'not a class')",
            "        raise",
            "",
            "",
            "def format(tokens, formatter, outfile=None):  # pylint: disable=redefined-builtin",
            "    \"\"\"",
            "    Format a tokenlist ``tokens`` with the formatter ``formatter``.",
            "",
            "    If ``outfile`` is given and a valid file object (an object",
            "    with a ``write`` method), the result will be written to it, otherwise",
            "    it is returned as a string.",
            "    \"\"\"",
            "    try:",
            "        if not outfile:",
            "            realoutfile = getattr(formatter, 'encoding', None) and BytesIO() or StringIO()",
            "            formatter.format(tokens, realoutfile)",
            "            return realoutfile.getvalue()",
            "        else:",
            "            formatter.format(tokens, outfile)",
            "    except TypeError as err:",
            "        if isinstance(err.args[0], str) and \\",
            "           ('unbound method format' in err.args[0] or",
            "            'missing 1 required positional argument' in err.args[0]):",
            "            raise TypeError('format() argument must be a formatter instance, '",
            "                            'not a class')",
            "        raise",
            "",
            "",
            "def highlight(code, lexer, formatter, outfile=None):",
            "    \"\"\"",
            "    Lex ``code`` with ``lexer`` and format it with the formatter ``formatter``.",
            "",
            "    If ``outfile`` is given and a valid file object (an object",
            "    with a ``write`` method), the result will be written to it, otherwise",
            "    it is returned as a string.",
            "    \"\"\"",
            "    return format(lex(code, lexer), formatter, outfile)",
            "",
            "",
            "if __name__ == '__main__':  # pragma: no cover",
            "    from pygments.cmdline import main",
            "    sys.exit(main(sys.argv))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "49": [
                "lex"
            ],
            "55": [
                "format"
            ],
            "73": [
                "format"
            ]
        },
        "addLocation": []
    },
    "pygments/cmdline.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from pygments.util import ClassNotFound, OptionError, docstring_headline, \\"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     guess_decode, guess_decode_from_terminal, terminal_encoding"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \\"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    get_lexer_for_filename, find_lexer_class_for_filename, TextLexer"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    get_lexer_for_filename, find_lexer_class_for_filename"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from pygments.lexers.special import TextLexer"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from pygments.formatters import get_all_formatters, get_formatter_by_name, \\"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    get_formatter_for_filename, find_formatter_class, \\"
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    TerminalFormatter  # pylint:disable-msg=E0611"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    get_formatter_for_filename, find_formatter_class"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from pygments.formatters.terminal import TerminalFormatter"
            },
            "12": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from pygments.filters import get_all_filters, find_filter_class"
            },
            "13": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from pygments.styles import get_all_styles, get_style_by_name"
            },
            "14": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             print(usage, file=sys.stderr)"
            },
            "16": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "             return 2"
            },
            "17": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 250,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        what, name = args"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        what, name = args  # pylint: disable=unbalanced-tuple-unpacking"
            },
            "20": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         if what not in ('lexer', 'formatter', 'filter'):"
            },
            "21": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "             print(usage, file=sys.stderr)"
            },
            "22": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             return 2"
            },
            "23": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "     opts.pop('-P', None)"
            },
            "24": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 271,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "     # encodings"
            },
            "26": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    inencoding  = parsed_opts.get('inencoding', parsed_opts.get('encoding'))"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    inencoding = parsed_opts.get('inencoding', parsed_opts.get('encoding'))"
            },
            "28": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "     outencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))"
            },
            "29": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 275,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     # handle ``pygmentize -N``"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.cmdline",
            "    ~~~~~~~~~~~~~~~~",
            "",
            "    Command line interface.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "from __future__ import print_function",
            "",
            "import sys",
            "import getopt",
            "from textwrap import dedent",
            "",
            "from pygments import __version__, highlight",
            "from pygments.util import ClassNotFound, OptionError, docstring_headline, \\",
            "    guess_decode, guess_decode_from_terminal, terminal_encoding",
            "from pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \\",
            "    get_lexer_for_filename, find_lexer_class_for_filename, TextLexer",
            "from pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter",
            "from pygments.formatters import get_all_formatters, get_formatter_by_name, \\",
            "    get_formatter_for_filename, find_formatter_class, \\",
            "    TerminalFormatter  # pylint:disable-msg=E0611",
            "from pygments.filters import get_all_filters, find_filter_class",
            "from pygments.styles import get_all_styles, get_style_by_name",
            "",
            "",
            "USAGE = \"\"\"\\",
            "Usage: %s [-l <lexer> | -g] [-F <filter>[:<options>]] [-f <formatter>]",
            "          [-O <options>] [-P <option=value>] [-s] [-v] [-o <outfile>] [<infile>]",
            "",
            "       %s -S <style> -f <formatter> [-a <arg>] [-O <options>] [-P <option=value>]",
            "       %s -L [<which> ...]",
            "       %s -N <filename>",
            "       %s -H <type> <name>",
            "       %s -h | -V",
            "",
            "Highlight the input file and write the result to <outfile>.",
            "",
            "If no input file is given, use stdin, if -o is not given, use stdout.",
            "",
            "If -s is passed, lexing will be done in \"streaming\" mode, reading and",
            "highlighting one line at a time.  This will only work properly with",
            "lexers that have no constructs spanning multiple lines!",
            "",
            "<lexer> is a lexer name (query all lexer names with -L). If -l is not",
            "given, the lexer is guessed from the extension of the input file name",
            "(this obviously doesn't work if the input is stdin).  If -g is passed,",
            "attempt to guess the lexer from the file contents, or pass through as",
            "plain text if this fails (this can work for stdin).",
            "",
            "Likewise, <formatter> is a formatter name, and will be guessed from",
            "the extension of the output file name. If no output file is given,",
            "the terminal formatter will be used by default.",
            "",
            "With the -O option, you can give the lexer and formatter a comma-",
            "separated list of options, e.g. ``-O bg=light,python=cool``.",
            "",
            "The -P option adds lexer and formatter options like the -O option, but",
            "you can only give one option per -P. That way, the option value may",
            "contain commas and equals signs, which it can't with -O, e.g.",
            "``-P \"heading=Pygments, the Python highlighter\".",
            "",
            "With the -F option, you can add filters to the token stream, you can",
            "give options in the same way as for -O after a colon (note: there must",
            "not be spaces around the colon).",
            "",
            "The -O, -P and -F options can be given multiple times.",
            "",
            "With the -S option, print out style definitions for style <style>",
            "for formatter <formatter>. The argument given by -a is formatter",
            "dependent.",
            "",
            "The -L option lists lexers, formatters, styles or filters -- set",
            "`which` to the thing you want to list (e.g. \"styles\"), or omit it to",
            "list everything.",
            "",
            "The -N option guesses and prints out a lexer name based solely on",
            "the given filename. It does not take input or highlight anything.",
            "If no specific lexer can be determined \"text\" is returned.",
            "",
            "The -H option prints detailed help for the object <name> of type <type>,",
            "where <type> is one of \"lexer\", \"formatter\" or \"filter\".",
            "",
            "The -s option processes lines one at a time until EOF, rather than",
            "waiting to process the entire file.  This only works for stdin, and",
            "is intended for streaming input such as you get from 'tail -f'.",
            "Example usage: \"tail -f sql.log | pygmentize -s -l sql\"",
            "",
            "The -v option prints a detailed traceback on unhandled exceptions,",
            "which is useful for debugging and bug reports.",
            "",
            "The -h option prints this help.",
            "The -V option prints the package version.",
            "\"\"\"",
            "",
            "",
            "def _parse_options(o_strs):",
            "    opts = {}",
            "    if not o_strs:",
            "        return opts",
            "    for o_str in o_strs:",
            "        if not o_str.strip():",
            "            continue",
            "        o_args = o_str.split(',')",
            "        for o_arg in o_args:",
            "            o_arg = o_arg.strip()",
            "            try:",
            "                o_key, o_val = o_arg.split('=', 1)",
            "                o_key = o_key.strip()",
            "                o_val = o_val.strip()",
            "            except ValueError:",
            "                opts[o_arg] = True",
            "            else:",
            "                opts[o_key] = o_val",
            "    return opts",
            "",
            "",
            "def _parse_filters(f_strs):",
            "    filters = []",
            "    if not f_strs:",
            "        return filters",
            "    for f_str in f_strs:",
            "        if ':' in f_str:",
            "            fname, fopts = f_str.split(':', 1)",
            "            filters.append((fname, _parse_options([fopts])))",
            "        else:",
            "            filters.append((f_str, {}))",
            "    return filters",
            "",
            "",
            "def _print_help(what, name):",
            "    try:",
            "        if what == 'lexer':",
            "            cls = get_lexer_by_name(name)",
            "            print(\"Help on the %s lexer:\" % cls.name)",
            "            print(dedent(cls.__doc__))",
            "        elif what == 'formatter':",
            "            cls = find_formatter_class(name)",
            "            print(\"Help on the %s formatter:\" % cls.name)",
            "            print(dedent(cls.__doc__))",
            "        elif what == 'filter':",
            "            cls = find_filter_class(name)",
            "            print(\"Help on the %s filter:\" % name)",
            "            print(dedent(cls.__doc__))",
            "        return 0",
            "    except (AttributeError, ValueError):",
            "        print(\"%s not found!\" % what, file=sys.stderr)",
            "        return 1",
            "",
            "",
            "def _print_list(what):",
            "    if what == 'lexer':",
            "        print()",
            "        print(\"Lexers:\")",
            "        print(\"~~~~~~~\")",
            "",
            "        info = []",
            "        for fullname, names, exts, _ in get_all_lexers():",
            "            tup = (', '.join(names)+':', fullname,",
            "                   exts and '(filenames ' + ', '.join(exts) + ')' or '')",
            "            info.append(tup)",
            "        info.sort()",
            "        for i in info:",
            "            print(('* %s\\n    %s %s') % i)",
            "",
            "    elif what == 'formatter':",
            "        print()",
            "        print(\"Formatters:\")",
            "        print(\"~~~~~~~~~~~\")",
            "",
            "        info = []",
            "        for cls in get_all_formatters():",
            "            doc = docstring_headline(cls)",
            "            tup = (', '.join(cls.aliases) + ':', doc, cls.filenames and",
            "                   '(filenames ' + ', '.join(cls.filenames) + ')' or '')",
            "            info.append(tup)",
            "        info.sort()",
            "        for i in info:",
            "            print(('* %s\\n    %s %s') % i)",
            "",
            "    elif what == 'filter':",
            "        print()",
            "        print(\"Filters:\")",
            "        print(\"~~~~~~~~\")",
            "",
            "        for name in get_all_filters():",
            "            cls = find_filter_class(name)",
            "            print(\"* \" + name + ':')",
            "            print(\"    %s\" % docstring_headline(cls))",
            "",
            "    elif what == 'style':",
            "        print()",
            "        print(\"Styles:\")",
            "        print(\"~~~~~~~\")",
            "",
            "        for name in get_all_styles():",
            "            cls = get_style_by_name(name)",
            "            print(\"* \" + name + ':')",
            "            print(\"    %s\" % docstring_headline(cls))",
            "",
            "",
            "def main_inner(popts, args, usage):",
            "    opts = {}",
            "    O_opts = []",
            "    P_opts = []",
            "    F_opts = []",
            "    for opt, arg in popts:",
            "        if opt == '-O':",
            "            O_opts.append(arg)",
            "        elif opt == '-P':",
            "            P_opts.append(arg)",
            "        elif opt == '-F':",
            "            F_opts.append(arg)",
            "        opts[opt] = arg",
            "",
            "    if opts.pop('-h', None) is not None:",
            "        print(usage)",
            "        return 0",
            "",
            "    if opts.pop('-V', None) is not None:",
            "        print('Pygments version %s, (c) 2006-2015 by Georg Brandl.' % __version__)",
            "        return 0",
            "",
            "    # handle ``pygmentize -L``",
            "    L_opt = opts.pop('-L', None)",
            "    if L_opt is not None:",
            "        if opts:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        # print version",
            "        main(['', '-V'])",
            "        if not args:",
            "            args = ['lexer', 'formatter', 'filter', 'style']",
            "        for arg in args:",
            "            _print_list(arg.rstrip('s'))",
            "        return 0",
            "",
            "    # handle ``pygmentize -H``",
            "    H_opt = opts.pop('-H', None)",
            "    if H_opt is not None:",
            "        if opts or len(args) != 2:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        what, name = args",
            "        if what not in ('lexer', 'formatter', 'filter'):",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        return _print_help(what, name)",
            "",
            "    # parse -O options",
            "    parsed_opts = _parse_options(O_opts)",
            "    opts.pop('-O', None)",
            "",
            "    # parse -P options",
            "    for p_opt in P_opts:",
            "        try:",
            "            name, value = p_opt.split('=', 1)",
            "        except ValueError:",
            "            parsed_opts[p_opt] = True",
            "        else:",
            "            parsed_opts[name] = value",
            "    opts.pop('-P', None)",
            "",
            "    # encodings",
            "    inencoding  = parsed_opts.get('inencoding', parsed_opts.get('encoding'))",
            "    outencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))",
            "",
            "    # handle ``pygmentize -N``",
            "    infn = opts.pop('-N', None)",
            "    if infn is not None:",
            "        lexer = find_lexer_class_for_filename(infn)",
            "        if lexer is None:",
            "            lexer = TextLexer",
            "",
            "        print(lexer.aliases[0])",
            "        return 0",
            "",
            "    # handle ``pygmentize -S``",
            "    S_opt = opts.pop('-S', None)",
            "    a_opt = opts.pop('-a', None)",
            "    if S_opt is not None:",
            "        f_opt = opts.pop('-f', None)",
            "        if not f_opt:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "        if opts or args:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        try:",
            "            parsed_opts['style'] = S_opt",
            "            fmter = get_formatter_by_name(f_opt, **parsed_opts)",
            "        except ClassNotFound as err:",
            "            print(err, file=sys.stderr)",
            "            return 1",
            "",
            "        print(fmter.get_style_defs(a_opt or ''))",
            "        return 0",
            "",
            "    # if no -S is given, -a is not allowed",
            "    if a_opt is not None:",
            "        print(usage, file=sys.stderr)",
            "        return 2",
            "",
            "    # parse -F options",
            "    F_opts = _parse_filters(F_opts)",
            "    opts.pop('-F', None)",
            "",
            "    # select lexer",
            "    lexer = None",
            "",
            "    # given by name?",
            "    lexername = opts.pop('-l', None)",
            "    if lexername:",
            "        try:",
            "            lexer = get_lexer_by_name(lexername, **parsed_opts)",
            "        except (OptionError, ClassNotFound) as err:",
            "            print('Error:', err, file=sys.stderr)",
            "            return 1",
            "",
            "    # read input code",
            "    code = None",
            "",
            "    if args:",
            "        if len(args) > 1:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        if '-s' in opts:",
            "            print('Error: -s option not usable when input file specified',",
            "                  file=sys.stderr)",
            "            return 2",
            "",
            "        infn = args[0]",
            "        try:",
            "            with open(infn, 'rb') as infp:",
            "                code = infp.read()",
            "        except Exception as err:",
            "            print('Error: cannot read infile:', err, file=sys.stderr)",
            "            return 1",
            "        if not inencoding:",
            "            code, inencoding = guess_decode(code)",
            "",
            "        # do we have to guess the lexer?",
            "        if not lexer:",
            "            try:",
            "                lexer = get_lexer_for_filename(infn, code, **parsed_opts)",
            "            except ClassNotFound as err:",
            "                if '-g' in opts:",
            "                    try:",
            "                        lexer = guess_lexer(code, **parsed_opts)",
            "                    except ClassNotFound:",
            "                        lexer = TextLexer(**parsed_opts)",
            "                else:",
            "                    print('Error:', err, file=sys.stderr)",
            "                    return 1",
            "            except OptionError as err:",
            "                print('Error:', err, file=sys.stderr)",
            "                return 1",
            "",
            "    elif '-s' not in opts:  # treat stdin as full file (-s support is later)",
            "        # read code from terminal, always in binary mode since we want to",
            "        # decode ourselves and be tolerant with it",
            "        if sys.version_info > (3,):",
            "            # Python 3: we have to use .buffer to get a binary stream",
            "            code = sys.stdin.buffer.read()",
            "        else:",
            "            code = sys.stdin.read()",
            "        if not inencoding:",
            "            code, inencoding = guess_decode_from_terminal(code, sys.stdin)",
            "            # else the lexer will do the decoding",
            "        if not lexer:",
            "            try:",
            "                lexer = guess_lexer(code, **parsed_opts)",
            "            except ClassNotFound:",
            "                lexer = TextLexer(**parsed_opts)",
            "",
            "    else:  # -s option needs a lexer with -l",
            "        if not lexer:",
            "            print('Error: when using -s a lexer has to be selected with -l',",
            "                  file=sys.stderr)",
            "            return 2",
            "",
            "    # process filters",
            "    for fname, fopts in F_opts:",
            "        try:",
            "            lexer.add_filter(fname, **fopts)",
            "        except ClassNotFound as err:",
            "            print('Error:', err, file=sys.stderr)",
            "            return 1",
            "",
            "    # select formatter",
            "    outfn = opts.pop('-o', None)",
            "    fmter = opts.pop('-f', None)",
            "    if fmter:",
            "        try:",
            "            fmter = get_formatter_by_name(fmter, **parsed_opts)",
            "        except (OptionError, ClassNotFound) as err:",
            "            print('Error:', err, file=sys.stderr)",
            "            return 1",
            "",
            "    if outfn:",
            "        if not fmter:",
            "            try:",
            "                fmter = get_formatter_for_filename(outfn, **parsed_opts)",
            "            except (OptionError, ClassNotFound) as err:",
            "                print('Error:', err, file=sys.stderr)",
            "                return 1",
            "        try:",
            "            outfile = open(outfn, 'wb')",
            "        except Exception as err:",
            "            print('Error: cannot open outfile:', err, file=sys.stderr)",
            "            return 1",
            "    else:",
            "        if not fmter:",
            "            fmter = TerminalFormatter(**parsed_opts)",
            "        if sys.version_info > (3,):",
            "            # Python 3: we have to use .buffer to get a binary stream",
            "            outfile = sys.stdout.buffer",
            "        else:",
            "            outfile = sys.stdout",
            "",
            "    # determine output encoding if not explicitly selected",
            "    if not outencoding:",
            "        if outfn:",
            "            # output file? use lexer encoding for now (can still be None)",
            "            fmter.encoding = inencoding",
            "        else:",
            "            # else use terminal encoding",
            "            fmter.encoding = terminal_encoding(sys.stdout)",
            "",
            "    # provide coloring under Windows, if possible",
            "    if not outfn and sys.platform in ('win32', 'cygwin') and \\",
            "       fmter.name in ('Terminal', 'Terminal256'):  # pragma: no cover",
            "        # unfortunately colorama doesn't support binary streams on Py3",
            "        if sys.version_info > (3,):",
            "            from pygments.util import UnclosingTextIOWrapper",
            "            outfile = UnclosingTextIOWrapper(outfile, encoding=fmter.encoding)",
            "            fmter.encoding = None",
            "        try:",
            "            import colorama.initialise",
            "        except ImportError:",
            "            pass",
            "        else:",
            "            outfile = colorama.initialise.wrap_stream(",
            "                outfile, convert=None, strip=None, autoreset=False, wrap=True)",
            "",
            "    # When using the LaTeX formatter and the option `escapeinside` is",
            "    # specified, we need a special lexer which collects escaped text",
            "    # before running the chosen language lexer.",
            "    escapeinside = parsed_opts.get('escapeinside', '')",
            "    if len(escapeinside) == 2 and isinstance(fmter, LatexFormatter):",
            "        left = escapeinside[0]",
            "        right = escapeinside[1]",
            "        lexer = LatexEmbeddedLexer(left, right, lexer)",
            "",
            "    # ... and do it!",
            "    if '-s' not in opts:",
            "        # process whole input as per normal...",
            "        highlight(code, lexer, fmter, outfile)",
            "        return 0",
            "    else:",
            "        # line by line processing of stdin (eg: for 'tail -f')...",
            "        try:",
            "            while 1:",
            "                if sys.version_info > (3,):",
            "                    # Python 3: we have to use .buffer to get a binary stream",
            "                    line = sys.stdin.buffer.readline()",
            "                else:",
            "                    line = sys.stdin.readline()",
            "                if not line:",
            "                    break",
            "                if not inencoding:",
            "                    line = guess_decode_from_terminal(line, sys.stdin)[0]",
            "                highlight(line, lexer, fmter, outfile)",
            "                if hasattr(outfile, 'flush'):",
            "                    outfile.flush()",
            "            return 0",
            "        except KeyboardInterrupt:  # pragma: no cover",
            "            return 0",
            "",
            "",
            "def main(args=sys.argv):",
            "    \"\"\"",
            "    Main command line entry point.",
            "    \"\"\"",
            "    usage = USAGE % ((args[0],) * 6)",
            "",
            "    try:",
            "        popts, args = getopt.getopt(args[1:], \"l:f:F:o:O:P:LS:a:N:vhVHgs\")",
            "    except getopt.GetoptError:",
            "        print(usage, file=sys.stderr)",
            "        return 2",
            "",
            "    try:",
            "        return main_inner(popts, args, usage)",
            "    except Exception:",
            "        if '-v' in dict(popts):",
            "            print(file=sys.stderr)",
            "            print('*' * 65, file=sys.stderr)",
            "            print('An unhandled exception occurred while highlighting.',",
            "                  file=sys.stderr)",
            "            print('Please report the whole traceback to the issue tracker at',",
            "                  file=sys.stderr)",
            "            print('<https://bitbucket.org/birkenfeld/pygments-main/issues>.',",
            "                  file=sys.stderr)",
            "            print('*' * 65, file=sys.stderr)",
            "            print(file=sys.stderr)",
            "            raise",
            "        import traceback",
            "        info = traceback.format_exception(*sys.exc_info())",
            "        msg = info[-1].strip()",
            "        if len(info) >= 3:",
            "            # extract relevant file and position info",
            "            msg += '\\n   (f%s)' % info[-2].split('\\n')[0].strip()[1:]",
            "        print(file=sys.stderr)",
            "        print('*** Error while highlighting:', file=sys.stderr)",
            "        print(msg, file=sys.stderr)",
            "        print('*** If this is a bug you want to report, please rerun with -v.',",
            "              file=sys.stderr)",
            "        return 1"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.cmdline",
            "    ~~~~~~~~~~~~~~~~",
            "",
            "    Command line interface.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "from __future__ import print_function",
            "",
            "import sys",
            "import getopt",
            "from textwrap import dedent",
            "",
            "from pygments import __version__, highlight",
            "from pygments.util import ClassNotFound, OptionError, docstring_headline, \\",
            "    guess_decode, guess_decode_from_terminal, terminal_encoding",
            "from pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \\",
            "    get_lexer_for_filename, find_lexer_class_for_filename",
            "from pygments.lexers.special import TextLexer",
            "from pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter",
            "from pygments.formatters import get_all_formatters, get_formatter_by_name, \\",
            "    get_formatter_for_filename, find_formatter_class",
            "from pygments.formatters.terminal import TerminalFormatter",
            "from pygments.filters import get_all_filters, find_filter_class",
            "from pygments.styles import get_all_styles, get_style_by_name",
            "",
            "",
            "USAGE = \"\"\"\\",
            "Usage: %s [-l <lexer> | -g] [-F <filter>[:<options>]] [-f <formatter>]",
            "          [-O <options>] [-P <option=value>] [-s] [-v] [-o <outfile>] [<infile>]",
            "",
            "       %s -S <style> -f <formatter> [-a <arg>] [-O <options>] [-P <option=value>]",
            "       %s -L [<which> ...]",
            "       %s -N <filename>",
            "       %s -H <type> <name>",
            "       %s -h | -V",
            "",
            "Highlight the input file and write the result to <outfile>.",
            "",
            "If no input file is given, use stdin, if -o is not given, use stdout.",
            "",
            "If -s is passed, lexing will be done in \"streaming\" mode, reading and",
            "highlighting one line at a time.  This will only work properly with",
            "lexers that have no constructs spanning multiple lines!",
            "",
            "<lexer> is a lexer name (query all lexer names with -L). If -l is not",
            "given, the lexer is guessed from the extension of the input file name",
            "(this obviously doesn't work if the input is stdin).  If -g is passed,",
            "attempt to guess the lexer from the file contents, or pass through as",
            "plain text if this fails (this can work for stdin).",
            "",
            "Likewise, <formatter> is a formatter name, and will be guessed from",
            "the extension of the output file name. If no output file is given,",
            "the terminal formatter will be used by default.",
            "",
            "With the -O option, you can give the lexer and formatter a comma-",
            "separated list of options, e.g. ``-O bg=light,python=cool``.",
            "",
            "The -P option adds lexer and formatter options like the -O option, but",
            "you can only give one option per -P. That way, the option value may",
            "contain commas and equals signs, which it can't with -O, e.g.",
            "``-P \"heading=Pygments, the Python highlighter\".",
            "",
            "With the -F option, you can add filters to the token stream, you can",
            "give options in the same way as for -O after a colon (note: there must",
            "not be spaces around the colon).",
            "",
            "The -O, -P and -F options can be given multiple times.",
            "",
            "With the -S option, print out style definitions for style <style>",
            "for formatter <formatter>. The argument given by -a is formatter",
            "dependent.",
            "",
            "The -L option lists lexers, formatters, styles or filters -- set",
            "`which` to the thing you want to list (e.g. \"styles\"), or omit it to",
            "list everything.",
            "",
            "The -N option guesses and prints out a lexer name based solely on",
            "the given filename. It does not take input or highlight anything.",
            "If no specific lexer can be determined \"text\" is returned.",
            "",
            "The -H option prints detailed help for the object <name> of type <type>,",
            "where <type> is one of \"lexer\", \"formatter\" or \"filter\".",
            "",
            "The -s option processes lines one at a time until EOF, rather than",
            "waiting to process the entire file.  This only works for stdin, and",
            "is intended for streaming input such as you get from 'tail -f'.",
            "Example usage: \"tail -f sql.log | pygmentize -s -l sql\"",
            "",
            "The -v option prints a detailed traceback on unhandled exceptions,",
            "which is useful for debugging and bug reports.",
            "",
            "The -h option prints this help.",
            "The -V option prints the package version.",
            "\"\"\"",
            "",
            "",
            "def _parse_options(o_strs):",
            "    opts = {}",
            "    if not o_strs:",
            "        return opts",
            "    for o_str in o_strs:",
            "        if not o_str.strip():",
            "            continue",
            "        o_args = o_str.split(',')",
            "        for o_arg in o_args:",
            "            o_arg = o_arg.strip()",
            "            try:",
            "                o_key, o_val = o_arg.split('=', 1)",
            "                o_key = o_key.strip()",
            "                o_val = o_val.strip()",
            "            except ValueError:",
            "                opts[o_arg] = True",
            "            else:",
            "                opts[o_key] = o_val",
            "    return opts",
            "",
            "",
            "def _parse_filters(f_strs):",
            "    filters = []",
            "    if not f_strs:",
            "        return filters",
            "    for f_str in f_strs:",
            "        if ':' in f_str:",
            "            fname, fopts = f_str.split(':', 1)",
            "            filters.append((fname, _parse_options([fopts])))",
            "        else:",
            "            filters.append((f_str, {}))",
            "    return filters",
            "",
            "",
            "def _print_help(what, name):",
            "    try:",
            "        if what == 'lexer':",
            "            cls = get_lexer_by_name(name)",
            "            print(\"Help on the %s lexer:\" % cls.name)",
            "            print(dedent(cls.__doc__))",
            "        elif what == 'formatter':",
            "            cls = find_formatter_class(name)",
            "            print(\"Help on the %s formatter:\" % cls.name)",
            "            print(dedent(cls.__doc__))",
            "        elif what == 'filter':",
            "            cls = find_filter_class(name)",
            "            print(\"Help on the %s filter:\" % name)",
            "            print(dedent(cls.__doc__))",
            "        return 0",
            "    except (AttributeError, ValueError):",
            "        print(\"%s not found!\" % what, file=sys.stderr)",
            "        return 1",
            "",
            "",
            "def _print_list(what):",
            "    if what == 'lexer':",
            "        print()",
            "        print(\"Lexers:\")",
            "        print(\"~~~~~~~\")",
            "",
            "        info = []",
            "        for fullname, names, exts, _ in get_all_lexers():",
            "            tup = (', '.join(names)+':', fullname,",
            "                   exts and '(filenames ' + ', '.join(exts) + ')' or '')",
            "            info.append(tup)",
            "        info.sort()",
            "        for i in info:",
            "            print(('* %s\\n    %s %s') % i)",
            "",
            "    elif what == 'formatter':",
            "        print()",
            "        print(\"Formatters:\")",
            "        print(\"~~~~~~~~~~~\")",
            "",
            "        info = []",
            "        for cls in get_all_formatters():",
            "            doc = docstring_headline(cls)",
            "            tup = (', '.join(cls.aliases) + ':', doc, cls.filenames and",
            "                   '(filenames ' + ', '.join(cls.filenames) + ')' or '')",
            "            info.append(tup)",
            "        info.sort()",
            "        for i in info:",
            "            print(('* %s\\n    %s %s') % i)",
            "",
            "    elif what == 'filter':",
            "        print()",
            "        print(\"Filters:\")",
            "        print(\"~~~~~~~~\")",
            "",
            "        for name in get_all_filters():",
            "            cls = find_filter_class(name)",
            "            print(\"* \" + name + ':')",
            "            print(\"    %s\" % docstring_headline(cls))",
            "",
            "    elif what == 'style':",
            "        print()",
            "        print(\"Styles:\")",
            "        print(\"~~~~~~~\")",
            "",
            "        for name in get_all_styles():",
            "            cls = get_style_by_name(name)",
            "            print(\"* \" + name + ':')",
            "            print(\"    %s\" % docstring_headline(cls))",
            "",
            "",
            "def main_inner(popts, args, usage):",
            "    opts = {}",
            "    O_opts = []",
            "    P_opts = []",
            "    F_opts = []",
            "    for opt, arg in popts:",
            "        if opt == '-O':",
            "            O_opts.append(arg)",
            "        elif opt == '-P':",
            "            P_opts.append(arg)",
            "        elif opt == '-F':",
            "            F_opts.append(arg)",
            "        opts[opt] = arg",
            "",
            "    if opts.pop('-h', None) is not None:",
            "        print(usage)",
            "        return 0",
            "",
            "    if opts.pop('-V', None) is not None:",
            "        print('Pygments version %s, (c) 2006-2015 by Georg Brandl.' % __version__)",
            "        return 0",
            "",
            "    # handle ``pygmentize -L``",
            "    L_opt = opts.pop('-L', None)",
            "    if L_opt is not None:",
            "        if opts:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        # print version",
            "        main(['', '-V'])",
            "        if not args:",
            "            args = ['lexer', 'formatter', 'filter', 'style']",
            "        for arg in args:",
            "            _print_list(arg.rstrip('s'))",
            "        return 0",
            "",
            "    # handle ``pygmentize -H``",
            "    H_opt = opts.pop('-H', None)",
            "    if H_opt is not None:",
            "        if opts or len(args) != 2:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        what, name = args  # pylint: disable=unbalanced-tuple-unpacking",
            "        if what not in ('lexer', 'formatter', 'filter'):",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        return _print_help(what, name)",
            "",
            "    # parse -O options",
            "    parsed_opts = _parse_options(O_opts)",
            "    opts.pop('-O', None)",
            "",
            "    # parse -P options",
            "    for p_opt in P_opts:",
            "        try:",
            "            name, value = p_opt.split('=', 1)",
            "        except ValueError:",
            "            parsed_opts[p_opt] = True",
            "        else:",
            "            parsed_opts[name] = value",
            "    opts.pop('-P', None)",
            "",
            "    # encodings",
            "    inencoding = parsed_opts.get('inencoding', parsed_opts.get('encoding'))",
            "    outencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))",
            "",
            "    # handle ``pygmentize -N``",
            "    infn = opts.pop('-N', None)",
            "    if infn is not None:",
            "        lexer = find_lexer_class_for_filename(infn)",
            "        if lexer is None:",
            "            lexer = TextLexer",
            "",
            "        print(lexer.aliases[0])",
            "        return 0",
            "",
            "    # handle ``pygmentize -S``",
            "    S_opt = opts.pop('-S', None)",
            "    a_opt = opts.pop('-a', None)",
            "    if S_opt is not None:",
            "        f_opt = opts.pop('-f', None)",
            "        if not f_opt:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "        if opts or args:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        try:",
            "            parsed_opts['style'] = S_opt",
            "            fmter = get_formatter_by_name(f_opt, **parsed_opts)",
            "        except ClassNotFound as err:",
            "            print(err, file=sys.stderr)",
            "            return 1",
            "",
            "        print(fmter.get_style_defs(a_opt or ''))",
            "        return 0",
            "",
            "    # if no -S is given, -a is not allowed",
            "    if a_opt is not None:",
            "        print(usage, file=sys.stderr)",
            "        return 2",
            "",
            "    # parse -F options",
            "    F_opts = _parse_filters(F_opts)",
            "    opts.pop('-F', None)",
            "",
            "    # select lexer",
            "    lexer = None",
            "",
            "    # given by name?",
            "    lexername = opts.pop('-l', None)",
            "    if lexername:",
            "        try:",
            "            lexer = get_lexer_by_name(lexername, **parsed_opts)",
            "        except (OptionError, ClassNotFound) as err:",
            "            print('Error:', err, file=sys.stderr)",
            "            return 1",
            "",
            "    # read input code",
            "    code = None",
            "",
            "    if args:",
            "        if len(args) > 1:",
            "            print(usage, file=sys.stderr)",
            "            return 2",
            "",
            "        if '-s' in opts:",
            "            print('Error: -s option not usable when input file specified',",
            "                  file=sys.stderr)",
            "            return 2",
            "",
            "        infn = args[0]",
            "        try:",
            "            with open(infn, 'rb') as infp:",
            "                code = infp.read()",
            "        except Exception as err:",
            "            print('Error: cannot read infile:', err, file=sys.stderr)",
            "            return 1",
            "        if not inencoding:",
            "            code, inencoding = guess_decode(code)",
            "",
            "        # do we have to guess the lexer?",
            "        if not lexer:",
            "            try:",
            "                lexer = get_lexer_for_filename(infn, code, **parsed_opts)",
            "            except ClassNotFound as err:",
            "                if '-g' in opts:",
            "                    try:",
            "                        lexer = guess_lexer(code, **parsed_opts)",
            "                    except ClassNotFound:",
            "                        lexer = TextLexer(**parsed_opts)",
            "                else:",
            "                    print('Error:', err, file=sys.stderr)",
            "                    return 1",
            "            except OptionError as err:",
            "                print('Error:', err, file=sys.stderr)",
            "                return 1",
            "",
            "    elif '-s' not in opts:  # treat stdin as full file (-s support is later)",
            "        # read code from terminal, always in binary mode since we want to",
            "        # decode ourselves and be tolerant with it",
            "        if sys.version_info > (3,):",
            "            # Python 3: we have to use .buffer to get a binary stream",
            "            code = sys.stdin.buffer.read()",
            "        else:",
            "            code = sys.stdin.read()",
            "        if not inencoding:",
            "            code, inencoding = guess_decode_from_terminal(code, sys.stdin)",
            "            # else the lexer will do the decoding",
            "        if not lexer:",
            "            try:",
            "                lexer = guess_lexer(code, **parsed_opts)",
            "            except ClassNotFound:",
            "                lexer = TextLexer(**parsed_opts)",
            "",
            "    else:  # -s option needs a lexer with -l",
            "        if not lexer:",
            "            print('Error: when using -s a lexer has to be selected with -l',",
            "                  file=sys.stderr)",
            "            return 2",
            "",
            "    # process filters",
            "    for fname, fopts in F_opts:",
            "        try:",
            "            lexer.add_filter(fname, **fopts)",
            "        except ClassNotFound as err:",
            "            print('Error:', err, file=sys.stderr)",
            "            return 1",
            "",
            "    # select formatter",
            "    outfn = opts.pop('-o', None)",
            "    fmter = opts.pop('-f', None)",
            "    if fmter:",
            "        try:",
            "            fmter = get_formatter_by_name(fmter, **parsed_opts)",
            "        except (OptionError, ClassNotFound) as err:",
            "            print('Error:', err, file=sys.stderr)",
            "            return 1",
            "",
            "    if outfn:",
            "        if not fmter:",
            "            try:",
            "                fmter = get_formatter_for_filename(outfn, **parsed_opts)",
            "            except (OptionError, ClassNotFound) as err:",
            "                print('Error:', err, file=sys.stderr)",
            "                return 1",
            "        try:",
            "            outfile = open(outfn, 'wb')",
            "        except Exception as err:",
            "            print('Error: cannot open outfile:', err, file=sys.stderr)",
            "            return 1",
            "    else:",
            "        if not fmter:",
            "            fmter = TerminalFormatter(**parsed_opts)",
            "        if sys.version_info > (3,):",
            "            # Python 3: we have to use .buffer to get a binary stream",
            "            outfile = sys.stdout.buffer",
            "        else:",
            "            outfile = sys.stdout",
            "",
            "    # determine output encoding if not explicitly selected",
            "    if not outencoding:",
            "        if outfn:",
            "            # output file? use lexer encoding for now (can still be None)",
            "            fmter.encoding = inencoding",
            "        else:",
            "            # else use terminal encoding",
            "            fmter.encoding = terminal_encoding(sys.stdout)",
            "",
            "    # provide coloring under Windows, if possible",
            "    if not outfn and sys.platform in ('win32', 'cygwin') and \\",
            "       fmter.name in ('Terminal', 'Terminal256'):  # pragma: no cover",
            "        # unfortunately colorama doesn't support binary streams on Py3",
            "        if sys.version_info > (3,):",
            "            from pygments.util import UnclosingTextIOWrapper",
            "            outfile = UnclosingTextIOWrapper(outfile, encoding=fmter.encoding)",
            "            fmter.encoding = None",
            "        try:",
            "            import colorama.initialise",
            "        except ImportError:",
            "            pass",
            "        else:",
            "            outfile = colorama.initialise.wrap_stream(",
            "                outfile, convert=None, strip=None, autoreset=False, wrap=True)",
            "",
            "    # When using the LaTeX formatter and the option `escapeinside` is",
            "    # specified, we need a special lexer which collects escaped text",
            "    # before running the chosen language lexer.",
            "    escapeinside = parsed_opts.get('escapeinside', '')",
            "    if len(escapeinside) == 2 and isinstance(fmter, LatexFormatter):",
            "        left = escapeinside[0]",
            "        right = escapeinside[1]",
            "        lexer = LatexEmbeddedLexer(left, right, lexer)",
            "",
            "    # ... and do it!",
            "    if '-s' not in opts:",
            "        # process whole input as per normal...",
            "        highlight(code, lexer, fmter, outfile)",
            "        return 0",
            "    else:",
            "        # line by line processing of stdin (eg: for 'tail -f')...",
            "        try:",
            "            while 1:",
            "                if sys.version_info > (3,):",
            "                    # Python 3: we have to use .buffer to get a binary stream",
            "                    line = sys.stdin.buffer.readline()",
            "                else:",
            "                    line = sys.stdin.readline()",
            "                if not line:",
            "                    break",
            "                if not inencoding:",
            "                    line = guess_decode_from_terminal(line, sys.stdin)[0]",
            "                highlight(line, lexer, fmter, outfile)",
            "                if hasattr(outfile, 'flush'):",
            "                    outfile.flush()",
            "            return 0",
            "        except KeyboardInterrupt:  # pragma: no cover",
            "            return 0",
            "",
            "",
            "def main(args=sys.argv):",
            "    \"\"\"",
            "    Main command line entry point.",
            "    \"\"\"",
            "    usage = USAGE % ((args[0],) * 6)",
            "",
            "    try:",
            "        popts, args = getopt.getopt(args[1:], \"l:f:F:o:O:P:LS:a:N:vhVHgs\")",
            "    except getopt.GetoptError:",
            "        print(usage, file=sys.stderr)",
            "        return 2",
            "",
            "    try:",
            "        return main_inner(popts, args, usage)",
            "    except Exception:",
            "        if '-v' in dict(popts):",
            "            print(file=sys.stderr)",
            "            print('*' * 65, file=sys.stderr)",
            "            print('An unhandled exception occurred while highlighting.',",
            "                  file=sys.stderr)",
            "            print('Please report the whole traceback to the issue tracker at',",
            "                  file=sys.stderr)",
            "            print('<https://bitbucket.org/birkenfeld/pygments-main/issues>.',",
            "                  file=sys.stderr)",
            "            print('*' * 65, file=sys.stderr)",
            "            print(file=sys.stderr)",
            "            raise",
            "        import traceback",
            "        info = traceback.format_exception(*sys.exc_info())",
            "        msg = info[-1].strip()",
            "        if len(info) >= 3:",
            "            # extract relevant file and position info",
            "            msg += '\\n   (f%s)' % info[-2].split('\\n')[0].strip()[1:]",
            "        print(file=sys.stderr)",
            "        print('*** Error while highlighting:', file=sys.stderr)",
            "        print(msg, file=sys.stderr)",
            "        print('*** If this is a bug you want to report, please rerun with -v.',",
            "              file=sys.stderr)",
            "        return 1"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "25": [],
            "26": [],
            "250": [
                "main_inner"
            ],
            "272": [
                "main_inner"
            ]
        },
        "addLocation": []
    },
    "pygments/filter.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         Filter.__init__(self, **options)"
            },
            "1": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     def filter(self, lexer, stream):"
            },
            "3": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # pylint: disable-msg=E1102"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        # pylint: disable=not-callable"
            },
            "5": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         for ttype, value in self.function(lexer, stream, self.options):"
            },
            "6": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             yield ttype, value"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.filter",
            "    ~~~~~~~~~~~~~~~",
            "",
            "    Module that implements the default filter.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "",
            "def apply_filters(stream, filters, lexer=None):",
            "    \"\"\"",
            "    Use this method to apply an iterable of filters to",
            "    a stream. If lexer is given it's forwarded to the",
            "    filter, otherwise the filter receives `None`.",
            "    \"\"\"",
            "    def _apply(filter_, stream):",
            "        for token in filter_.filter(lexer, stream):",
            "            yield token",
            "    for filter_ in filters:",
            "        stream = _apply(filter_, stream)",
            "    return stream",
            "",
            "",
            "def simplefilter(f):",
            "    \"\"\"",
            "    Decorator that converts a function into a filter::",
            "",
            "        @simplefilter",
            "        def lowercase(self, lexer, stream, options):",
            "            for ttype, value in stream:",
            "                yield ttype, value.lower()",
            "    \"\"\"",
            "    return type(f.__name__, (FunctionFilter,), {",
            "                'function':     f,",
            "                '__module__':   getattr(f, '__module__'),",
            "                '__doc__':      f.__doc__",
            "            })",
            "",
            "",
            "class Filter(object):",
            "    \"\"\"",
            "    Default filter. Subclass this class or use the `simplefilter`",
            "    decorator to create own filters.",
            "    \"\"\"",
            "",
            "    def __init__(self, **options):",
            "        self.options = options",
            "",
            "    def filter(self, lexer, stream):",
            "        raise NotImplementedError()",
            "",
            "",
            "class FunctionFilter(Filter):",
            "    \"\"\"",
            "    Abstract class used by `simplefilter` to create simple",
            "    function filters on the fly. The `simplefilter` decorator",
            "    automatically creates subclasses of this class for",
            "    functions passed to it.",
            "    \"\"\"",
            "    function = None",
            "",
            "    def __init__(self, **options):",
            "        if not hasattr(self, 'function'):",
            "            raise TypeError('%r used without bound function' %",
            "                            self.__class__.__name__)",
            "        Filter.__init__(self, **options)",
            "",
            "    def filter(self, lexer, stream):",
            "        # pylint: disable-msg=E1102",
            "        for ttype, value in self.function(lexer, stream, self.options):",
            "            yield ttype, value"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.filter",
            "    ~~~~~~~~~~~~~~~",
            "",
            "    Module that implements the default filter.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "",
            "def apply_filters(stream, filters, lexer=None):",
            "    \"\"\"",
            "    Use this method to apply an iterable of filters to",
            "    a stream. If lexer is given it's forwarded to the",
            "    filter, otherwise the filter receives `None`.",
            "    \"\"\"",
            "    def _apply(filter_, stream):",
            "        for token in filter_.filter(lexer, stream):",
            "            yield token",
            "    for filter_ in filters:",
            "        stream = _apply(filter_, stream)",
            "    return stream",
            "",
            "",
            "def simplefilter(f):",
            "    \"\"\"",
            "    Decorator that converts a function into a filter::",
            "",
            "        @simplefilter",
            "        def lowercase(self, lexer, stream, options):",
            "            for ttype, value in stream:",
            "                yield ttype, value.lower()",
            "    \"\"\"",
            "    return type(f.__name__, (FunctionFilter,), {",
            "                'function':     f,",
            "                '__module__':   getattr(f, '__module__'),",
            "                '__doc__':      f.__doc__",
            "            })",
            "",
            "",
            "class Filter(object):",
            "    \"\"\"",
            "    Default filter. Subclass this class or use the `simplefilter`",
            "    decorator to create own filters.",
            "    \"\"\"",
            "",
            "    def __init__(self, **options):",
            "        self.options = options",
            "",
            "    def filter(self, lexer, stream):",
            "        raise NotImplementedError()",
            "",
            "",
            "class FunctionFilter(Filter):",
            "    \"\"\"",
            "    Abstract class used by `simplefilter` to create simple",
            "    function filters on the fly. The `simplefilter` decorator",
            "    automatically creates subclasses of this class for",
            "    functions passed to it.",
            "    \"\"\"",
            "    function = None",
            "",
            "    def __init__(self, **options):",
            "        if not hasattr(self, 'function'):",
            "            raise TypeError('%r used without bound function' %",
            "                            self.__class__.__name__)",
            "        Filter.__init__(self, **options)",
            "",
            "    def filter(self, lexer, stream):",
            "        # pylint: disable=not-callable",
            "        for ttype, value in self.function(lexer, stream, self.options):",
            "            yield ttype, value"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "72": [
                "FunctionFilter",
                "filter"
            ]
        },
        "addLocation": []
    },
    "pygments/formatters/_mapping.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     'BmpImageFormatter': ('pygments.formatters.img', 'img_bmp', ('bmp', 'bitmap'), ('*.bmp',), 'Create a bitmap image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),"
            },
            "1": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     'GifImageFormatter': ('pygments.formatters.img', 'img_gif', ('gif',), ('*.gif',), 'Create a GIF image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),"
            },
            "2": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     'HtmlFormatter': ('pygments.formatters.html', 'HTML', ('html',), ('*.html', '*.htm'), \"Format tokens as HTML 4 ``<span>`` tags within a ``<pre>`` tag, wrapped in a ``<div>`` tag. The ``<div>``'s CSS class can be set by the `cssclass` option.\"),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    'IRCFormatter': ('pygments.formatters.irc', 'IRC', ('irc', 'IRC'), (), 'Format tokens with IRC color sequences'),"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     'ImageFormatter': ('pygments.formatters.img', 'img', ('img', 'IMG', 'png'), ('*.png',), 'Create a PNG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     'JpgImageFormatter': ('pygments.formatters.img', 'img_jpg', ('jpg', 'jpeg'), ('*.jpg',), 'Create a JPEG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     'LatexFormatter': ('pygments.formatters.latex', 'LaTeX', ('latex', 'tex'), ('*.tex',), 'Format tokens as LaTeX code. This needs the `fancyvrb` and `color` standard packages.'),"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.formatters._mapping",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Formatter mapping definitions. This file is generated by itself. Everytime",
            "    you change something on a builtin formatter definition, run this script from",
            "    the formatters folder to update it.",
            "",
            "    Do not alter the FORMATTERS dictionary by hand.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "from __future__ import print_function",
            "",
            "FORMATTERS = {",
            "    'BBCodeFormatter': ('pygments.formatters.bbcode', 'BBCode', ('bbcode', 'bb'), (), 'Format tokens with BBcodes. These formatting codes are used by many bulletin boards, so you can highlight your sourcecode with pygments before posting it there.'),",
            "    'BmpImageFormatter': ('pygments.formatters.img', 'img_bmp', ('bmp', 'bitmap'), ('*.bmp',), 'Create a bitmap image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'GifImageFormatter': ('pygments.formatters.img', 'img_gif', ('gif',), ('*.gif',), 'Create a GIF image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'HtmlFormatter': ('pygments.formatters.html', 'HTML', ('html',), ('*.html', '*.htm'), \"Format tokens as HTML 4 ``<span>`` tags within a ``<pre>`` tag, wrapped in a ``<div>`` tag. The ``<div>``'s CSS class can be set by the `cssclass` option.\"),",
            "    'ImageFormatter': ('pygments.formatters.img', 'img', ('img', 'IMG', 'png'), ('*.png',), 'Create a PNG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'JpgImageFormatter': ('pygments.formatters.img', 'img_jpg', ('jpg', 'jpeg'), ('*.jpg',), 'Create a JPEG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'LatexFormatter': ('pygments.formatters.latex', 'LaTeX', ('latex', 'tex'), ('*.tex',), 'Format tokens as LaTeX code. This needs the `fancyvrb` and `color` standard packages.'),",
            "    'NullFormatter': ('pygments.formatters.other', 'Text only', ('text', 'null'), ('*.txt',), 'Output the text unchanged without any formatting.'),",
            "    'RawTokenFormatter': ('pygments.formatters.other', 'Raw tokens', ('raw', 'tokens'), ('*.raw',), 'Format tokens as a raw representation for storing token streams.'),",
            "    'RtfFormatter': ('pygments.formatters.rtf', 'RTF', ('rtf',), ('*.rtf',), 'Format tokens as RTF markup. This formatter automatically outputs full RTF documents with color information and other useful stuff. Perfect for Copy and Paste into Microsoft(R) Word(R) documents.'),",
            "    'SvgFormatter': ('pygments.formatters.svg', 'SVG', ('svg',), ('*.svg',), 'Format tokens as an SVG graphics file.  This formatter is still experimental. Each line of code is a ``<text>`` element with explicit ``x`` and ``y`` coordinates containing ``<tspan>`` elements with the individual token styles.'),",
            "    'Terminal256Formatter': ('pygments.formatters.terminal256', 'Terminal256', ('terminal256', 'console256', '256'), (), 'Format tokens with ANSI color sequences, for output in a 256-color terminal or console. Like in `TerminalFormatter` color sequences are terminated at newlines, so that paging the output works correctly.'),",
            "    'TerminalFormatter': ('pygments.formatters.terminal', 'Terminal', ('terminal', 'console'), (), 'Format tokens with ANSI color sequences, for output in a text console. Color sequences are terminated at newlines, so that paging the output works correctly.'),",
            "    'TestcaseFormatter': ('pygments.formatters.other', 'Testcase', ('testcase',), (), 'Format tokens as appropriate for a new testcase.')",
            "}",
            "",
            "if __name__ == '__main__':  # pragma: no cover",
            "    import sys",
            "    import os",
            "",
            "    # lookup formatters",
            "    found_formatters = []",
            "    imports = []",
            "    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))",
            "    from pygments.util import docstring_headline",
            "",
            "    for root, dirs, files in os.walk('.'):",
            "        for filename in files:",
            "            if filename.endswith('.py') and not filename.startswith('_'):",
            "                module_name = 'pygments.formatters%s.%s' % (",
            "                    root[1:].replace('/', '.'), filename[:-3])",
            "                print(module_name)",
            "                module = __import__(module_name, None, None, [''])",
            "                for formatter_name in module.__all__:",
            "                    formatter = getattr(module, formatter_name)",
            "                    found_formatters.append(",
            "                        '%r: %r' % (formatter_name,",
            "                                    (module_name,",
            "                                     formatter.name,",
            "                                     tuple(formatter.aliases),",
            "                                     tuple(formatter.filenames),",
            "                                     docstring_headline(formatter))))",
            "    # sort them to make the diff minimal",
            "    found_formatters.sort()",
            "",
            "    # extract useful sourcecode from this file",
            "    with open(__file__) as fp:",
            "        content = fp.read()",
            "    header = content[:content.find('FORMATTERS = {')]",
            "    footer = content[content.find(\"if __name__ == '__main__':\"):]",
            "",
            "    # write new file",
            "    with open(__file__, 'w') as fp:",
            "        fp.write(header)",
            "        fp.write('FORMATTERS = {\\n    %s\\n}\\n\\n' % ',\\n    '.join(found_formatters))",
            "        fp.write(footer)",
            "",
            "    print ('=== %d formatters processed.' % len(found_formatters))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.formatters._mapping",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Formatter mapping definitions. This file is generated by itself. Everytime",
            "    you change something on a builtin formatter definition, run this script from",
            "    the formatters folder to update it.",
            "",
            "    Do not alter the FORMATTERS dictionary by hand.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "from __future__ import print_function",
            "",
            "FORMATTERS = {",
            "    'BBCodeFormatter': ('pygments.formatters.bbcode', 'BBCode', ('bbcode', 'bb'), (), 'Format tokens with BBcodes. These formatting codes are used by many bulletin boards, so you can highlight your sourcecode with pygments before posting it there.'),",
            "    'BmpImageFormatter': ('pygments.formatters.img', 'img_bmp', ('bmp', 'bitmap'), ('*.bmp',), 'Create a bitmap image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'GifImageFormatter': ('pygments.formatters.img', 'img_gif', ('gif',), ('*.gif',), 'Create a GIF image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'HtmlFormatter': ('pygments.formatters.html', 'HTML', ('html',), ('*.html', '*.htm'), \"Format tokens as HTML 4 ``<span>`` tags within a ``<pre>`` tag, wrapped in a ``<div>`` tag. The ``<div>``'s CSS class can be set by the `cssclass` option.\"),",
            "    'IRCFormatter': ('pygments.formatters.irc', 'IRC', ('irc', 'IRC'), (), 'Format tokens with IRC color sequences'),",
            "    'ImageFormatter': ('pygments.formatters.img', 'img', ('img', 'IMG', 'png'), ('*.png',), 'Create a PNG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'JpgImageFormatter': ('pygments.formatters.img', 'img_jpg', ('jpg', 'jpeg'), ('*.jpg',), 'Create a JPEG image from source code. This uses the Python Imaging Library to generate a pixmap from the source code.'),",
            "    'LatexFormatter': ('pygments.formatters.latex', 'LaTeX', ('latex', 'tex'), ('*.tex',), 'Format tokens as LaTeX code. This needs the `fancyvrb` and `color` standard packages.'),",
            "    'NullFormatter': ('pygments.formatters.other', 'Text only', ('text', 'null'), ('*.txt',), 'Output the text unchanged without any formatting.'),",
            "    'RawTokenFormatter': ('pygments.formatters.other', 'Raw tokens', ('raw', 'tokens'), ('*.raw',), 'Format tokens as a raw representation for storing token streams.'),",
            "    'RtfFormatter': ('pygments.formatters.rtf', 'RTF', ('rtf',), ('*.rtf',), 'Format tokens as RTF markup. This formatter automatically outputs full RTF documents with color information and other useful stuff. Perfect for Copy and Paste into Microsoft(R) Word(R) documents.'),",
            "    'SvgFormatter': ('pygments.formatters.svg', 'SVG', ('svg',), ('*.svg',), 'Format tokens as an SVG graphics file.  This formatter is still experimental. Each line of code is a ``<text>`` element with explicit ``x`` and ``y`` coordinates containing ``<tspan>`` elements with the individual token styles.'),",
            "    'Terminal256Formatter': ('pygments.formatters.terminal256', 'Terminal256', ('terminal256', 'console256', '256'), (), 'Format tokens with ANSI color sequences, for output in a 256-color terminal or console. Like in `TerminalFormatter` color sequences are terminated at newlines, so that paging the output works correctly.'),",
            "    'TerminalFormatter': ('pygments.formatters.terminal', 'Terminal', ('terminal', 'console'), (), 'Format tokens with ANSI color sequences, for output in a text console. Color sequences are terminated at newlines, so that paging the output works correctly.'),",
            "    'TestcaseFormatter': ('pygments.formatters.other', 'Testcase', ('testcase',), (), 'Format tokens as appropriate for a new testcase.')",
            "}",
            "",
            "if __name__ == '__main__':  # pragma: no cover",
            "    import sys",
            "    import os",
            "",
            "    # lookup formatters",
            "    found_formatters = []",
            "    imports = []",
            "    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))",
            "    from pygments.util import docstring_headline",
            "",
            "    for root, dirs, files in os.walk('.'):",
            "        for filename in files:",
            "            if filename.endswith('.py') and not filename.startswith('_'):",
            "                module_name = 'pygments.formatters%s.%s' % (",
            "                    root[1:].replace('/', '.'), filename[:-3])",
            "                print(module_name)",
            "                module = __import__(module_name, None, None, [''])",
            "                for formatter_name in module.__all__:",
            "                    formatter = getattr(module, formatter_name)",
            "                    found_formatters.append(",
            "                        '%r: %r' % (formatter_name,",
            "                                    (module_name,",
            "                                     formatter.name,",
            "                                     tuple(formatter.aliases),",
            "                                     tuple(formatter.filenames),",
            "                                     docstring_headline(formatter))))",
            "    # sort them to make the diff minimal",
            "    found_formatters.sort()",
            "",
            "    # extract useful sourcecode from this file",
            "    with open(__file__) as fp:",
            "        content = fp.read()",
            "    header = content[:content.find('FORMATTERS = {')]",
            "    footer = content[content.find(\"if __name__ == '__main__':\"):]",
            "",
            "    # write new file",
            "    with open(__file__, 'w') as fp:",
            "        fp.write(header)",
            "        fp.write('FORMATTERS = {\\n    %s\\n}\\n\\n' % ',\\n    '.join(found_formatters))",
            "        fp.write(footer)",
            "",
            "    print ('=== %d formatters processed.' % len(found_formatters))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "pygments/formatters/html.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     When `tagsfile` is set to the path of a ctags index file, it is used to"
            },
            "2": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "     generate hyperlinks from names to their definition.  You must enable"
            },
            "3": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    `anchorlines` and run ctags with the `-n` option for this to work.  The"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    `lineanchors` and run ctags with the `-n` option for this to work.  The"
            },
            "5": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     `python-ctags` module from PyPI must be installed to use this feature;"
            },
            "6": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     otherwise a `RuntimeError` will be raised."
            },
            "7": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.formatters.html",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Formatter for HTML output.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "from __future__ import print_function",
            "",
            "import os",
            "import sys",
            "import os.path",
            "",
            "from pygments.formatter import Formatter",
            "from pygments.token import Token, Text, STANDARD_TYPES",
            "from pygments.util import get_bool_opt, get_int_opt, get_list_opt, \\",
            "    StringIO, string_types, iteritems",
            "",
            "try:",
            "    import ctags",
            "except ImportError:",
            "    ctags = None",
            "",
            "__all__ = ['HtmlFormatter']",
            "",
            "",
            "_escape_html_table = {",
            "    ord('&'): u'&amp;',",
            "    ord('<'): u'&lt;',",
            "    ord('>'): u'&gt;',",
            "    ord('\"'): u'&quot;',",
            "    ord(\"'\"): u'&#39;',",
            "}",
            "",
            "",
            "def escape_html(text, table=_escape_html_table):",
            "    \"\"\"Escape &, <, > as well as single and double quotes for HTML.\"\"\"",
            "    return text.translate(table)",
            "",
            "",
            "def _get_ttype_class(ttype):",
            "    fname = STANDARD_TYPES.get(ttype)",
            "    if fname:",
            "        return fname",
            "    aname = ''",
            "    while fname is None:",
            "        aname = '-' + ttype[-1] + aname",
            "        ttype = ttype.parent",
            "        fname = STANDARD_TYPES.get(ttype)",
            "    return fname + aname",
            "",
            "",
            "CSSFILE_TEMPLATE = '''\\",
            "td.linenos { background-color: #f0f0f0; padding-right: 10px; }",
            "span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }",
            "pre { line-height: 125%%; }",
            "%(styledefs)s",
            "'''",
            "",
            "DOC_HEADER = '''\\",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"",
            "   \"http://www.w3.org/TR/html4/strict.dtd\">",
            "",
            "<html>",
            "<head>",
            "  <title>%(title)s</title>",
            "  <meta http-equiv=\"content-type\" content=\"text/html; charset=%(encoding)s\">",
            "  <style type=\"text/css\">",
            "''' + CSSFILE_TEMPLATE + '''",
            "  </style>",
            "</head>",
            "<body>",
            "<h2>%(title)s</h2>",
            "",
            "'''",
            "",
            "DOC_HEADER_EXTERNALCSS = '''\\",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"",
            "   \"http://www.w3.org/TR/html4/strict.dtd\">",
            "",
            "<html>",
            "<head>",
            "  <title>%(title)s</title>",
            "  <meta http-equiv=\"content-type\" content=\"text/html; charset=%(encoding)s\">",
            "  <link rel=\"stylesheet\" href=\"%(cssfile)s\" type=\"text/css\">",
            "</head>",
            "<body>",
            "<h2>%(title)s</h2>",
            "",
            "'''",
            "",
            "DOC_FOOTER = '''\\",
            "</body>",
            "</html>",
            "'''",
            "",
            "",
            "class HtmlFormatter(Formatter):",
            "    r\"\"\"",
            "    Format tokens as HTML 4 ``<span>`` tags within a ``<pre>`` tag, wrapped",
            "    in a ``<div>`` tag. The ``<div>``'s CSS class can be set by the `cssclass`",
            "    option.",
            "",
            "    If the `linenos` option is set to ``\"table\"``, the ``<pre>`` is",
            "    additionally wrapped inside a ``<table>`` which has one row and two",
            "    cells: one containing the line numbers and one containing the code.",
            "    Example:",
            "",
            "    .. sourcecode:: html",
            "",
            "        <div class=\"highlight\" >",
            "        <table><tr>",
            "          <td class=\"linenos\" title=\"click to toggle\"",
            "            onclick=\"with (this.firstChild.style)",
            "                     { display = (display == '') ? 'none' : '' }\">",
            "            <pre>1",
            "            2</pre>",
            "          </td>",
            "          <td class=\"code\">",
            "            <pre><span class=\"Ke\">def </span><span class=\"NaFu\">foo</span>(bar):",
            "              <span class=\"Ke\">pass</span>",
            "            </pre>",
            "          </td>",
            "        </tr></table></div>",
            "",
            "    (whitespace added to improve clarity).",
            "",
            "    Wrapping can be disabled using the `nowrap` option.",
            "",
            "    A list of lines can be specified using the `hl_lines` option to make these",
            "    lines highlighted (as of Pygments 0.11).",
            "",
            "    With the `full` option, a complete HTML 4 document is output, including",
            "    the style definitions inside a ``<style>`` tag, or in a separate file if",
            "    the `cssfile` option is given.",
            "",
            "    When `tagsfile` is set to the path of a ctags index file, it is used to",
            "    generate hyperlinks from names to their definition.  You must enable",
            "    `anchorlines` and run ctags with the `-n` option for this to work.  The",
            "    `python-ctags` module from PyPI must be installed to use this feature;",
            "    otherwise a `RuntimeError` will be raised.",
            "",
            "    The `get_style_defs(arg='')` method of a `HtmlFormatter` returns a string",
            "    containing CSS rules for the CSS classes used by the formatter. The",
            "    argument `arg` can be used to specify additional CSS selectors that",
            "    are prepended to the classes. A call `fmter.get_style_defs('td .code')`",
            "    would result in the following CSS classes:",
            "",
            "    .. sourcecode:: css",
            "",
            "        td .code .kw { font-weight: bold; color: #00FF00 }",
            "        td .code .cm { color: #999999 }",
            "        ...",
            "",
            "    If you have Pygments 0.6 or higher, you can also pass a list or tuple to the",
            "    `get_style_defs()` method to request multiple prefixes for the tokens:",
            "",
            "    .. sourcecode:: python",
            "",
            "        formatter.get_style_defs(['div.syntax pre', 'pre.syntax'])",
            "",
            "    The output would then look like this:",
            "",
            "    .. sourcecode:: css",
            "",
            "        div.syntax pre .kw,",
            "        pre.syntax .kw { font-weight: bold; color: #00FF00 }",
            "        div.syntax pre .cm,",
            "        pre.syntax .cm { color: #999999 }",
            "        ...",
            "",
            "    Additional options accepted:",
            "",
            "    `nowrap`",
            "        If set to ``True``, don't wrap the tokens at all, not even inside a ``<pre>``",
            "        tag. This disables most other options (default: ``False``).",
            "",
            "    `full`",
            "        Tells the formatter to output a \"full\" document, i.e. a complete",
            "        self-contained document (default: ``False``).",
            "",
            "    `title`",
            "        If `full` is true, the title that should be used to caption the",
            "        document (default: ``''``).",
            "",
            "    `style`",
            "        The style to use, can be a string or a Style subclass (default:",
            "        ``'default'``). This option has no effect if the `cssfile`",
            "        and `noclobber_cssfile` option are given and the file specified in",
            "        `cssfile` exists.",
            "",
            "    `noclasses`",
            "        If set to true, token ``<span>`` tags will not use CSS classes, but",
            "        inline styles. This is not recommended for larger pieces of code since",
            "        it increases output size by quite a bit (default: ``False``).",
            "",
            "    `classprefix`",
            "        Since the token types use relatively short class names, they may clash",
            "        with some of your own class names. In this case you can use the",
            "        `classprefix` option to give a string to prepend to all Pygments-generated",
            "        CSS class names for token types.",
            "        Note that this option also affects the output of `get_style_defs()`.",
            "",
            "    `cssclass`",
            "        CSS class for the wrapping ``<div>`` tag (default: ``'highlight'``).",
            "        If you set this option, the default selector for `get_style_defs()`",
            "        will be this class.",
            "",
            "        .. versionadded:: 0.9",
            "           If you select the ``'table'`` line numbers, the wrapping table will",
            "           have a CSS class of this string plus ``'table'``, the default is",
            "           accordingly ``'highlighttable'``.",
            "",
            "    `cssstyles`",
            "        Inline CSS styles for the wrapping ``<div>`` tag (default: ``''``).",
            "",
            "    `prestyles`",
            "        Inline CSS styles for the ``<pre>`` tag (default: ``''``).",
            "",
            "        .. versionadded:: 0.11",
            "",
            "    `cssfile`",
            "        If the `full` option is true and this option is given, it must be the",
            "        name of an external file. If the filename does not include an absolute",
            "        path, the file's path will be assumed to be relative to the main output",
            "        file's path, if the latter can be found. The stylesheet is then written",
            "        to this file instead of the HTML file.",
            "",
            "        .. versionadded:: 0.6",
            "",
            "    `noclobber_cssfile`",
            "        If `cssfile` is given and the specified file exists, the css file will",
            "        not be overwritten. This allows the use of the `full` option in",
            "        combination with a user specified css file. Default is ``False``.",
            "",
            "        .. versionadded:: 1.1",
            "",
            "    `linenos`",
            "        If set to ``'table'``, output line numbers as a table with two cells,",
            "        one containing the line numbers, the other the whole code.  This is",
            "        copy-and-paste-friendly, but may cause alignment problems with some",
            "        browsers or fonts.  If set to ``'inline'``, the line numbers will be",
            "        integrated in the ``<pre>`` tag that contains the code (that setting",
            "        is *new in Pygments 0.8*).",
            "",
            "        For compatibility with Pygments 0.7 and earlier, every true value",
            "        except ``'inline'`` means the same as ``'table'`` (in particular, that",
            "        means also ``True``).",
            "",
            "        The default value is ``False``, which means no line numbers at all.",
            "",
            "        **Note:** with the default (\"table\") line number mechanism, the line",
            "        numbers and code can have different line heights in Internet Explorer",
            "        unless you give the enclosing ``<pre>`` tags an explicit ``line-height``",
            "        CSS property (you get the default line spacing with ``line-height:",
            "        125%``).",
            "",
            "    `hl_lines`",
            "        Specify a list of lines to be highlighted.",
            "",
            "        .. versionadded:: 0.11",
            "",
            "    `linenostart`",
            "        The line number for the first line (default: ``1``).",
            "",
            "    `linenostep`",
            "        If set to a number n > 1, only every nth line number is printed.",
            "",
            "    `linenospecial`",
            "        If set to a number n > 0, every nth line number is given the CSS",
            "        class ``\"special\"`` (default: ``0``).",
            "",
            "    `nobackground`",
            "        If set to ``True``, the formatter won't output the background color",
            "        for the wrapping element (this automatically defaults to ``False``",
            "        when there is no wrapping element [eg: no argument for the",
            "        `get_syntax_defs` method given]) (default: ``False``).",
            "",
            "        .. versionadded:: 0.6",
            "",
            "    `lineseparator`",
            "        This string is output between lines of code. It defaults to ``\"\\n\"``,",
            "        which is enough to break a line inside ``<pre>`` tags, but you can",
            "        e.g. set it to ``\"<br>\"`` to get HTML line breaks.",
            "",
            "        .. versionadded:: 0.7",
            "",
            "    `lineanchors`",
            "        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each",
            "        output line in an anchor tag with a ``name`` of ``foo-linenumber``.",
            "        This allows easy linking to certain lines.",
            "",
            "        .. versionadded:: 0.9",
            "",
            "    `linespans`",
            "        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each",
            "        output line in a span tag with an ``id`` of ``foo-linenumber``.",
            "        This allows easy access to lines via javascript.",
            "",
            "        .. versionadded:: 1.6",
            "",
            "    `anchorlinenos`",
            "        If set to `True`, will wrap line numbers in <a> tags. Used in",
            "        combination with `linenos` and `lineanchors`.",
            "",
            "    `tagsfile`",
            "        If set to the path of a ctags file, wrap names in anchor tags that",
            "        link to their definitions. `lineanchors` should be used, and the",
            "        tags file should specify line numbers (see the `-n` option to ctags).",
            "",
            "        .. versionadded:: 1.6",
            "",
            "    `tagurlformat`",
            "        A string formatting pattern used to generate links to ctags definitions.",
            "        Available variables are `%(path)s`, `%(fname)s` and `%(fext)s`.",
            "        Defaults to an empty string, resulting in just `#prefix-number` links.",
            "",
            "        .. versionadded:: 1.6",
            "",
            "",
            "    **Subclassing the HTML formatter**",
            "",
            "    .. versionadded:: 0.7",
            "",
            "    The HTML formatter is now built in a way that allows easy subclassing, thus",
            "    customizing the output HTML code. The `format()` method calls",
            "    `self._format_lines()` which returns a generator that yields tuples of ``(1,",
            "    line)``, where the ``1`` indicates that the ``line`` is a line of the",
            "    formatted source code.",
            "",
            "    If the `nowrap` option is set, the generator is the iterated over and the",
            "    resulting HTML is output.",
            "",
            "    Otherwise, `format()` calls `self.wrap()`, which wraps the generator with",
            "    other generators. These may add some HTML code to the one generated by",
            "    `_format_lines()`, either by modifying the lines generated by the latter,",
            "    then yielding them again with ``(1, line)``, and/or by yielding other HTML",
            "    code before or after the lines, with ``(0, html)``. The distinction between",
            "    source lines and other code makes it possible to wrap the generator multiple",
            "    times.",
            "",
            "    The default `wrap()` implementation adds a ``<div>`` and a ``<pre>`` tag.",
            "",
            "    A custom `HtmlFormatter` subclass could look like this:",
            "",
            "    .. sourcecode:: python",
            "",
            "        class CodeHtmlFormatter(HtmlFormatter):",
            "",
            "            def wrap(self, source, outfile):",
            "                return self._wrap_code(source)",
            "",
            "            def _wrap_code(self, source):",
            "                yield 0, '<code>'",
            "                for i, t in source:",
            "                    if i == 1:",
            "                        # it's a line of formatted code",
            "                        t += '<br>'",
            "                    yield i, t",
            "                yield 0, '</code>'",
            "",
            "    This results in wrapping the formatted lines with a ``<code>`` tag, where the",
            "    source lines are broken using ``<br>`` tags.",
            "",
            "    After calling `wrap()`, the `format()` method also adds the \"line numbers\"",
            "    and/or \"full document\" wrappers if the respective options are set. Then, all",
            "    HTML yielded by the wrapped generator is output.",
            "    \"\"\"",
            "",
            "    name = 'HTML'",
            "    aliases = ['html']",
            "    filenames = ['*.html', '*.htm']",
            "",
            "    def __init__(self, **options):",
            "        Formatter.__init__(self, **options)",
            "        self.title = self._decodeifneeded(self.title)",
            "        self.nowrap = get_bool_opt(options, 'nowrap', False)",
            "        self.noclasses = get_bool_opt(options, 'noclasses', False)",
            "        self.classprefix = options.get('classprefix', '')",
            "        self.cssclass = self._decodeifneeded(options.get('cssclass', 'highlight'))",
            "        self.cssstyles = self._decodeifneeded(options.get('cssstyles', ''))",
            "        self.prestyles = self._decodeifneeded(options.get('prestyles', ''))",
            "        self.cssfile = self._decodeifneeded(options.get('cssfile', ''))",
            "        self.noclobber_cssfile = get_bool_opt(options, 'noclobber_cssfile', False)",
            "        self.tagsfile = self._decodeifneeded(options.get('tagsfile', ''))",
            "        self.tagurlformat = self._decodeifneeded(options.get('tagurlformat', ''))",
            "",
            "        if self.tagsfile:",
            "            if not ctags:",
            "                raise RuntimeError('The \"ctags\" package must to be installed '",
            "                                   'to be able to use the \"tagsfile\" feature.')",
            "            self._ctags = ctags.CTags(self.tagsfile)",
            "",
            "        linenos = options.get('linenos', False)",
            "        if linenos == 'inline':",
            "            self.linenos = 2",
            "        elif linenos:",
            "            # compatibility with <= 0.7",
            "            self.linenos = 1",
            "        else:",
            "            self.linenos = 0",
            "        self.linenostart = abs(get_int_opt(options, 'linenostart', 1))",
            "        self.linenostep = abs(get_int_opt(options, 'linenostep', 1))",
            "        self.linenospecial = abs(get_int_opt(options, 'linenospecial', 0))",
            "        self.nobackground = get_bool_opt(options, 'nobackground', False)",
            "        self.lineseparator = options.get('lineseparator', '\\n')",
            "        self.lineanchors = options.get('lineanchors', '')",
            "        self.linespans = options.get('linespans', '')",
            "        self.anchorlinenos = options.get('anchorlinenos', False)",
            "        self.hl_lines = set()",
            "        for lineno in get_list_opt(options, 'hl_lines', []):",
            "            try:",
            "                self.hl_lines.add(int(lineno))",
            "            except ValueError:",
            "                pass",
            "",
            "        self._create_stylesheet()",
            "",
            "    def _get_css_class(self, ttype):",
            "        \"\"\"Return the css class of this token type prefixed with",
            "        the classprefix option.\"\"\"",
            "        ttypeclass = _get_ttype_class(ttype)",
            "        if ttypeclass:",
            "            return self.classprefix + ttypeclass",
            "        return ''",
            "",
            "    def _get_css_classes(self, ttype):",
            "        \"\"\"Return the css classes of this token type prefixed with",
            "        the classprefix option.\"\"\"",
            "        cls = self._get_css_class(ttype)",
            "        while ttype not in STANDARD_TYPES:",
            "            ttype = ttype.parent",
            "            cls = self._get_css_class(ttype) + ' ' + cls",
            "        return cls",
            "",
            "    def _create_stylesheet(self):",
            "        t2c = self.ttype2class = {Token: ''}",
            "        c2s = self.class2style = {}",
            "        for ttype, ndef in self.style:",
            "            name = self._get_css_class(ttype)",
            "            style = ''",
            "            if ndef['color']:",
            "                style += 'color: #%s; ' % ndef['color']",
            "            if ndef['bold']:",
            "                style += 'font-weight: bold; '",
            "            if ndef['italic']:",
            "                style += 'font-style: italic; '",
            "            if ndef['underline']:",
            "                style += 'text-decoration: underline; '",
            "            if ndef['bgcolor']:",
            "                style += 'background-color: #%s; ' % ndef['bgcolor']",
            "            if ndef['border']:",
            "                style += 'border: 1px solid #%s; ' % ndef['border']",
            "            if style:",
            "                t2c[ttype] = name",
            "                # save len(ttype) to enable ordering the styles by",
            "                # hierarchy (necessary for CSS cascading rules!)",
            "                c2s[name] = (style[:-2], ttype, len(ttype))",
            "",
            "    def get_style_defs(self, arg=None):",
            "        \"\"\"",
            "        Return CSS style definitions for the classes produced by the current",
            "        highlighting style. ``arg`` can be a string or list of selectors to",
            "        insert before the token type classes.",
            "        \"\"\"",
            "        if arg is None:",
            "            arg = ('cssclass' in self.options and '.'+self.cssclass or '')",
            "        if isinstance(arg, string_types):",
            "            args = [arg]",
            "        else:",
            "            args = list(arg)",
            "",
            "        def prefix(cls):",
            "            if cls:",
            "                cls = '.' + cls",
            "            tmp = []",
            "            for arg in args:",
            "                tmp.append((arg and arg + ' ' or '') + cls)",
            "            return ', '.join(tmp)",
            "",
            "        styles = [(level, ttype, cls, style)",
            "                  for cls, (style, ttype, level) in iteritems(self.class2style)",
            "                  if cls and style]",
            "        styles.sort()",
            "        lines = ['%s { %s } /* %s */' % (prefix(cls), style, repr(ttype)[6:])",
            "                 for (level, ttype, cls, style) in styles]",
            "        if arg and not self.nobackground and \\",
            "           self.style.background_color is not None:",
            "            text_style = ''",
            "            if Text in self.ttype2class:",
            "                text_style = ' ' + self.class2style[self.ttype2class[Text]][0]",
            "            lines.insert(0, '%s { background: %s;%s }' %",
            "                         (prefix(''), self.style.background_color, text_style))",
            "        if self.style.highlight_color is not None:",
            "            lines.insert(0, '%s.hll { background-color: %s }' %",
            "                         (prefix(''), self.style.highlight_color))",
            "        return '\\n'.join(lines)",
            "",
            "    def _decodeifneeded(self, value):",
            "        if isinstance(value, bytes):",
            "            if self.encoding:",
            "                return value.decode(self.encoding)",
            "            return value.decode()",
            "        return value",
            "",
            "    def _wrap_full(self, inner, outfile):",
            "        if self.cssfile:",
            "            if os.path.isabs(self.cssfile):",
            "                # it's an absolute filename",
            "                cssfilename = self.cssfile",
            "            else:",
            "                try:",
            "                    filename = outfile.name",
            "                    if not filename or filename[0] == '<':",
            "                        # pseudo files, e.g. name == '<fdopen>'",
            "                        raise AttributeError",
            "                    cssfilename = os.path.join(os.path.dirname(filename),",
            "                                               self.cssfile)",
            "                except AttributeError:",
            "                    print('Note: Cannot determine output file name, ' \\",
            "                          'using current directory as base for the CSS file name',",
            "                          file=sys.stderr)",
            "                    cssfilename = self.cssfile",
            "            # write CSS file only if noclobber_cssfile isn't given as an option.",
            "            try:",
            "                if not os.path.exists(cssfilename) or not self.noclobber_cssfile:",
            "                    cf = open(cssfilename, \"w\")",
            "                    cf.write(CSSFILE_TEMPLATE %",
            "                            {'styledefs': self.get_style_defs('body')})",
            "                    cf.close()",
            "            except IOError as err:",
            "                err.strerror = 'Error writing CSS file: ' + err.strerror",
            "                raise",
            "",
            "            yield 0, (DOC_HEADER_EXTERNALCSS %",
            "                      dict(title     = self.title,",
            "                           cssfile   = self.cssfile,",
            "                           encoding  = self.encoding))",
            "        else:",
            "            yield 0, (DOC_HEADER %",
            "                      dict(title     = self.title,",
            "                           styledefs = self.get_style_defs('body'),",
            "                           encoding  = self.encoding))",
            "",
            "        for t, line in inner:",
            "            yield t, line",
            "        yield 0, DOC_FOOTER",
            "",
            "    def _wrap_tablelinenos(self, inner):",
            "        dummyoutfile = StringIO()",
            "        lncount = 0",
            "        for t, line in inner:",
            "            if t:",
            "                lncount += 1",
            "            dummyoutfile.write(line)",
            "",
            "        fl = self.linenostart",
            "        mw = len(str(lncount + fl - 1))",
            "        sp = self.linenospecial",
            "        st = self.linenostep",
            "        la = self.lineanchors",
            "        aln = self.anchorlinenos",
            "        nocls = self.noclasses",
            "        if sp:",
            "            lines = []",
            "",
            "            for i in range(fl, fl+lncount):",
            "                if i % st == 0:",
            "                    if i % sp == 0:",
            "                        if aln:",
            "                            lines.append('<a href=\"#%s-%d\" class=\"special\">%*d</a>' %",
            "                                         (la, i, mw, i))",
            "                        else:",
            "                            lines.append('<span class=\"special\">%*d</span>' % (mw, i))",
            "                    else:",
            "                        if aln:",
            "                            lines.append('<a href=\"#%s-%d\">%*d</a>' % (la, i, mw, i))",
            "                        else:",
            "                            lines.append('%*d' % (mw, i))",
            "                else:",
            "                    lines.append('')",
            "            ls = '\\n'.join(lines)",
            "        else:",
            "            lines = []",
            "            for i in range(fl, fl+lncount):",
            "                if i % st == 0:",
            "                    if aln:",
            "                        lines.append('<a href=\"#%s-%d\">%*d</a>' % (la, i, mw, i))",
            "                    else:",
            "                        lines.append('%*d' % (mw, i))",
            "                else:",
            "                    lines.append('')",
            "            ls = '\\n'.join(lines)",
            "",
            "        # in case you wonder about the seemingly redundant <div> here: since the",
            "        # content in the other cell also is wrapped in a div, some browsers in",
            "        # some configurations seem to mess up the formatting...",
            "        if nocls:",
            "            yield 0, ('<table class=\"%stable\">' % self.cssclass +",
            "                      '<tr><td><div class=\"linenodiv\" '",
            "                      'style=\"background-color: #f0f0f0; padding-right: 10px\">'",
            "                      '<pre style=\"line-height: 125%\">' +",
            "                      ls + '</pre></div></td><td class=\"code\">')",
            "        else:",
            "            yield 0, ('<table class=\"%stable\">' % self.cssclass +",
            "                      '<tr><td class=\"linenos\"><div class=\"linenodiv\"><pre>' +",
            "                      ls + '</pre></div></td><td class=\"code\">')",
            "        yield 0, dummyoutfile.getvalue()",
            "        yield 0, '</td></tr></table>'",
            "",
            "    def _wrap_inlinelinenos(self, inner):",
            "        # need a list of lines since we need the width of a single number :(",
            "        lines = list(inner)",
            "        sp = self.linenospecial",
            "        st = self.linenostep",
            "        num = self.linenostart",
            "        mw = len(str(len(lines) + num - 1))",
            "",
            "        if self.noclasses:",
            "            if sp:",
            "                for t, line in lines:",
            "                    if num%sp == 0:",
            "                        style = 'background-color: #ffffc0; padding: 0 5px 0 5px'",
            "                    else:",
            "                        style = 'background-color: #f0f0f0; padding: 0 5px 0 5px'",
            "                    yield 1, '<span style=\"%s\">%*s </span>' % (",
            "                        style, mw, (num%st and ' ' or num)) + line",
            "                    num += 1",
            "            else:",
            "                for t, line in lines:",
            "                    yield 1, ('<span style=\"background-color: #f0f0f0; '",
            "                              'padding: 0 5px 0 5px\">%*s </span>' % (",
            "                              mw, (num%st and ' ' or num)) + line)",
            "                    num += 1",
            "        elif sp:",
            "            for t, line in lines:",
            "                yield 1, '<span class=\"lineno%s\">%*s </span>' % (",
            "                    num%sp == 0 and ' special' or '', mw,",
            "                    (num%st and ' ' or num)) + line",
            "                num += 1",
            "        else:",
            "            for t, line in lines:",
            "                yield 1, '<span class=\"lineno\">%*s </span>' % (",
            "                    mw, (num%st and ' ' or num)) + line",
            "                num += 1",
            "",
            "    def _wrap_lineanchors(self, inner):",
            "        s = self.lineanchors",
            "        i = self.linenostart - 1 # subtract 1 since we have to increment i",
            "                                 # *before* yielding",
            "        for t, line in inner:",
            "            if t:",
            "                i += 1",
            "                yield 1, '<a name=\"%s-%d\"></a>' % (s, i) + line",
            "            else:",
            "                yield 0, line",
            "",
            "    def _wrap_linespans(self, inner):",
            "        s = self.linespans",
            "        i = self.linenostart - 1",
            "        for t, line in inner:",
            "            if t:",
            "                i += 1",
            "                yield 1, '<span id=\"%s-%d\">%s</span>' % (s, i, line)",
            "            else:",
            "                yield 0, line",
            "",
            "    def _wrap_div(self, inner):",
            "        style = []",
            "        if (self.noclasses and not self.nobackground and",
            "            self.style.background_color is not None):",
            "            style.append('background: %s' % (self.style.background_color,))",
            "        if self.cssstyles:",
            "            style.append(self.cssstyles)",
            "        style = '; '.join(style)",
            "",
            "        yield 0, ('<div' + (self.cssclass and ' class=\"%s\"' % self.cssclass)",
            "                  + (style and (' style=\"%s\"' % style)) + '>')",
            "        for tup in inner:",
            "            yield tup",
            "        yield 0, '</div>\\n'",
            "",
            "    def _wrap_pre(self, inner):",
            "        style = []",
            "        if self.prestyles:",
            "            style.append(self.prestyles)",
            "        if self.noclasses:",
            "            style.append('line-height: 125%')",
            "        style = '; '.join(style)",
            "",
            "        yield 0, ('<pre' + (style and ' style=\"%s\"' % style) + '>')",
            "        for tup in inner:",
            "            yield tup",
            "        yield 0, '</pre>'",
            "",
            "    def _format_lines(self, tokensource):",
            "        \"\"\"",
            "        Just format the tokens, without any wrapping tags.",
            "        Yield individual lines.",
            "        \"\"\"",
            "        nocls = self.noclasses",
            "        lsep = self.lineseparator",
            "        # for <span style=\"\"> lookup only",
            "        getcls = self.ttype2class.get",
            "        c2s = self.class2style",
            "        escape_table = _escape_html_table",
            "        tagsfile = self.tagsfile",
            "",
            "        lspan = ''",
            "        line = ''",
            "        for ttype, value in tokensource:",
            "            if nocls:",
            "                cclass = getcls(ttype)",
            "                while cclass is None:",
            "                    ttype = ttype.parent",
            "                    cclass = getcls(ttype)",
            "                cspan = cclass and '<span style=\"%s\">' % c2s[cclass][0] or ''",
            "            else:",
            "                cls = self._get_css_classes(ttype)",
            "                cspan = cls and '<span class=\"%s\">' % cls or ''",
            "",
            "            parts = value.translate(escape_table).split('\\n')",
            "",
            "            if tagsfile and ttype in Token.Name:",
            "                filename, linenumber = self._lookup_ctag(value)",
            "                if linenumber:",
            "                    base, filename = os.path.split(filename)",
            "                    if base:",
            "                        base += '/'",
            "                    filename, extension = os.path.splitext(filename)",
            "                    url = self.tagurlformat % {'path': base, 'fname': filename,",
            "                                               'fext': extension}",
            "                    parts[0] = \"<a href=\\\"%s#%s-%d\\\">%s\" % \\",
            "                        (url, self.lineanchors, linenumber, parts[0])",
            "                    parts[-1] = parts[-1] + \"</a>\"",
            "",
            "            # for all but the last line",
            "            for part in parts[:-1]:",
            "                if line:",
            "                    if lspan != cspan:",
            "                        line += (lspan and '</span>') + cspan + part + \\",
            "                                (cspan and '</span>') + lsep",
            "                    else: # both are the same",
            "                        line += part + (lspan and '</span>') + lsep",
            "                    yield 1, line",
            "                    line = ''",
            "                elif part:",
            "                    yield 1, cspan + part + (cspan and '</span>') + lsep",
            "                else:",
            "                    yield 1, lsep",
            "            # for the last line",
            "            if line and parts[-1]:",
            "                if lspan != cspan:",
            "                    line += (lspan and '</span>') + cspan + parts[-1]",
            "                    lspan = cspan",
            "                else:",
            "                    line += parts[-1]",
            "            elif parts[-1]:",
            "                line = cspan + parts[-1]",
            "                lspan = cspan",
            "            # else we neither have to open a new span nor set lspan",
            "",
            "        if line:",
            "            yield 1, line + (lspan and '</span>') + lsep",
            "",
            "    def _lookup_ctag(self, token):",
            "        entry = ctags.TagEntry()",
            "        if self._ctags.find(entry, token, 0):",
            "            return entry['file'], entry['lineNumber']",
            "        else:",
            "            return None, None",
            "",
            "    def _highlight_lines(self, tokensource):",
            "        \"\"\"",
            "        Highlighted the lines specified in the `hl_lines` option by",
            "        post-processing the token stream coming from `_format_lines`.",
            "        \"\"\"",
            "        hls = self.hl_lines",
            "",
            "        for i, (t, value) in enumerate(tokensource):",
            "            if t != 1:",
            "                yield t, value",
            "            if i + 1 in hls: # i + 1 because Python indexes start at 0",
            "                if self.noclasses:",
            "                    style = ''",
            "                    if self.style.highlight_color is not None:",
            "                        style = (' style=\"background-color: %s\"' %",
            "                                 (self.style.highlight_color,))",
            "                    yield 1, '<span%s>%s</span>' % (style, value)",
            "                else:",
            "                    yield 1, '<span class=\"hll\">%s</span>' % value",
            "            else:",
            "                yield 1, value",
            "",
            "    def wrap(self, source, outfile):",
            "        \"\"\"",
            "        Wrap the ``source``, which is a generator yielding",
            "        individual lines, in custom generators. See docstring",
            "        for `format`. Can be overridden.",
            "        \"\"\"",
            "        return self._wrap_div(self._wrap_pre(source))",
            "",
            "    def format_unencoded(self, tokensource, outfile):",
            "        \"\"\"",
            "        The formatting process uses several nested generators; which of",
            "        them are used is determined by the user's options.",
            "",
            "        Each generator should take at least one argument, ``inner``,",
            "        and wrap the pieces of text generated by this.",
            "",
            "        Always yield 2-tuples: (code, text). If \"code\" is 1, the text",
            "        is part of the original tokensource being highlighted, if it's",
            "        0, the text is some piece of wrapping. This makes it possible to",
            "        use several different wrappers that process the original source",
            "        linewise, e.g. line number generators.",
            "        \"\"\"",
            "        source = self._format_lines(tokensource)",
            "        if self.hl_lines:",
            "            source = self._highlight_lines(source)",
            "        if not self.nowrap:",
            "            if self.linenos == 2:",
            "                source = self._wrap_inlinelinenos(source)",
            "            if self.lineanchors:",
            "                source = self._wrap_lineanchors(source)",
            "            if self.linespans:",
            "                source = self._wrap_linespans(source)",
            "            source = self.wrap(source, outfile)",
            "            if self.linenos == 1:",
            "                source = self._wrap_tablelinenos(source)",
            "            if self.full:",
            "                source = self._wrap_full(source, outfile)",
            "",
            "        for t, piece in source:",
            "            outfile.write(piece)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "\"\"\"",
            "    pygments.formatters.html",
            "    ~~~~~~~~~~~~~~~~~~~~~~~~",
            "",
            "    Formatter for HTML output.",
            "",
            "    :copyright: Copyright 2006-2015 by the Pygments team, see AUTHORS.",
            "    :license: BSD, see LICENSE for details.",
            "\"\"\"",
            "",
            "from __future__ import print_function",
            "",
            "import os",
            "import sys",
            "import os.path",
            "",
            "from pygments.formatter import Formatter",
            "from pygments.token import Token, Text, STANDARD_TYPES",
            "from pygments.util import get_bool_opt, get_int_opt, get_list_opt, \\",
            "    StringIO, string_types, iteritems",
            "",
            "try:",
            "    import ctags",
            "except ImportError:",
            "    ctags = None",
            "",
            "__all__ = ['HtmlFormatter']",
            "",
            "",
            "_escape_html_table = {",
            "    ord('&'): u'&amp;',",
            "    ord('<'): u'&lt;',",
            "    ord('>'): u'&gt;',",
            "    ord('\"'): u'&quot;',",
            "    ord(\"'\"): u'&#39;',",
            "}",
            "",
            "",
            "def escape_html(text, table=_escape_html_table):",
            "    \"\"\"Escape &, <, > as well as single and double quotes for HTML.\"\"\"",
            "    return text.translate(table)",
            "",
            "",
            "def _get_ttype_class(ttype):",
            "    fname = STANDARD_TYPES.get(ttype)",
            "    if fname:",
            "        return fname",
            "    aname = ''",
            "    while fname is None:",
            "        aname = '-' + ttype[-1] + aname",
            "        ttype = ttype.parent",
            "        fname = STANDARD_TYPES.get(ttype)",
            "    return fname + aname",
            "",
            "",
            "CSSFILE_TEMPLATE = '''\\",
            "td.linenos { background-color: #f0f0f0; padding-right: 10px; }",
            "span.lineno { background-color: #f0f0f0; padding: 0 5px 0 5px; }",
            "pre { line-height: 125%%; }",
            "%(styledefs)s",
            "'''",
            "",
            "DOC_HEADER = '''\\",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"",
            "   \"http://www.w3.org/TR/html4/strict.dtd\">",
            "",
            "<html>",
            "<head>",
            "  <title>%(title)s</title>",
            "  <meta http-equiv=\"content-type\" content=\"text/html; charset=%(encoding)s\">",
            "  <style type=\"text/css\">",
            "''' + CSSFILE_TEMPLATE + '''",
            "  </style>",
            "</head>",
            "<body>",
            "<h2>%(title)s</h2>",
            "",
            "'''",
            "",
            "DOC_HEADER_EXTERNALCSS = '''\\",
            "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\"",
            "   \"http://www.w3.org/TR/html4/strict.dtd\">",
            "",
            "<html>",
            "<head>",
            "  <title>%(title)s</title>",
            "  <meta http-equiv=\"content-type\" content=\"text/html; charset=%(encoding)s\">",
            "  <link rel=\"stylesheet\" href=\"%(cssfile)s\" type=\"text/css\">",
            "</head>",
            "<body>",
            "<h2>%(title)s</h2>",
            "",
            "'''",
            "",
            "DOC_FOOTER = '''\\",
            "</body>",
            "</html>",
            "'''",
            "",
            "",
            "class HtmlFormatter(Formatter):",
            "    r\"\"\"",
            "    Format tokens as HTML 4 ``<span>`` tags within a ``<pre>`` tag, wrapped",
            "    in a ``<div>`` tag. The ``<div>``'s CSS class can be set by the `cssclass`",
            "    option.",
            "",
            "    If the `linenos` option is set to ``\"table\"``, the ``<pre>`` is",
            "    additionally wrapped inside a ``<table>`` which has one row and two",
            "    cells: one containing the line numbers and one containing the code.",
            "    Example:",
            "",
            "    .. sourcecode:: html",
            "",
            "        <div class=\"highlight\" >",
            "        <table><tr>",
            "          <td class=\"linenos\" title=\"click to toggle\"",
            "            onclick=\"with (this.firstChild.style)",
            "                     { display = (display == '') ? 'none' : '' }\">",
            "            <pre>1",
            "            2</pre>",
            "          </td>",
            "          <td class=\"code\">",
            "            <pre><span class=\"Ke\">def </span><span class=\"NaFu\">foo</span>(bar):",
            "              <span class=\"Ke\">pass</span>",
            "            </pre>",
            "          </td>",
            "        </tr></table></div>",
            "",
            "    (whitespace added to improve clarity).",
            "",
            "    Wrapping can be disabled using the `nowrap` option.",
            "",
            "    A list of lines can be specified using the `hl_lines` option to make these",
            "    lines highlighted (as of Pygments 0.11).",
            "",
            "    With the `full` option, a complete HTML 4 document is output, including",
            "    the style definitions inside a ``<style>`` tag, or in a separate file if",
            "    the `cssfile` option is given.",
            "",
            "    When `tagsfile` is set to the path of a ctags index file, it is used to",
            "    generate hyperlinks from names to their definition.  You must enable",
            "    `lineanchors` and run ctags with the `-n` option for this to work.  The",
            "    `python-ctags` module from PyPI must be installed to use this feature;",
            "    otherwise a `RuntimeError` will be raised.",
            "",
            "    The `get_style_defs(arg='')` method of a `HtmlFormatter` returns a string",
            "    containing CSS rules for the CSS classes used by the formatter. The",
            "    argument `arg` can be used to specify additional CSS selectors that",
            "    are prepended to the classes. A call `fmter.get_style_defs('td .code')`",
            "    would result in the following CSS classes:",
            "",
            "    .. sourcecode:: css",
            "",
            "        td .code .kw { font-weight: bold; color: #00FF00 }",
            "        td .code .cm { color: #999999 }",
            "        ...",
            "",
            "    If you have Pygments 0.6 or higher, you can also pass a list or tuple to the",
            "    `get_style_defs()` method to request multiple prefixes for the tokens:",
            "",
            "    .. sourcecode:: python",
            "",
            "        formatter.get_style_defs(['div.syntax pre', 'pre.syntax'])",
            "",
            "    The output would then look like this:",
            "",
            "    .. sourcecode:: css",
            "",
            "        div.syntax pre .kw,",
            "        pre.syntax .kw { font-weight: bold; color: #00FF00 }",
            "        div.syntax pre .cm,",
            "        pre.syntax .cm { color: #999999 }",
            "        ...",
            "",
            "    Additional options accepted:",
            "",
            "    `nowrap`",
            "        If set to ``True``, don't wrap the tokens at all, not even inside a ``<pre>``",
            "        tag. This disables most other options (default: ``False``).",
            "",
            "    `full`",
            "        Tells the formatter to output a \"full\" document, i.e. a complete",
            "        self-contained document (default: ``False``).",
            "",
            "    `title`",
            "        If `full` is true, the title that should be used to caption the",
            "        document (default: ``''``).",
            "",
            "    `style`",
            "        The style to use, can be a string or a Style subclass (default:",
            "        ``'default'``). This option has no effect if the `cssfile`",
            "        and `noclobber_cssfile` option are given and the file specified in",
            "        `cssfile` exists.",
            "",
            "    `noclasses`",
            "        If set to true, token ``<span>`` tags will not use CSS classes, but",
            "        inline styles. This is not recommended for larger pieces of code since",
            "        it increases output size by quite a bit (default: ``False``).",
            "",
            "    `classprefix`",
            "        Since the token types use relatively short class names, they may clash",
            "        with some of your own class names. In this case you can use the",
            "        `classprefix` option to give a string to prepend to all Pygments-generated",
            "        CSS class names for token types.",
            "        Note that this option also affects the output of `get_style_defs()`.",
            "",
            "    `cssclass`",
            "        CSS class for the wrapping ``<div>`` tag (default: ``'highlight'``).",
            "        If you set this option, the default selector for `get_style_defs()`",
            "        will be this class.",
            "",
            "        .. versionadded:: 0.9",
            "           If you select the ``'table'`` line numbers, the wrapping table will",
            "           have a CSS class of this string plus ``'table'``, the default is",
            "           accordingly ``'highlighttable'``.",
            "",
            "    `cssstyles`",
            "        Inline CSS styles for the wrapping ``<div>`` tag (default: ``''``).",
            "",
            "    `prestyles`",
            "        Inline CSS styles for the ``<pre>`` tag (default: ``''``).",
            "",
            "        .. versionadded:: 0.11",
            "",
            "    `cssfile`",
            "        If the `full` option is true and this option is given, it must be the",
            "        name of an external file. If the filename does not include an absolute",
            "        path, the file's path will be assumed to be relative to the main output",
            "        file's path, if the latter can be found. The stylesheet is then written",
            "        to this file instead of the HTML file.",
            "",
            "        .. versionadded:: 0.6",
            "",
            "    `noclobber_cssfile`",
            "        If `cssfile` is given and the specified file exists, the css file will",
            "        not be overwritten. This allows the use of the `full` option in",
            "        combination with a user specified css file. Default is ``False``.",
            "",
            "        .. versionadded:: 1.1",
            "",
            "    `linenos`",
            "        If set to ``'table'``, output line numbers as a table with two cells,",
            "        one containing the line numbers, the other the whole code.  This is",
            "        copy-and-paste-friendly, but may cause alignment problems with some",
            "        browsers or fonts.  If set to ``'inline'``, the line numbers will be",
            "        integrated in the ``<pre>`` tag that contains the code (that setting",
            "        is *new in Pygments 0.8*).",
            "",
            "        For compatibility with Pygments 0.7 and earlier, every true value",
            "        except ``'inline'`` means the same as ``'table'`` (in particular, that",
            "        means also ``True``).",
            "",
            "        The default value is ``False``, which means no line numbers at all.",
            "",
            "        **Note:** with the default (\"table\") line number mechanism, the line",
            "        numbers and code can have different line heights in Internet Explorer",
            "        unless you give the enclosing ``<pre>`` tags an explicit ``line-height``",
            "        CSS property (you get the default line spacing with ``line-height:",
            "        125%``).",
            "",
            "    `hl_lines`",
            "        Specify a list of lines to be highlighted.",
            "",
            "        .. versionadded:: 0.11",
            "",
            "    `linenostart`",
            "        The line number for the first line (default: ``1``).",
            "",
            "    `linenostep`",
            "        If set to a number n > 1, only every nth line number is printed.",
            "",
            "    `linenospecial`",
            "        If set to a number n > 0, every nth line number is given the CSS",
            "        class ``\"special\"`` (default: ``0``).",
            "",
            "    `nobackground`",
            "        If set to ``True``, the formatter won't output the background color",
            "        for the wrapping element (this automatically defaults to ``False``",
            "        when there is no wrapping element [eg: no argument for the",
            "        `get_syntax_defs` method given]) (default: ``False``).",
            "",
            "        .. versionadded:: 0.6",
            "",
            "    `lineseparator`",
            "        This string is output between lines of code. It defaults to ``\"\\n\"``,",
            "        which is enough to break a line inside ``<pre>`` tags, but you can",
            "        e.g. set it to ``\"<br>\"`` to get HTML line breaks.",
            "",
            "        .. versionadded:: 0.7",
            "",
            "    `lineanchors`",
            "        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each",
            "        output line in an anchor tag with a ``name`` of ``foo-linenumber``.",
            "        This allows easy linking to certain lines.",
            "",
            "        .. versionadded:: 0.9",
            "",
            "    `linespans`",
            "        If set to a nonempty string, e.g. ``foo``, the formatter will wrap each",
            "        output line in a span tag with an ``id`` of ``foo-linenumber``.",
            "        This allows easy access to lines via javascript.",
            "",
            "        .. versionadded:: 1.6",
            "",
            "    `anchorlinenos`",
            "        If set to `True`, will wrap line numbers in <a> tags. Used in",
            "        combination with `linenos` and `lineanchors`.",
            "",
            "    `tagsfile`",
            "        If set to the path of a ctags file, wrap names in anchor tags that",
            "        link to their definitions. `lineanchors` should be used, and the",
            "        tags file should specify line numbers (see the `-n` option to ctags).",
            "",
            "        .. versionadded:: 1.6",
            "",
            "    `tagurlformat`",
            "        A string formatting pattern used to generate links to ctags definitions.",
            "        Available variables are `%(path)s`, `%(fname)s` and `%(fext)s`.",
            "        Defaults to an empty string, resulting in just `#prefix-number` links.",
            "",
            "        .. versionadded:: 1.6",
            "",
            "",
            "    **Subclassing the HTML formatter**",
            "",
            "    .. versionadded:: 0.7",
            "",
            "    The HTML formatter is now built in a way that allows easy subclassing, thus",
            "    customizing the output HTML code. The `format()` method calls",
            "    `self._format_lines()` which returns a generator that yields tuples of ``(1,",
            "    line)``, where the ``1`` indicates that the ``line`` is a line of the",
            "    formatted source code.",
            "",
            "    If the `nowrap` option is set, the generator is the iterated over and the",
            "    resulting HTML is output.",
            "",
            "    Otherwise, `format()` calls `self.wrap()`, which wraps the generator with",
            "    other generators. These may add some HTML code to the one generated by",
            "    `_format_lines()`, either by modifying the lines generated by the latter,",
            "    then yielding them again with ``(1, line)``, and/or by yielding other HTML",
            "    code before or after the lines, with ``(0, html)``. The distinction between",
            "    source lines and other code makes it possible to wrap the generator multiple",
            "    times.",
            "",
            "    The default `wrap()` implementation adds a ``<div>`` and a ``<pre>`` tag.",
            "",
            "    A custom `HtmlFormatter` subclass could look like this:",
            "",
            "    .. sourcecode:: python",
            "",
            "        class CodeHtmlFormatter(HtmlFormatter):",
            "",
            "            def wrap(self, source, outfile):",
            "                return self._wrap_code(source)",
            "",
            "            def _wrap_code(self, source):",
            "                yield 0, '<code>'",
            "                for i, t in source:",
            "                    if i == 1:",
            "                        # it's a line of formatted code",
            "                        t += '<br>'",
            "                    yield i, t",
            "                yield 0, '</code>'",
            "",
            "    This results in wrapping the formatted lines with a ``<code>`` tag, where the",
            "    source lines are broken using ``<br>`` tags.",
            "",
            "    After calling `wrap()`, the `format()` method also adds the \"line numbers\"",
            "    and/or \"full document\" wrappers if the respective options are set. Then, all",
            "    HTML yielded by the wrapped generator is output.",
            "    \"\"\"",
            "",
            "    name = 'HTML'",
            "    aliases = ['html']",
            "    filenames = ['*.html', '*.htm']",
            "",
            "    def __init__(self, **options):",
            "        Formatter.__init__(self, **options)",
            "        self.title = self._decodeifneeded(self.title)",
            "        self.nowrap = get_bool_opt(options, 'nowrap', False)",
            "        self.noclasses = get_bool_opt(options, 'noclasses', False)",
            "        self.classprefix = options.get('classprefix', '')",
            "        self.cssclass = self._decodeifneeded(options.get('cssclass', 'highlight'))",
            "        self.cssstyles = self._decodeifneeded(options.get('cssstyles', ''))",
            "        self.prestyles = self._decodeifneeded(options.get('prestyles', ''))",
            "        self.cssfile = self._decodeifneeded(options.get('cssfile', ''))",
            "        self.noclobber_cssfile = get_bool_opt(options, 'noclobber_cssfile', False)",
            "        self.tagsfile = self._decodeifneeded(options.get('tagsfile', ''))",
            "        self.tagurlformat = self._decodeifneeded(options.get('tagurlformat', ''))",
            "",
            "        if self.tagsfile:",
            "            if not ctags:",
            "                raise RuntimeError('The \"ctags\" package must to be installed '",
            "                                   'to be able to use the \"tagsfile\" feature.')",
            "            self._ctags = ctags.CTags(self.tagsfile)",
            "",
            "        linenos = options.get('linenos', False)",
            "        if linenos == 'inline':",
            "            self.linenos = 2",
            "        elif linenos:",
            "            # compatibility with <= 0.7",
            "            self.linenos = 1",
            "        else:",
            "            self.linenos = 0",
            "        self.linenostart = abs(get_int_opt(options, 'linenostart', 1))",
            "        self.linenostep = abs(get_int_opt(options, 'linenostep', 1))",
            "        self.linenospecial = abs(get_int_opt(options, 'linenospecial', 0))",
            "        self.nobackground = get_bool_opt(options, 'nobackground', False)",
            "        self.lineseparator = options.get('lineseparator', '\\n')",
            "        self.lineanchors = options.get('lineanchors', '')",
            "        self.linespans = options.get('linespans', '')",
            "        self.anchorlinenos = options.get('anchorlinenos', False)",
            "        self.hl_lines = set()",
            "        for lineno in get_list_opt(options, 'hl_lines', []):",
            "            try:",
            "                self.hl_lines.add(int(lineno))",
            "            except ValueError:",
            "                pass",
            "",
            "        self._create_stylesheet()",
            "",
            "    def _get_css_class(self, ttype):",
            "        \"\"\"Return the css class of this token type prefixed with",
            "        the classprefix option.\"\"\"",
            "        ttypeclass = _get_ttype_class(ttype)",
            "        if ttypeclass:",
            "            return self.classprefix + ttypeclass",
            "        return ''",
            "",
            "    def _get_css_classes(self, ttype):",
            "        \"\"\"Return the css classes of this token type prefixed with",
            "        the classprefix option.\"\"\"",
            "        cls = self._get_css_class(ttype)",
            "        while ttype not in STANDARD_TYPES:",
            "            ttype = ttype.parent",
            "            cls = self._get_css_class(ttype) + ' ' + cls",
            "        return cls",
            "",
            "    def _create_stylesheet(self):",
            "        t2c = self.ttype2class = {Token: ''}",
            "        c2s = self.class2style = {}",
            "        for ttype, ndef in self.style:",
            "            name = self._get_css_class(ttype)",
            "            style = ''",
            "            if ndef['color']:",
            "                style += 'color: #%s; ' % ndef['color']",
            "            if ndef['bold']:",
            "                style += 'font-weight: bold; '",
            "            if ndef['italic']:",
            "                style += 'font-style: italic; '",
            "            if ndef['underline']:",
            "                style += 'text-decoration: underline; '",
            "            if ndef['bgcolor']:",
            "                style += 'background-color: #%s; ' % ndef['bgcolor']",
            "            if ndef['border']:",
            "                style += 'border: 1px solid #%s; ' % ndef['border']",
            "            if style:",
            "                t2c[ttype] = name",
            "                # save len(ttype) to enable ordering the styles by",
            "                # hierarchy (necessary for CSS cascading rules!)",
            "                c2s[name] = (style[:-2], ttype, len(ttype))",
            "",
            "    def get_style_defs(self, arg=None):",
            "        \"\"\"",
            "        Return CSS style definitions for the classes produced by the current",
            "        highlighting style. ``arg`` can be a string or list of selectors to",
            "        insert before the token type classes.",
            "        \"\"\"",
            "        if arg is None:",
            "            arg = ('cssclass' in self.options and '.'+self.cssclass or '')",
            "        if isinstance(arg, string_types):",
            "            args = [arg]",
            "        else:",
            "            args = list(arg)",
            "",
            "        def prefix(cls):",
            "            if cls:",
            "                cls = '.' + cls",
            "            tmp = []",
            "            for arg in args:",
            "                tmp.append((arg and arg + ' ' or '') + cls)",
            "            return ', '.join(tmp)",
            "",
            "        styles = [(level, ttype, cls, style)",
            "                  for cls, (style, ttype, level) in iteritems(self.class2style)",
            "                  if cls and style]",
            "        styles.sort()",
            "        lines = ['%s { %s } /* %s */' % (prefix(cls), style, repr(ttype)[6:])",
            "                 for (level, ttype, cls, style) in styles]",
            "        if arg and not self.nobackground and \\",
            "           self.style.background_color is not None:",
            "            text_style = ''",
            "            if Text in self.ttype2class:",
            "                text_style = ' ' + self.class2style[self.ttype2class[Text]][0]",
            "            lines.insert(0, '%s { background: %s;%s }' %",
            "                         (prefix(''), self.style.background_color, text_style))",
            "        if self.style.highlight_color is not None:",
            "            lines.insert(0, '%s.hll { background-color: %s }' %",
            "                         (prefix(''), self.style.highlight_color))",
            "        return '\\n'.join(lines)",
            "",
            "    def _decodeifneeded(self, value):",
            "        if isinstance(value, bytes):",
            "            if self.encoding:",
            "                return value.decode(self.encoding)",
            "            return value.decode()",
            "        return value",
            "",
            "    def _wrap_full(self, inner, outfile):",
            "        if self.cssfile:",
            "            if os.path.isabs(self.cssfile):",
            "                # it's an absolute filename",
            "                cssfilename = self.cssfile",
            "            else:",
            "                try:",
            "                    filename = outfile.name",
            "                    if not filename or filename[0] == '<':",
            "                        # pseudo files, e.g. name == '<fdopen>'",
            "                        raise AttributeError",
            "                    cssfilename = os.path.join(os.path.dirname(filename),",
            "                                               self.cssfile)",
            "                except AttributeError:",
            "                    print('Note: Cannot determine output file name, ' \\",
            "                          'using current directory as base for the CSS file name',",
            "                          file=sys.stderr)",
            "                    cssfilename = self.cssfile",
            "            # write CSS file only if noclobber_cssfile isn't given as an option.",
            "            try:",
            "                if not os.path.exists(cssfilename) or not self.noclobber_cssfile:",
            "                    cf = open(cssfilename, \"w\")",
            "                    cf.write(CSSFILE_TEMPLATE %",
            "                            {'styledefs': self.get_style_defs('body')})",
            "                    cf.close()",
            "            except IOError as err:",
            "                err.strerror = 'Error writing CSS file: ' + err.strerror",
            "                raise",
            "",
            "            yield 0, (DOC_HEADER_EXTERNALCSS %",
            "                      dict(title     = self.title,",
            "                           cssfile   = self.cssfile,",
            "                           encoding  = self.encoding))",
            "        else:",
            "            yield 0, (DOC_HEADER %",
            "                      dict(title     = self.title,",
            "                           styledefs = self.get_style_defs('body'),",
            "                           encoding  = self.encoding))",
            "",
            "        for t, line in inner:",
            "            yield t, line",
            "        yield 0, DOC_FOOTER",
            "",
            "    def _wrap_tablelinenos(self, inner):",
            "        dummyoutfile = StringIO()",
            "        lncount = 0",
            "        for t, line in inner:",
            "            if t:",
            "                lncount += 1",
            "            dummyoutfile.write(line)",
            "",
            "        fl = self.linenostart",
            "        mw = len(str(lncount + fl - 1))",
            "        sp = self.linenospecial",
            "        st = self.linenostep",
            "        la = self.lineanchors",
            "        aln = self.anchorlinenos",
            "        nocls = self.noclasses",
            "        if sp:",
            "            lines = []",
            "",
            "            for i in range(fl, fl+lncount):",
            "                if i % st == 0:",
            "                    if i % sp == 0:",
            "                        if aln:",
            "                            lines.append('<a href=\"#%s-%d\" class=\"special\">%*d</a>' %",
            "                                         (la, i, mw, i))",
            "                        else:",
            "                            lines.append('<span class=\"special\">%*d</span>' % (mw, i))",
            "                    else:",
            "                        if aln:",
            "                            lines.append('<a href=\"#%s-%d\">%*d</a>' % (la, i, mw, i))",
            "                        else:",
            "                            lines.append('%*d' % (mw, i))",
            "                else:",
            "                    lines.append('')",
            "            ls = '\\n'.join(lines)",
            "        else:",
            "            lines = []",
            "            for i in range(fl, fl+lncount):",
            "                if i % st == 0:",
            "                    if aln:",
            "                        lines.append('<a href=\"#%s-%d\">%*d</a>' % (la, i, mw, i))",
            "                    else:",
            "                        lines.append('%*d' % (mw, i))",
            "                else:",
            "                    lines.append('')",
            "            ls = '\\n'.join(lines)",
            "",
            "        # in case you wonder about the seemingly redundant <div> here: since the",
            "        # content in the other cell also is wrapped in a div, some browsers in",
            "        # some configurations seem to mess up the formatting...",
            "        if nocls:",
            "            yield 0, ('<table class=\"%stable\">' % self.cssclass +",
            "                      '<tr><td><div class=\"linenodiv\" '",
            "                      'style=\"background-color: #f0f0f0; padding-right: 10px\">'",
            "                      '<pre style=\"line-height: 125%\">' +",
            "                      ls + '</pre></div></td><td class=\"code\">')",
            "        else:",
            "            yield 0, ('<table class=\"%stable\">' % self.cssclass +",
            "                      '<tr><td class=\"linenos\"><div class=\"linenodiv\"><pre>' +",
            "                      ls + '</pre></div></td><td class=\"code\">')",
            "        yield 0, dummyoutfile.getvalue()",
            "        yield 0, '</td></tr></table>'",
            "",
            "    def _wrap_inlinelinenos(self, inner):",
            "        # need a list of lines since we need the width of a single number :(",
            "        lines = list(inner)",
            "        sp = self.linenospecial",
            "        st = self.linenostep",
            "        num = self.linenostart",
            "        mw = len(str(len(lines) + num - 1))",
            "",
            "        if self.noclasses:",
            "            if sp:",
            "                for t, line in lines:",
            "                    if num%sp == 0:",
            "                        style = 'background-color: #ffffc0; padding: 0 5px 0 5px'",
            "                    else:",
            "                        style = 'background-color: #f0f0f0; padding: 0 5px 0 5px'",
            "                    yield 1, '<span style=\"%s\">%*s </span>' % (",
            "                        style, mw, (num%st and ' ' or num)) + line",
            "                    num += 1",
            "            else:",
            "                for t, line in lines:",
            "                    yield 1, ('<span style=\"background-color: #f0f0f0; '",
            "                              'padding: 0 5px 0 5px\">%*s </span>' % (",
            "                              mw, (num%st and ' ' or num)) + line)",
            "                    num += 1",
            "        elif sp:",
            "            for t, line in lines:",
            "                yield 1, '<span class=\"lineno%s\">%*s </span>' % (",
            "                    num%sp == 0 and ' special' or '', mw,",
            "                    (num%st and ' ' or num)) + line",
            "                num += 1",
            "        else:",
            "            for t, line in lines:",
            "                yield 1, '<span class=\"lineno\">%*s </span>' % (",
            "                    mw, (num%st and ' ' or num)) + line",
            "                num += 1",
            "",
            "    def _wrap_lineanchors(self, inner):",
            "        s = self.lineanchors",
            "        i = self.linenostart - 1 # subtract 1 since we have to increment i",
            "                                 # *before* yielding",
            "        for t, line in inner:",
            "            if t:",
            "                i += 1",
            "                yield 1, '<a name=\"%s-%d\"></a>' % (s, i) + line",
            "            else:",
            "                yield 0, line",
            "",
            "    def _wrap_linespans(self, inner):",
            "        s = self.linespans",
            "        i = self.linenostart - 1",
            "        for t, line in inner:",
            "            if t:",
            "                i += 1",
            "                yield 1, '<span id=\"%s-%d\">%s</span>' % (s, i, line)",
            "            else:",
            "                yield 0, line",
            "",
            "    def _wrap_div(self, inner):",
            "        style = []",
            "        if (self.noclasses and not self.nobackground and",
            "            self.style.background_color is not None):",
            "            style.append('background: %s' % (self.style.background_color,))",
            "        if self.cssstyles:",
            "            style.append(self.cssstyles)",
            "        style = '; '.join(style)",
            "",
            "        yield 0, ('<div' + (self.cssclass and ' class=\"%s\"' % self.cssclass)",
            "                  + (style and (' style=\"%s\"' % style)) + '>')",
            "        for tup in inner:",
            "            yield tup",
            "        yield 0, '</div>\\n'",
            "",
            "    def _wrap_pre(self, inner):",
            "        style = []",
            "        if self.prestyles:",
            "            style.append(self.prestyles)",
            "        if self.noclasses:",
            "            style.append('line-height: 125%')",
            "        style = '; '.join(style)",
            "",
            "        yield 0, ('<pre' + (style and ' style=\"%s\"' % style) + '>')",
            "        for tup in inner:",
            "            yield tup",
            "        yield 0, '</pre>'",
            "",
            "    def _format_lines(self, tokensource):",
            "        \"\"\"",
            "        Just format the tokens, without any wrapping tags.",
            "        Yield individual lines.",
            "        \"\"\"",
            "        nocls = self.noclasses",
            "        lsep = self.lineseparator",
            "        # for <span style=\"\"> lookup only",
            "        getcls = self.ttype2class.get",
            "        c2s = self.class2style",
            "        escape_table = _escape_html_table",
            "        tagsfile = self.tagsfile",
            "",
            "        lspan = ''",
            "        line = ''",
            "        for ttype, value in tokensource:",
            "            if nocls:",
            "                cclass = getcls(ttype)",
            "                while cclass is None:",
            "                    ttype = ttype.parent",
            "                    cclass = getcls(ttype)",
            "                cspan = cclass and '<span style=\"%s\">' % c2s[cclass][0] or ''",
            "            else:",
            "                cls = self._get_css_classes(ttype)",
            "                cspan = cls and '<span class=\"%s\">' % cls or ''",
            "",
            "            parts = value.translate(escape_table).split('\\n')",
            "",
            "            if tagsfile and ttype in Token.Name:",
            "                filename, linenumber = self._lookup_ctag(value)",
            "                if linenumber:",
            "                    base, filename = os.path.split(filename)",
            "                    if base:",
            "                        base += '/'",
            "                    filename, extension = os.path.splitext(filename)",
            "                    url = self.tagurlformat % {'path': base, 'fname': filename,",
            "                                               'fext': extension}",
            "                    parts[0] = \"<a href=\\\"%s#%s-%d\\\">%s\" % \\",
            "                        (url, self.lineanchors, linenumber, parts[0])",
            "                    parts[-1] = parts[-1] + \"</a>\"",
            "",
            "            # for all but the last line",
            "            for part in parts[:-1]:",
            "                if line:",
            "                    if lspan != cspan:",
            "                        line += (lspan and '</span>') + cspan + part + \\",
            "                                (cspan and '</span>') + lsep",
            "                    else: # both are the same",
            "                        line += part + (lspan and '</span>') + lsep",
            "                    yield 1, line",
            "                    line = ''",
            "                elif part:",
            "                    yield 1, cspan + part + (cspan and '</span>') + lsep",
            "                else:",
            "                    yield 1, lsep",
            "            # for the last line",
            "            if line and parts[-1]:",
            "                if lspan != cspan:",
            "                    line += (lspan and '</span>') + cspan + parts[-1]",
            "                    lspan = cspan",
            "                else:",
            "                    line += parts[-1]",
            "            elif parts[-1]:",
            "                line = cspan + parts[-1]",
            "                lspan = cspan",
            "            # else we neither have to open a new span nor set lspan",
            "",
            "        if line:",
            "            yield 1, line + (lspan and '</span>') + lsep",
            "",
            "    def _lookup_ctag(self, token):",
            "        entry = ctags.TagEntry()",
            "        if self._ctags.find(entry, token, 0):",
            "            return entry['file'], entry['lineNumber']",
            "        else:",
            "            return None, None",
            "",
            "    def _highlight_lines(self, tokensource):",
            "        \"\"\"",
            "        Highlighted the lines specified in the `hl_lines` option by",
            "        post-processing the token stream coming from `_format_lines`.",
            "        \"\"\"",
            "        hls = self.hl_lines",
            "",
            "        for i, (t, value) in enumerate(tokensource):",
            "            if t != 1:",
            "                yield t, value",
            "            if i + 1 in hls: # i + 1 because Python indexes start at 0",
            "                if self.noclasses:",
            "                    style = ''",
            "                    if self.style.highlight_color is not None:",
            "                        style = (' style=\"background-color: %s\"' %",
            "                                 (self.style.highlight_color,))",
            "                    yield 1, '<span%s>%s</span>' % (style, value)",
            "                else:",
            "                    yield 1, '<span class=\"hll\">%s</span>' % value",
            "            else:",
            "                yield 1, value",
            "",
            "    def wrap(self, source, outfile):",
            "        \"\"\"",
            "        Wrap the ``source``, which is a generator yielding",
            "        individual lines, in custom generators. See docstring",
            "        for `format`. Can be overridden.",
            "        \"\"\"",
            "        return self._wrap_div(self._wrap_pre(source))",
            "",
            "    def format_unencoded(self, tokensource, outfile):",
            "        \"\"\"",
            "        The formatting process uses several nested generators; which of",
            "        them are used is determined by the user's options.",
            "",
            "        Each generator should take at least one argument, ``inner``,",
            "        and wrap the pieces of text generated by this.",
            "",
            "        Always yield 2-tuples: (code, text). If \"code\" is 1, the text",
            "        is part of the original tokensource being highlighted, if it's",
            "        0, the text is some piece of wrapping. This makes it possible to",
            "        use several different wrappers that process the original source",
            "        linewise, e.g. line number generators.",
            "        \"\"\"",
            "        source = self._format_lines(tokensource)",
            "        if self.hl_lines:",
            "            source = self._highlight_lines(source)",
            "        if not self.nowrap:",
            "            if self.linenos == 2:",
            "                source = self._wrap_inlinelinenos(source)",
            "            if self.lineanchors:",
            "                source = self._wrap_lineanchors(source)",
            "            if self.linespans:",
            "                source = self._wrap_linespans(source)",
            "            source = self.wrap(source, outfile)",
            "            if self.linenos == 1:",
            "                source = self._wrap_tablelinenos(source)",
            "            if self.full:",
            "                source = self._wrap_full(source, outfile)",
            "",
            "        for t, piece in source:",
            "            outfile.write(piece)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "143": [
                "HtmlFormatter"
            ]
        },
        "addLocation": []
    }
}