{
    "src/fides/api/db/database.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     directory = path.join(migrations_dir, \"../alembic/migrations\")"
            },
            "1": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     config = Config(path.join(migrations_dir, \"../alembic/alembic.ini\"))"
            },
            "2": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     config.set_main_option(\"script_location\", directory.replace(\"%\", \"%%\"))"
            },
            "3": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    config.set_main_option(\"sqlalchemy.url\", database_url)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+    # Avoids invalid interpolation syntax errors if % in string"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    config.set_main_option(\"sqlalchemy.url\", database_url.replace(\"%\", \"%%\"))"
            },
            "6": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     return config"
            },
            "7": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Contains all of the logic related to the database including connections, setup, teardown, etc.",
            "\"\"\"",
            "",
            "from os import path",
            "from typing import Literal, Optional, Tuple",
            "",
            "from alembic import command, script",
            "from alembic.config import Config",
            "from alembic.runtime import migration",
            "from loguru import logger as log",
            "from sqlalchemy.orm import Session",
            "from sqlalchemy_utils.functions import create_database, database_exists",
            "from sqlalchemy_utils.types.encrypted.encrypted_type import InvalidCiphertextError",
            "",
            "from fides.api.db.base import Base  # type: ignore[attr-defined]",
            "from fides.api.db.ctl_session import async_session",
            "from fides.api.db.seed import load_default_resources, load_samples",
            "from fides.api.util.errors import get_full_exception_name",
            "from fides.core.utils import get_db_engine",
            "",
            "DatabaseHealth = Literal[\"healthy\", \"unhealthy\", \"needs migration\"]",
            "",
            "",
            "def get_alembic_config(database_url: str) -> Config:",
            "    \"\"\"",
            "    Do lots of magic to make alembic work programmatically from the CLI.",
            "    \"\"\"",
            "",
            "    migrations_dir = path.dirname(path.abspath(__file__))",
            "    directory = path.join(migrations_dir, \"../alembic/migrations\")",
            "    config = Config(path.join(migrations_dir, \"../alembic/alembic.ini\"))",
            "    config.set_main_option(\"script_location\", directory.replace(\"%\", \"%%\"))",
            "    config.set_main_option(\"sqlalchemy.url\", database_url)",
            "    return config",
            "",
            "",
            "def upgrade_db(alembic_config: Config, revision: str = \"head\") -> None:",
            "    \"\"\"Upgrade the database to the specified migration revision.\"\"\"",
            "    log.info(f\"Running database upgrade to revision {revision}\")",
            "    command.upgrade(alembic_config, revision)",
            "",
            "",
            "def downgrade_db(alembic_config: Config, revision: str = \"head\") -> None:",
            "    \"\"\"Downgrade the database to the specified migration revision.\"\"\"",
            "    log.info(f\"Running database downgrade to revision {revision}\")",
            "    command.downgrade(alembic_config, revision)",
            "",
            "",
            "async def migrate_db(",
            "    database_url: str,",
            "    samples: bool = False,",
            "    revision: str = \"head\",",
            "    downgrade: bool = False,",
            ") -> None:",
            "    \"\"\"",
            "    Runs migrations and creates database objects if needed.",
            "",
            "    Safe to run on an existing database when upgrading Fides version.",
            "    \"\"\"",
            "    log.info(\"Migrating database\")",
            "    alembic_config = get_alembic_config(database_url)",
            "    if downgrade:",
            "        downgrade_db(alembic_config, revision)",
            "    else:",
            "        upgrade_db(alembic_config, revision)",
            "",
            "        async with async_session() as session:",
            "            await load_default_resources(session)",
            "            if samples:",
            "                await load_samples(session)",
            "",
            "",
            "def create_db_if_not_exists(database_url: str) -> None:",
            "    \"\"\"",
            "    Creates a database which does not exist already.",
            "    \"\"\"",
            "    if not database_exists(database_url):",
            "        create_database(database_url)",
            "",
            "",
            "def reset_db(database_url: str) -> None:",
            "    \"\"\"",
            "    Drops all tables/metadata from the database.",
            "    \"\"\"",
            "    log.info(\"Resetting database...\")",
            "    engine = get_db_engine(database_url)",
            "    with engine.connect() as connection:",
            "        log.info(\"Dropping tables...\")",
            "        Base.metadata.drop_all(connection)",
            "",
            "        log.info(\"Dropping Alembic table...\")",
            "        migration_context = migration.MigrationContext.configure(connection)",
            "        version = migration_context._version  # pylint: disable=protected-access",
            "        if version.exists(connection):",
            "            version.drop(connection)",
            "    log.info(\"Reset complete.\")",
            "",
            "",
            "def get_db_health(",
            "    database_url: str, db: Session",
            ") -> Tuple[DatabaseHealth, Optional[str]]:",
            "    \"\"\"Checks if the db is reachable and up-to-date with Alembic migrations.\"\"\"",
            "    try:",
            "        alembic_config = get_alembic_config(database_url)",
            "        alembic_script_directory = script.ScriptDirectory.from_config(alembic_config)",
            "        context = migration.MigrationContext.configure(db.connection())",
            "        current_revision = context.get_current_revision()",
            "        if (",
            "            context.get_current_revision()",
            "            != alembic_script_directory.get_current_head()",
            "        ):",
            "            db_health: DatabaseHealth = \"needs migration\"",
            "        else:",
            "            db_health = \"healthy\"",
            "        return db_health, current_revision",
            "    except Exception as error:  # pylint: disable=broad-except",
            "        error_type = get_full_exception_name(error)",
            "        log.error(\"Unable to reach the database: {}: {}\", error_type, error)",
            "        return (\"unhealthy\", None)",
            "",
            "",
            "async def configure_db(",
            "    database_url: str, samples: bool = False, revision: Optional[str] = \"head\"",
            ") -> None:",
            "    \"\"\"Set up the db to be used by the app.\"\"\"",
            "    try:",
            "        create_db_if_not_exists(database_url)",
            "        await migrate_db(database_url, samples=samples, revision=revision)  # type: ignore[arg-type]",
            "    except InvalidCiphertextError as cipher_error:",
            "        log.error(",
            "            \"Unable to configure database due to a decryption error! Check to ensure your `app_encryption_key` has not changed.\"",
            "        )",
            "        log.opt(exception=True).error(cipher_error)",
            "",
            "    except Exception as error:  # pylint: disable=broad-except",
            "        error_type = get_full_exception_name(error)",
            "        log.error(\"Unable to configure database: {}: {}\", error_type, error)",
            "        log.opt(exception=True).error(error)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Contains all of the logic related to the database including connections, setup, teardown, etc.",
            "\"\"\"",
            "",
            "from os import path",
            "from typing import Literal, Optional, Tuple",
            "",
            "from alembic import command, script",
            "from alembic.config import Config",
            "from alembic.runtime import migration",
            "from loguru import logger as log",
            "from sqlalchemy.orm import Session",
            "from sqlalchemy_utils.functions import create_database, database_exists",
            "from sqlalchemy_utils.types.encrypted.encrypted_type import InvalidCiphertextError",
            "",
            "from fides.api.db.base import Base  # type: ignore[attr-defined]",
            "from fides.api.db.ctl_session import async_session",
            "from fides.api.db.seed import load_default_resources, load_samples",
            "from fides.api.util.errors import get_full_exception_name",
            "from fides.core.utils import get_db_engine",
            "",
            "DatabaseHealth = Literal[\"healthy\", \"unhealthy\", \"needs migration\"]",
            "",
            "",
            "def get_alembic_config(database_url: str) -> Config:",
            "    \"\"\"",
            "    Do lots of magic to make alembic work programmatically from the CLI.",
            "    \"\"\"",
            "",
            "    migrations_dir = path.dirname(path.abspath(__file__))",
            "    directory = path.join(migrations_dir, \"../alembic/migrations\")",
            "    config = Config(path.join(migrations_dir, \"../alembic/alembic.ini\"))",
            "    config.set_main_option(\"script_location\", directory.replace(\"%\", \"%%\"))",
            "    # Avoids invalid interpolation syntax errors if % in string",
            "    config.set_main_option(\"sqlalchemy.url\", database_url.replace(\"%\", \"%%\"))",
            "    return config",
            "",
            "",
            "def upgrade_db(alembic_config: Config, revision: str = \"head\") -> None:",
            "    \"\"\"Upgrade the database to the specified migration revision.\"\"\"",
            "    log.info(f\"Running database upgrade to revision {revision}\")",
            "    command.upgrade(alembic_config, revision)",
            "",
            "",
            "def downgrade_db(alembic_config: Config, revision: str = \"head\") -> None:",
            "    \"\"\"Downgrade the database to the specified migration revision.\"\"\"",
            "    log.info(f\"Running database downgrade to revision {revision}\")",
            "    command.downgrade(alembic_config, revision)",
            "",
            "",
            "async def migrate_db(",
            "    database_url: str,",
            "    samples: bool = False,",
            "    revision: str = \"head\",",
            "    downgrade: bool = False,",
            ") -> None:",
            "    \"\"\"",
            "    Runs migrations and creates database objects if needed.",
            "",
            "    Safe to run on an existing database when upgrading Fides version.",
            "    \"\"\"",
            "    log.info(\"Migrating database\")",
            "    alembic_config = get_alembic_config(database_url)",
            "    if downgrade:",
            "        downgrade_db(alembic_config, revision)",
            "    else:",
            "        upgrade_db(alembic_config, revision)",
            "",
            "        async with async_session() as session:",
            "            await load_default_resources(session)",
            "            if samples:",
            "                await load_samples(session)",
            "",
            "",
            "def create_db_if_not_exists(database_url: str) -> None:",
            "    \"\"\"",
            "    Creates a database which does not exist already.",
            "    \"\"\"",
            "    if not database_exists(database_url):",
            "        create_database(database_url)",
            "",
            "",
            "def reset_db(database_url: str) -> None:",
            "    \"\"\"",
            "    Drops all tables/metadata from the database.",
            "    \"\"\"",
            "    log.info(\"Resetting database...\")",
            "    engine = get_db_engine(database_url)",
            "    with engine.connect() as connection:",
            "        log.info(\"Dropping tables...\")",
            "        Base.metadata.drop_all(connection)",
            "",
            "        log.info(\"Dropping Alembic table...\")",
            "        migration_context = migration.MigrationContext.configure(connection)",
            "        version = migration_context._version  # pylint: disable=protected-access",
            "        if version.exists(connection):",
            "            version.drop(connection)",
            "    log.info(\"Reset complete.\")",
            "",
            "",
            "def get_db_health(",
            "    database_url: str, db: Session",
            ") -> Tuple[DatabaseHealth, Optional[str]]:",
            "    \"\"\"Checks if the db is reachable and up-to-date with Alembic migrations.\"\"\"",
            "    try:",
            "        alembic_config = get_alembic_config(database_url)",
            "        alembic_script_directory = script.ScriptDirectory.from_config(alembic_config)",
            "        context = migration.MigrationContext.configure(db.connection())",
            "        current_revision = context.get_current_revision()",
            "        if (",
            "            context.get_current_revision()",
            "            != alembic_script_directory.get_current_head()",
            "        ):",
            "            db_health: DatabaseHealth = \"needs migration\"",
            "        else:",
            "            db_health = \"healthy\"",
            "        return db_health, current_revision",
            "    except Exception as error:  # pylint: disable=broad-except",
            "        error_type = get_full_exception_name(error)",
            "        log.error(\"Unable to reach the database: {}: {}\", error_type, error)",
            "        return (\"unhealthy\", None)",
            "",
            "",
            "async def configure_db(",
            "    database_url: str, samples: bool = False, revision: Optional[str] = \"head\"",
            ") -> None:",
            "    \"\"\"Set up the db to be used by the app.\"\"\"",
            "    try:",
            "        create_db_if_not_exists(database_url)",
            "        await migrate_db(database_url, samples=samples, revision=revision)  # type: ignore[arg-type]",
            "    except InvalidCiphertextError as cipher_error:",
            "        log.error(",
            "            \"Unable to configure database due to a decryption error! Check to ensure your `app_encryption_key` has not changed.\"",
            "        )",
            "        log.opt(exception=True).error(cipher_error)",
            "",
            "    except Exception as error:  # pylint: disable=broad-except",
            "        error_type = get_full_exception_name(error)",
            "        log.error(\"Unable to configure database: {}: {}\", error_type, error)",
            "        log.opt(exception=True).error(error)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "34": [
                "get_alembic_config"
            ]
        },
        "addLocation": []
    },
    "src/fides/config/database_settings.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from copy import deepcopy"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Dict, Optional, Union, cast"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from urllib.parse import quote, urlencode"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from urllib.parse import quote, quote_plus, urlencode"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from pydantic import Field, PostgresDsn, validator"
            },
            "7": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     )"
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     params: Dict = Field("
            },
            "10": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         default={},  # Can't use the default_factory since it breaks docs generation"
            },
            "11": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        description=\"Additional connection parameters used when connecting to the applicaiton database.\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        description=\"Additional connection parameters used when connecting to the application database.\","
            },
            "13": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     )"
            },
            "14": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     # These must be at the end because they require other values to construct"
            },
            "16": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         exclude=True,"
            },
            "17": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     )"
            },
            "18": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    @validator(\"password\", pre=True)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+    def escape_password(cls, value: Optional[str]) -> Optional[str]:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        \"\"\"Escape password\"\"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        if value and isinstance(value, str):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            return quote_plus(value)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+        return value"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     @validator(\"sync_database_uri\", pre=True)"
            },
            "27": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "     @classmethod"
            },
            "28": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     def assemble_sync_database_uri("
            }
        },
        "frontPatchFile": [
            "\"\"\"This module handles database credentials for the application database..\"\"\"",
            "",
            "# pylint: disable=C0115,C0116, E0213",
            "",
            "from copy import deepcopy",
            "from typing import Dict, Optional, Union, cast",
            "from urllib.parse import quote, urlencode",
            "",
            "from pydantic import Field, PostgresDsn, validator",
            "",
            "from fides.config.utils import get_test_mode",
            "",
            "from .fides_settings import FidesSettings",
            "",
            "ENV_PREFIX = \"FIDES__DATABASE__\"",
            "",
            "",
            "class DatabaseSettings(FidesSettings):",
            "    \"\"\"Configuration settings for the application database.\"\"\"",
            "",
            "    automigrate: bool = Field(",
            "        default=True,",
            "        description=\"Automatically runs migrations on webserver startup. If set to `false`, will require the user to run migrations manually via the CLI or API. WARNING: Must be set to `true` for first-time startup.\",",
            "    )",
            "    api_engine_pool_size: int = Field(",
            "        default=50,",
            "        description=\"Number of concurrent database connections Fides will use for API requests. Note that the pool begins with no connections, but as they are requested the connections are maintained and reused up to this limit.\",",
            "    )",
            "    api_engine_max_overflow: int = Field(",
            "        default=50,",
            "        description=\"Number of additional 'overflow' concurrent database connections Fides will use for API requests if the pool reaches the limit. These overflow connections are discarded afterwards and not maintained.\",",
            "    )",
            "    db: str = Field(",
            "        default=\"default_db\", description=\"The name of the application database.\"",
            "    )",
            "    load_samples: bool = Field(",
            "        default=False,",
            "        description=(",
            "            \"When set to True, initializes the database with sample data for testing (Systems, Datasets, Connectors, etc.) \"",
            "            \"Used by 'fides deploy' to configure the sample project.\"",
            "        ),",
            "    )",
            "    password: str = Field(",
            "        default=\"defaultpassword\",",
            "        description=\"The password with which to login to the application database.\",",
            "    )",
            "    port: str = Field(",
            "        default=\"5432\",",
            "        description=\"The port at which the application database will be accessible.\",",
            "    )",
            "    server: str = Field(",
            "        default=\"default-db\",",
            "        description=\"The hostname of the application database server.\",",
            "    )",
            "    task_engine_pool_size: int = Field(",
            "        default=50,",
            "        description=\"Number of concurrent database connections Fides will use for executing privacy request tasks, either locally or on each worker. Note that the pool begins with no connections, but as they are requested the connections are maintained and reused up to this limit.\",",
            "    )",
            "    task_engine_max_overflow: int = Field(",
            "        default=50,",
            "        description=\"Number of additional 'overflow' concurrent database connections Fides will use for executing privacy request tasks, either locally or on each worker, if the pool reaches the limit. These overflow connections are discarded afterwards and not maintained.\",",
            "    )",
            "    test_db: str = Field(",
            "        default=\"default_test_db\",",
            "        description=\"Used instead of the 'db' value when the FIDES_TEST_MODE environment variable is set to True. Avoids overwriting production data.\",",
            "        exclude=True,",
            "    )",
            "    user: str = Field(",
            "        default=\"defaultuser\",",
            "        description=\"The database user with which to login to the application database.\",",
            "    )",
            "    params: Dict = Field(",
            "        default={},  # Can't use the default_factory since it breaks docs generation",
            "        description=\"Additional connection parameters used when connecting to the applicaiton database.\",",
            "    )",
            "",
            "    # These must be at the end because they require other values to construct",
            "    sqlalchemy_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created connection string for the application database.\",",
            "        exclude=True,",
            "    )",
            "    sqlalchemy_test_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created connection string for the test database.\",",
            "        exclude=True,",
            "    )",
            "    async_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created asynchronous connection string for the configured database (either application or test).\",",
            "        exclude=True,",
            "    )",
            "    sync_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created synchronous connection string for the configured database (either application or test).\",",
            "        exclude=True,",
            "    )",
            "",
            "    @validator(\"sync_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_sync_database_uri(",
            "        cls, value: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into a connection string\"\"\"",
            "        if isinstance(value, str) and value:",
            "            return value",
            "",
            "        db_name = values[\"test_db\"] if get_test_mode() else values[\"db\"]",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql+psycopg2\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values.get(\"port\"),",
            "                path=f\"/{db_name or ''}\",",
            "                query=urlencode(",
            "                    cast(Dict, values[\"params\"]), quote_via=quote, safe=\"/\"",
            "                ),",
            "            )",
            "        )",
            "",
            "    @validator(\"async_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_async_database_uri(",
            "        cls, value: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into an async connection string.\"\"\"",
            "        if isinstance(value, str) and value:",
            "            return value",
            "",
            "        db_name = values[\"test_db\"] if get_test_mode() else values[\"db\"]",
            "",
            "        # Workaround https://github.com/MagicStack/asyncpg/issues/737",
            "        # Required due to the unique way in which Asyncpg handles SSL",
            "        params = cast(Dict, deepcopy(values[\"params\"]))",
            "        if \"sslmode\" in params:",
            "            params[\"ssl\"] = params.pop(\"sslmode\")",
            "        # This must be constructed in fides.api.db.session as part of the ssl context",
            "        # ref: https://github.com/sqlalchemy/sqlalchemy/discussions/5975",
            "        params.pop(\"sslrootcert\", None)",
            "        # End workaround",
            "",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql+asyncpg\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values.get(\"port\"),",
            "                path=f\"/{db_name or ''}\",",
            "                query=urlencode(params, quote_via=quote, safe=\"/\"),",
            "            )",
            "        )",
            "",
            "    @validator(\"sqlalchemy_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_db_connection(",
            "        cls, v: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into a synchronous connection string.\"\"\"",
            "        if isinstance(v, str) and v:",
            "            return v",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values.get(\"port\"),",
            "                path=f\"/{values.get('db') or ''}\",",
            "                query=urlencode(",
            "                    cast(Dict, values[\"params\"]), quote_via=quote, safe=\"/\"",
            "                ),",
            "            )",
            "        )",
            "",
            "    @validator(\"sqlalchemy_test_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_test_db_connection(",
            "        cls, v: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into a connection string\"\"\"",
            "        if isinstance(v, str) and v:",
            "            return v",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values[\"port\"],",
            "                path=f\"/{values.get('test_db') or ''}\",",
            "                query=urlencode(",
            "                    cast(Dict, values[\"params\"]), quote_via=quote, safe=\"/\"",
            "                ),",
            "            )",
            "        )",
            "",
            "    class Config:",
            "        env_prefix = ENV_PREFIX"
        ],
        "afterPatchFile": [
            "\"\"\"This module handles database credentials for the application database..\"\"\"",
            "",
            "# pylint: disable=C0115,C0116, E0213",
            "",
            "from copy import deepcopy",
            "from typing import Dict, Optional, Union, cast",
            "from urllib.parse import quote, quote_plus, urlencode",
            "",
            "from pydantic import Field, PostgresDsn, validator",
            "",
            "from fides.config.utils import get_test_mode",
            "",
            "from .fides_settings import FidesSettings",
            "",
            "ENV_PREFIX = \"FIDES__DATABASE__\"",
            "",
            "",
            "class DatabaseSettings(FidesSettings):",
            "    \"\"\"Configuration settings for the application database.\"\"\"",
            "",
            "    automigrate: bool = Field(",
            "        default=True,",
            "        description=\"Automatically runs migrations on webserver startup. If set to `false`, will require the user to run migrations manually via the CLI or API. WARNING: Must be set to `true` for first-time startup.\",",
            "    )",
            "    api_engine_pool_size: int = Field(",
            "        default=50,",
            "        description=\"Number of concurrent database connections Fides will use for API requests. Note that the pool begins with no connections, but as they are requested the connections are maintained and reused up to this limit.\",",
            "    )",
            "    api_engine_max_overflow: int = Field(",
            "        default=50,",
            "        description=\"Number of additional 'overflow' concurrent database connections Fides will use for API requests if the pool reaches the limit. These overflow connections are discarded afterwards and not maintained.\",",
            "    )",
            "    db: str = Field(",
            "        default=\"default_db\", description=\"The name of the application database.\"",
            "    )",
            "    load_samples: bool = Field(",
            "        default=False,",
            "        description=(",
            "            \"When set to True, initializes the database with sample data for testing (Systems, Datasets, Connectors, etc.) \"",
            "            \"Used by 'fides deploy' to configure the sample project.\"",
            "        ),",
            "    )",
            "    password: str = Field(",
            "        default=\"defaultpassword\",",
            "        description=\"The password with which to login to the application database.\",",
            "    )",
            "    port: str = Field(",
            "        default=\"5432\",",
            "        description=\"The port at which the application database will be accessible.\",",
            "    )",
            "    server: str = Field(",
            "        default=\"default-db\",",
            "        description=\"The hostname of the application database server.\",",
            "    )",
            "    task_engine_pool_size: int = Field(",
            "        default=50,",
            "        description=\"Number of concurrent database connections Fides will use for executing privacy request tasks, either locally or on each worker. Note that the pool begins with no connections, but as they are requested the connections are maintained and reused up to this limit.\",",
            "    )",
            "    task_engine_max_overflow: int = Field(",
            "        default=50,",
            "        description=\"Number of additional 'overflow' concurrent database connections Fides will use for executing privacy request tasks, either locally or on each worker, if the pool reaches the limit. These overflow connections are discarded afterwards and not maintained.\",",
            "    )",
            "    test_db: str = Field(",
            "        default=\"default_test_db\",",
            "        description=\"Used instead of the 'db' value when the FIDES_TEST_MODE environment variable is set to True. Avoids overwriting production data.\",",
            "        exclude=True,",
            "    )",
            "    user: str = Field(",
            "        default=\"defaultuser\",",
            "        description=\"The database user with which to login to the application database.\",",
            "    )",
            "    params: Dict = Field(",
            "        default={},  # Can't use the default_factory since it breaks docs generation",
            "        description=\"Additional connection parameters used when connecting to the application database.\",",
            "    )",
            "",
            "    # These must be at the end because they require other values to construct",
            "    sqlalchemy_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created connection string for the application database.\",",
            "        exclude=True,",
            "    )",
            "    sqlalchemy_test_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created connection string for the test database.\",",
            "        exclude=True,",
            "    )",
            "    async_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created asynchronous connection string for the configured database (either application or test).\",",
            "        exclude=True,",
            "    )",
            "    sync_database_uri: str = Field(",
            "        default=\"\",",
            "        description=\"Programmatically created synchronous connection string for the configured database (either application or test).\",",
            "        exclude=True,",
            "    )",
            "",
            "    @validator(\"password\", pre=True)",
            "    def escape_password(cls, value: Optional[str]) -> Optional[str]:",
            "        \"\"\"Escape password\"\"\"",
            "        if value and isinstance(value, str):",
            "            return quote_plus(value)",
            "        return value",
            "",
            "    @validator(\"sync_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_sync_database_uri(",
            "        cls, value: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into a connection string\"\"\"",
            "        if isinstance(value, str) and value:",
            "            return value",
            "",
            "        db_name = values[\"test_db\"] if get_test_mode() else values[\"db\"]",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql+psycopg2\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values.get(\"port\"),",
            "                path=f\"/{db_name or ''}\",",
            "                query=urlencode(",
            "                    cast(Dict, values[\"params\"]), quote_via=quote, safe=\"/\"",
            "                ),",
            "            )",
            "        )",
            "",
            "    @validator(\"async_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_async_database_uri(",
            "        cls, value: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into an async connection string.\"\"\"",
            "        if isinstance(value, str) and value:",
            "            return value",
            "",
            "        db_name = values[\"test_db\"] if get_test_mode() else values[\"db\"]",
            "",
            "        # Workaround https://github.com/MagicStack/asyncpg/issues/737",
            "        # Required due to the unique way in which Asyncpg handles SSL",
            "        params = cast(Dict, deepcopy(values[\"params\"]))",
            "        if \"sslmode\" in params:",
            "            params[\"ssl\"] = params.pop(\"sslmode\")",
            "        # This must be constructed in fides.api.db.session as part of the ssl context",
            "        # ref: https://github.com/sqlalchemy/sqlalchemy/discussions/5975",
            "        params.pop(\"sslrootcert\", None)",
            "        # End workaround",
            "",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql+asyncpg\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values.get(\"port\"),",
            "                path=f\"/{db_name or ''}\",",
            "                query=urlencode(params, quote_via=quote, safe=\"/\"),",
            "            )",
            "        )",
            "",
            "    @validator(\"sqlalchemy_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_db_connection(",
            "        cls, v: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into a synchronous connection string.\"\"\"",
            "        if isinstance(v, str) and v:",
            "            return v",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values.get(\"port\"),",
            "                path=f\"/{values.get('db') or ''}\",",
            "                query=urlencode(",
            "                    cast(Dict, values[\"params\"]), quote_via=quote, safe=\"/\"",
            "                ),",
            "            )",
            "        )",
            "",
            "    @validator(\"sqlalchemy_test_database_uri\", pre=True)",
            "    @classmethod",
            "    def assemble_test_db_connection(",
            "        cls, v: Optional[str], values: Dict[str, Union[str, Dict]]",
            "    ) -> str:",
            "        \"\"\"Join DB connection credentials into a connection string\"\"\"",
            "        if isinstance(v, str) and v:",
            "            return v",
            "        return str(",
            "            PostgresDsn.build(",
            "                scheme=\"postgresql\",",
            "                user=values[\"user\"],",
            "                password=values[\"password\"],",
            "                host=values[\"server\"],",
            "                port=values[\"port\"],",
            "                path=f\"/{values.get('test_db') or ''}\",",
            "                query=urlencode(",
            "                    cast(Dict, values[\"params\"]), quote_via=quote, safe=\"/\"",
            "                ),",
            "            )",
            "        )",
            "",
            "    class Config:",
            "        env_prefix = ENV_PREFIX"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [],
            "74": [
                "DatabaseSettings"
            ]
        },
        "addLocation": []
    }
}