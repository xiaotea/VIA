{
    "neutron/agent/linux/iptables_firewall.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "             mac_ipv6_pairs.append((mac, ip_address))"
            },
            "1": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 382,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "     def _spoofing_rule(self, port, ipv4_rules, ipv6_rules):"
            },
            "3": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Allow dhcp client packets"
            },
            "4": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ipv4_rules += [comment_rule('-p udp -m udp --sport 68 '"
            },
            "5": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                    '-m udp --dport 67 '"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+        # Allow dhcp client discovery and request"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+        ipv4_rules += [comment_rule('-s 0.0.0.0/32 -d 255.255.255.255/32 '"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+                                    '-p udp -m udp --sport 68 --dport 67 '"
            },
            "9": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 387,
                "PatchRowcode": "                                     '-j RETURN', comment=ic.DHCP_CLIENT)]"
            },
            "10": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         # Drop Router Advts from the port."
            },
            "11": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         ipv6_rules += [comment_rule('-p ipv6-icmp -m icmp6 --icmpv6-type %s '"
            },
            "12": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 415,
                "PatchRowcode": "                                        mac_ipv4_pairs, ipv4_rules)"
            },
            "13": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "         self._setup_spoof_filter_chain(port, self.iptables.ipv6['filter'],"
            },
            "14": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": 417,
                "PatchRowcode": "                                        mac_ipv6_pairs, ipv6_rules)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        # Allow dhcp client renewal and rebinding"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+        ipv4_rules += [comment_rule('-p udp -m udp --sport 68 --dport 67 '"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+                                    '-j RETURN', comment=ic.DHCP_CLIENT)]"
            },
            "18": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 421,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "     def _drop_dhcp_rule(self, ipv4_rules, ipv6_rules):"
            },
            "20": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "         #Note(nati) Drop dhcp packet from VM"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012, Nachi Ueno, NTT MCL, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import re",
            "",
            "import netaddr",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import six",
            "",
            "from neutron._i18n import _LI",
            "from neutron.agent import firewall",
            "from neutron.agent.linux import ip_conntrack",
            "from neutron.agent.linux import ipset_manager",
            "from neutron.agent.linux import iptables_comments as ic",
            "from neutron.agent.linux import iptables_manager",
            "from neutron.agent.linux import utils",
            "from neutron.common import constants",
            "from neutron.common import exceptions as n_exc",
            "from neutron.common import ipv6_utils",
            "from neutron.common import utils as c_utils",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "SG_CHAIN = 'sg-chain'",
            "SPOOF_FILTER = 'spoof-filter'",
            "CHAIN_NAME_PREFIX = {firewall.INGRESS_DIRECTION: 'i',",
            "                     firewall.EGRESS_DIRECTION: 'o',",
            "                     SPOOF_FILTER: 's'}",
            "IPSET_DIRECTION = {firewall.INGRESS_DIRECTION: 'src',",
            "                   firewall.EGRESS_DIRECTION: 'dst'}",
            "# length of all device prefixes (e.g. qvo, tap, qvb)",
            "LINUX_DEV_PREFIX_LEN = 3",
            "LINUX_DEV_LEN = 14",
            "MAX_CONNTRACK_ZONES = 65535",
            "comment_rule = iptables_manager.comment_rule",
            "",
            "",
            "class mac_iptables(netaddr.mac_eui48):",
            "    \"\"\"mac format class for netaddr to match iptables representation.\"\"\"",
            "    word_sep = ':'",
            "",
            "",
            "class IptablesFirewallDriver(firewall.FirewallDriver):",
            "    \"\"\"Driver which enforces security groups through iptables rules.\"\"\"",
            "    IPTABLES_DIRECTION = {firewall.INGRESS_DIRECTION: 'physdev-out',",
            "                          firewall.EGRESS_DIRECTION: 'physdev-in'}",
            "",
            "    def __init__(self, namespace=None):",
            "        self.iptables = iptables_manager.IptablesManager(",
            "            use_ipv6=ipv6_utils.is_enabled(),",
            "            namespace=namespace)",
            "        # TODO(majopela, shihanzhang): refactor out ipset to a separate",
            "        # driver composed over this one",
            "        self.ipset = ipset_manager.IpsetManager(namespace=namespace)",
            "        self.ipconntrack = ip_conntrack.IpConntrackManager(",
            "            self.get_device_zone, namespace=namespace)",
            "        self._populate_initial_zone_map()",
            "        # list of port which has security group",
            "        self.filtered_ports = {}",
            "        self.unfiltered_ports = {}",
            "        self._add_fallback_chain_v4v6()",
            "        self._defer_apply = False",
            "        self._pre_defer_filtered_ports = None",
            "        self._pre_defer_unfiltered_ports = None",
            "        # List of security group rules for ports residing on this host",
            "        self.sg_rules = {}",
            "        self.pre_sg_rules = None",
            "        # List of security group member ips for ports residing on this host",
            "        self.sg_members = collections.defaultdict(",
            "            lambda: collections.defaultdict(list))",
            "        self.pre_sg_members = None",
            "        self.enable_ipset = cfg.CONF.SECURITYGROUP.enable_ipset",
            "        self._enabled_netfilter_for_bridges = False",
            "        self.updated_rule_sg_ids = set()",
            "        self.updated_sg_members = set()",
            "        self.devices_with_updated_sg_members = collections.defaultdict(list)",
            "",
            "    def _enable_netfilter_for_bridges(self):",
            "        # we only need to set these values once, but it has to be when",
            "        # we create a bridge; before that the bridge module might not",
            "        # be loaded and the proc values aren't there.",
            "        if self._enabled_netfilter_for_bridges:",
            "            return",
            "        else:",
            "            self._enabled_netfilter_for_bridges = True",
            "",
            "        # These proc values ensure that netfilter is enabled on",
            "        # bridges; essential for enforcing security groups rules with",
            "        # OVS Hybrid.  Distributions can differ on whether this is",
            "        # enabled by default or not (Ubuntu - yes, Redhat - no, for",
            "        # example).",
            "        LOG.debug(\"Enabling netfilter for bridges\")",
            "        utils.execute(['sysctl', '-w',",
            "                       'net.bridge.bridge-nf-call-arptables=1'],",
            "                      run_as_root=True)",
            "        utils.execute(['sysctl', '-w',",
            "                       'net.bridge.bridge-nf-call-ip6tables=1'],",
            "                      run_as_root=True)",
            "        utils.execute(['sysctl', '-w',",
            "                       'net.bridge.bridge-nf-call-iptables=1'],",
            "                      run_as_root=True)",
            "",
            "    @property",
            "    def ports(self):",
            "        return dict(self.filtered_ports, **self.unfiltered_ports)",
            "",
            "    def _update_remote_security_group_members(self, sec_group_ids):",
            "        for sg_id in sec_group_ids:",
            "            for device in self.filtered_ports.values():",
            "                if sg_id in device.get('security_group_source_groups', []):",
            "                    self.devices_with_updated_sg_members[sg_id].append(device)",
            "",
            "    def security_group_updated(self, action_type, sec_group_ids,",
            "                               device_ids=None):",
            "        device_ids = device_ids or []",
            "        if action_type == 'sg_rule':",
            "            self.updated_rule_sg_ids.update(sec_group_ids)",
            "        elif action_type == 'sg_member':",
            "            if device_ids:",
            "                self.updated_sg_members.update(device_ids)",
            "            else:",
            "                self._update_remote_security_group_members(sec_group_ids)",
            "",
            "    def update_security_group_rules(self, sg_id, sg_rules):",
            "        LOG.debug(\"Update rules of security group (%s)\", sg_id)",
            "        self.sg_rules[sg_id] = sg_rules",
            "",
            "    def update_security_group_members(self, sg_id, sg_members):",
            "        LOG.debug(\"Update members of security group (%s)\", sg_id)",
            "        self.sg_members[sg_id] = collections.defaultdict(list, sg_members)",
            "",
            "    def _set_ports(self, port):",
            "        if not firewall.port_sec_enabled(port):",
            "            self.unfiltered_ports[port['device']] = port",
            "            self.filtered_ports.pop(port['device'], None)",
            "        else:",
            "            self.filtered_ports[port['device']] = port",
            "            self.unfiltered_ports.pop(port['device'], None)",
            "",
            "    def _unset_ports(self, port):",
            "        self.unfiltered_ports.pop(port['device'], None)",
            "        self.filtered_ports.pop(port['device'], None)",
            "",
            "    def prepare_port_filter(self, port):",
            "        LOG.debug(\"Preparing device (%s) filter\", port['device'])",
            "        self._remove_chains()",
            "        self._set_ports(port)",
            "        self._enable_netfilter_for_bridges()",
            "        # each security group has it own chains",
            "        self._setup_chains()",
            "        return self.iptables.apply()",
            "",
            "    def update_port_filter(self, port):",
            "        LOG.debug(\"Updating device (%s) filter\", port['device'])",
            "        if port['device'] not in self.ports:",
            "            LOG.info(_LI('Attempted to update port filter which is not '",
            "                         'filtered %s'), port['device'])",
            "            return",
            "        self._remove_chains()",
            "        self._set_ports(port)",
            "        self._setup_chains()",
            "        return self.iptables.apply()",
            "",
            "    def remove_port_filter(self, port):",
            "        LOG.debug(\"Removing device (%s) filter\", port['device'])",
            "        if port['device'] not in self.ports:",
            "            LOG.info(_LI('Attempted to remove port filter which is not '",
            "                         'filtered %r'), port)",
            "            return",
            "        self._remove_chains()",
            "        self._unset_ports(port)",
            "        self._setup_chains()",
            "        return self.iptables.apply()",
            "",
            "    def _add_accept_rule_port_sec(self, port, direction):",
            "        self._update_port_sec_rules(port, direction, add=True)",
            "",
            "    def _remove_rule_port_sec(self, port, direction):",
            "        self._update_port_sec_rules(port, direction, add=False)",
            "",
            "    def _remove_rule_from_chain_v4v6(self, chain_name, ipv4_rules, ipv6_rules):",
            "        for rule in ipv4_rules:",
            "            self.iptables.ipv4['filter'].remove_rule(chain_name, rule)",
            "",
            "        for rule in ipv6_rules:",
            "            self.iptables.ipv6['filter'].remove_rule(chain_name, rule)",
            "",
            "    def _setup_chains(self):",
            "        \"\"\"Setup ingress and egress chain for a port.\"\"\"",
            "        if not self._defer_apply:",
            "            self._setup_chains_apply(self.filtered_ports,",
            "                                     self.unfiltered_ports)",
            "",
            "    def _setup_chains_apply(self, ports, unfiltered_ports):",
            "        self._add_chain_by_name_v4v6(SG_CHAIN)",
            "        # sort by port so we always do this deterministically between",
            "        # agent restarts and don't cause unnecessary rule differences",
            "        for pname in sorted(ports):",
            "            port = ports[pname]",
            "            self._setup_chain(port, firewall.INGRESS_DIRECTION)",
            "            self._setup_chain(port, firewall.EGRESS_DIRECTION)",
            "        self.iptables.ipv4['filter'].add_rule(SG_CHAIN, '-j ACCEPT')",
            "        self.iptables.ipv6['filter'].add_rule(SG_CHAIN, '-j ACCEPT')",
            "",
            "        for port in unfiltered_ports.values():",
            "            self._add_accept_rule_port_sec(port, firewall.INGRESS_DIRECTION)",
            "            self._add_accept_rule_port_sec(port, firewall.EGRESS_DIRECTION)",
            "",
            "    def _remove_chains(self):",
            "        \"\"\"Remove ingress and egress chain for a port.\"\"\"",
            "        if not self._defer_apply:",
            "            self._remove_chains_apply(self.filtered_ports,",
            "                                      self.unfiltered_ports)",
            "",
            "    def _remove_chains_apply(self, ports, unfiltered_ports):",
            "        for port in ports.values():",
            "            self._remove_chain(port, firewall.INGRESS_DIRECTION)",
            "            self._remove_chain(port, firewall.EGRESS_DIRECTION)",
            "            self._remove_chain(port, SPOOF_FILTER)",
            "        for port in unfiltered_ports.values():",
            "            self._remove_rule_port_sec(port, firewall.INGRESS_DIRECTION)",
            "            self._remove_rule_port_sec(port, firewall.EGRESS_DIRECTION)",
            "        self._remove_chain_by_name_v4v6(SG_CHAIN)",
            "",
            "    def _setup_chain(self, port, DIRECTION):",
            "        self._add_chain(port, DIRECTION)",
            "        self._add_rules_by_security_group(port, DIRECTION)",
            "",
            "    def _remove_chain(self, port, DIRECTION):",
            "        chain_name = self._port_chain_name(port, DIRECTION)",
            "        self._remove_chain_by_name_v4v6(chain_name)",
            "",
            "    def _add_fallback_chain_v4v6(self):",
            "        self.iptables.ipv4['filter'].add_chain('sg-fallback')",
            "        self.iptables.ipv4['filter'].add_rule('sg-fallback', '-j DROP',",
            "                                              comment=ic.UNMATCH_DROP)",
            "        self.iptables.ipv6['filter'].add_chain('sg-fallback')",
            "        self.iptables.ipv6['filter'].add_rule('sg-fallback', '-j DROP',",
            "                                              comment=ic.UNMATCH_DROP)",
            "",
            "    def _add_raw_chain(self, chain_name):",
            "        self.iptables.ipv4['raw'].add_chain(chain_name)",
            "        self.iptables.ipv6['raw'].add_chain(chain_name)",
            "",
            "    def _add_chain_by_name_v4v6(self, chain_name):",
            "        self.iptables.ipv4['filter'].add_chain(chain_name)",
            "        self.iptables.ipv6['filter'].add_chain(chain_name)",
            "",
            "    def _remove_raw_chain(self, chain_name):",
            "        self.iptables.ipv4['raw'].remove_chain(chain_name)",
            "        self.iptables.ipv6['raw'].remove_chain(chain_name)",
            "",
            "    def _remove_chain_by_name_v4v6(self, chain_name):",
            "        self.iptables.ipv4['filter'].remove_chain(chain_name)",
            "        self.iptables.ipv6['filter'].remove_chain(chain_name)",
            "",
            "    def _add_rules_to_chain_v4v6(self, chain_name, ipv4_rules, ipv6_rules,",
            "                                 comment=None):",
            "        for rule in ipv4_rules:",
            "            self.iptables.ipv4['filter'].add_rule(chain_name, rule,",
            "                                                  comment=comment)",
            "",
            "        for rule in ipv6_rules:",
            "            self.iptables.ipv6['filter'].add_rule(chain_name, rule,",
            "                                                  comment=comment)",
            "",
            "    def _get_device_name(self, port):",
            "        return port['device']",
            "",
            "    def _update_port_sec_rules(self, port, direction, add=False):",
            "        # add/remove rules in FORWARD and INPUT chain",
            "        device = self._get_device_name(port)",
            "",
            "        jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                     '-j ACCEPT' % (self.IPTABLES_DIRECTION[direction],",
            "                                    device)]",
            "        if add:",
            "            self._add_rules_to_chain_v4v6(",
            "                'FORWARD', jump_rule, jump_rule, comment=ic.PORT_SEC_ACCEPT)",
            "        else:",
            "            self._remove_rule_from_chain_v4v6('FORWARD', jump_rule, jump_rule)",
            "",
            "        if direction == firewall.EGRESS_DIRECTION:",
            "            jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                         '-j ACCEPT' % (self.IPTABLES_DIRECTION[direction],",
            "                                        device)]",
            "            if add:",
            "                self._add_rules_to_chain_v4v6('INPUT', jump_rule, jump_rule,",
            "                                              comment=ic.PORT_SEC_ACCEPT)",
            "            else:",
            "                self._remove_rule_from_chain_v4v6(",
            "                    'INPUT', jump_rule, jump_rule)",
            "",
            "    def _add_chain(self, port, direction):",
            "        chain_name = self._port_chain_name(port, direction)",
            "        self._add_chain_by_name_v4v6(chain_name)",
            "",
            "        # Note(nati) jump to the security group chain (SG_CHAIN)",
            "        # This is needed because the packet may much two rule in port",
            "        # if the two port is in the same host",
            "        # We accept the packet at the end of SG_CHAIN.",
            "",
            "        # jump to the security group chain",
            "        device = self._get_device_name(port)",
            "        jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                     '-j $%s' % (self.IPTABLES_DIRECTION[direction],",
            "                                 device,",
            "                                 SG_CHAIN)]",
            "        self._add_rules_to_chain_v4v6('FORWARD', jump_rule, jump_rule,",
            "                                      comment=ic.VM_INT_SG)",
            "",
            "        # jump to the chain based on the device",
            "        jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                     '-j $%s' % (self.IPTABLES_DIRECTION[direction],",
            "                                 device,",
            "                                 chain_name)]",
            "        self._add_rules_to_chain_v4v6(SG_CHAIN, jump_rule, jump_rule,",
            "                                      comment=ic.SG_TO_VM_SG)",
            "",
            "        if direction == firewall.EGRESS_DIRECTION:",
            "            self._add_rules_to_chain_v4v6('INPUT', jump_rule, jump_rule,",
            "                                          comment=ic.INPUT_TO_SG)",
            "",
            "    def _split_sgr_by_ethertype(self, security_group_rules):",
            "        ipv4_sg_rules = []",
            "        ipv6_sg_rules = []",
            "        for rule in security_group_rules:",
            "            if rule.get('ethertype') == constants.IPv4:",
            "                ipv4_sg_rules.append(rule)",
            "            elif rule.get('ethertype') == constants.IPv6:",
            "                if rule.get('protocol') == 'icmp':",
            "                    rule['protocol'] = 'ipv6-icmp'",
            "                ipv6_sg_rules.append(rule)",
            "        return ipv4_sg_rules, ipv6_sg_rules",
            "",
            "    def _select_sgr_by_direction(self, port, direction):",
            "        return [rule",
            "                for rule in port.get('security_group_rules', [])",
            "                if rule['direction'] == direction]",
            "",
            "    def _setup_spoof_filter_chain(self, port, table, mac_ip_pairs, rules):",
            "        if mac_ip_pairs:",
            "            chain_name = self._port_chain_name(port, SPOOF_FILTER)",
            "            table.add_chain(chain_name)",
            "            for mac, ip in mac_ip_pairs:",
            "                if ip is None:",
            "                    # If fixed_ips is [] this rule will be added to the end",
            "                    # of the list after the allowed_address_pair rules.",
            "                    table.add_rule(chain_name,",
            "                                   '-m mac --mac-source %s -j RETURN'",
            "                                   % mac.upper(), comment=ic.PAIR_ALLOW)",
            "                else:",
            "                    # we need to convert it into a prefix to match iptables",
            "                    ip = c_utils.ip_to_cidr(ip)",
            "                    table.add_rule(chain_name,",
            "                                   '-s %s -m mac --mac-source %s -j RETURN'",
            "                                   % (ip, mac.upper()), comment=ic.PAIR_ALLOW)",
            "            table.add_rule(chain_name, '-j DROP', comment=ic.PAIR_DROP)",
            "            rules.append('-j $%s' % chain_name)",
            "",
            "    def _build_ipv4v6_mac_ip_list(self, mac, ip_address, mac_ipv4_pairs,",
            "                                  mac_ipv6_pairs):",
            "        mac = str(netaddr.EUI(mac, dialect=mac_iptables))",
            "        if netaddr.IPNetwork(ip_address).version == 4:",
            "            mac_ipv4_pairs.append((mac, ip_address))",
            "        else:",
            "            mac_ipv6_pairs.append((mac, ip_address))",
            "",
            "    def _spoofing_rule(self, port, ipv4_rules, ipv6_rules):",
            "        # Allow dhcp client packets",
            "        ipv4_rules += [comment_rule('-p udp -m udp --sport 68 '",
            "                                    '-m udp --dport 67 '",
            "                                    '-j RETURN', comment=ic.DHCP_CLIENT)]",
            "        # Drop Router Advts from the port.",
            "        ipv6_rules += [comment_rule('-p ipv6-icmp -m icmp6 --icmpv6-type %s '",
            "                                    '-j DROP' % constants.ICMPV6_TYPE_RA,",
            "                                    comment=ic.IPV6_RA_DROP)]",
            "        ipv6_rules += [comment_rule('-p ipv6-icmp -j RETURN',",
            "                                    comment=ic.IPV6_ICMP_ALLOW)]",
            "        ipv6_rules += [comment_rule('-p udp -m udp --sport 546 '",
            "                                    '-m udp --dport 547 '",
            "                                    '-j RETURN', comment=ic.DHCP_CLIENT)]",
            "        mac_ipv4_pairs = []",
            "        mac_ipv6_pairs = []",
            "",
            "        if isinstance(port.get('allowed_address_pairs'), list):",
            "            for address_pair in port['allowed_address_pairs']:",
            "                self._build_ipv4v6_mac_ip_list(address_pair['mac_address'],",
            "                                               address_pair['ip_address'],",
            "                                               mac_ipv4_pairs,",
            "                                               mac_ipv6_pairs)",
            "",
            "        for ip in port['fixed_ips']:",
            "            self._build_ipv4v6_mac_ip_list(port['mac_address'], ip,",
            "                                           mac_ipv4_pairs, mac_ipv6_pairs)",
            "        if not port['fixed_ips']:",
            "            mac_ipv4_pairs.append((port['mac_address'], None))",
            "            mac_ipv6_pairs.append((port['mac_address'], None))",
            "",
            "        self._setup_spoof_filter_chain(port, self.iptables.ipv4['filter'],",
            "                                       mac_ipv4_pairs, ipv4_rules)",
            "        self._setup_spoof_filter_chain(port, self.iptables.ipv6['filter'],",
            "                                       mac_ipv6_pairs, ipv6_rules)",
            "",
            "    def _drop_dhcp_rule(self, ipv4_rules, ipv6_rules):",
            "        #Note(nati) Drop dhcp packet from VM",
            "        ipv4_rules += [comment_rule('-p udp -m udp --sport 67 '",
            "                                    '-m udp --dport 68 '",
            "                                    '-j DROP', comment=ic.DHCP_SPOOF)]",
            "        ipv6_rules += [comment_rule('-p udp -m udp --sport 547 '",
            "                                    '-m udp --dport 546 '",
            "                                    '-j DROP', comment=ic.DHCP_SPOOF)]",
            "",
            "    def _accept_inbound_icmpv6(self):",
            "        # Allow multicast listener, neighbor solicitation and",
            "        # neighbor advertisement into the instance",
            "        icmpv6_rules = []",
            "        for icmp6_type in constants.ICMPV6_ALLOWED_TYPES:",
            "            icmpv6_rules += ['-p ipv6-icmp -m icmp6 --icmpv6-type %s '",
            "                             '-j RETURN' % icmp6_type]",
            "        return icmpv6_rules",
            "",
            "    def _select_sg_rules_for_port(self, port, direction):",
            "        \"\"\"Select rules from the security groups the port is member of.\"\"\"",
            "        port_sg_ids = port.get('security_groups', [])",
            "        port_rules = []",
            "",
            "        for sg_id in port_sg_ids:",
            "            for rule in self.sg_rules.get(sg_id, []):",
            "                if rule['direction'] == direction:",
            "                    if self.enable_ipset:",
            "                        port_rules.append(rule)",
            "                    else:",
            "                        port_rules.extend(",
            "                            self._expand_sg_rule_with_remote_ips(",
            "                                rule, port, direction))",
            "        return port_rules",
            "",
            "    def _expand_sg_rule_with_remote_ips(self, rule, port, direction):",
            "        \"\"\"Expand a remote group rule to rule per remote group IP.\"\"\"",
            "        remote_group_id = rule.get('remote_group_id')",
            "        if remote_group_id:",
            "            ethertype = rule['ethertype']",
            "            port_ips = port.get('fixed_ips', [])",
            "",
            "            for ip in self.sg_members[remote_group_id][ethertype]:",
            "                if ip not in port_ips:",
            "                    ip_rule = rule.copy()",
            "                    direction_ip_prefix = firewall.DIRECTION_IP_PREFIX[",
            "                        direction]",
            "                    ip_prefix = str(netaddr.IPNetwork(ip).cidr)",
            "                    ip_rule[direction_ip_prefix] = ip_prefix",
            "                    yield ip_rule",
            "        else:",
            "            yield rule",
            "",
            "    def _get_remote_sg_ids(self, port, direction=None):",
            "        sg_ids = port.get('security_groups', [])",
            "        remote_sg_ids = {constants.IPv4: set(), constants.IPv6: set()}",
            "        for sg_id in sg_ids:",
            "            for rule in self.sg_rules.get(sg_id, []):",
            "                if not direction or rule['direction'] == direction:",
            "                    remote_sg_id = rule.get('remote_group_id')",
            "                    ether_type = rule.get('ethertype')",
            "                    if remote_sg_id and ether_type:",
            "                        remote_sg_ids[ether_type].add(remote_sg_id)",
            "        return remote_sg_ids",
            "",
            "    def _add_rules_by_security_group(self, port, direction):",
            "        # select rules for current port and direction",
            "        security_group_rules = self._select_sgr_by_direction(port, direction)",
            "        security_group_rules += self._select_sg_rules_for_port(port, direction)",
            "        # make sure ipset members are updated for remote security groups",
            "        if self.enable_ipset:",
            "            remote_sg_ids = self._get_remote_sg_ids(port, direction)",
            "            self._update_ipset_members(remote_sg_ids)",
            "        # split groups by ip version",
            "        # for ipv4, iptables command is used",
            "        # for ipv6, iptables6 command is used",
            "        ipv4_sg_rules, ipv6_sg_rules = self._split_sgr_by_ethertype(",
            "            security_group_rules)",
            "        ipv4_iptables_rules = []",
            "        ipv6_iptables_rules = []",
            "        # include fixed egress/ingress rules",
            "        if direction == firewall.EGRESS_DIRECTION:",
            "            self._add_fixed_egress_rules(port,",
            "                                         ipv4_iptables_rules,",
            "                                         ipv6_iptables_rules)",
            "        elif direction == firewall.INGRESS_DIRECTION:",
            "            ipv6_iptables_rules += self._accept_inbound_icmpv6()",
            "        # include IPv4 and IPv6 iptable rules from security group",
            "        ipv4_iptables_rules += self._convert_sgr_to_iptables_rules(",
            "            ipv4_sg_rules)",
            "        ipv6_iptables_rules += self._convert_sgr_to_iptables_rules(",
            "            ipv6_sg_rules)",
            "        # finally add the rules to the port chain for a given direction",
            "        self._add_rules_to_chain_v4v6(self._port_chain_name(port, direction),",
            "                                      ipv4_iptables_rules,",
            "                                      ipv6_iptables_rules)",
            "",
            "    def _add_fixed_egress_rules(self, port, ipv4_iptables_rules,",
            "                                ipv6_iptables_rules):",
            "        self._spoofing_rule(port,",
            "                            ipv4_iptables_rules,",
            "                            ipv6_iptables_rules)",
            "        self._drop_dhcp_rule(ipv4_iptables_rules, ipv6_iptables_rules)",
            "",
            "    def _update_ipset_members(self, security_group_ids):",
            "        for ip_version, sg_ids in security_group_ids.items():",
            "            for sg_id in sg_ids:",
            "                current_ips = self.sg_members[sg_id][ip_version]",
            "                self.ipset.set_members(sg_id, ip_version, current_ips)",
            "",
            "    def _generate_ipset_rule_args(self, sg_rule, remote_gid):",
            "        ethertype = sg_rule.get('ethertype')",
            "        ipset_name = self.ipset.get_name(remote_gid, ethertype)",
            "        if not self.ipset.set_name_exists(ipset_name):",
            "            #NOTE(mangelajo): ipsets for empty groups are not created",
            "            #                 thus we can't reference them.",
            "            return None",
            "        ipset_direction = IPSET_DIRECTION[sg_rule.get('direction')]",
            "        args = self._generate_protocol_and_port_args(sg_rule)",
            "        args += ['-m set', '--match-set', ipset_name, ipset_direction]",
            "        args += ['-j RETURN']",
            "        return args",
            "",
            "    def _generate_protocol_and_port_args(self, sg_rule):",
            "        args = self._protocol_arg(sg_rule.get('protocol'))",
            "        args += self._port_arg('sport',",
            "                               sg_rule.get('protocol'),",
            "                               sg_rule.get('source_port_range_min'),",
            "                               sg_rule.get('source_port_range_max'))",
            "        args += self._port_arg('dport',",
            "                               sg_rule.get('protocol'),",
            "                               sg_rule.get('port_range_min'),",
            "                               sg_rule.get('port_range_max'))",
            "        return args",
            "",
            "    def _generate_plain_rule_args(self, sg_rule):",
            "        # These arguments MUST be in the format iptables-save will",
            "        # display them: source/dest, protocol, sport, dport, target",
            "        # Otherwise the iptables_manager code won't be able to find",
            "        # them to preserve their [packet:byte] counts.",
            "        args = self._ip_prefix_arg('s', sg_rule.get('source_ip_prefix'))",
            "        args += self._ip_prefix_arg('d', sg_rule.get('dest_ip_prefix'))",
            "        args += self._generate_protocol_and_port_args(sg_rule)",
            "        args += ['-j RETURN']",
            "        return args",
            "",
            "    def _convert_sg_rule_to_iptables_args(self, sg_rule):",
            "        remote_gid = sg_rule.get('remote_group_id')",
            "        if self.enable_ipset and remote_gid:",
            "            return self._generate_ipset_rule_args(sg_rule, remote_gid)",
            "        else:",
            "            return self._generate_plain_rule_args(sg_rule)",
            "",
            "    def _convert_sgr_to_iptables_rules(self, security_group_rules):",
            "        iptables_rules = []",
            "        self._allow_established(iptables_rules)",
            "        for rule in security_group_rules:",
            "            args = self._convert_sg_rule_to_iptables_args(rule)",
            "            if args:",
            "                iptables_rules += [' '.join(args)]",
            "",
            "        self._drop_invalid_packets(iptables_rules)",
            "        iptables_rules += [comment_rule('-j $sg-fallback',",
            "                                        comment=ic.UNMATCHED)]",
            "        return iptables_rules",
            "",
            "    def _drop_invalid_packets(self, iptables_rules):",
            "        # Always drop invalid packets",
            "        iptables_rules += [comment_rule('-m state --state ' 'INVALID -j DROP',",
            "                                        comment=ic.INVALID_DROP)]",
            "        return iptables_rules",
            "",
            "    def _allow_established(self, iptables_rules):",
            "        # Allow established connections",
            "        iptables_rules += [comment_rule(",
            "            '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "            comment=ic.ALLOW_ASSOC)]",
            "        return iptables_rules",
            "",
            "    def _protocol_arg(self, protocol):",
            "        if not protocol:",
            "            return []",
            "        if protocol == 'icmpv6':",
            "            protocol = 'ipv6-icmp'",
            "        iptables_rule = ['-p', protocol]",
            "        return iptables_rule",
            "",
            "    def _port_arg(self, direction, protocol, port_range_min, port_range_max):",
            "        if (protocol not in ['udp', 'tcp', 'icmp', 'ipv6-icmp']",
            "            or port_range_min is None):",
            "            return []",
            "",
            "        protocol_modules = {'udp': 'udp', 'tcp': 'tcp',",
            "                            'icmp': 'icmp', 'ipv6-icmp': 'icmp6'}",
            "        # iptables adds '-m protocol' when the port number is specified",
            "        args = ['-m', protocol_modules[protocol]]",
            "",
            "        if protocol in ['icmp', 'ipv6-icmp']:",
            "            protocol_type = 'icmpv6' if protocol == 'ipv6-icmp' else 'icmp'",
            "            # Note(xuhanp): port_range_min/port_range_max represent",
            "            # icmp type/code when protocol is icmp or icmpv6",
            "            args += ['--%s-type' % protocol_type, '%s' % port_range_min]",
            "            # icmp code can be 0 so we cannot use \"if port_range_max\" here",
            "            if port_range_max is not None:",
            "                args[-1] += '/%s' % port_range_max",
            "        elif port_range_min == port_range_max:",
            "            args += ['--%s' % direction, '%s' % (port_range_min,)]",
            "        else:",
            "            args += ['-m', 'multiport', '--%ss' % direction,",
            "                     '%s:%s' % (port_range_min, port_range_max)]",
            "        return args",
            "",
            "    def _ip_prefix_arg(self, direction, ip_prefix):",
            "        #NOTE (nati) : source_group_id is converted to list of source_",
            "        # ip_prefix in server side",
            "        if ip_prefix:",
            "            if '/' not in ip_prefix:",
            "                # we need to convert it into a prefix to match iptables",
            "                ip_prefix = c_utils.ip_to_cidr(ip_prefix)",
            "            elif ip_prefix.endswith('/0'):",
            "                # an allow for every address is not a constraint so",
            "                # iptables drops it",
            "                return []",
            "            return ['-%s' % direction, ip_prefix]",
            "        return []",
            "",
            "    def _port_chain_name(self, port, direction):",
            "        return iptables_manager.get_chain_name(",
            "            '%s%s' % (CHAIN_NAME_PREFIX[direction], port['device'][3:]))",
            "",
            "    def filter_defer_apply_on(self):",
            "        if not self._defer_apply:",
            "            self.iptables.defer_apply_on()",
            "            self._pre_defer_filtered_ports = dict(self.filtered_ports)",
            "            self._pre_defer_unfiltered_ports = dict(self.unfiltered_ports)",
            "            self.pre_sg_members = dict(self.sg_members)",
            "            self.pre_sg_rules = dict(self.sg_rules)",
            "            self._defer_apply = True",
            "",
            "    def _remove_unused_security_group_info(self):",
            "        \"\"\"Remove any unnecessary local security group info or unused ipsets.",
            "",
            "        This function has to be called after applying the last iptables",
            "        rules, so we're in a point where no iptable rule depends",
            "        on an ipset we're going to delete.",
            "        \"\"\"",
            "        filtered_ports = self.filtered_ports.values()",
            "",
            "        remote_sgs_to_remove = self._determine_remote_sgs_to_remove(",
            "            filtered_ports)",
            "",
            "        for ip_version, remote_sg_ids in six.iteritems(remote_sgs_to_remove):",
            "            if self.enable_ipset:",
            "                self._remove_ipsets_for_remote_sgs(ip_version, remote_sg_ids)",
            "",
            "        self._remove_sg_members(remote_sgs_to_remove)",
            "",
            "        # Remove unused security group rules",
            "        for remove_group_id in self._determine_sg_rules_to_remove(",
            "                filtered_ports):",
            "            self.sg_rules.pop(remove_group_id, None)",
            "",
            "    def _determine_remote_sgs_to_remove(self, filtered_ports):",
            "        \"\"\"Calculate which remote security groups we don't need anymore.",
            "",
            "        We do the calculation for each ip_version.",
            "        \"\"\"",
            "        sgs_to_remove_per_ipversion = {constants.IPv4: set(),",
            "                                       constants.IPv6: set()}",
            "        remote_group_id_sets = self._get_remote_sg_ids_sets_by_ipversion(",
            "            filtered_ports)",
            "        for ip_version, remote_group_id_set in (",
            "                six.iteritems(remote_group_id_sets)):",
            "            sgs_to_remove_per_ipversion[ip_version].update(",
            "                set(self.pre_sg_members) - remote_group_id_set)",
            "        return sgs_to_remove_per_ipversion",
            "",
            "    def _get_remote_sg_ids_sets_by_ipversion(self, filtered_ports):",
            "        \"\"\"Given a port, calculates the remote sg references by ip_version.\"\"\"",
            "        remote_group_id_sets = {constants.IPv4: set(),",
            "                                constants.IPv6: set()}",
            "        for port in filtered_ports:",
            "            remote_sg_ids = self._get_remote_sg_ids(port)",
            "            for ip_version in (constants.IPv4, constants.IPv6):",
            "                remote_group_id_sets[ip_version] |= remote_sg_ids[ip_version]",
            "        return remote_group_id_sets",
            "",
            "    def _determine_sg_rules_to_remove(self, filtered_ports):",
            "        \"\"\"Calculate which security groups need to be removed.",
            "",
            "        We find out by subtracting our previous sg group ids,",
            "        with the security groups associated to a set of ports.",
            "        \"\"\"",
            "        port_group_ids = self._get_sg_ids_set_for_ports(filtered_ports)",
            "        return set(self.pre_sg_rules) - port_group_ids",
            "",
            "    def _get_sg_ids_set_for_ports(self, filtered_ports):",
            "        \"\"\"Get the port security group ids as a set.\"\"\"",
            "        port_group_ids = set()",
            "        for port in filtered_ports:",
            "            port_group_ids.update(port.get('security_groups', []))",
            "        return port_group_ids",
            "",
            "    def _remove_ipsets_for_remote_sgs(self, ip_version, remote_sg_ids):",
            "        \"\"\"Remove system ipsets matching the provided parameters.\"\"\"",
            "        for remote_sg_id in remote_sg_ids:",
            "            self.ipset.destroy(remote_sg_id, ip_version)",
            "",
            "    def _remove_sg_members(self, remote_sgs_to_remove):",
            "        \"\"\"Remove sg_member entries.\"\"\"",
            "        ipv4_sec_group_set = remote_sgs_to_remove.get(constants.IPv4)",
            "        ipv6_sec_group_set = remote_sgs_to_remove.get(constants.IPv6)",
            "        for sg_id in (ipv4_sec_group_set & ipv6_sec_group_set):",
            "            if sg_id in self.sg_members:",
            "                del self.sg_members[sg_id]",
            "",
            "    def _find_deleted_sg_rules(self, sg_id):",
            "        del_rules = list()",
            "        for pre_rule in self.pre_sg_rules.get(sg_id, []):",
            "            if pre_rule not in self.sg_rules.get(sg_id, []):",
            "                del_rules.append(pre_rule)",
            "        return del_rules",
            "",
            "    def _find_devices_on_security_group(self, sg_id):",
            "        device_list = list()",
            "        for device in self.filtered_ports.values():",
            "            if sg_id in device.get('security_groups', []):",
            "                device_list.append(device)",
            "        return device_list",
            "",
            "    def _clean_deleted_sg_rule_conntrack_entries(self):",
            "        deleted_sg_ids = set()",
            "        for sg_id in self.updated_rule_sg_ids:",
            "            del_rules = self._find_deleted_sg_rules(sg_id)",
            "            if not del_rules:",
            "                continue",
            "            device_list = self._find_devices_on_security_group(sg_id)",
            "            for rule in del_rules:",
            "                self.ipconntrack.delete_conntrack_state_by_rule(",
            "                    device_list, rule)",
            "            deleted_sg_ids.add(sg_id)",
            "        for id in deleted_sg_ids:",
            "            self.updated_rule_sg_ids.remove(id)",
            "",
            "    def _clean_updated_sg_member_conntrack_entries(self):",
            "        updated_device_ids = set()",
            "        for device in self.updated_sg_members:",
            "            sec_group_change = False",
            "            device_info = self.filtered_ports.get(device)",
            "            pre_device_info = self._pre_defer_filtered_ports.get(device)",
            "            if not device_info or not pre_device_info:",
            "                continue",
            "            for sg_id in pre_device_info.get('security_groups', []):",
            "                if sg_id not in device_info.get('security_groups', []):",
            "                    sec_group_change = True",
            "                    break",
            "            if not sec_group_change:",
            "                continue",
            "            for ethertype in [constants.IPv4, constants.IPv6]:",
            "                self.ipconntrack.delete_conntrack_state_by_remote_ips(",
            "                    [device_info], ethertype, set())",
            "            updated_device_ids.add(device)",
            "        for id in updated_device_ids:",
            "            self.updated_sg_members.remove(id)",
            "",
            "    def _clean_deleted_remote_sg_members_conntrack_entries(self):",
            "        deleted_sg_ids = set()",
            "        for sg_id, devices in self.devices_with_updated_sg_members.items():",
            "            for ethertype in [constants.IPv4, constants.IPv6]:",
            "                pre_ips = self._get_sg_members(",
            "                    self.pre_sg_members, sg_id, ethertype)",
            "                cur_ips = self._get_sg_members(",
            "                    self.sg_members, sg_id, ethertype)",
            "                ips = (pre_ips - cur_ips)",
            "                if devices and ips:",
            "                    self.ipconntrack.delete_conntrack_state_by_remote_ips(",
            "                        devices, ethertype, ips)",
            "            deleted_sg_ids.add(sg_id)",
            "        for id in deleted_sg_ids:",
            "            self.devices_with_updated_sg_members.pop(id, None)",
            "",
            "    def _remove_conntrack_entries_from_sg_updates(self):",
            "        self._clean_deleted_sg_rule_conntrack_entries()",
            "        self._clean_updated_sg_member_conntrack_entries()",
            "        self._clean_deleted_remote_sg_members_conntrack_entries()",
            "",
            "    def _get_sg_members(self, sg_info, sg_id, ethertype):",
            "        return set(sg_info.get(sg_id, {}).get(ethertype, []))",
            "",
            "    def filter_defer_apply_off(self):",
            "        if self._defer_apply:",
            "            self._defer_apply = False",
            "            self._remove_chains_apply(self._pre_defer_filtered_ports,",
            "                                      self._pre_defer_unfiltered_ports)",
            "            self._setup_chains_apply(self.filtered_ports,",
            "                                     self.unfiltered_ports)",
            "            self.iptables.defer_apply_off()",
            "            self._remove_conntrack_entries_from_sg_updates()",
            "            self._remove_unused_security_group_info()",
            "            self._pre_defer_filtered_ports = None",
            "            self._pre_defer_unfiltered_ports = None",
            "",
            "    def _populate_initial_zone_map(self):",
            "        \"\"\"Setup the map between devices and zones based on current rules.\"\"\"",
            "        self._device_zone_map = {}",
            "        rules = self.iptables.get_rules_for_table('raw')",
            "        for rule in rules:",
            "            match = re.match(r'.* --physdev-in (?P<dev>[a-zA-Z0-9\\-]+)'",
            "                             r'.* -j CT --zone (?P<zone>\\d+).*', rule)",
            "            if match:",
            "                # strip off any prefix that the interface is using",
            "                short_port_id = match.group('dev')[LINUX_DEV_PREFIX_LEN:]",
            "                self._device_zone_map[short_port_id] = int(match.group('zone'))",
            "        LOG.debug(\"Populated conntrack zone map: %s\", self._device_zone_map)",
            "",
            "    def get_device_zone(self, port_id):",
            "        # we have to key the device_zone_map based on the fragment of the port",
            "        # UUID that shows up in the interface name. This is because the initial",
            "        # map is populated strictly based on interface names that we don't know",
            "        # the full UUID of.",
            "        short_port_id = port_id[:(LINUX_DEV_LEN - LINUX_DEV_PREFIX_LEN)]",
            "        try:",
            "            return self._device_zone_map[short_port_id]",
            "        except KeyError:",
            "            return self._generate_device_zone(short_port_id)",
            "",
            "    def _free_zones_from_removed_ports(self):",
            "        \"\"\"Clears any entries from the zone map of removed ports.\"\"\"",
            "        existing_ports = [",
            "            port['device'][:(LINUX_DEV_LEN - LINUX_DEV_PREFIX_LEN)]",
            "            for port in (list(self.filtered_ports.values()) +",
            "                         list(self.unfiltered_ports.values()))",
            "        ]",
            "        removed = set(self._device_zone_map) - set(existing_ports)",
            "        for dev in removed:",
            "            self._device_zone_map.pop(dev, None)",
            "",
            "    def _generate_device_zone(self, short_port_id):",
            "        \"\"\"Generates a unique conntrack zone for the passed in ID.\"\"\"",
            "        try:",
            "            zone = self._find_open_zone()",
            "        except n_exc.CTZoneExhaustedError:",
            "            # Free some zones and try again, repeat failure will not be caught",
            "            self._free_zones_from_removed_ports()",
            "            zone = self._find_open_zone()",
            "",
            "        self._device_zone_map[short_port_id] = zone",
            "        LOG.debug(\"Assigned CT zone %(z)s to port %(dev)s.\",",
            "                  {'z': zone, 'dev': short_port_id})",
            "        return self._device_zone_map[short_port_id]",
            "",
            "    def _find_open_zone(self):",
            "        # call set to dedup because old ports may be mapped to the same zone.",
            "        zones_in_use = sorted(set(self._device_zone_map.values()))",
            "        if not zones_in_use:",
            "            return 1",
            "        # attempt to increment onto the highest used zone first. if we hit the",
            "        # end, go back and look for any gaps left by removed devices.",
            "        last = zones_in_use[-1]",
            "        if last < MAX_CONNTRACK_ZONES:",
            "            return last + 1",
            "        for index, used in enumerate(zones_in_use):",
            "            if used - index != 1:",
            "                # gap found, let's use it!",
            "                return index + 1",
            "        # conntrack zones exhausted :( :(",
            "        raise n_exc.CTZoneExhaustedError()",
            "",
            "",
            "class OVSHybridIptablesFirewallDriver(IptablesFirewallDriver):",
            "    OVS_HYBRID_TAP_PREFIX = constants.TAP_DEVICE_PREFIX",
            "",
            "    def _port_chain_name(self, port, direction):",
            "        return iptables_manager.get_chain_name(",
            "            '%s%s' % (CHAIN_NAME_PREFIX[direction], port['device']))",
            "",
            "    def _get_device_name(self, port):",
            "        return (self.OVS_HYBRID_TAP_PREFIX + port['device'])[:LINUX_DEV_LEN]",
            "",
            "    def _get_br_device_name(self, port):",
            "        return ('qvb' + port['device'])[:LINUX_DEV_LEN]",
            "",
            "    def _get_jump_rule(self, port, direction):",
            "        if direction == firewall.INGRESS_DIRECTION:",
            "            device = self._get_br_device_name(port)",
            "        else:",
            "            device = self._get_device_name(port)",
            "        jump_rule = '-m physdev --physdev-in %s -j CT --zone %s' % (",
            "            device, self.get_device_zone(port['device']))",
            "        return jump_rule",
            "",
            "    def _add_raw_chain_rules(self, port, direction):",
            "        jump_rule = self._get_jump_rule(port, direction)",
            "        self.iptables.ipv4['raw'].add_rule('PREROUTING', jump_rule)",
            "        self.iptables.ipv6['raw'].add_rule('PREROUTING', jump_rule)",
            "",
            "    def _remove_raw_chain_rules(self, port, direction):",
            "        jump_rule = self._get_jump_rule(port, direction)",
            "        self.iptables.ipv4['raw'].remove_rule('PREROUTING', jump_rule)",
            "        self.iptables.ipv6['raw'].remove_rule('PREROUTING', jump_rule)",
            "",
            "    def _add_chain(self, port, direction):",
            "        super(OVSHybridIptablesFirewallDriver, self)._add_chain(port,",
            "                                                                direction)",
            "        if direction in [firewall.INGRESS_DIRECTION,",
            "                         firewall.EGRESS_DIRECTION]:",
            "            self._add_raw_chain_rules(port, direction)",
            "",
            "    def _remove_chain(self, port, direction):",
            "        super(OVSHybridIptablesFirewallDriver, self)._remove_chain(port,",
            "                                                                   direction)",
            "        if direction in [firewall.INGRESS_DIRECTION,",
            "                         firewall.EGRESS_DIRECTION]:",
            "            self._remove_raw_chain_rules(port, direction)"
        ],
        "afterPatchFile": [
            "# Copyright 2012, Nachi Ueno, NTT MCL, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import collections",
            "import re",
            "",
            "import netaddr",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import six",
            "",
            "from neutron._i18n import _LI",
            "from neutron.agent import firewall",
            "from neutron.agent.linux import ip_conntrack",
            "from neutron.agent.linux import ipset_manager",
            "from neutron.agent.linux import iptables_comments as ic",
            "from neutron.agent.linux import iptables_manager",
            "from neutron.agent.linux import utils",
            "from neutron.common import constants",
            "from neutron.common import exceptions as n_exc",
            "from neutron.common import ipv6_utils",
            "from neutron.common import utils as c_utils",
            "",
            "",
            "LOG = logging.getLogger(__name__)",
            "SG_CHAIN = 'sg-chain'",
            "SPOOF_FILTER = 'spoof-filter'",
            "CHAIN_NAME_PREFIX = {firewall.INGRESS_DIRECTION: 'i',",
            "                     firewall.EGRESS_DIRECTION: 'o',",
            "                     SPOOF_FILTER: 's'}",
            "IPSET_DIRECTION = {firewall.INGRESS_DIRECTION: 'src',",
            "                   firewall.EGRESS_DIRECTION: 'dst'}",
            "# length of all device prefixes (e.g. qvo, tap, qvb)",
            "LINUX_DEV_PREFIX_LEN = 3",
            "LINUX_DEV_LEN = 14",
            "MAX_CONNTRACK_ZONES = 65535",
            "comment_rule = iptables_manager.comment_rule",
            "",
            "",
            "class mac_iptables(netaddr.mac_eui48):",
            "    \"\"\"mac format class for netaddr to match iptables representation.\"\"\"",
            "    word_sep = ':'",
            "",
            "",
            "class IptablesFirewallDriver(firewall.FirewallDriver):",
            "    \"\"\"Driver which enforces security groups through iptables rules.\"\"\"",
            "    IPTABLES_DIRECTION = {firewall.INGRESS_DIRECTION: 'physdev-out',",
            "                          firewall.EGRESS_DIRECTION: 'physdev-in'}",
            "",
            "    def __init__(self, namespace=None):",
            "        self.iptables = iptables_manager.IptablesManager(",
            "            use_ipv6=ipv6_utils.is_enabled(),",
            "            namespace=namespace)",
            "        # TODO(majopela, shihanzhang): refactor out ipset to a separate",
            "        # driver composed over this one",
            "        self.ipset = ipset_manager.IpsetManager(namespace=namespace)",
            "        self.ipconntrack = ip_conntrack.IpConntrackManager(",
            "            self.get_device_zone, namespace=namespace)",
            "        self._populate_initial_zone_map()",
            "        # list of port which has security group",
            "        self.filtered_ports = {}",
            "        self.unfiltered_ports = {}",
            "        self._add_fallback_chain_v4v6()",
            "        self._defer_apply = False",
            "        self._pre_defer_filtered_ports = None",
            "        self._pre_defer_unfiltered_ports = None",
            "        # List of security group rules for ports residing on this host",
            "        self.sg_rules = {}",
            "        self.pre_sg_rules = None",
            "        # List of security group member ips for ports residing on this host",
            "        self.sg_members = collections.defaultdict(",
            "            lambda: collections.defaultdict(list))",
            "        self.pre_sg_members = None",
            "        self.enable_ipset = cfg.CONF.SECURITYGROUP.enable_ipset",
            "        self._enabled_netfilter_for_bridges = False",
            "        self.updated_rule_sg_ids = set()",
            "        self.updated_sg_members = set()",
            "        self.devices_with_updated_sg_members = collections.defaultdict(list)",
            "",
            "    def _enable_netfilter_for_bridges(self):",
            "        # we only need to set these values once, but it has to be when",
            "        # we create a bridge; before that the bridge module might not",
            "        # be loaded and the proc values aren't there.",
            "        if self._enabled_netfilter_for_bridges:",
            "            return",
            "        else:",
            "            self._enabled_netfilter_for_bridges = True",
            "",
            "        # These proc values ensure that netfilter is enabled on",
            "        # bridges; essential for enforcing security groups rules with",
            "        # OVS Hybrid.  Distributions can differ on whether this is",
            "        # enabled by default or not (Ubuntu - yes, Redhat - no, for",
            "        # example).",
            "        LOG.debug(\"Enabling netfilter for bridges\")",
            "        utils.execute(['sysctl', '-w',",
            "                       'net.bridge.bridge-nf-call-arptables=1'],",
            "                      run_as_root=True)",
            "        utils.execute(['sysctl', '-w',",
            "                       'net.bridge.bridge-nf-call-ip6tables=1'],",
            "                      run_as_root=True)",
            "        utils.execute(['sysctl', '-w',",
            "                       'net.bridge.bridge-nf-call-iptables=1'],",
            "                      run_as_root=True)",
            "",
            "    @property",
            "    def ports(self):",
            "        return dict(self.filtered_ports, **self.unfiltered_ports)",
            "",
            "    def _update_remote_security_group_members(self, sec_group_ids):",
            "        for sg_id in sec_group_ids:",
            "            for device in self.filtered_ports.values():",
            "                if sg_id in device.get('security_group_source_groups', []):",
            "                    self.devices_with_updated_sg_members[sg_id].append(device)",
            "",
            "    def security_group_updated(self, action_type, sec_group_ids,",
            "                               device_ids=None):",
            "        device_ids = device_ids or []",
            "        if action_type == 'sg_rule':",
            "            self.updated_rule_sg_ids.update(sec_group_ids)",
            "        elif action_type == 'sg_member':",
            "            if device_ids:",
            "                self.updated_sg_members.update(device_ids)",
            "            else:",
            "                self._update_remote_security_group_members(sec_group_ids)",
            "",
            "    def update_security_group_rules(self, sg_id, sg_rules):",
            "        LOG.debug(\"Update rules of security group (%s)\", sg_id)",
            "        self.sg_rules[sg_id] = sg_rules",
            "",
            "    def update_security_group_members(self, sg_id, sg_members):",
            "        LOG.debug(\"Update members of security group (%s)\", sg_id)",
            "        self.sg_members[sg_id] = collections.defaultdict(list, sg_members)",
            "",
            "    def _set_ports(self, port):",
            "        if not firewall.port_sec_enabled(port):",
            "            self.unfiltered_ports[port['device']] = port",
            "            self.filtered_ports.pop(port['device'], None)",
            "        else:",
            "            self.filtered_ports[port['device']] = port",
            "            self.unfiltered_ports.pop(port['device'], None)",
            "",
            "    def _unset_ports(self, port):",
            "        self.unfiltered_ports.pop(port['device'], None)",
            "        self.filtered_ports.pop(port['device'], None)",
            "",
            "    def prepare_port_filter(self, port):",
            "        LOG.debug(\"Preparing device (%s) filter\", port['device'])",
            "        self._remove_chains()",
            "        self._set_ports(port)",
            "        self._enable_netfilter_for_bridges()",
            "        # each security group has it own chains",
            "        self._setup_chains()",
            "        return self.iptables.apply()",
            "",
            "    def update_port_filter(self, port):",
            "        LOG.debug(\"Updating device (%s) filter\", port['device'])",
            "        if port['device'] not in self.ports:",
            "            LOG.info(_LI('Attempted to update port filter which is not '",
            "                         'filtered %s'), port['device'])",
            "            return",
            "        self._remove_chains()",
            "        self._set_ports(port)",
            "        self._setup_chains()",
            "        return self.iptables.apply()",
            "",
            "    def remove_port_filter(self, port):",
            "        LOG.debug(\"Removing device (%s) filter\", port['device'])",
            "        if port['device'] not in self.ports:",
            "            LOG.info(_LI('Attempted to remove port filter which is not '",
            "                         'filtered %r'), port)",
            "            return",
            "        self._remove_chains()",
            "        self._unset_ports(port)",
            "        self._setup_chains()",
            "        return self.iptables.apply()",
            "",
            "    def _add_accept_rule_port_sec(self, port, direction):",
            "        self._update_port_sec_rules(port, direction, add=True)",
            "",
            "    def _remove_rule_port_sec(self, port, direction):",
            "        self._update_port_sec_rules(port, direction, add=False)",
            "",
            "    def _remove_rule_from_chain_v4v6(self, chain_name, ipv4_rules, ipv6_rules):",
            "        for rule in ipv4_rules:",
            "            self.iptables.ipv4['filter'].remove_rule(chain_name, rule)",
            "",
            "        for rule in ipv6_rules:",
            "            self.iptables.ipv6['filter'].remove_rule(chain_name, rule)",
            "",
            "    def _setup_chains(self):",
            "        \"\"\"Setup ingress and egress chain for a port.\"\"\"",
            "        if not self._defer_apply:",
            "            self._setup_chains_apply(self.filtered_ports,",
            "                                     self.unfiltered_ports)",
            "",
            "    def _setup_chains_apply(self, ports, unfiltered_ports):",
            "        self._add_chain_by_name_v4v6(SG_CHAIN)",
            "        # sort by port so we always do this deterministically between",
            "        # agent restarts and don't cause unnecessary rule differences",
            "        for pname in sorted(ports):",
            "            port = ports[pname]",
            "            self._setup_chain(port, firewall.INGRESS_DIRECTION)",
            "            self._setup_chain(port, firewall.EGRESS_DIRECTION)",
            "        self.iptables.ipv4['filter'].add_rule(SG_CHAIN, '-j ACCEPT')",
            "        self.iptables.ipv6['filter'].add_rule(SG_CHAIN, '-j ACCEPT')",
            "",
            "        for port in unfiltered_ports.values():",
            "            self._add_accept_rule_port_sec(port, firewall.INGRESS_DIRECTION)",
            "            self._add_accept_rule_port_sec(port, firewall.EGRESS_DIRECTION)",
            "",
            "    def _remove_chains(self):",
            "        \"\"\"Remove ingress and egress chain for a port.\"\"\"",
            "        if not self._defer_apply:",
            "            self._remove_chains_apply(self.filtered_ports,",
            "                                      self.unfiltered_ports)",
            "",
            "    def _remove_chains_apply(self, ports, unfiltered_ports):",
            "        for port in ports.values():",
            "            self._remove_chain(port, firewall.INGRESS_DIRECTION)",
            "            self._remove_chain(port, firewall.EGRESS_DIRECTION)",
            "            self._remove_chain(port, SPOOF_FILTER)",
            "        for port in unfiltered_ports.values():",
            "            self._remove_rule_port_sec(port, firewall.INGRESS_DIRECTION)",
            "            self._remove_rule_port_sec(port, firewall.EGRESS_DIRECTION)",
            "        self._remove_chain_by_name_v4v6(SG_CHAIN)",
            "",
            "    def _setup_chain(self, port, DIRECTION):",
            "        self._add_chain(port, DIRECTION)",
            "        self._add_rules_by_security_group(port, DIRECTION)",
            "",
            "    def _remove_chain(self, port, DIRECTION):",
            "        chain_name = self._port_chain_name(port, DIRECTION)",
            "        self._remove_chain_by_name_v4v6(chain_name)",
            "",
            "    def _add_fallback_chain_v4v6(self):",
            "        self.iptables.ipv4['filter'].add_chain('sg-fallback')",
            "        self.iptables.ipv4['filter'].add_rule('sg-fallback', '-j DROP',",
            "                                              comment=ic.UNMATCH_DROP)",
            "        self.iptables.ipv6['filter'].add_chain('sg-fallback')",
            "        self.iptables.ipv6['filter'].add_rule('sg-fallback', '-j DROP',",
            "                                              comment=ic.UNMATCH_DROP)",
            "",
            "    def _add_raw_chain(self, chain_name):",
            "        self.iptables.ipv4['raw'].add_chain(chain_name)",
            "        self.iptables.ipv6['raw'].add_chain(chain_name)",
            "",
            "    def _add_chain_by_name_v4v6(self, chain_name):",
            "        self.iptables.ipv4['filter'].add_chain(chain_name)",
            "        self.iptables.ipv6['filter'].add_chain(chain_name)",
            "",
            "    def _remove_raw_chain(self, chain_name):",
            "        self.iptables.ipv4['raw'].remove_chain(chain_name)",
            "        self.iptables.ipv6['raw'].remove_chain(chain_name)",
            "",
            "    def _remove_chain_by_name_v4v6(self, chain_name):",
            "        self.iptables.ipv4['filter'].remove_chain(chain_name)",
            "        self.iptables.ipv6['filter'].remove_chain(chain_name)",
            "",
            "    def _add_rules_to_chain_v4v6(self, chain_name, ipv4_rules, ipv6_rules,",
            "                                 comment=None):",
            "        for rule in ipv4_rules:",
            "            self.iptables.ipv4['filter'].add_rule(chain_name, rule,",
            "                                                  comment=comment)",
            "",
            "        for rule in ipv6_rules:",
            "            self.iptables.ipv6['filter'].add_rule(chain_name, rule,",
            "                                                  comment=comment)",
            "",
            "    def _get_device_name(self, port):",
            "        return port['device']",
            "",
            "    def _update_port_sec_rules(self, port, direction, add=False):",
            "        # add/remove rules in FORWARD and INPUT chain",
            "        device = self._get_device_name(port)",
            "",
            "        jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                     '-j ACCEPT' % (self.IPTABLES_DIRECTION[direction],",
            "                                    device)]",
            "        if add:",
            "            self._add_rules_to_chain_v4v6(",
            "                'FORWARD', jump_rule, jump_rule, comment=ic.PORT_SEC_ACCEPT)",
            "        else:",
            "            self._remove_rule_from_chain_v4v6('FORWARD', jump_rule, jump_rule)",
            "",
            "        if direction == firewall.EGRESS_DIRECTION:",
            "            jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                         '-j ACCEPT' % (self.IPTABLES_DIRECTION[direction],",
            "                                        device)]",
            "            if add:",
            "                self._add_rules_to_chain_v4v6('INPUT', jump_rule, jump_rule,",
            "                                              comment=ic.PORT_SEC_ACCEPT)",
            "            else:",
            "                self._remove_rule_from_chain_v4v6(",
            "                    'INPUT', jump_rule, jump_rule)",
            "",
            "    def _add_chain(self, port, direction):",
            "        chain_name = self._port_chain_name(port, direction)",
            "        self._add_chain_by_name_v4v6(chain_name)",
            "",
            "        # Note(nati) jump to the security group chain (SG_CHAIN)",
            "        # This is needed because the packet may much two rule in port",
            "        # if the two port is in the same host",
            "        # We accept the packet at the end of SG_CHAIN.",
            "",
            "        # jump to the security group chain",
            "        device = self._get_device_name(port)",
            "        jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                     '-j $%s' % (self.IPTABLES_DIRECTION[direction],",
            "                                 device,",
            "                                 SG_CHAIN)]",
            "        self._add_rules_to_chain_v4v6('FORWARD', jump_rule, jump_rule,",
            "                                      comment=ic.VM_INT_SG)",
            "",
            "        # jump to the chain based on the device",
            "        jump_rule = ['-m physdev --%s %s --physdev-is-bridged '",
            "                     '-j $%s' % (self.IPTABLES_DIRECTION[direction],",
            "                                 device,",
            "                                 chain_name)]",
            "        self._add_rules_to_chain_v4v6(SG_CHAIN, jump_rule, jump_rule,",
            "                                      comment=ic.SG_TO_VM_SG)",
            "",
            "        if direction == firewall.EGRESS_DIRECTION:",
            "            self._add_rules_to_chain_v4v6('INPUT', jump_rule, jump_rule,",
            "                                          comment=ic.INPUT_TO_SG)",
            "",
            "    def _split_sgr_by_ethertype(self, security_group_rules):",
            "        ipv4_sg_rules = []",
            "        ipv6_sg_rules = []",
            "        for rule in security_group_rules:",
            "            if rule.get('ethertype') == constants.IPv4:",
            "                ipv4_sg_rules.append(rule)",
            "            elif rule.get('ethertype') == constants.IPv6:",
            "                if rule.get('protocol') == 'icmp':",
            "                    rule['protocol'] = 'ipv6-icmp'",
            "                ipv6_sg_rules.append(rule)",
            "        return ipv4_sg_rules, ipv6_sg_rules",
            "",
            "    def _select_sgr_by_direction(self, port, direction):",
            "        return [rule",
            "                for rule in port.get('security_group_rules', [])",
            "                if rule['direction'] == direction]",
            "",
            "    def _setup_spoof_filter_chain(self, port, table, mac_ip_pairs, rules):",
            "        if mac_ip_pairs:",
            "            chain_name = self._port_chain_name(port, SPOOF_FILTER)",
            "            table.add_chain(chain_name)",
            "            for mac, ip in mac_ip_pairs:",
            "                if ip is None:",
            "                    # If fixed_ips is [] this rule will be added to the end",
            "                    # of the list after the allowed_address_pair rules.",
            "                    table.add_rule(chain_name,",
            "                                   '-m mac --mac-source %s -j RETURN'",
            "                                   % mac.upper(), comment=ic.PAIR_ALLOW)",
            "                else:",
            "                    # we need to convert it into a prefix to match iptables",
            "                    ip = c_utils.ip_to_cidr(ip)",
            "                    table.add_rule(chain_name,",
            "                                   '-s %s -m mac --mac-source %s -j RETURN'",
            "                                   % (ip, mac.upper()), comment=ic.PAIR_ALLOW)",
            "            table.add_rule(chain_name, '-j DROP', comment=ic.PAIR_DROP)",
            "            rules.append('-j $%s' % chain_name)",
            "",
            "    def _build_ipv4v6_mac_ip_list(self, mac, ip_address, mac_ipv4_pairs,",
            "                                  mac_ipv6_pairs):",
            "        mac = str(netaddr.EUI(mac, dialect=mac_iptables))",
            "        if netaddr.IPNetwork(ip_address).version == 4:",
            "            mac_ipv4_pairs.append((mac, ip_address))",
            "        else:",
            "            mac_ipv6_pairs.append((mac, ip_address))",
            "",
            "    def _spoofing_rule(self, port, ipv4_rules, ipv6_rules):",
            "        # Allow dhcp client discovery and request",
            "        ipv4_rules += [comment_rule('-s 0.0.0.0/32 -d 255.255.255.255/32 '",
            "                                    '-p udp -m udp --sport 68 --dport 67 '",
            "                                    '-j RETURN', comment=ic.DHCP_CLIENT)]",
            "        # Drop Router Advts from the port.",
            "        ipv6_rules += [comment_rule('-p ipv6-icmp -m icmp6 --icmpv6-type %s '",
            "                                    '-j DROP' % constants.ICMPV6_TYPE_RA,",
            "                                    comment=ic.IPV6_RA_DROP)]",
            "        ipv6_rules += [comment_rule('-p ipv6-icmp -j RETURN',",
            "                                    comment=ic.IPV6_ICMP_ALLOW)]",
            "        ipv6_rules += [comment_rule('-p udp -m udp --sport 546 '",
            "                                    '-m udp --dport 547 '",
            "                                    '-j RETURN', comment=ic.DHCP_CLIENT)]",
            "        mac_ipv4_pairs = []",
            "        mac_ipv6_pairs = []",
            "",
            "        if isinstance(port.get('allowed_address_pairs'), list):",
            "            for address_pair in port['allowed_address_pairs']:",
            "                self._build_ipv4v6_mac_ip_list(address_pair['mac_address'],",
            "                                               address_pair['ip_address'],",
            "                                               mac_ipv4_pairs,",
            "                                               mac_ipv6_pairs)",
            "",
            "        for ip in port['fixed_ips']:",
            "            self._build_ipv4v6_mac_ip_list(port['mac_address'], ip,",
            "                                           mac_ipv4_pairs, mac_ipv6_pairs)",
            "        if not port['fixed_ips']:",
            "            mac_ipv4_pairs.append((port['mac_address'], None))",
            "            mac_ipv6_pairs.append((port['mac_address'], None))",
            "",
            "        self._setup_spoof_filter_chain(port, self.iptables.ipv4['filter'],",
            "                                       mac_ipv4_pairs, ipv4_rules)",
            "        self._setup_spoof_filter_chain(port, self.iptables.ipv6['filter'],",
            "                                       mac_ipv6_pairs, ipv6_rules)",
            "        # Allow dhcp client renewal and rebinding",
            "        ipv4_rules += [comment_rule('-p udp -m udp --sport 68 --dport 67 '",
            "                                    '-j RETURN', comment=ic.DHCP_CLIENT)]",
            "",
            "    def _drop_dhcp_rule(self, ipv4_rules, ipv6_rules):",
            "        #Note(nati) Drop dhcp packet from VM",
            "        ipv4_rules += [comment_rule('-p udp -m udp --sport 67 '",
            "                                    '-m udp --dport 68 '",
            "                                    '-j DROP', comment=ic.DHCP_SPOOF)]",
            "        ipv6_rules += [comment_rule('-p udp -m udp --sport 547 '",
            "                                    '-m udp --dport 546 '",
            "                                    '-j DROP', comment=ic.DHCP_SPOOF)]",
            "",
            "    def _accept_inbound_icmpv6(self):",
            "        # Allow multicast listener, neighbor solicitation and",
            "        # neighbor advertisement into the instance",
            "        icmpv6_rules = []",
            "        for icmp6_type in constants.ICMPV6_ALLOWED_TYPES:",
            "            icmpv6_rules += ['-p ipv6-icmp -m icmp6 --icmpv6-type %s '",
            "                             '-j RETURN' % icmp6_type]",
            "        return icmpv6_rules",
            "",
            "    def _select_sg_rules_for_port(self, port, direction):",
            "        \"\"\"Select rules from the security groups the port is member of.\"\"\"",
            "        port_sg_ids = port.get('security_groups', [])",
            "        port_rules = []",
            "",
            "        for sg_id in port_sg_ids:",
            "            for rule in self.sg_rules.get(sg_id, []):",
            "                if rule['direction'] == direction:",
            "                    if self.enable_ipset:",
            "                        port_rules.append(rule)",
            "                    else:",
            "                        port_rules.extend(",
            "                            self._expand_sg_rule_with_remote_ips(",
            "                                rule, port, direction))",
            "        return port_rules",
            "",
            "    def _expand_sg_rule_with_remote_ips(self, rule, port, direction):",
            "        \"\"\"Expand a remote group rule to rule per remote group IP.\"\"\"",
            "        remote_group_id = rule.get('remote_group_id')",
            "        if remote_group_id:",
            "            ethertype = rule['ethertype']",
            "            port_ips = port.get('fixed_ips', [])",
            "",
            "            for ip in self.sg_members[remote_group_id][ethertype]:",
            "                if ip not in port_ips:",
            "                    ip_rule = rule.copy()",
            "                    direction_ip_prefix = firewall.DIRECTION_IP_PREFIX[",
            "                        direction]",
            "                    ip_prefix = str(netaddr.IPNetwork(ip).cidr)",
            "                    ip_rule[direction_ip_prefix] = ip_prefix",
            "                    yield ip_rule",
            "        else:",
            "            yield rule",
            "",
            "    def _get_remote_sg_ids(self, port, direction=None):",
            "        sg_ids = port.get('security_groups', [])",
            "        remote_sg_ids = {constants.IPv4: set(), constants.IPv6: set()}",
            "        for sg_id in sg_ids:",
            "            for rule in self.sg_rules.get(sg_id, []):",
            "                if not direction or rule['direction'] == direction:",
            "                    remote_sg_id = rule.get('remote_group_id')",
            "                    ether_type = rule.get('ethertype')",
            "                    if remote_sg_id and ether_type:",
            "                        remote_sg_ids[ether_type].add(remote_sg_id)",
            "        return remote_sg_ids",
            "",
            "    def _add_rules_by_security_group(self, port, direction):",
            "        # select rules for current port and direction",
            "        security_group_rules = self._select_sgr_by_direction(port, direction)",
            "        security_group_rules += self._select_sg_rules_for_port(port, direction)",
            "        # make sure ipset members are updated for remote security groups",
            "        if self.enable_ipset:",
            "            remote_sg_ids = self._get_remote_sg_ids(port, direction)",
            "            self._update_ipset_members(remote_sg_ids)",
            "        # split groups by ip version",
            "        # for ipv4, iptables command is used",
            "        # for ipv6, iptables6 command is used",
            "        ipv4_sg_rules, ipv6_sg_rules = self._split_sgr_by_ethertype(",
            "            security_group_rules)",
            "        ipv4_iptables_rules = []",
            "        ipv6_iptables_rules = []",
            "        # include fixed egress/ingress rules",
            "        if direction == firewall.EGRESS_DIRECTION:",
            "            self._add_fixed_egress_rules(port,",
            "                                         ipv4_iptables_rules,",
            "                                         ipv6_iptables_rules)",
            "        elif direction == firewall.INGRESS_DIRECTION:",
            "            ipv6_iptables_rules += self._accept_inbound_icmpv6()",
            "        # include IPv4 and IPv6 iptable rules from security group",
            "        ipv4_iptables_rules += self._convert_sgr_to_iptables_rules(",
            "            ipv4_sg_rules)",
            "        ipv6_iptables_rules += self._convert_sgr_to_iptables_rules(",
            "            ipv6_sg_rules)",
            "        # finally add the rules to the port chain for a given direction",
            "        self._add_rules_to_chain_v4v6(self._port_chain_name(port, direction),",
            "                                      ipv4_iptables_rules,",
            "                                      ipv6_iptables_rules)",
            "",
            "    def _add_fixed_egress_rules(self, port, ipv4_iptables_rules,",
            "                                ipv6_iptables_rules):",
            "        self._spoofing_rule(port,",
            "                            ipv4_iptables_rules,",
            "                            ipv6_iptables_rules)",
            "        self._drop_dhcp_rule(ipv4_iptables_rules, ipv6_iptables_rules)",
            "",
            "    def _update_ipset_members(self, security_group_ids):",
            "        for ip_version, sg_ids in security_group_ids.items():",
            "            for sg_id in sg_ids:",
            "                current_ips = self.sg_members[sg_id][ip_version]",
            "                self.ipset.set_members(sg_id, ip_version, current_ips)",
            "",
            "    def _generate_ipset_rule_args(self, sg_rule, remote_gid):",
            "        ethertype = sg_rule.get('ethertype')",
            "        ipset_name = self.ipset.get_name(remote_gid, ethertype)",
            "        if not self.ipset.set_name_exists(ipset_name):",
            "            #NOTE(mangelajo): ipsets for empty groups are not created",
            "            #                 thus we can't reference them.",
            "            return None",
            "        ipset_direction = IPSET_DIRECTION[sg_rule.get('direction')]",
            "        args = self._generate_protocol_and_port_args(sg_rule)",
            "        args += ['-m set', '--match-set', ipset_name, ipset_direction]",
            "        args += ['-j RETURN']",
            "        return args",
            "",
            "    def _generate_protocol_and_port_args(self, sg_rule):",
            "        args = self._protocol_arg(sg_rule.get('protocol'))",
            "        args += self._port_arg('sport',",
            "                               sg_rule.get('protocol'),",
            "                               sg_rule.get('source_port_range_min'),",
            "                               sg_rule.get('source_port_range_max'))",
            "        args += self._port_arg('dport',",
            "                               sg_rule.get('protocol'),",
            "                               sg_rule.get('port_range_min'),",
            "                               sg_rule.get('port_range_max'))",
            "        return args",
            "",
            "    def _generate_plain_rule_args(self, sg_rule):",
            "        # These arguments MUST be in the format iptables-save will",
            "        # display them: source/dest, protocol, sport, dport, target",
            "        # Otherwise the iptables_manager code won't be able to find",
            "        # them to preserve their [packet:byte] counts.",
            "        args = self._ip_prefix_arg('s', sg_rule.get('source_ip_prefix'))",
            "        args += self._ip_prefix_arg('d', sg_rule.get('dest_ip_prefix'))",
            "        args += self._generate_protocol_and_port_args(sg_rule)",
            "        args += ['-j RETURN']",
            "        return args",
            "",
            "    def _convert_sg_rule_to_iptables_args(self, sg_rule):",
            "        remote_gid = sg_rule.get('remote_group_id')",
            "        if self.enable_ipset and remote_gid:",
            "            return self._generate_ipset_rule_args(sg_rule, remote_gid)",
            "        else:",
            "            return self._generate_plain_rule_args(sg_rule)",
            "",
            "    def _convert_sgr_to_iptables_rules(self, security_group_rules):",
            "        iptables_rules = []",
            "        self._allow_established(iptables_rules)",
            "        for rule in security_group_rules:",
            "            args = self._convert_sg_rule_to_iptables_args(rule)",
            "            if args:",
            "                iptables_rules += [' '.join(args)]",
            "",
            "        self._drop_invalid_packets(iptables_rules)",
            "        iptables_rules += [comment_rule('-j $sg-fallback',",
            "                                        comment=ic.UNMATCHED)]",
            "        return iptables_rules",
            "",
            "    def _drop_invalid_packets(self, iptables_rules):",
            "        # Always drop invalid packets",
            "        iptables_rules += [comment_rule('-m state --state ' 'INVALID -j DROP',",
            "                                        comment=ic.INVALID_DROP)]",
            "        return iptables_rules",
            "",
            "    def _allow_established(self, iptables_rules):",
            "        # Allow established connections",
            "        iptables_rules += [comment_rule(",
            "            '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "            comment=ic.ALLOW_ASSOC)]",
            "        return iptables_rules",
            "",
            "    def _protocol_arg(self, protocol):",
            "        if not protocol:",
            "            return []",
            "        if protocol == 'icmpv6':",
            "            protocol = 'ipv6-icmp'",
            "        iptables_rule = ['-p', protocol]",
            "        return iptables_rule",
            "",
            "    def _port_arg(self, direction, protocol, port_range_min, port_range_max):",
            "        if (protocol not in ['udp', 'tcp', 'icmp', 'ipv6-icmp']",
            "            or port_range_min is None):",
            "            return []",
            "",
            "        protocol_modules = {'udp': 'udp', 'tcp': 'tcp',",
            "                            'icmp': 'icmp', 'ipv6-icmp': 'icmp6'}",
            "        # iptables adds '-m protocol' when the port number is specified",
            "        args = ['-m', protocol_modules[protocol]]",
            "",
            "        if protocol in ['icmp', 'ipv6-icmp']:",
            "            protocol_type = 'icmpv6' if protocol == 'ipv6-icmp' else 'icmp'",
            "            # Note(xuhanp): port_range_min/port_range_max represent",
            "            # icmp type/code when protocol is icmp or icmpv6",
            "            args += ['--%s-type' % protocol_type, '%s' % port_range_min]",
            "            # icmp code can be 0 so we cannot use \"if port_range_max\" here",
            "            if port_range_max is not None:",
            "                args[-1] += '/%s' % port_range_max",
            "        elif port_range_min == port_range_max:",
            "            args += ['--%s' % direction, '%s' % (port_range_min,)]",
            "        else:",
            "            args += ['-m', 'multiport', '--%ss' % direction,",
            "                     '%s:%s' % (port_range_min, port_range_max)]",
            "        return args",
            "",
            "    def _ip_prefix_arg(self, direction, ip_prefix):",
            "        #NOTE (nati) : source_group_id is converted to list of source_",
            "        # ip_prefix in server side",
            "        if ip_prefix:",
            "            if '/' not in ip_prefix:",
            "                # we need to convert it into a prefix to match iptables",
            "                ip_prefix = c_utils.ip_to_cidr(ip_prefix)",
            "            elif ip_prefix.endswith('/0'):",
            "                # an allow for every address is not a constraint so",
            "                # iptables drops it",
            "                return []",
            "            return ['-%s' % direction, ip_prefix]",
            "        return []",
            "",
            "    def _port_chain_name(self, port, direction):",
            "        return iptables_manager.get_chain_name(",
            "            '%s%s' % (CHAIN_NAME_PREFIX[direction], port['device'][3:]))",
            "",
            "    def filter_defer_apply_on(self):",
            "        if not self._defer_apply:",
            "            self.iptables.defer_apply_on()",
            "            self._pre_defer_filtered_ports = dict(self.filtered_ports)",
            "            self._pre_defer_unfiltered_ports = dict(self.unfiltered_ports)",
            "            self.pre_sg_members = dict(self.sg_members)",
            "            self.pre_sg_rules = dict(self.sg_rules)",
            "            self._defer_apply = True",
            "",
            "    def _remove_unused_security_group_info(self):",
            "        \"\"\"Remove any unnecessary local security group info or unused ipsets.",
            "",
            "        This function has to be called after applying the last iptables",
            "        rules, so we're in a point where no iptable rule depends",
            "        on an ipset we're going to delete.",
            "        \"\"\"",
            "        filtered_ports = self.filtered_ports.values()",
            "",
            "        remote_sgs_to_remove = self._determine_remote_sgs_to_remove(",
            "            filtered_ports)",
            "",
            "        for ip_version, remote_sg_ids in six.iteritems(remote_sgs_to_remove):",
            "            if self.enable_ipset:",
            "                self._remove_ipsets_for_remote_sgs(ip_version, remote_sg_ids)",
            "",
            "        self._remove_sg_members(remote_sgs_to_remove)",
            "",
            "        # Remove unused security group rules",
            "        for remove_group_id in self._determine_sg_rules_to_remove(",
            "                filtered_ports):",
            "            self.sg_rules.pop(remove_group_id, None)",
            "",
            "    def _determine_remote_sgs_to_remove(self, filtered_ports):",
            "        \"\"\"Calculate which remote security groups we don't need anymore.",
            "",
            "        We do the calculation for each ip_version.",
            "        \"\"\"",
            "        sgs_to_remove_per_ipversion = {constants.IPv4: set(),",
            "                                       constants.IPv6: set()}",
            "        remote_group_id_sets = self._get_remote_sg_ids_sets_by_ipversion(",
            "            filtered_ports)",
            "        for ip_version, remote_group_id_set in (",
            "                six.iteritems(remote_group_id_sets)):",
            "            sgs_to_remove_per_ipversion[ip_version].update(",
            "                set(self.pre_sg_members) - remote_group_id_set)",
            "        return sgs_to_remove_per_ipversion",
            "",
            "    def _get_remote_sg_ids_sets_by_ipversion(self, filtered_ports):",
            "        \"\"\"Given a port, calculates the remote sg references by ip_version.\"\"\"",
            "        remote_group_id_sets = {constants.IPv4: set(),",
            "                                constants.IPv6: set()}",
            "        for port in filtered_ports:",
            "            remote_sg_ids = self._get_remote_sg_ids(port)",
            "            for ip_version in (constants.IPv4, constants.IPv6):",
            "                remote_group_id_sets[ip_version] |= remote_sg_ids[ip_version]",
            "        return remote_group_id_sets",
            "",
            "    def _determine_sg_rules_to_remove(self, filtered_ports):",
            "        \"\"\"Calculate which security groups need to be removed.",
            "",
            "        We find out by subtracting our previous sg group ids,",
            "        with the security groups associated to a set of ports.",
            "        \"\"\"",
            "        port_group_ids = self._get_sg_ids_set_for_ports(filtered_ports)",
            "        return set(self.pre_sg_rules) - port_group_ids",
            "",
            "    def _get_sg_ids_set_for_ports(self, filtered_ports):",
            "        \"\"\"Get the port security group ids as a set.\"\"\"",
            "        port_group_ids = set()",
            "        for port in filtered_ports:",
            "            port_group_ids.update(port.get('security_groups', []))",
            "        return port_group_ids",
            "",
            "    def _remove_ipsets_for_remote_sgs(self, ip_version, remote_sg_ids):",
            "        \"\"\"Remove system ipsets matching the provided parameters.\"\"\"",
            "        for remote_sg_id in remote_sg_ids:",
            "            self.ipset.destroy(remote_sg_id, ip_version)",
            "",
            "    def _remove_sg_members(self, remote_sgs_to_remove):",
            "        \"\"\"Remove sg_member entries.\"\"\"",
            "        ipv4_sec_group_set = remote_sgs_to_remove.get(constants.IPv4)",
            "        ipv6_sec_group_set = remote_sgs_to_remove.get(constants.IPv6)",
            "        for sg_id in (ipv4_sec_group_set & ipv6_sec_group_set):",
            "            if sg_id in self.sg_members:",
            "                del self.sg_members[sg_id]",
            "",
            "    def _find_deleted_sg_rules(self, sg_id):",
            "        del_rules = list()",
            "        for pre_rule in self.pre_sg_rules.get(sg_id, []):",
            "            if pre_rule not in self.sg_rules.get(sg_id, []):",
            "                del_rules.append(pre_rule)",
            "        return del_rules",
            "",
            "    def _find_devices_on_security_group(self, sg_id):",
            "        device_list = list()",
            "        for device in self.filtered_ports.values():",
            "            if sg_id in device.get('security_groups', []):",
            "                device_list.append(device)",
            "        return device_list",
            "",
            "    def _clean_deleted_sg_rule_conntrack_entries(self):",
            "        deleted_sg_ids = set()",
            "        for sg_id in self.updated_rule_sg_ids:",
            "            del_rules = self._find_deleted_sg_rules(sg_id)",
            "            if not del_rules:",
            "                continue",
            "            device_list = self._find_devices_on_security_group(sg_id)",
            "            for rule in del_rules:",
            "                self.ipconntrack.delete_conntrack_state_by_rule(",
            "                    device_list, rule)",
            "            deleted_sg_ids.add(sg_id)",
            "        for id in deleted_sg_ids:",
            "            self.updated_rule_sg_ids.remove(id)",
            "",
            "    def _clean_updated_sg_member_conntrack_entries(self):",
            "        updated_device_ids = set()",
            "        for device in self.updated_sg_members:",
            "            sec_group_change = False",
            "            device_info = self.filtered_ports.get(device)",
            "            pre_device_info = self._pre_defer_filtered_ports.get(device)",
            "            if not device_info or not pre_device_info:",
            "                continue",
            "            for sg_id in pre_device_info.get('security_groups', []):",
            "                if sg_id not in device_info.get('security_groups', []):",
            "                    sec_group_change = True",
            "                    break",
            "            if not sec_group_change:",
            "                continue",
            "            for ethertype in [constants.IPv4, constants.IPv6]:",
            "                self.ipconntrack.delete_conntrack_state_by_remote_ips(",
            "                    [device_info], ethertype, set())",
            "            updated_device_ids.add(device)",
            "        for id in updated_device_ids:",
            "            self.updated_sg_members.remove(id)",
            "",
            "    def _clean_deleted_remote_sg_members_conntrack_entries(self):",
            "        deleted_sg_ids = set()",
            "        for sg_id, devices in self.devices_with_updated_sg_members.items():",
            "            for ethertype in [constants.IPv4, constants.IPv6]:",
            "                pre_ips = self._get_sg_members(",
            "                    self.pre_sg_members, sg_id, ethertype)",
            "                cur_ips = self._get_sg_members(",
            "                    self.sg_members, sg_id, ethertype)",
            "                ips = (pre_ips - cur_ips)",
            "                if devices and ips:",
            "                    self.ipconntrack.delete_conntrack_state_by_remote_ips(",
            "                        devices, ethertype, ips)",
            "            deleted_sg_ids.add(sg_id)",
            "        for id in deleted_sg_ids:",
            "            self.devices_with_updated_sg_members.pop(id, None)",
            "",
            "    def _remove_conntrack_entries_from_sg_updates(self):",
            "        self._clean_deleted_sg_rule_conntrack_entries()",
            "        self._clean_updated_sg_member_conntrack_entries()",
            "        self._clean_deleted_remote_sg_members_conntrack_entries()",
            "",
            "    def _get_sg_members(self, sg_info, sg_id, ethertype):",
            "        return set(sg_info.get(sg_id, {}).get(ethertype, []))",
            "",
            "    def filter_defer_apply_off(self):",
            "        if self._defer_apply:",
            "            self._defer_apply = False",
            "            self._remove_chains_apply(self._pre_defer_filtered_ports,",
            "                                      self._pre_defer_unfiltered_ports)",
            "            self._setup_chains_apply(self.filtered_ports,",
            "                                     self.unfiltered_ports)",
            "            self.iptables.defer_apply_off()",
            "            self._remove_conntrack_entries_from_sg_updates()",
            "            self._remove_unused_security_group_info()",
            "            self._pre_defer_filtered_ports = None",
            "            self._pre_defer_unfiltered_ports = None",
            "",
            "    def _populate_initial_zone_map(self):",
            "        \"\"\"Setup the map between devices and zones based on current rules.\"\"\"",
            "        self._device_zone_map = {}",
            "        rules = self.iptables.get_rules_for_table('raw')",
            "        for rule in rules:",
            "            match = re.match(r'.* --physdev-in (?P<dev>[a-zA-Z0-9\\-]+)'",
            "                             r'.* -j CT --zone (?P<zone>\\d+).*', rule)",
            "            if match:",
            "                # strip off any prefix that the interface is using",
            "                short_port_id = match.group('dev')[LINUX_DEV_PREFIX_LEN:]",
            "                self._device_zone_map[short_port_id] = int(match.group('zone'))",
            "        LOG.debug(\"Populated conntrack zone map: %s\", self._device_zone_map)",
            "",
            "    def get_device_zone(self, port_id):",
            "        # we have to key the device_zone_map based on the fragment of the port",
            "        # UUID that shows up in the interface name. This is because the initial",
            "        # map is populated strictly based on interface names that we don't know",
            "        # the full UUID of.",
            "        short_port_id = port_id[:(LINUX_DEV_LEN - LINUX_DEV_PREFIX_LEN)]",
            "        try:",
            "            return self._device_zone_map[short_port_id]",
            "        except KeyError:",
            "            return self._generate_device_zone(short_port_id)",
            "",
            "    def _free_zones_from_removed_ports(self):",
            "        \"\"\"Clears any entries from the zone map of removed ports.\"\"\"",
            "        existing_ports = [",
            "            port['device'][:(LINUX_DEV_LEN - LINUX_DEV_PREFIX_LEN)]",
            "            for port in (list(self.filtered_ports.values()) +",
            "                         list(self.unfiltered_ports.values()))",
            "        ]",
            "        removed = set(self._device_zone_map) - set(existing_ports)",
            "        for dev in removed:",
            "            self._device_zone_map.pop(dev, None)",
            "",
            "    def _generate_device_zone(self, short_port_id):",
            "        \"\"\"Generates a unique conntrack zone for the passed in ID.\"\"\"",
            "        try:",
            "            zone = self._find_open_zone()",
            "        except n_exc.CTZoneExhaustedError:",
            "            # Free some zones and try again, repeat failure will not be caught",
            "            self._free_zones_from_removed_ports()",
            "            zone = self._find_open_zone()",
            "",
            "        self._device_zone_map[short_port_id] = zone",
            "        LOG.debug(\"Assigned CT zone %(z)s to port %(dev)s.\",",
            "                  {'z': zone, 'dev': short_port_id})",
            "        return self._device_zone_map[short_port_id]",
            "",
            "    def _find_open_zone(self):",
            "        # call set to dedup because old ports may be mapped to the same zone.",
            "        zones_in_use = sorted(set(self._device_zone_map.values()))",
            "        if not zones_in_use:",
            "            return 1",
            "        # attempt to increment onto the highest used zone first. if we hit the",
            "        # end, go back and look for any gaps left by removed devices.",
            "        last = zones_in_use[-1]",
            "        if last < MAX_CONNTRACK_ZONES:",
            "            return last + 1",
            "        for index, used in enumerate(zones_in_use):",
            "            if used - index != 1:",
            "                # gap found, let's use it!",
            "                return index + 1",
            "        # conntrack zones exhausted :( :(",
            "        raise n_exc.CTZoneExhaustedError()",
            "",
            "",
            "class OVSHybridIptablesFirewallDriver(IptablesFirewallDriver):",
            "    OVS_HYBRID_TAP_PREFIX = constants.TAP_DEVICE_PREFIX",
            "",
            "    def _port_chain_name(self, port, direction):",
            "        return iptables_manager.get_chain_name(",
            "            '%s%s' % (CHAIN_NAME_PREFIX[direction], port['device']))",
            "",
            "    def _get_device_name(self, port):",
            "        return (self.OVS_HYBRID_TAP_PREFIX + port['device'])[:LINUX_DEV_LEN]",
            "",
            "    def _get_br_device_name(self, port):",
            "        return ('qvb' + port['device'])[:LINUX_DEV_LEN]",
            "",
            "    def _get_jump_rule(self, port, direction):",
            "        if direction == firewall.INGRESS_DIRECTION:",
            "            device = self._get_br_device_name(port)",
            "        else:",
            "            device = self._get_device_name(port)",
            "        jump_rule = '-m physdev --physdev-in %s -j CT --zone %s' % (",
            "            device, self.get_device_zone(port['device']))",
            "        return jump_rule",
            "",
            "    def _add_raw_chain_rules(self, port, direction):",
            "        jump_rule = self._get_jump_rule(port, direction)",
            "        self.iptables.ipv4['raw'].add_rule('PREROUTING', jump_rule)",
            "        self.iptables.ipv6['raw'].add_rule('PREROUTING', jump_rule)",
            "",
            "    def _remove_raw_chain_rules(self, port, direction):",
            "        jump_rule = self._get_jump_rule(port, direction)",
            "        self.iptables.ipv4['raw'].remove_rule('PREROUTING', jump_rule)",
            "        self.iptables.ipv6['raw'].remove_rule('PREROUTING', jump_rule)",
            "",
            "    def _add_chain(self, port, direction):",
            "        super(OVSHybridIptablesFirewallDriver, self)._add_chain(port,",
            "                                                                direction)",
            "        if direction in [firewall.INGRESS_DIRECTION,",
            "                         firewall.EGRESS_DIRECTION]:",
            "            self._add_raw_chain_rules(port, direction)",
            "",
            "    def _remove_chain(self, port, direction):",
            "        super(OVSHybridIptablesFirewallDriver, self)._remove_chain(port,",
            "                                                                   direction)",
            "        if direction in [firewall.INGRESS_DIRECTION,",
            "                         firewall.EGRESS_DIRECTION]:",
            "            self._remove_raw_chain_rules(port, direction)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "384": [
                "IptablesFirewallDriver",
                "_spoofing_rule"
            ],
            "385": [
                "IptablesFirewallDriver",
                "_spoofing_rule"
            ],
            "386": [
                "IptablesFirewallDriver",
                "_spoofing_rule"
            ]
        },
        "addLocation": []
    },
    "neutron/tests/functional/agent/test_firewall.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "                                          direction=self.tester.INGRESS)"
            },
            "1": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         self.tester.assert_no_connection(protocol=self.tester.ICMP,"
            },
            "2": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 357,
                "PatchRowcode": "                                          direction=self.tester.EGRESS)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        self.tester.assert_no_connection(protocol=self.tester.UDP,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+                                         src_port=68, dst_port=67,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+                                         direction=self.tester.EGRESS)"
            },
            "6": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 361,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "     @skip_if_firewall('openvswitch')"
            },
            "8": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 363,
                "PatchRowcode": "     def test_ip_spoofing_works_without_port_security_enabled(self):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Intel Corporation.",
            "# Copyright 2015 Isaku Yamahata <isaku.yamahata at intel com>",
            "#                               <isaku.yamahata at gmail com>",
            "# Copyright 2015 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import functools",
            "import random",
            "",
            "import netaddr",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import testscenarios",
            "",
            "from neutron.agent import firewall",
            "from neutron.agent.linux import iptables_firewall",
            "from neutron.agent.linux import openvswitch_firewall",
            "from neutron.agent import securitygroups_rpc as sg_cfg",
            "from neutron.cmd.sanity import checks",
            "from neutron.common import constants",
            "from neutron.tests.common import conn_testers",
            "from neutron.tests.functional import base",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "load_tests = testscenarios.load_tests_apply_scenarios",
            "",
            "reverse_direction = {",
            "    conn_testers.ConnectionTester.INGRESS:",
            "        conn_testers.ConnectionTester.EGRESS,",
            "    conn_testers.ConnectionTester.EGRESS:",
            "        conn_testers.ConnectionTester.INGRESS}",
            "reverse_transport_protocol = {",
            "    conn_testers.ConnectionTester.TCP: conn_testers.ConnectionTester.UDP,",
            "    conn_testers.ConnectionTester.UDP: conn_testers.ConnectionTester.TCP}",
            "",
            "DEVICE_OWNER_COMPUTE = constants.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "VLAN_COUNT = 4096",
            "",
            "",
            "def skip_if_firewall(firewall_name):",
            "    def outter(f):",
            "        @functools.wraps(f)",
            "        def wrap(self, *args, **kwargs):",
            "            if self.firewall_name == firewall_name:",
            "                self.skipTest(\"This test doesn't use %s firewall\" %",
            "                              firewall_name)",
            "            return f(self, *args, **kwargs)",
            "        return wrap",
            "    return outter",
            "",
            "",
            "def _add_rule(sg_rules, base, port_range_min=None, port_range_max=None):",
            "    rule = copy.copy(base)",
            "    if port_range_min:",
            "        rule['port_range_min'] = port_range_min",
            "    if port_range_max:",
            "        rule['port_range_max'] = port_range_max",
            "    sg_rules.append(rule)",
            "",
            "",
            "class BaseFirewallTestCase(base.BaseSudoTestCase):",
            "    FAKE_SECURITY_GROUP_ID = 'fake_sg_id'",
            "    MAC_SPOOFED = \"fa:16:3e:9a:2f:48\"",
            "    scenarios = [('IptablesFirewallDriver without ipset',",
            "                  {'enable_ipset': False,",
            "                   'initialize': 'initialize_iptables',",
            "                   'firewall_name': 'iptables'}),",
            "                 ('IptablesFirewallDriver with ipset',",
            "                  {'enable_ipset': True,",
            "                   'initialize': 'initialize_iptables',",
            "                   'firewall_name': 'iptables'}),",
            "                 ('OVS Firewall Driver',",
            "                  {'initialize': 'initialize_ovs',",
            "                   'firewall_name': 'openvswitch'})]",
            "    ip_cidr = None",
            "    vlan_range = set(range(VLAN_COUNT))",
            "",
            "    def setUp(self):",
            "        cfg.CONF.register_opts(sg_cfg.security_group_opts, 'SECURITYGROUP')",
            "        super(BaseFirewallTestCase, self).setUp()",
            "        self.tester, self.firewall = getattr(self, self.initialize)()",
            "        if self.firewall_name == \"openvswitch\":",
            "            self.assign_vlan_to_peers()",
            "        self.src_port_desc = self._create_port_description(",
            "            self.tester.vm_port_id,",
            "            [self.tester.vm_ip_address],",
            "            self.tester.vm_mac_address,",
            "            [self.FAKE_SECURITY_GROUP_ID])",
            "        # FIXME(jlibosva): We should consider to call prepare_port_filter with",
            "        # deferred bridge depending on its performance",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "",
            "    def initialize_iptables(self):",
            "        cfg.CONF.set_override('enable_ipset', self.enable_ipset,",
            "                              'SECURITYGROUP')",
            "        tester = self.useFixture(",
            "            conn_testers.LinuxBridgeConnectionTester(self.ip_cidr))",
            "        firewall_drv = iptables_firewall.IptablesFirewallDriver(",
            "            namespace=tester.bridge_namespace)",
            "        return tester, firewall_drv",
            "",
            "    def initialize_ovs(self):",
            "        # Tests for ovs requires kernel >= 4.3 and OVS >= 2.5",
            "        if not checks.ovs_conntrack_supported():",
            "            self.skipTest(\"Open vSwitch with conntrack is not installed \"",
            "                          \"on this machine. To run tests for OVS/CT firewall,\"",
            "                          \" please meet the requirements (kernel>=4.3, \"",
            "                          \"OVS>=2.5. More info at\"",
            "                          \"https://github.com/openvswitch/ovs/blob/master/\"",
            "                          \"FAQ.md\")",
            "        tester = self.useFixture(",
            "            conn_testers.OVSConnectionTester(self.ip_cidr))",
            "        firewall_drv = openvswitch_firewall.OVSFirewallDriver(tester.bridge)",
            "        return tester, firewall_drv",
            "",
            "    def assign_vlan_to_peers(self):",
            "        vlan = self.get_not_used_vlan()",
            "        LOG.debug(\"Using %d vlan tag for this test\", vlan)",
            "        self.tester.set_vm_tag(vlan)",
            "        self.tester.set_peer_tag(vlan)",
            "",
            "    def get_not_used_vlan(self):",
            "        port_vlans = self.firewall.int_br.br.ovsdb.db_find(",
            "                'Port', ('tag', '!=', '[]'), columns=['tag']).execute()",
            "        used_vlan_tags = {val['tag'] for val in port_vlans}",
            "        available_vlans = self.vlan_range - used_vlan_tags",
            "        return random.choice(list(available_vlans))",
            "",
            "    @staticmethod",
            "    def _create_port_description(port_id, ip_addresses, mac_address, sg_ids):",
            "        return {'admin_state_up': True,",
            "                'device': port_id,",
            "                'device_owner': DEVICE_OWNER_COMPUTE,",
            "                'fixed_ips': ip_addresses,",
            "                'mac_address': mac_address,",
            "                'port_security_enabled': True,",
            "                'security_groups': sg_ids,",
            "                'status': 'ACTIVE'}",
            "",
            "    def _apply_security_group_rules(self, sg_id, sg_rules):",
            "        with self.firewall.defer_apply():",
            "            self.firewall.update_security_group_rules(sg_id, sg_rules)",
            "            self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "    def _apply_security_group_members(self, sg_id, members):",
            "        with self.firewall.defer_apply():",
            "            self.firewall.update_security_group_members(sg_id, members)",
            "            self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "",
            "class FirewallTestCase(BaseFirewallTestCase):",
            "    ip_cidr = '192.168.0.1/24'",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_rule_application_converges(self):",
            "        sg_rules = [{'ethertype': 'IPv4', 'direction': 'egress'},",
            "                    {'ethertype': 'IPv6', 'direction': 'egress'},",
            "                    {'ethertype': 'IPv4', 'direction': 'ingress',",
            "                     'source_ip_prefix': '0.0.0.0/0', 'protocol': 'icmp'},",
            "                    {'ethertype': 'IPv6', 'direction': 'ingress',",
            "                     'source_ip_prefix': '0::0/0', 'protocol': 'ipv6-icmp'}]",
            "        # make sure port ranges converge on all protocols with and without",
            "        # port ranges (prevents regression of bug 1502924)",
            "        for proto in ('tcp', 'udp', 'icmp'):",
            "            for version in ('IPv4', 'IPv6'):",
            "                if proto == 'icmp' and version == 'IPv6':",
            "                    proto = 'ipv6-icmp'",
            "                base = {'ethertype': version, 'direction': 'ingress',",
            "                        'protocol': proto}",
            "                sg_rules.append(copy.copy(base))",
            "                _add_rule(sg_rules, base, port_range_min=50,",
            "                          port_range_max=50)",
            "                _add_rule(sg_rules, base, port_range_max=55)",
            "                _add_rule(sg_rules, base, port_range_min=60,",
            "                          port_range_max=60)",
            "                _add_rule(sg_rules, base, port_range_max=65)",
            "",
            "        # add some single-host rules to prevent regression of bug 1502917",
            "        sg_rules.append({'ethertype': 'IPv4', 'direction': 'ingress',",
            "                         'source_ip_prefix': '77.77.77.77/32'})",
            "        sg_rules.append({'ethertype': 'IPv6', 'direction': 'ingress',",
            "                         'source_ip_prefix': 'fe80::1/128'})",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        # after one prepare call, another apply should be a NOOP",
            "        self.assertEqual([], self.firewall.iptables._apply())",
            "",
            "        orig_sg_rules = copy.copy(sg_rules)",
            "        for proto in ('tcp', 'udp', 'icmp'):",
            "            for version in ('IPv4', 'IPv6'):",
            "                if proto == 'icmp' and version == 'IPv6':",
            "                    proto = 'ipv6-icmp'",
            "                # make sure firewall is in converged state",
            "                self.firewall.update_security_group_rules(",
            "                    self.FAKE_SECURITY_GROUP_ID, orig_sg_rules)",
            "                self.firewall.update_port_filter(self.src_port_desc)",
            "                sg_rules = copy.copy(orig_sg_rules)",
            "",
            "                # remove one rule and add another to make sure it results in",
            "                # exactly one delete and insert",
            "                sg_rules.pop(0 if version == 'IPv4' else 1)",
            "                sg_rules.append({'ethertype': version, 'direction': 'egress',",
            "                                 'protocol': proto})",
            "                self.firewall.update_security_group_rules(",
            "                    self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "                result = self.firewall.update_port_filter(self.src_port_desc)",
            "                deletes = [r for r in result if r.startswith('-D ')]",
            "                creates = [r for r in result if r.startswith('-I ')]",
            "                self.assertEqual(1, len(deletes))",
            "                self.assertEqual(1, len(creates))",
            "                # quick sanity check to make sure the insert was for the",
            "                # correct proto",
            "                self.assertIn('-p %s' % proto, creates[0])",
            "                # another apply should be a NOOP if the right rule was removed",
            "                # and the new one was inserted in the correct position",
            "                self.assertEqual([], self.firewall.iptables._apply())",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_rule_ordering_correct(self):",
            "        sg_rules = [",
            "            {'ethertype': 'IPv4', 'direction': 'egress', 'protocol': 'tcp',",
            "             'port_range_min': i, 'port_range_max': i}",
            "            for i in range(50, 61)",
            "        ]",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        self._assert_sg_out_tcp_rules_appear_in_order(sg_rules)",
            "        # remove a rule and add a new one",
            "        sg_rules.pop(5)",
            "        sg_rules.insert(8, {'ethertype': 'IPv4', 'direction': 'egress',",
            "                            'protocol': 'tcp', 'port_range_min': 400,",
            "                            'port_range_max': 400})",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        self._assert_sg_out_tcp_rules_appear_in_order(sg_rules)",
            "",
            "        # reverse all of the rules (requires lots of deletes and inserts)",
            "        sg_rules = list(reversed(sg_rules))",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        self._assert_sg_out_tcp_rules_appear_in_order(sg_rules)",
            "",
            "    def _assert_sg_out_tcp_rules_appear_in_order(self, sg_rules):",
            "        outgoing_rule_pref = '-A %s-o%s' % (self.firewall.iptables.wrap_name,",
            "                                            self.src_port_desc['device'][3:13])",
            "        rules = [",
            "            r for r in self.firewall.iptables.get_rules_for_table('filter')",
            "            if r.startswith(outgoing_rule_pref)",
            "        ]",
            "        # we want to ensure the rules went in in the same order we sent",
            "        indexes = [rules.index('%s -p tcp -m tcp --dport %s -j RETURN' %",
            "                               (outgoing_rule_pref, i['port_range_min']))",
            "                   for i in sg_rules]",
            "        # all indexes should be in order with no unexpected rules in between",
            "        self.assertEqual(range(indexes[0], indexes[-1] + 1), indexes)",
            "",
            "    def test_ingress_icmp_secgroup(self):",
            "        # update the sg_group to make ping pass",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP},",
            "                    {'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def test_mac_spoofing(self):",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP},",
            "                    {'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_mac_address = self.MAC_SPOOFED",
            "        self.tester.flush_arp_tables()",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_mac_spoofing_works_without_port_security_enabled(self):",
            "        self.src_port_desc['port_security_enabled'] = False",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_mac_address = self.MAC_SPOOFED",
            "        self.tester.flush_arp_tables()",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.EGRESS)",
            "",
            "    def test_port_security_enabled_set_to_false(self):",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.src_port_desc['port_security_enabled'] = False",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def test_dhcp_requests_from_vm(self):",
            "        # DHCPv4 uses source port 67, destination port 68",
            "        self.tester.assert_connection(direction=self.tester.EGRESS,",
            "                                      protocol=self.tester.UDP,",
            "                                      src_port=68, dst_port=67)",
            "",
            "    def test_dhcp_server_forbidden_on_vm(self):",
            "        self.tester.assert_no_connection(direction=self.tester.EGRESS,",
            "                                         protocol=self.tester.UDP,",
            "                                         src_port=67, dst_port=68)",
            "        self.tester.assert_no_connection(direction=self.tester.INGRESS,",
            "                                         protocol=self.tester.UDP,",
            "                                         src_port=68, dst_port=67)",
            "",
            "    def test_ip_spoofing(self):",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        not_allowed_ip = \"%s/24\" % (",
            "            netaddr.IPAddress(self.tester.vm_ip_address) + 1)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = not_allowed_ip",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_ip_spoofing_works_without_port_security_enabled(self):",
            "        self.src_port_desc['port_security_enabled'] = False",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        not_allowed_ip = \"%s/24\" % (",
            "            netaddr.IPAddress(self.tester.vm_ip_address) + 1)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = not_allowed_ip",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.EGRESS)",
            "",
            "    def test_allowed_address_pairs(self):",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP},",
            "                    {'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        port_mac = self.tester.vm_mac_address",
            "        allowed_ip = netaddr.IPAddress(self.tester.vm_ip_address) + 1",
            "        not_allowed_ip = \"%s/24\" % (allowed_ip + 1)",
            "        self.src_port_desc['allowed_address_pairs'] = [",
            "            {'mac_address': port_mac,",
            "             'ip_address': allowed_ip}]",
            "        allowed_ip = \"%s/24\" % allowed_ip",
            "",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = allowed_ip",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = not_allowed_ip",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "",
            "    def test_arp_is_allowed(self):",
            "        self.tester.assert_connection(protocol=self.tester.ARP,",
            "                                      direction=self.tester.EGRESS)",
            "        self.tester.assert_connection(protocol=self.tester.ARP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def _test_rule(self, direction, protocol):",
            "        sg_rules = [{'ethertype': constants.IPv4, 'direction': direction,",
            "                     'protocol': protocol}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        not_allowed_direction = reverse_direction[direction]",
            "        not_allowed_protocol = reverse_transport_protocol[protocol]",
            "",
            "        self.tester.assert_connection(protocol=protocol,",
            "                                      direction=direction)",
            "        self.tester.assert_no_connection(protocol=not_allowed_protocol,",
            "                                         direction=direction)",
            "        self.tester.assert_no_connection(protocol=protocol,",
            "                                         direction=not_allowed_direction)",
            "",
            "    def test_ingress_tcp_rule(self):",
            "        self._test_rule(self.tester.INGRESS, self.tester.TCP)",
            "",
            "    def test_ingress_udp_rule(self):",
            "        self._test_rule(self.tester.INGRESS, self.tester.UDP)",
            "",
            "    def test_egress_tcp_rule(self):",
            "        self._test_rule(self.tester.EGRESS, self.tester.TCP)",
            "",
            "    def test_egress_udp_rule(self):",
            "        self._test_rule(self.tester.EGRESS, self.tester.UDP)",
            "",
            "    def test_connection_with_destination_port_range(self):",
            "        port_min = 12345",
            "        port_max = 12346",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'port_range_min': port_min,",
            "                     'port_range_max': port_max}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.INGRESS,",
            "                                      dst_port=port_min)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.INGRESS,",
            "                                      dst_port=port_max)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS,",
            "                                         dst_port=port_min - 1)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS,",
            "                                         dst_port=port_max + 1)",
            "",
            "    def test_connection_with_source_port_range(self):",
            "        source_port_min = 12345",
            "        source_port_max = 12346",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'source_port_range_min': source_port_min,",
            "                     'source_port_range_max': source_port_max}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.EGRESS,",
            "                                      src_port=source_port_min)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.EGRESS,",
            "                                      src_port=source_port_max)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS,",
            "                                         src_port=source_port_min - 1)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS,",
            "                                         src_port=source_port_max + 1)",
            "",
            "    @skip_if_firewall('iptables')",
            "    def test_established_connection_is_cut(self):",
            "        port = 12345",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'port_range_min': port,",
            "                     'port_range_max': port}]",
            "        connection = {'protocol': self.tester.TCP,",
            "                      'direction': self.tester.INGRESS,",
            "                      'dst_port': port}",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.establish_connection(**connection)",
            "",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, list())",
            "        self.tester.assert_no_established_connection(**connection)",
            "",
            "    def test_preventing_firewall_blink(self):",
            "        direction = self.tester.INGRESS",
            "        sg_rules = [{'ethertype': 'IPv4', 'direction': 'ingress',",
            "                     'protocol': 'tcp'}]",
            "        self.tester.start_sending_icmp(direction)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, {})",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.stop_sending_icmp(direction)",
            "        packets_sent = self.tester.get_sent_icmp_packets(direction)",
            "        packets_received = self.tester.get_received_icmp_packets(direction)",
            "        self.assertGreater(packets_sent, 0)",
            "        self.assertEqual(packets_received, 0)",
            "",
            "    def test_remote_security_groups(self):",
            "        remote_sg_id = 'remote_sg_id'",
            "        peer_port_desc = self._create_port_description(",
            "            self.tester.peer_port_id,",
            "            [self.tester.peer_ip_address],",
            "            self.tester.peer_mac_address,",
            "            [remote_sg_id])",
            "",
            "        vm_sg_members = {'IPv4': [self.tester.peer_ip_address]}",
            "        peer_sg_rules = [{'ethertype': 'IPv4', 'direction': 'egress',",
            "                          'protocol': 'icmp'}]",
            "        self.firewall.update_security_group_rules(remote_sg_id, peer_sg_rules)",
            "        self.firewall.update_security_group_members(remote_sg_id,",
            "                                                    vm_sg_members)",
            "        self.firewall.prepare_port_filter(peer_port_desc)",
            "",
            "        vm_sg_rules = [{'ethertype': 'IPv4', 'direction': 'ingress',",
            "                        'protocol': 'icmp', 'remote_group_id': remote_sg_id}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID,",
            "                                         vm_sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    def test_related_connection(self):",
            "        \"\"\"Test ICMP net unreachable packets get back",
            "",
            "        When destination address of ip traffic is not reachable, ICMP packets",
            "        are returned. This packets are marked as RELATED traffic by conntrack",
            "        and this test case validates such packets are not dropped by the",
            "        firewall as ingress ICMP packets are not allowed in this test case. The",
            "        used address below 1.2.3.4 is outside of subnet that is used in tester",
            "        object.",
            "",
            "        \"\"\"",
            "        # Enable ip forwarding on the interface in order to reply with",
            "        # destionation net unreachable",
            "        self.tester._peer.execute([",
            "            'sysctl', '-w', 'net.ipv4.conf.%s.forwarding=1' %",
            "            self.tester._peer.port.name])",
            "        self.tester.set_vm_default_gateway(self.tester.peer_ip_address)",
            "        vm_sg_rules = [{'ethertype': 'IPv4', 'direction': 'egress',",
            "                        'protocol': 'icmp'}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID,",
            "                                         vm_sg_rules)",
            "",
            "        self.tester.assert_net_unreachable(self.tester.EGRESS, '1.2.3.4')",
            "",
            "",
            "class FirewallTestCaseIPv6(BaseFirewallTestCase):",
            "    scenarios = [('OVS Firewall Driver',",
            "                  {'initialize': 'initialize_ovs',",
            "                   'firewall_name': 'openvswitch'})]",
            "    ip_cidr = '2001:db8:aaaa::1/64'",
            "",
            "    def test_icmp_from_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP,",
            "                     'source_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def test_icmp_to_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP,",
            "                     'destination_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.EGRESS)",
            "",
            "    def test_tcp_from_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'source_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "",
            "    def test_tcp_to_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'destination_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    def test_udp_from_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_UDP,",
            "                     'source_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.UDP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "",
            "    def test_udp_to_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_UDP,",
            "                     'destination_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.EGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.UDP,",
            "                                      direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Intel Corporation.",
            "# Copyright 2015 Isaku Yamahata <isaku.yamahata at intel com>",
            "#                               <isaku.yamahata at gmail com>",
            "# Copyright 2015 Red Hat, Inc.",
            "# All Rights Reserved.",
            "#",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "import functools",
            "import random",
            "",
            "import netaddr",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "import testscenarios",
            "",
            "from neutron.agent import firewall",
            "from neutron.agent.linux import iptables_firewall",
            "from neutron.agent.linux import openvswitch_firewall",
            "from neutron.agent import securitygroups_rpc as sg_cfg",
            "from neutron.cmd.sanity import checks",
            "from neutron.common import constants",
            "from neutron.tests.common import conn_testers",
            "from neutron.tests.functional import base",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "load_tests = testscenarios.load_tests_apply_scenarios",
            "",
            "reverse_direction = {",
            "    conn_testers.ConnectionTester.INGRESS:",
            "        conn_testers.ConnectionTester.EGRESS,",
            "    conn_testers.ConnectionTester.EGRESS:",
            "        conn_testers.ConnectionTester.INGRESS}",
            "reverse_transport_protocol = {",
            "    conn_testers.ConnectionTester.TCP: conn_testers.ConnectionTester.UDP,",
            "    conn_testers.ConnectionTester.UDP: conn_testers.ConnectionTester.TCP}",
            "",
            "DEVICE_OWNER_COMPUTE = constants.DEVICE_OWNER_COMPUTE_PREFIX + 'fake'",
            "VLAN_COUNT = 4096",
            "",
            "",
            "def skip_if_firewall(firewall_name):",
            "    def outter(f):",
            "        @functools.wraps(f)",
            "        def wrap(self, *args, **kwargs):",
            "            if self.firewall_name == firewall_name:",
            "                self.skipTest(\"This test doesn't use %s firewall\" %",
            "                              firewall_name)",
            "            return f(self, *args, **kwargs)",
            "        return wrap",
            "    return outter",
            "",
            "",
            "def _add_rule(sg_rules, base, port_range_min=None, port_range_max=None):",
            "    rule = copy.copy(base)",
            "    if port_range_min:",
            "        rule['port_range_min'] = port_range_min",
            "    if port_range_max:",
            "        rule['port_range_max'] = port_range_max",
            "    sg_rules.append(rule)",
            "",
            "",
            "class BaseFirewallTestCase(base.BaseSudoTestCase):",
            "    FAKE_SECURITY_GROUP_ID = 'fake_sg_id'",
            "    MAC_SPOOFED = \"fa:16:3e:9a:2f:48\"",
            "    scenarios = [('IptablesFirewallDriver without ipset',",
            "                  {'enable_ipset': False,",
            "                   'initialize': 'initialize_iptables',",
            "                   'firewall_name': 'iptables'}),",
            "                 ('IptablesFirewallDriver with ipset',",
            "                  {'enable_ipset': True,",
            "                   'initialize': 'initialize_iptables',",
            "                   'firewall_name': 'iptables'}),",
            "                 ('OVS Firewall Driver',",
            "                  {'initialize': 'initialize_ovs',",
            "                   'firewall_name': 'openvswitch'})]",
            "    ip_cidr = None",
            "    vlan_range = set(range(VLAN_COUNT))",
            "",
            "    def setUp(self):",
            "        cfg.CONF.register_opts(sg_cfg.security_group_opts, 'SECURITYGROUP')",
            "        super(BaseFirewallTestCase, self).setUp()",
            "        self.tester, self.firewall = getattr(self, self.initialize)()",
            "        if self.firewall_name == \"openvswitch\":",
            "            self.assign_vlan_to_peers()",
            "        self.src_port_desc = self._create_port_description(",
            "            self.tester.vm_port_id,",
            "            [self.tester.vm_ip_address],",
            "            self.tester.vm_mac_address,",
            "            [self.FAKE_SECURITY_GROUP_ID])",
            "        # FIXME(jlibosva): We should consider to call prepare_port_filter with",
            "        # deferred bridge depending on its performance",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "",
            "    def initialize_iptables(self):",
            "        cfg.CONF.set_override('enable_ipset', self.enable_ipset,",
            "                              'SECURITYGROUP')",
            "        tester = self.useFixture(",
            "            conn_testers.LinuxBridgeConnectionTester(self.ip_cidr))",
            "        firewall_drv = iptables_firewall.IptablesFirewallDriver(",
            "            namespace=tester.bridge_namespace)",
            "        return tester, firewall_drv",
            "",
            "    def initialize_ovs(self):",
            "        # Tests for ovs requires kernel >= 4.3 and OVS >= 2.5",
            "        if not checks.ovs_conntrack_supported():",
            "            self.skipTest(\"Open vSwitch with conntrack is not installed \"",
            "                          \"on this machine. To run tests for OVS/CT firewall,\"",
            "                          \" please meet the requirements (kernel>=4.3, \"",
            "                          \"OVS>=2.5. More info at\"",
            "                          \"https://github.com/openvswitch/ovs/blob/master/\"",
            "                          \"FAQ.md\")",
            "        tester = self.useFixture(",
            "            conn_testers.OVSConnectionTester(self.ip_cidr))",
            "        firewall_drv = openvswitch_firewall.OVSFirewallDriver(tester.bridge)",
            "        return tester, firewall_drv",
            "",
            "    def assign_vlan_to_peers(self):",
            "        vlan = self.get_not_used_vlan()",
            "        LOG.debug(\"Using %d vlan tag for this test\", vlan)",
            "        self.tester.set_vm_tag(vlan)",
            "        self.tester.set_peer_tag(vlan)",
            "",
            "    def get_not_used_vlan(self):",
            "        port_vlans = self.firewall.int_br.br.ovsdb.db_find(",
            "                'Port', ('tag', '!=', '[]'), columns=['tag']).execute()",
            "        used_vlan_tags = {val['tag'] for val in port_vlans}",
            "        available_vlans = self.vlan_range - used_vlan_tags",
            "        return random.choice(list(available_vlans))",
            "",
            "    @staticmethod",
            "    def _create_port_description(port_id, ip_addresses, mac_address, sg_ids):",
            "        return {'admin_state_up': True,",
            "                'device': port_id,",
            "                'device_owner': DEVICE_OWNER_COMPUTE,",
            "                'fixed_ips': ip_addresses,",
            "                'mac_address': mac_address,",
            "                'port_security_enabled': True,",
            "                'security_groups': sg_ids,",
            "                'status': 'ACTIVE'}",
            "",
            "    def _apply_security_group_rules(self, sg_id, sg_rules):",
            "        with self.firewall.defer_apply():",
            "            self.firewall.update_security_group_rules(sg_id, sg_rules)",
            "            self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "    def _apply_security_group_members(self, sg_id, members):",
            "        with self.firewall.defer_apply():",
            "            self.firewall.update_security_group_members(sg_id, members)",
            "            self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "",
            "class FirewallTestCase(BaseFirewallTestCase):",
            "    ip_cidr = '192.168.0.1/24'",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_rule_application_converges(self):",
            "        sg_rules = [{'ethertype': 'IPv4', 'direction': 'egress'},",
            "                    {'ethertype': 'IPv6', 'direction': 'egress'},",
            "                    {'ethertype': 'IPv4', 'direction': 'ingress',",
            "                     'source_ip_prefix': '0.0.0.0/0', 'protocol': 'icmp'},",
            "                    {'ethertype': 'IPv6', 'direction': 'ingress',",
            "                     'source_ip_prefix': '0::0/0', 'protocol': 'ipv6-icmp'}]",
            "        # make sure port ranges converge on all protocols with and without",
            "        # port ranges (prevents regression of bug 1502924)",
            "        for proto in ('tcp', 'udp', 'icmp'):",
            "            for version in ('IPv4', 'IPv6'):",
            "                if proto == 'icmp' and version == 'IPv6':",
            "                    proto = 'ipv6-icmp'",
            "                base = {'ethertype': version, 'direction': 'ingress',",
            "                        'protocol': proto}",
            "                sg_rules.append(copy.copy(base))",
            "                _add_rule(sg_rules, base, port_range_min=50,",
            "                          port_range_max=50)",
            "                _add_rule(sg_rules, base, port_range_max=55)",
            "                _add_rule(sg_rules, base, port_range_min=60,",
            "                          port_range_max=60)",
            "                _add_rule(sg_rules, base, port_range_max=65)",
            "",
            "        # add some single-host rules to prevent regression of bug 1502917",
            "        sg_rules.append({'ethertype': 'IPv4', 'direction': 'ingress',",
            "                         'source_ip_prefix': '77.77.77.77/32'})",
            "        sg_rules.append({'ethertype': 'IPv6', 'direction': 'ingress',",
            "                         'source_ip_prefix': 'fe80::1/128'})",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        # after one prepare call, another apply should be a NOOP",
            "        self.assertEqual([], self.firewall.iptables._apply())",
            "",
            "        orig_sg_rules = copy.copy(sg_rules)",
            "        for proto in ('tcp', 'udp', 'icmp'):",
            "            for version in ('IPv4', 'IPv6'):",
            "                if proto == 'icmp' and version == 'IPv6':",
            "                    proto = 'ipv6-icmp'",
            "                # make sure firewall is in converged state",
            "                self.firewall.update_security_group_rules(",
            "                    self.FAKE_SECURITY_GROUP_ID, orig_sg_rules)",
            "                self.firewall.update_port_filter(self.src_port_desc)",
            "                sg_rules = copy.copy(orig_sg_rules)",
            "",
            "                # remove one rule and add another to make sure it results in",
            "                # exactly one delete and insert",
            "                sg_rules.pop(0 if version == 'IPv4' else 1)",
            "                sg_rules.append({'ethertype': version, 'direction': 'egress',",
            "                                 'protocol': proto})",
            "                self.firewall.update_security_group_rules(",
            "                    self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "                result = self.firewall.update_port_filter(self.src_port_desc)",
            "                deletes = [r for r in result if r.startswith('-D ')]",
            "                creates = [r for r in result if r.startswith('-I ')]",
            "                self.assertEqual(1, len(deletes))",
            "                self.assertEqual(1, len(creates))",
            "                # quick sanity check to make sure the insert was for the",
            "                # correct proto",
            "                self.assertIn('-p %s' % proto, creates[0])",
            "                # another apply should be a NOOP if the right rule was removed",
            "                # and the new one was inserted in the correct position",
            "                self.assertEqual([], self.firewall.iptables._apply())",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_rule_ordering_correct(self):",
            "        sg_rules = [",
            "            {'ethertype': 'IPv4', 'direction': 'egress', 'protocol': 'tcp',",
            "             'port_range_min': i, 'port_range_max': i}",
            "            for i in range(50, 61)",
            "        ]",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        self._assert_sg_out_tcp_rules_appear_in_order(sg_rules)",
            "        # remove a rule and add a new one",
            "        sg_rules.pop(5)",
            "        sg_rules.insert(8, {'ethertype': 'IPv4', 'direction': 'egress',",
            "                            'protocol': 'tcp', 'port_range_min': 400,",
            "                            'port_range_max': 400})",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        self._assert_sg_out_tcp_rules_appear_in_order(sg_rules)",
            "",
            "        # reverse all of the rules (requires lots of deletes and inserts)",
            "        sg_rules = list(reversed(sg_rules))",
            "        self.firewall.update_security_group_rules(",
            "            self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.firewall.prepare_port_filter(self.src_port_desc)",
            "        self._assert_sg_out_tcp_rules_appear_in_order(sg_rules)",
            "",
            "    def _assert_sg_out_tcp_rules_appear_in_order(self, sg_rules):",
            "        outgoing_rule_pref = '-A %s-o%s' % (self.firewall.iptables.wrap_name,",
            "                                            self.src_port_desc['device'][3:13])",
            "        rules = [",
            "            r for r in self.firewall.iptables.get_rules_for_table('filter')",
            "            if r.startswith(outgoing_rule_pref)",
            "        ]",
            "        # we want to ensure the rules went in in the same order we sent",
            "        indexes = [rules.index('%s -p tcp -m tcp --dport %s -j RETURN' %",
            "                               (outgoing_rule_pref, i['port_range_min']))",
            "                   for i in sg_rules]",
            "        # all indexes should be in order with no unexpected rules in between",
            "        self.assertEqual(range(indexes[0], indexes[-1] + 1), indexes)",
            "",
            "    def test_ingress_icmp_secgroup(self):",
            "        # update the sg_group to make ping pass",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP},",
            "                    {'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def test_mac_spoofing(self):",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP},",
            "                    {'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_mac_address = self.MAC_SPOOFED",
            "        self.tester.flush_arp_tables()",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_mac_spoofing_works_without_port_security_enabled(self):",
            "        self.src_port_desc['port_security_enabled'] = False",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_mac_address = self.MAC_SPOOFED",
            "        self.tester.flush_arp_tables()",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.EGRESS)",
            "",
            "    def test_port_security_enabled_set_to_false(self):",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.src_port_desc['port_security_enabled'] = False",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def test_dhcp_requests_from_vm(self):",
            "        # DHCPv4 uses source port 67, destination port 68",
            "        self.tester.assert_connection(direction=self.tester.EGRESS,",
            "                                      protocol=self.tester.UDP,",
            "                                      src_port=68, dst_port=67)",
            "",
            "    def test_dhcp_server_forbidden_on_vm(self):",
            "        self.tester.assert_no_connection(direction=self.tester.EGRESS,",
            "                                         protocol=self.tester.UDP,",
            "                                         src_port=67, dst_port=68)",
            "        self.tester.assert_no_connection(direction=self.tester.INGRESS,",
            "                                         protocol=self.tester.UDP,",
            "                                         src_port=68, dst_port=67)",
            "",
            "    def test_ip_spoofing(self):",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        not_allowed_ip = \"%s/24\" % (",
            "            netaddr.IPAddress(self.tester.vm_ip_address) + 1)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = not_allowed_ip",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         src_port=68, dst_port=67,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    @skip_if_firewall('openvswitch')",
            "    def test_ip_spoofing_works_without_port_security_enabled(self):",
            "        self.src_port_desc['port_security_enabled'] = False",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        not_allowed_ip = \"%s/24\" % (",
            "            netaddr.IPAddress(self.tester.vm_ip_address) + 1)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = not_allowed_ip",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.EGRESS)",
            "",
            "    def test_allowed_address_pairs(self):",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP},",
            "                    {'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        port_mac = self.tester.vm_mac_address",
            "        allowed_ip = netaddr.IPAddress(self.tester.vm_ip_address) + 1",
            "        not_allowed_ip = \"%s/24\" % (allowed_ip + 1)",
            "        self.src_port_desc['allowed_address_pairs'] = [",
            "            {'mac_address': port_mac,",
            "             'ip_address': allowed_ip}]",
            "        allowed_ip = \"%s/24\" % allowed_ip",
            "",
            "        self.firewall.update_port_filter(self.src_port_desc)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = allowed_ip",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.vm_ip_cidr = not_allowed_ip",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "",
            "    def test_arp_is_allowed(self):",
            "        self.tester.assert_connection(protocol=self.tester.ARP,",
            "                                      direction=self.tester.EGRESS)",
            "        self.tester.assert_connection(protocol=self.tester.ARP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def _test_rule(self, direction, protocol):",
            "        sg_rules = [{'ethertype': constants.IPv4, 'direction': direction,",
            "                     'protocol': protocol}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        not_allowed_direction = reverse_direction[direction]",
            "        not_allowed_protocol = reverse_transport_protocol[protocol]",
            "",
            "        self.tester.assert_connection(protocol=protocol,",
            "                                      direction=direction)",
            "        self.tester.assert_no_connection(protocol=not_allowed_protocol,",
            "                                         direction=direction)",
            "        self.tester.assert_no_connection(protocol=protocol,",
            "                                         direction=not_allowed_direction)",
            "",
            "    def test_ingress_tcp_rule(self):",
            "        self._test_rule(self.tester.INGRESS, self.tester.TCP)",
            "",
            "    def test_ingress_udp_rule(self):",
            "        self._test_rule(self.tester.INGRESS, self.tester.UDP)",
            "",
            "    def test_egress_tcp_rule(self):",
            "        self._test_rule(self.tester.EGRESS, self.tester.TCP)",
            "",
            "    def test_egress_udp_rule(self):",
            "        self._test_rule(self.tester.EGRESS, self.tester.UDP)",
            "",
            "    def test_connection_with_destination_port_range(self):",
            "        port_min = 12345",
            "        port_max = 12346",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'port_range_min': port_min,",
            "                     'port_range_max': port_max}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.INGRESS,",
            "                                      dst_port=port_min)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.INGRESS,",
            "                                      dst_port=port_max)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS,",
            "                                         dst_port=port_min - 1)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS,",
            "                                         dst_port=port_max + 1)",
            "",
            "    def test_connection_with_source_port_range(self):",
            "        source_port_min = 12345",
            "        source_port_max = 12346",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'source_port_range_min': source_port_min,",
            "                     'source_port_range_max': source_port_max}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.EGRESS,",
            "                                      src_port=source_port_min)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.EGRESS,",
            "                                      src_port=source_port_max)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS,",
            "                                         src_port=source_port_min - 1)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS,",
            "                                         src_port=source_port_max + 1)",
            "",
            "    @skip_if_firewall('iptables')",
            "    def test_established_connection_is_cut(self):",
            "        port = 12345",
            "        sg_rules = [{'ethertype': constants.IPv4,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'port_range_min': port,",
            "                     'port_range_max': port}]",
            "        connection = {'protocol': self.tester.TCP,",
            "                      'direction': self.tester.INGRESS,",
            "                      'dst_port': port}",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.establish_connection(**connection)",
            "",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, list())",
            "        self.tester.assert_no_established_connection(**connection)",
            "",
            "    def test_preventing_firewall_blink(self):",
            "        direction = self.tester.INGRESS",
            "        sg_rules = [{'ethertype': 'IPv4', 'direction': 'ingress',",
            "                     'protocol': 'tcp'}]",
            "        self.tester.start_sending_icmp(direction)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, {})",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.stop_sending_icmp(direction)",
            "        packets_sent = self.tester.get_sent_icmp_packets(direction)",
            "        packets_received = self.tester.get_received_icmp_packets(direction)",
            "        self.assertGreater(packets_sent, 0)",
            "        self.assertEqual(packets_received, 0)",
            "",
            "    def test_remote_security_groups(self):",
            "        remote_sg_id = 'remote_sg_id'",
            "        peer_port_desc = self._create_port_description(",
            "            self.tester.peer_port_id,",
            "            [self.tester.peer_ip_address],",
            "            self.tester.peer_mac_address,",
            "            [remote_sg_id])",
            "",
            "        vm_sg_members = {'IPv4': [self.tester.peer_ip_address]}",
            "        peer_sg_rules = [{'ethertype': 'IPv4', 'direction': 'egress',",
            "                          'protocol': 'icmp'}]",
            "        self.firewall.update_security_group_rules(remote_sg_id, peer_sg_rules)",
            "        self.firewall.update_security_group_members(remote_sg_id,",
            "                                                    vm_sg_members)",
            "        self.firewall.prepare_port_filter(peer_port_desc)",
            "",
            "        vm_sg_rules = [{'ethertype': 'IPv4', 'direction': 'ingress',",
            "                        'protocol': 'icmp', 'remote_group_id': remote_sg_id}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID,",
            "                                         vm_sg_rules)",
            "",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    def test_related_connection(self):",
            "        \"\"\"Test ICMP net unreachable packets get back",
            "",
            "        When destination address of ip traffic is not reachable, ICMP packets",
            "        are returned. This packets are marked as RELATED traffic by conntrack",
            "        and this test case validates such packets are not dropped by the",
            "        firewall as ingress ICMP packets are not allowed in this test case. The",
            "        used address below 1.2.3.4 is outside of subnet that is used in tester",
            "        object.",
            "",
            "        \"\"\"",
            "        # Enable ip forwarding on the interface in order to reply with",
            "        # destionation net unreachable",
            "        self.tester._peer.execute([",
            "            'sysctl', '-w', 'net.ipv4.conf.%s.forwarding=1' %",
            "            self.tester._peer.port.name])",
            "        self.tester.set_vm_default_gateway(self.tester.peer_ip_address)",
            "        vm_sg_rules = [{'ethertype': 'IPv4', 'direction': 'egress',",
            "                        'protocol': 'icmp'}]",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID,",
            "                                         vm_sg_rules)",
            "",
            "        self.tester.assert_net_unreachable(self.tester.EGRESS, '1.2.3.4')",
            "",
            "",
            "class FirewallTestCaseIPv6(BaseFirewallTestCase):",
            "    scenarios = [('OVS Firewall Driver',",
            "                  {'initialize': 'initialize_ovs',",
            "                   'firewall_name': 'openvswitch'})]",
            "    ip_cidr = '2001:db8:aaaa::1/64'",
            "",
            "    def test_icmp_from_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP,",
            "                     'source_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.INGRESS)",
            "",
            "    def test_icmp_to_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_ICMP,",
            "                     'destination_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.ICMP,",
            "                                      direction=self.tester.EGRESS)",
            "",
            "    def test_tcp_from_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'source_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "",
            "    def test_tcp_to_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_TCP,",
            "                     'destination_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.TCP,",
            "                                      direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)",
            "",
            "    def test_udp_from_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.INGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_UDP,",
            "                     'source_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.INGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.UDP,",
            "                                      direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.INGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.INGRESS)",
            "",
            "    def test_udp_to_specific_address(self):",
            "        sg_rules = [{'ethertype': constants.IPv6,",
            "                     'direction': firewall.EGRESS_DIRECTION,",
            "                     'protocol': constants.PROTO_NAME_UDP,",
            "                     'destination_ip_prefix': self.tester.peer_ip_address}]",
            "",
            "        self.tester.assert_no_connection(protocol=self.tester.UDP,",
            "                                         direction=self.tester.EGRESS)",
            "        self._apply_security_group_rules(self.FAKE_SECURITY_GROUP_ID, sg_rules)",
            "        self.tester.assert_connection(protocol=self.tester.UDP,",
            "                                      direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.TCP,",
            "                                         direction=self.tester.EGRESS)",
            "        self.tester.assert_no_connection(protocol=self.tester.ICMP,",
            "                                         direction=self.tester.EGRESS)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.pgadmin.tools.import_export.create_import_export_job",
            "neutron.tests.functional.agent.test_firewall.BaseFirewallTestCase._apply_security_group_rules.sg_id",
            "neutron.tests.functional.agent.test_firewall.FirewallTestCase.test_ip_spoofing.sg_rules"
        ]
    },
    "neutron/tests/unit/agent/linux/test_iptables_firewall.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "                      comment=ic.PAIR_DROP),"
            },
            "1": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "2": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "3": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+                     '--sport 68 --dport 67 -j RETURN',"
            },
            "6": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                      comment=None),"
            },
            "7": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "                  mock.call.add_rule('ofake_dev', '-j $sfake_dev',"
            },
            "8": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "                                     comment=None),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                 mock.call.add_rule("
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                     'ofake_dev',"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                     comment=None),"
            },
            "13": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "14": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "15": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                      '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',"
            },
            "16": {
                "beforePatchRowNumber": 940,
                "afterPatchRowNumber": 945,
                "PatchRowcode": "         filter_inst = self.v4filter_inst"
            },
            "17": {
                "beforePatchRowNumber": 941,
                "afterPatchRowNumber": 946,
                "PatchRowcode": "         dhcp_rule = [mock.call.add_rule("
            },
            "18": {
                "beforePatchRowNumber": 942,
                "afterPatchRowNumber": 947,
                "PatchRowcode": "             'ofake_dev',"
            },
            "19": {
                "beforePatchRowNumber": 943,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 948,
                "PatchRowcode": "+            '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 949,
                "PatchRowcode": "+            '--sport 68 --dport 67 -j RETURN',"
            },
            "22": {
                "beforePatchRowNumber": 944,
                "afterPatchRowNumber": 950,
                "PatchRowcode": "             comment=None)]"
            },
            "23": {
                "beforePatchRowNumber": 945,
                "afterPatchRowNumber": 951,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 946,
                "afterPatchRowNumber": 952,
                "PatchRowcode": "         if ethertype == 'IPv6':"
            },
            "25": {
                "beforePatchRowNumber": 1027,
                "afterPatchRowNumber": 1033,
                "PatchRowcode": "         calls.append(mock.call.add_rule('ofake_dev', '-j $sfake_dev',"
            },
            "26": {
                "beforePatchRowNumber": 1028,
                "afterPatchRowNumber": 1034,
                "PatchRowcode": "                                         comment=None))"
            },
            "27": {
                "beforePatchRowNumber": 1029,
                "afterPatchRowNumber": 1035,
                "PatchRowcode": "         if ethertype == 'IPv4':"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1036,
                "PatchRowcode": "+            calls.append(mock.call.add_rule("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1037,
                "PatchRowcode": "+                'ofake_dev',"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1038,
                "PatchRowcode": "+                '-p udp -m udp --sport 68 --dport 67 -j RETURN',"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1039,
                "PatchRowcode": "+                comment=None))"
            },
            "32": {
                "beforePatchRowNumber": 1030,
                "afterPatchRowNumber": 1040,
                "PatchRowcode": "             calls.append(mock.call.add_rule("
            },
            "33": {
                "beforePatchRowNumber": 1031,
                "afterPatchRowNumber": 1041,
                "PatchRowcode": "                 'ofake_dev',"
            },
            "34": {
                "beforePatchRowNumber": 1032,
                "afterPatchRowNumber": 1042,
                "PatchRowcode": "                 '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',"
            },
            "35": {
                "beforePatchRowNumber": 1195,
                "afterPatchRowNumber": 1205,
                "PatchRowcode": "                      comment=ic.PAIR_DROP),"
            },
            "36": {
                "beforePatchRowNumber": 1196,
                "afterPatchRowNumber": 1206,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "37": {
                "beforePatchRowNumber": 1197,
                "afterPatchRowNumber": 1207,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "38": {
                "beforePatchRowNumber": 1198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1208,
                "PatchRowcode": "+                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1209,
                "PatchRowcode": "+                     '--sport 68 --dport 67 -j RETURN',"
            },
            "41": {
                "beforePatchRowNumber": 1199,
                "afterPatchRowNumber": 1210,
                "PatchRowcode": "                      comment=None),"
            },
            "42": {
                "beforePatchRowNumber": 1200,
                "afterPatchRowNumber": 1211,
                "PatchRowcode": "                  mock.call.add_rule('ofake_dev', '-j $sfake_dev',"
            },
            "43": {
                "beforePatchRowNumber": 1201,
                "afterPatchRowNumber": 1212,
                "PatchRowcode": "                                     comment=None),"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1213,
                "PatchRowcode": "+                 mock.call.add_rule("
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1214,
                "PatchRowcode": "+                     'ofake_dev',"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1215,
                "PatchRowcode": "+                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1216,
                "PatchRowcode": "+                     comment=None),"
            },
            "48": {
                "beforePatchRowNumber": 1202,
                "afterPatchRowNumber": 1217,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "49": {
                "beforePatchRowNumber": 1203,
                "afterPatchRowNumber": 1218,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "50": {
                "beforePatchRowNumber": 1204,
                "afterPatchRowNumber": 1219,
                "PatchRowcode": "                      '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',"
            },
            "51": {
                "beforePatchRowNumber": 1267,
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "                      comment=ic.PAIR_DROP),"
            },
            "52": {
                "beforePatchRowNumber": 1268,
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "53": {
                "beforePatchRowNumber": 1269,
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "54": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1285,
                "PatchRowcode": "+                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1286,
                "PatchRowcode": "+                     '--sport 68 --dport 67 -j RETURN',"
            },
            "57": {
                "beforePatchRowNumber": 1271,
                "afterPatchRowNumber": 1287,
                "PatchRowcode": "                      comment=None),"
            },
            "58": {
                "beforePatchRowNumber": 1272,
                "afterPatchRowNumber": 1288,
                "PatchRowcode": "                  mock.call.add_rule('ofake_dev', '-j $sfake_dev',"
            },
            "59": {
                "beforePatchRowNumber": 1273,
                "afterPatchRowNumber": 1289,
                "PatchRowcode": "                                     comment=None),"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1290,
                "PatchRowcode": "+                 mock.call.add_rule("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1291,
                "PatchRowcode": "+                     'ofake_dev',"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1292,
                "PatchRowcode": "+                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1293,
                "PatchRowcode": "+                     comment=None),"
            },
            "64": {
                "beforePatchRowNumber": 1274,
                "afterPatchRowNumber": 1294,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "65": {
                "beforePatchRowNumber": 1275,
                "afterPatchRowNumber": 1295,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "66": {
                "beforePatchRowNumber": 1276,
                "afterPatchRowNumber": 1296,
                "PatchRowcode": "                      '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',"
            },
            "67": {
                "beforePatchRowNumber": 1442,
                "afterPatchRowNumber": 1462,
                "PatchRowcode": "                      comment=ic.PAIR_DROP),"
            },
            "68": {
                "beforePatchRowNumber": 1443,
                "afterPatchRowNumber": 1463,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "69": {
                "beforePatchRowNumber": 1444,
                "afterPatchRowNumber": 1464,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "70": {
                "beforePatchRowNumber": 1445,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1465,
                "PatchRowcode": "+                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1466,
                "PatchRowcode": "+                     '--sport 68 --dport 67 -j RETURN',"
            },
            "73": {
                "beforePatchRowNumber": 1446,
                "afterPatchRowNumber": 1467,
                "PatchRowcode": "                      comment=None),"
            },
            "74": {
                "beforePatchRowNumber": 1447,
                "afterPatchRowNumber": 1468,
                "PatchRowcode": "                  mock.call.add_rule('ofake_dev', '-j $sfake_dev',"
            },
            "75": {
                "beforePatchRowNumber": 1448,
                "afterPatchRowNumber": 1469,
                "PatchRowcode": "                                     comment=None),"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1470,
                "PatchRowcode": "+                 mock.call.add_rule("
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1471,
                "PatchRowcode": "+                     'ofake_dev',"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1472,
                "PatchRowcode": "+                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1473,
                "PatchRowcode": "+                     comment=None),"
            },
            "80": {
                "beforePatchRowNumber": 1449,
                "afterPatchRowNumber": 1474,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "81": {
                "beforePatchRowNumber": 1450,
                "afterPatchRowNumber": 1475,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "82": {
                "beforePatchRowNumber": 1451,
                "afterPatchRowNumber": 1476,
                "PatchRowcode": "                      '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',"
            },
            "83": {
                "beforePatchRowNumber": 1516,
                "afterPatchRowNumber": 1541,
                "PatchRowcode": "                      comment=ic.PAIR_DROP),"
            },
            "84": {
                "beforePatchRowNumber": 1517,
                "afterPatchRowNumber": 1542,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "85": {
                "beforePatchRowNumber": 1518,
                "afterPatchRowNumber": 1543,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "86": {
                "beforePatchRowNumber": 1519,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1544,
                "PatchRowcode": "+                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1545,
                "PatchRowcode": "+                     '--sport 68 --dport 67 -j RETURN',"
            },
            "89": {
                "beforePatchRowNumber": 1520,
                "afterPatchRowNumber": 1546,
                "PatchRowcode": "                      comment=None),"
            },
            "90": {
                "beforePatchRowNumber": 1521,
                "afterPatchRowNumber": 1547,
                "PatchRowcode": "                  mock.call.add_rule('ofake_dev', '-j $sfake_dev',"
            },
            "91": {
                "beforePatchRowNumber": 1522,
                "afterPatchRowNumber": 1548,
                "PatchRowcode": "                                     comment=None),"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1549,
                "PatchRowcode": "+                 mock.call.add_rule("
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1550,
                "PatchRowcode": "+                     'ofake_dev',"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1551,
                "PatchRowcode": "+                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1552,
                "PatchRowcode": "+                     comment=None),"
            },
            "96": {
                "beforePatchRowNumber": 1523,
                "afterPatchRowNumber": 1553,
                "PatchRowcode": "                  mock.call.add_rule("
            },
            "97": {
                "beforePatchRowNumber": 1524,
                "afterPatchRowNumber": 1554,
                "PatchRowcode": "                      'ofake_dev',"
            },
            "98": {
                "beforePatchRowNumber": 1525,
                "afterPatchRowNumber": 1555,
                "PatchRowcode": "                      '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012, Nachi Ueno, NTT MCL, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "import mock",
            "from oslo_config import cfg",
            "import six",
            "import testtools",
            "",
            "from neutron.agent.common import config as a_cfg",
            "from neutron.agent.linux import ipset_manager",
            "from neutron.agent.linux import iptables_comments as ic",
            "from neutron.agent.linux import iptables_firewall",
            "from neutron.agent import securitygroups_rpc as sg_cfg",
            "from neutron.common import constants",
            "from neutron.common import exceptions as n_exc",
            "from neutron.common import utils",
            "from neutron.tests import base",
            "from neutron.tests.unit.api.v2 import test_base",
            "",
            "",
            "_uuid = test_base._uuid",
            "#TODO(mangelajo): replace all 'IPv4', 'IPv6' to constants",
            "FAKE_PREFIX = {'IPv4': '10.0.0.0/24',",
            "               'IPv6': 'fe80::/48'}",
            "FAKE_IP = {'IPv4': '10.0.0.1',",
            "           'IPv6': 'fe80::1'}",
            "#TODO(mangelajo): replace all '*_sgid' strings for the constants",
            "FAKE_SGID = 'fake_sgid'",
            "OTHER_SGID = 'other_sgid'",
            "_IPv6 = constants.IPv6",
            "_IPv4 = constants.IPv4",
            "",
            "RAW_TABLE_OUTPUT = \"\"\"",
            "# Generated by iptables-save v1.4.21 on Fri Jul 31 16:13:28 2015",
            "*raw",
            ":PREROUTING ACCEPT [11561:3470468]",
            ":OUTPUT ACCEPT [11504:4064044]",
            ":neutron-openvswi-OUTPUT - [0:0]",
            ":neutron-openvswi-PREROUTING - [0:0]",
            "-A PREROUTING -j neutron-openvswi-PREROUTING",
            " -A OUTPUT -j neutron-openvswi-OUTPUT",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvbe804433b-61 -j CT --zone 1",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tape804433b-61 -j CT --zone 1",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvb95c24827-02 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tap95c24827-02 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvb61634509-31 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tap61634509-31 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvb8f46cf18-12 -j CT --zone 9",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tap8f46cf18-12 -j CT --zone 9",
            "COMMIT",
            "# Completed on Fri Jul 31 16:13:28 2015",
            "\"\"\"  # noqa",
            "",
            "",
            "class BaseIptablesFirewallTestCase(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(BaseIptablesFirewallTestCase, self).setUp()",
            "        cfg.CONF.register_opts(a_cfg.ROOT_HELPER_OPTS, 'AGENT')",
            "        cfg.CONF.register_opts(sg_cfg.security_group_opts, 'SECURITYGROUP')",
            "        cfg.CONF.set_override('comment_iptables_rules', False, 'AGENT')",
            "        self.utils_exec_p = mock.patch(",
            "            'neutron.agent.linux.utils.execute')",
            "        self.utils_exec = self.utils_exec_p.start()",
            "        self.iptables_cls_p = mock.patch(",
            "            'neutron.agent.linux.iptables_manager.IptablesManager')",
            "        iptables_cls = self.iptables_cls_p.start()",
            "        self.iptables_inst = mock.Mock()",
            "        self.v4filter_inst = mock.Mock()",
            "        self.v6filter_inst = mock.Mock()",
            "        self.iptables_inst.ipv4 = {'filter': self.v4filter_inst,",
            "                                   'raw': self.v4filter_inst",
            "                                   }",
            "        self.iptables_inst.ipv6 = {'filter': self.v6filter_inst,",
            "                                   'raw': self.v6filter_inst",
            "                                   }",
            "        iptables_cls.return_value = self.iptables_inst",
            "",
            "        self.iptables_inst.get_rules_for_table.return_value = (",
            "            RAW_TABLE_OUTPUT.splitlines())",
            "        self.firewall = iptables_firewall.IptablesFirewallDriver()",
            "        self.firewall.iptables = self.iptables_inst",
            "",
            "",
            "class IptablesFirewallTestCase(BaseIptablesFirewallTestCase):",
            "",
            "    def _fake_port(self):",
            "        return {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': [FAKE_IP['IPv4'],",
            "                              FAKE_IP['IPv6']]}",
            "",
            "    def test_prepare_port_filter_with_no_sg(self):",
            "        port = self._fake_port()",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback', '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule('INPUT',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-j $sg-fallback',",
            "                     comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "    def test_filter_ipv4_ingress(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress'}",
            "        ingress = mock.call.add_rule('ifake_dev', '-j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p tcp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p tcp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_icmp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp'}",
            "        ingress = mock.call.add_rule('ifake_dev', '-p icmp -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -p icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p udp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p udp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p udp -m udp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress'}",
            "        egress = mock.call.add_rule('ofake_dev', '-j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p tcp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p tcp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp'}",
            "        egress = mock.call.add_rule('ofake_dev', '-p icmp -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -p icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_type(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p icmp -m icmp --icmp-type 8 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_type_name(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 'echo-request',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p icmp -m icmp --icmp-type echo-request '",
            "            '-j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_type_code(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_port_range_max': 0,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p icmp -m icmp --icmp-type 8/0 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p udp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p udp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p udp -m udp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress'}",
            "        ingress = mock.call.add_rule('ifake_dev', '-j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p tcp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p tcp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_icmp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p ipv6-icmp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -p ipv6-icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def _test_filter_ingress_tcp_min_port_0(self, ethertype):",
            "        rule = {'ethertype': ethertype,",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 0,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 0:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ingress_tcp_min_port_0_for_ipv4(self):",
            "        self._test_filter_ingress_tcp_min_port_0('IPv4')",
            "",
            "    def test_filter_ingress_tcp_min_port_0_for_ipv6(self):",
            "        self._test_filter_ingress_tcp_min_port_0('IPv6')",
            "",
            "    def test_filter_ipv6_ingress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p udp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p udp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p udp -m udp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress'}",
            "        egress = mock.call.add_rule('ofake_dev', '-j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p tcp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p tcp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p ipv6-icmp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -p ipv6-icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_type(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p ipv6-icmp -m icmp6 --icmpv6-type 8 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_type_name(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 'echo-request',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p ipv6-icmp -m icmp6 --icmpv6-type echo-request '",
            "            '-j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_type_code(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_port_range_max': 0,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p ipv6-icmp -m icmp6 --icmpv6-type 8/0 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p udp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p udp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p udp -m udp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def _test_prepare_port_filter(self,",
            "                                  rule,",
            "                                  ingress_expected_call=None,",
            "                                  egress_expected_call=None):",
            "        port = self._fake_port()",
            "        ethertype = rule['ethertype']",
            "        prefix = utils.ip_to_cidr(FAKE_IP[ethertype])",
            "        filter_inst = self.v4filter_inst",
            "        dhcp_rule = [mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',",
            "            comment=None)]",
            "",
            "        if ethertype == 'IPv6':",
            "            filter_inst = self.v6filter_inst",
            "",
            "            dhcp_rule = [mock.call.add_rule('ofake_dev', '-p ipv6-icmp '",
            "                                            '-m icmp6 '",
            "                                            '--icmpv6-type %s -j DROP'",
            "                                            % constants.ICMPV6_TYPE_RA,",
            "                                            comment=None),",
            "                         mock.call.add_rule('ofake_dev',",
            "                                            '-p ipv6-icmp -j RETURN',",
            "                                            comment=None),",
            "                         mock.call.add_rule('ofake_dev', '-p udp -m udp '",
            "                                            '--sport 546 -m udp --dport 547 '",
            "                                            '-j RETURN', comment=None)]",
            "        sg = [rule]",
            "        port['security_group_rules'] = sg",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback',",
            "                     '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG)",
            "                 ]",
            "        if ethertype == 'IPv6':",
            "            for icmp6_type in constants.ICMPV6_ALLOWED_TYPES:",
            "                calls.append(",
            "                    mock.call.add_rule('ifake_dev',",
            "                                       '-p ipv6-icmp -m icmp6 --icmpv6-type '",
            "                                       '%s -j RETURN' %",
            "                                       icmp6_type, comment=None))",
            "        calls += [",
            "            mock.call.add_rule(",
            "                'ifake_dev',",
            "                '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                comment=None",
            "            )",
            "        ]",
            "",
            "        if ingress_expected_call:",
            "            calls.append(ingress_expected_call)",
            "",
            "        calls += [mock.call.add_rule(",
            "                      'ifake_dev',",
            "                      '-m state --state INVALID -j DROP', comment=None),",
            "                  mock.call.add_rule('ifake_dev',",
            "                                     '-j $sg-fallback', comment=None),",
            "                  mock.call.add_chain('ofake_dev'),",
            "                  mock.call.add_rule('FORWARD',",
            "                                     '-m physdev --physdev-in tapfake_dev '",
            "                                     '--physdev-is-bridged '",
            "                                     '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                  mock.call.add_rule('sg-chain',",
            "                                     '-m physdev --physdev-in tapfake_dev '",
            "                                     '--physdev-is-bridged -j $ofake_dev',",
            "                                     comment=ic.SG_TO_VM_SG),",
            "                  mock.call.add_rule('INPUT',",
            "                                     '-m physdev --physdev-in tapfake_dev '",
            "                                     '--physdev-is-bridged -j $ofake_dev',",
            "                                     comment=ic.INPUT_TO_SG),",
            "                  mock.call.add_chain('sfake_dev'),",
            "                  mock.call.add_rule(",
            "                      'sfake_dev',",
            "                      '-s %s -m mac --mac-source FF:FF:FF:FF:FF:FF -j RETURN'",
            "                      % prefix,",
            "                      comment=ic.PAIR_ALLOW),",
            "                  mock.call.add_rule(",
            "                      'sfake_dev', '-j DROP',",
            "                      comment=ic.PAIR_DROP)]",
            "        calls += dhcp_rule",
            "        calls.append(mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                        comment=None))",
            "        if ethertype == 'IPv4':",
            "            calls.append(mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                comment=None))",
            "        if ethertype == 'IPv6':",
            "            calls.append(mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-p udp -m udp --sport 547 -m udp --dport 546 -j DROP',",
            "                comment=None))",
            "",
            "        calls += [",
            "            mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                comment=None),",
            "        ]",
            "",
            "        if egress_expected_call:",
            "            calls.append(egress_expected_call)",
            "",
            "        calls += [mock.call.add_rule(",
            "                      'ofake_dev',",
            "                      '-m state --state INVALID -j DROP', comment=None),",
            "                  mock.call.add_rule('ofake_dev',",
            "                                     '-j $sg-fallback', comment=None),",
            "                  mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "        comb = zip(calls, filter_inst.mock_calls)",
            "        for (l, r) in comb:",
            "            self.assertEqual(l, r)",
            "        filter_inst.assert_has_calls(calls)",
            "",
            "    def _test_remove_conntrack_entries(self, ethertype, protocol,",
            "                                       direction):",
            "        port = self._fake_port()",
            "        port['security_groups'] = 'fake_sg_id'",
            "        self.firewall.filtered_ports[port['device']] = port",
            "        self.firewall.updated_rule_sg_ids = set(['fake_sg_id'])",
            "        self.firewall.sg_rules['fake_sg_id'] = [",
            "            {'direction': direction, 'ethertype': ethertype,",
            "             'protocol': protocol}]",
            "",
            "        self.firewall.filter_defer_apply_on()",
            "        self.firewall.sg_rules['fake_sg_id'] = []",
            "        self.firewall.filter_defer_apply_off()",
            "        cmd = ['conntrack', '-D']",
            "        if protocol:",
            "            cmd.extend(['-p', protocol])",
            "        if ethertype == 'IPv4':",
            "            cmd.extend(['-f', 'ipv4'])",
            "            if direction == 'ingress':",
            "                cmd.extend(['-d', '10.0.0.1'])",
            "            else:",
            "                cmd.extend(['-s', '10.0.0.1'])",
            "        else:",
            "            cmd.extend(['-f', 'ipv6'])",
            "            if direction == 'ingress':",
            "                cmd.extend(['-d', 'fe80::1'])",
            "            else:",
            "                cmd.extend(['-s', 'fe80::1'])",
            "        # initial data has 1, 2, and 9 in use, CT zone will start at 10.",
            "        cmd.extend(['-w', 10])",
            "        calls = [",
            "            mock.call(cmd, run_as_root=True, check_exit_code=True,",
            "                      extra_ok_codes=[1])]",
            "        self.utils_exec.assert_has_calls(calls)",
            "",
            "    def test_remove_conntrack_entries_for_delete_rule_ipv4(self):",
            "        for direction in ['ingress', 'egress']:",
            "            for pro in [None, 'tcp', 'icmp', 'udp']:",
            "                self._test_remove_conntrack_entries(",
            "                    'IPv4', pro, direction)",
            "",
            "    def test_remove_conntrack_entries_for_delete_rule_ipv6(self):",
            "        for direction in ['ingress', 'egress']:",
            "            for pro in [None, 'tcp', 'icmp', 'udp']:",
            "                self._test_remove_conntrack_entries(",
            "                    'IPv6', pro, direction)",
            "",
            "    def test_remove_conntrack_entries_for_port_sec_group_change(self):",
            "        port = self._fake_port()",
            "        port['security_groups'] = ['fake_sg_id']",
            "        self.firewall.filtered_ports[port['device']] = port",
            "        self.firewall.updated_sg_members = set(['tapfake_dev'])",
            "        self.firewall.filter_defer_apply_on()",
            "        new_port = copy.deepcopy(port)",
            "        new_port['security_groups'] = ['fake_sg_id2']",
            "        self.firewall.filtered_ports[port['device']] = new_port",
            "        self.firewall.filter_defer_apply_off()",
            "        calls = [",
            "            # initial data has 1, 2, and 9 in use, CT zone will start at 10.",
            "            mock.call(['conntrack', '-D', '-f', 'ipv4', '-d', '10.0.0.1',",
            "                       '-w', 10],",
            "                      run_as_root=True, check_exit_code=True,",
            "                      extra_ok_codes=[1]),",
            "            mock.call(['conntrack', '-D', '-f', 'ipv6', '-d', 'fe80::1',",
            "                       '-w', 10],",
            "                      run_as_root=True, check_exit_code=True,",
            "                      extra_ok_codes=[1])]",
            "        self.utils_exec.assert_has_calls(calls)",
            "",
            "    def test_update_delete_port_filter(self):",
            "        port = self._fake_port()",
            "        port['security_group_rules'] = [{'ethertype': 'IPv4',",
            "                                         'direction': 'ingress'}]",
            "        self.firewall.prepare_port_filter(port)",
            "        port['security_group_rules'] = [{'ethertype': 'IPv4',",
            "                                         'direction': 'egress'}]",
            "        self.firewall.update_port_filter(port)",
            "        self.firewall.update_port_filter({'device': 'no-exist-device'})",
            "        self.firewall.remove_port_filter(port)",
            "        self.firewall.remove_port_filter({'device': 'no-exist-device'})",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback',",
            "                     '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $ifake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ifake_dev', '-j RETURN',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'INPUT',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev', '-m state --state INVALID -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT'),",
            "                 mock.call.remove_chain('ifake_dev'),",
            "                 mock.call.remove_chain('ofake_dev'),",
            "                 mock.call.remove_chain('sfake_dev'),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $ifake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'INPUT',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j RETURN',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ofake_dev',",
            "                                    '-j $sg-fallback',",
            "                                    comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT'),",
            "                 mock.call.remove_chain('ifake_dev'),",
            "                 mock.call.remove_chain('ofake_dev'),",
            "                 mock.call.remove_chain('sfake_dev'),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain')]",
            "",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "    def test_remove_unknown_port(self):",
            "        port = self._fake_port()",
            "        self.firewall.remove_port_filter(port)",
            "        # checking no exception occurs",
            "        self.assertFalse(self.v4filter_inst.called)",
            "",
            "    def test_defer_apply(self):",
            "        with self.firewall.defer_apply():",
            "            pass",
            "        self.iptables_inst.assert_has_calls([mock.call.defer_apply_on(),",
            "                                             mock.call.defer_apply_off()])",
            "",
            "    def test_filter_defer_with_exception(self):",
            "        try:",
            "            with self.firewall.defer_apply():",
            "                raise Exception(\"same exception\")",
            "        except Exception:",
            "            pass",
            "        self.iptables_inst.assert_has_calls([mock.call.defer_apply_on(),",
            "                                             mock.call.defer_apply_off()])",
            "",
            "    def _mock_chain_applies(self):",
            "        class CopyingMock(mock.MagicMock):",
            "            \"\"\"Copies arguments so mutable arguments can be asserted on.",
            "",
            "            Copied verbatim from unittest.mock documentation.",
            "            \"\"\"",
            "            def __call__(self, *args, **kwargs):",
            "                args = copy.deepcopy(args)",
            "                kwargs = copy.deepcopy(kwargs)",
            "                return super(CopyingMock, self).__call__(*args, **kwargs)",
            "        # Need to use CopyingMock because _{setup,remove}_chains_apply are",
            "        # usually called with that's modified between calls (i.e.,",
            "        # self.firewall.filtered_ports).",
            "        chain_applies = CopyingMock()",
            "        self.firewall._setup_chains_apply = chain_applies.setup",
            "        self.firewall._remove_chains_apply = chain_applies.remove",
            "        return chain_applies",
            "",
            "    def test_mock_chain_applies(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port_prepare = {'device': 'd1', 'mac_address': 'prepare'}",
            "        port_update = {'device': 'd1', 'mac_address': 'update'}",
            "        self.firewall.prepare_port_filter(port_prepare)",
            "        self.firewall.update_port_filter(port_update)",
            "        self.firewall.remove_port_filter(port_update)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                mock.call.setup({'d1': port_prepare}, {}),",
            "                                mock.call.remove({'d1': port_prepare}, {}),",
            "                                mock.call.setup({'d1': port_update}, {}),",
            "                                mock.call.remove({'d1': port_update}, {}),",
            "                                mock.call.setup({}, {})])",
            "",
            "    def test_defer_chain_apply_need_pre_defer_copy(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port = self._fake_port()",
            "        device2port = {port['device']: port}",
            "        self.firewall.prepare_port_filter(port)",
            "        with self.firewall.defer_apply():",
            "            self.firewall.remove_port_filter(port)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                        mock.call.setup(device2port, {}),",
            "                                        mock.call.remove(device2port, {}),",
            "                                        mock.call.setup({}, {})])",
            "",
            "    def test_defer_chain_apply_coalesce_simple(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port = self._fake_port()",
            "        with self.firewall.defer_apply():",
            "            self.firewall.prepare_port_filter(port)",
            "            self.firewall.update_port_filter(port)",
            "            self.firewall.remove_port_filter(port)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                        mock.call.setup({}, {})])",
            "",
            "    def test_defer_chain_apply_coalesce_multiple_ports(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port1 = {'device': 'd1', 'mac_address': 'mac1', 'network_id': 'net1'}",
            "        port2 = {'device': 'd2', 'mac_address': 'mac2', 'network_id': 'net1'}",
            "        device2port = {'d1': port1, 'd2': port2}",
            "        with self.firewall.defer_apply():",
            "            self.firewall.prepare_port_filter(port1)",
            "            self.firewall.prepare_port_filter(port2)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                        mock.call.setup(device2port, {})])",
            "",
            "    def test_ip_spoofing_filter_with_multiple_ips(self):",
            "        port = {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': ['10.0.0.1', 'fe80::1', '10.0.0.2']}",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback', '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ifake_dev',",
            "                                    '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule('INPUT',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.2/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ofake_dev',",
            "                                    '-j $sg-fallback', comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "    def test_ip_spoofing_no_fixed_ips(self):",
            "        port = {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': []}",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback', '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ifake_dev', '-j $sg-fallback',",
            "                                    comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule('INPUT',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-m mac --mac-source FF:FF:FF:FF:FF:FF -j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 -m udp --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sg-fallback',",
            "                                    comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "",
            "class IptablesFirewallEnhancedIpsetTestCase(BaseIptablesFirewallTestCase):",
            "    def setUp(self):",
            "        super(IptablesFirewallEnhancedIpsetTestCase, self).setUp()",
            "        self.firewall.ipset = mock.Mock()",
            "        self.firewall.ipset.get_name.side_effect = (",
            "            ipset_manager.IpsetManager.get_name)",
            "        self.firewall.ipset.set_name_exists.return_value = True",
            "",
            "    def _fake_port(self, sg_id=FAKE_SGID):",
            "        return {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': [FAKE_IP['IPv4'],",
            "                              FAKE_IP['IPv6']],",
            "                'security_groups': [sg_id],",
            "                'security_group_source_groups': [sg_id]}",
            "",
            "    def _fake_sg_rule_for_ethertype(self, ethertype, remote_group):",
            "        return {'direction': 'ingress', 'remote_group_id': remote_group,",
            "                'ethertype': ethertype}",
            "",
            "    def _fake_sg_rules(self, sg_id=FAKE_SGID, remote_groups=None):",
            "        remote_groups = remote_groups or {_IPv4: [FAKE_SGID],",
            "                                          _IPv6: [FAKE_SGID]}",
            "        rules = []",
            "        for ip_version, remote_group_list in six.iteritems(remote_groups):",
            "            for remote_group in remote_group_list:",
            "                rules.append(self._fake_sg_rule_for_ethertype(ip_version,",
            "                                                              remote_group))",
            "        return {sg_id: rules}",
            "",
            "    def _fake_sg_members(self, sg_ids=None):",
            "        return {sg_id: copy.copy(FAKE_IP) for sg_id in (sg_ids or [FAKE_SGID])}",
            "",
            "    def test_prepare_port_filter_with_new_members(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.1', '10.0.0.2'], 'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {}",
            "        port = self._fake_port()",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [",
            "            mock.call.set_members('fake_sgid', 'IPv4',",
            "                                  ['10.0.0.1', '10.0.0.2']),",
            "            mock.call.set_members('fake_sgid', 'IPv6',",
            "                                  ['fe80::1'])",
            "        ]",
            "        self.firewall.ipset.assert_has_calls(calls, any_order=True)",
            "",
            "    def _setup_fake_firewall_members_and_rules(self, firewall):",
            "        firewall.sg_rules = self._fake_sg_rules()",
            "        firewall.pre_sg_rules = self._fake_sg_rules()",
            "        firewall.sg_members = self._fake_sg_members()",
            "        firewall.pre_sg_members = firewall.sg_members",
            "",
            "    def _prepare_rules_and_members_for_removal(self):",
            "        self._setup_fake_firewall_members_and_rules(self.firewall)",
            "        self.firewall.pre_sg_members[OTHER_SGID] = (",
            "            self.firewall.pre_sg_members[FAKE_SGID])",
            "",
            "    def test_determine_remote_sgs_to_remove(self):",
            "        self._prepare_rules_and_members_for_removal()",
            "        ports = [self._fake_port()]",
            "",
            "        self.assertEqual(",
            "            {_IPv4: set([OTHER_SGID]), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._determine_remote_sgs_to_remove(ports))",
            "",
            "    def test_determine_remote_sgs_to_remove_ipv6_unreferenced(self):",
            "        self._prepare_rules_and_members_for_removal()",
            "        ports = [self._fake_port()]",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [OTHER_SGID, FAKE_SGID],",
            "                           _IPv6: [FAKE_SGID]})",
            "        self.assertEqual(",
            "            {_IPv4: set(), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._determine_remote_sgs_to_remove(ports))",
            "",
            "    def test_get_remote_sg_ids_by_ipversion(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [FAKE_SGID], _IPv6: [OTHER_SGID]})",
            "",
            "        ports = [self._fake_port()]",
            "",
            "        self.assertEqual(",
            "            {_IPv4: set([FAKE_SGID]), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._get_remote_sg_ids_sets_by_ipversion(ports))",
            "",
            "    def test_get_remote_sg_ids(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [FAKE_SGID, FAKE_SGID, FAKE_SGID],",
            "                           _IPv6: [OTHER_SGID, OTHER_SGID, OTHER_SGID]})",
            "",
            "        port = self._fake_port()",
            "",
            "        self.assertEqual(",
            "            {_IPv4: set([FAKE_SGID]), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._get_remote_sg_ids(port))",
            "",
            "    def test_determine_sg_rules_to_remove(self):",
            "        self.firewall.pre_sg_rules = self._fake_sg_rules(sg_id=OTHER_SGID)",
            "        ports = [self._fake_port()]",
            "",
            "        self.assertEqual(set([OTHER_SGID]),",
            "                         self.firewall._determine_sg_rules_to_remove(ports))",
            "",
            "    def test_get_sg_ids_set_for_ports(self):",
            "        sg_ids = set([FAKE_SGID, OTHER_SGID])",
            "        ports = [self._fake_port(sg_id) for sg_id in sg_ids]",
            "",
            "        self.assertEqual(sg_ids,",
            "                         self.firewall._get_sg_ids_set_for_ports(ports))",
            "",
            "    def test_remove_sg_members(self):",
            "        self.firewall.sg_members = self._fake_sg_members([FAKE_SGID,",
            "                                                          OTHER_SGID])",
            "        remote_sgs_to_remove = {_IPv4: set([FAKE_SGID]),",
            "                                _IPv6: set([FAKE_SGID, OTHER_SGID])}",
            "        self.firewall._remove_sg_members(remote_sgs_to_remove)",
            "",
            "        self.assertIn(OTHER_SGID, self.firewall.sg_members)",
            "        self.assertNotIn(FAKE_SGID, self.firewall.sg_members)",
            "",
            "    def test_remove_unused_security_group_info_clears_unused_rules(self):",
            "        self._setup_fake_firewall_members_and_rules(self.firewall)",
            "        self.firewall.prepare_port_filter(self._fake_port())",
            "",
            "        # create another SG which won't be referenced by any filtered port",
            "        fake_sg_rules = self.firewall.sg_rules['fake_sgid']",
            "        self.firewall.pre_sg_rules[OTHER_SGID] = fake_sg_rules",
            "        self.firewall.sg_rules[OTHER_SGID] = fake_sg_rules",
            "",
            "        # call the cleanup function, and check the unused sg_rules are out",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertNotIn(OTHER_SGID, self.firewall.sg_rules)",
            "",
            "    def test_remove_unused_security_group_info(self):",
            "        self.firewall.sg_members = {OTHER_SGID: {_IPv4: [], _IPv6: []}}",
            "        self.firewall.pre_sg_members = self.firewall.sg_members",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [FAKE_SGID], _IPv6: [FAKE_SGID]})",
            "        self.firewall.pre_sg_rules = self.firewall.sg_rules",
            "        port = self._fake_port()",
            "        self.firewall.filtered_ports['tapfake_dev'] = port",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertNotIn(OTHER_SGID, self.firewall.sg_members)",
            "",
            "    def test_not_remove_used_security_group_info(self):",
            "        self.firewall.sg_members = {OTHER_SGID: {_IPv4: [], _IPv6: []}}",
            "        self.firewall.pre_sg_members = self.firewall.sg_members",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [OTHER_SGID], _IPv6: [OTHER_SGID]})",
            "        self.firewall.pre_sg_rules = self.firewall.sg_rules",
            "        port = self._fake_port()",
            "        self.firewall.filtered_ports['tapfake_dev'] = port",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertIn(OTHER_SGID, self.firewall.sg_members)",
            "",
            "    def test_remove_all_unused_info(self):",
            "        self._setup_fake_firewall_members_and_rules(self.firewall)",
            "        self.firewall.filtered_ports = {}",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertFalse(self.firewall.sg_members)",
            "        self.assertFalse(self.firewall.sg_rules)",
            "",
            "    def test_single_fallback_accept_rule(self):",
            "        p1, p2 = self._fake_port(), self._fake_port()",
            "        self.firewall._setup_chains_apply(dict(p1=p1, p2=p2), {})",
            "        v4_adds = self.firewall.iptables.ipv4['filter'].add_rule.mock_calls",
            "        v6_adds = self.firewall.iptables.ipv6['filter'].add_rule.mock_calls",
            "        sg_chain_v4_accept = [call for call in v4_adds",
            "                              if call == mock.call('sg-chain', '-j ACCEPT')]",
            "        sg_chain_v6_accept = [call for call in v6_adds",
            "                              if call == mock.call('sg-chain', '-j ACCEPT')]",
            "        self.assertEqual(1, len(sg_chain_v4_accept))",
            "        self.assertEqual(1, len(sg_chain_v6_accept))",
            "",
            "    def test_prepare_port_filter_with_deleted_member(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.pre_sg_rules = self._fake_sg_rules()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': [",
            "                '10.0.0.1', '10.0.0.3', '10.0.0.4', '10.0.0.5'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.2'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.prepare_port_filter(self._fake_port())",
            "        calls = [",
            "            mock.call.set_members('fake_sgid', 'IPv4',",
            "                                  ['10.0.0.1', '10.0.0.3', '10.0.0.4',",
            "                                   '10.0.0.5']),",
            "            mock.call.set_members('fake_sgid', 'IPv6', ['fe80::1'])]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, True)",
            "",
            "    def test_remove_port_filter_with_destroy_ipset_chain(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        port = self._fake_port()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.1'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': [],",
            "            'IPv6': []}}",
            "        self.firewall.prepare_port_filter(port)",
            "        self.firewall.filter_defer_apply_on()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': [],",
            "            'IPv6': []}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.1'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.remove_port_filter(port)",
            "        self.firewall.filter_defer_apply_off()",
            "        calls = [",
            "            mock.call.set_members('fake_sgid', 'IPv4', ['10.0.0.1']),",
            "            mock.call.set_members('fake_sgid', 'IPv6', ['fe80::1']),",
            "            mock.call.get_name('fake_sgid', 'IPv4'),",
            "            mock.call.set_name_exists('NIPv4fake_sgid'),",
            "            mock.call.get_name('fake_sgid', 'IPv6'),",
            "            mock.call.set_name_exists('NIPv6fake_sgid'),",
            "            mock.call.destroy('fake_sgid', 'IPv4'),",
            "            mock.call.destroy('fake_sgid', 'IPv6')]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, any_order=True)",
            "",
            "    def test_prepare_port_filter_with_sg_no_member(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.sg_rules[FAKE_SGID].append(",
            "            {'direction': 'ingress', 'remote_group_id': 'fake_sgid2',",
            "             'ethertype': 'IPv4'})",
            "        self.firewall.sg_rules.update()",
            "        self.firewall.sg_members['fake_sgid'] = {",
            "            'IPv4': ['10.0.0.1', '10.0.0.2'], 'IPv6': ['fe80::1']}",
            "        self.firewall.pre_sg_members = {}",
            "        port = self._fake_port()",
            "        port['security_group_source_groups'].append('fake_sgid2')",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.set_members('fake_sgid', 'IPv4',",
            "                                       ['10.0.0.1', '10.0.0.2']),",
            "                 mock.call.set_members('fake_sgid', 'IPv6', ['fe80::1'])]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, any_order=True)",
            "",
            "    def test_filter_defer_apply_off_with_sg_only_ipv6_rule(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.pre_sg_rules = self._fake_sg_rules()",
            "        self.firewall.ipset_chains = {'IPv4fake_sgid': ['10.0.0.2'],",
            "                                      'IPv6fake_sgid': ['fe80::1']}",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.2'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.2'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.sg_rules['fake_sgid'].remove(",
            "            {'direction': 'ingress', 'remote_group_id': 'fake_sgid',",
            "             'ethertype': 'IPv4'})",
            "        self.firewall.sg_rules.update()",
            "        self.firewall._defer_apply = True",
            "        port = self._fake_port()",
            "        self.firewall.filtered_ports['tapfake_dev'] = port",
            "        self.firewall._pre_defer_filtered_ports = {}",
            "        self.firewall._pre_defer_unfiltered_ports = {}",
            "        self.firewall.filter_defer_apply_off()",
            "        calls = [mock.call.destroy('fake_sgid', 'IPv4')]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, True)",
            "",
            "    def test_sg_rule_expansion_with_remote_ips(self):",
            "        other_ips = ['10.0.0.2', '10.0.0.3', '10.0.0.4']",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': [FAKE_IP['IPv4']] + other_ips,",
            "            'IPv6': [FAKE_IP['IPv6']]}}",
            "",
            "        port = self._fake_port()",
            "        rule = self._fake_sg_rule_for_ethertype(_IPv4, FAKE_SGID)",
            "        rules = self.firewall._expand_sg_rule_with_remote_ips(",
            "            rule, port, 'ingress')",
            "        self.assertEqual(list(rules),",
            "                         [dict(list(rule.items()) +",
            "                               [('source_ip_prefix', '%s/32' % ip)])",
            "                          for ip in other_ips])",
            "",
            "    def test_build_ipv4v6_mac_ip_list(self):",
            "        mac_oth = 'ffff-ff0f-ffff'",
            "        mac_unix = 'FF:FF:FF:0F:FF:FF'",
            "        ipv4 = FAKE_IP['IPv4']",
            "        ipv6 = FAKE_IP['IPv6']",
            "        fake_ipv4_pair = []",
            "        fake_ipv4_pair.append((mac_unix, ipv4))",
            "        fake_ipv6_pair = []",
            "        fake_ipv6_pair.append((mac_unix, ipv6))",
            "",
            "        mac_ipv4_pairs = []",
            "        mac_ipv6_pairs = []",
            "",
            "        self.firewall._build_ipv4v6_mac_ip_list(mac_oth, ipv4,",
            "                                                mac_ipv4_pairs, mac_ipv6_pairs)",
            "        self.assertEqual(fake_ipv4_pair, mac_ipv4_pairs)",
            "        self.firewall._build_ipv4v6_mac_ip_list(mac_oth, ipv6,",
            "                                                mac_ipv4_pairs, mac_ipv6_pairs)",
            "        self.assertEqual(fake_ipv6_pair, mac_ipv6_pairs)",
            "",
            "    def test_update_ipset_members(self):",
            "        self.firewall.sg_members[FAKE_SGID][_IPv4] = []",
            "        self.firewall.sg_members[FAKE_SGID][_IPv6] = []",
            "        sg_info = {constants.IPv4: [FAKE_SGID]}",
            "        self.firewall._update_ipset_members(sg_info)",
            "        calls = [mock.call.set_members(FAKE_SGID, constants.IPv4, [])]",
            "        self.firewall.ipset.assert_has_calls(calls)",
            "",
            "",
            "class OVSHybridIptablesFirewallTestCase(BaseIptablesFirewallTestCase):",
            "",
            "    def setUp(self):",
            "        super(OVSHybridIptablesFirewallTestCase, self).setUp()",
            "        self.firewall = iptables_firewall.OVSHybridIptablesFirewallDriver()",
            "        # initial data has 1, 2, and 9 in use, see RAW_TABLE_OUTPUT above.",
            "        self._dev_zone_map = {'61634509-31': 2, '8f46cf18-12': 9,",
            "                              '95c24827-02': 2, 'e804433b-61': 1}",
            "",
            "    def test__populate_initial_zone_map(self):",
            "        self.assertEqual(self._dev_zone_map, self.firewall._device_zone_map)",
            "",
            "    def test__generate_device_zone(self):",
            "        # initial data has 1, 2, and 9 in use.",
            "        # we fill from top up first.",
            "        self.assertEqual(10, self.firewall._generate_device_zone('test'))",
            "",
            "        # once it's maxed out, it scans for gaps",
            "        self.firewall._device_zone_map['someport'] = (",
            "            iptables_firewall.MAX_CONNTRACK_ZONES)",
            "        for i in range(3, 9):",
            "            self.assertEqual(i, self.firewall._generate_device_zone(i))",
            "",
            "        # 9 and 10 are taken so next should be 11",
            "        self.assertEqual(11, self.firewall._generate_device_zone('p11'))",
            "",
            "        # take out zone 1 and make sure it's selected",
            "        self.firewall._device_zone_map.pop('e804433b-61')",
            "        self.assertEqual(1, self.firewall._generate_device_zone('p1'))",
            "",
            "        # fill it up and then make sure an extra throws an error",
            "        for i in range(1, 65536):",
            "            self.firewall._device_zone_map['dev-%s' % i] = i",
            "        with testtools.ExpectedException(n_exc.CTZoneExhaustedError):",
            "            self.firewall._find_open_zone()",
            "",
            "        # with it full, try again, this should trigger a cleanup and return 1",
            "        self.assertEqual(1, self.firewall._generate_device_zone('p12'))",
            "        self.assertEqual({'p12': 1}, self.firewall._device_zone_map)",
            "",
            "    def test_get_device_zone(self):",
            "        # initial data has 1, 2, and 9 in use.",
            "        self.assertEqual(10,",
            "                         self.firewall.get_device_zone('12345678901234567'))",
            "        # should have been truncated to 11 chars",
            "        self._dev_zone_map.update({'12345678901': 10})",
            "        self.assertEqual(self._dev_zone_map, self.firewall._device_zone_map)"
        ],
        "afterPatchFile": [
            "# Copyright 2012, Nachi Ueno, NTT MCL, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import copy",
            "",
            "import mock",
            "from oslo_config import cfg",
            "import six",
            "import testtools",
            "",
            "from neutron.agent.common import config as a_cfg",
            "from neutron.agent.linux import ipset_manager",
            "from neutron.agent.linux import iptables_comments as ic",
            "from neutron.agent.linux import iptables_firewall",
            "from neutron.agent import securitygroups_rpc as sg_cfg",
            "from neutron.common import constants",
            "from neutron.common import exceptions as n_exc",
            "from neutron.common import utils",
            "from neutron.tests import base",
            "from neutron.tests.unit.api.v2 import test_base",
            "",
            "",
            "_uuid = test_base._uuid",
            "#TODO(mangelajo): replace all 'IPv4', 'IPv6' to constants",
            "FAKE_PREFIX = {'IPv4': '10.0.0.0/24',",
            "               'IPv6': 'fe80::/48'}",
            "FAKE_IP = {'IPv4': '10.0.0.1',",
            "           'IPv6': 'fe80::1'}",
            "#TODO(mangelajo): replace all '*_sgid' strings for the constants",
            "FAKE_SGID = 'fake_sgid'",
            "OTHER_SGID = 'other_sgid'",
            "_IPv6 = constants.IPv6",
            "_IPv4 = constants.IPv4",
            "",
            "RAW_TABLE_OUTPUT = \"\"\"",
            "# Generated by iptables-save v1.4.21 on Fri Jul 31 16:13:28 2015",
            "*raw",
            ":PREROUTING ACCEPT [11561:3470468]",
            ":OUTPUT ACCEPT [11504:4064044]",
            ":neutron-openvswi-OUTPUT - [0:0]",
            ":neutron-openvswi-PREROUTING - [0:0]",
            "-A PREROUTING -j neutron-openvswi-PREROUTING",
            " -A OUTPUT -j neutron-openvswi-OUTPUT",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvbe804433b-61 -j CT --zone 1",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tape804433b-61 -j CT --zone 1",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvb95c24827-02 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tap95c24827-02 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvb61634509-31 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tap61634509-31 -j CT --zone 2",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in qvb8f46cf18-12 -j CT --zone 9",
            "-A neutron-openvswi-PREROUTING -m physdev --physdev-in tap8f46cf18-12 -j CT --zone 9",
            "COMMIT",
            "# Completed on Fri Jul 31 16:13:28 2015",
            "\"\"\"  # noqa",
            "",
            "",
            "class BaseIptablesFirewallTestCase(base.BaseTestCase):",
            "    def setUp(self):",
            "        super(BaseIptablesFirewallTestCase, self).setUp()",
            "        cfg.CONF.register_opts(a_cfg.ROOT_HELPER_OPTS, 'AGENT')",
            "        cfg.CONF.register_opts(sg_cfg.security_group_opts, 'SECURITYGROUP')",
            "        cfg.CONF.set_override('comment_iptables_rules', False, 'AGENT')",
            "        self.utils_exec_p = mock.patch(",
            "            'neutron.agent.linux.utils.execute')",
            "        self.utils_exec = self.utils_exec_p.start()",
            "        self.iptables_cls_p = mock.patch(",
            "            'neutron.agent.linux.iptables_manager.IptablesManager')",
            "        iptables_cls = self.iptables_cls_p.start()",
            "        self.iptables_inst = mock.Mock()",
            "        self.v4filter_inst = mock.Mock()",
            "        self.v6filter_inst = mock.Mock()",
            "        self.iptables_inst.ipv4 = {'filter': self.v4filter_inst,",
            "                                   'raw': self.v4filter_inst",
            "                                   }",
            "        self.iptables_inst.ipv6 = {'filter': self.v6filter_inst,",
            "                                   'raw': self.v6filter_inst",
            "                                   }",
            "        iptables_cls.return_value = self.iptables_inst",
            "",
            "        self.iptables_inst.get_rules_for_table.return_value = (",
            "            RAW_TABLE_OUTPUT.splitlines())",
            "        self.firewall = iptables_firewall.IptablesFirewallDriver()",
            "        self.firewall.iptables = self.iptables_inst",
            "",
            "",
            "class IptablesFirewallTestCase(BaseIptablesFirewallTestCase):",
            "",
            "    def _fake_port(self):",
            "        return {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': [FAKE_IP['IPv4'],",
            "                              FAKE_IP['IPv6']]}",
            "",
            "    def test_prepare_port_filter_with_no_sg(self):",
            "        port = self._fake_port()",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback', '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule('INPUT',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '",
            "                     '--sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-j $sg-fallback',",
            "                     comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "    def test_filter_ipv4_ingress(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress'}",
            "        ingress = mock.call.add_rule('ifake_dev', '-j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p tcp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p tcp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_icmp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp'}",
            "        ingress = mock.call.add_rule('ifake_dev', '-p icmp -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -p icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p udp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p udp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p udp -m udp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_ingress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress'}",
            "        egress = mock.call.add_rule('ofake_dev', '-j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p tcp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p tcp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp'}",
            "        egress = mock.call.add_rule('ofake_dev', '-p icmp -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -p icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_type(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p icmp -m icmp --icmp-type 8 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_type_name(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 'echo-request',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p icmp -m icmp --icmp-type echo-request '",
            "            '-j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_icmp_type_code(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_port_range_max': 0,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p icmp -m icmp --icmp-type 8/0 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p udp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p udp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_port(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p udp -m udp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv4_egress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv4']",
            "        rule = {'ethertype': 'IPv4',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress'}",
            "        ingress = mock.call.add_rule('ifake_dev', '-j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p tcp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p tcp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_icmp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p ipv6-icmp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-s %s -p ipv6-icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def _test_filter_ingress_tcp_min_port_0(self, ethertype):",
            "        rule = {'ethertype': ethertype,",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 0,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 0:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ingress_tcp_min_port_0_for_ipv4(self):",
            "        self._test_filter_ingress_tcp_min_port_0('IPv4')",
            "",
            "    def test_filter_ingress_tcp_min_port_0_for_ipv6(self):",
            "        self._test_filter_ingress_tcp_min_port_0('IPv6')",
            "",
            "    def test_filter_ipv6_ingress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp'}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev', '-p udp -j RETURN', comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-s %s -p udp -j RETURN' % prefix,",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        ingress = mock.call.add_rule('ifake_dev',",
            "                                     '-p udp -m udp --dport 10 -j RETURN',",
            "                                     comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_ingress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'ingress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        ingress = mock.call.add_rule(",
            "            'ifake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        egress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress'}",
            "        egress = mock.call.add_rule('ofake_dev', '-j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p tcp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p tcp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p ipv6-icmp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-s %s -p ipv6-icmp -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_type(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p ipv6-icmp -m icmp6 --icmpv6-type 8 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_type_name(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 'echo-request',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p ipv6-icmp -m icmp6 --icmpv6-type echo-request '",
            "            '-j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_icmp_type_code(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'icmp',",
            "                'source_port_range_min': 8,",
            "                'source_port_range_max': 0,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p ipv6-icmp -m icmp6 --icmpv6-type 8/0 -j RETURN' % prefix,",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p tcp -m tcp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p tcp -m tcp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_tcp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'tcp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p tcp -m tcp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp'}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev', '-p udp -j RETURN', comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-s %s -p udp -j RETURN' % prefix,",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_port(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 10}",
            "        egress = mock.call.add_rule('ofake_dev',",
            "                                    '-p udp -m udp --dport 10 -j RETURN',",
            "                                    comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_mport(self):",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-p udp -m udp -m multiport --dports 10:100 -j RETURN',",
            "            comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def test_filter_ipv6_egress_udp_mport_prefix(self):",
            "        prefix = FAKE_PREFIX['IPv6']",
            "        rule = {'ethertype': 'IPv6',",
            "                'direction': 'egress',",
            "                'protocol': 'udp',",
            "                'port_range_min': 10,",
            "                'port_range_max': 100,",
            "                'source_ip_prefix': prefix}",
            "        egress = mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s %s -p udp -m udp -m multiport --dports 10:100 '",
            "            '-j RETURN' % prefix, comment=None)",
            "        ingress = None",
            "        self._test_prepare_port_filter(rule, ingress, egress)",
            "",
            "    def _test_prepare_port_filter(self,",
            "                                  rule,",
            "                                  ingress_expected_call=None,",
            "                                  egress_expected_call=None):",
            "        port = self._fake_port()",
            "        ethertype = rule['ethertype']",
            "        prefix = utils.ip_to_cidr(FAKE_IP[ethertype])",
            "        filter_inst = self.v4filter_inst",
            "        dhcp_rule = [mock.call.add_rule(",
            "            'ofake_dev',",
            "            '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '",
            "            '--sport 68 --dport 67 -j RETURN',",
            "            comment=None)]",
            "",
            "        if ethertype == 'IPv6':",
            "            filter_inst = self.v6filter_inst",
            "",
            "            dhcp_rule = [mock.call.add_rule('ofake_dev', '-p ipv6-icmp '",
            "                                            '-m icmp6 '",
            "                                            '--icmpv6-type %s -j DROP'",
            "                                            % constants.ICMPV6_TYPE_RA,",
            "                                            comment=None),",
            "                         mock.call.add_rule('ofake_dev',",
            "                                            '-p ipv6-icmp -j RETURN',",
            "                                            comment=None),",
            "                         mock.call.add_rule('ofake_dev', '-p udp -m udp '",
            "                                            '--sport 546 -m udp --dport 547 '",
            "                                            '-j RETURN', comment=None)]",
            "        sg = [rule]",
            "        port['security_group_rules'] = sg",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback',",
            "                     '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG)",
            "                 ]",
            "        if ethertype == 'IPv6':",
            "            for icmp6_type in constants.ICMPV6_ALLOWED_TYPES:",
            "                calls.append(",
            "                    mock.call.add_rule('ifake_dev',",
            "                                       '-p ipv6-icmp -m icmp6 --icmpv6-type '",
            "                                       '%s -j RETURN' %",
            "                                       icmp6_type, comment=None))",
            "        calls += [",
            "            mock.call.add_rule(",
            "                'ifake_dev',",
            "                '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                comment=None",
            "            )",
            "        ]",
            "",
            "        if ingress_expected_call:",
            "            calls.append(ingress_expected_call)",
            "",
            "        calls += [mock.call.add_rule(",
            "                      'ifake_dev',",
            "                      '-m state --state INVALID -j DROP', comment=None),",
            "                  mock.call.add_rule('ifake_dev',",
            "                                     '-j $sg-fallback', comment=None),",
            "                  mock.call.add_chain('ofake_dev'),",
            "                  mock.call.add_rule('FORWARD',",
            "                                     '-m physdev --physdev-in tapfake_dev '",
            "                                     '--physdev-is-bridged '",
            "                                     '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                  mock.call.add_rule('sg-chain',",
            "                                     '-m physdev --physdev-in tapfake_dev '",
            "                                     '--physdev-is-bridged -j $ofake_dev',",
            "                                     comment=ic.SG_TO_VM_SG),",
            "                  mock.call.add_rule('INPUT',",
            "                                     '-m physdev --physdev-in tapfake_dev '",
            "                                     '--physdev-is-bridged -j $ofake_dev',",
            "                                     comment=ic.INPUT_TO_SG),",
            "                  mock.call.add_chain('sfake_dev'),",
            "                  mock.call.add_rule(",
            "                      'sfake_dev',",
            "                      '-s %s -m mac --mac-source FF:FF:FF:FF:FF:FF -j RETURN'",
            "                      % prefix,",
            "                      comment=ic.PAIR_ALLOW),",
            "                  mock.call.add_rule(",
            "                      'sfake_dev', '-j DROP',",
            "                      comment=ic.PAIR_DROP)]",
            "        calls += dhcp_rule",
            "        calls.append(mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                        comment=None))",
            "        if ethertype == 'IPv4':",
            "            calls.append(mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-p udp -m udp --sport 68 --dport 67 -j RETURN',",
            "                comment=None))",
            "            calls.append(mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                comment=None))",
            "        if ethertype == 'IPv6':",
            "            calls.append(mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-p udp -m udp --sport 547 -m udp --dport 546 -j DROP',",
            "                comment=None))",
            "",
            "        calls += [",
            "            mock.call.add_rule(",
            "                'ofake_dev',",
            "                '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                comment=None),",
            "        ]",
            "",
            "        if egress_expected_call:",
            "            calls.append(egress_expected_call)",
            "",
            "        calls += [mock.call.add_rule(",
            "                      'ofake_dev',",
            "                      '-m state --state INVALID -j DROP', comment=None),",
            "                  mock.call.add_rule('ofake_dev',",
            "                                     '-j $sg-fallback', comment=None),",
            "                  mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "        comb = zip(calls, filter_inst.mock_calls)",
            "        for (l, r) in comb:",
            "            self.assertEqual(l, r)",
            "        filter_inst.assert_has_calls(calls)",
            "",
            "    def _test_remove_conntrack_entries(self, ethertype, protocol,",
            "                                       direction):",
            "        port = self._fake_port()",
            "        port['security_groups'] = 'fake_sg_id'",
            "        self.firewall.filtered_ports[port['device']] = port",
            "        self.firewall.updated_rule_sg_ids = set(['fake_sg_id'])",
            "        self.firewall.sg_rules['fake_sg_id'] = [",
            "            {'direction': direction, 'ethertype': ethertype,",
            "             'protocol': protocol}]",
            "",
            "        self.firewall.filter_defer_apply_on()",
            "        self.firewall.sg_rules['fake_sg_id'] = []",
            "        self.firewall.filter_defer_apply_off()",
            "        cmd = ['conntrack', '-D']",
            "        if protocol:",
            "            cmd.extend(['-p', protocol])",
            "        if ethertype == 'IPv4':",
            "            cmd.extend(['-f', 'ipv4'])",
            "            if direction == 'ingress':",
            "                cmd.extend(['-d', '10.0.0.1'])",
            "            else:",
            "                cmd.extend(['-s', '10.0.0.1'])",
            "        else:",
            "            cmd.extend(['-f', 'ipv6'])",
            "            if direction == 'ingress':",
            "                cmd.extend(['-d', 'fe80::1'])",
            "            else:",
            "                cmd.extend(['-s', 'fe80::1'])",
            "        # initial data has 1, 2, and 9 in use, CT zone will start at 10.",
            "        cmd.extend(['-w', 10])",
            "        calls = [",
            "            mock.call(cmd, run_as_root=True, check_exit_code=True,",
            "                      extra_ok_codes=[1])]",
            "        self.utils_exec.assert_has_calls(calls)",
            "",
            "    def test_remove_conntrack_entries_for_delete_rule_ipv4(self):",
            "        for direction in ['ingress', 'egress']:",
            "            for pro in [None, 'tcp', 'icmp', 'udp']:",
            "                self._test_remove_conntrack_entries(",
            "                    'IPv4', pro, direction)",
            "",
            "    def test_remove_conntrack_entries_for_delete_rule_ipv6(self):",
            "        for direction in ['ingress', 'egress']:",
            "            for pro in [None, 'tcp', 'icmp', 'udp']:",
            "                self._test_remove_conntrack_entries(",
            "                    'IPv6', pro, direction)",
            "",
            "    def test_remove_conntrack_entries_for_port_sec_group_change(self):",
            "        port = self._fake_port()",
            "        port['security_groups'] = ['fake_sg_id']",
            "        self.firewall.filtered_ports[port['device']] = port",
            "        self.firewall.updated_sg_members = set(['tapfake_dev'])",
            "        self.firewall.filter_defer_apply_on()",
            "        new_port = copy.deepcopy(port)",
            "        new_port['security_groups'] = ['fake_sg_id2']",
            "        self.firewall.filtered_ports[port['device']] = new_port",
            "        self.firewall.filter_defer_apply_off()",
            "        calls = [",
            "            # initial data has 1, 2, and 9 in use, CT zone will start at 10.",
            "            mock.call(['conntrack', '-D', '-f', 'ipv4', '-d', '10.0.0.1',",
            "                       '-w', 10],",
            "                      run_as_root=True, check_exit_code=True,",
            "                      extra_ok_codes=[1]),",
            "            mock.call(['conntrack', '-D', '-f', 'ipv6', '-d', 'fe80::1',",
            "                       '-w', 10],",
            "                      run_as_root=True, check_exit_code=True,",
            "                      extra_ok_codes=[1])]",
            "        self.utils_exec.assert_has_calls(calls)",
            "",
            "    def test_update_delete_port_filter(self):",
            "        port = self._fake_port()",
            "        port['security_group_rules'] = [{'ethertype': 'IPv4',",
            "                                         'direction': 'ingress'}]",
            "        self.firewall.prepare_port_filter(port)",
            "        port['security_group_rules'] = [{'ethertype': 'IPv4',",
            "                                         'direction': 'egress'}]",
            "        self.firewall.update_port_filter(port)",
            "        self.firewall.update_port_filter({'device': 'no-exist-device'})",
            "        self.firewall.remove_port_filter(port)",
            "        self.firewall.remove_port_filter({'device': 'no-exist-device'})",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback',",
            "                     '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $ifake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ifake_dev', '-j RETURN',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'INPUT',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '",
            "                     '--sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev', '-m state --state INVALID -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT'),",
            "                 mock.call.remove_chain('ifake_dev'),",
            "                 mock.call.remove_chain('ofake_dev'),",
            "                 mock.call.remove_chain('sfake_dev'),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-out tapfake_dev '",
            "                     '--physdev-is-bridged -j $ifake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule(",
            "                     'FORWARD',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $sg-chain',",
            "                     comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule(",
            "                     'sg-chain',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'INPUT',",
            "                     '-m physdev --physdev-in tapfake_dev '",
            "                     '--physdev-is-bridged -j $ofake_dev',",
            "                     comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '",
            "                     '--sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j RETURN',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ofake_dev',",
            "                                    '-j $sg-fallback',",
            "                                    comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT'),",
            "                 mock.call.remove_chain('ifake_dev'),",
            "                 mock.call.remove_chain('ofake_dev'),",
            "                 mock.call.remove_chain('sfake_dev'),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain')]",
            "",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "    def test_remove_unknown_port(self):",
            "        port = self._fake_port()",
            "        self.firewall.remove_port_filter(port)",
            "        # checking no exception occurs",
            "        self.assertFalse(self.v4filter_inst.called)",
            "",
            "    def test_defer_apply(self):",
            "        with self.firewall.defer_apply():",
            "            pass",
            "        self.iptables_inst.assert_has_calls([mock.call.defer_apply_on(),",
            "                                             mock.call.defer_apply_off()])",
            "",
            "    def test_filter_defer_with_exception(self):",
            "        try:",
            "            with self.firewall.defer_apply():",
            "                raise Exception(\"same exception\")",
            "        except Exception:",
            "            pass",
            "        self.iptables_inst.assert_has_calls([mock.call.defer_apply_on(),",
            "                                             mock.call.defer_apply_off()])",
            "",
            "    def _mock_chain_applies(self):",
            "        class CopyingMock(mock.MagicMock):",
            "            \"\"\"Copies arguments so mutable arguments can be asserted on.",
            "",
            "            Copied verbatim from unittest.mock documentation.",
            "            \"\"\"",
            "            def __call__(self, *args, **kwargs):",
            "                args = copy.deepcopy(args)",
            "                kwargs = copy.deepcopy(kwargs)",
            "                return super(CopyingMock, self).__call__(*args, **kwargs)",
            "        # Need to use CopyingMock because _{setup,remove}_chains_apply are",
            "        # usually called with that's modified between calls (i.e.,",
            "        # self.firewall.filtered_ports).",
            "        chain_applies = CopyingMock()",
            "        self.firewall._setup_chains_apply = chain_applies.setup",
            "        self.firewall._remove_chains_apply = chain_applies.remove",
            "        return chain_applies",
            "",
            "    def test_mock_chain_applies(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port_prepare = {'device': 'd1', 'mac_address': 'prepare'}",
            "        port_update = {'device': 'd1', 'mac_address': 'update'}",
            "        self.firewall.prepare_port_filter(port_prepare)",
            "        self.firewall.update_port_filter(port_update)",
            "        self.firewall.remove_port_filter(port_update)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                mock.call.setup({'d1': port_prepare}, {}),",
            "                                mock.call.remove({'d1': port_prepare}, {}),",
            "                                mock.call.setup({'d1': port_update}, {}),",
            "                                mock.call.remove({'d1': port_update}, {}),",
            "                                mock.call.setup({}, {})])",
            "",
            "    def test_defer_chain_apply_need_pre_defer_copy(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port = self._fake_port()",
            "        device2port = {port['device']: port}",
            "        self.firewall.prepare_port_filter(port)",
            "        with self.firewall.defer_apply():",
            "            self.firewall.remove_port_filter(port)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                        mock.call.setup(device2port, {}),",
            "                                        mock.call.remove(device2port, {}),",
            "                                        mock.call.setup({}, {})])",
            "",
            "    def test_defer_chain_apply_coalesce_simple(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port = self._fake_port()",
            "        with self.firewall.defer_apply():",
            "            self.firewall.prepare_port_filter(port)",
            "            self.firewall.update_port_filter(port)",
            "            self.firewall.remove_port_filter(port)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                        mock.call.setup({}, {})])",
            "",
            "    def test_defer_chain_apply_coalesce_multiple_ports(self):",
            "        chain_applies = self._mock_chain_applies()",
            "        port1 = {'device': 'd1', 'mac_address': 'mac1', 'network_id': 'net1'}",
            "        port2 = {'device': 'd2', 'mac_address': 'mac2', 'network_id': 'net1'}",
            "        device2port = {'d1': port1, 'd2': port2}",
            "        with self.firewall.defer_apply():",
            "            self.firewall.prepare_port_filter(port1)",
            "            self.firewall.prepare_port_filter(port2)",
            "        chain_applies.assert_has_calls([mock.call.remove({}, {}),",
            "                                        mock.call.setup(device2port, {})])",
            "",
            "    def test_ip_spoofing_filter_with_multiple_ips(self):",
            "        port = {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': ['10.0.0.1', 'fe80::1', '10.0.0.2']}",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback', '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ifake_dev',",
            "                                    '-j $sg-fallback', comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule('INPUT',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.1/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-s 10.0.0.2/32 -m mac --mac-source FF:FF:FF:FF:FF:FF '",
            "                     '-j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '",
            "                     '--sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ofake_dev',",
            "                                    '-j $sg-fallback', comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "    def test_ip_spoofing_no_fixed_ips(self):",
            "        port = {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': []}",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.add_chain('sg-fallback'),",
            "                 mock.call.add_rule(",
            "                     'sg-fallback', '-j DROP',",
            "                     comment=ic.UNMATCH_DROP),",
            "                 mock.call.remove_chain('sg-chain'),",
            "                 mock.call.add_chain('sg-chain'),",
            "                 mock.call.add_chain('ifake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-out tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $ifake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ifake_dev',",
            "                     '-m state --state INVALID -j DROP', comment=None),",
            "                 mock.call.add_rule('ifake_dev', '-j $sg-fallback',",
            "                                    comment=None),",
            "                 mock.call.add_chain('ofake_dev'),",
            "                 mock.call.add_rule('FORWARD',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged '",
            "                                    '-j $sg-chain', comment=ic.VM_INT_SG),",
            "                 mock.call.add_rule('sg-chain',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.SG_TO_VM_SG),",
            "                 mock.call.add_rule('INPUT',",
            "                                    '-m physdev --physdev-in tapfake_dev '",
            "                                    '--physdev-is-bridged -j $ofake_dev',",
            "                                    comment=ic.INPUT_TO_SG),",
            "                 mock.call.add_chain('sfake_dev'),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev',",
            "                     '-m mac --mac-source FF:FF:FF:FF:FF:FF -j RETURN',",
            "                     comment=ic.PAIR_ALLOW),",
            "                 mock.call.add_rule(",
            "                     'sfake_dev', '-j DROP',",
            "                     comment=ic.PAIR_DROP),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-s 0.0.0.0/32 -d 255.255.255.255/32 -p udp -m udp '",
            "                     '--sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sfake_dev',",
            "                                    comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 68 --dport 67 -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-p udp -m udp --sport 67 -m udp --dport 68 -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state RELATED,ESTABLISHED -j RETURN',",
            "                     comment=None),",
            "                 mock.call.add_rule(",
            "                     'ofake_dev',",
            "                     '-m state --state INVALID -j DROP',",
            "                     comment=None),",
            "                 mock.call.add_rule('ofake_dev', '-j $sg-fallback',",
            "                                    comment=None),",
            "                 mock.call.add_rule('sg-chain', '-j ACCEPT')]",
            "        self.v4filter_inst.assert_has_calls(calls)",
            "",
            "",
            "class IptablesFirewallEnhancedIpsetTestCase(BaseIptablesFirewallTestCase):",
            "    def setUp(self):",
            "        super(IptablesFirewallEnhancedIpsetTestCase, self).setUp()",
            "        self.firewall.ipset = mock.Mock()",
            "        self.firewall.ipset.get_name.side_effect = (",
            "            ipset_manager.IpsetManager.get_name)",
            "        self.firewall.ipset.set_name_exists.return_value = True",
            "",
            "    def _fake_port(self, sg_id=FAKE_SGID):",
            "        return {'device': 'tapfake_dev',",
            "                'mac_address': 'ff:ff:ff:ff:ff:ff',",
            "                'network_id': 'fake_net',",
            "                'fixed_ips': [FAKE_IP['IPv4'],",
            "                              FAKE_IP['IPv6']],",
            "                'security_groups': [sg_id],",
            "                'security_group_source_groups': [sg_id]}",
            "",
            "    def _fake_sg_rule_for_ethertype(self, ethertype, remote_group):",
            "        return {'direction': 'ingress', 'remote_group_id': remote_group,",
            "                'ethertype': ethertype}",
            "",
            "    def _fake_sg_rules(self, sg_id=FAKE_SGID, remote_groups=None):",
            "        remote_groups = remote_groups or {_IPv4: [FAKE_SGID],",
            "                                          _IPv6: [FAKE_SGID]}",
            "        rules = []",
            "        for ip_version, remote_group_list in six.iteritems(remote_groups):",
            "            for remote_group in remote_group_list:",
            "                rules.append(self._fake_sg_rule_for_ethertype(ip_version,",
            "                                                              remote_group))",
            "        return {sg_id: rules}",
            "",
            "    def _fake_sg_members(self, sg_ids=None):",
            "        return {sg_id: copy.copy(FAKE_IP) for sg_id in (sg_ids or [FAKE_SGID])}",
            "",
            "    def test_prepare_port_filter_with_new_members(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.1', '10.0.0.2'], 'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {}",
            "        port = self._fake_port()",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [",
            "            mock.call.set_members('fake_sgid', 'IPv4',",
            "                                  ['10.0.0.1', '10.0.0.2']),",
            "            mock.call.set_members('fake_sgid', 'IPv6',",
            "                                  ['fe80::1'])",
            "        ]",
            "        self.firewall.ipset.assert_has_calls(calls, any_order=True)",
            "",
            "    def _setup_fake_firewall_members_and_rules(self, firewall):",
            "        firewall.sg_rules = self._fake_sg_rules()",
            "        firewall.pre_sg_rules = self._fake_sg_rules()",
            "        firewall.sg_members = self._fake_sg_members()",
            "        firewall.pre_sg_members = firewall.sg_members",
            "",
            "    def _prepare_rules_and_members_for_removal(self):",
            "        self._setup_fake_firewall_members_and_rules(self.firewall)",
            "        self.firewall.pre_sg_members[OTHER_SGID] = (",
            "            self.firewall.pre_sg_members[FAKE_SGID])",
            "",
            "    def test_determine_remote_sgs_to_remove(self):",
            "        self._prepare_rules_and_members_for_removal()",
            "        ports = [self._fake_port()]",
            "",
            "        self.assertEqual(",
            "            {_IPv4: set([OTHER_SGID]), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._determine_remote_sgs_to_remove(ports))",
            "",
            "    def test_determine_remote_sgs_to_remove_ipv6_unreferenced(self):",
            "        self._prepare_rules_and_members_for_removal()",
            "        ports = [self._fake_port()]",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [OTHER_SGID, FAKE_SGID],",
            "                           _IPv6: [FAKE_SGID]})",
            "        self.assertEqual(",
            "            {_IPv4: set(), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._determine_remote_sgs_to_remove(ports))",
            "",
            "    def test_get_remote_sg_ids_by_ipversion(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [FAKE_SGID], _IPv6: [OTHER_SGID]})",
            "",
            "        ports = [self._fake_port()]",
            "",
            "        self.assertEqual(",
            "            {_IPv4: set([FAKE_SGID]), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._get_remote_sg_ids_sets_by_ipversion(ports))",
            "",
            "    def test_get_remote_sg_ids(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [FAKE_SGID, FAKE_SGID, FAKE_SGID],",
            "                           _IPv6: [OTHER_SGID, OTHER_SGID, OTHER_SGID]})",
            "",
            "        port = self._fake_port()",
            "",
            "        self.assertEqual(",
            "            {_IPv4: set([FAKE_SGID]), _IPv6: set([OTHER_SGID])},",
            "            self.firewall._get_remote_sg_ids(port))",
            "",
            "    def test_determine_sg_rules_to_remove(self):",
            "        self.firewall.pre_sg_rules = self._fake_sg_rules(sg_id=OTHER_SGID)",
            "        ports = [self._fake_port()]",
            "",
            "        self.assertEqual(set([OTHER_SGID]),",
            "                         self.firewall._determine_sg_rules_to_remove(ports))",
            "",
            "    def test_get_sg_ids_set_for_ports(self):",
            "        sg_ids = set([FAKE_SGID, OTHER_SGID])",
            "        ports = [self._fake_port(sg_id) for sg_id in sg_ids]",
            "",
            "        self.assertEqual(sg_ids,",
            "                         self.firewall._get_sg_ids_set_for_ports(ports))",
            "",
            "    def test_remove_sg_members(self):",
            "        self.firewall.sg_members = self._fake_sg_members([FAKE_SGID,",
            "                                                          OTHER_SGID])",
            "        remote_sgs_to_remove = {_IPv4: set([FAKE_SGID]),",
            "                                _IPv6: set([FAKE_SGID, OTHER_SGID])}",
            "        self.firewall._remove_sg_members(remote_sgs_to_remove)",
            "",
            "        self.assertIn(OTHER_SGID, self.firewall.sg_members)",
            "        self.assertNotIn(FAKE_SGID, self.firewall.sg_members)",
            "",
            "    def test_remove_unused_security_group_info_clears_unused_rules(self):",
            "        self._setup_fake_firewall_members_and_rules(self.firewall)",
            "        self.firewall.prepare_port_filter(self._fake_port())",
            "",
            "        # create another SG which won't be referenced by any filtered port",
            "        fake_sg_rules = self.firewall.sg_rules['fake_sgid']",
            "        self.firewall.pre_sg_rules[OTHER_SGID] = fake_sg_rules",
            "        self.firewall.sg_rules[OTHER_SGID] = fake_sg_rules",
            "",
            "        # call the cleanup function, and check the unused sg_rules are out",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertNotIn(OTHER_SGID, self.firewall.sg_rules)",
            "",
            "    def test_remove_unused_security_group_info(self):",
            "        self.firewall.sg_members = {OTHER_SGID: {_IPv4: [], _IPv6: []}}",
            "        self.firewall.pre_sg_members = self.firewall.sg_members",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [FAKE_SGID], _IPv6: [FAKE_SGID]})",
            "        self.firewall.pre_sg_rules = self.firewall.sg_rules",
            "        port = self._fake_port()",
            "        self.firewall.filtered_ports['tapfake_dev'] = port",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertNotIn(OTHER_SGID, self.firewall.sg_members)",
            "",
            "    def test_not_remove_used_security_group_info(self):",
            "        self.firewall.sg_members = {OTHER_SGID: {_IPv4: [], _IPv6: []}}",
            "        self.firewall.pre_sg_members = self.firewall.sg_members",
            "        self.firewall.sg_rules = self._fake_sg_rules(",
            "            remote_groups={_IPv4: [OTHER_SGID], _IPv6: [OTHER_SGID]})",
            "        self.firewall.pre_sg_rules = self.firewall.sg_rules",
            "        port = self._fake_port()",
            "        self.firewall.filtered_ports['tapfake_dev'] = port",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertIn(OTHER_SGID, self.firewall.sg_members)",
            "",
            "    def test_remove_all_unused_info(self):",
            "        self._setup_fake_firewall_members_and_rules(self.firewall)",
            "        self.firewall.filtered_ports = {}",
            "        self.firewall._remove_unused_security_group_info()",
            "        self.assertFalse(self.firewall.sg_members)",
            "        self.assertFalse(self.firewall.sg_rules)",
            "",
            "    def test_single_fallback_accept_rule(self):",
            "        p1, p2 = self._fake_port(), self._fake_port()",
            "        self.firewall._setup_chains_apply(dict(p1=p1, p2=p2), {})",
            "        v4_adds = self.firewall.iptables.ipv4['filter'].add_rule.mock_calls",
            "        v6_adds = self.firewall.iptables.ipv6['filter'].add_rule.mock_calls",
            "        sg_chain_v4_accept = [call for call in v4_adds",
            "                              if call == mock.call('sg-chain', '-j ACCEPT')]",
            "        sg_chain_v6_accept = [call for call in v6_adds",
            "                              if call == mock.call('sg-chain', '-j ACCEPT')]",
            "        self.assertEqual(1, len(sg_chain_v4_accept))",
            "        self.assertEqual(1, len(sg_chain_v6_accept))",
            "",
            "    def test_prepare_port_filter_with_deleted_member(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.pre_sg_rules = self._fake_sg_rules()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': [",
            "                '10.0.0.1', '10.0.0.3', '10.0.0.4', '10.0.0.5'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.2'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.prepare_port_filter(self._fake_port())",
            "        calls = [",
            "            mock.call.set_members('fake_sgid', 'IPv4',",
            "                                  ['10.0.0.1', '10.0.0.3', '10.0.0.4',",
            "                                   '10.0.0.5']),",
            "            mock.call.set_members('fake_sgid', 'IPv6', ['fe80::1'])]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, True)",
            "",
            "    def test_remove_port_filter_with_destroy_ipset_chain(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        port = self._fake_port()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.1'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': [],",
            "            'IPv6': []}}",
            "        self.firewall.prepare_port_filter(port)",
            "        self.firewall.filter_defer_apply_on()",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': [],",
            "            'IPv6': []}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.1'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.remove_port_filter(port)",
            "        self.firewall.filter_defer_apply_off()",
            "        calls = [",
            "            mock.call.set_members('fake_sgid', 'IPv4', ['10.0.0.1']),",
            "            mock.call.set_members('fake_sgid', 'IPv6', ['fe80::1']),",
            "            mock.call.get_name('fake_sgid', 'IPv4'),",
            "            mock.call.set_name_exists('NIPv4fake_sgid'),",
            "            mock.call.get_name('fake_sgid', 'IPv6'),",
            "            mock.call.set_name_exists('NIPv6fake_sgid'),",
            "            mock.call.destroy('fake_sgid', 'IPv4'),",
            "            mock.call.destroy('fake_sgid', 'IPv6')]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, any_order=True)",
            "",
            "    def test_prepare_port_filter_with_sg_no_member(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.sg_rules[FAKE_SGID].append(",
            "            {'direction': 'ingress', 'remote_group_id': 'fake_sgid2',",
            "             'ethertype': 'IPv4'})",
            "        self.firewall.sg_rules.update()",
            "        self.firewall.sg_members['fake_sgid'] = {",
            "            'IPv4': ['10.0.0.1', '10.0.0.2'], 'IPv6': ['fe80::1']}",
            "        self.firewall.pre_sg_members = {}",
            "        port = self._fake_port()",
            "        port['security_group_source_groups'].append('fake_sgid2')",
            "        self.firewall.prepare_port_filter(port)",
            "        calls = [mock.call.set_members('fake_sgid', 'IPv4',",
            "                                       ['10.0.0.1', '10.0.0.2']),",
            "                 mock.call.set_members('fake_sgid', 'IPv6', ['fe80::1'])]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, any_order=True)",
            "",
            "    def test_filter_defer_apply_off_with_sg_only_ipv6_rule(self):",
            "        self.firewall.sg_rules = self._fake_sg_rules()",
            "        self.firewall.pre_sg_rules = self._fake_sg_rules()",
            "        self.firewall.ipset_chains = {'IPv4fake_sgid': ['10.0.0.2'],",
            "                                      'IPv6fake_sgid': ['fe80::1']}",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.2'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.pre_sg_members = {'fake_sgid': {",
            "            'IPv4': ['10.0.0.2'],",
            "            'IPv6': ['fe80::1']}}",
            "        self.firewall.sg_rules['fake_sgid'].remove(",
            "            {'direction': 'ingress', 'remote_group_id': 'fake_sgid',",
            "             'ethertype': 'IPv4'})",
            "        self.firewall.sg_rules.update()",
            "        self.firewall._defer_apply = True",
            "        port = self._fake_port()",
            "        self.firewall.filtered_ports['tapfake_dev'] = port",
            "        self.firewall._pre_defer_filtered_ports = {}",
            "        self.firewall._pre_defer_unfiltered_ports = {}",
            "        self.firewall.filter_defer_apply_off()",
            "        calls = [mock.call.destroy('fake_sgid', 'IPv4')]",
            "",
            "        self.firewall.ipset.assert_has_calls(calls, True)",
            "",
            "    def test_sg_rule_expansion_with_remote_ips(self):",
            "        other_ips = ['10.0.0.2', '10.0.0.3', '10.0.0.4']",
            "        self.firewall.sg_members = {'fake_sgid': {",
            "            'IPv4': [FAKE_IP['IPv4']] + other_ips,",
            "            'IPv6': [FAKE_IP['IPv6']]}}",
            "",
            "        port = self._fake_port()",
            "        rule = self._fake_sg_rule_for_ethertype(_IPv4, FAKE_SGID)",
            "        rules = self.firewall._expand_sg_rule_with_remote_ips(",
            "            rule, port, 'ingress')",
            "        self.assertEqual(list(rules),",
            "                         [dict(list(rule.items()) +",
            "                               [('source_ip_prefix', '%s/32' % ip)])",
            "                          for ip in other_ips])",
            "",
            "    def test_build_ipv4v6_mac_ip_list(self):",
            "        mac_oth = 'ffff-ff0f-ffff'",
            "        mac_unix = 'FF:FF:FF:0F:FF:FF'",
            "        ipv4 = FAKE_IP['IPv4']",
            "        ipv6 = FAKE_IP['IPv6']",
            "        fake_ipv4_pair = []",
            "        fake_ipv4_pair.append((mac_unix, ipv4))",
            "        fake_ipv6_pair = []",
            "        fake_ipv6_pair.append((mac_unix, ipv6))",
            "",
            "        mac_ipv4_pairs = []",
            "        mac_ipv6_pairs = []",
            "",
            "        self.firewall._build_ipv4v6_mac_ip_list(mac_oth, ipv4,",
            "                                                mac_ipv4_pairs, mac_ipv6_pairs)",
            "        self.assertEqual(fake_ipv4_pair, mac_ipv4_pairs)",
            "        self.firewall._build_ipv4v6_mac_ip_list(mac_oth, ipv6,",
            "                                                mac_ipv4_pairs, mac_ipv6_pairs)",
            "        self.assertEqual(fake_ipv6_pair, mac_ipv6_pairs)",
            "",
            "    def test_update_ipset_members(self):",
            "        self.firewall.sg_members[FAKE_SGID][_IPv4] = []",
            "        self.firewall.sg_members[FAKE_SGID][_IPv6] = []",
            "        sg_info = {constants.IPv4: [FAKE_SGID]}",
            "        self.firewall._update_ipset_members(sg_info)",
            "        calls = [mock.call.set_members(FAKE_SGID, constants.IPv4, [])]",
            "        self.firewall.ipset.assert_has_calls(calls)",
            "",
            "",
            "class OVSHybridIptablesFirewallTestCase(BaseIptablesFirewallTestCase):",
            "",
            "    def setUp(self):",
            "        super(OVSHybridIptablesFirewallTestCase, self).setUp()",
            "        self.firewall = iptables_firewall.OVSHybridIptablesFirewallDriver()",
            "        # initial data has 1, 2, and 9 in use, see RAW_TABLE_OUTPUT above.",
            "        self._dev_zone_map = {'61634509-31': 2, '8f46cf18-12': 9,",
            "                              '95c24827-02': 2, 'e804433b-61': 1}",
            "",
            "    def test__populate_initial_zone_map(self):",
            "        self.assertEqual(self._dev_zone_map, self.firewall._device_zone_map)",
            "",
            "    def test__generate_device_zone(self):",
            "        # initial data has 1, 2, and 9 in use.",
            "        # we fill from top up first.",
            "        self.assertEqual(10, self.firewall._generate_device_zone('test'))",
            "",
            "        # once it's maxed out, it scans for gaps",
            "        self.firewall._device_zone_map['someport'] = (",
            "            iptables_firewall.MAX_CONNTRACK_ZONES)",
            "        for i in range(3, 9):",
            "            self.assertEqual(i, self.firewall._generate_device_zone(i))",
            "",
            "        # 9 and 10 are taken so next should be 11",
            "        self.assertEqual(11, self.firewall._generate_device_zone('p11'))",
            "",
            "        # take out zone 1 and make sure it's selected",
            "        self.firewall._device_zone_map.pop('e804433b-61')",
            "        self.assertEqual(1, self.firewall._generate_device_zone('p1'))",
            "",
            "        # fill it up and then make sure an extra throws an error",
            "        for i in range(1, 65536):",
            "            self.firewall._device_zone_map['dev-%s' % i] = i",
            "        with testtools.ExpectedException(n_exc.CTZoneExhaustedError):",
            "            self.firewall._find_open_zone()",
            "",
            "        # with it full, try again, this should trigger a cleanup and return 1",
            "        self.assertEqual(1, self.firewall._generate_device_zone('p12'))",
            "        self.assertEqual({'p12': 1}, self.firewall._device_zone_map)",
            "",
            "    def test_get_device_zone(self):",
            "        # initial data has 1, 2, and 9 in use.",
            "        self.assertEqual(10,",
            "                         self.firewall.get_device_zone('12345678901234567'))",
            "        # should have been truncated to 11 chars",
            "        self._dev_zone_map.update({'12345678901': 10})",
            "        self.assertEqual(self._dev_zone_map, self.firewall._device_zone_map)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "161": [
                "IptablesFirewallTestCase",
                "test_prepare_port_filter_with_no_sg"
            ],
            "943": [
                "IptablesFirewallTestCase",
                "_test_prepare_port_filter"
            ],
            "1198": [
                "IptablesFirewallTestCase",
                "test_update_delete_port_filter"
            ],
            "1270": [
                "IptablesFirewallTestCase",
                "test_update_delete_port_filter"
            ],
            "1445": [
                "IptablesFirewallTestCase",
                "test_ip_spoofing_filter_with_multiple_ips"
            ],
            "1519": [
                "IptablesFirewallTestCase",
                "test_ip_spoofing_no_fixed_ips"
            ]
        },
        "addLocation": []
    }
}