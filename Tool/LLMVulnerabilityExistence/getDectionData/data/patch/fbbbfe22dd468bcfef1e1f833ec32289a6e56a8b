{
    "web/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "     \"ppas-16\": \"\""
            },
            "1": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": 470,
                "PatchRowcode": " }"
            },
            "2": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 471,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 472,
                "PatchRowcode": "+##########################################################################"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 473,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 474,
                "PatchRowcode": "+# Admin can specify fixed binary paths to prevent users from changing."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 475,
                "PatchRowcode": "+# It will take precedence over DEFAULT_BINARY_PATHS."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 476,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 477,
                "PatchRowcode": "+FIXED_BINARY_PATHS = {"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+    \"pg\": \"\","
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 479,
                "PatchRowcode": "+    \"pg-12\": \"\","
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 480,
                "PatchRowcode": "+    \"pg-13\": \"\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 481,
                "PatchRowcode": "+    \"pg-14\": \"\","
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 482,
                "PatchRowcode": "+    \"pg-15\": \"\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+    \"pg-16\": \"\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+    \"ppas\": \"\","
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+    \"ppas-12\": \"\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+    \"ppas-13\": \"\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+    \"ppas-14\": \"\","
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+    \"ppas-15\": \"\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+    \"ppas-16\": \"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+}"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 492,
                "PatchRowcode": " ##########################################################################"
            },
            "24": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 493,
                "PatchRowcode": " # Test settings - used primarily by the regression suite, not for users"
            },
            "25": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": 494,
                "PatchRowcode": " ##########################################################################"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "# config.py - Core application configuration settings",
            "#",
            "##########################################################################",
            "",
            "import builtins",
            "import logging",
            "import os",
            "import sys",
            "from collections import OrderedDict",
            "",
            "# We need to include the root directory in sys.path to ensure that we can",
            "# find everything we need when running in the standalone runtime.",
            "root = os.path.dirname(os.path.realpath(__file__))",
            "if sys.path[0] != root:",
            "    sys.path.insert(0, root)",
            "",
            "# The config database connection pool size.",
            "# Setting this to 0 will remove any limit.",
            "CONFIG_DATABASE_CONNECTION_POOL_SIZE = 5",
            "# The number of connections allowed to overflow beyond",
            "# the connection pool size.",
            "CONFIG_DATABASE_CONNECTION_MAX_OVERFLOW = 100",
            "",
            "from pgadmin.utils import env, IS_WIN, fs_short_path",
            "from version import APP_VERSION, APP_RELEASE, APP_REVISION, APP_SUFFIX, \\",
            "    APP_VERSION_INT",
            "from branding import APP_NAME, APP_ICON, APP_COPYRIGHT, APP_PATH, \\",
            "    APP_WIN_PATH, APP_SHORT_NAME, APP_DEFAULT_EMAIL",
            "",
            "##########################################################################",
            "# Misc stuff",
            "##########################################################################",
            "",
            "# Path to the online help.",
            "HELP_PATH = '../../../docs/en_US/_build/html/'",
            "",
            "# Languages we support in the UI",
            "LANGUAGES = {",
            "    'en': 'English',",
            "    'zh': 'Chinese (Simplified)',",
            "    'cs': 'Czech',",
            "    'fr': 'French',",
            "    'de': 'German',",
            "    'id': 'Indonesian',",
            "    'it': 'Italian',",
            "    'ja': 'Japanese',",
            "    'ko': 'Korean',",
            "    'pl': 'Polish',",
            "    'pt_BR': 'Portuguese (Brazilian)',",
            "    'ru': 'Russian',",
            "    'es': 'Spanish',",
            "}",
            "",
            "# DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING!",
            "# List of modules to skip when dynamically loading",
            "MODULE_BLACKLIST = ['test']",
            "",
            "# DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING!",
            "# List of treeview browser nodes to skip when dynamically loading",
            "NODE_BLACKLIST = []",
            "",
            "##########################################################################",
            "# Server settings",
            "##########################################################################",
            "",
            "# The server mode determines whether or not we're running on a web server",
            "# requiring user authentication, or desktop mode which uses an automatic",
            "# default login.",
            "#",
            "# DO NOT DISABLE SERVER MODE IF RUNNING ON A WEBSERVER!!",
            "#",
            "# We only set SERVER_MODE if it's not already set. That's to allow the",
            "# runtime to force it to False.",
            "#",
            "# NOTE: If you change the value of SERVER_MODE or DATA_DIR in an included",
            "#       config file, you may also need to redefine any values below that are",
            "#       derived from it, notably various paths such as LOG_FILE, SQLITE_PATH,",
            "#       SESSION_DB_PATH, STORAGE_DIR, KERBEROS_CCACHE_DIR, and",
            "#       AZURE_CREDENTIAL_CACHE_DIR",
            "",
            "if (not hasattr(builtins, 'SERVER_MODE')) or builtins.SERVER_MODE is None:",
            "    SERVER_MODE = True",
            "else:",
            "    SERVER_MODE = builtins.SERVER_MODE",
            "",
            "# HTTP headers to search for CSRF token when it is not provided in the form.",
            "# Default is ['X-CSRFToken', 'X-CSRF-Token']",
            "WTF_CSRF_HEADERS = ['X-pgA-CSRFToken']",
            "",
            "# User ID (email address) to use for the default user in desktop mode.",
            "# The default should be fine here, as it's not exposed in the app.",
            "DESKTOP_USER = APP_DEFAULT_EMAIL",
            "",
            "# This option allows the user to host the application on a LAN",
            "# Default hosting is on localhost (DEFAULT_SERVER='localhost').",
            "# To host pgAdmin4 over LAN set DEFAULT_SERVER='0.0.0.0' (or a specific",
            "# adaptor address.",
            "#",
            "# NOTE: This is NOT recommended for production use, only for debugging",
            "# or testing. Production installations should be run as a WSGI application",
            "# behind Apache HTTPD.",
            "DEFAULT_SERVER = '127.0.0.1'",
            "",
            "# The default port on which the app server will listen if not set in the",
            "# environment by the runtime",
            "DEFAULT_SERVER_PORT = 5050",
            "",
            "# This param is used to override the default web server information about",
            "# the web technology and the frameworks being used in the application",
            "# An attacker could use this information to fingerprint underlying operating",
            "# system and research known exploits for the specific version of",
            "# software in use",
            "WEB_SERVER = 'Python'",
            "",
            "# Enable X-Frame-Option protection.",
            "# Set to one of \"SAMEORIGIN\", \"ALLOW-FROM origin\" or \"\" to disable.",
            "# Note that \"DENY\" is NOT supported (and will be silently ignored).",
            "# See https://tools.ietf.org/html/rfc7034 for more info.",
            "X_FRAME_OPTIONS = \"SAMEORIGIN\"",
            "",
            "# The Content-Security-Policy header allows you to restrict how resources",
            "# such as JavaScript, CSS, or pretty much anything that the browser loads.",
            "# see https://content-security-policy.com/#source_list for more info",
            "# e.g. \"default-src https: data: 'unsafe-inline' 'unsafe-eval';\"",
            "CONTENT_SECURITY_POLICY = \"default-src ws: http: data: blob: 'unsafe-inline'\" \\",
            "                          \" 'unsafe-eval';\"",
            "",
            "# STRICT_TRANSPORT_SECURITY_ENABLED when set to True will set the",
            "# Strict-Transport-Security header",
            "STRICT_TRANSPORT_SECURITY_ENABLED = False",
            "",
            "# The Strict-Transport-Security header tells the browser to convert all HTTP",
            "# requests to HTTPS, preventing man-in-the-middle (MITM) attacks.",
            "# e.g. 'max-age=31536000; includeSubDomains'",
            "STRICT_TRANSPORT_SECURITY = \"max-age=31536000; includeSubDomains\"",
            "",
            "# The X-Content-Type-Options header forces the browser to honor the response",
            "# content type instead of trying to detect it, which can be abused to",
            "# generate a cross-site scripting (XSS) attack.",
            "# e.g. nosniff",
            "X_CONTENT_TYPE_OPTIONS = \"nosniff\"",
            "",
            "# The browser will try to prevent reflected XSS attacks by not loading the",
            "# page if the request contains something that looks like JavaScript and the",
            "# response contains the same data. e.g. '1; mode=block'",
            "X_XSS_PROTECTION = \"1; mode=block\"",
            "",
            "# This param is used to validate ALLOWED_HOSTS for the application",
            "# This will be used to avoid Host Header Injection attack",
            "# ALLOWED_HOSTS = ['225.0.0.0/8', '226.0.0.0/7', '228.0.0.0/6']",
            "# ALLOWED_HOSTS = ['127.0.0.1', '192.168.0.1']",
            "# if ALLOWED_HOSTS= [] then it will accept all ips (and application will be",
            "# vulnerable to Host Header Injection attack)",
            "ALLOWED_HOSTS = []",
            "",
            "# Hashing algorithm used for password storage",
            "SECURITY_PASSWORD_HASH = 'pbkdf2_sha512'",
            "",
            "# Minimum password length",
            "PASSWORD_LENGTH_MIN = 6",
            "",
            "# Reverse Proxy parameters",
            "# You must tell the middleware how many proxies set each header",
            "# so it knows what values to trust.",
            "# See https://tinyurl.com/yyg7r9av",
            "# for more information.",
            "",
            "# Number of values to trust for X-Forwarded-For",
            "PROXY_X_FOR_COUNT = 1",
            "",
            "# Number of values to trust for X-Forwarded-Proto.",
            "PROXY_X_PROTO_COUNT = 1",
            "",
            "# Number of values to trust for X-Forwarded-Host.",
            "PROXY_X_HOST_COUNT = 0",
            "",
            "# Number of values to trust for X-Forwarded-Port.",
            "PROXY_X_PORT_COUNT = 1",
            "",
            "# Number of values to trust for X-Forwarded-Prefix.",
            "PROXY_X_PREFIX_COUNT = 0",
            "",
            "# NOTE: CSRF_SESSION_KEY, SECRET_KEY and SECURITY_PASSWORD_SALT are no",
            "#       longer part of the main configuration, but are stored in the",
            "#       configuration databases 'keys' table and are auto-generated.",
            "",
            "# COMPRESSION",
            "COMPRESS_MIMETYPES = [",
            "    'text/html', 'text/css', 'text/xml', 'text/javascript',",
            "    'application/json', 'application/javascript'",
            "]",
            "COMPRESS_LEVEL = 9",
            "COMPRESS_MIN_SIZE = 500",
            "",
            "# Set the cache control max age for static files in flask to 1 year",
            "SEND_FILE_MAX_AGE_DEFAULT = 31556952",
            "",
            "# This will be added to static urls as url parameter with value as",
            "# APP_VERSION_INT for cache busting on version upgrade. If the value is set as",
            "# None or empty string then it will not be added.",
            "# eg - http:localhost:5050/pgadmin.css?intver=3.13",
            "APP_VERSION_PARAM = 'ver'",
            "",
            "# Add the internal version param to below extensions only",
            "APP_VERSION_EXTN = ('.css', '.js', '.html', '.svg', '.png', '.gif', '.ico')",
            "",
            "# Data directory for storage of config settings etc. This shouldn't normally",
            "# need to be changed - it's here as various other settings depend on it.",
            "# On Windows, we always store data in %APPDATA%\\$(APP_WIN_PATH). On other",
            "# platforms, if we're in server mode we use /var/lib/$(APP_PATH),",
            "# otherwise ~/.$(APP_PATH)",
            "if IS_WIN:",
            "    # Use the short path on windows",
            "    DATA_DIR = os.path.realpath(",
            "        os.path.join(fs_short_path(env('APPDATA')), APP_WIN_PATH)",
            "    )",
            "else:",
            "    if SERVER_MODE:",
            "        DATA_DIR = os.path.join('/var/lib/', APP_PATH)",
            "    else:",
            "        DATA_DIR = os.path.realpath(",
            "            os.path.expanduser('~/' + '.' + APP_PATH + '/')",
            "        )",
            "",
            "# An optional login banner to show security warnings/disclaimers etc. at",
            "# login and password recovery etc. HTML may be included for basic formatting,",
            "# For example:",
            "# LOGIN_BANNER = \"<h4>Authorised Users Only!</h4>\" \\",
            "#                \"Unauthorised use is strictly forbidden.\"",
            "LOGIN_BANNER = \"\"",
            "",
            "##########################################################################",
            "# Log settings",
            "##########################################################################",
            "",
            "# Debug mode?",
            "DEBUG = False",
            "",
            "# Application log level - one of:",
            "#   CRITICAL 50",
            "#   ERROR    40",
            "#   WARNING  30",
            "#   SQL      25",
            "#   INFO     20",
            "#   DEBUG    10",
            "#   NOTSET    0",
            "CONSOLE_LOG_LEVEL = logging.WARNING",
            "FILE_LOG_LEVEL = logging.WARNING",
            "",
            "# Log format.",
            "JSON_LOGGER = False",
            "CONSOLE_LOG_FORMAT_JSON = OrderedDict([",
            "    (\"time\", \"asctime\"),",
            "    (\"message\", \"message\"),",
            "    (\"level\", \"levelname\")",
            "])",
            "",
            "FILE_LOG_FORMAT_JSON = OrderedDict([",
            "    (\"time\", \"asctime\"),",
            "    (\"message\", \"message\"),",
            "    (\"level\", \"levelname\")",
            "])",
            "",
            "",
            "CONSOLE_LOG_FORMAT = '%(asctime)s: %(levelname)s\\t%(name)s:\\t%(message)s'",
            "FILE_LOG_FORMAT = '%(asctime)s: %(levelname)s\\t%(name)s:\\t%(message)s'",
            "",
            "# Log file name. This goes in the data directory, except on non-Windows",
            "# platforms in server mode.",
            "if SERVER_MODE and not IS_WIN:",
            "    LOG_FILE = os.path.join('/var/log', APP_PATH, APP_SHORT_NAME + '.log')",
            "else:",
            "    LOG_FILE = os.path.join(DATA_DIR, APP_SHORT_NAME + '.log')",
            "",
            "# Log rotation setting",
            "# Log file will be rotated considering values for LOG_ROTATION_SIZE",
            "# & LOG_ROTATION_AGE. Rotated file will be named in format",
            "# - LOG_FILE.Y-m-d_H-M-S",
            "LOG_ROTATION_SIZE = 10  # In MBs",
            "LOG_ROTATION_AGE = 1440  # In minutes",
            "LOG_ROTATION_MAX_LOG_FILES = 90  # Maximum number of backups to retain",
            "##########################################################################",
            "# Server Connection Driver Settings",
            "##########################################################################",
            "",
            "# The default driver used for making connection with PostgreSQL",
            "PG_DEFAULT_DRIVER = 'psycopg3'",
            "",
            "# Maximum allowed idle time in minutes before which releasing the connection",
            "# for the particular session. (in minutes)",
            "MAX_SESSION_IDLE_TIME = 60",
            "",
            "##########################################################################",
            "# External Database Settings",
            "#",
            "# All configuration settings are stored by default in the SQLite database.",
            "# In order to use external databases like PostgreSQL sets the value of",
            "# CONFIG_DATABASE_URI like below:",
            "# dialect+driver://username:password@host:port/database",
            "#",
            "# PostgreSQL:",
            "# postgresql://username:password@host:port/database",
            "# Specify Schema Name",
            "# postgresql://username:password@host:port/database?options=-csearch_path=pgadmin",
            "# Using PGPASS file",
            "# postgresql://username@host:port?options=-csearch_path=pgadmin",
            "##########################################################################",
            "CONFIG_DATABASE_URI = ''",
            "",
            "##########################################################################",
            "# User account and settings storage",
            "##########################################################################",
            "",
            "# The default path to the SQLite database used to store user accounts and",
            "# settings. This default places the file in the same directory as this",
            "# config file, but generates an absolute path for use througout the app.",
            "SQLITE_PATH = env('SQLITE_PATH') or \\",
            "    os.path.join(DATA_DIR, APP_SHORT_NAME + '.db')",
            "",
            "# SQLITE_TIMEOUT will define how long to wait before throwing the error -",
            "# OperationError due to database lock. On slower system, you may need to change",
            "# this to some higher value.",
            "# (Default: 500 milliseconds)",
            "SQLITE_TIMEOUT = 500",
            "",
            "# Allow database connection passwords to be saved if the user chooses.",
            "# Set to False to disable password saving.",
            "ALLOW_SAVE_PASSWORD = True",
            "",
            "# Maximum number of history queries stored per user/server/database",
            "MAX_QUERY_HIST_STORED = 20",
            "",
            "##########################################################################",
            "# Server-side session storage path",
            "#",
            "# SESSION_DB_PATH (Default: $HOME/.pgadmin4/sessions)",
            "##########################################################################",
            "#",
            "# We use SQLite for server-side session storage. There will be one",
            "# SQLite database object per session created.",
            "#",
            "# Specify the path used to store your session objects.",
            "#",
            "# If the specified directory does not exist, the setup script will create",
            "# it with permission mode 700 to keep the session database secure.",
            "#",
            "# On certain systems, you can use shared memory (tmpfs) for maximum",
            "# scalability, for example, on Ubuntu:",
            "#",
            "# SESSION_DB_PATH = '/run/shm/pgAdmin4_session'",
            "#",
            "##########################################################################",
            "SESSION_DB_PATH = os.path.join(DATA_DIR, 'sessions')",
            "",
            "SESSION_COOKIE_NAME = 'pga4_session'",
            "",
            "##########################################################################",
            "# Mail server settings",
            "##########################################################################",
            "",
            "# These settings are used when running in web server mode for confirming",
            "# and resetting passwords etc.",
            "# See: http://pythonhosted.org/Flask-Mail/ for more info",
            "MAIL_SERVER = 'localhost'",
            "MAIL_PORT = 25",
            "MAIL_USE_SSL = False",
            "MAIL_USE_TLS = False",
            "MAIL_USERNAME = ''",
            "MAIL_PASSWORD = ''",
            "MAIL_DEBUG = False",
            "",
            "# Flask-Security overrides Flask-Mail's MAIL_DEFAULT_SENDER setting, so",
            "# that should be set as such:",
            "SECURITY_EMAIL_SENDER = 'no-reply@localhost'",
            "",
            "##########################################################################",
            "# Mail content settings",
            "##########################################################################",
            "",
            "# These settings define the content of password reset emails",
            "SECURITY_EMAIL_SUBJECT_PASSWORD_RESET = \"Password reset instructions for %s\" \\",
            "                                        % APP_NAME",
            "SECURITY_EMAIL_SUBJECT_PASSWORD_NOTICE = \"Your %s password has been reset\" \\",
            "                                         % APP_NAME",
            "SECURITY_EMAIL_SUBJECT_PASSWORD_CHANGE_NOTICE = \\",
            "    \"Your password for %s has been changed\" % APP_NAME",
            "",
            "##########################################################################",
            "# Email address validation",
            "##########################################################################",
            "CHECK_EMAIL_DELIVERABILITY = False",
            "SECURITY_EMAIL_VALIDATOR_ARGS = \\",
            "    {\"check_deliverability\": CHECK_EMAIL_DELIVERABILITY}",
            "",
            "##########################################################################",
            "# Upgrade checks",
            "##########################################################################",
            "",
            "# Check for new versions of the application?",
            "UPGRADE_CHECK_ENABLED = True",
            "",
            "# Where should we get the data from?",
            "UPGRADE_CHECK_URL = 'https://www.pgadmin.org/versions.json'",
            "",
            "# What key should we look at in the upgrade data file?",
            "UPGRADE_CHECK_KEY = 'pgadmin4'",
            "",
            "# Which CA file should we use?",
            "# Default to cacert.pem in the same directory as config.py et al.",
            "CA_FILE = os.path.join(os.path.dirname(os.path.realpath(__file__)),",
            "                       \"cacert.pem\")",
            "",
            "# Check if the detected browser is supported",
            "CHECK_SUPPORTED_BROWSER = True",
            "",
            "##########################################################################",
            "# Storage Manager storage url config settings",
            "# If user sets STORAGE_DIR to empty it will show all volumes if platform",
            "# is Windows, '/' if it is Linux, Mac or any other unix type system.",
            "",
            "# For example:",
            "# 1. STORAGE_DIR = get_drive(\"C\") or get_drive() # return C:/ by default",
            "# where C can be any drive character such as \"D\", \"E\", \"G\" etc",
            "# 2. Set path manually like",
            "# STORAGE_DIR = \"/path/to/directory/\"",
            "##########################################################################",
            "STORAGE_DIR = os.path.join(DATA_DIR, 'storage')",
            "",
            "##########################################################################",
            "# Default locations for binary utilities (pg_dump, pg_restore etc)",
            "#",
            "# These are intentionally left empty in the main config file, but are",
            "# expected to be overridden by packagers in config_distro.py.",
            "#",
            "# A default location can be specified for each database driver ID, in",
            "# a dictionary. Either an absolute or relative path can be specified.",
            "#",
            "# Version-specific defaults can also be specified, which will take priority",
            "# over un-versioned paths.",
            "#",
            "# In cases where it may be difficult to know what the working directory",
            "# is, \"$DIR\" can be specified. This will be replaced with the path to the",
            "# top-level pgAdmin4.py file. For example, on macOS we might use:",
            "#",
            "# $DIR/../../SharedSupport",
            "#",
            "##########################################################################",
            "DEFAULT_BINARY_PATHS = {",
            "    \"pg\": \"\",",
            "    \"pg-12\": \"\",",
            "    \"pg-13\": \"\",",
            "    \"pg-14\": \"\",",
            "    \"pg-15\": \"\",",
            "    \"pg-16\": \"\",",
            "    \"ppas\": \"\",",
            "    \"ppas-12\": \"\",",
            "    \"ppas-13\": \"\",",
            "    \"ppas-14\": \"\",",
            "    \"ppas-15\": \"\",",
            "    \"ppas-16\": \"\"",
            "}",
            "",
            "##########################################################################",
            "# Test settings - used primarily by the regression suite, not for users",
            "##########################################################################",
            "",
            "# The default path for SQLite database for testing",
            "TEST_SQLITE_PATH = os.path.join(DATA_DIR, 'test_pgadmin4.db')",
            "",
            "##########################################################################",
            "# Allows flask application to response to the each request asynchronously",
            "##########################################################################",
            "THREADED_MODE = True",
            "",
            "##########################################################################",
            "# Do not allow SQLALCHEMY to track modification as it is going to be",
            "# deprecated in future",
            "##########################################################################",
            "SQLALCHEMY_TRACK_MODIFICATIONS = False",
            "",
            "##########################################################################",
            "# Number of records to fetch in one batch in query tool when query result",
            "# set is large.",
            "##########################################################################",
            "ON_DEMAND_RECORD_COUNT = 1000",
            "",
            "##########################################################################",
            "# Allow users to display Gravatar image for their username in Server mode",
            "##########################################################################",
            "SHOW_GRAVATAR_IMAGE = True",
            "",
            "##########################################################################",
            "# Set cookie path and options",
            "##########################################################################",
            "COOKIE_DEFAULT_PATH = '/'",
            "COOKIE_DEFAULT_DOMAIN = None",
            "SESSION_COOKIE_DOMAIN = None",
            "SESSION_COOKIE_SAMESITE = 'Lax'",
            "SESSION_COOKIE_SECURE = False",
            "SESSION_COOKIE_HTTPONLY = True",
            "",
            "#########################################################################",
            "# Skip storing session in files and cache for specific paths",
            "#########################################################################",
            "SESSION_SKIP_PATHS = [",
            "    '/misc/ping'",
            "]",
            "",
            "##########################################################################",
            "# Session expiration support",
            "##########################################################################",
            "# SESSION_EXPIRATION_TIME is the interval in Days. Session will be",
            "# expire after the specified number of *days*.",
            "SESSION_EXPIRATION_TIME = 1",
            "",
            "# Make SESSION_EXPIRATION_TIME to 1 week in DESKTOP mode",
            "if not SERVER_MODE:",
            "    SESSION_EXPIRATION_TIME = 7",
            "",
            "# CHECK_SESSION_FILES_INTERVAL is interval in Hours. Application will check",
            "# the session files for cleanup after specified number of *hours*.",
            "CHECK_SESSION_FILES_INTERVAL = 24",
            "",
            "# USER_INACTIVITY_TIMEOUT is interval in Seconds. If the pgAdmin screen is left",
            "# unattended for <USER_INACTIVITY_TIMEOUT> seconds then the user will",
            "# be logged out. When set to 0, the timeout will be disabled.",
            "# If pgAdmin doesn't detect any activity in the time specified (in seconds),",
            "# the user will be forcibly logged out from pgAdmin. Set to zero to disable",
            "# the timeout.",
            "# Note: This is applicable only for SERVER_MODE=True.",
            "USER_INACTIVITY_TIMEOUT = 0",
            "",
            "# OVERRIDE_USER_INACTIVITY_TIMEOUT when set to True will override",
            "# USER_INACTIVITY_TIMEOUT when long running queries in the Query Tool",
            "# or Debugger are running. When the queries complete, the inactivity timer",
            "# will restart in this case. If set to False, user inactivity may cause",
            "# transactions or in-process debugging sessions to be aborted.",
            "OVERRIDE_USER_INACTIVITY_TIMEOUT = True",
            "",
            "##########################################################################",
            "# SSH Tunneling supports only for Python 2.7 and 3.4+",
            "##########################################################################",
            "SUPPORT_SSH_TUNNEL = True",
            "# Allow SSH Tunnel passwords to be saved if the user chooses.",
            "# Set to False to disable password saving.",
            "ALLOW_SAVE_TUNNEL_PASSWORD = False",
            "",
            "##########################################################################",
            "# Master password is used to encrypt/decrypt saved server passwords",
            "# Applicable for desktop mode only",
            "##########################################################################",
            "MASTER_PASSWORD_REQUIRED = True",
            "",
            "##########################################################################",
            "",
            "# pgAdmin encrypts the database connection and ssh tunnel password using a",
            "# master password or pgAdmin login password (for other authentication sources)",
            "# before storing it in the pgAdmin configuration database.",
            "#",
            "# Below setting is used to allow the user to specify the path to a script",
            "# or program that will return an encryption key which will be used to",
            "# encrypt the passwords. This setting is used only in server mode when",
            "# auth sources are oauth, Kerberos, and webserver.",
            "#",
            "# You can pass the current username as an argument to the external script",
            "# by specifying %u in config value.",
            "# E.g. - MASTER_PASSWORD_HOOK = '<PATH>/passwdgen_script.sh %u'",
            "##########################################################################",
            "MASTER_PASSWORD_HOOK = None",
            "",
            "##########################################################################",
            "",
            "# Allows pgAdmin4 to create session cookies based on IP address, so even",
            "# if a cookie is stolen, the attacker will not be able to connect to the",
            "# server using that stolen cookie.",
            "# Note: This can cause problems when the server is deployed in dynamic IP",
            "# address hosting environments, such as Kubernetes or behind load",
            "# balancers. In such cases, this option should be set to False.",
            "##########################################################################",
            "ENHANCED_COOKIE_PROTECTION = True",
            "",
            "##########################################################################",
            "# External Authentication Sources",
            "##########################################################################",
            "",
            "# Default setting is internal",
            "# External Supported Sources: ldap, kerberos, oauth2",
            "# Multiple authentication can be achieved by setting this parameter to",
            "# ['ldap', 'internal'] or ['oauth2', 'internal'] or",
            "# ['webserver', 'internal'] etc.",
            "# pgAdmin will authenticate the user with ldap/oauth2 whatever first in the",
            "# list, in case of failure the second authentication option will be considered.",
            "",
            "AUTHENTICATION_SOURCES = ['internal']",
            "",
            "##########################################################################",
            "# MAX_LOGIN_ATTEMPTS which sets the number of failed login attempts that",
            "# are allowed. If this value is exceeded the account is locked and can be",
            "# reset by an administrator. By setting the variable to the value zero",
            "# this feature is deactivated.",
            "##########################################################################",
            "MAX_LOGIN_ATTEMPTS = 3",
            "",
            "##########################################################################",
            "# Only consider password to check the failed login attempts, email is",
            "# excluded from this check",
            "LOGIN_ATTEMPT_FIELDS = ['password']",
            "##########################################################################",
            "# LDAP Configuration",
            "##########################################################################",
            "",
            "# After ldap authentication, user will be added into the SQLite database",
            "# automatically, if set to True.",
            "# Set it to False, if user should not be added automatically,",
            "# in this case Admin has to add the user manually in the SQLite database.",
            "LDAP_AUTO_CREATE_USER = True",
            "",
            "# Connection timeout",
            "LDAP_CONNECTION_TIMEOUT = 10",
            "",
            "# Server connection details (REQUIRED)",
            "# example: ldap://<ip-address>:<port> or ldap://<hostname>:<port>",
            "LDAP_SERVER_URI = 'ldap://<ip-address>:<port>'",
            "",
            "# The LDAP attribute containing user names. In OpenLDAP, this may be 'uid'",
            "# whilst in AD, 'sAMAccountName' might be appropriate. (REQUIRED)",
            "LDAP_USERNAME_ATTRIBUTE = '<User-id>'",
            "",
            "##########################################################################",
            "# 3 ways to configure LDAP as follows (Choose anyone):",
            "",
            "# 1. Dedicated User binding",
            "",
            "# LDAP Bind User DN Example: cn=username,dc=example,dc=com",
            "# Set this parameter to allow the connection to bind using a dedicated user.",
            "# After the connection is made, the pgadmin login user will be further",
            "# authenticated by the username and password provided",
            "# at the login screen.",
            "LDAP_BIND_USER = None",
            "",
            "# LDAP Bind User Password",
            "LDAP_BIND_PASSWORD = None",
            "",
            "# OR ####################",
            "# 2. Anonymous Binding",
            "",
            "# Set this parameter to allow the anonymous bind.",
            "# After the connection is made, the pgadmin login user will be further",
            "# authenticated by the username and password provided",
            "",
            "LDAP_ANONYMOUS_BIND = False",
            "",
            "# OR ####################",
            "# 3. Bind as pgAdmin user",
            "",
            "# BaseDN (REQUIRED)",
            "# AD example:",
            "# (&(objectClass=user)(memberof=CN=MYGROUP,CN=Users,dc=example,dc=com))",
            "# OpenLDAP example: CN=Users,dc=example,dc=com",
            "LDAP_BASE_DN = '<Base-DN>'",
            "",
            "# Configure the bind format string",
            "# Default: LDAP_BIND_FORMAT=\"",
            "#   {LDAP_USERNAME_ATTRIBUTE}={LDAP_USERNAME},{LDAP_BASE_DN}\"",
            "# The current available options are:",
            "# LDAP_USERNAME_ATTRIBUTE, LDAP_USERNAME, LDAP_BASE_DN",
            "# Example: LDAP_BIND_FORMAT=\"myldapuser@sales.example.com\"",
            "#          LDAP_BIND_FORMAT=\"NET\\\\myldapuser\"",
            "LDAP_BIND_FORMAT = '{LDAP_USERNAME_ATTRIBUTE}={LDAP_USERNAME},{LDAP_BASE_DN}'",
            "",
            "##########################################################################",
            "",
            "# Search ldap for further authentication (REQUIRED)",
            "# It can be optional while bind as pgAdmin user",
            "LDAP_SEARCH_BASE_DN = '<Search-Base-DN>'",
            "",
            "# The LDAP attribute indicates whether the DN (Distinguished Names)",
            "# are case sensitive or not",
            "LDAP_DN_CASE_SENSITIVE = False",
            "",
            "# Filter string for the user search.",
            "# For OpenLDAP, '(cn=*)' may well be enough.",
            "# For AD, you might use '(objectClass=user)' (REQUIRED)",
            "LDAP_SEARCH_FILTER = '(objectclass=*)'",
            "",
            "# Search scope for users (one of BASE, LEVEL or SUBTREE)",
            "LDAP_SEARCH_SCOPE = 'SUBTREE'",
            "",
            "# Use TLS? If the URI scheme is ldaps://, this is ignored.",
            "LDAP_USE_STARTTLS = False",
            "",
            "# TLS/SSL certificates. Specify if required, otherwise leave empty",
            "LDAP_CA_CERT_FILE = ''",
            "LDAP_CERT_FILE = ''",
            "LDAP_KEY_FILE = ''",
            "",
            "##########################################################################",
            "",
            "# Some flaky LDAP servers returns malformed schema. If True, no exception",
            "# will be raised and schema is thrown away but authentication will be done.",
            "# This parameter should remain False, as recommended.",
            "LDAP_IGNORE_MALFORMED_SCHEMA = False",
            "",
            "##########################################################################",
            "# Kerberos Configuration",
            "##########################################################################",
            "",
            "KRB_APP_HOST_NAME = DEFAULT_SERVER",
            "",
            "# If the default_keytab_name is not set in krb5.conf or",
            "# the KRB_KTNAME environment variable is not set then, explicitly set",
            "# the Keytab file",
            "",
            "KRB_KTNAME = '<KRB5_KEYTAB_FILE>'",
            "",
            "# After kerberos authentication, user will be added into the SQLite database",
            "# automatically, if set to True.",
            "# Set it to False, if user should not be added automatically,",
            "# in this case Admin has to add the user manually in the SQLite database.",
            "",
            "KRB_AUTO_CREATE_USER = True",
            "",
            "KERBEROS_CCACHE_DIR = os.path.join(DATA_DIR, 'krbccache')",
            "",
            "#############################################################################",
            "# Create local directory to store azure credential cache",
            "#############################################################################",
            "",
            "AZURE_CREDENTIAL_CACHE_DIR = os.path.join(DATA_DIR, 'azurecredentialcache')",
            "",
            "##########################################################################",
            "# OAuth2 Configuration",
            "##########################################################################",
            "",
            "# Multiple OAUTH2 providers can be added in the list like [{...},{...}]",
            "# All parameters are required",
            "",
            "OAUTH2_CONFIG = [",
            "    {",
            "        # The name of the of the oauth provider, ex: github, google",
            "        'OAUTH2_NAME': None,",
            "        # The display name, ex: Google",
            "        'OAUTH2_DISPLAY_NAME': '<Oauth2 Display Name>',",
            "        # Oauth client id",
            "        'OAUTH2_CLIENT_ID': None,",
            "        # Oauth secret",
            "        'OAUTH2_CLIENT_SECRET': None,",
            "        # URL to generate a token,",
            "        # Ex: https://github.com/login/oauth/access_token",
            "        'OAUTH2_TOKEN_URL': None,",
            "        # URL is used for authentication,",
            "        # Ex: https://github.com/login/oauth/authorize",
            "        'OAUTH2_AUTHORIZATION_URL': None,",
            "        # server metadata url might optional for your provider",
            "        'OAUTH2_SERVER_METADATA_URL': None,",
            "        # Oauth base url, ex: https://api.github.com/",
            "        'OAUTH2_API_BASE_URL': None,",
            "        # Name of the Endpoint, ex: user",
            "        'OAUTH2_USERINFO_ENDPOINT': None,",
            "        # Oauth scope, ex: 'openid email profile'",
            "        # Note that an 'email' claim is required in the resulting profile",
            "        'OAUTH2_SCOPE': None,",
            "        # The claim which is used for the username. If the value is empty the",
            "        # email is used as username, but if a value is provided,",
            "        # the claim has to exist.",
            "        'OAUTH2_USERNAME_CLAIM': None,",
            "        # Font-awesome icon, ex: fa-github",
            "        'OAUTH2_ICON': None,",
            "        # UI button colour, ex: #0000ff",
            "        'OAUTH2_BUTTON_COLOR': None,",
            "        # The additional claims to check on user ID Token or Userinfo response.",
            "        # This is useful to provide additional authorization checks",
            "        # before allowing access.",
            "        # Example for GitLab: allowing all maintainers teams, and a specific",
            "        # developers group to access pgadmin:",
            "        # 'OAUTH2_ADDITIONAL_CLAIMS': {",
            "        #     'https://gitlab.org/claims/groups/maintainer': [",
            "        #           'kuberheads/applications',",
            "        #           'kuberheads/dba',",
            "        #           'kuberheads/support'",
            "        #      ],",
            "        #     'https://gitlab.org/claims/groups/developer': [",
            "        #           'kuberheads/applications/team01'",
            "        #      ],",
            "        # }",
            "        # Example for AzureAD:",
            "        # 'OAUTH2_ADDITIONAL_CLAIMS': {",
            "        #     'groups': [\"0760b6cf-170e-4a14-91b3-4b78e0739963\"],",
            "        #     'wids': [\"cf1c38e5-3621-4004-a7cb-879624dced7c\"],",
            "        # }",
            "        'OAUTH2_ADDITIONAL_CLAIMS': None,",
            "        # Set this variable to False to disable SSL certificate verification",
            "        # for OAuth2 provider.",
            "        # This may need to set False, in case of self-signed certificates.",
            "        # Ref: https://github.com/psf/requests/issues/6071",
            "        'OAUTH2_SSL_CERT_VERIFICATION': True,",
            "        # set this variable to invalidate the session of the oauth2 provider",
            "        # Example for keycloak:",
            "        # 'OAUTH2_LOGOUT_URL':",
            "        # 'https://example.com/realms/master/protocol/openid-connect/logout?post_logout_redirect_uri={redirect_uri}&id_token_hint={id_token}'",
            "        'OAUTH2_LOGOUT_URL': None",
            "    }",
            "]",
            "",
            "# After Oauth authentication, user will be added into the SQLite database",
            "# automatically, if set to True.",
            "# Set it to False, if user should not be added automatically,",
            "# in this case Admin has to add the user manually in the SQLite database.",
            "",
            "OAUTH2_AUTO_CREATE_USER = True",
            "",
            "##########################################################################",
            "# Webserver Configuration",
            "##########################################################################",
            "",
            "WEBSERVER_AUTO_CREATE_USER = True",
            "",
            "# REMOTE_USER variable will be used to check the environment variable",
            "# is set or not first, if not available,",
            "# request header will be checked for the same.",
            "# Possible values: REMOTE_USER, HTTP_X_FORWARDED_USER, X-Forwarded-User",
            "",
            "WEBSERVER_REMOTE_USER = 'REMOTE_USER'",
            "",
            "##########################################################################",
            "# Two-factor Authentication Configuration",
            "##########################################################################",
            "",
            "# Set it to True, to enable the two-factor authentication",
            "MFA_ENABLED = True",
            "",
            "# Set it to True, to ask the users to register forcefully for the",
            "# two-authentication methods on logged-in.",
            "MFA_FORCE_REGISTRATION = False",
            "",
            "# pgAdmin supports Two-factor authentication by either sending an one-time code",
            "# to an email, or using the TOTP based application like Google Authenticator.",
            "MFA_SUPPORTED_METHODS = [\"email\", \"authenticator\"]",
            "",
            "# NOTE: Please set the 'Mail server settings' to use 'email' as two-factor",
            "#       authentication method.",
            "",
            "# Subject for the email verification code",
            "# Default: <APP_NAME> - Verification Code",
            "# e.g.  pgAdmin 4 - Verification Code",
            "MFA_EMAIL_SUBJECT = None",
            "",
            "##########################################################################",
            "# PSQL tool settings",
            "##########################################################################",
            "# This will enable PSQL tool in pgAdmin when running in server mode.",
            "# PSQL is always enabled in Desktop mode, however in server mode it is",
            "# disabled by default because users can run arbitrary commands on the",
            "# server through it.",
            "ENABLE_PSQL = False",
            "",
            "##########################################################################",
            "# ENABLE_BINARY_PATH_BROWSING setting is used to enable the browse button",
            "# while selecting binary path for the database server in server mode.",
            "# In Desktop mode it is always enabled and setting is of no use.",
            "##########################################################################",
            "ENABLE_BINARY_PATH_BROWSING = False",
            "",
            "##########################################################################",
            "# In server mode, the SHARED_STORAGE setting is used to enable shared storage.",
            "# Specify the name, path, and restricted_access values that should be shared",
            "# between users. When restricted_access is set to True, non-admin users cannot",
            "# upload/add, delete, or rename files/folders in shared storage, only admins",
            "# can do that. Users must provide the absolute path to the folder, and the name",
            "# can be anything they see on the user interface.",
            "# [{ 'name': 'Shared 1', 'path': '/shared_folder',",
            "#   'restricted_access': True/False}]",
            "##########################################################################",
            "SHARED_STORAGE = []",
            "",
            "#############################################################################",
            "# AUTO_DISCOVER_SERVERS setting is used to enable the pgAdmin to discover the",
            "# database server automatically on the local machine.",
            "# When it is set to False, pgAdmin will not discover servers installed on",
            "# the local machine.",
            "#############################################################################",
            "AUTO_DISCOVER_SERVERS = True",
            "",
            "#############################################################################",
            "# SERVER_HEARTBEAT_TIMEOUT is used to send the server heartbeat to server",
            "# from the client. This will resolve the orphan database issue once",
            "# browser tab is closed.",
            "#############################################################################",
            "SERVER_HEARTBEAT_TIMEOUT = 30  # In seconds",
            "",
            "#############################################################################",
            "# ENABLE_SERVER_PASS_EXEC_CMD is used to enable/disable Password exec command",
            "# field in server properties. This is used to specify a shell command to be",
            "# executed to retrieve a password to be used for server authentication.",
            "# This setting is applicable only for server mode.",
            "#############################################################################",
            "ENABLE_SERVER_PASS_EXEC_CMD = False",
            "",
            "#############################################################################",
            "# Patch the default config with custom config and other manipulations",
            "#############################################################################",
            "from pgadmin.evaluate_config import evaluate_and_patch_config",
            "locals().update(evaluate_and_patch_config(locals()))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "# config.py - Core application configuration settings",
            "#",
            "##########################################################################",
            "",
            "import builtins",
            "import logging",
            "import os",
            "import sys",
            "from collections import OrderedDict",
            "",
            "# We need to include the root directory in sys.path to ensure that we can",
            "# find everything we need when running in the standalone runtime.",
            "root = os.path.dirname(os.path.realpath(__file__))",
            "if sys.path[0] != root:",
            "    sys.path.insert(0, root)",
            "",
            "# The config database connection pool size.",
            "# Setting this to 0 will remove any limit.",
            "CONFIG_DATABASE_CONNECTION_POOL_SIZE = 5",
            "# The number of connections allowed to overflow beyond",
            "# the connection pool size.",
            "CONFIG_DATABASE_CONNECTION_MAX_OVERFLOW = 100",
            "",
            "from pgadmin.utils import env, IS_WIN, fs_short_path",
            "from version import APP_VERSION, APP_RELEASE, APP_REVISION, APP_SUFFIX, \\",
            "    APP_VERSION_INT",
            "from branding import APP_NAME, APP_ICON, APP_COPYRIGHT, APP_PATH, \\",
            "    APP_WIN_PATH, APP_SHORT_NAME, APP_DEFAULT_EMAIL",
            "",
            "##########################################################################",
            "# Misc stuff",
            "##########################################################################",
            "",
            "# Path to the online help.",
            "HELP_PATH = '../../../docs/en_US/_build/html/'",
            "",
            "# Languages we support in the UI",
            "LANGUAGES = {",
            "    'en': 'English',",
            "    'zh': 'Chinese (Simplified)',",
            "    'cs': 'Czech',",
            "    'fr': 'French',",
            "    'de': 'German',",
            "    'id': 'Indonesian',",
            "    'it': 'Italian',",
            "    'ja': 'Japanese',",
            "    'ko': 'Korean',",
            "    'pl': 'Polish',",
            "    'pt_BR': 'Portuguese (Brazilian)',",
            "    'ru': 'Russian',",
            "    'es': 'Spanish',",
            "}",
            "",
            "# DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING!",
            "# List of modules to skip when dynamically loading",
            "MODULE_BLACKLIST = ['test']",
            "",
            "# DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING!",
            "# List of treeview browser nodes to skip when dynamically loading",
            "NODE_BLACKLIST = []",
            "",
            "##########################################################################",
            "# Server settings",
            "##########################################################################",
            "",
            "# The server mode determines whether or not we're running on a web server",
            "# requiring user authentication, or desktop mode which uses an automatic",
            "# default login.",
            "#",
            "# DO NOT DISABLE SERVER MODE IF RUNNING ON A WEBSERVER!!",
            "#",
            "# We only set SERVER_MODE if it's not already set. That's to allow the",
            "# runtime to force it to False.",
            "#",
            "# NOTE: If you change the value of SERVER_MODE or DATA_DIR in an included",
            "#       config file, you may also need to redefine any values below that are",
            "#       derived from it, notably various paths such as LOG_FILE, SQLITE_PATH,",
            "#       SESSION_DB_PATH, STORAGE_DIR, KERBEROS_CCACHE_DIR, and",
            "#       AZURE_CREDENTIAL_CACHE_DIR",
            "",
            "if (not hasattr(builtins, 'SERVER_MODE')) or builtins.SERVER_MODE is None:",
            "    SERVER_MODE = True",
            "else:",
            "    SERVER_MODE = builtins.SERVER_MODE",
            "",
            "# HTTP headers to search for CSRF token when it is not provided in the form.",
            "# Default is ['X-CSRFToken', 'X-CSRF-Token']",
            "WTF_CSRF_HEADERS = ['X-pgA-CSRFToken']",
            "",
            "# User ID (email address) to use for the default user in desktop mode.",
            "# The default should be fine here, as it's not exposed in the app.",
            "DESKTOP_USER = APP_DEFAULT_EMAIL",
            "",
            "# This option allows the user to host the application on a LAN",
            "# Default hosting is on localhost (DEFAULT_SERVER='localhost').",
            "# To host pgAdmin4 over LAN set DEFAULT_SERVER='0.0.0.0' (or a specific",
            "# adaptor address.",
            "#",
            "# NOTE: This is NOT recommended for production use, only for debugging",
            "# or testing. Production installations should be run as a WSGI application",
            "# behind Apache HTTPD.",
            "DEFAULT_SERVER = '127.0.0.1'",
            "",
            "# The default port on which the app server will listen if not set in the",
            "# environment by the runtime",
            "DEFAULT_SERVER_PORT = 5050",
            "",
            "# This param is used to override the default web server information about",
            "# the web technology and the frameworks being used in the application",
            "# An attacker could use this information to fingerprint underlying operating",
            "# system and research known exploits for the specific version of",
            "# software in use",
            "WEB_SERVER = 'Python'",
            "",
            "# Enable X-Frame-Option protection.",
            "# Set to one of \"SAMEORIGIN\", \"ALLOW-FROM origin\" or \"\" to disable.",
            "# Note that \"DENY\" is NOT supported (and will be silently ignored).",
            "# See https://tools.ietf.org/html/rfc7034 for more info.",
            "X_FRAME_OPTIONS = \"SAMEORIGIN\"",
            "",
            "# The Content-Security-Policy header allows you to restrict how resources",
            "# such as JavaScript, CSS, or pretty much anything that the browser loads.",
            "# see https://content-security-policy.com/#source_list for more info",
            "# e.g. \"default-src https: data: 'unsafe-inline' 'unsafe-eval';\"",
            "CONTENT_SECURITY_POLICY = \"default-src ws: http: data: blob: 'unsafe-inline'\" \\",
            "                          \" 'unsafe-eval';\"",
            "",
            "# STRICT_TRANSPORT_SECURITY_ENABLED when set to True will set the",
            "# Strict-Transport-Security header",
            "STRICT_TRANSPORT_SECURITY_ENABLED = False",
            "",
            "# The Strict-Transport-Security header tells the browser to convert all HTTP",
            "# requests to HTTPS, preventing man-in-the-middle (MITM) attacks.",
            "# e.g. 'max-age=31536000; includeSubDomains'",
            "STRICT_TRANSPORT_SECURITY = \"max-age=31536000; includeSubDomains\"",
            "",
            "# The X-Content-Type-Options header forces the browser to honor the response",
            "# content type instead of trying to detect it, which can be abused to",
            "# generate a cross-site scripting (XSS) attack.",
            "# e.g. nosniff",
            "X_CONTENT_TYPE_OPTIONS = \"nosniff\"",
            "",
            "# The browser will try to prevent reflected XSS attacks by not loading the",
            "# page if the request contains something that looks like JavaScript and the",
            "# response contains the same data. e.g. '1; mode=block'",
            "X_XSS_PROTECTION = \"1; mode=block\"",
            "",
            "# This param is used to validate ALLOWED_HOSTS for the application",
            "# This will be used to avoid Host Header Injection attack",
            "# ALLOWED_HOSTS = ['225.0.0.0/8', '226.0.0.0/7', '228.0.0.0/6']",
            "# ALLOWED_HOSTS = ['127.0.0.1', '192.168.0.1']",
            "# if ALLOWED_HOSTS= [] then it will accept all ips (and application will be",
            "# vulnerable to Host Header Injection attack)",
            "ALLOWED_HOSTS = []",
            "",
            "# Hashing algorithm used for password storage",
            "SECURITY_PASSWORD_HASH = 'pbkdf2_sha512'",
            "",
            "# Minimum password length",
            "PASSWORD_LENGTH_MIN = 6",
            "",
            "# Reverse Proxy parameters",
            "# You must tell the middleware how many proxies set each header",
            "# so it knows what values to trust.",
            "# See https://tinyurl.com/yyg7r9av",
            "# for more information.",
            "",
            "# Number of values to trust for X-Forwarded-For",
            "PROXY_X_FOR_COUNT = 1",
            "",
            "# Number of values to trust for X-Forwarded-Proto.",
            "PROXY_X_PROTO_COUNT = 1",
            "",
            "# Number of values to trust for X-Forwarded-Host.",
            "PROXY_X_HOST_COUNT = 0",
            "",
            "# Number of values to trust for X-Forwarded-Port.",
            "PROXY_X_PORT_COUNT = 1",
            "",
            "# Number of values to trust for X-Forwarded-Prefix.",
            "PROXY_X_PREFIX_COUNT = 0",
            "",
            "# NOTE: CSRF_SESSION_KEY, SECRET_KEY and SECURITY_PASSWORD_SALT are no",
            "#       longer part of the main configuration, but are stored in the",
            "#       configuration databases 'keys' table and are auto-generated.",
            "",
            "# COMPRESSION",
            "COMPRESS_MIMETYPES = [",
            "    'text/html', 'text/css', 'text/xml', 'text/javascript',",
            "    'application/json', 'application/javascript'",
            "]",
            "COMPRESS_LEVEL = 9",
            "COMPRESS_MIN_SIZE = 500",
            "",
            "# Set the cache control max age for static files in flask to 1 year",
            "SEND_FILE_MAX_AGE_DEFAULT = 31556952",
            "",
            "# This will be added to static urls as url parameter with value as",
            "# APP_VERSION_INT for cache busting on version upgrade. If the value is set as",
            "# None or empty string then it will not be added.",
            "# eg - http:localhost:5050/pgadmin.css?intver=3.13",
            "APP_VERSION_PARAM = 'ver'",
            "",
            "# Add the internal version param to below extensions only",
            "APP_VERSION_EXTN = ('.css', '.js', '.html', '.svg', '.png', '.gif', '.ico')",
            "",
            "# Data directory for storage of config settings etc. This shouldn't normally",
            "# need to be changed - it's here as various other settings depend on it.",
            "# On Windows, we always store data in %APPDATA%\\$(APP_WIN_PATH). On other",
            "# platforms, if we're in server mode we use /var/lib/$(APP_PATH),",
            "# otherwise ~/.$(APP_PATH)",
            "if IS_WIN:",
            "    # Use the short path on windows",
            "    DATA_DIR = os.path.realpath(",
            "        os.path.join(fs_short_path(env('APPDATA')), APP_WIN_PATH)",
            "    )",
            "else:",
            "    if SERVER_MODE:",
            "        DATA_DIR = os.path.join('/var/lib/', APP_PATH)",
            "    else:",
            "        DATA_DIR = os.path.realpath(",
            "            os.path.expanduser('~/' + '.' + APP_PATH + '/')",
            "        )",
            "",
            "# An optional login banner to show security warnings/disclaimers etc. at",
            "# login and password recovery etc. HTML may be included for basic formatting,",
            "# For example:",
            "# LOGIN_BANNER = \"<h4>Authorised Users Only!</h4>\" \\",
            "#                \"Unauthorised use is strictly forbidden.\"",
            "LOGIN_BANNER = \"\"",
            "",
            "##########################################################################",
            "# Log settings",
            "##########################################################################",
            "",
            "# Debug mode?",
            "DEBUG = False",
            "",
            "# Application log level - one of:",
            "#   CRITICAL 50",
            "#   ERROR    40",
            "#   WARNING  30",
            "#   SQL      25",
            "#   INFO     20",
            "#   DEBUG    10",
            "#   NOTSET    0",
            "CONSOLE_LOG_LEVEL = logging.WARNING",
            "FILE_LOG_LEVEL = logging.WARNING",
            "",
            "# Log format.",
            "JSON_LOGGER = False",
            "CONSOLE_LOG_FORMAT_JSON = OrderedDict([",
            "    (\"time\", \"asctime\"),",
            "    (\"message\", \"message\"),",
            "    (\"level\", \"levelname\")",
            "])",
            "",
            "FILE_LOG_FORMAT_JSON = OrderedDict([",
            "    (\"time\", \"asctime\"),",
            "    (\"message\", \"message\"),",
            "    (\"level\", \"levelname\")",
            "])",
            "",
            "",
            "CONSOLE_LOG_FORMAT = '%(asctime)s: %(levelname)s\\t%(name)s:\\t%(message)s'",
            "FILE_LOG_FORMAT = '%(asctime)s: %(levelname)s\\t%(name)s:\\t%(message)s'",
            "",
            "# Log file name. This goes in the data directory, except on non-Windows",
            "# platforms in server mode.",
            "if SERVER_MODE and not IS_WIN:",
            "    LOG_FILE = os.path.join('/var/log', APP_PATH, APP_SHORT_NAME + '.log')",
            "else:",
            "    LOG_FILE = os.path.join(DATA_DIR, APP_SHORT_NAME + '.log')",
            "",
            "# Log rotation setting",
            "# Log file will be rotated considering values for LOG_ROTATION_SIZE",
            "# & LOG_ROTATION_AGE. Rotated file will be named in format",
            "# - LOG_FILE.Y-m-d_H-M-S",
            "LOG_ROTATION_SIZE = 10  # In MBs",
            "LOG_ROTATION_AGE = 1440  # In minutes",
            "LOG_ROTATION_MAX_LOG_FILES = 90  # Maximum number of backups to retain",
            "##########################################################################",
            "# Server Connection Driver Settings",
            "##########################################################################",
            "",
            "# The default driver used for making connection with PostgreSQL",
            "PG_DEFAULT_DRIVER = 'psycopg3'",
            "",
            "# Maximum allowed idle time in minutes before which releasing the connection",
            "# for the particular session. (in minutes)",
            "MAX_SESSION_IDLE_TIME = 60",
            "",
            "##########################################################################",
            "# External Database Settings",
            "#",
            "# All configuration settings are stored by default in the SQLite database.",
            "# In order to use external databases like PostgreSQL sets the value of",
            "# CONFIG_DATABASE_URI like below:",
            "# dialect+driver://username:password@host:port/database",
            "#",
            "# PostgreSQL:",
            "# postgresql://username:password@host:port/database",
            "# Specify Schema Name",
            "# postgresql://username:password@host:port/database?options=-csearch_path=pgadmin",
            "# Using PGPASS file",
            "# postgresql://username@host:port?options=-csearch_path=pgadmin",
            "##########################################################################",
            "CONFIG_DATABASE_URI = ''",
            "",
            "##########################################################################",
            "# User account and settings storage",
            "##########################################################################",
            "",
            "# The default path to the SQLite database used to store user accounts and",
            "# settings. This default places the file in the same directory as this",
            "# config file, but generates an absolute path for use througout the app.",
            "SQLITE_PATH = env('SQLITE_PATH') or \\",
            "    os.path.join(DATA_DIR, APP_SHORT_NAME + '.db')",
            "",
            "# SQLITE_TIMEOUT will define how long to wait before throwing the error -",
            "# OperationError due to database lock. On slower system, you may need to change",
            "# this to some higher value.",
            "# (Default: 500 milliseconds)",
            "SQLITE_TIMEOUT = 500",
            "",
            "# Allow database connection passwords to be saved if the user chooses.",
            "# Set to False to disable password saving.",
            "ALLOW_SAVE_PASSWORD = True",
            "",
            "# Maximum number of history queries stored per user/server/database",
            "MAX_QUERY_HIST_STORED = 20",
            "",
            "##########################################################################",
            "# Server-side session storage path",
            "#",
            "# SESSION_DB_PATH (Default: $HOME/.pgadmin4/sessions)",
            "##########################################################################",
            "#",
            "# We use SQLite for server-side session storage. There will be one",
            "# SQLite database object per session created.",
            "#",
            "# Specify the path used to store your session objects.",
            "#",
            "# If the specified directory does not exist, the setup script will create",
            "# it with permission mode 700 to keep the session database secure.",
            "#",
            "# On certain systems, you can use shared memory (tmpfs) for maximum",
            "# scalability, for example, on Ubuntu:",
            "#",
            "# SESSION_DB_PATH = '/run/shm/pgAdmin4_session'",
            "#",
            "##########################################################################",
            "SESSION_DB_PATH = os.path.join(DATA_DIR, 'sessions')",
            "",
            "SESSION_COOKIE_NAME = 'pga4_session'",
            "",
            "##########################################################################",
            "# Mail server settings",
            "##########################################################################",
            "",
            "# These settings are used when running in web server mode for confirming",
            "# and resetting passwords etc.",
            "# See: http://pythonhosted.org/Flask-Mail/ for more info",
            "MAIL_SERVER = 'localhost'",
            "MAIL_PORT = 25",
            "MAIL_USE_SSL = False",
            "MAIL_USE_TLS = False",
            "MAIL_USERNAME = ''",
            "MAIL_PASSWORD = ''",
            "MAIL_DEBUG = False",
            "",
            "# Flask-Security overrides Flask-Mail's MAIL_DEFAULT_SENDER setting, so",
            "# that should be set as such:",
            "SECURITY_EMAIL_SENDER = 'no-reply@localhost'",
            "",
            "##########################################################################",
            "# Mail content settings",
            "##########################################################################",
            "",
            "# These settings define the content of password reset emails",
            "SECURITY_EMAIL_SUBJECT_PASSWORD_RESET = \"Password reset instructions for %s\" \\",
            "                                        % APP_NAME",
            "SECURITY_EMAIL_SUBJECT_PASSWORD_NOTICE = \"Your %s password has been reset\" \\",
            "                                         % APP_NAME",
            "SECURITY_EMAIL_SUBJECT_PASSWORD_CHANGE_NOTICE = \\",
            "    \"Your password for %s has been changed\" % APP_NAME",
            "",
            "##########################################################################",
            "# Email address validation",
            "##########################################################################",
            "CHECK_EMAIL_DELIVERABILITY = False",
            "SECURITY_EMAIL_VALIDATOR_ARGS = \\",
            "    {\"check_deliverability\": CHECK_EMAIL_DELIVERABILITY}",
            "",
            "##########################################################################",
            "# Upgrade checks",
            "##########################################################################",
            "",
            "# Check for new versions of the application?",
            "UPGRADE_CHECK_ENABLED = True",
            "",
            "# Where should we get the data from?",
            "UPGRADE_CHECK_URL = 'https://www.pgadmin.org/versions.json'",
            "",
            "# What key should we look at in the upgrade data file?",
            "UPGRADE_CHECK_KEY = 'pgadmin4'",
            "",
            "# Which CA file should we use?",
            "# Default to cacert.pem in the same directory as config.py et al.",
            "CA_FILE = os.path.join(os.path.dirname(os.path.realpath(__file__)),",
            "                       \"cacert.pem\")",
            "",
            "# Check if the detected browser is supported",
            "CHECK_SUPPORTED_BROWSER = True",
            "",
            "##########################################################################",
            "# Storage Manager storage url config settings",
            "# If user sets STORAGE_DIR to empty it will show all volumes if platform",
            "# is Windows, '/' if it is Linux, Mac or any other unix type system.",
            "",
            "# For example:",
            "# 1. STORAGE_DIR = get_drive(\"C\") or get_drive() # return C:/ by default",
            "# where C can be any drive character such as \"D\", \"E\", \"G\" etc",
            "# 2. Set path manually like",
            "# STORAGE_DIR = \"/path/to/directory/\"",
            "##########################################################################",
            "STORAGE_DIR = os.path.join(DATA_DIR, 'storage')",
            "",
            "##########################################################################",
            "# Default locations for binary utilities (pg_dump, pg_restore etc)",
            "#",
            "# These are intentionally left empty in the main config file, but are",
            "# expected to be overridden by packagers in config_distro.py.",
            "#",
            "# A default location can be specified for each database driver ID, in",
            "# a dictionary. Either an absolute or relative path can be specified.",
            "#",
            "# Version-specific defaults can also be specified, which will take priority",
            "# over un-versioned paths.",
            "#",
            "# In cases where it may be difficult to know what the working directory",
            "# is, \"$DIR\" can be specified. This will be replaced with the path to the",
            "# top-level pgAdmin4.py file. For example, on macOS we might use:",
            "#",
            "# $DIR/../../SharedSupport",
            "#",
            "##########################################################################",
            "DEFAULT_BINARY_PATHS = {",
            "    \"pg\": \"\",",
            "    \"pg-12\": \"\",",
            "    \"pg-13\": \"\",",
            "    \"pg-14\": \"\",",
            "    \"pg-15\": \"\",",
            "    \"pg-16\": \"\",",
            "    \"ppas\": \"\",",
            "    \"ppas-12\": \"\",",
            "    \"ppas-13\": \"\",",
            "    \"ppas-14\": \"\",",
            "    \"ppas-15\": \"\",",
            "    \"ppas-16\": \"\"",
            "}",
            "",
            "##########################################################################",
            "",
            "# Admin can specify fixed binary paths to prevent users from changing.",
            "# It will take precedence over DEFAULT_BINARY_PATHS.",
            "",
            "FIXED_BINARY_PATHS = {",
            "    \"pg\": \"\",",
            "    \"pg-12\": \"\",",
            "    \"pg-13\": \"\",",
            "    \"pg-14\": \"\",",
            "    \"pg-15\": \"\",",
            "    \"pg-16\": \"\",",
            "    \"ppas\": \"\",",
            "    \"ppas-12\": \"\",",
            "    \"ppas-13\": \"\",",
            "    \"ppas-14\": \"\",",
            "    \"ppas-15\": \"\",",
            "    \"ppas-16\": \"\"",
            "}",
            "",
            "##########################################################################",
            "# Test settings - used primarily by the regression suite, not for users",
            "##########################################################################",
            "",
            "# The default path for SQLite database for testing",
            "TEST_SQLITE_PATH = os.path.join(DATA_DIR, 'test_pgadmin4.db')",
            "",
            "##########################################################################",
            "# Allows flask application to response to the each request asynchronously",
            "##########################################################################",
            "THREADED_MODE = True",
            "",
            "##########################################################################",
            "# Do not allow SQLALCHEMY to track modification as it is going to be",
            "# deprecated in future",
            "##########################################################################",
            "SQLALCHEMY_TRACK_MODIFICATIONS = False",
            "",
            "##########################################################################",
            "# Number of records to fetch in one batch in query tool when query result",
            "# set is large.",
            "##########################################################################",
            "ON_DEMAND_RECORD_COUNT = 1000",
            "",
            "##########################################################################",
            "# Allow users to display Gravatar image for their username in Server mode",
            "##########################################################################",
            "SHOW_GRAVATAR_IMAGE = True",
            "",
            "##########################################################################",
            "# Set cookie path and options",
            "##########################################################################",
            "COOKIE_DEFAULT_PATH = '/'",
            "COOKIE_DEFAULT_DOMAIN = None",
            "SESSION_COOKIE_DOMAIN = None",
            "SESSION_COOKIE_SAMESITE = 'Lax'",
            "SESSION_COOKIE_SECURE = False",
            "SESSION_COOKIE_HTTPONLY = True",
            "",
            "#########################################################################",
            "# Skip storing session in files and cache for specific paths",
            "#########################################################################",
            "SESSION_SKIP_PATHS = [",
            "    '/misc/ping'",
            "]",
            "",
            "##########################################################################",
            "# Session expiration support",
            "##########################################################################",
            "# SESSION_EXPIRATION_TIME is the interval in Days. Session will be",
            "# expire after the specified number of *days*.",
            "SESSION_EXPIRATION_TIME = 1",
            "",
            "# Make SESSION_EXPIRATION_TIME to 1 week in DESKTOP mode",
            "if not SERVER_MODE:",
            "    SESSION_EXPIRATION_TIME = 7",
            "",
            "# CHECK_SESSION_FILES_INTERVAL is interval in Hours. Application will check",
            "# the session files for cleanup after specified number of *hours*.",
            "CHECK_SESSION_FILES_INTERVAL = 24",
            "",
            "# USER_INACTIVITY_TIMEOUT is interval in Seconds. If the pgAdmin screen is left",
            "# unattended for <USER_INACTIVITY_TIMEOUT> seconds then the user will",
            "# be logged out. When set to 0, the timeout will be disabled.",
            "# If pgAdmin doesn't detect any activity in the time specified (in seconds),",
            "# the user will be forcibly logged out from pgAdmin. Set to zero to disable",
            "# the timeout.",
            "# Note: This is applicable only for SERVER_MODE=True.",
            "USER_INACTIVITY_TIMEOUT = 0",
            "",
            "# OVERRIDE_USER_INACTIVITY_TIMEOUT when set to True will override",
            "# USER_INACTIVITY_TIMEOUT when long running queries in the Query Tool",
            "# or Debugger are running. When the queries complete, the inactivity timer",
            "# will restart in this case. If set to False, user inactivity may cause",
            "# transactions or in-process debugging sessions to be aborted.",
            "OVERRIDE_USER_INACTIVITY_TIMEOUT = True",
            "",
            "##########################################################################",
            "# SSH Tunneling supports only for Python 2.7 and 3.4+",
            "##########################################################################",
            "SUPPORT_SSH_TUNNEL = True",
            "# Allow SSH Tunnel passwords to be saved if the user chooses.",
            "# Set to False to disable password saving.",
            "ALLOW_SAVE_TUNNEL_PASSWORD = False",
            "",
            "##########################################################################",
            "# Master password is used to encrypt/decrypt saved server passwords",
            "# Applicable for desktop mode only",
            "##########################################################################",
            "MASTER_PASSWORD_REQUIRED = True",
            "",
            "##########################################################################",
            "",
            "# pgAdmin encrypts the database connection and ssh tunnel password using a",
            "# master password or pgAdmin login password (for other authentication sources)",
            "# before storing it in the pgAdmin configuration database.",
            "#",
            "# Below setting is used to allow the user to specify the path to a script",
            "# or program that will return an encryption key which will be used to",
            "# encrypt the passwords. This setting is used only in server mode when",
            "# auth sources are oauth, Kerberos, and webserver.",
            "#",
            "# You can pass the current username as an argument to the external script",
            "# by specifying %u in config value.",
            "# E.g. - MASTER_PASSWORD_HOOK = '<PATH>/passwdgen_script.sh %u'",
            "##########################################################################",
            "MASTER_PASSWORD_HOOK = None",
            "",
            "##########################################################################",
            "",
            "# Allows pgAdmin4 to create session cookies based on IP address, so even",
            "# if a cookie is stolen, the attacker will not be able to connect to the",
            "# server using that stolen cookie.",
            "# Note: This can cause problems when the server is deployed in dynamic IP",
            "# address hosting environments, such as Kubernetes or behind load",
            "# balancers. In such cases, this option should be set to False.",
            "##########################################################################",
            "ENHANCED_COOKIE_PROTECTION = True",
            "",
            "##########################################################################",
            "# External Authentication Sources",
            "##########################################################################",
            "",
            "# Default setting is internal",
            "# External Supported Sources: ldap, kerberos, oauth2",
            "# Multiple authentication can be achieved by setting this parameter to",
            "# ['ldap', 'internal'] or ['oauth2', 'internal'] or",
            "# ['webserver', 'internal'] etc.",
            "# pgAdmin will authenticate the user with ldap/oauth2 whatever first in the",
            "# list, in case of failure the second authentication option will be considered.",
            "",
            "AUTHENTICATION_SOURCES = ['internal']",
            "",
            "##########################################################################",
            "# MAX_LOGIN_ATTEMPTS which sets the number of failed login attempts that",
            "# are allowed. If this value is exceeded the account is locked and can be",
            "# reset by an administrator. By setting the variable to the value zero",
            "# this feature is deactivated.",
            "##########################################################################",
            "MAX_LOGIN_ATTEMPTS = 3",
            "",
            "##########################################################################",
            "# Only consider password to check the failed login attempts, email is",
            "# excluded from this check",
            "LOGIN_ATTEMPT_FIELDS = ['password']",
            "##########################################################################",
            "# LDAP Configuration",
            "##########################################################################",
            "",
            "# After ldap authentication, user will be added into the SQLite database",
            "# automatically, if set to True.",
            "# Set it to False, if user should not be added automatically,",
            "# in this case Admin has to add the user manually in the SQLite database.",
            "LDAP_AUTO_CREATE_USER = True",
            "",
            "# Connection timeout",
            "LDAP_CONNECTION_TIMEOUT = 10",
            "",
            "# Server connection details (REQUIRED)",
            "# example: ldap://<ip-address>:<port> or ldap://<hostname>:<port>",
            "LDAP_SERVER_URI = 'ldap://<ip-address>:<port>'",
            "",
            "# The LDAP attribute containing user names. In OpenLDAP, this may be 'uid'",
            "# whilst in AD, 'sAMAccountName' might be appropriate. (REQUIRED)",
            "LDAP_USERNAME_ATTRIBUTE = '<User-id>'",
            "",
            "##########################################################################",
            "# 3 ways to configure LDAP as follows (Choose anyone):",
            "",
            "# 1. Dedicated User binding",
            "",
            "# LDAP Bind User DN Example: cn=username,dc=example,dc=com",
            "# Set this parameter to allow the connection to bind using a dedicated user.",
            "# After the connection is made, the pgadmin login user will be further",
            "# authenticated by the username and password provided",
            "# at the login screen.",
            "LDAP_BIND_USER = None",
            "",
            "# LDAP Bind User Password",
            "LDAP_BIND_PASSWORD = None",
            "",
            "# OR ####################",
            "# 2. Anonymous Binding",
            "",
            "# Set this parameter to allow the anonymous bind.",
            "# After the connection is made, the pgadmin login user will be further",
            "# authenticated by the username and password provided",
            "",
            "LDAP_ANONYMOUS_BIND = False",
            "",
            "# OR ####################",
            "# 3. Bind as pgAdmin user",
            "",
            "# BaseDN (REQUIRED)",
            "# AD example:",
            "# (&(objectClass=user)(memberof=CN=MYGROUP,CN=Users,dc=example,dc=com))",
            "# OpenLDAP example: CN=Users,dc=example,dc=com",
            "LDAP_BASE_DN = '<Base-DN>'",
            "",
            "# Configure the bind format string",
            "# Default: LDAP_BIND_FORMAT=\"",
            "#   {LDAP_USERNAME_ATTRIBUTE}={LDAP_USERNAME},{LDAP_BASE_DN}\"",
            "# The current available options are:",
            "# LDAP_USERNAME_ATTRIBUTE, LDAP_USERNAME, LDAP_BASE_DN",
            "# Example: LDAP_BIND_FORMAT=\"myldapuser@sales.example.com\"",
            "#          LDAP_BIND_FORMAT=\"NET\\\\myldapuser\"",
            "LDAP_BIND_FORMAT = '{LDAP_USERNAME_ATTRIBUTE}={LDAP_USERNAME},{LDAP_BASE_DN}'",
            "",
            "##########################################################################",
            "",
            "# Search ldap for further authentication (REQUIRED)",
            "# It can be optional while bind as pgAdmin user",
            "LDAP_SEARCH_BASE_DN = '<Search-Base-DN>'",
            "",
            "# The LDAP attribute indicates whether the DN (Distinguished Names)",
            "# are case sensitive or not",
            "LDAP_DN_CASE_SENSITIVE = False",
            "",
            "# Filter string for the user search.",
            "# For OpenLDAP, '(cn=*)' may well be enough.",
            "# For AD, you might use '(objectClass=user)' (REQUIRED)",
            "LDAP_SEARCH_FILTER = '(objectclass=*)'",
            "",
            "# Search scope for users (one of BASE, LEVEL or SUBTREE)",
            "LDAP_SEARCH_SCOPE = 'SUBTREE'",
            "",
            "# Use TLS? If the URI scheme is ldaps://, this is ignored.",
            "LDAP_USE_STARTTLS = False",
            "",
            "# TLS/SSL certificates. Specify if required, otherwise leave empty",
            "LDAP_CA_CERT_FILE = ''",
            "LDAP_CERT_FILE = ''",
            "LDAP_KEY_FILE = ''",
            "",
            "##########################################################################",
            "",
            "# Some flaky LDAP servers returns malformed schema. If True, no exception",
            "# will be raised and schema is thrown away but authentication will be done.",
            "# This parameter should remain False, as recommended.",
            "LDAP_IGNORE_MALFORMED_SCHEMA = False",
            "",
            "##########################################################################",
            "# Kerberos Configuration",
            "##########################################################################",
            "",
            "KRB_APP_HOST_NAME = DEFAULT_SERVER",
            "",
            "# If the default_keytab_name is not set in krb5.conf or",
            "# the KRB_KTNAME environment variable is not set then, explicitly set",
            "# the Keytab file",
            "",
            "KRB_KTNAME = '<KRB5_KEYTAB_FILE>'",
            "",
            "# After kerberos authentication, user will be added into the SQLite database",
            "# automatically, if set to True.",
            "# Set it to False, if user should not be added automatically,",
            "# in this case Admin has to add the user manually in the SQLite database.",
            "",
            "KRB_AUTO_CREATE_USER = True",
            "",
            "KERBEROS_CCACHE_DIR = os.path.join(DATA_DIR, 'krbccache')",
            "",
            "#############################################################################",
            "# Create local directory to store azure credential cache",
            "#############################################################################",
            "",
            "AZURE_CREDENTIAL_CACHE_DIR = os.path.join(DATA_DIR, 'azurecredentialcache')",
            "",
            "##########################################################################",
            "# OAuth2 Configuration",
            "##########################################################################",
            "",
            "# Multiple OAUTH2 providers can be added in the list like [{...},{...}]",
            "# All parameters are required",
            "",
            "OAUTH2_CONFIG = [",
            "    {",
            "        # The name of the of the oauth provider, ex: github, google",
            "        'OAUTH2_NAME': None,",
            "        # The display name, ex: Google",
            "        'OAUTH2_DISPLAY_NAME': '<Oauth2 Display Name>',",
            "        # Oauth client id",
            "        'OAUTH2_CLIENT_ID': None,",
            "        # Oauth secret",
            "        'OAUTH2_CLIENT_SECRET': None,",
            "        # URL to generate a token,",
            "        # Ex: https://github.com/login/oauth/access_token",
            "        'OAUTH2_TOKEN_URL': None,",
            "        # URL is used for authentication,",
            "        # Ex: https://github.com/login/oauth/authorize",
            "        'OAUTH2_AUTHORIZATION_URL': None,",
            "        # server metadata url might optional for your provider",
            "        'OAUTH2_SERVER_METADATA_URL': None,",
            "        # Oauth base url, ex: https://api.github.com/",
            "        'OAUTH2_API_BASE_URL': None,",
            "        # Name of the Endpoint, ex: user",
            "        'OAUTH2_USERINFO_ENDPOINT': None,",
            "        # Oauth scope, ex: 'openid email profile'",
            "        # Note that an 'email' claim is required in the resulting profile",
            "        'OAUTH2_SCOPE': None,",
            "        # The claim which is used for the username. If the value is empty the",
            "        # email is used as username, but if a value is provided,",
            "        # the claim has to exist.",
            "        'OAUTH2_USERNAME_CLAIM': None,",
            "        # Font-awesome icon, ex: fa-github",
            "        'OAUTH2_ICON': None,",
            "        # UI button colour, ex: #0000ff",
            "        'OAUTH2_BUTTON_COLOR': None,",
            "        # The additional claims to check on user ID Token or Userinfo response.",
            "        # This is useful to provide additional authorization checks",
            "        # before allowing access.",
            "        # Example for GitLab: allowing all maintainers teams, and a specific",
            "        # developers group to access pgadmin:",
            "        # 'OAUTH2_ADDITIONAL_CLAIMS': {",
            "        #     'https://gitlab.org/claims/groups/maintainer': [",
            "        #           'kuberheads/applications',",
            "        #           'kuberheads/dba',",
            "        #           'kuberheads/support'",
            "        #      ],",
            "        #     'https://gitlab.org/claims/groups/developer': [",
            "        #           'kuberheads/applications/team01'",
            "        #      ],",
            "        # }",
            "        # Example for AzureAD:",
            "        # 'OAUTH2_ADDITIONAL_CLAIMS': {",
            "        #     'groups': [\"0760b6cf-170e-4a14-91b3-4b78e0739963\"],",
            "        #     'wids': [\"cf1c38e5-3621-4004-a7cb-879624dced7c\"],",
            "        # }",
            "        'OAUTH2_ADDITIONAL_CLAIMS': None,",
            "        # Set this variable to False to disable SSL certificate verification",
            "        # for OAuth2 provider.",
            "        # This may need to set False, in case of self-signed certificates.",
            "        # Ref: https://github.com/psf/requests/issues/6071",
            "        'OAUTH2_SSL_CERT_VERIFICATION': True,",
            "        # set this variable to invalidate the session of the oauth2 provider",
            "        # Example for keycloak:",
            "        # 'OAUTH2_LOGOUT_URL':",
            "        # 'https://example.com/realms/master/protocol/openid-connect/logout?post_logout_redirect_uri={redirect_uri}&id_token_hint={id_token}'",
            "        'OAUTH2_LOGOUT_URL': None",
            "    }",
            "]",
            "",
            "# After Oauth authentication, user will be added into the SQLite database",
            "# automatically, if set to True.",
            "# Set it to False, if user should not be added automatically,",
            "# in this case Admin has to add the user manually in the SQLite database.",
            "",
            "OAUTH2_AUTO_CREATE_USER = True",
            "",
            "##########################################################################",
            "# Webserver Configuration",
            "##########################################################################",
            "",
            "WEBSERVER_AUTO_CREATE_USER = True",
            "",
            "# REMOTE_USER variable will be used to check the environment variable",
            "# is set or not first, if not available,",
            "# request header will be checked for the same.",
            "# Possible values: REMOTE_USER, HTTP_X_FORWARDED_USER, X-Forwarded-User",
            "",
            "WEBSERVER_REMOTE_USER = 'REMOTE_USER'",
            "",
            "##########################################################################",
            "# Two-factor Authentication Configuration",
            "##########################################################################",
            "",
            "# Set it to True, to enable the two-factor authentication",
            "MFA_ENABLED = True",
            "",
            "# Set it to True, to ask the users to register forcefully for the",
            "# two-authentication methods on logged-in.",
            "MFA_FORCE_REGISTRATION = False",
            "",
            "# pgAdmin supports Two-factor authentication by either sending an one-time code",
            "# to an email, or using the TOTP based application like Google Authenticator.",
            "MFA_SUPPORTED_METHODS = [\"email\", \"authenticator\"]",
            "",
            "# NOTE: Please set the 'Mail server settings' to use 'email' as two-factor",
            "#       authentication method.",
            "",
            "# Subject for the email verification code",
            "# Default: <APP_NAME> - Verification Code",
            "# e.g.  pgAdmin 4 - Verification Code",
            "MFA_EMAIL_SUBJECT = None",
            "",
            "##########################################################################",
            "# PSQL tool settings",
            "##########################################################################",
            "# This will enable PSQL tool in pgAdmin when running in server mode.",
            "# PSQL is always enabled in Desktop mode, however in server mode it is",
            "# disabled by default because users can run arbitrary commands on the",
            "# server through it.",
            "ENABLE_PSQL = False",
            "",
            "##########################################################################",
            "# ENABLE_BINARY_PATH_BROWSING setting is used to enable the browse button",
            "# while selecting binary path for the database server in server mode.",
            "# In Desktop mode it is always enabled and setting is of no use.",
            "##########################################################################",
            "ENABLE_BINARY_PATH_BROWSING = False",
            "",
            "##########################################################################",
            "# In server mode, the SHARED_STORAGE setting is used to enable shared storage.",
            "# Specify the name, path, and restricted_access values that should be shared",
            "# between users. When restricted_access is set to True, non-admin users cannot",
            "# upload/add, delete, or rename files/folders in shared storage, only admins",
            "# can do that. Users must provide the absolute path to the folder, and the name",
            "# can be anything they see on the user interface.",
            "# [{ 'name': 'Shared 1', 'path': '/shared_folder',",
            "#   'restricted_access': True/False}]",
            "##########################################################################",
            "SHARED_STORAGE = []",
            "",
            "#############################################################################",
            "# AUTO_DISCOVER_SERVERS setting is used to enable the pgAdmin to discover the",
            "# database server automatically on the local machine.",
            "# When it is set to False, pgAdmin will not discover servers installed on",
            "# the local machine.",
            "#############################################################################",
            "AUTO_DISCOVER_SERVERS = True",
            "",
            "#############################################################################",
            "# SERVER_HEARTBEAT_TIMEOUT is used to send the server heartbeat to server",
            "# from the client. This will resolve the orphan database issue once",
            "# browser tab is closed.",
            "#############################################################################",
            "SERVER_HEARTBEAT_TIMEOUT = 30  # In seconds",
            "",
            "#############################################################################",
            "# ENABLE_SERVER_PASS_EXEC_CMD is used to enable/disable Password exec command",
            "# field in server properties. This is used to specify a shell command to be",
            "# executed to retrieve a password to be used for server authentication.",
            "# This setting is applicable only for server mode.",
            "#############################################################################",
            "ENABLE_SERVER_PASS_EXEC_CMD = False",
            "",
            "#############################################################################",
            "# Patch the default config with custom config and other manipulations",
            "#############################################################################",
            "from pgadmin.evaluate_config import evaluate_and_patch_config",
            "locals().update(evaluate_and_patch_config(locals()))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "web/pgadmin/browser/server_groups/servers/types.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import config"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import copy"
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from flask import render_template"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from flask_babel import gettext as _"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from pgadmin.utils.preferences import Preferences"
            },
            "7": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         \"\"\""
            },
            "8": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         is_default_path_set = ServerType.is_default_binary_path_set(bin_paths)"
            },
            "9": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         for path in config.DEFAULT_BINARY_PATHS:"
            },
            "10": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path_value = config.DEFAULT_BINARY_PATHS[path]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+            is_fixed_path = (path in config.FIXED_BINARY_PATHS and"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+                             config.FIXED_BINARY_PATHS[path] != '' and"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                             config.FIXED_BINARY_PATHS[path] is not None)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+            path_value = (is_fixed_path and config.FIXED_BINARY_PATHS[path]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+                          ) or config.DEFAULT_BINARY_PATHS[path]"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             if path_value is not None and path_value != \"\" and \\"
            },
            "18": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "                     path.find(server_type) == 0 and len(path.split('-')) > 1:"
            },
            "19": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                set_binary_path(path_value, bin_paths, server_type,"
            },
            "20": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                path.split('-')[1])"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+                set_binary_path("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+                    path_value, bin_paths, server_type, path.split('-')[1],"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+                    is_fixed_path=is_fixed_path)"
            },
            "24": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "             elif path_value is not None and path_value != \"\" and \\"
            },
            "25": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "                     path.find(server_type) == 0:"
            },
            "26": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "                 set_binary_path(path_value, bin_paths, server_type,"
            },
            "27": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                set_as_default=not is_default_path_set)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+                                set_as_default=not is_default_path_set,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+                                is_fixed_path=is_fixed_path)"
            },
            "30": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 260,
                "PatchRowcode": " # Default Server Type"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import os",
            "import json",
            "import config",
            "import copy",
            "",
            "from flask import render_template",
            "from flask_babel import gettext as _",
            "from pgadmin.utils.preferences import Preferences",
            "from werkzeug.exceptions import InternalServerError",
            "from pgadmin.utils.constants import BINARY_PATHS",
            "from pgadmin.utils import set_binary_path, replace_binary_path",
            "",
            "",
            "class ServerType():",
            "    \"\"\"",
            "    Server Type",
            "",
            "    Create an instance of this class to define new type of the server support,",
            "    In order to define new type of instance, you may want to override this",
            "    class with overriden function - instanceOf for type checking for",
            "    identification based on the version.",
            "    \"\"\"",
            "    registry = dict()",
            "    UTILITY_PATH_LABEL = _(\"PostgreSQL Binary Path\")",
            "    UTILITY_PATH_HELP = _(",
            "        \"Path to the directory containing the PostgreSQL utility programs\"",
            "        \" (pg_dump, pg_restore etc).\"",
            "    )",
            "",
            "    def __init__(self, server_type, description, priority):",
            "        self.stype = server_type",
            "        self.desc = description",
            "        self.spriority = priority",
            "        self.utility_path = None",
            "",
            "        assert server_type not in ServerType.registry",
            "        ServerType.registry[server_type] = self",
            "",
            "    @property",
            "    def icon(self):",
            "        return \"%s.svg\" % self.stype",
            "",
            "    @property",
            "    def server_type(self):",
            "        return self.stype",
            "",
            "    @property",
            "    def description(self):",
            "        return self.desc",
            "",
            "    @classmethod",
            "    def register_preferences(cls):",
            "        paths = Preferences('paths', _('Paths'))",
            "        bin_paths = copy.deepcopy(BINARY_PATHS)",
            "",
            "        def path_converter(old_path):",
            "            \"\"\"",
            "            This function is used to convert old path to the",
            "            new paths which are in JSON format.",
            "            \"\"\"",
            "            bin_paths_server_based = \\",
            "                copy.deepcopy(BINARY_PATHS['pg_bin_paths'])",
            "            if key == 'ppas':",
            "                bin_paths_server_based = \\",
            "                    copy.deepcopy(BINARY_PATHS['as_bin_paths'])",
            "",
            "            if not ServerType.is_binary_path_of_type_json(old_path):",
            "                set_binary_path(old_path, bin_paths_server_based,",
            "                                key, set_as_default=True)",
            "            else:",
            "                bin_path_dict = \\",
            "                    {item['version']: item for item in bin_paths_server_based}",
            "                old_path_dict = \\",
            "                    {item['version']: item for item in json.loads(old_path)}",
            "",
            "                for item in bin_path_dict:",
            "                    bin_path_dict[item].update(old_path_dict.get(item, {}))",
            "",
            "                bin_paths_server_based = list(bin_path_dict.values())",
            "",
            "            # Set the DEFAULT_BINARY_PATHS if any",
            "            ServerType.set_default_binary_path(bin_paths_server_based, key)",
            "",
            "            return json.dumps(bin_paths_server_based)",
            "",
            "        for key in cls.registry:",
            "            st = cls.registry[key]",
            "",
            "            if key not in ['pg', 'ppas']:",
            "                continue",
            "",
            "            if key == 'pg':",
            "                # Set the DEFAULT_BINARY_PATHS if any",
            "                ServerType.set_default_binary_path(",
            "                    bin_paths['pg_bin_paths'], key)",
            "",
            "                st.utility_path = paths.register(",
            "                    'bin_paths', 'pg_bin_dir',",
            "                    _(\"PostgreSQL Binary Path\"), 'selectFile',",
            "                    json.dumps(bin_paths['pg_bin_paths']),",
            "                    category_label=_('Binary paths')",
            "                )",
            "            elif key == 'ppas':",
            "                # Set the DEFAULT_BINARY_PATHS if any",
            "                ServerType.set_default_binary_path(",
            "                    bin_paths['as_bin_paths'], key)",
            "",
            "                st.utility_path = paths.register(",
            "                    'bin_paths', 'ppas_bin_dir',",
            "                    _(\"EDB Advanced Server Binary Path\"), 'selectFile',",
            "                    json.dumps(bin_paths['as_bin_paths']),",
            "                    category_label=_('Binary paths')",
            "                )",
            "",
            "            # Run the migrate user preferences.",
            "            paths.migrate_user_preferences(st.utility_path.pid,",
            "                                           path_converter)",
            "",
            "    @property",
            "    def priority(self):",
            "        return self.spriority",
            "",
            "    def __str__(self):",
            "        return _(\"Type: {0}, Description: {1}, Priority: {2}\").format(",
            "            self.stype, self.desc, self.spriority",
            "        )",
            "",
            "    def instance_of(self):",
            "        return True",
            "",
            "    @property",
            "    def csssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of css to include in the page",
            "        \"\"\"",
            "        return [",
            "            render_template(",
            "                \"css/server_type.css\",",
            "                server_type=self.stype,",
            "                icon=self.icon",
            "            )",
            "        ]",
            "",
            "    @classmethod",
            "    def types(cls):",
            "        return sorted(",
            "            ServerType.registry.values(),",
            "            key=lambda x: x.priority,",
            "            reverse=True",
            "        )",
            "",
            "    def utility(self, operation, sversion):",
            "        res = None",
            "",
            "        if operation == 'backup':",
            "            res = 'pg_dump'",
            "        elif operation == 'backup_server':",
            "            res = 'pg_dumpall'",
            "        elif operation == 'restore':",
            "            res = 'pg_restore'",
            "        elif operation == 'sql':",
            "            res = 'psql'",
            "        else:",
            "            raise InternalServerError(",
            "                _(\"Could not find the utility for the operation '%s'\").format(",
            "                    operation",
            "                )",
            "            )",
            "",
            "        bin_path = self.get_utility_path(sversion)",
            "        if bin_path is None:",
            "            return None",
            "",
            "        # Check if \"$DIR\" present in binary path",
            "        bin_path = replace_binary_path(bin_path)",
            "",
            "        return os.path.abspath(os.path.join(",
            "            bin_path,",
            "            (res if os.name != 'nt' else (res + '.exe'))",
            "        ))",
            "",
            "    def get_utility_path(self, sverison):",
            "        \"\"\"",
            "        This function is used to get the utility path set by the user in",
            "        preferences for the specific server version, if not set then check",
            "        for any default path is set.",
            "        \"\"\"",
            "        default_path = None",
            "        bin_path_json = json.loads(self.utility_path.get())",
            "        # iterate through all the path and return appropriate value",
            "        for bin_path in bin_path_json:",
            "            if int(bin_path['version']) <= sverison < \\",
            "                int(bin_path['next_major_version']) and \\",
            "                    bin_path['binaryPath'] is not None and \\",
            "                    bin_path['binaryPath'].strip() != '':",
            "                return bin_path['binaryPath']",
            "",
            "            if bin_path['isDefault']:",
            "                default_path = bin_path['binaryPath']",
            "",
            "        return default_path",
            "",
            "    @staticmethod",
            "    def is_default_binary_path_set(binary_paths):",
            "        \"\"\"",
            "        This function is used to iterate through the binary paths",
            "        and check whether isDefault is set to true.",
            "        \"\"\"",
            "        for path in binary_paths:",
            "            if path['isDefault']:",
            "                return True",
            "        return False",
            "",
            "    @staticmethod",
            "    def is_binary_path_of_type_json(binary_path):",
            "        \"\"\"",
            "        This function will check if the binary path is of type json or not.",
            "        \"\"\"",
            "        try:",
            "            json.loads(binary_path)",
            "        except ValueError:",
            "            return False",
            "        return True",
            "",
            "    @staticmethod",
            "    def set_default_binary_path(bin_paths, server_type):",
            "        \"\"\"",
            "        This function is used to check whether default binary path is set",
            "        or not and then iterate through config.DEFAULT_BINARY_PATHS and",
            "        set the path based on version number.",
            "        \"\"\"",
            "        is_default_path_set = ServerType.is_default_binary_path_set(bin_paths)",
            "        for path in config.DEFAULT_BINARY_PATHS:",
            "            path_value = config.DEFAULT_BINARY_PATHS[path]",
            "            if path_value is not None and path_value != \"\" and \\",
            "                    path.find(server_type) == 0 and len(path.split('-')) > 1:",
            "                set_binary_path(path_value, bin_paths, server_type,",
            "                                path.split('-')[1])",
            "            elif path_value is not None and path_value != \"\" and \\",
            "                    path.find(server_type) == 0:",
            "                set_binary_path(path_value, bin_paths, server_type,",
            "                                set_as_default=not is_default_path_set)",
            "",
            "",
            "# Default Server Type",
            "ServerType('pg', _(\"PostgreSQL\"), -1)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import os",
            "import json",
            "import config",
            "import copy",
            "from flask import render_template",
            "from flask_babel import gettext as _",
            "from pgadmin.utils.preferences import Preferences",
            "from werkzeug.exceptions import InternalServerError",
            "from pgadmin.utils.constants import BINARY_PATHS",
            "from pgadmin.utils import set_binary_path, replace_binary_path",
            "",
            "",
            "class ServerType():",
            "    \"\"\"",
            "    Server Type",
            "",
            "    Create an instance of this class to define new type of the server support,",
            "    In order to define new type of instance, you may want to override this",
            "    class with overriden function - instanceOf for type checking for",
            "    identification based on the version.",
            "    \"\"\"",
            "    registry = dict()",
            "    UTILITY_PATH_LABEL = _(\"PostgreSQL Binary Path\")",
            "    UTILITY_PATH_HELP = _(",
            "        \"Path to the directory containing the PostgreSQL utility programs\"",
            "        \" (pg_dump, pg_restore etc).\"",
            "    )",
            "",
            "    def __init__(self, server_type, description, priority):",
            "        self.stype = server_type",
            "        self.desc = description",
            "        self.spriority = priority",
            "        self.utility_path = None",
            "",
            "        assert server_type not in ServerType.registry",
            "        ServerType.registry[server_type] = self",
            "",
            "    @property",
            "    def icon(self):",
            "        return \"%s.svg\" % self.stype",
            "",
            "    @property",
            "    def server_type(self):",
            "        return self.stype",
            "",
            "    @property",
            "    def description(self):",
            "        return self.desc",
            "",
            "    @classmethod",
            "    def register_preferences(cls):",
            "        paths = Preferences('paths', _('Paths'))",
            "        bin_paths = copy.deepcopy(BINARY_PATHS)",
            "",
            "        def path_converter(old_path):",
            "            \"\"\"",
            "            This function is used to convert old path to the",
            "            new paths which are in JSON format.",
            "            \"\"\"",
            "            bin_paths_server_based = \\",
            "                copy.deepcopy(BINARY_PATHS['pg_bin_paths'])",
            "            if key == 'ppas':",
            "                bin_paths_server_based = \\",
            "                    copy.deepcopy(BINARY_PATHS['as_bin_paths'])",
            "",
            "            if not ServerType.is_binary_path_of_type_json(old_path):",
            "                set_binary_path(old_path, bin_paths_server_based,",
            "                                key, set_as_default=True)",
            "            else:",
            "                bin_path_dict = \\",
            "                    {item['version']: item for item in bin_paths_server_based}",
            "                old_path_dict = \\",
            "                    {item['version']: item for item in json.loads(old_path)}",
            "",
            "                for item in bin_path_dict:",
            "                    bin_path_dict[item].update(old_path_dict.get(item, {}))",
            "",
            "                bin_paths_server_based = list(bin_path_dict.values())",
            "",
            "            # Set the DEFAULT_BINARY_PATHS if any",
            "            ServerType.set_default_binary_path(bin_paths_server_based, key)",
            "",
            "            return json.dumps(bin_paths_server_based)",
            "",
            "        for key in cls.registry:",
            "            st = cls.registry[key]",
            "",
            "            if key not in ['pg', 'ppas']:",
            "                continue",
            "",
            "            if key == 'pg':",
            "                # Set the DEFAULT_BINARY_PATHS if any",
            "                ServerType.set_default_binary_path(",
            "                    bin_paths['pg_bin_paths'], key)",
            "",
            "                st.utility_path = paths.register(",
            "                    'bin_paths', 'pg_bin_dir',",
            "                    _(\"PostgreSQL Binary Path\"), 'selectFile',",
            "                    json.dumps(bin_paths['pg_bin_paths']),",
            "                    category_label=_('Binary paths')",
            "                )",
            "            elif key == 'ppas':",
            "                # Set the DEFAULT_BINARY_PATHS if any",
            "                ServerType.set_default_binary_path(",
            "                    bin_paths['as_bin_paths'], key)",
            "",
            "                st.utility_path = paths.register(",
            "                    'bin_paths', 'ppas_bin_dir',",
            "                    _(\"EDB Advanced Server Binary Path\"), 'selectFile',",
            "                    json.dumps(bin_paths['as_bin_paths']),",
            "                    category_label=_('Binary paths')",
            "                )",
            "",
            "            # Run the migrate user preferences.",
            "            paths.migrate_user_preferences(st.utility_path.pid,",
            "                                           path_converter)",
            "",
            "    @property",
            "    def priority(self):",
            "        return self.spriority",
            "",
            "    def __str__(self):",
            "        return _(\"Type: {0}, Description: {1}, Priority: {2}\").format(",
            "            self.stype, self.desc, self.spriority",
            "        )",
            "",
            "    def instance_of(self):",
            "        return True",
            "",
            "    @property",
            "    def csssnippets(self):",
            "        \"\"\"",
            "        Returns a snippet of css to include in the page",
            "        \"\"\"",
            "        return [",
            "            render_template(",
            "                \"css/server_type.css\",",
            "                server_type=self.stype,",
            "                icon=self.icon",
            "            )",
            "        ]",
            "",
            "    @classmethod",
            "    def types(cls):",
            "        return sorted(",
            "            ServerType.registry.values(),",
            "            key=lambda x: x.priority,",
            "            reverse=True",
            "        )",
            "",
            "    def utility(self, operation, sversion):",
            "        res = None",
            "",
            "        if operation == 'backup':",
            "            res = 'pg_dump'",
            "        elif operation == 'backup_server':",
            "            res = 'pg_dumpall'",
            "        elif operation == 'restore':",
            "            res = 'pg_restore'",
            "        elif operation == 'sql':",
            "            res = 'psql'",
            "        else:",
            "            raise InternalServerError(",
            "                _(\"Could not find the utility for the operation '%s'\").format(",
            "                    operation",
            "                )",
            "            )",
            "",
            "        bin_path = self.get_utility_path(sversion)",
            "        if bin_path is None:",
            "            return None",
            "",
            "        # Check if \"$DIR\" present in binary path",
            "        bin_path = replace_binary_path(bin_path)",
            "",
            "        return os.path.abspath(os.path.join(",
            "            bin_path,",
            "            (res if os.name != 'nt' else (res + '.exe'))",
            "        ))",
            "",
            "    def get_utility_path(self, sverison):",
            "        \"\"\"",
            "        This function is used to get the utility path set by the user in",
            "        preferences for the specific server version, if not set then check",
            "        for any default path is set.",
            "        \"\"\"",
            "        default_path = None",
            "        bin_path_json = json.loads(self.utility_path.get())",
            "        # iterate through all the path and return appropriate value",
            "        for bin_path in bin_path_json:",
            "            if int(bin_path['version']) <= sverison < \\",
            "                int(bin_path['next_major_version']) and \\",
            "                    bin_path['binaryPath'] is not None and \\",
            "                    bin_path['binaryPath'].strip() != '':",
            "                return bin_path['binaryPath']",
            "",
            "            if bin_path['isDefault']:",
            "                default_path = bin_path['binaryPath']",
            "",
            "        return default_path",
            "",
            "    @staticmethod",
            "    def is_default_binary_path_set(binary_paths):",
            "        \"\"\"",
            "        This function is used to iterate through the binary paths",
            "        and check whether isDefault is set to true.",
            "        \"\"\"",
            "        for path in binary_paths:",
            "            if path['isDefault']:",
            "                return True",
            "        return False",
            "",
            "    @staticmethod",
            "    def is_binary_path_of_type_json(binary_path):",
            "        \"\"\"",
            "        This function will check if the binary path is of type json or not.",
            "        \"\"\"",
            "        try:",
            "            json.loads(binary_path)",
            "        except ValueError:",
            "            return False",
            "        return True",
            "",
            "    @staticmethod",
            "    def set_default_binary_path(bin_paths, server_type):",
            "        \"\"\"",
            "        This function is used to check whether default binary path is set",
            "        or not and then iterate through config.DEFAULT_BINARY_PATHS and",
            "        set the path based on version number.",
            "        \"\"\"",
            "        is_default_path_set = ServerType.is_default_binary_path_set(bin_paths)",
            "        for path in config.DEFAULT_BINARY_PATHS:",
            "            is_fixed_path = (path in config.FIXED_BINARY_PATHS and",
            "                             config.FIXED_BINARY_PATHS[path] != '' and",
            "                             config.FIXED_BINARY_PATHS[path] is not None)",
            "            path_value = (is_fixed_path and config.FIXED_BINARY_PATHS[path]",
            "                          ) or config.DEFAULT_BINARY_PATHS[path]",
            "",
            "            if path_value is not None and path_value != \"\" and \\",
            "                    path.find(server_type) == 0 and len(path.split('-')) > 1:",
            "                set_binary_path(",
            "                    path_value, bin_paths, server_type, path.split('-')[1],",
            "                    is_fixed_path=is_fixed_path)",
            "            elif path_value is not None and path_value != \"\" and \\",
            "                    path.find(server_type) == 0:",
            "                set_binary_path(path_value, bin_paths, server_type,",
            "                                set_as_default=not is_default_path_set,",
            "                                is_fixed_path=is_fixed_path)",
            "",
            "",
            "# Default Server Type",
            "ServerType('pg', _(\"PostgreSQL\"), -1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [],
            "243": [
                "ServerType",
                "set_default_binary_path"
            ],
            "246": [
                "ServerType",
                "set_default_binary_path"
            ],
            "247": [
                "ServerType",
                "set_default_binary_path"
            ],
            "251": [
                "ServerType",
                "set_default_binary_path"
            ]
        },
        "addLocation": []
    },
    "web/pgadmin/misc/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from flask.helpers import url_for"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from flask_babel import gettext"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from flask_security import login_required"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from pgadmin.utils import PgAdminModule, replace_binary_path, \\"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     get_binary_path_versions"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from pgadmin.utils.csrf import pgCSRFProtect"
            },
            "7": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         data = json.loads(data)"
            },
            "8": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 236,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     version_str = ''"
            },
            "10": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'utility_path' in data and data['utility_path'] is not None:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+    # Do not allow storage dir as utility path"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    if 'utility_path' in data and data['utility_path'] is not None and \\"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+        Path(config.STORAGE_DIR) != Path(data['utility_path']) and \\"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+            Path(config.STORAGE_DIR) not in Path(data['utility_path']).parents:"
            },
            "16": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         binary_versions = get_binary_path_versions(data['utility_path'])"
            },
            "17": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         for utility, version in binary_versions.items():"
            },
            "18": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             if version is None:"
            },
            "19": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     return make_json_response(data=gettext(version_str), status=200)"
            },
            "20": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 255,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@blueprint.route(\"/upgrade_check\", endpoint=\"upgrade_check\", methods=['GET'])"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+@blueprint.route(\"/upgrade_check\", endpoint=\"upgrade_check\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+                 methods=['GET'])"
            },
            "25": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " @login_required"
            },
            "26": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " def upgrade_check():"
            },
            "27": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     # Get the current version info from the website, and flash a message if"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module providing utility functions for the application.\"\"\"",
            "",
            "from pgadmin.utils import driver",
            "from flask import render_template, Response, request, current_app",
            "from flask.helpers import url_for",
            "from flask_babel import gettext",
            "from flask_security import login_required",
            "from pgadmin.utils import PgAdminModule, replace_binary_path, \\",
            "    get_binary_path_versions",
            "from pgadmin.utils.csrf import pgCSRFProtect",
            "from pgadmin.utils.session import cleanup_session_files",
            "from pgadmin.misc.themes import get_all_themes",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS, UTILITIES_ARRAY",
            "from pgadmin.utils.ajax import precondition_required, make_json_response, \\",
            "    internal_server_error",
            "from pgadmin.utils.heartbeat import log_server_heartbeat, \\",
            "    get_server_heartbeat, stop_server_heartbeat",
            "import config",
            "import time",
            "import json",
            "import os",
            "from urllib.request import urlopen",
            "from pgadmin.settings import get_setting, store_setting",
            "",
            "MODULE_NAME = 'misc'",
            "",
            "",
            "class MiscModule(PgAdminModule):",
            "    LABEL = gettext('Miscellaneous')",
            "",
            "    def register_preferences(self):",
            "        \"\"\"",
            "        Register preferences for this module.",
            "        \"\"\"",
            "        lang_options = []",
            "        for lang in config.LANGUAGES:",
            "            lang_options.append(",
            "                {",
            "                    'label': config.LANGUAGES[lang],",
            "                    'value': lang",
            "                }",
            "            )",
            "",
            "        # Register options for the User language settings",
            "        self.preference.register(",
            "            'user_language', 'user_language',",
            "            gettext(\"User language\"), 'options', 'en',",
            "            category_label=gettext('User language'),",
            "            options=lang_options,",
            "            control_props={",
            "                'allowClear': False,",
            "            }",
            "        )",
            "",
            "        theme_options = []",
            "",
            "        for theme, theme_data in (get_all_themes()).items():",
            "            theme_options.append({",
            "                'label': theme_data['disp_name']",
            "                .replace('_', ' ')",
            "                .replace('-', ' ')",
            "                .title(),",
            "                'value': theme,",
            "                'preview_src': url_for(",
            "                    'static', filename='js/generated/img/' +",
            "                                       theme_data['preview_img']",
            "                )",
            "            })",
            "",
            "        self.preference.register(",
            "            'themes', 'theme',",
            "            gettext(\"Theme\"), 'options', 'standard',",
            "            category_label=gettext('Themes'),",
            "            options=theme_options,",
            "            control_props={",
            "                'allowClear': False,",
            "            },",
            "            help_str=gettext(",
            "                'A refresh is required to apply the theme. Above is the '",
            "                'preview of the theme'",
            "            )",
            "        )",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return ['misc.ping', 'misc.index', 'misc.cleanup',",
            "                'misc.validate_binary_path', 'misc.log_heartbeat',",
            "                'misc.stop_heartbeat', 'misc.get_heartbeat',",
            "                'misc.upgrade_check']",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "        from .bgprocess import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .cloud import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .dependencies import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .dependents import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .file_manager import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .statistics import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        super().register(app, options)",
            "",
            "",
            "# Initialise the module",
            "blueprint = MiscModule(MODULE_NAME, __name__)",
            "",
            "",
            "##########################################################################",
            "# A special URL used to \"ping\" the server",
            "##########################################################################",
            "@blueprint.route(\"/\", endpoint='index')",
            "def index():",
            "    return ''",
            "",
            "",
            "##########################################################################",
            "# A special URL used to \"ping\" the server",
            "##########################################################################",
            "@blueprint.route(\"/ping\")",
            "@pgCSRFProtect.exempt",
            "def ping():",
            "    \"\"\"Generate a \"PING\" response to indicate that the server is alive.\"\"\"",
            "    return \"PING\"",
            "",
            "",
            "# For Garbage Collecting closed connections",
            "@blueprint.route(\"/cleanup\", methods=['POST'])",
            "@pgCSRFProtect.exempt",
            "def cleanup():",
            "    driver.ping()",
            "    # Cleanup session files.",
            "    cleanup_session_files()",
            "    return \"\"",
            "",
            "",
            "@blueprint.route(\"/heartbeat/log\", methods=['POST'])",
            "@pgCSRFProtect.exempt",
            "def log_heartbeat():",
            "    data = None",
            "    if hasattr(request.data, 'decode'):",
            "        data = request.data.decode('utf-8')",
            "",
            "    if data != '':",
            "        data = json.loads(data)",
            "",
            "    status, msg = log_server_heartbeat(data)",
            "    if status:",
            "        return make_json_response(data=msg, status=200)",
            "    else:",
            "        return make_json_response(data=msg, status=404)",
            "",
            "",
            "@blueprint.route(\"/heartbeat/stop\", methods=['POST'])",
            "@pgCSRFProtect.exempt",
            "def stop_heartbeat():",
            "    data = None",
            "    if hasattr(request.data, 'decode'):",
            "        data = request.data.decode('utf-8')",
            "",
            "    if data != '':",
            "        data = json.loads(data)",
            "",
            "    _, msg = stop_server_heartbeat(data)",
            "    return make_json_response(data=msg,",
            "                              status=200)",
            "",
            "",
            "@blueprint.route(\"/get_heartbeat/<int:sid>\", methods=['GET'])",
            "@pgCSRFProtect.exempt",
            "def get_heartbeat(sid):",
            "    heartbeat_data = get_server_heartbeat(sid)",
            "    return make_json_response(data=heartbeat_data,",
            "                              status=200)",
            "",
            "",
            "##########################################################################",
            "# A special URL used to shut down the server",
            "##########################################################################",
            "@blueprint.route(\"/shutdown\", methods=('get', 'post'))",
            "@pgCSRFProtect.exempt",
            "def shutdown():",
            "    if config.SERVER_MODE is not True:",
            "        func = request.environ.get('werkzeug.server.shutdown')",
            "        if func is None:",
            "            raise RuntimeError('Not running with the Werkzeug Server')",
            "        func()",
            "        return 'SHUTDOWN'",
            "    else:",
            "        return ''",
            "",
            "",
            "##########################################################################",
            "# A special URL used to validate the binary path",
            "##########################################################################",
            "@blueprint.route(\"/validate_binary_path\",",
            "                 endpoint=\"validate_binary_path\",",
            "                 methods=[\"POST\"])",
            "@login_required",
            "def validate_binary_path():",
            "    \"\"\"",
            "    This function is used to validate the specified utilities path by",
            "    running the utilities with their versions.",
            "    \"\"\"",
            "    data = None",
            "    if hasattr(request.data, 'decode'):",
            "        data = request.data.decode('utf-8')",
            "",
            "    if data != '':",
            "        data = json.loads(data)",
            "",
            "    version_str = ''",
            "    if 'utility_path' in data and data['utility_path'] is not None:",
            "        binary_versions = get_binary_path_versions(data['utility_path'])",
            "        for utility, version in binary_versions.items():",
            "            if version is None:",
            "                version_str += \"<b>\" + utility + \":</b> \" + \\",
            "                               \"not found on the specified binary path.<br/>\"",
            "            else:",
            "                version_str += \"<b>\" + utility + \":</b> \" + version + \"<br/>\"",
            "    else:",
            "        return precondition_required(gettext('Invalid binary path.'))",
            "",
            "    return make_json_response(data=gettext(version_str), status=200)",
            "",
            "",
            "@blueprint.route(\"/upgrade_check\", endpoint=\"upgrade_check\", methods=['GET'])",
            "@login_required",
            "def upgrade_check():",
            "    # Get the current version info from the website, and flash a message if",
            "    # the user is out of date, and the check is enabled.",
            "    ret = {",
            "        \"outdated\": False,",
            "    }",
            "    if config.UPGRADE_CHECK_ENABLED:",
            "        last_check = get_setting('LastUpdateCheck', default='0')",
            "        today = time.strftime('%Y%m%d')",
            "        if int(last_check) < int(today):",
            "            data = None",
            "            url = '%s?version=%s' % (",
            "                config.UPGRADE_CHECK_URL, config.APP_VERSION)",
            "            current_app.logger.debug('Checking version data at: %s' % url)",
            "            try:",
            "                # Do not wait for more than 5 seconds.",
            "                # It stuck on rendering the browser.html, while working in the",
            "                # broken network.",
            "                if os.path.exists(config.CA_FILE):",
            "                    response = urlopen(url, data, 5, cafile=config.CA_FILE)",
            "                else:",
            "                    response = urlopen(url, data, 5)",
            "                current_app.logger.debug(",
            "                    'Version check HTTP response code: %d' % response.getcode()",
            "                )",
            "",
            "                if response.getcode() == 200:",
            "                    data = json.loads(response.read().decode('utf-8'))",
            "                    current_app.logger.debug('Response data: %s' % data)",
            "            except Exception:",
            "                current_app.logger.exception(",
            "                    'Exception when checking for update')",
            "                return internal_server_error('Failed to check for update')",
            "",
            "            if data is not None and \\",
            "                data[config.UPGRADE_CHECK_KEY]['version_int'] > \\",
            "                    config.APP_VERSION_INT:",
            "                ret = {",
            "                    \"outdated\": True,",
            "                    \"current_version\": config.APP_VERSION,",
            "                    \"upgrade_version\": data[config.UPGRADE_CHECK_KEY][",
            "                        'version'],",
            "                    \"product_name\": config.APP_NAME,",
            "                    \"download_url\": data[config.UPGRADE_CHECK_KEY][",
            "                        'download_url']",
            "                }",
            "",
            "        store_setting('LastUpdateCheck', today)",
            "    return make_json_response(data=ret)"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "\"\"\"A blueprint module providing utility functions for the application.\"\"\"",
            "",
            "from pgadmin.utils import driver",
            "from flask import render_template, Response, request, current_app",
            "from flask.helpers import url_for",
            "from flask_babel import gettext",
            "from flask_security import login_required",
            "from pathlib import Path",
            "from pgadmin.utils import PgAdminModule, replace_binary_path, \\",
            "    get_binary_path_versions",
            "from pgadmin.utils.csrf import pgCSRFProtect",
            "from pgadmin.utils.session import cleanup_session_files",
            "from pgadmin.misc.themes import get_all_themes",
            "from pgadmin.utils.constants import MIMETYPE_APP_JS, UTILITIES_ARRAY",
            "from pgadmin.utils.ajax import precondition_required, make_json_response, \\",
            "    internal_server_error",
            "from pgadmin.utils.heartbeat import log_server_heartbeat, \\",
            "    get_server_heartbeat, stop_server_heartbeat",
            "import config",
            "import time",
            "import json",
            "import os",
            "from urllib.request import urlopen",
            "from pgadmin.settings import get_setting, store_setting",
            "",
            "MODULE_NAME = 'misc'",
            "",
            "",
            "class MiscModule(PgAdminModule):",
            "    LABEL = gettext('Miscellaneous')",
            "",
            "    def register_preferences(self):",
            "        \"\"\"",
            "        Register preferences for this module.",
            "        \"\"\"",
            "        lang_options = []",
            "        for lang in config.LANGUAGES:",
            "            lang_options.append(",
            "                {",
            "                    'label': config.LANGUAGES[lang],",
            "                    'value': lang",
            "                }",
            "            )",
            "",
            "        # Register options for the User language settings",
            "        self.preference.register(",
            "            'user_language', 'user_language',",
            "            gettext(\"User language\"), 'options', 'en',",
            "            category_label=gettext('User language'),",
            "            options=lang_options,",
            "            control_props={",
            "                'allowClear': False,",
            "            }",
            "        )",
            "",
            "        theme_options = []",
            "",
            "        for theme, theme_data in (get_all_themes()).items():",
            "            theme_options.append({",
            "                'label': theme_data['disp_name']",
            "                .replace('_', ' ')",
            "                .replace('-', ' ')",
            "                .title(),",
            "                'value': theme,",
            "                'preview_src': url_for(",
            "                    'static', filename='js/generated/img/' +",
            "                                       theme_data['preview_img']",
            "                )",
            "            })",
            "",
            "        self.preference.register(",
            "            'themes', 'theme',",
            "            gettext(\"Theme\"), 'options', 'standard',",
            "            category_label=gettext('Themes'),",
            "            options=theme_options,",
            "            control_props={",
            "                'allowClear': False,",
            "            },",
            "            help_str=gettext(",
            "                'A refresh is required to apply the theme. Above is the '",
            "                'preview of the theme'",
            "            )",
            "        )",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return ['misc.ping', 'misc.index', 'misc.cleanup',",
            "                'misc.validate_binary_path', 'misc.log_heartbeat',",
            "                'misc.stop_heartbeat', 'misc.get_heartbeat',",
            "                'misc.upgrade_check']",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "        from .bgprocess import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .cloud import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .dependencies import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .dependents import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .file_manager import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        from .statistics import blueprint as module",
            "        self.submodules.append(module)",
            "",
            "        super().register(app, options)",
            "",
            "",
            "# Initialise the module",
            "blueprint = MiscModule(MODULE_NAME, __name__)",
            "",
            "",
            "##########################################################################",
            "# A special URL used to \"ping\" the server",
            "##########################################################################",
            "@blueprint.route(\"/\", endpoint='index')",
            "def index():",
            "    return ''",
            "",
            "",
            "##########################################################################",
            "# A special URL used to \"ping\" the server",
            "##########################################################################",
            "@blueprint.route(\"/ping\")",
            "@pgCSRFProtect.exempt",
            "def ping():",
            "    \"\"\"Generate a \"PING\" response to indicate that the server is alive.\"\"\"",
            "    return \"PING\"",
            "",
            "",
            "# For Garbage Collecting closed connections",
            "@blueprint.route(\"/cleanup\", methods=['POST'])",
            "@pgCSRFProtect.exempt",
            "def cleanup():",
            "    driver.ping()",
            "    # Cleanup session files.",
            "    cleanup_session_files()",
            "    return \"\"",
            "",
            "",
            "@blueprint.route(\"/heartbeat/log\", methods=['POST'])",
            "@pgCSRFProtect.exempt",
            "def log_heartbeat():",
            "    data = None",
            "    if hasattr(request.data, 'decode'):",
            "        data = request.data.decode('utf-8')",
            "",
            "    if data != '':",
            "        data = json.loads(data)",
            "",
            "    status, msg = log_server_heartbeat(data)",
            "    if status:",
            "        return make_json_response(data=msg, status=200)",
            "    else:",
            "        return make_json_response(data=msg, status=404)",
            "",
            "",
            "@blueprint.route(\"/heartbeat/stop\", methods=['POST'])",
            "@pgCSRFProtect.exempt",
            "def stop_heartbeat():",
            "    data = None",
            "    if hasattr(request.data, 'decode'):",
            "        data = request.data.decode('utf-8')",
            "",
            "    if data != '':",
            "        data = json.loads(data)",
            "",
            "    _, msg = stop_server_heartbeat(data)",
            "    return make_json_response(data=msg,",
            "                              status=200)",
            "",
            "",
            "@blueprint.route(\"/get_heartbeat/<int:sid>\", methods=['GET'])",
            "@pgCSRFProtect.exempt",
            "def get_heartbeat(sid):",
            "    heartbeat_data = get_server_heartbeat(sid)",
            "    return make_json_response(data=heartbeat_data,",
            "                              status=200)",
            "",
            "",
            "##########################################################################",
            "# A special URL used to shut down the server",
            "##########################################################################",
            "@blueprint.route(\"/shutdown\", methods=('get', 'post'))",
            "@pgCSRFProtect.exempt",
            "def shutdown():",
            "    if config.SERVER_MODE is not True:",
            "        func = request.environ.get('werkzeug.server.shutdown')",
            "        if func is None:",
            "            raise RuntimeError('Not running with the Werkzeug Server')",
            "        func()",
            "        return 'SHUTDOWN'",
            "    else:",
            "        return ''",
            "",
            "",
            "##########################################################################",
            "# A special URL used to validate the binary path",
            "##########################################################################",
            "@blueprint.route(\"/validate_binary_path\",",
            "                 endpoint=\"validate_binary_path\",",
            "                 methods=[\"POST\"])",
            "@login_required",
            "def validate_binary_path():",
            "    \"\"\"",
            "    This function is used to validate the specified utilities path by",
            "    running the utilities with their versions.",
            "    \"\"\"",
            "    data = None",
            "    if hasattr(request.data, 'decode'):",
            "        data = request.data.decode('utf-8')",
            "",
            "    if data != '':",
            "        data = json.loads(data)",
            "",
            "    version_str = ''",
            "",
            "    # Do not allow storage dir as utility path",
            "    if 'utility_path' in data and data['utility_path'] is not None and \\",
            "        Path(config.STORAGE_DIR) != Path(data['utility_path']) and \\",
            "            Path(config.STORAGE_DIR) not in Path(data['utility_path']).parents:",
            "        binary_versions = get_binary_path_versions(data['utility_path'])",
            "        for utility, version in binary_versions.items():",
            "            if version is None:",
            "                version_str += \"<b>\" + utility + \":</b> \" + \\",
            "                               \"not found on the specified binary path.<br/>\"",
            "            else:",
            "                version_str += \"<b>\" + utility + \":</b> \" + version + \"<br/>\"",
            "    else:",
            "        return precondition_required(gettext('Invalid binary path.'))",
            "",
            "    return make_json_response(data=gettext(version_str), status=200)",
            "",
            "",
            "@blueprint.route(\"/upgrade_check\", endpoint=\"upgrade_check\",",
            "                 methods=['GET'])",
            "@login_required",
            "def upgrade_check():",
            "    # Get the current version info from the website, and flash a message if",
            "    # the user is out of date, and the check is enabled.",
            "    ret = {",
            "        \"outdated\": False,",
            "    }",
            "    if config.UPGRADE_CHECK_ENABLED:",
            "        last_check = get_setting('LastUpdateCheck', default='0')",
            "        today = time.strftime('%Y%m%d')",
            "        if int(last_check) < int(today):",
            "            data = None",
            "            url = '%s?version=%s' % (",
            "                config.UPGRADE_CHECK_URL, config.APP_VERSION)",
            "            current_app.logger.debug('Checking version data at: %s' % url)",
            "            try:",
            "                # Do not wait for more than 5 seconds.",
            "                # It stuck on rendering the browser.html, while working in the",
            "                # broken network.",
            "                if os.path.exists(config.CA_FILE):",
            "                    response = urlopen(url, data, 5, cafile=config.CA_FILE)",
            "                else:",
            "                    response = urlopen(url, data, 5)",
            "                current_app.logger.debug(",
            "                    'Version check HTTP response code: %d' % response.getcode()",
            "                )",
            "",
            "                if response.getcode() == 200:",
            "                    data = json.loads(response.read().decode('utf-8'))",
            "                    current_app.logger.debug('Response data: %s' % data)",
            "            except Exception:",
            "                current_app.logger.exception(",
            "                    'Exception when checking for update')",
            "                return internal_server_error('Failed to check for update')",
            "",
            "            if data is not None and \\",
            "                data[config.UPGRADE_CHECK_KEY]['version_int'] > \\",
            "                    config.APP_VERSION_INT:",
            "                ret = {",
            "                    \"outdated\": True,",
            "                    \"current_version\": config.APP_VERSION,",
            "                    \"upgrade_version\": data[config.UPGRADE_CHECK_KEY][",
            "                        'version'],",
            "                    \"product_name\": config.APP_NAME,",
            "                    \"download_url\": data[config.UPGRADE_CHECK_KEY][",
            "                        'download_url']",
            "                }",
            "",
            "        store_setting('LastUpdateCheck', today)",
            "    return make_json_response(data=ret)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "237": [
                "validate_binary_path"
            ],
            "251": []
        },
        "addLocation": []
    },
    "web/pgadmin/utils/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from collections import defaultdict"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from operator import attrgetter"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from flask import Blueprint, current_app, url_for"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from flask_babel import gettext"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from flask_security import current_user, login_required"
            },
            "7": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from flask_security.utils import get_post_login_redirect, \\"
            },
            "8": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     get_post_logout_redirect"
            },
            "9": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from threading import Lock"
            },
            "10": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+import config"
            },
            "12": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from .paths import get_storage_directory"
            },
            "13": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from .preferences import Preferences"
            },
            "14": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from pgadmin.utils.constants import UTILITIES_ARRAY, USER_NOT_FOUND, \\"
            },
            "15": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "     :return:"
            },
            "16": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "     \"\"\""
            },
            "17": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "     error_msg = None"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 311,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "     if file is None:"
            },
            "20": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "         error_msg = gettext(\"Utility file not found. Please correct the Binary\""
            },
            "21": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 315,
                "PatchRowcode": "                             \" Path in the Preferences dialog\")"
            },
            "22": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "         return error_msg"
            },
            "23": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 317,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+    if Path(config.STORAGE_DIR) == Path(file) or \\"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+            Path(config.STORAGE_DIR) in Path(file).parents:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+        error_msg = gettext(\"Please correct the Binary Path in the Preferences\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+                            \" dialog. pgAdmin storage directory can not be a\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+                            \" utility binary directory.\")"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 324,
                "PatchRowcode": "     if not os.path.exists(file):"
            },
            "31": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "         error_msg = gettext(\"'%s' file not found. Please correct the Binary\""
            },
            "32": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "                             \" Path in the Preferences dialog\" % file)"
            },
            "33": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 372,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 373,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 374,
                "PatchRowcode": " def set_binary_path(binary_path, bin_paths, server_type,"
            },
            "36": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    version_number=None, set_as_default=False):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+                    version_number=None, set_as_default=False,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+                    is_fixed_path=False):"
            },
            "39": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 377,
                "PatchRowcode": "     \"\"\""
            },
            "40": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 378,
                "PatchRowcode": "     This function is used to iterate through the utilities and set the"
            },
            "41": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "     default binary path."
            },
            "42": {
                "beforePatchRowNumber": 394,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "                         if path_with_dir is not None else binary_path"
            },
            "43": {
                "beforePatchRowNumber": 395,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "                     if set_as_default:"
            },
            "44": {
                "beforePatchRowNumber": 396,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "                         path['isDefault'] = True"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+                    # Whether the fixed path in the config file exists or not"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+                    path['isFixed'] = is_fixed_path"
            },
            "47": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "                     break"
            },
            "48": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             break"
            },
            "49": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "         except Exception:"
            }
        },
        "frontPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import os",
            "import sys",
            "import json",
            "import subprocess",
            "from collections import defaultdict",
            "from operator import attrgetter",
            "",
            "from flask import Blueprint, current_app, url_for",
            "from flask_babel import gettext",
            "from flask_security import current_user, login_required",
            "from flask_security.utils import get_post_login_redirect, \\",
            "    get_post_logout_redirect",
            "from threading import Lock",
            "",
            "from .paths import get_storage_directory",
            "from .preferences import Preferences",
            "from pgadmin.utils.constants import UTILITIES_ARRAY, USER_NOT_FOUND, \\",
            "    MY_STORAGE, ACCESS_DENIED_MESSAGE, INTERNAL",
            "from pgadmin.utils.ajax import make_json_response",
            "from pgadmin.model import db, User, ServerGroup, Server",
            "from urllib.parse import unquote",
            "",
            "ADD_SERVERS_MSG = \"Added %d Server Group(s) and %d Server(s).\"",
            "",
            "",
            "class PgAdminModule(Blueprint):",
            "    \"\"\"",
            "    Base class for every PgAdmin Module.",
            "",
            "    This class defines a set of method and attributes that",
            "    every module should implement.",
            "    \"\"\"",
            "",
            "    def __init__(self, name, import_name, **kwargs):",
            "        kwargs.setdefault('url_prefix', '/' + name)",
            "        kwargs.setdefault('template_folder', 'templates')",
            "        kwargs.setdefault('static_folder', 'static')",
            "        self.submodules = []",
            "        self.parentmodules = []",
            "",
            "        super().__init__(name, import_name, **kwargs)",
            "",
            "    def register_preferences(self):",
            "        # To be implemented by child classes",
            "        pass",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "",
            "        super().register(app, options)",
            "",
            "        def create_module_preference():",
            "            # Create preference for each module by default",
            "            if hasattr(self, 'LABEL'):",
            "                self.preference = Preferences(self.name, self.LABEL)",
            "            else:",
            "                self.preference = Preferences(self.name, None)",
            "",
            "            self.register_preferences()",
            "",
            "        # Create and register the module preference object and preferences for",
            "        # it just before starting app",
            "        app.register_before_app_start(create_module_preference)",
            "",
            "        for module in self.submodules:",
            "            module.parentmodules.append(self)",
            "            if app.blueprints.get(module.name) is None:",
            "                app.register_blueprint(module)",
            "                app.register_logout_hook(module)",
            "",
            "    def get_own_messages(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the i18n messages used by this module, not including any",
            "                messages needed by the submodules.",
            "        \"\"\"",
            "        return dict()",
            "",
            "    def get_own_menuitems(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the menuitems for this module, not including",
            "                any needed from the submodules.",
            "        \"\"\"",
            "        return defaultdict(list)",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    def messages(self):",
            "        res = self.get_own_messages()",
            "",
            "        for module in self.submodules:",
            "            res.update(module.messages)",
            "        return res",
            "",
            "    @property",
            "    def menu_items(self):",
            "        menu_items = self.get_own_menuitems()",
            "        for module in self.submodules:",
            "            for key, value in module.menu_items.items():",
            "                menu_items[key].extend(value)",
            "        menu_items = dict((key, sorted(value, key=attrgetter('priority')))",
            "                          for key, value in menu_items.items())",
            "        return menu_items",
            "",
            "    @property",
            "    def exposed_endpoints(self):",
            "        res = self.get_exposed_url_endpoints()",
            "",
            "        for module in self.submodules:",
            "            res += module.exposed_endpoints",
            "",
            "        return res",
            "",
            "",
            "IS_WIN = (os.name == 'nt')",
            "",
            "sys_encoding = sys.getdefaultencoding()",
            "if not sys_encoding or sys_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the default encoding,",
            "    # or 'ascii'.",
            "    sys_encoding = 'utf-8'",
            "",
            "fs_encoding = sys.getfilesystemencoding()",
            "if not fs_encoding or fs_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the file-system encoding,",
            "    # or 'ascii'.",
            "    fs_encoding = 'utf-8'",
            "",
            "",
            "def u_encode(_s, _encoding=sys_encoding):",
            "    return _s",
            "",
            "",
            "def file_quote(_p):",
            "    return _p",
            "",
            "",
            "if IS_WIN:",
            "    import ctypes",
            "    from ctypes import wintypes",
            "",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    _GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW",
            "    _GetShortPathNameW.argtypes = [",
            "        wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD",
            "    ]",
            "    _GetShortPathNameW.restype = wintypes.DWORD",
            "",
            "    def fs_short_path(_path):",
            "        \"\"\"",
            "        Gets the short path name of a given long path.",
            "        http://stackoverflow.com/a/23598461/200291",
            "        \"\"\"",
            "        buf_size = len(_path)",
            "        while True:",
            "            res = ctypes.create_unicode_buffer(buf_size)",
            "            # Note:- _GetShortPathNameW may return empty value",
            "            # if directory doesn't exist.",
            "            needed = _GetShortPathNameW(_path, res, buf_size)",
            "",
            "            if buf_size >= needed:",
            "                return res.value",
            "            else:",
            "                buf_size += needed",
            "",
            "    def document_dir():",
            "        CSIDL_PERSONAL = 5  # My Documents",
            "        SHGFP_TYPE_CURRENT = 0  # Get current, not default value",
            "",
            "        buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)",
            "        ctypes.windll.shell32.SHGetFolderPathW(",
            "            None, CSIDL_PERSONAL, None, SHGFP_TYPE_CURRENT, buf",
            "        )",
            "",
            "        return buf.value",
            "",
            "else:",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    def fs_short_path(_path):",
            "        return _path",
            "",
            "    def document_dir():",
            "        return os.path.realpath(os.path.expanduser('~/'))",
            "",
            "",
            "def get_complete_file_path(file, validate=True):",
            "    \"\"\"",
            "    Args:",
            "        file: File returned by file manager",
            "",
            "    Returns:",
            "         Full path for the file",
            "    \"\"\"",
            "    if not file:",
            "        return None",
            "",
            "    # If desktop mode",
            "    if current_app.PGADMIN_RUNTIME or not current_app.config['SERVER_MODE']:",
            "        return file if os.path.isfile(file) else None",
            "",
            "    storage_dir = get_storage_directory()",
            "    if storage_dir:",
            "        file = os.path.join(",
            "            storage_dir,",
            "            file.lstrip('/').lstrip('\\\\')",
            "        )",
            "        if IS_WIN:",
            "            file = file.replace('\\\\', '/')",
            "            file = fs_short_path(file)",
            "",
            "    if validate:",
            "        return file if os.path.isfile(file) else None",
            "    else:",
            "        return file",
            "",
            "",
            "def filename_with_file_manager_path(_file, create_file=False,",
            "                                    skip_permission_check=False):",
            "    \"\"\"",
            "    Args:",
            "        file: File name returned from client file manager",
            "        create_file: Set flag to False when file creation doesn't require",
            "        skip_permission_check:",
            "    Returns:",
            "        Filename to use for backup with full path taken from preference",
            "    \"\"\"",
            "    # retrieve storage directory path",
            "    try:",
            "        last_storage = Preferences.module('file_manager').preference(",
            "            'last_storage').get()",
            "    except Exception:",
            "        last_storage = MY_STORAGE",
            "",
            "    if last_storage != MY_STORAGE:",
            "        sel_dir_list = [sdir for sdir in current_app.config['SHARED_STORAGE']",
            "                        if sdir['name'] == last_storage]",
            "        selected_dir = sel_dir_list[0] if len(",
            "            sel_dir_list) == 1 else None",
            "",
            "        if selected_dir and selected_dir['restricted_access'] and \\",
            "                not current_user.has_role(\"Administrator\"):",
            "            return make_json_response(success=0,",
            "                                      errormsg=ACCESS_DENIED_MESSAGE,",
            "                                      info='ACCESS_DENIED',",
            "                                      status=403)",
            "        storage_dir = get_storage_directory(",
            "            shared_storage=last_storage)",
            "    else:",
            "        storage_dir = get_storage_directory()",
            "",
            "    from pgadmin.misc.file_manager import Filemanager",
            "    Filemanager.check_access_permission(",
            "        storage_dir, _file, skip_permission_check)",
            "    if storage_dir:",
            "        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))",
            "    elif not os.path.isabs(_file):",
            "        _file = os.path.join(document_dir(), _file)",
            "",
            "    def short_filepath():",
            "        short_path = fs_short_path(_file)",
            "        # fs_short_path() function may return empty path on Windows",
            "        # if directory doesn't exists. In that case we strip the last path",
            "        # component and get the short path.",
            "        if os.name == 'nt' and short_path == '':",
            "            base_name = os.path.basename(_file)",
            "            dir_name = os.path.dirname(_file)",
            "            short_path = fs_short_path(dir_name) + '\\\\' + base_name",
            "        return short_path",
            "",
            "    if create_file:",
            "        # Touch the file to get the short path of the file on windows.",
            "        with open(_file, 'a'):",
            "            return short_filepath()",
            "",
            "    return short_filepath()",
            "",
            "",
            "def does_utility_exist(file):",
            "    \"\"\"",
            "    This function will check the utility file exists on given path.",
            "    :return:",
            "    \"\"\"",
            "    error_msg = None",
            "    if file is None:",
            "        error_msg = gettext(\"Utility file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\")",
            "        return error_msg",
            "",
            "    if not os.path.exists(file):",
            "        error_msg = gettext(\"'%s' file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\" % file)",
            "    return error_msg",
            "",
            "",
            "def get_server(sid):",
            "    \"\"\"",
            "    # Fetch the server  etc",
            "    :param sid:",
            "    :return: server",
            "    \"\"\"",
            "    server = Server.query.filter_by(id=sid).first()",
            "    return server",
            "",
            "",
            "def get_binary_path_versions(binary_path: str) -> dict:",
            "    ret = {}",
            "    binary_path = os.path.abspath(",
            "        replace_binary_path(binary_path)",
            "    )",
            "",
            "    for utility in UTILITIES_ARRAY:",
            "        ret[utility] = None",
            "        full_path = os.path.join(binary_path,",
            "                                 (utility if os.name != 'nt' else",
            "                                  (utility + '.exe')))",
            "",
            "        try:",
            "            # if path doesn't exist raise exception",
            "            if not os.path.isdir(binary_path):",
            "                current_app.logger.warning('Invalid binary path.')",
            "                raise Exception()",
            "            # Get the output of the '--version' command",
            "            cmd = subprocess.run(",
            "                [full_path, '--version'],",
            "                shell=False,",
            "                capture_output=True,",
            "                text=True",
            "            )",
            "            if cmd.returncode == 0:",
            "                ret[utility] = cmd.stdout.split(\") \", 1)[1].strip()",
            "            else:",
            "                raise Exception()",
            "        except Exception as _:",
            "            continue",
            "",
            "    return ret",
            "",
            "",
            "def set_binary_path(binary_path, bin_paths, server_type,",
            "                    version_number=None, set_as_default=False):",
            "    \"\"\"",
            "    This function is used to iterate through the utilities and set the",
            "    default binary path.",
            "    \"\"\"",
            "    path_with_dir = binary_path if \"$DIR\" in binary_path else None",
            "    binary_versions = get_binary_path_versions(binary_path)",
            "",
            "    for utility, version in binary_versions.items():",
            "        version_number = version if version_number is None else version_number",
            "        # version will be None if binary not present",
            "        version_number = version_number or ''",
            "        if version_number.find('.'):",
            "            version_number = version_number.split('.', 1)[0]",
            "        try:",
            "            # Get the paths array based on server type",
            "            if 'pg_bin_paths' in bin_paths or 'as_bin_paths' in bin_paths:",
            "                paths_array = bin_paths['pg_bin_paths']",
            "                if server_type == 'ppas':",
            "                    paths_array = bin_paths['as_bin_paths']",
            "            else:",
            "                paths_array = bin_paths",
            "",
            "            for path in paths_array:",
            "                if path['version'].find(version_number) == 0 and \\",
            "                        path['binaryPath'] is None:",
            "                    path['binaryPath'] = path_with_dir \\",
            "                        if path_with_dir is not None else binary_path",
            "                    if set_as_default:",
            "                        path['isDefault'] = True",
            "                    break",
            "            break",
            "        except Exception:",
            "            continue",
            "",
            "",
            "def replace_binary_path(binary_path):",
            "    \"\"\"",
            "    This function is used to check if $DIR is present in",
            "    the binary path. If it is there then replace it with",
            "    module.",
            "    \"\"\"",
            "    if \"$DIR\" in binary_path:",
            "        # When running as an WSGI application, we will not find the",
            "        # '__file__' attribute for the '__main__' module.",
            "        main_module_file = getattr(",
            "            sys.modules['__main__'], '__file__', None",
            "        )",
            "",
            "        if main_module_file is not None:",
            "            binary_path = binary_path.replace(",
            "                \"$DIR\", os.path.dirname(main_module_file)",
            "            )",
            "",
            "    return binary_path",
            "",
            "",
            "def add_value(attr_dict, key, value):",
            "    \"\"\"Add a value to the attribute dict if non-empty.",
            "",
            "    Args:",
            "        attr_dict (dict): The dictionary to add the values to",
            "        key (str): The key for the new value",
            "        value (str): The value to add",
            "",
            "    Returns:",
            "        The updated attribute dictionary",
            "    \"\"\"",
            "    if value != \"\" and value is not None:",
            "        attr_dict[key] = value",
            "",
            "    return attr_dict",
            "",
            "",
            "def dump_database_servers(output_file, selected_servers,",
            "                          dump_user=current_user, from_setup=False,",
            "                          auth_source=INTERNAL):",
            "    \"\"\"Dump the server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(dump_user, from_setup, auth_source)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % dump_user",
            "",
            "    user_id = user.id",
            "    # Dict to collect the output",
            "    object_dict = {}",
            "    # Counters",
            "    servers_dumped = 0",
            "",
            "    # Dump servers",
            "    servers = Server.query.filter_by(user_id=user_id).all()",
            "    server_dict = {}",
            "    for server in servers:",
            "        if selected_servers is None or (",
            "            isinstance(selected_servers, list) and len(selected_servers) == 0)\\",
            "                or str(server.id) in selected_servers\\",
            "                or server.id in selected_servers:",
            "            # Get the group name",
            "            group_name = ServerGroup.query.filter_by(",
            "                user_id=user_id, id=server.servergroup_id).first().name",
            "",
            "            attr_dict = {}",
            "            add_value(attr_dict, \"Name\", server.name)",
            "            add_value(attr_dict, \"Group\", group_name)",
            "            add_value(attr_dict, \"Host\", server.host)",
            "            add_value(attr_dict, \"Port\", server.port)",
            "            add_value(attr_dict, \"MaintenanceDB\", server.maintenance_db)",
            "            add_value(attr_dict, \"Username\", server.username)",
            "            add_value(attr_dict, \"Role\", server.role)",
            "            add_value(attr_dict, \"Comment\", server.comment)",
            "            add_value(attr_dict, \"Shared\", server.shared)",
            "            add_value(attr_dict, \"SharedUsername\", server.shared_username)",
            "            add_value(attr_dict, \"DBRestriction\", server.db_res)",
            "            add_value(attr_dict, \"BGColor\", server.bgcolor)",
            "            add_value(attr_dict, \"FGColor\", server.fgcolor)",
            "            add_value(attr_dict, \"Service\", server.service)",
            "            add_value(attr_dict, \"UseSSHTunnel\", server.use_ssh_tunnel)",
            "            add_value(attr_dict, \"TunnelHost\", server.tunnel_host)",
            "            add_value(attr_dict, \"TunnelPort\", server.tunnel_port)",
            "            add_value(attr_dict, \"TunnelUsername\", server.tunnel_username)",
            "            add_value(attr_dict, \"TunnelAuthentication\",",
            "                      server.tunnel_authentication)",
            "            add_value(attr_dict, \"KerberosAuthentication\",",
            "                      server.kerberos_conn),",
            "            add_value(attr_dict, \"ConnectionParameters\",",
            "                      server.connection_params)",
            "",
            "            # if desktop mode or server mode with",
            "            # ENABLE_SERVER_PASS_EXEC_CMD flag is True",
            "            if not current_app.config['SERVER_MODE'] or \\",
            "                    current_app.config['ENABLE_SERVER_PASS_EXEC_CMD']:",
            "                add_value(attr_dict, \"PasswordExecCommand\",",
            "                          server.passexec_cmd)",
            "                add_value(attr_dict, \"PasswordExecExpiration\",",
            "                          server.passexec_expiration)",
            "",
            "            servers_dumped = servers_dumped + 1",
            "",
            "            server_dict[servers_dumped] = attr_dict",
            "",
            "    object_dict[\"Servers\"] = server_dict",
            "",
            "    try:",
            "        if from_setup:",
            "            file_path = unquote(output_file)",
            "        else:",
            "            file_path = filename_with_file_manager_path(unquote(output_file))",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    # write to file",
            "    file_content = json.dumps(object_dict, indent=4)",
            "    error_str = \"Error: {0}\"",
            "    try:",
            "        with open(file_path, 'w') as output_file:",
            "            output_file.write(file_content)",
            "    except IOError as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "    except Exception as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "",
            "    msg = gettext(\"Configuration for %s servers dumped to %s\" %",
            "                  (servers_dumped, output_file.name))",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def validate_json_data(data, is_admin):",
            "    \"\"\"",
            "    Used internally by load_servers to validate servers data.",
            "    :param data: servers data",
            "    :param is_admin:",
            "    :return: error message if any",
            "    \"\"\"",
            "    skip_servers = []",
            "    # Loop through the servers...",
            "    if \"Servers\" not in data:",
            "        return gettext(\"'Servers' attribute not found in the specified file.\")",
            "",
            "    for server in data[\"Servers\"]:",
            "        obj = data[\"Servers\"][server]",
            "",
            "        # Check if server is shared.Won't import if user is non-admin",
            "        if obj.get('Shared', None) and not is_admin:",
            "            print(\"Won't import the server '%s' as it is shared \" %",
            "                  obj[\"Name\"])",
            "            skip_servers.append(server)",
            "            continue",
            "",
            "        def check_attrib(attrib):",
            "            if attrib not in obj:",
            "                return gettext(\"'%s' attribute not found for server '%s'\" %",
            "                               (attrib, server))",
            "            return None",
            "",
            "        def check_is_integer(value):",
            "            if not isinstance(value, int):",
            "                return gettext(\"Port must be integer for server '%s'\" % server)",
            "            return None",
            "",
            "        for attrib in (\"Group\", \"Name\"):",
            "            errmsg = check_attrib(attrib)",
            "            if errmsg:",
            "                return errmsg",
            "",
            "        is_service_attrib_available = obj.get(\"Service\", None) is not None",
            "",
            "        if not is_service_attrib_available:",
            "            for attrib in (\"Port\", \"Username\"):",
            "                errmsg = check_attrib(attrib)",
            "                if errmsg:",
            "                    return errmsg",
            "                if attrib == 'Port':",
            "                    errmsg = check_is_integer(obj[attrib])",
            "                    if errmsg:",
            "                        return errmsg",
            "",
            "        errmsg = check_attrib(\"MaintenanceDB\")",
            "        if errmsg:",
            "            return errmsg",
            "",
            "        if \"Host\" not in obj and not is_service_attrib_available:",
            "            return gettext(\"'Host' or 'Service' attribute not \"",
            "                           \"found for server '%s'\" % server)",
            "",
            "    for server in skip_servers:",
            "        del data[\"Servers\"][server]",
            "    return None",
            "",
            "",
            "def load_database_servers(input_file, selected_servers,",
            "                          load_user=current_user, from_setup=False,",
            "                          auth_source=INTERNAL):",
            "    \"\"\"Load server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup, auth_source)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % load_user",
            "",
            "    # generate full path of file",
            "    try:",
            "        if from_setup:",
            "            file_path = unquote(input_file)",
            "        else:",
            "            file_path = filename_with_file_manager_path(unquote(input_file))",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    try:",
            "        with open(file_path) as f:",
            "            data = json.load(f)",
            "    except json.decoder.JSONDecodeError as e:",
            "        return _handle_error(gettext(\"Error parsing input file %s: %s\" %",
            "                             (file_path, e)), from_setup)",
            "    except Exception as e:",
            "        return _handle_error(gettext(\"Error reading input file %s: [%d] %s\" %",
            "                             (file_path, e.errno, e.strerror)), from_setup)",
            "",
            "    f.close()",
            "",
            "    user_id = user.id",
            "    # Counters",
            "    groups_added = 0",
            "    servers_added = 0",
            "",
            "    # Get the server groups",
            "    groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "    # Validate server data",
            "    error_msg = validate_json_data(data, user.has_role(\"Administrator\"))",
            "    if error_msg is not None and from_setup:",
            "        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "        return _handle_error(error_msg, from_setup)",
            "",
            "    for server in data[\"Servers\"]:",
            "        if selected_servers is None or str(server) in selected_servers:",
            "            obj = data[\"Servers\"][server]",
            "",
            "            # Get the group. Create if necessary",
            "            group_id = next(",
            "                (g.id for g in groups if g.name == obj[\"Group\"]), -1)",
            "",
            "            if group_id == -1:",
            "                new_group = ServerGroup()",
            "                new_group.name = obj[\"Group\"]",
            "                new_group.user_id = user_id",
            "                db.session.add(new_group)",
            "",
            "                try:",
            "                    db.session.commit()",
            "                except Exception as e:",
            "                    if from_setup:",
            "                        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                    return _handle_error(",
            "                        gettext(\"Error creating server group '%s': %s\" %",
            "                                (new_group.name, e)), from_setup)",
            "",
            "                group_id = new_group.id",
            "                groups_added = groups_added + 1",
            "                groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "            # Create the server",
            "            new_server = Server()",
            "            new_server.name = obj[\"Name\"]",
            "            new_server.servergroup_id = group_id",
            "            new_server.user_id = user_id",
            "            new_server.maintenance_db = obj[\"MaintenanceDB\"]",
            "",
            "            new_server.host = obj.get(\"Host\", None)",
            "",
            "            new_server.port = obj.get(\"Port\", None)",
            "",
            "            new_server.username = obj.get(\"Username\", None)",
            "",
            "            new_server.role = obj.get(\"Role\", None)",
            "",
            "            new_server.comment = obj.get(\"Comment\", None)",
            "",
            "            new_server.db_res = obj.get(\"DBRestriction\", None)",
            "",
            "            if 'ConnectionParameters' in obj:",
            "                new_server.connection_params = \\",
            "                    obj.get(\"ConnectionParameters\", None)",
            "            else:",
            "                # JSON file format is old before introduction of the",
            "                # connection parameters.",
            "                conn_param = dict()",
            "                for item in ['HostAddr', 'SSLMode', 'PassFile', 'SSLCert',",
            "                             'SSLKey', 'SSLRootCert', 'SSLCrl', 'Timeout',",
            "                             'SSLCompression']:",
            "                    if item in obj:",
            "                        key = item.lower()",
            "                        if item == 'Timeout':",
            "                            key = 'connect_timeout'",
            "                        conn_param[key] = obj.get(item)",
            "",
            "                new_server.connection_params = conn_param",
            "",
            "            new_server.bgcolor = obj.get(\"BGColor\", None)",
            "",
            "            new_server.fgcolor = obj.get(\"FGColor\", None)",
            "",
            "            new_server.service = obj.get(\"Service\", None)",
            "",
            "            new_server.use_ssh_tunnel = obj.get(\"UseSSHTunnel\", None)",
            "",
            "            new_server.tunnel_host = obj.get(\"TunnelHost\", None)",
            "",
            "            new_server.tunnel_port = obj.get(\"TunnelPort\", None)",
            "",
            "            new_server.tunnel_username = obj.get(\"TunnelUsername\", None)",
            "",
            "            new_server.tunnel_authentication = \\",
            "                obj.get(\"TunnelAuthentication\", None)",
            "",
            "            new_server.shared = obj.get(\"Shared\", None)",
            "",
            "            new_server.shared_username = obj.get(\"SharedUsername\", None)",
            "",
            "            new_server.kerberos_conn = obj.get(\"KerberosAuthentication\", None)",
            "",
            "            # if desktop mode or server mode with",
            "            # ENABLE_SERVER_PASS_EXEC_CMD flag is True",
            "            if not current_app.config['SERVER_MODE'] or \\",
            "                    current_app.config['ENABLE_SERVER_PASS_EXEC_CMD']:",
            "                new_server.passexec_cmd = obj.get(\"PasswordExecCommand\", None)",
            "                new_server.passexec_expiration = obj.get(",
            "                    \"PasswordExecExpiration\", None)",
            "",
            "            db.session.add(new_server)",
            "",
            "            try:",
            "                db.session.commit()",
            "            except Exception as e:",
            "                if from_setup:",
            "                    print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                return _handle_error(gettext(\"Error creating server '%s': %s\" %",
            "                                             (new_server.name, e)), from_setup)",
            "",
            "            servers_added = servers_added + 1",
            "",
            "    msg = ADD_SERVERS_MSG % (groups_added, servers_added)",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def clear_database_servers(load_user=current_user, from_setup=False,",
            "                           auth_source=INTERNAL):",
            "    \"\"\"Clear groups and servers configurations.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup, auth_source)",
            "    if user is None:",
            "        return False",
            "",
            "    user_id = user.id",
            "",
            "    # Remove all servers",
            "    servers = Server.query.filter_by(user_id=user_id)",
            "    for server in servers:",
            "        db.session.delete(server)",
            "",
            "    # Remove all servergroups except for the first",
            "    # This matches the UI behavior in",
            "    # web/pgadmin/browser/server_groups/__init__.py#delete",
            "    # TODO: Investigate if we can skip the first with an `offset(1)`",
            "    groups = ServerGroup.query.filter_by(user_id=user_id).order_by(\"id\")",
            "    default_sg = groups.first()",
            "    for group in groups:",
            "        if group.id != default_sg.id:",
            "            db.session.delete(group)",
            "",
            "    try:",
            "        db.session.commit()",
            "    except Exception as e:",
            "        error_msg = \\",
            "            gettext(\"Error clearing server configuration with error (%s)\" %",
            "                    str(e))",
            "        if from_setup:",
            "            print(error_msg)",
            "            sys.exit(1)",
            "",
            "        return False, error_msg",
            "",
            "",
            "def _does_user_exist(user, from_setup, auth_source=INTERNAL):",
            "    \"\"\"",
            "    This function will check user is exist or not. If exist then return",
            "    \"\"\"",
            "    if isinstance(user, User):",
            "        auth_source = user.auth_source",
            "        user = user.username",
            "",
            "    new_user = User.query.filter_by(username=user,",
            "                                    auth_source=auth_source).first()",
            "",
            "    if new_user is None:",
            "        print(USER_NOT_FOUND % user)",
            "        if from_setup:",
            "            sys.exit(1)",
            "",
            "    return new_user",
            "",
            "",
            "def _handle_error(error_msg, from_setup):",
            "    \"\"\"",
            "    This function is used to print the error msg and exit from app if",
            "    called from setup.py",
            "    \"\"\"",
            "    if from_setup:",
            "        print(error_msg)",
            "        sys.exit(1)",
            "",
            "    return False, error_msg",
            "",
            "",
            "# Shortcut configuration for Accesskey",
            "ACCESSKEY_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    }",
            "]",
            "",
            "# Shortcut configuration",
            "SHORTCUT_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    },",
            "    {",
            "        'name': 'shift',",
            "        'type': 'checkbox',",
            "        'label': gettext('Shift')",
            "    },",
            "",
            "    {",
            "        'name': 'control',",
            "        'type': 'checkbox',",
            "        'label': gettext('Ctrl')",
            "    },",
            "    {",
            "        'name': 'alt',",
            "        'type': 'checkbox',",
            "        'label': gettext('Alt/Option')",
            "    }",
            "]",
            "",
            "",
            "class KeyManager:",
            "    def __init__(self):",
            "        self.users = dict()",
            "        self.lock = Lock()",
            "",
            "    @login_required",
            "    def get(self):",
            "        user = self.users.get(current_user.id, None)",
            "        if user is not None:",
            "            return user.get('key', None)",
            "",
            "    @login_required",
            "    def set(self, _key, _new_login=True):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "            if user is None:",
            "                self.users[current_user.id] = dict(",
            "                    session_count=1, key=_key)",
            "            else:",
            "                if _new_login:",
            "                    user['session_count'] += 1",
            "                user['key'] = _key",
            "",
            "    @login_required",
            "    def reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                # This will not decrement if session expired",
            "                user['session_count'] -= 1",
            "                if user['session_count'] == 0:",
            "                    del self.users[current_user.id]",
            "",
            "    @login_required",
            "    def hard_reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                del self.users[current_user.id]",
            "",
            "",
            "def get_safe_post_login_redirect():",
            "    allow_list = [",
            "        url_for('browser.index')",
            "    ]",
            "    if \"SCRIPT_NAME\" in os.environ and os.environ[\"SCRIPT_NAME\"]:",
            "        allow_list.append(os.environ[\"SCRIPT_NAME\"])",
            "",
            "    url = get_post_login_redirect()",
            "    for item in allow_list:",
            "        if url.startswith(item):",
            "            return url",
            "",
            "    return url_for('browser.index')",
            "",
            "",
            "def get_safe_post_logout_redirect():",
            "    allow_list = [",
            "        url_for('security.login')",
            "    ]",
            "    if \"SCRIPT_NAME\" in os.environ and os.environ[\"SCRIPT_NAME\"]:",
            "        allow_list.append(os.environ[\"SCRIPT_NAME\"])",
            "    url = get_post_logout_redirect()",
            "    for item in allow_list:",
            "        if url.startswith(item):",
            "            return url",
            "    return url_for('security.login')"
        ],
        "afterPatchFile": [
            "##########################################################################",
            "#",
            "# pgAdmin 4 - PostgreSQL Tools",
            "#",
            "# Copyright (C) 2013 - 2024, The pgAdmin Development Team",
            "# This software is released under the PostgreSQL Licence",
            "#",
            "##########################################################################",
            "",
            "import os",
            "import sys",
            "import json",
            "import subprocess",
            "from collections import defaultdict",
            "from operator import attrgetter",
            "",
            "from pathlib import Path",
            "from flask import Blueprint, current_app, url_for",
            "from flask_babel import gettext",
            "from flask_security import current_user, login_required",
            "from flask_security.utils import get_post_login_redirect, \\",
            "    get_post_logout_redirect",
            "from threading import Lock",
            "import config",
            "from .paths import get_storage_directory",
            "from .preferences import Preferences",
            "from pgadmin.utils.constants import UTILITIES_ARRAY, USER_NOT_FOUND, \\",
            "    MY_STORAGE, ACCESS_DENIED_MESSAGE, INTERNAL",
            "from pgadmin.utils.ajax import make_json_response",
            "from pgadmin.model import db, User, ServerGroup, Server",
            "from urllib.parse import unquote",
            "",
            "ADD_SERVERS_MSG = \"Added %d Server Group(s) and %d Server(s).\"",
            "",
            "",
            "class PgAdminModule(Blueprint):",
            "    \"\"\"",
            "    Base class for every PgAdmin Module.",
            "",
            "    This class defines a set of method and attributes that",
            "    every module should implement.",
            "    \"\"\"",
            "",
            "    def __init__(self, name, import_name, **kwargs):",
            "        kwargs.setdefault('url_prefix', '/' + name)",
            "        kwargs.setdefault('template_folder', 'templates')",
            "        kwargs.setdefault('static_folder', 'static')",
            "        self.submodules = []",
            "        self.parentmodules = []",
            "",
            "        super().__init__(name, import_name, **kwargs)",
            "",
            "    def register_preferences(self):",
            "        # To be implemented by child classes",
            "        pass",
            "",
            "    def register(self, app, options):",
            "        \"\"\"",
            "        Override the default register function to automagically register",
            "        sub-modules at once.",
            "        \"\"\"",
            "",
            "        super().register(app, options)",
            "",
            "        def create_module_preference():",
            "            # Create preference for each module by default",
            "            if hasattr(self, 'LABEL'):",
            "                self.preference = Preferences(self.name, self.LABEL)",
            "            else:",
            "                self.preference = Preferences(self.name, None)",
            "",
            "            self.register_preferences()",
            "",
            "        # Create and register the module preference object and preferences for",
            "        # it just before starting app",
            "        app.register_before_app_start(create_module_preference)",
            "",
            "        for module in self.submodules:",
            "            module.parentmodules.append(self)",
            "            if app.blueprints.get(module.name) is None:",
            "                app.register_blueprint(module)",
            "                app.register_logout_hook(module)",
            "",
            "    def get_own_messages(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the i18n messages used by this module, not including any",
            "                messages needed by the submodules.",
            "        \"\"\"",
            "        return dict()",
            "",
            "    def get_own_menuitems(self):",
            "        \"\"\"",
            "        Returns:",
            "            dict: the menuitems for this module, not including",
            "                any needed from the submodules.",
            "        \"\"\"",
            "        return defaultdict(list)",
            "",
            "    def get_exposed_url_endpoints(self):",
            "        \"\"\"",
            "        Returns:",
            "            list: a list of url endpoints exposed to the client.",
            "        \"\"\"",
            "        return []",
            "",
            "    @property",
            "    def messages(self):",
            "        res = self.get_own_messages()",
            "",
            "        for module in self.submodules:",
            "            res.update(module.messages)",
            "        return res",
            "",
            "    @property",
            "    def menu_items(self):",
            "        menu_items = self.get_own_menuitems()",
            "        for module in self.submodules:",
            "            for key, value in module.menu_items.items():",
            "                menu_items[key].extend(value)",
            "        menu_items = dict((key, sorted(value, key=attrgetter('priority')))",
            "                          for key, value in menu_items.items())",
            "        return menu_items",
            "",
            "    @property",
            "    def exposed_endpoints(self):",
            "        res = self.get_exposed_url_endpoints()",
            "",
            "        for module in self.submodules:",
            "            res += module.exposed_endpoints",
            "",
            "        return res",
            "",
            "",
            "IS_WIN = (os.name == 'nt')",
            "",
            "sys_encoding = sys.getdefaultencoding()",
            "if not sys_encoding or sys_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the default encoding,",
            "    # or 'ascii'.",
            "    sys_encoding = 'utf-8'",
            "",
            "fs_encoding = sys.getfilesystemencoding()",
            "if not fs_encoding or fs_encoding == 'ascii':",
            "    # Fall back to 'utf-8', if we couldn't determine the file-system encoding,",
            "    # or 'ascii'.",
            "    fs_encoding = 'utf-8'",
            "",
            "",
            "def u_encode(_s, _encoding=sys_encoding):",
            "    return _s",
            "",
            "",
            "def file_quote(_p):",
            "    return _p",
            "",
            "",
            "if IS_WIN:",
            "    import ctypes",
            "    from ctypes import wintypes",
            "",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    _GetShortPathNameW = ctypes.windll.kernel32.GetShortPathNameW",
            "    _GetShortPathNameW.argtypes = [",
            "        wintypes.LPCWSTR, wintypes.LPWSTR, wintypes.DWORD",
            "    ]",
            "    _GetShortPathNameW.restype = wintypes.DWORD",
            "",
            "    def fs_short_path(_path):",
            "        \"\"\"",
            "        Gets the short path name of a given long path.",
            "        http://stackoverflow.com/a/23598461/200291",
            "        \"\"\"",
            "        buf_size = len(_path)",
            "        while True:",
            "            res = ctypes.create_unicode_buffer(buf_size)",
            "            # Note:- _GetShortPathNameW may return empty value",
            "            # if directory doesn't exist.",
            "            needed = _GetShortPathNameW(_path, res, buf_size)",
            "",
            "            if buf_size >= needed:",
            "                return res.value",
            "            else:",
            "                buf_size += needed",
            "",
            "    def document_dir():",
            "        CSIDL_PERSONAL = 5  # My Documents",
            "        SHGFP_TYPE_CURRENT = 0  # Get current, not default value",
            "",
            "        buf = ctypes.create_unicode_buffer(wintypes.MAX_PATH)",
            "        ctypes.windll.shell32.SHGetFolderPathW(",
            "            None, CSIDL_PERSONAL, None, SHGFP_TYPE_CURRENT, buf",
            "        )",
            "",
            "        return buf.value",
            "",
            "else:",
            "    def env(name):",
            "        if name in os.environ:",
            "            return os.environ[name]",
            "        return None",
            "",
            "    def fs_short_path(_path):",
            "        return _path",
            "",
            "    def document_dir():",
            "        return os.path.realpath(os.path.expanduser('~/'))",
            "",
            "",
            "def get_complete_file_path(file, validate=True):",
            "    \"\"\"",
            "    Args:",
            "        file: File returned by file manager",
            "",
            "    Returns:",
            "         Full path for the file",
            "    \"\"\"",
            "    if not file:",
            "        return None",
            "",
            "    # If desktop mode",
            "    if current_app.PGADMIN_RUNTIME or not current_app.config['SERVER_MODE']:",
            "        return file if os.path.isfile(file) else None",
            "",
            "    storage_dir = get_storage_directory()",
            "    if storage_dir:",
            "        file = os.path.join(",
            "            storage_dir,",
            "            file.lstrip('/').lstrip('\\\\')",
            "        )",
            "        if IS_WIN:",
            "            file = file.replace('\\\\', '/')",
            "            file = fs_short_path(file)",
            "",
            "    if validate:",
            "        return file if os.path.isfile(file) else None",
            "    else:",
            "        return file",
            "",
            "",
            "def filename_with_file_manager_path(_file, create_file=False,",
            "                                    skip_permission_check=False):",
            "    \"\"\"",
            "    Args:",
            "        file: File name returned from client file manager",
            "        create_file: Set flag to False when file creation doesn't require",
            "        skip_permission_check:",
            "    Returns:",
            "        Filename to use for backup with full path taken from preference",
            "    \"\"\"",
            "    # retrieve storage directory path",
            "    try:",
            "        last_storage = Preferences.module('file_manager').preference(",
            "            'last_storage').get()",
            "    except Exception:",
            "        last_storage = MY_STORAGE",
            "",
            "    if last_storage != MY_STORAGE:",
            "        sel_dir_list = [sdir for sdir in current_app.config['SHARED_STORAGE']",
            "                        if sdir['name'] == last_storage]",
            "        selected_dir = sel_dir_list[0] if len(",
            "            sel_dir_list) == 1 else None",
            "",
            "        if selected_dir and selected_dir['restricted_access'] and \\",
            "                not current_user.has_role(\"Administrator\"):",
            "            return make_json_response(success=0,",
            "                                      errormsg=ACCESS_DENIED_MESSAGE,",
            "                                      info='ACCESS_DENIED',",
            "                                      status=403)",
            "        storage_dir = get_storage_directory(",
            "            shared_storage=last_storage)",
            "    else:",
            "        storage_dir = get_storage_directory()",
            "",
            "    from pgadmin.misc.file_manager import Filemanager",
            "    Filemanager.check_access_permission(",
            "        storage_dir, _file, skip_permission_check)",
            "    if storage_dir:",
            "        _file = os.path.join(storage_dir, _file.lstrip('/').lstrip('\\\\'))",
            "    elif not os.path.isabs(_file):",
            "        _file = os.path.join(document_dir(), _file)",
            "",
            "    def short_filepath():",
            "        short_path = fs_short_path(_file)",
            "        # fs_short_path() function may return empty path on Windows",
            "        # if directory doesn't exists. In that case we strip the last path",
            "        # component and get the short path.",
            "        if os.name == 'nt' and short_path == '':",
            "            base_name = os.path.basename(_file)",
            "            dir_name = os.path.dirname(_file)",
            "            short_path = fs_short_path(dir_name) + '\\\\' + base_name",
            "        return short_path",
            "",
            "    if create_file:",
            "        # Touch the file to get the short path of the file on windows.",
            "        with open(_file, 'a'):",
            "            return short_filepath()",
            "",
            "    return short_filepath()",
            "",
            "",
            "def does_utility_exist(file):",
            "    \"\"\"",
            "    This function will check the utility file exists on given path.",
            "    :return:",
            "    \"\"\"",
            "    error_msg = None",
            "",
            "    if file is None:",
            "        error_msg = gettext(\"Utility file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\")",
            "        return error_msg",
            "",
            "    if Path(config.STORAGE_DIR) == Path(file) or \\",
            "            Path(config.STORAGE_DIR) in Path(file).parents:",
            "        error_msg = gettext(\"Please correct the Binary Path in the Preferences\"",
            "                            \" dialog. pgAdmin storage directory can not be a\"",
            "                            \" utility binary directory.\")",
            "",
            "    if not os.path.exists(file):",
            "        error_msg = gettext(\"'%s' file not found. Please correct the Binary\"",
            "                            \" Path in the Preferences dialog\" % file)",
            "    return error_msg",
            "",
            "",
            "def get_server(sid):",
            "    \"\"\"",
            "    # Fetch the server  etc",
            "    :param sid:",
            "    :return: server",
            "    \"\"\"",
            "    server = Server.query.filter_by(id=sid).first()",
            "    return server",
            "",
            "",
            "def get_binary_path_versions(binary_path: str) -> dict:",
            "    ret = {}",
            "    binary_path = os.path.abspath(",
            "        replace_binary_path(binary_path)",
            "    )",
            "",
            "    for utility in UTILITIES_ARRAY:",
            "        ret[utility] = None",
            "        full_path = os.path.join(binary_path,",
            "                                 (utility if os.name != 'nt' else",
            "                                  (utility + '.exe')))",
            "",
            "        try:",
            "            # if path doesn't exist raise exception",
            "            if not os.path.isdir(binary_path):",
            "                current_app.logger.warning('Invalid binary path.')",
            "                raise Exception()",
            "            # Get the output of the '--version' command",
            "            cmd = subprocess.run(",
            "                [full_path, '--version'],",
            "                shell=False,",
            "                capture_output=True,",
            "                text=True",
            "            )",
            "            if cmd.returncode == 0:",
            "                ret[utility] = cmd.stdout.split(\") \", 1)[1].strip()",
            "            else:",
            "                raise Exception()",
            "        except Exception as _:",
            "            continue",
            "",
            "    return ret",
            "",
            "",
            "def set_binary_path(binary_path, bin_paths, server_type,",
            "                    version_number=None, set_as_default=False,",
            "                    is_fixed_path=False):",
            "    \"\"\"",
            "    This function is used to iterate through the utilities and set the",
            "    default binary path.",
            "    \"\"\"",
            "    path_with_dir = binary_path if \"$DIR\" in binary_path else None",
            "    binary_versions = get_binary_path_versions(binary_path)",
            "",
            "    for utility, version in binary_versions.items():",
            "        version_number = version if version_number is None else version_number",
            "        # version will be None if binary not present",
            "        version_number = version_number or ''",
            "        if version_number.find('.'):",
            "            version_number = version_number.split('.', 1)[0]",
            "        try:",
            "            # Get the paths array based on server type",
            "            if 'pg_bin_paths' in bin_paths or 'as_bin_paths' in bin_paths:",
            "                paths_array = bin_paths['pg_bin_paths']",
            "                if server_type == 'ppas':",
            "                    paths_array = bin_paths['as_bin_paths']",
            "            else:",
            "                paths_array = bin_paths",
            "",
            "            for path in paths_array:",
            "                if path['version'].find(version_number) == 0 and \\",
            "                        path['binaryPath'] is None:",
            "                    path['binaryPath'] = path_with_dir \\",
            "                        if path_with_dir is not None else binary_path",
            "                    if set_as_default:",
            "                        path['isDefault'] = True",
            "                    # Whether the fixed path in the config file exists or not",
            "                    path['isFixed'] = is_fixed_path",
            "                    break",
            "            break",
            "        except Exception:",
            "            continue",
            "",
            "",
            "def replace_binary_path(binary_path):",
            "    \"\"\"",
            "    This function is used to check if $DIR is present in",
            "    the binary path. If it is there then replace it with",
            "    module.",
            "    \"\"\"",
            "    if \"$DIR\" in binary_path:",
            "        # When running as an WSGI application, we will not find the",
            "        # '__file__' attribute for the '__main__' module.",
            "        main_module_file = getattr(",
            "            sys.modules['__main__'], '__file__', None",
            "        )",
            "",
            "        if main_module_file is not None:",
            "            binary_path = binary_path.replace(",
            "                \"$DIR\", os.path.dirname(main_module_file)",
            "            )",
            "",
            "    return binary_path",
            "",
            "",
            "def add_value(attr_dict, key, value):",
            "    \"\"\"Add a value to the attribute dict if non-empty.",
            "",
            "    Args:",
            "        attr_dict (dict): The dictionary to add the values to",
            "        key (str): The key for the new value",
            "        value (str): The value to add",
            "",
            "    Returns:",
            "        The updated attribute dictionary",
            "    \"\"\"",
            "    if value != \"\" and value is not None:",
            "        attr_dict[key] = value",
            "",
            "    return attr_dict",
            "",
            "",
            "def dump_database_servers(output_file, selected_servers,",
            "                          dump_user=current_user, from_setup=False,",
            "                          auth_source=INTERNAL):",
            "    \"\"\"Dump the server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(dump_user, from_setup, auth_source)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % dump_user",
            "",
            "    user_id = user.id",
            "    # Dict to collect the output",
            "    object_dict = {}",
            "    # Counters",
            "    servers_dumped = 0",
            "",
            "    # Dump servers",
            "    servers = Server.query.filter_by(user_id=user_id).all()",
            "    server_dict = {}",
            "    for server in servers:",
            "        if selected_servers is None or (",
            "            isinstance(selected_servers, list) and len(selected_servers) == 0)\\",
            "                or str(server.id) in selected_servers\\",
            "                or server.id in selected_servers:",
            "            # Get the group name",
            "            group_name = ServerGroup.query.filter_by(",
            "                user_id=user_id, id=server.servergroup_id).first().name",
            "",
            "            attr_dict = {}",
            "            add_value(attr_dict, \"Name\", server.name)",
            "            add_value(attr_dict, \"Group\", group_name)",
            "            add_value(attr_dict, \"Host\", server.host)",
            "            add_value(attr_dict, \"Port\", server.port)",
            "            add_value(attr_dict, \"MaintenanceDB\", server.maintenance_db)",
            "            add_value(attr_dict, \"Username\", server.username)",
            "            add_value(attr_dict, \"Role\", server.role)",
            "            add_value(attr_dict, \"Comment\", server.comment)",
            "            add_value(attr_dict, \"Shared\", server.shared)",
            "            add_value(attr_dict, \"SharedUsername\", server.shared_username)",
            "            add_value(attr_dict, \"DBRestriction\", server.db_res)",
            "            add_value(attr_dict, \"BGColor\", server.bgcolor)",
            "            add_value(attr_dict, \"FGColor\", server.fgcolor)",
            "            add_value(attr_dict, \"Service\", server.service)",
            "            add_value(attr_dict, \"UseSSHTunnel\", server.use_ssh_tunnel)",
            "            add_value(attr_dict, \"TunnelHost\", server.tunnel_host)",
            "            add_value(attr_dict, \"TunnelPort\", server.tunnel_port)",
            "            add_value(attr_dict, \"TunnelUsername\", server.tunnel_username)",
            "            add_value(attr_dict, \"TunnelAuthentication\",",
            "                      server.tunnel_authentication)",
            "            add_value(attr_dict, \"KerberosAuthentication\",",
            "                      server.kerberos_conn),",
            "            add_value(attr_dict, \"ConnectionParameters\",",
            "                      server.connection_params)",
            "",
            "            # if desktop mode or server mode with",
            "            # ENABLE_SERVER_PASS_EXEC_CMD flag is True",
            "            if not current_app.config['SERVER_MODE'] or \\",
            "                    current_app.config['ENABLE_SERVER_PASS_EXEC_CMD']:",
            "                add_value(attr_dict, \"PasswordExecCommand\",",
            "                          server.passexec_cmd)",
            "                add_value(attr_dict, \"PasswordExecExpiration\",",
            "                          server.passexec_expiration)",
            "",
            "            servers_dumped = servers_dumped + 1",
            "",
            "            server_dict[servers_dumped] = attr_dict",
            "",
            "    object_dict[\"Servers\"] = server_dict",
            "",
            "    try:",
            "        if from_setup:",
            "            file_path = unquote(output_file)",
            "        else:",
            "            file_path = filename_with_file_manager_path(unquote(output_file))",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    # write to file",
            "    file_content = json.dumps(object_dict, indent=4)",
            "    error_str = \"Error: {0}\"",
            "    try:",
            "        with open(file_path, 'w') as output_file:",
            "            output_file.write(file_content)",
            "    except IOError as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "    except Exception as e:",
            "        err_msg = error_str.format(e.strerror)",
            "        return _handle_error(err_msg, from_setup)",
            "",
            "    msg = gettext(\"Configuration for %s servers dumped to %s\" %",
            "                  (servers_dumped, output_file.name))",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def validate_json_data(data, is_admin):",
            "    \"\"\"",
            "    Used internally by load_servers to validate servers data.",
            "    :param data: servers data",
            "    :param is_admin:",
            "    :return: error message if any",
            "    \"\"\"",
            "    skip_servers = []",
            "    # Loop through the servers...",
            "    if \"Servers\" not in data:",
            "        return gettext(\"'Servers' attribute not found in the specified file.\")",
            "",
            "    for server in data[\"Servers\"]:",
            "        obj = data[\"Servers\"][server]",
            "",
            "        # Check if server is shared.Won't import if user is non-admin",
            "        if obj.get('Shared', None) and not is_admin:",
            "            print(\"Won't import the server '%s' as it is shared \" %",
            "                  obj[\"Name\"])",
            "            skip_servers.append(server)",
            "            continue",
            "",
            "        def check_attrib(attrib):",
            "            if attrib not in obj:",
            "                return gettext(\"'%s' attribute not found for server '%s'\" %",
            "                               (attrib, server))",
            "            return None",
            "",
            "        def check_is_integer(value):",
            "            if not isinstance(value, int):",
            "                return gettext(\"Port must be integer for server '%s'\" % server)",
            "            return None",
            "",
            "        for attrib in (\"Group\", \"Name\"):",
            "            errmsg = check_attrib(attrib)",
            "            if errmsg:",
            "                return errmsg",
            "",
            "        is_service_attrib_available = obj.get(\"Service\", None) is not None",
            "",
            "        if not is_service_attrib_available:",
            "            for attrib in (\"Port\", \"Username\"):",
            "                errmsg = check_attrib(attrib)",
            "                if errmsg:",
            "                    return errmsg",
            "                if attrib == 'Port':",
            "                    errmsg = check_is_integer(obj[attrib])",
            "                    if errmsg:",
            "                        return errmsg",
            "",
            "        errmsg = check_attrib(\"MaintenanceDB\")",
            "        if errmsg:",
            "            return errmsg",
            "",
            "        if \"Host\" not in obj and not is_service_attrib_available:",
            "            return gettext(\"'Host' or 'Service' attribute not \"",
            "                           \"found for server '%s'\" % server)",
            "",
            "    for server in skip_servers:",
            "        del data[\"Servers\"][server]",
            "    return None",
            "",
            "",
            "def load_database_servers(input_file, selected_servers,",
            "                          load_user=current_user, from_setup=False,",
            "                          auth_source=INTERNAL):",
            "    \"\"\"Load server groups and servers.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup, auth_source)",
            "    if user is None:",
            "        return False, USER_NOT_FOUND % load_user",
            "",
            "    # generate full path of file",
            "    try:",
            "        if from_setup:",
            "            file_path = unquote(input_file)",
            "        else:",
            "            file_path = filename_with_file_manager_path(unquote(input_file))",
            "    except Exception as e:",
            "        return _handle_error(str(e), from_setup)",
            "",
            "    try:",
            "        with open(file_path) as f:",
            "            data = json.load(f)",
            "    except json.decoder.JSONDecodeError as e:",
            "        return _handle_error(gettext(\"Error parsing input file %s: %s\" %",
            "                             (file_path, e)), from_setup)",
            "    except Exception as e:",
            "        return _handle_error(gettext(\"Error reading input file %s: [%d] %s\" %",
            "                             (file_path, e.errno, e.strerror)), from_setup)",
            "",
            "    f.close()",
            "",
            "    user_id = user.id",
            "    # Counters",
            "    groups_added = 0",
            "    servers_added = 0",
            "",
            "    # Get the server groups",
            "    groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "    # Validate server data",
            "    error_msg = validate_json_data(data, user.has_role(\"Administrator\"))",
            "    if error_msg is not None and from_setup:",
            "        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "        return _handle_error(error_msg, from_setup)",
            "",
            "    for server in data[\"Servers\"]:",
            "        if selected_servers is None or str(server) in selected_servers:",
            "            obj = data[\"Servers\"][server]",
            "",
            "            # Get the group. Create if necessary",
            "            group_id = next(",
            "                (g.id for g in groups if g.name == obj[\"Group\"]), -1)",
            "",
            "            if group_id == -1:",
            "                new_group = ServerGroup()",
            "                new_group.name = obj[\"Group\"]",
            "                new_group.user_id = user_id",
            "                db.session.add(new_group)",
            "",
            "                try:",
            "                    db.session.commit()",
            "                except Exception as e:",
            "                    if from_setup:",
            "                        print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                    return _handle_error(",
            "                        gettext(\"Error creating server group '%s': %s\" %",
            "                                (new_group.name, e)), from_setup)",
            "",
            "                group_id = new_group.id",
            "                groups_added = groups_added + 1",
            "                groups = ServerGroup.query.filter_by(user_id=user_id)",
            "",
            "            # Create the server",
            "            new_server = Server()",
            "            new_server.name = obj[\"Name\"]",
            "            new_server.servergroup_id = group_id",
            "            new_server.user_id = user_id",
            "            new_server.maintenance_db = obj[\"MaintenanceDB\"]",
            "",
            "            new_server.host = obj.get(\"Host\", None)",
            "",
            "            new_server.port = obj.get(\"Port\", None)",
            "",
            "            new_server.username = obj.get(\"Username\", None)",
            "",
            "            new_server.role = obj.get(\"Role\", None)",
            "",
            "            new_server.comment = obj.get(\"Comment\", None)",
            "",
            "            new_server.db_res = obj.get(\"DBRestriction\", None)",
            "",
            "            if 'ConnectionParameters' in obj:",
            "                new_server.connection_params = \\",
            "                    obj.get(\"ConnectionParameters\", None)",
            "            else:",
            "                # JSON file format is old before introduction of the",
            "                # connection parameters.",
            "                conn_param = dict()",
            "                for item in ['HostAddr', 'SSLMode', 'PassFile', 'SSLCert',",
            "                             'SSLKey', 'SSLRootCert', 'SSLCrl', 'Timeout',",
            "                             'SSLCompression']:",
            "                    if item in obj:",
            "                        key = item.lower()",
            "                        if item == 'Timeout':",
            "                            key = 'connect_timeout'",
            "                        conn_param[key] = obj.get(item)",
            "",
            "                new_server.connection_params = conn_param",
            "",
            "            new_server.bgcolor = obj.get(\"BGColor\", None)",
            "",
            "            new_server.fgcolor = obj.get(\"FGColor\", None)",
            "",
            "            new_server.service = obj.get(\"Service\", None)",
            "",
            "            new_server.use_ssh_tunnel = obj.get(\"UseSSHTunnel\", None)",
            "",
            "            new_server.tunnel_host = obj.get(\"TunnelHost\", None)",
            "",
            "            new_server.tunnel_port = obj.get(\"TunnelPort\", None)",
            "",
            "            new_server.tunnel_username = obj.get(\"TunnelUsername\", None)",
            "",
            "            new_server.tunnel_authentication = \\",
            "                obj.get(\"TunnelAuthentication\", None)",
            "",
            "            new_server.shared = obj.get(\"Shared\", None)",
            "",
            "            new_server.shared_username = obj.get(\"SharedUsername\", None)",
            "",
            "            new_server.kerberos_conn = obj.get(\"KerberosAuthentication\", None)",
            "",
            "            # if desktop mode or server mode with",
            "            # ENABLE_SERVER_PASS_EXEC_CMD flag is True",
            "            if not current_app.config['SERVER_MODE'] or \\",
            "                    current_app.config['ENABLE_SERVER_PASS_EXEC_CMD']:",
            "                new_server.passexec_cmd = obj.get(\"PasswordExecCommand\", None)",
            "                new_server.passexec_expiration = obj.get(",
            "                    \"PasswordExecExpiration\", None)",
            "",
            "            db.session.add(new_server)",
            "",
            "            try:",
            "                db.session.commit()",
            "            except Exception as e:",
            "                if from_setup:",
            "                    print(ADD_SERVERS_MSG % (groups_added, servers_added))",
            "                return _handle_error(gettext(\"Error creating server '%s': %s\" %",
            "                                             (new_server.name, e)), from_setup)",
            "",
            "            servers_added = servers_added + 1",
            "",
            "    msg = ADD_SERVERS_MSG % (groups_added, servers_added)",
            "    print(msg)",
            "",
            "    return True, msg",
            "",
            "",
            "def clear_database_servers(load_user=current_user, from_setup=False,",
            "                           auth_source=INTERNAL):",
            "    \"\"\"Clear groups and servers configurations.",
            "    \"\"\"",
            "    user = _does_user_exist(load_user, from_setup, auth_source)",
            "    if user is None:",
            "        return False",
            "",
            "    user_id = user.id",
            "",
            "    # Remove all servers",
            "    servers = Server.query.filter_by(user_id=user_id)",
            "    for server in servers:",
            "        db.session.delete(server)",
            "",
            "    # Remove all servergroups except for the first",
            "    # This matches the UI behavior in",
            "    # web/pgadmin/browser/server_groups/__init__.py#delete",
            "    # TODO: Investigate if we can skip the first with an `offset(1)`",
            "    groups = ServerGroup.query.filter_by(user_id=user_id).order_by(\"id\")",
            "    default_sg = groups.first()",
            "    for group in groups:",
            "        if group.id != default_sg.id:",
            "            db.session.delete(group)",
            "",
            "    try:",
            "        db.session.commit()",
            "    except Exception as e:",
            "        error_msg = \\",
            "            gettext(\"Error clearing server configuration with error (%s)\" %",
            "                    str(e))",
            "        if from_setup:",
            "            print(error_msg)",
            "            sys.exit(1)",
            "",
            "        return False, error_msg",
            "",
            "",
            "def _does_user_exist(user, from_setup, auth_source=INTERNAL):",
            "    \"\"\"",
            "    This function will check user is exist or not. If exist then return",
            "    \"\"\"",
            "    if isinstance(user, User):",
            "        auth_source = user.auth_source",
            "        user = user.username",
            "",
            "    new_user = User.query.filter_by(username=user,",
            "                                    auth_source=auth_source).first()",
            "",
            "    if new_user is None:",
            "        print(USER_NOT_FOUND % user)",
            "        if from_setup:",
            "            sys.exit(1)",
            "",
            "    return new_user",
            "",
            "",
            "def _handle_error(error_msg, from_setup):",
            "    \"\"\"",
            "    This function is used to print the error msg and exit from app if",
            "    called from setup.py",
            "    \"\"\"",
            "    if from_setup:",
            "        print(error_msg)",
            "        sys.exit(1)",
            "",
            "    return False, error_msg",
            "",
            "",
            "# Shortcut configuration for Accesskey",
            "ACCESSKEY_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    }",
            "]",
            "",
            "# Shortcut configuration",
            "SHORTCUT_FIELDS = [",
            "    {",
            "        'name': 'key',",
            "        'type': 'keyCode',",
            "        'label': gettext('Key')",
            "    },",
            "    {",
            "        'name': 'shift',",
            "        'type': 'checkbox',",
            "        'label': gettext('Shift')",
            "    },",
            "",
            "    {",
            "        'name': 'control',",
            "        'type': 'checkbox',",
            "        'label': gettext('Ctrl')",
            "    },",
            "    {",
            "        'name': 'alt',",
            "        'type': 'checkbox',",
            "        'label': gettext('Alt/Option')",
            "    }",
            "]",
            "",
            "",
            "class KeyManager:",
            "    def __init__(self):",
            "        self.users = dict()",
            "        self.lock = Lock()",
            "",
            "    @login_required",
            "    def get(self):",
            "        user = self.users.get(current_user.id, None)",
            "        if user is not None:",
            "            return user.get('key', None)",
            "",
            "    @login_required",
            "    def set(self, _key, _new_login=True):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "            if user is None:",
            "                self.users[current_user.id] = dict(",
            "                    session_count=1, key=_key)",
            "            else:",
            "                if _new_login:",
            "                    user['session_count'] += 1",
            "                user['key'] = _key",
            "",
            "    @login_required",
            "    def reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                # This will not decrement if session expired",
            "                user['session_count'] -= 1",
            "                if user['session_count'] == 0:",
            "                    del self.users[current_user.id]",
            "",
            "    @login_required",
            "    def hard_reset(self):",
            "        with self.lock:",
            "            user = self.users.get(current_user.id, None)",
            "",
            "            if user is not None:",
            "                del self.users[current_user.id]",
            "",
            "",
            "def get_safe_post_login_redirect():",
            "    allow_list = [",
            "        url_for('browser.index')",
            "    ]",
            "    if \"SCRIPT_NAME\" in os.environ and os.environ[\"SCRIPT_NAME\"]:",
            "        allow_list.append(os.environ[\"SCRIPT_NAME\"])",
            "",
            "    url = get_post_login_redirect()",
            "    for item in allow_list:",
            "        if url.startswith(item):",
            "            return url",
            "",
            "    return url_for('browser.index')",
            "",
            "",
            "def get_safe_post_logout_redirect():",
            "    allow_list = [",
            "        url_for('security.login')",
            "    ]",
            "    if \"SCRIPT_NAME\" in os.environ and os.environ[\"SCRIPT_NAME\"]:",
            "        allow_list.append(os.environ[\"SCRIPT_NAME\"])",
            "    url = get_post_logout_redirect()",
            "    for item in allow_list:",
            "        if url.startswith(item):",
            "            return url",
            "    return url_for('security.login')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "23": [],
            "367": [
                "set_binary_path"
            ]
        },
        "addLocation": []
    }
}