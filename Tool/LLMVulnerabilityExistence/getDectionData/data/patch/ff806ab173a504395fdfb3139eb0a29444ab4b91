{
    "wagtail/contrib/modeladmin/tests/test_simple_modeladmin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from wagtail.admin.admin_url_finder import AdminURLFinder"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from wagtail.admin.panels import FieldPanel, TabbedInterface"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from wagtail.contrib.modeladmin.helpers.search import DjangoORMSearchHandler"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from wagtail.documents.models import Document"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from wagtail.documents.tests.utils import get_test_document_file"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from wagtail.images.models import Image"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from wagtail.images.tests.utils import get_test_image_file"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from wagtail.models import Locale, ModelLogEntry, Page"
            },
            "8": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 593,
                "PatchRowcode": "         response = self.get_for_book(1)"
            },
            "9": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "         self.assertContains(response, \"J. R. R. Tolkien\", 1)"
            },
            "10": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 595,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 596,
                "PatchRowcode": "+    def test_book_extract_document_html_escaping(self):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+        doc = Document.objects.create("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+            title=\"Title with <script>alert('XSS')</script>\","
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+            file=get_test_document_file(),"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+        )"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+        book = Book.objects.get(title=\"The Lord of the Rings\")"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 602,
                "PatchRowcode": "+        book.extract_document = doc"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 603,
                "PatchRowcode": "+        book.save()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 604,
                "PatchRowcode": "+        response = self.get_for_book(1)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+        self.assertNotContains(response, \"Title with <script>alert('XSS')</script>\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+        self.assertContains("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+            response, \"Title with &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;\""
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+        )"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 610,
                "PatchRowcode": "     def test_non_existent(self):"
            },
            "26": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 611,
                "PatchRowcode": "         response = self.get_for_book(100)"
            },
            "27": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 612,
                "PatchRowcode": "         self.assertEqual(response.status_code, 404)"
            }
        },
        "frontPatchFile": [
            "import datetime",
            "from io import BytesIO",
            "from unittest import mock",
            "",
            "from django.contrib.auth.models import Group, Permission",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core import checks",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "from django.utils.timezone import make_aware",
            "from openpyxl import load_workbook",
            "",
            "from wagtail.admin.admin_url_finder import AdminURLFinder",
            "from wagtail.admin.panels import FieldPanel, TabbedInterface",
            "from wagtail.contrib.modeladmin.helpers.search import DjangoORMSearchHandler",
            "from wagtail.images.models import Image",
            "from wagtail.images.tests.utils import get_test_image_file",
            "from wagtail.models import Locale, ModelLogEntry, Page",
            "from wagtail.test.modeladmintest.models import (",
            "    Author,",
            "    Book,",
            "    Publisher,",
            "    RelatedLink,",
            "    Token,",
            "    TranslatableBook,",
            ")",
            "from wagtail.test.modeladmintest.wagtail_hooks import BookModelAdmin, EventsAdminGroup",
            "from wagtail.test.utils import WagtailTestUtils",
            "",
            "",
            "class TestBookIndexView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "        img = Image.objects.create(",
            "            title=\"LOTR cover\",",
            "            file=get_test_image_file(),",
            "        )",
            "        book = Book.objects.get(title=\"The Lord of the Rings\")",
            "        book.cover_image = img",
            "        book.save()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/book/\", params)",
            "",
            "    def test_thumbnail_image_col_header_text(self):",
            "        response = self.get()",
            "",
            "        # check thumb_col_header_text is correctly used",
            "        self.assertContains(",
            "            response,",
            "            '<th scope=\"col\" class=\"column-admin_thumb\">The cover</th>',",
            "            html=True,",
            "        )",
            "",
            "    def test_simple(self):",
            "        response = self.get()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">4 out of 4</span>', html=True",
            "        )",
            "",
            "        # User has add permission",
            "        self.assertIs(response.context[\"user_can_create\"], True)",
            "",
            "    def test_csv_export(self):",
            "        # Export the whole queryset",
            "        response = self.get(export=\"csv\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        # Check attachment is present and named correctly using the modeladmin export_filename",
            "        self.assertEqual(",
            "            response.get(\"content-disposition\"),",
            "            'attachment; filename=\"books-export.csv\"',",
            "        )",
            "",
            "        # Check response - all books should be in it",
            "        data_lines = response.getvalue().decode().split(\"\\n\")",
            "        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")",
            "        self.assertEqual(",
            "            data_lines[1], \"Charlie and the Chocolate Factory,Roald Dahl,1916-09-13\\r\"",
            "        )",
            "        self.assertEqual(",
            "            data_lines[2], \"The Chronicles of Narnia,Roald Dahl,1898-11-29\\r\"",
            "        )",
            "        self.assertEqual(data_lines[3], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")",
            "        self.assertEqual(",
            "            data_lines[4], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"",
            "        )",
            "",
            "    def test_xlsx_export(self):",
            "        # Export the whole queryset",
            "        response = self.get(export=\"xlsx\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        # Check attachment is present and named correctly using the modeladmin export_filename",
            "        self.assertEqual(",
            "            response.get(\"content-disposition\"),",
            "            'attachment; filename=\"books-export.xlsx\"',",
            "        )",
            "",
            "        # Check response - all books should be in it",
            "        workbook_data = response.getvalue()",
            "        worksheet = load_workbook(filename=BytesIO(workbook_data))[\"Sheet1\"]",
            "        cell_array = [[cell.value for cell in row] for row in worksheet.rows]",
            "        self.assertEqual(cell_array[0], [\"Title\", \"Author\", \"Author Date Of Birth\"])",
            "        self.assertEqual(",
            "            cell_array[1],",
            "            [\"Charlie and the Chocolate Factory\", \"Roald Dahl\", \"1916-09-13\"],",
            "        )",
            "        self.assertEqual(",
            "            cell_array[2], [\"The Chronicles of Narnia\", \"Roald Dahl\", \"1898-11-29\"]",
            "        )",
            "        self.assertEqual(",
            "            cell_array[3], [\"The Hobbit\", \"J. R. R. Tolkien\", \"1892-01-03\"]",
            "        )",
            "        self.assertEqual(",
            "            cell_array[4], [\"The Lord of the Rings\", \"J. R. R. Tolkien\", \"1892-01-03\"]",
            "        )",
            "        self.assertEqual(len(cell_array), 5)",
            "",
            "    def test_tr_attributes(self):",
            "        response = self.get()",
            "",
            "        # Charlie & The Chocolate factory should be in the list with the",
            "        # `data-author_yob` and `data-object_pk` attributes added",
            "        self.assertContains(response, 'data-author-yob=\"1916\"')",
            "        self.assertContains(response, 'data-object-pk=\"3\"')",
            "",
            "        # There should be two odd rows and two even ones, and 'book' should be",
            "        # added to the `class` attribute for every one.",
            "        self.assertContains(response, 'class=\"book odd\"', count=2)",
            "        self.assertContains(response, 'class=\"book even\"', count=2)",
            "",
            "    def test_filter(self):",
            "        # Filter by author 1 (JRR Tolkien)",
            "        response = self.get(author__id__exact=1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # JRR Tolkien has two books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">2 out of 4</span>', html=True",
            "        )",
            "",
            "        # The search form should retain the filter",
            "        self.assertContains(",
            "            response,",
            "            '<input type=\"hidden\" name=\"author__id__exact\" value=\"1\">',",
            "            html=True,",
            "        )",
            "",
            "        for book in response.context[\"object_list\"]:",
            "            self.assertEqual(book.author_id, 1)",
            "",
            "    def test_filtered_csv_export(self):",
            "        # Filter by author 1 (JRR Tolkien) and export the current selection",
            "        response = self.get(author__id__exact=1, export=\"csv\")",
            "",
            "        # Check response - only books by JRR Tolkien should be in it",
            "        self.assertEqual(response.status_code, 200)",
            "        data_lines = response.getvalue().decode().split(\"\\n\")",
            "        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")",
            "        self.assertEqual(data_lines[1], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")",
            "        self.assertEqual(",
            "            data_lines[2], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"",
            "        )",
            "        self.assertEqual(data_lines[3], \"\")",
            "",
            "    def test_search_indexed(self):",
            "        response = self.get(q=\"of\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are two books where the title contains 'of'",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">2 out of 4</span>', html=True",
            "        )",
            "",
            "    def test_search_form_present(self):",
            "        # Test the backend search handler allows the search form to render",
            "        response = self.get()",
            "",
            "        self.assertContains(response, '<input id=\"id_q\"')",
            "",
            "    def test_search_form_absent(self):",
            "        # DjangoORMSearchHandler + no search_fields, search form should be absent",
            "        with mock.patch.object(",
            "            BookModelAdmin, \"search_handler_class\", DjangoORMSearchHandler",
            "        ):",
            "            response = self.get()",
            "",
            "            self.assertNotContains(response, '<input id=\"id_q\"')",
            "",
            "    def test_ordering(self):",
            "        response = self.get(o=\"0.1\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "    def test_paging(self):",
            "        # should be corrected to just the first page, as there aren't enough",
            "        # objects to make up more than one page",
            "        response = self.get(p=9)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "        # Should raise a ValueError that gets caught during initialisation",
            "        response = self.get(p=\"notaninteger\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "",
            "class TestAuthorIndexView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/author/\", params)",
            "",
            "    def test_search(self):",
            "        response = self.get(q=\"Roald Dahl\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">2 out of 5</span>', html=True",
            "        )",
            "",
            "    def test_col_extra_class_names(self):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <td class=\"field-first_book for-author-1 title\">The Lord of the Rings</td>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    def test_col_extra_attributes(self):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <td class=\"field-last_book title\" data-for_author=\"1\">The Hobbit</td>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    def test_title_column_links_to_edit_view_by_default(self):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/edit/1/\" title=\"Edit this author\">J. R. R. Tolkien</a></div>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    @mock.patch(",
            "        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",",
            "        return_value=False,",
            "    )",
            "    def test_title_column_links_to_inspect_view_when_user_cannot_edit(self, *mocks):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/inspect/1/\" title=\"Inspect this author\">J. R. R. Tolkien</a></div>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    @mock.patch(",
            "        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_inspect_obj\",",
            "        return_value=False,",
            "    )",
            "    @mock.patch(",
            "        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",",
            "        return_value=False,",
            "    )",
            "    def test_title_column_is_not_linked_when_user_cannot_edit_or_inspect(self, *mocks):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(response, '<td class=\"field-name title\">J. R. R. Tolkien')",
            "",
            "",
            "@override_settings(WAGTAIL_I18N_ENABLED=True)",
            "class TestTranslatableBookIndexView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/translatablebook/\", params)",
            "",
            "    def test_simple(self):",
            "        response = self.get()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are two books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # Check the locale filter is there",
            "        expected = \"\"\"",
            "        <ul>",
            "            <li class=\"selected\">",
            "            <a href=\"?\">All</a></li>",
            "            <li>",
            "            <a href=\"?locale__id__exact=1\">English</a></li>",
            "            <li>",
            "            <a href=\"?locale__id__exact=2\">French</a></li>",
            "        </ul>\"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "    @override_settings(WAGTAIL_I18N_ENABLED=False)",
            "    def test_locale_selector_not_present_when_i18n_disabled(self):",
            "        response = self.get()",
            "",
            "        self.assertNotContains(",
            "            response, '<a href=\"?locale__id__exact=2\">French</a>', html=True",
            "        )",
            "",
            "    def test_filter(self):",
            "        # Filter by locale 2 (fr)",
            "        response = self.get(locale__id__exact=2)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Locale fr has one book in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 1)",
            "",
            "        for book in response.context[\"object_list\"]:",
            "            self.assertEqual(book.locale_id, 2)",
            "",
            "        self.assertContains(response, \"Le Seigneur des anneaux\", html=True)",
            "",
            "",
            "class TestCreateView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self):",
            "        return self.client.get(\"/admin/modeladmintest/book/create/\")",
            "",
            "    def post(self, post_data):",
            "        return self.client.post(\"/admin/modeladmintest/book/create/\", post_data)",
            "",
            "    def test_simple(self):",
            "        response = self.get()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_create(self):",
            "        response = self.post(",
            "            {",
            "                \"title\": \"George's Marvellous Medicine\",",
            "                \"author\": 2,",
            "            }",
            "        )",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "        # Check that the book was created",
            "        self.assertEqual(",
            "            Book.objects.filter(title=\"George's Marvellous Medicine\").count(), 1",
            "        )",
            "",
            "        response = self.client.get(\"/admin/modeladmintest/publisher/create/\")",
            "        self.assertIn(\"name\", response.content.decode(\"UTF-8\"))",
            "        self.assertNotIn(\"headquartered_in\", response.content.decode(\"UTF-8\"))",
            "        self.assertEqual(list(response.context[\"form\"].fields), [\"name\"])",
            "        self.client.post(",
            "            \"/admin/modeladmintest/publisher/create/\", {\"name\": \"Sharper Collins\"}",
            "        )",
            "        publisher = Publisher.objects.get(name=\"Sharper Collins\")",
            "        self.assertIsNone(publisher.headquartered_in)",
            "",
            "    def test_post_invalid(self):",
            "        initial_book_count = Book.objects.count()",
            "",
            "        response = self.post(",
            "            {",
            "                \"title\": \"\",",
            "                \"author\": 2,",
            "            }",
            "        )",
            "        final_book_count = Book.objects.count()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        # Check that the book was not created",
            "        self.assertEqual(initial_book_count, final_book_count)",
            "",
            "        # Check that a form error was raised",
            "        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")",
            "        self.assertContains(response, \"error-message\", count=1)",
            "",
            "    def test_exclude_passed_to_extract_panel_definitions(self):",
            "        path_to_form_fields_exclude_property = (",
            "            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"",
            "        )",
            "        with mock.patch(",
            "            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"",
            "        ) as m:",
            "            with mock.patch(",
            "                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock",
            "            ) as mock_form_fields_exclude:",
            "                mock_form_fields_exclude.return_value = [\"123\"]",
            "",
            "                self.get()",
            "                self.assertTrue(mock_form_fields_exclude.called)",
            "                m.assert_called_with(",
            "                    Book, exclude=mock_form_fields_exclude.return_value",
            "                )",
            "",
            "    def test_clean_form_once(self):",
            "        with mock.patch(",
            "            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"",
            "        ) as mock_form_clean:",
            "            response = self.client.post(",
            "                \"/admin/modeladmintest/publisher/create/\", {\"name\": \"\"}",
            "            )",
            "            self.assertEqual(response.status_code, 200)",
            "",
            "            mock_form_clean.assert_called_once()",
            "",
            "    def test_create_view_with_multifieldpanel(self):",
            "        # https://github.com/wagtail/wagtail/issues/6413",
            "        response = self.client.get(\"/admin/modeladmintest/relatedlink/create/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        response = self.client.post(",
            "            \"/admin/modeladmintest/relatedlink/create/\",",
            "            {",
            "                \"title\": \"Homepage\",",
            "                \"link\": Page.objects.filter(depth=2).first().id,",
            "            },",
            "        )",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")",
            "",
            "        # Check that the link was created",
            "        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage\").count(), 1)",
            "",
            "    def test_prepopulated_field_data_in_context(self):",
            "        response = self.get()",
            "        self.assertIn(",
            "            'data-prepopulated-fields=\"[{&quot;id&quot;: &quot;#id_title&quot;, &quot;name&quot;: &quot;title&quot;, &quot;dependency_ids&quot;: [&quot;#id_author&quot;], &quot;dependency_list&quot;: [&quot;author&quot;], &quot;maxLength&quot;: 255, &quot;allowUnicode&quot;: false}]\"',",
            "            response.content.decode(\"UTF-8\"),",
            "        )",
            "",
            "",
            "@override_settings(WAGTAIL_I18N_ENABLED=True)",
            "class TestTranslatableCreateView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/translatablebook/create/\", params)",
            "",
            "    def test_simple(self):",
            "        response = self.get(locale=\"fr\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check that the locale select exists and is set correctly",
            "        expected = '<a href=\"javascript:void(0)\" aria-label=\"French\" class=\"c-dropdown__button u-btn-current w-no-underline\">'",
            "        self.assertContains(response, expected)",
            "",
            "        # Check that the other locale link is right",
            "        expected = \"\"\"",
            "        <a href=\"/admin/modeladmintest/translatablebook/create/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">",
            "            English",
            "        </a>\"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "",
            "class TestRevisableCreateView(TestCase, WagtailTestUtils):",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def post(self, post_data):",
            "        return self.client.post(\"/admin/modeladmintest/publisher/create/\", post_data)",
            "",
            "    def test_create_with_revision(self):",
            "        data = {\"name\": \"foo\"}",
            "        response = self.post(data)",
            "        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")",
            "",
            "        instances = Publisher.objects.filter(name=\"foo\")",
            "        instance = instances.first()",
            "        self.assertEqual(instances.count(), 1)",
            "",
            "        # The revision should be created",
            "        revisions = instance.revisions",
            "        revision = revisions.first()",
            "        self.assertEqual(revisions.count(), 1)",
            "        self.assertEqual(revision.content[\"name\"], \"foo\")",
            "",
            "        # The log entry should have the revision attached",
            "        log_entries = ModelLogEntry.objects.for_instance(instance).filter(",
            "            action=\"wagtail.create\"",
            "        )",
            "        self.assertEqual(log_entries.count(), 1)",
            "        self.assertEqual(log_entries.first().revision, revision)",
            "",
            "",
            "class TestInspectView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "        img = Image.objects.create(",
            "            title=\"LOTR cover\",",
            "            file=get_test_image_file(),",
            "        )",
            "        book = Book.objects.get(title=\"The Lord of the Rings\")",
            "        book.cover_image = img",
            "        book.save()",
            "",
            "    def get_for_author(self, author_id):",
            "        return self.client.get(\"/admin/modeladmintest/author/inspect/%d/\" % author_id)",
            "",
            "    def get_for_book(self, book_id):",
            "        return self.client.get(\"/admin/modeladmintest/book/inspect/%d/\" % book_id)",
            "",
            "    def test_author_simple(self):",
            "        response = self.get_for_author(1)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_author_name_present(self):",
            "        \"\"\"",
            "        The author name should appear twice. Once in the header, and once",
            "        more in the field listing",
            "        \"\"\"",
            "        response = self.get_for_author(1)",
            "        self.assertContains(response, \"J. R. R. Tolkien\", 2)",
            "",
            "    def test_author_dob_not_present(self):",
            "        \"\"\"",
            "        The date of birth shouldn't appear, because the field wasn't included",
            "        in the `inspect_view_fields` list",
            "        \"\"\"",
            "        response = self.get_for_author(1)",
            "        self.assertNotContains(response, \"1892\")",
            "",
            "    def test_book_simple(self):",
            "        response = self.get_for_book(1)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_book_title_present(self):",
            "        \"\"\"",
            "        The book title should appear once only, in the header, as 'title'",
            "        was added to the `inspect_view_fields_ignore` list",
            "        \"\"\"",
            "        response = self.get_for_book(1)",
            "        self.assertContains(response, \"The Lord of the Rings\", 1)",
            "",
            "    def test_book_author_present(self):",
            "        \"\"\"",
            "        The author name should appear, because 'author' is not in",
            "        `inspect_view_fields_ignore` and should be returned by the",
            "        `get_inspect_view_fields` method.",
            "        \"\"\"",
            "        response = self.get_for_book(1)",
            "        self.assertContains(response, \"J. R. R. Tolkien\", 1)",
            "",
            "    def test_non_existent(self):",
            "        response = self.get_for_book(100)",
            "        self.assertEqual(response.status_code, 404)",
            "",
            "    def test_back_to_listing(self):",
            "        response = self.client.get(\"/admin/modeladmintest/author/inspect/1/\")",
            "        # check that back to listing link exists",
            "        expected = \"\"\"",
            "            <p class=\"back\">",
            "                    <a href=\"/admin/modeladmintest/author/\">",
            "                        <svg class=\"icon icon-arrow-left default\" aria-hidden=\"true\">",
            "                            <use href=\"#icon-arrow-left\"></use>",
            "                        </svg>",
            "                        Back to author list",
            "                    </a>",
            "            </p>",
            "        \"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "",
            "class TestEditView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.user = self.login()",
            "        ModelLogEntry.objects.create(",
            "            content_type=ContentType.objects.get_for_model(Book),",
            "            label=\"The Lord of the Rings\",",
            "            action=\"wagtail.create\",",
            "            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),",
            "            object_id=\"1\",",
            "        )",
            "",
            "    def get(self, book_id):",
            "        return self.client.get(\"/admin/modeladmintest/book/edit/%d/\" % book_id)",
            "",
            "    def post(self, book_id, post_data):",
            "        return self.client.post(",
            "            \"/admin/modeladmintest/book/edit/%d/\" % book_id, post_data",
            "        )",
            "",
            "    def test_simple(self):",
            "        response = self.get(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(response, \"The Lord of the Rings\")",
            "",
            "        # \"Last updated\" timestamp should be present",
            "        self.assertContains(",
            "            response, 'data-wagtail-tooltip=\"Sept. 30, 2021, 10:01 a.m.\"'",
            "        )",
            "        # History link should be present",
            "        self.assertContains(response, 'href=\"/admin/modeladmintest/book/history/1/\"')",
            "",
            "        url_finder = AdminURLFinder(self.user)",
            "        expected_url = \"/admin/modeladmintest/book/edit/1/\"",
            "        self.assertEqual(url_finder.get_edit_url(Book.objects.get(id=1)), expected_url)",
            "",
            "    def test_non_existent(self):",
            "        response = self.get(100)",
            "",
            "        self.assertEqual(response.status_code, 404)",
            "",
            "    def test_edit(self):",
            "        response = self.post(",
            "            1,",
            "            {",
            "                \"title\": \"The Lady of the Rings\",",
            "                \"author\": 1,",
            "            },",
            "        )",
            "",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "        # Check that the book was updated",
            "        self.assertEqual(Book.objects.get(id=1).title, \"The Lady of the Rings\")",
            "",
            "    def test_post_invalid(self):",
            "        response = self.post(",
            "            1,",
            "            {",
            "                \"title\": \"\",",
            "                \"author\": 1,",
            "            },",
            "        )",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check that the title was not updated",
            "        self.assertEqual(Book.objects.get(id=1).title, \"The Lord of the Rings\")",
            "",
            "        # Check that a form error was raised",
            "        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")",
            "        self.assertContains(response, \"error-message\", count=1)",
            "",
            "    def test_exclude_passed_to_extract_panel_definitions(self):",
            "        path_to_form_fields_exclude_property = (",
            "            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"",
            "        )",
            "        with mock.patch(",
            "            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"",
            "        ) as m:",
            "            with mock.patch(",
            "                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock",
            "            ) as mock_form_fields_exclude:",
            "                mock_form_fields_exclude.return_value = [\"123\"]",
            "",
            "                self.get(1)",
            "                self.assertTrue(mock_form_fields_exclude.called)",
            "                m.assert_called_with(",
            "                    Book, exclude=mock_form_fields_exclude.return_value",
            "                )",
            "",
            "    def test_clean_form_once(self):",
            "        with mock.patch(",
            "            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"",
            "        ) as mock_form_clean:",
            "            publisher = Publisher.objects.create(name=\"Sharper Collins\")",
            "",
            "            response = self.client.post(",
            "                \"/admin/modeladmintest/publisher/edit/%d/\" % publisher.pk, {\"name\": \"\"}",
            "            )",
            "            self.assertEqual(response.status_code, 200)",
            "",
            "            mock_form_clean.assert_called_once()",
            "",
            "    def test_edit_view_with_multifieldpanel(self):",
            "        # https://github.com/wagtail/wagtail/issues/6413",
            "        link = RelatedLink.objects.create(",
            "            title=\"Homepage\", link=Page.objects.filter(depth=2).first()",
            "        )",
            "        response = self.client.get(",
            "            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id",
            "        )",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        response = self.client.post(",
            "            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id,",
            "            {",
            "                \"title\": \"Homepage edited\",",
            "                \"link\": Page.objects.filter(depth=2).first().id,",
            "            },",
            "        )",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")",
            "",
            "        # Check that the link was updated",
            "        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage edited\").count(), 1)",
            "",
            "",
            "@override_settings(WAGTAIL_I18N_ENABLED=True)",
            "class TestTranslatableBookEditView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, book_id, **params):",
            "        return self.client.get(",
            "            \"/admin/modeladmintest/translatablebook/edit/%d/\" % book_id, params",
            "        )",
            "",
            "    def test_simple(self):",
            "        book = TranslatableBook.objects.first()",
            "        response = self.get(book.id)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check the locale switcher isn't there",
            "        self.assertNotContains(response, \"English\", html=True)",
            "",
            "        tbook = book.copy_for_translation(locale=Locale.objects.get(language_code=\"fr\"))",
            "        tbook.save()",
            "",
            "        response = self.get(tbook.id)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check the locale switcher is there",
            "        expected = \"\"\"",
            "        <a href=\"/admin/modeladmintest/translatablebook/edit/1/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">",
            "            English",
            "        </a>\"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "",
            "class TestRevisableEditView(TestCase, WagtailTestUtils):",
            "    def setUp(self):",
            "        self.login()",
            "        self.instance = Publisher.objects.create(name=\"foo\")",
            "",
            "    def post(self, post_data):",
            "        return self.client.post(",
            "            \"/admin/modeladmintest/publisher/edit/%s/\" % self.instance.pk, post_data",
            "        )",
            "",
            "    def test_edit_with_revision(self):",
            "        data = {\"name\": \"bar\"}",
            "        response = self.post(data)",
            "        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")",
            "",
            "        instances = Publisher.objects.filter(name=\"bar\")",
            "        instance = instances.first()",
            "        self.assertEqual(instances.count(), 1)",
            "",
            "        # The revision should be created",
            "        revisions = instance.revisions",
            "        revision = revisions.first()",
            "        self.assertEqual(revisions.count(), 1)",
            "        self.assertEqual(revision.content[\"name\"], \"bar\")",
            "",
            "        # The log entry should have the revision attached",
            "        log_entries = ModelLogEntry.objects.for_instance(instance).filter(",
            "            action=\"wagtail.edit\"",
            "        )",
            "        self.assertEqual(log_entries.count(), 1)",
            "        self.assertEqual(log_entries.first().revision, revision)",
            "",
            "",
            "class TestPageSpecificViews(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "    expected_status_code = 404",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def test_choose_parent(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/choose_parent/\")",
            "        self.assertEqual(response.status_code, self.expected_status_code)",
            "",
            "",
            "class TestConfirmDeleteView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, book_id):",
            "        return self.client.get(\"/admin/modeladmintest/book/delete/%d/\" % book_id)",
            "",
            "    def post(self, book_id):",
            "        return self.client.post(\"/admin/modeladmintest/book/delete/%d/\" % book_id)",
            "",
            "    def test_simple(self):",
            "        response = self.get(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_non_existent(self):",
            "        response = self.get(100)",
            "",
            "        self.assertEqual(response.status_code, 404)",
            "",
            "    def test_post(self):",
            "        response = self.post(1)",
            "",
            "        # User redirected to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "        # Book deleted",
            "        self.assertFalse(Book.objects.filter(id=1).exists())",
            "",
            "",
            "class TestDeleteViewWithProtectedRelation(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, author_id):",
            "        return self.client.get(\"/admin/modeladmintest/author/delete/%d/\" % author_id)",
            "",
            "    def post(self, author_id):",
            "        return self.client.post(\"/admin/modeladmintest/author/delete/%d/\" % author_id)",
            "",
            "    def test_get_with_dependent_object(self):",
            "        response = self.get(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_get_without_dependent_object(self):",
            "        response = self.get(4)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_post_with_dependent_object(self):",
            "        response = self.post(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(",
            "            response, \"'J. R. R. Tolkien' is currently referenced by other objects\"",
            "        )",
            "        self.assertContains(response, \"<li><b>Book:</b> The Lord of the Rings</li>\")",
            "",
            "        # Author not deleted",
            "        self.assertTrue(Author.objects.filter(id=1).exists())",
            "",
            "    def test_post_without_dependent_object(self):",
            "        response = self.post(4)",
            "",
            "        # User redirected to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/author/\")",
            "",
            "        # Author deleted",
            "        self.assertFalse(Author.objects.filter(id=4).exists())",
            "",
            "    def test_post_with_1to1_dependent_object(self):",
            "        response = self.post(5)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(",
            "            response, \"'Harper Lee' is currently referenced by other objects\"",
            "        )",
            "        self.assertContains(",
            "            response, \"<li><b>Solo Book:</b> To Kill a Mockingbird</li>\"",
            "        )",
            "",
            "        # Author not deleted",
            "        self.assertTrue(Author.objects.filter(id=5).exists())",
            "",
            "",
            "class TestDeleteViewModelReprPrimary(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def test_delete(self):",
            "        response = self.client.post(\"/admin/modeladmintest/token/delete/boom/\")",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "",
            "class TestEditorAccess(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        # Create a user",
            "        self.user = self.create_user(username=\"test2\", password=\"password\")",
            "        self.group = Group.objects.get(name=\"Editors\")",
            "        self.user.groups.add(self.group)",
            "        self.book_content_type = ContentType.objects.get_for_model(Book)",
            "",
            "        # Login",
            "        self.login(username=\"test2\", password=\"password\")",
            "",
            "    def test_index_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"add_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_inspect_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"add_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_create_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/create/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"add_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/create/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_edit_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"change_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_admin_url_finder_without_permission(self):",
            "        url_finder = AdminURLFinder(self.user)",
            "        self.assertIsNone(url_finder.get_edit_url(Book.objects.get(id=2)))",
            "",
            "    def test_admin_url_finder_with_permission(self):",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"change_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        url_finder = AdminURLFinder(self.user)",
            "        self.assertEqual(",
            "            url_finder.get_edit_url(Book.objects.get(id=2)),",
            "            \"/admin/modeladmintest/book/edit/2/\",",
            "        )",
            "",
            "    def test_delete_get_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"delete_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_delete_post_permitted(self):",
            "        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"delete_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "",
            "class TestHistoryView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "        ModelLogEntry.objects.create(",
            "            content_type=ContentType.objects.get_for_model(Book),",
            "            label=\"The Lord of the Rings\",",
            "            action=\"wagtail.create\",",
            "            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),",
            "            object_id=\"1\",",
            "        )",
            "",
            "    def test_simple(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/history/1/\")",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(response, \"<td>Created</td>\", html=True)",
            "        self.assertContains(",
            "            response,",
            "            'data-tippy-content=\"Sept. 30, 2021, 10:01 a.m.\"',",
            "        )",
            "",
            "",
            "class TestQuoting(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "    expected_status_code = 200",
            "",
            "    def setUp(self):",
            "        self.login()",
            "        self.tok_reg = Token.objects.create(key=\"RegularName\")",
            "        self.tok_irr = Token.objects.create(key=\"Irregular_Name\")",
            "",
            "    def test_action_links(self):",
            "        response = self.client.get(\"/admin/modeladmintest/token/\")",
            "",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/edit/RegularName/\"'",
            "        )",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/delete/RegularName/\"'",
            "        )",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/edit/Irregular_5FName/\"'",
            "        )",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/delete/Irregular_5FName/\"'",
            "        )",
            "",
            "        response = self.client.get(\"/admin/modeladmintest/token/edit/Irregular_5FName/\")",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.get(",
            "            \"/admin/modeladmintest/token/delete/Irregular_5FName/\"",
            "        )",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "",
            "class TestPanelConfigurationChecks(TestCase, WagtailTestUtils):",
            "    def setUp(self):",
            "        self.warning_id = \"wagtailadmin.W002\"",
            "",
            "        def get_checks_result():",
            "            # run checks only with the 'panels' tag",
            "            checks_result = checks.run_checks(tags=[\"panels\"])",
            "            return [",
            "                warning for warning in checks_result if warning.id == self.warning_id",
            "            ]",
            "",
            "        self.get_checks_result = get_checks_result",
            "",
            "    def test_model_with_single_tabbed_panel_only(self):",
            "        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]",
            "",
            "        warning = checks.Warning(",
            "            \"Publisher.content_panels will have no effect on modeladmin editing\",",
            "            hint=\"\"\"Ensure that Publisher uses `panels` instead of `content_panels`\\",
            "or set up an `edit_handler` if you want a tabbed editing interface.",
            "There are no default tabs on non-Page models so there will be no\\",
            " Content tab for the content_panels to render in.\"\"\",",
            "            obj=Publisher,",
            "            id=\"wagtailadmin.W002\",",
            "        )",
            "",
            "        checks_results = self.get_checks_result()",
            "",
            "        self.assertIn(warning, checks_results)",
            "",
            "        # clean up for future checks",
            "        delattr(Publisher, \"content_panels\")",
            "",
            "    def test_model_with_two_tabbed_panels_only(self):",
            "        Publisher.settings_panels = [FieldPanel(\"name\")]",
            "        Publisher.promote_panels = [FieldPanel(\"headquartered_in\")]",
            "",
            "        warning_1 = checks.Warning(",
            "            \"Publisher.promote_panels will have no effect on modeladmin editing\",",
            "            hint=\"\"\"Ensure that Publisher uses `panels` instead of `promote_panels`\\",
            "or set up an `edit_handler` if you want a tabbed editing interface.",
            "There are no default tabs on non-Page models so there will be no\\",
            " Promote tab for the promote_panels to render in.\"\"\",",
            "            obj=Publisher,",
            "            id=\"wagtailadmin.W002\",",
            "        )",
            "",
            "        warning_2 = checks.Warning(",
            "            \"Publisher.settings_panels will have no effect on modeladmin editing\",",
            "            hint=\"\"\"Ensure that Publisher uses `panels` instead of `settings_panels`\\",
            "or set up an `edit_handler` if you want a tabbed editing interface.",
            "There are no default tabs on non-Page models so there will be no\\",
            " Settings tab for the settings_panels to render in.\"\"\",",
            "            obj=Publisher,",
            "            id=\"wagtailadmin.W002\",",
            "        )",
            "",
            "        checks_results = self.get_checks_result()",
            "",
            "        self.assertIn(warning_1, checks_results)",
            "        self.assertIn(warning_2, checks_results)",
            "",
            "        # clean up for future checks",
            "        delattr(Publisher, \"settings_panels\")",
            "        delattr(Publisher, \"promote_panels\")",
            "",
            "    def test_model_with_single_tabbed_panel_and_edit_handler(self):",
            "        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]",
            "        Publisher.edit_handler = TabbedInterface(Publisher.content_panels)",
            "",
            "        # no errors should occur",
            "        self.assertEqual(self.get_checks_result(), [])",
            "",
            "        # clean up for future checks",
            "        delattr(Publisher, \"content_panels\")",
            "        delattr(Publisher, \"edit_handler\")",
            "",
            "",
            "class TestMenuSetting(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def test_default_menu_setting_model_admin(self):",
            "        modeladmin = BookModelAdmin()",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Books\")",
            "        self.assertEqual(menu_item.name, \"books\")",
            "",
            "    def test_custom_menu_setting_model_admin(self):",
            "        modeladmin = BookModelAdmin()",
            "        modeladmin.menu_label = \"Book Model Label\"",
            "        modeladmin.menu_item_name = \"bookitem\"",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Book Model Label\")",
            "        self.assertEqual(menu_item.name, \"bookitem\")",
            "",
            "    def test_default_menu_setting_model_admin_group(self):",
            "        modeladmin = EventsAdminGroup()",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Events\")",
            "        self.assertEqual(menu_item.name, \"events\")",
            "",
            "    def test_custom_menu_setting_model_admin_group(self):",
            "        modeladmin = EventsAdminGroup()",
            "        modeladmin.menu_label = \"Event Model Label\"",
            "        modeladmin.menu_item_name = \"eventitem\"",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Event Model Label\")",
            "        self.assertEqual(menu_item.name, \"eventitem\")"
        ],
        "afterPatchFile": [
            "import datetime",
            "from io import BytesIO",
            "from unittest import mock",
            "",
            "from django.contrib.auth.models import Group, Permission",
            "from django.contrib.contenttypes.models import ContentType",
            "from django.core import checks",
            "from django.test import TestCase",
            "from django.test.utils import override_settings",
            "from django.utils.timezone import make_aware",
            "from openpyxl import load_workbook",
            "",
            "from wagtail.admin.admin_url_finder import AdminURLFinder",
            "from wagtail.admin.panels import FieldPanel, TabbedInterface",
            "from wagtail.contrib.modeladmin.helpers.search import DjangoORMSearchHandler",
            "from wagtail.documents.models import Document",
            "from wagtail.documents.tests.utils import get_test_document_file",
            "from wagtail.images.models import Image",
            "from wagtail.images.tests.utils import get_test_image_file",
            "from wagtail.models import Locale, ModelLogEntry, Page",
            "from wagtail.test.modeladmintest.models import (",
            "    Author,",
            "    Book,",
            "    Publisher,",
            "    RelatedLink,",
            "    Token,",
            "    TranslatableBook,",
            ")",
            "from wagtail.test.modeladmintest.wagtail_hooks import BookModelAdmin, EventsAdminGroup",
            "from wagtail.test.utils import WagtailTestUtils",
            "",
            "",
            "class TestBookIndexView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "        img = Image.objects.create(",
            "            title=\"LOTR cover\",",
            "            file=get_test_image_file(),",
            "        )",
            "        book = Book.objects.get(title=\"The Lord of the Rings\")",
            "        book.cover_image = img",
            "        book.save()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/book/\", params)",
            "",
            "    def test_thumbnail_image_col_header_text(self):",
            "        response = self.get()",
            "",
            "        # check thumb_col_header_text is correctly used",
            "        self.assertContains(",
            "            response,",
            "            '<th scope=\"col\" class=\"column-admin_thumb\">The cover</th>',",
            "            html=True,",
            "        )",
            "",
            "    def test_simple(self):",
            "        response = self.get()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">4 out of 4</span>', html=True",
            "        )",
            "",
            "        # User has add permission",
            "        self.assertIs(response.context[\"user_can_create\"], True)",
            "",
            "    def test_csv_export(self):",
            "        # Export the whole queryset",
            "        response = self.get(export=\"csv\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        # Check attachment is present and named correctly using the modeladmin export_filename",
            "        self.assertEqual(",
            "            response.get(\"content-disposition\"),",
            "            'attachment; filename=\"books-export.csv\"',",
            "        )",
            "",
            "        # Check response - all books should be in it",
            "        data_lines = response.getvalue().decode().split(\"\\n\")",
            "        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")",
            "        self.assertEqual(",
            "            data_lines[1], \"Charlie and the Chocolate Factory,Roald Dahl,1916-09-13\\r\"",
            "        )",
            "        self.assertEqual(",
            "            data_lines[2], \"The Chronicles of Narnia,Roald Dahl,1898-11-29\\r\"",
            "        )",
            "        self.assertEqual(data_lines[3], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")",
            "        self.assertEqual(",
            "            data_lines[4], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"",
            "        )",
            "",
            "    def test_xlsx_export(self):",
            "        # Export the whole queryset",
            "        response = self.get(export=\"xlsx\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        # Check attachment is present and named correctly using the modeladmin export_filename",
            "        self.assertEqual(",
            "            response.get(\"content-disposition\"),",
            "            'attachment; filename=\"books-export.xlsx\"',",
            "        )",
            "",
            "        # Check response - all books should be in it",
            "        workbook_data = response.getvalue()",
            "        worksheet = load_workbook(filename=BytesIO(workbook_data))[\"Sheet1\"]",
            "        cell_array = [[cell.value for cell in row] for row in worksheet.rows]",
            "        self.assertEqual(cell_array[0], [\"Title\", \"Author\", \"Author Date Of Birth\"])",
            "        self.assertEqual(",
            "            cell_array[1],",
            "            [\"Charlie and the Chocolate Factory\", \"Roald Dahl\", \"1916-09-13\"],",
            "        )",
            "        self.assertEqual(",
            "            cell_array[2], [\"The Chronicles of Narnia\", \"Roald Dahl\", \"1898-11-29\"]",
            "        )",
            "        self.assertEqual(",
            "            cell_array[3], [\"The Hobbit\", \"J. R. R. Tolkien\", \"1892-01-03\"]",
            "        )",
            "        self.assertEqual(",
            "            cell_array[4], [\"The Lord of the Rings\", \"J. R. R. Tolkien\", \"1892-01-03\"]",
            "        )",
            "        self.assertEqual(len(cell_array), 5)",
            "",
            "    def test_tr_attributes(self):",
            "        response = self.get()",
            "",
            "        # Charlie & The Chocolate factory should be in the list with the",
            "        # `data-author_yob` and `data-object_pk` attributes added",
            "        self.assertContains(response, 'data-author-yob=\"1916\"')",
            "        self.assertContains(response, 'data-object-pk=\"3\"')",
            "",
            "        # There should be two odd rows and two even ones, and 'book' should be",
            "        # added to the `class` attribute for every one.",
            "        self.assertContains(response, 'class=\"book odd\"', count=2)",
            "        self.assertContains(response, 'class=\"book even\"', count=2)",
            "",
            "    def test_filter(self):",
            "        # Filter by author 1 (JRR Tolkien)",
            "        response = self.get(author__id__exact=1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # JRR Tolkien has two books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">2 out of 4</span>', html=True",
            "        )",
            "",
            "        # The search form should retain the filter",
            "        self.assertContains(",
            "            response,",
            "            '<input type=\"hidden\" name=\"author__id__exact\" value=\"1\">',",
            "            html=True,",
            "        )",
            "",
            "        for book in response.context[\"object_list\"]:",
            "            self.assertEqual(book.author_id, 1)",
            "",
            "    def test_filtered_csv_export(self):",
            "        # Filter by author 1 (JRR Tolkien) and export the current selection",
            "        response = self.get(author__id__exact=1, export=\"csv\")",
            "",
            "        # Check response - only books by JRR Tolkien should be in it",
            "        self.assertEqual(response.status_code, 200)",
            "        data_lines = response.getvalue().decode().split(\"\\n\")",
            "        self.assertEqual(data_lines[0], \"Title,Author,Author Date Of Birth\\r\")",
            "        self.assertEqual(data_lines[1], \"The Hobbit,J. R. R. Tolkien,1892-01-03\\r\")",
            "        self.assertEqual(",
            "            data_lines[2], \"The Lord of the Rings,J. R. R. Tolkien,1892-01-03\\r\"",
            "        )",
            "        self.assertEqual(data_lines[3], \"\")",
            "",
            "    def test_search_indexed(self):",
            "        response = self.get(q=\"of\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are two books where the title contains 'of'",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">2 out of 4</span>', html=True",
            "        )",
            "",
            "    def test_search_form_present(self):",
            "        # Test the backend search handler allows the search form to render",
            "        response = self.get()",
            "",
            "        self.assertContains(response, '<input id=\"id_q\"')",
            "",
            "    def test_search_form_absent(self):",
            "        # DjangoORMSearchHandler + no search_fields, search form should be absent",
            "        with mock.patch.object(",
            "            BookModelAdmin, \"search_handler_class\", DjangoORMSearchHandler",
            "        ):",
            "            response = self.get()",
            "",
            "            self.assertNotContains(response, '<input id=\"id_q\"')",
            "",
            "    def test_ordering(self):",
            "        response = self.get(o=\"0.1\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "    def test_paging(self):",
            "        # should be corrected to just the first page, as there aren't enough",
            "        # objects to make up more than one page",
            "        response = self.get(p=9)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "        # Should raise a ValueError that gets caught during initialisation",
            "        response = self.get(p=\"notaninteger\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are four books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 4)",
            "",
            "",
            "class TestAuthorIndexView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/author/\", params)",
            "",
            "    def test_search(self):",
            "        response = self.get(q=\"Roald Dahl\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # The result count content is shown in the header",
            "        self.assertContains(",
            "            response, '<span class=\"result-count\">2 out of 5</span>', html=True",
            "        )",
            "",
            "    def test_col_extra_class_names(self):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <td class=\"field-first_book for-author-1 title\">The Lord of the Rings</td>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    def test_col_extra_attributes(self):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <td class=\"field-last_book title\" data-for_author=\"1\">The Hobbit</td>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    def test_title_column_links_to_edit_view_by_default(self):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/edit/1/\" title=\"Edit this author\">J. R. R. Tolkien</a></div>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    @mock.patch(",
            "        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",",
            "        return_value=False,",
            "    )",
            "    def test_title_column_links_to_inspect_view_when_user_cannot_edit(self, *mocks):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        test_html = \"\"\"",
            "            <div class=\"title-wrapper\"><a href=\"/admin/modeladmintest/author/inspect/1/\" title=\"Inspect this author\">J. R. R. Tolkien</a></div>",
            "        \"\"\"",
            "        self.assertContains(response, test_html, html=True)",
            "",
            "    @mock.patch(",
            "        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_inspect_obj\",",
            "        return_value=False,",
            "    )",
            "    @mock.patch(",
            "        \"wagtail.contrib.modeladmin.helpers.permission.PermissionHelper.user_can_edit_obj\",",
            "        return_value=False,",
            "    )",
            "    def test_title_column_is_not_linked_when_user_cannot_edit_or_inspect(self, *mocks):",
            "        response = self.get()",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(response, '<td class=\"field-name title\">J. R. R. Tolkien')",
            "",
            "",
            "@override_settings(WAGTAIL_I18N_ENABLED=True)",
            "class TestTranslatableBookIndexView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/translatablebook/\", params)",
            "",
            "    def test_simple(self):",
            "        response = self.get()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # There are two books in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 2)",
            "",
            "        # Check the locale filter is there",
            "        expected = \"\"\"",
            "        <ul>",
            "            <li class=\"selected\">",
            "            <a href=\"?\">All</a></li>",
            "            <li>",
            "            <a href=\"?locale__id__exact=1\">English</a></li>",
            "            <li>",
            "            <a href=\"?locale__id__exact=2\">French</a></li>",
            "        </ul>\"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "    @override_settings(WAGTAIL_I18N_ENABLED=False)",
            "    def test_locale_selector_not_present_when_i18n_disabled(self):",
            "        response = self.get()",
            "",
            "        self.assertNotContains(",
            "            response, '<a href=\"?locale__id__exact=2\">French</a>', html=True",
            "        )",
            "",
            "    def test_filter(self):",
            "        # Filter by locale 2 (fr)",
            "        response = self.get(locale__id__exact=2)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Locale fr has one book in the test data",
            "        self.assertEqual(response.context[\"result_count\"], 1)",
            "",
            "        for book in response.context[\"object_list\"]:",
            "            self.assertEqual(book.locale_id, 2)",
            "",
            "        self.assertContains(response, \"Le Seigneur des anneaux\", html=True)",
            "",
            "",
            "class TestCreateView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self):",
            "        return self.client.get(\"/admin/modeladmintest/book/create/\")",
            "",
            "    def post(self, post_data):",
            "        return self.client.post(\"/admin/modeladmintest/book/create/\", post_data)",
            "",
            "    def test_simple(self):",
            "        response = self.get()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_create(self):",
            "        response = self.post(",
            "            {",
            "                \"title\": \"George's Marvellous Medicine\",",
            "                \"author\": 2,",
            "            }",
            "        )",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "        # Check that the book was created",
            "        self.assertEqual(",
            "            Book.objects.filter(title=\"George's Marvellous Medicine\").count(), 1",
            "        )",
            "",
            "        response = self.client.get(\"/admin/modeladmintest/publisher/create/\")",
            "        self.assertIn(\"name\", response.content.decode(\"UTF-8\"))",
            "        self.assertNotIn(\"headquartered_in\", response.content.decode(\"UTF-8\"))",
            "        self.assertEqual(list(response.context[\"form\"].fields), [\"name\"])",
            "        self.client.post(",
            "            \"/admin/modeladmintest/publisher/create/\", {\"name\": \"Sharper Collins\"}",
            "        )",
            "        publisher = Publisher.objects.get(name=\"Sharper Collins\")",
            "        self.assertIsNone(publisher.headquartered_in)",
            "",
            "    def test_post_invalid(self):",
            "        initial_book_count = Book.objects.count()",
            "",
            "        response = self.post(",
            "            {",
            "                \"title\": \"\",",
            "                \"author\": 2,",
            "            }",
            "        )",
            "        final_book_count = Book.objects.count()",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        # Check that the book was not created",
            "        self.assertEqual(initial_book_count, final_book_count)",
            "",
            "        # Check that a form error was raised",
            "        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")",
            "        self.assertContains(response, \"error-message\", count=1)",
            "",
            "    def test_exclude_passed_to_extract_panel_definitions(self):",
            "        path_to_form_fields_exclude_property = (",
            "            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"",
            "        )",
            "        with mock.patch(",
            "            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"",
            "        ) as m:",
            "            with mock.patch(",
            "                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock",
            "            ) as mock_form_fields_exclude:",
            "                mock_form_fields_exclude.return_value = [\"123\"]",
            "",
            "                self.get()",
            "                self.assertTrue(mock_form_fields_exclude.called)",
            "                m.assert_called_with(",
            "                    Book, exclude=mock_form_fields_exclude.return_value",
            "                )",
            "",
            "    def test_clean_form_once(self):",
            "        with mock.patch(",
            "            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"",
            "        ) as mock_form_clean:",
            "            response = self.client.post(",
            "                \"/admin/modeladmintest/publisher/create/\", {\"name\": \"\"}",
            "            )",
            "            self.assertEqual(response.status_code, 200)",
            "",
            "            mock_form_clean.assert_called_once()",
            "",
            "    def test_create_view_with_multifieldpanel(self):",
            "        # https://github.com/wagtail/wagtail/issues/6413",
            "        response = self.client.get(\"/admin/modeladmintest/relatedlink/create/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        response = self.client.post(",
            "            \"/admin/modeladmintest/relatedlink/create/\",",
            "            {",
            "                \"title\": \"Homepage\",",
            "                \"link\": Page.objects.filter(depth=2).first().id,",
            "            },",
            "        )",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")",
            "",
            "        # Check that the link was created",
            "        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage\").count(), 1)",
            "",
            "    def test_prepopulated_field_data_in_context(self):",
            "        response = self.get()",
            "        self.assertIn(",
            "            'data-prepopulated-fields=\"[{&quot;id&quot;: &quot;#id_title&quot;, &quot;name&quot;: &quot;title&quot;, &quot;dependency_ids&quot;: [&quot;#id_author&quot;], &quot;dependency_list&quot;: [&quot;author&quot;], &quot;maxLength&quot;: 255, &quot;allowUnicode&quot;: false}]\"',",
            "            response.content.decode(\"UTF-8\"),",
            "        )",
            "",
            "",
            "@override_settings(WAGTAIL_I18N_ENABLED=True)",
            "class TestTranslatableCreateView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, **params):",
            "        return self.client.get(\"/admin/modeladmintest/translatablebook/create/\", params)",
            "",
            "    def test_simple(self):",
            "        response = self.get(locale=\"fr\")",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check that the locale select exists and is set correctly",
            "        expected = '<a href=\"javascript:void(0)\" aria-label=\"French\" class=\"c-dropdown__button u-btn-current w-no-underline\">'",
            "        self.assertContains(response, expected)",
            "",
            "        # Check that the other locale link is right",
            "        expected = \"\"\"",
            "        <a href=\"/admin/modeladmintest/translatablebook/create/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">",
            "            English",
            "        </a>\"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "",
            "class TestRevisableCreateView(TestCase, WagtailTestUtils):",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def post(self, post_data):",
            "        return self.client.post(\"/admin/modeladmintest/publisher/create/\", post_data)",
            "",
            "    def test_create_with_revision(self):",
            "        data = {\"name\": \"foo\"}",
            "        response = self.post(data)",
            "        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")",
            "",
            "        instances = Publisher.objects.filter(name=\"foo\")",
            "        instance = instances.first()",
            "        self.assertEqual(instances.count(), 1)",
            "",
            "        # The revision should be created",
            "        revisions = instance.revisions",
            "        revision = revisions.first()",
            "        self.assertEqual(revisions.count(), 1)",
            "        self.assertEqual(revision.content[\"name\"], \"foo\")",
            "",
            "        # The log entry should have the revision attached",
            "        log_entries = ModelLogEntry.objects.for_instance(instance).filter(",
            "            action=\"wagtail.create\"",
            "        )",
            "        self.assertEqual(log_entries.count(), 1)",
            "        self.assertEqual(log_entries.first().revision, revision)",
            "",
            "",
            "class TestInspectView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "        img = Image.objects.create(",
            "            title=\"LOTR cover\",",
            "            file=get_test_image_file(),",
            "        )",
            "        book = Book.objects.get(title=\"The Lord of the Rings\")",
            "        book.cover_image = img",
            "        book.save()",
            "",
            "    def get_for_author(self, author_id):",
            "        return self.client.get(\"/admin/modeladmintest/author/inspect/%d/\" % author_id)",
            "",
            "    def get_for_book(self, book_id):",
            "        return self.client.get(\"/admin/modeladmintest/book/inspect/%d/\" % book_id)",
            "",
            "    def test_author_simple(self):",
            "        response = self.get_for_author(1)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_author_name_present(self):",
            "        \"\"\"",
            "        The author name should appear twice. Once in the header, and once",
            "        more in the field listing",
            "        \"\"\"",
            "        response = self.get_for_author(1)",
            "        self.assertContains(response, \"J. R. R. Tolkien\", 2)",
            "",
            "    def test_author_dob_not_present(self):",
            "        \"\"\"",
            "        The date of birth shouldn't appear, because the field wasn't included",
            "        in the `inspect_view_fields` list",
            "        \"\"\"",
            "        response = self.get_for_author(1)",
            "        self.assertNotContains(response, \"1892\")",
            "",
            "    def test_book_simple(self):",
            "        response = self.get_for_book(1)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_book_title_present(self):",
            "        \"\"\"",
            "        The book title should appear once only, in the header, as 'title'",
            "        was added to the `inspect_view_fields_ignore` list",
            "        \"\"\"",
            "        response = self.get_for_book(1)",
            "        self.assertContains(response, \"The Lord of the Rings\", 1)",
            "",
            "    def test_book_author_present(self):",
            "        \"\"\"",
            "        The author name should appear, because 'author' is not in",
            "        `inspect_view_fields_ignore` and should be returned by the",
            "        `get_inspect_view_fields` method.",
            "        \"\"\"",
            "        response = self.get_for_book(1)",
            "        self.assertContains(response, \"J. R. R. Tolkien\", 1)",
            "",
            "    def test_book_extract_document_html_escaping(self):",
            "        doc = Document.objects.create(",
            "            title=\"Title with <script>alert('XSS')</script>\",",
            "            file=get_test_document_file(),",
            "        )",
            "        book = Book.objects.get(title=\"The Lord of the Rings\")",
            "        book.extract_document = doc",
            "        book.save()",
            "        response = self.get_for_book(1)",
            "        self.assertNotContains(response, \"Title with <script>alert('XSS')</script>\")",
            "        self.assertContains(",
            "            response, \"Title with &lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;\"",
            "        )",
            "",
            "    def test_non_existent(self):",
            "        response = self.get_for_book(100)",
            "        self.assertEqual(response.status_code, 404)",
            "",
            "    def test_back_to_listing(self):",
            "        response = self.client.get(\"/admin/modeladmintest/author/inspect/1/\")",
            "        # check that back to listing link exists",
            "        expected = \"\"\"",
            "            <p class=\"back\">",
            "                    <a href=\"/admin/modeladmintest/author/\">",
            "                        <svg class=\"icon icon-arrow-left default\" aria-hidden=\"true\">",
            "                            <use href=\"#icon-arrow-left\"></use>",
            "                        </svg>",
            "                        Back to author list",
            "                    </a>",
            "            </p>",
            "        \"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "",
            "class TestEditView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.user = self.login()",
            "        ModelLogEntry.objects.create(",
            "            content_type=ContentType.objects.get_for_model(Book),",
            "            label=\"The Lord of the Rings\",",
            "            action=\"wagtail.create\",",
            "            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),",
            "            object_id=\"1\",",
            "        )",
            "",
            "    def get(self, book_id):",
            "        return self.client.get(\"/admin/modeladmintest/book/edit/%d/\" % book_id)",
            "",
            "    def post(self, book_id, post_data):",
            "        return self.client.post(",
            "            \"/admin/modeladmintest/book/edit/%d/\" % book_id, post_data",
            "        )",
            "",
            "    def test_simple(self):",
            "        response = self.get(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(response, \"The Lord of the Rings\")",
            "",
            "        # \"Last updated\" timestamp should be present",
            "        self.assertContains(",
            "            response, 'data-wagtail-tooltip=\"Sept. 30, 2021, 10:01 a.m.\"'",
            "        )",
            "        # History link should be present",
            "        self.assertContains(response, 'href=\"/admin/modeladmintest/book/history/1/\"')",
            "",
            "        url_finder = AdminURLFinder(self.user)",
            "        expected_url = \"/admin/modeladmintest/book/edit/1/\"",
            "        self.assertEqual(url_finder.get_edit_url(Book.objects.get(id=1)), expected_url)",
            "",
            "    def test_non_existent(self):",
            "        response = self.get(100)",
            "",
            "        self.assertEqual(response.status_code, 404)",
            "",
            "    def test_edit(self):",
            "        response = self.post(",
            "            1,",
            "            {",
            "                \"title\": \"The Lady of the Rings\",",
            "                \"author\": 1,",
            "            },",
            "        )",
            "",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "        # Check that the book was updated",
            "        self.assertEqual(Book.objects.get(id=1).title, \"The Lady of the Rings\")",
            "",
            "    def test_post_invalid(self):",
            "        response = self.post(",
            "            1,",
            "            {",
            "                \"title\": \"\",",
            "                \"author\": 1,",
            "            },",
            "        )",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check that the title was not updated",
            "        self.assertEqual(Book.objects.get(id=1).title, \"The Lord of the Rings\")",
            "",
            "        # Check that a form error was raised",
            "        self.assertFormError(response, \"form\", \"title\", \"This field is required.\")",
            "        self.assertContains(response, \"error-message\", count=1)",
            "",
            "    def test_exclude_passed_to_extract_panel_definitions(self):",
            "        path_to_form_fields_exclude_property = (",
            "            \"wagtail.contrib.modeladmin.options.ModelAdmin.form_fields_exclude\"",
            "        )",
            "        with mock.patch(",
            "            \"wagtail.contrib.modeladmin.options.extract_panel_definitions_from_model_class\"",
            "        ) as m:",
            "            with mock.patch(",
            "                path_to_form_fields_exclude_property, new_callable=mock.PropertyMock",
            "            ) as mock_form_fields_exclude:",
            "                mock_form_fields_exclude.return_value = [\"123\"]",
            "",
            "                self.get(1)",
            "                self.assertTrue(mock_form_fields_exclude.called)",
            "                m.assert_called_with(",
            "                    Book, exclude=mock_form_fields_exclude.return_value",
            "                )",
            "",
            "    def test_clean_form_once(self):",
            "        with mock.patch(",
            "            \"wagtail.test.modeladmintest.wagtail_hooks.PublisherModelAdminForm.clean\"",
            "        ) as mock_form_clean:",
            "            publisher = Publisher.objects.create(name=\"Sharper Collins\")",
            "",
            "            response = self.client.post(",
            "                \"/admin/modeladmintest/publisher/edit/%d/\" % publisher.pk, {\"name\": \"\"}",
            "            )",
            "            self.assertEqual(response.status_code, 200)",
            "",
            "            mock_form_clean.assert_called_once()",
            "",
            "    def test_edit_view_with_multifieldpanel(self):",
            "        # https://github.com/wagtail/wagtail/issues/6413",
            "        link = RelatedLink.objects.create(",
            "            title=\"Homepage\", link=Page.objects.filter(depth=2).first()",
            "        )",
            "        response = self.client.get(",
            "            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id",
            "        )",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        response = self.client.post(",
            "            \"/admin/modeladmintest/relatedlink/edit/%d/\" % link.id,",
            "            {",
            "                \"title\": \"Homepage edited\",",
            "                \"link\": Page.objects.filter(depth=2).first().id,",
            "            },",
            "        )",
            "        # Should redirect back to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/relatedlink/\")",
            "",
            "        # Check that the link was updated",
            "        self.assertEqual(RelatedLink.objects.filter(title=\"Homepage edited\").count(), 1)",
            "",
            "",
            "@override_settings(WAGTAIL_I18N_ENABLED=True)",
            "class TestTranslatableBookEditView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, book_id, **params):",
            "        return self.client.get(",
            "            \"/admin/modeladmintest/translatablebook/edit/%d/\" % book_id, params",
            "        )",
            "",
            "    def test_simple(self):",
            "        book = TranslatableBook.objects.first()",
            "        response = self.get(book.id)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check the locale switcher isn't there",
            "        self.assertNotContains(response, \"English\", html=True)",
            "",
            "        tbook = book.copy_for_translation(locale=Locale.objects.get(language_code=\"fr\"))",
            "        tbook.save()",
            "",
            "        response = self.get(tbook.id)",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "        # Check the locale switcher is there",
            "        expected = \"\"\"",
            "        <a href=\"/admin/modeladmintest/translatablebook/edit/1/?locale=en\" aria-label=\"English\" class=\"u-link is-live w-no-underline\">",
            "            English",
            "        </a>\"\"\"",
            "        self.assertContains(response, expected, html=True)",
            "",
            "",
            "class TestRevisableEditView(TestCase, WagtailTestUtils):",
            "    def setUp(self):",
            "        self.login()",
            "        self.instance = Publisher.objects.create(name=\"foo\")",
            "",
            "    def post(self, post_data):",
            "        return self.client.post(",
            "            \"/admin/modeladmintest/publisher/edit/%s/\" % self.instance.pk, post_data",
            "        )",
            "",
            "    def test_edit_with_revision(self):",
            "        data = {\"name\": \"bar\"}",
            "        response = self.post(data)",
            "        self.assertRedirects(response, \"/admin/modeladmintest/publisher/\")",
            "",
            "        instances = Publisher.objects.filter(name=\"bar\")",
            "        instance = instances.first()",
            "        self.assertEqual(instances.count(), 1)",
            "",
            "        # The revision should be created",
            "        revisions = instance.revisions",
            "        revision = revisions.first()",
            "        self.assertEqual(revisions.count(), 1)",
            "        self.assertEqual(revision.content[\"name\"], \"bar\")",
            "",
            "        # The log entry should have the revision attached",
            "        log_entries = ModelLogEntry.objects.for_instance(instance).filter(",
            "            action=\"wagtail.edit\"",
            "        )",
            "        self.assertEqual(log_entries.count(), 1)",
            "        self.assertEqual(log_entries.first().revision, revision)",
            "",
            "",
            "class TestPageSpecificViews(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "    expected_status_code = 404",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def test_choose_parent(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/choose_parent/\")",
            "        self.assertEqual(response.status_code, self.expected_status_code)",
            "",
            "",
            "class TestConfirmDeleteView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, book_id):",
            "        return self.client.get(\"/admin/modeladmintest/book/delete/%d/\" % book_id)",
            "",
            "    def post(self, book_id):",
            "        return self.client.post(\"/admin/modeladmintest/book/delete/%d/\" % book_id)",
            "",
            "    def test_simple(self):",
            "        response = self.get(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_non_existent(self):",
            "        response = self.get(100)",
            "",
            "        self.assertEqual(response.status_code, 404)",
            "",
            "    def test_post(self):",
            "        response = self.post(1)",
            "",
            "        # User redirected to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "        # Book deleted",
            "        self.assertFalse(Book.objects.filter(id=1).exists())",
            "",
            "",
            "class TestDeleteViewWithProtectedRelation(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def get(self, author_id):",
            "        return self.client.get(\"/admin/modeladmintest/author/delete/%d/\" % author_id)",
            "",
            "    def post(self, author_id):",
            "        return self.client.post(\"/admin/modeladmintest/author/delete/%d/\" % author_id)",
            "",
            "    def test_get_with_dependent_object(self):",
            "        response = self.get(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_get_without_dependent_object(self):",
            "        response = self.get(4)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_post_with_dependent_object(self):",
            "        response = self.post(1)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(",
            "            response, \"'J. R. R. Tolkien' is currently referenced by other objects\"",
            "        )",
            "        self.assertContains(response, \"<li><b>Book:</b> The Lord of the Rings</li>\")",
            "",
            "        # Author not deleted",
            "        self.assertTrue(Author.objects.filter(id=1).exists())",
            "",
            "    def test_post_without_dependent_object(self):",
            "        response = self.post(4)",
            "",
            "        # User redirected to index",
            "        self.assertRedirects(response, \"/admin/modeladmintest/author/\")",
            "",
            "        # Author deleted",
            "        self.assertFalse(Author.objects.filter(id=4).exists())",
            "",
            "    def test_post_with_1to1_dependent_object(self):",
            "        response = self.post(5)",
            "",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(",
            "            response, \"'Harper Lee' is currently referenced by other objects\"",
            "        )",
            "        self.assertContains(",
            "            response, \"<li><b>Solo Book:</b> To Kill a Mockingbird</li>\"",
            "        )",
            "",
            "        # Author not deleted",
            "        self.assertTrue(Author.objects.filter(id=5).exists())",
            "",
            "",
            "class TestDeleteViewModelReprPrimary(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def test_delete(self):",
            "        response = self.client.post(\"/admin/modeladmintest/token/delete/boom/\")",
            "        self.assertEqual(response.status_code, 302)",
            "",
            "",
            "class TestEditorAccess(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        # Create a user",
            "        self.user = self.create_user(username=\"test2\", password=\"password\")",
            "        self.group = Group.objects.get(name=\"Editors\")",
            "        self.user.groups.add(self.group)",
            "        self.book_content_type = ContentType.objects.get_for_model(Book)",
            "",
            "        # Login",
            "        self.login(username=\"test2\", password=\"password\")",
            "",
            "    def test_index_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"add_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_inspect_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"add_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/inspect/2/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_create_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/create/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"add_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/create/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_edit_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"change_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/edit/2/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_admin_url_finder_without_permission(self):",
            "        url_finder = AdminURLFinder(self.user)",
            "        self.assertIsNone(url_finder.get_edit_url(Book.objects.get(id=2)))",
            "",
            "    def test_admin_url_finder_with_permission(self):",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"change_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        url_finder = AdminURLFinder(self.user)",
            "        self.assertEqual(",
            "            url_finder.get_edit_url(Book.objects.get(id=2)),",
            "            \"/admin/modeladmintest/book/edit/2/\",",
            "        )",
            "",
            "    def test_delete_get_permitted(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"delete_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.get(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "    def test_delete_post_permitted(self):",
            "        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertRedirects(response, \"/admin/\")",
            "",
            "        self.group.permissions.add(",
            "            Permission.objects.get(",
            "                codename=\"delete_book\", content_type=self.book_content_type",
            "            )",
            "        )",
            "        response = self.client.post(\"/admin/modeladmintest/book/delete/2/\")",
            "        self.assertRedirects(response, \"/admin/modeladmintest/book/\")",
            "",
            "",
            "class TestHistoryView(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "        ModelLogEntry.objects.create(",
            "            content_type=ContentType.objects.get_for_model(Book),",
            "            label=\"The Lord of the Rings\",",
            "            action=\"wagtail.create\",",
            "            timestamp=make_aware(datetime.datetime(2021, 9, 30, 10, 1, 0)),",
            "            object_id=\"1\",",
            "        )",
            "",
            "    def test_simple(self):",
            "        response = self.client.get(\"/admin/modeladmintest/book/history/1/\")",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertContains(response, \"<td>Created</td>\", html=True)",
            "        self.assertContains(",
            "            response,",
            "            'data-tippy-content=\"Sept. 30, 2021, 10:01 a.m.\"',",
            "        )",
            "",
            "",
            "class TestQuoting(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "    expected_status_code = 200",
            "",
            "    def setUp(self):",
            "        self.login()",
            "        self.tok_reg = Token.objects.create(key=\"RegularName\")",
            "        self.tok_irr = Token.objects.create(key=\"Irregular_Name\")",
            "",
            "    def test_action_links(self):",
            "        response = self.client.get(\"/admin/modeladmintest/token/\")",
            "",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/edit/RegularName/\"'",
            "        )",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/delete/RegularName/\"'",
            "        )",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/edit/Irregular_5FName/\"'",
            "        )",
            "        self.assertContains(",
            "            response, 'href=\"/admin/modeladmintest/token/delete/Irregular_5FName/\"'",
            "        )",
            "",
            "        response = self.client.get(\"/admin/modeladmintest/token/edit/Irregular_5FName/\")",
            "        self.assertEqual(response.status_code, 200)",
            "        response = self.client.get(",
            "            \"/admin/modeladmintest/token/delete/Irregular_5FName/\"",
            "        )",
            "        self.assertEqual(response.status_code, 200)",
            "",
            "",
            "class TestPanelConfigurationChecks(TestCase, WagtailTestUtils):",
            "    def setUp(self):",
            "        self.warning_id = \"wagtailadmin.W002\"",
            "",
            "        def get_checks_result():",
            "            # run checks only with the 'panels' tag",
            "            checks_result = checks.run_checks(tags=[\"panels\"])",
            "            return [",
            "                warning for warning in checks_result if warning.id == self.warning_id",
            "            ]",
            "",
            "        self.get_checks_result = get_checks_result",
            "",
            "    def test_model_with_single_tabbed_panel_only(self):",
            "        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]",
            "",
            "        warning = checks.Warning(",
            "            \"Publisher.content_panels will have no effect on modeladmin editing\",",
            "            hint=\"\"\"Ensure that Publisher uses `panels` instead of `content_panels`\\",
            "or set up an `edit_handler` if you want a tabbed editing interface.",
            "There are no default tabs on non-Page models so there will be no\\",
            " Content tab for the content_panels to render in.\"\"\",",
            "            obj=Publisher,",
            "            id=\"wagtailadmin.W002\",",
            "        )",
            "",
            "        checks_results = self.get_checks_result()",
            "",
            "        self.assertIn(warning, checks_results)",
            "",
            "        # clean up for future checks",
            "        delattr(Publisher, \"content_panels\")",
            "",
            "    def test_model_with_two_tabbed_panels_only(self):",
            "        Publisher.settings_panels = [FieldPanel(\"name\")]",
            "        Publisher.promote_panels = [FieldPanel(\"headquartered_in\")]",
            "",
            "        warning_1 = checks.Warning(",
            "            \"Publisher.promote_panels will have no effect on modeladmin editing\",",
            "            hint=\"\"\"Ensure that Publisher uses `panels` instead of `promote_panels`\\",
            "or set up an `edit_handler` if you want a tabbed editing interface.",
            "There are no default tabs on non-Page models so there will be no\\",
            " Promote tab for the promote_panels to render in.\"\"\",",
            "            obj=Publisher,",
            "            id=\"wagtailadmin.W002\",",
            "        )",
            "",
            "        warning_2 = checks.Warning(",
            "            \"Publisher.settings_panels will have no effect on modeladmin editing\",",
            "            hint=\"\"\"Ensure that Publisher uses `panels` instead of `settings_panels`\\",
            "or set up an `edit_handler` if you want a tabbed editing interface.",
            "There are no default tabs on non-Page models so there will be no\\",
            " Settings tab for the settings_panels to render in.\"\"\",",
            "            obj=Publisher,",
            "            id=\"wagtailadmin.W002\",",
            "        )",
            "",
            "        checks_results = self.get_checks_result()",
            "",
            "        self.assertIn(warning_1, checks_results)",
            "        self.assertIn(warning_2, checks_results)",
            "",
            "        # clean up for future checks",
            "        delattr(Publisher, \"settings_panels\")",
            "        delattr(Publisher, \"promote_panels\")",
            "",
            "    def test_model_with_single_tabbed_panel_and_edit_handler(self):",
            "        Publisher.content_panels = [FieldPanel(\"name\"), FieldPanel(\"headquartered_in\")]",
            "        Publisher.edit_handler = TabbedInterface(Publisher.content_panels)",
            "",
            "        # no errors should occur",
            "        self.assertEqual(self.get_checks_result(), [])",
            "",
            "        # clean up for future checks",
            "        delattr(Publisher, \"content_panels\")",
            "        delattr(Publisher, \"edit_handler\")",
            "",
            "",
            "class TestMenuSetting(TestCase, WagtailTestUtils):",
            "    fixtures = [\"modeladmintest_test.json\"]",
            "",
            "    def setUp(self):",
            "        self.login()",
            "",
            "    def test_default_menu_setting_model_admin(self):",
            "        modeladmin = BookModelAdmin()",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Books\")",
            "        self.assertEqual(menu_item.name, \"books\")",
            "",
            "    def test_custom_menu_setting_model_admin(self):",
            "        modeladmin = BookModelAdmin()",
            "        modeladmin.menu_label = \"Book Model Label\"",
            "        modeladmin.menu_item_name = \"bookitem\"",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Book Model Label\")",
            "        self.assertEqual(menu_item.name, \"bookitem\")",
            "",
            "    def test_default_menu_setting_model_admin_group(self):",
            "        modeladmin = EventsAdminGroup()",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Events\")",
            "        self.assertEqual(menu_item.name, \"events\")",
            "",
            "    def test_custom_menu_setting_model_admin_group(self):",
            "        modeladmin = EventsAdminGroup()",
            "        modeladmin.menu_label = \"Event Model Label\"",
            "        modeladmin.menu_item_name = \"eventitem\"",
            "",
            "        menu_item = modeladmin.get_menu_item()",
            "        self.assertEqual(menu_item.label, \"Event Model Label\")",
            "        self.assertEqual(menu_item.name, \"eventitem\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "wagtail.contrib.modeladmin.tests.test_simple_modeladmin.TestInspectView.fixtures",
            "trytond.res.user",
            "wagtail.contrib.modeladmin.tests.test_simple_modeladmin.TestInspectView.self"
        ]
    },
    "wagtail/contrib/modeladmin/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from django.utils.decorators import method_decorator"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from django.utils.encoding import force_str"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from django.utils.functional import cached_property"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from django.utils.html import format_html"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from django.utils.http import urlencode"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.safestring import mark_safe"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from django.utils.text import capfirst"
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from django.utils.translation import gettext as _"
            },
            "8": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from django.utils.translation import gettext_lazy"
            },
            "9": {
                "beforePatchRowNumber": 1131,
                "afterPatchRowNumber": 1131,
                "PatchRowcode": "         \"\"\"Render a link to a document\"\"\""
            },
            "10": {
                "beforePatchRowNumber": 1132,
                "afterPatchRowNumber": 1132,
                "PatchRowcode": "         document = getattr(self.instance, field_name)"
            },
            "11": {
                "beforePatchRowNumber": 1133,
                "afterPatchRowNumber": 1133,
                "PatchRowcode": "         if document:"
            },
            "12": {
                "beforePatchRowNumber": 1134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return mark_safe("
            },
            "13": {
                "beforePatchRowNumber": 1135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'"
            },
            "14": {
                "beforePatchRowNumber": 1136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                % ("
            },
            "15": {
                "beforePatchRowNumber": 1137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    document.url,"
            },
            "16": {
                "beforePatchRowNumber": 1138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    document.title,"
            },
            "17": {
                "beforePatchRowNumber": 1139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    document.file_extension.upper(),"
            },
            "18": {
                "beforePatchRowNumber": 1140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    filesizeformat(document.file.size),"
            },
            "19": {
                "beforePatchRowNumber": 1141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1134,
                "PatchRowcode": "+            return format_html("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "+                '<a href=\"{}\">{} <span class=\"meta\">({}, {})</span></a>',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1136,
                "PatchRowcode": "+                document.url,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1137,
                "PatchRowcode": "+                document.title,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "+                document.file_extension.upper(),"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "+                filesizeformat(document.file.size),"
            },
            "26": {
                "beforePatchRowNumber": 1142,
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "             )"
            },
            "27": {
                "beforePatchRowNumber": 1143,
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "         return self.model_admin.get_empty_value_display(field_name)"
            },
            "28": {
                "beforePatchRowNumber": 1144,
                "afterPatchRowNumber": 1142,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import warnings",
            "from collections import OrderedDict",
            "",
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.admin import FieldListFilter",
            "from django.contrib.admin.options import IncorrectLookupParameters",
            "from django.contrib.admin.utils import (",
            "    get_fields_from_path,",
            "    label_for_field,",
            "    lookup_field,",
            "    prepare_lookup_value,",
            "    quote,",
            "    unquote,",
            ")",
            "from django.contrib.auth.decorators import login_required",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ImproperlyConfigured,",
            "    ObjectDoesNotExist,",
            "    PermissionDenied,",
            "    SuspiciousOperation,",
            ")",
            "from django.core.paginator import InvalidPage, Paginator",
            "from django.db import models, transaction",
            "from django.db.models.fields.related import ManyToManyField, OneToOneRel",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.defaultfilters import filesizeformat",
            "from django.utils.decorators import method_decorator",
            "from django.utils.encoding import force_str",
            "from django.utils.functional import cached_property",
            "from django.utils.http import urlencode",
            "from django.utils.safestring import mark_safe",
            "from django.utils.text import capfirst",
            "from django.utils.translation import gettext as _",
            "from django.utils.translation import gettext_lazy",
            "from django.views.generic import TemplateView",
            "from django.views.generic.edit import FormView",
            "from django.views.generic.list import MultipleObjectMixin",
            "",
            "from wagtail.admin import messages",
            "from wagtail.admin.ui.tables import Column, DateColumn, Table, UserColumn",
            "from wagtail.admin.views.generic.base import WagtailAdminTemplateMixin",
            "from wagtail.admin.views.mixins import SpreadsheetExportMixin",
            "from wagtail.log_actions import log",
            "from wagtail.log_actions import registry as log_registry",
            "from wagtail.models import Locale, RevisionMixin, TranslatableMixin",
            "from wagtail.utils.deprecation import RemovedInWagtail50Warning",
            "",
            "from .forms import ParentChooserForm",
            "",
            "try:",
            "    from django.contrib.admin.utils import lookup_spawns_duplicates",
            "except ImportError:",
            "    # fallback for Django <4.0",
            "    from django.contrib.admin.utils import (",
            "        lookup_needs_distinct as lookup_spawns_duplicates,",
            "    )",
            "",
            "",
            "QUERY_TERMS = {",
            "    \"contains\",",
            "    \"day\",",
            "    \"endswith\",",
            "    \"exact\",",
            "    \"gt\",",
            "    \"gte\",",
            "    \"hour\",",
            "    \"icontains\",",
            "    \"iendswith\",",
            "    \"iexact\",",
            "    \"in\",",
            "    \"iregex\",",
            "    \"isnull\",",
            "    \"istartswith\",",
            "    \"lt\",",
            "    \"lte\",",
            "    \"minute\",",
            "    \"month\",",
            "    \"range\",",
            "    \"regex\",",
            "    \"search\",",
            "    \"second\",",
            "    \"startswith\",",
            "    \"week_day\",",
            "    \"year\",",
            "}",
            "",
            "",
            "class WMABaseView(TemplateView):",
            "    \"\"\"",
            "    Groups together common functionality for all app views.",
            "    \"\"\"",
            "",
            "    model_admin = None",
            "    meta_title = \"\"",
            "    page_title = \"\"",
            "    page_subtitle = \"\"",
            "",
            "    def __init__(self, model_admin):",
            "        self.model_admin = model_admin",
            "        self.model = model_admin.model",
            "        self.opts = self.model._meta",
            "        self.app_label = force_str(self.opts.app_label)",
            "        self.model_name = force_str(self.opts.model_name)",
            "        self.verbose_name = force_str(self.opts.verbose_name)",
            "        self.verbose_name_plural = force_str(self.opts.verbose_name_plural)",
            "        self.pk_attname = self.opts.pk.attname",
            "        self.is_pagemodel = model_admin.is_pagemodel",
            "        self.permission_helper = model_admin.permission_helper",
            "        self.url_helper = model_admin.url_helper",
            "",
            "    def check_action_permitted(self, user):",
            "        return True",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.check_action_permitted(request.user):",
            "            raise PermissionDenied",
            "        button_helper_class = self.model_admin.get_button_helper_class()",
            "        self.button_helper = button_helper_class(self, request)",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    @cached_property",
            "    def menu_icon(self):",
            "        return self.model_admin.get_menu_icon()",
            "",
            "    @cached_property",
            "    def header_icon(self):",
            "        return self.menu_icon",
            "",
            "    def get_page_title(self):",
            "        return self.page_title or capfirst(self.opts.verbose_name_plural)",
            "",
            "    def get_meta_title(self):",
            "        return self.meta_title or self.get_page_title()",
            "",
            "    @cached_property",
            "    def index_url(self):",
            "        return self.url_helper.index_url",
            "",
            "    @cached_property",
            "    def create_url(self):",
            "        return self.url_helper.create_url",
            "",
            "    def get_base_queryset(self, request=None):",
            "        return self.model_admin.get_queryset(request or self.request)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {",
            "            \"view\": self,",
            "            \"model_admin\": self.model_admin,",
            "        }",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "",
            "class ModelFormView(WMABaseView, FormView):",
            "    def setup(self, request, *args, **kwargs):",
            "        super().setup(request, *args, **kwargs)",
            "        self.edit_handler = self.get_edit_handler()",
            "",
            "    def get_form(self):",
            "        form = super().get_form()",
            "        return form",
            "",
            "    def get_edit_handler(self):",
            "        try:",
            "            edit_handler = self.model_admin.get_edit_handler()",
            "        except TypeError:",
            "            edit_handler = self.model_admin.get_edit_handler(",
            "                instance=None, request=None",
            "            )",
            "            warnings.warn(",
            "                \"%s.get_edit_handler should not accept instance or request arguments\"",
            "                % type(self.model_admin).__name__,",
            "                category=RemovedInWagtail50Warning,",
            "            )",
            "",
            "        return edit_handler.bind_to_model(self.model_admin.model)",
            "",
            "    def get_form_class(self):",
            "        return self.edit_handler.get_form_class()",
            "",
            "    def get_success_url(self):",
            "        return self.index_url",
            "",
            "    def get_instance(self):",
            "        return getattr(self, \"instance\", None) or self.model()",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs.update({\"instance\": self.get_instance(), \"for_user\": self.request.user})",
            "        return kwargs",
            "",
            "    @property",
            "    def media(self):",
            "        return forms.Media(",
            "            css={\"all\": self.model_admin.get_form_view_extra_css()},",
            "            js=self.model_admin.get_form_view_extra_js(),",
            "        )",
            "",
            "    def get_context_data(self, form=None, **kwargs):",
            "        if form is None:",
            "            form = self.get_form()",
            "",
            "        bound_panel = self.edit_handler.get_bound_panel(",
            "            form=form, instance=form.instance, request=self.request",
            "        )",
            "",
            "        prepopulated_fields = self.get_prepopulated_fields(form)",
            "        context = {",
            "            \"is_multipart\": form.is_multipart(),",
            "            \"edit_handler\": bound_panel,",
            "            \"form\": form,",
            "            \"prepopulated_fields\": prepopulated_fields,",
            "            \"media\": self.media + bound_panel.media + form.media,",
            "        }",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "    def get_prepopulated_fields(self, form):",
            "        fields = []",
            "        for field_name, dependencies in self.model_admin.get_prepopulated_fields(",
            "            self.request",
            "        ).items():",
            "            missing_dependencies = [",
            "                f\"'{f}'\" for f in dependencies if f not in form.fields",
            "            ]",
            "            if len(missing_dependencies) != 0:",
            "                missing_deps_string = \", \".join(missing_dependencies)",
            "                dependency_string = (",
            "                    \"dependencies\" if len(missing_dependencies) > 1 else \"dependency\"",
            "                )",
            "                warnings.warn(",
            "                    f\"Missing {dependency_string} {missing_deps_string} for prepopulated_field '{field_name}''.\",",
            "                    category=RuntimeWarning,",
            "                )",
            "            elif field_name in form.fields:",
            "                fields.append(",
            "                    {",
            "                        \"field\": form[field_name],",
            "                        \"dependencies\": [form[f] for f in dependencies],",
            "                    }",
            "                )",
            "        return fields",
            "",
            "    def get_success_message(self, instance):",
            "        return _(\"%(model_name)s '%(object)s' created.\") % {",
            "            \"model_name\": capfirst(self.opts.verbose_name),",
            "            \"object\": instance,",
            "        }",
            "",
            "    def get_success_message_buttons(self, instance):",
            "        button_url = self.url_helper.get_action_url(\"edit\", quote(instance.pk))",
            "        return [messages.button(button_url, _(\"Edit\"))]",
            "",
            "    def get_error_message(self):",
            "        model_name = self.verbose_name",
            "        return _(\"The %(object)s could not be created due to errors.\") % {",
            "            \"object\": model_name",
            "        }",
            "",
            "    def form_valid(self, form):",
            "        self.instance = form.save()",
            "        messages.success(",
            "            self.request,",
            "            self.get_success_message(self.instance),",
            "            buttons=self.get_success_message_buttons(self.instance),",
            "        )",
            "        return redirect(self.get_success_url())",
            "",
            "    def form_invalid(self, form):",
            "        messages.validation_error(self.request, self.get_error_message(), form)",
            "        return self.render_to_response(self.get_context_data(form=form))",
            "",
            "",
            "class InstanceSpecificView(WMABaseView):",
            "",
            "    instance_pk = None",
            "    pk_quoted = None",
            "    instance = None",
            "    locale = None",
            "",
            "    def __init__(self, model_admin, instance_pk):",
            "        super().__init__(model_admin)",
            "        self.instance_pk = unquote(instance_pk)",
            "        self.pk_quoted = quote(self.instance_pk)",
            "        filter_kwargs = {}",
            "        filter_kwargs[self.pk_attname] = self.instance_pk",
            "        object_qs = model_admin.model._default_manager.get_queryset().filter(",
            "            **filter_kwargs",
            "        )",
            "        self.instance = get_object_or_404(object_qs)",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            model_admin.model, TranslatableMixin",
            "        ):",
            "            self.locale = self.instance.locale",
            "",
            "    def get_page_subtitle(self):",
            "        return self.instance",
            "",
            "    @cached_property",
            "    def edit_url(self):",
            "        return self.url_helper.get_action_url(\"edit\", self.pk_quoted)",
            "",
            "    @cached_property",
            "    def delete_url(self):",
            "        return self.url_helper.get_action_url(\"delete\", self.pk_quoted)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {\"instance\": self.instance}",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "",
            "class IndexView(SpreadsheetExportMixin, WMABaseView):",
            "",
            "    ORDER_VAR = \"o\"",
            "    ORDER_TYPE_VAR = \"ot\"",
            "    PAGE_VAR = \"p\"",
            "    SEARCH_VAR = \"q\"",
            "    ERROR_FLAG = \"e\"",
            "    EXPORT_VAR = \"export\"",
            "    IGNORED_PARAMS = (ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, EXPORT_VAR)",
            "",
            "    # sortable_by is required by the django.contrib.admin.templatetags.admin_list.result_headers",
            "    # template tag - see https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.sortable_by",
            "    sortable_by = None",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Only continue if logged in user has list permission",
            "        if not self.permission_helper.user_can_list(request.user):",
            "            raise PermissionDenied",
            "",
            "        self.list_export = self.model_admin.get_list_export(request)",
            "        self.list_display = self.model_admin.get_list_display(request)",
            "        self.list_filter = self.model_admin.get_list_filter(request)",
            "        self.search_fields = self.model_admin.get_search_fields(request)",
            "        self.items_per_page = self.model_admin.list_per_page",
            "        self.select_related = self.model_admin.list_select_related",
            "        self.search_handler = self.model_admin.get_search_handler(",
            "            request, self.search_fields",
            "        )",
            "        self.export = request.GET.get(self.EXPORT_VAR)",
            "",
            "        # Get search parameters from the query string.",
            "        try:",
            "            self.page_num = int(request.GET.get(self.PAGE_VAR, 0))",
            "        except ValueError:",
            "            self.page_num = 0",
            "",
            "        self.params = dict(request.GET.items())",
            "        if self.PAGE_VAR in self.params:",
            "            del self.params[self.PAGE_VAR]",
            "        if self.ERROR_FLAG in self.params:",
            "            del self.params[self.ERROR_FLAG]",
            "        if self.EXPORT_VAR in self.params:",
            "            del self.params[self.EXPORT_VAR]",
            "",
            "        self.query = request.GET.get(self.SEARCH_VAR, \"\")",
            "",
            "        self.queryset = self.get_queryset(request)",
            "",
            "        if self.export in self.FORMATS:",
            "            return self.as_spreadsheet(self.queryset, self.export)",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_filename(self):",
            "        \"\"\"Get filename for exported spreadsheet, without extension\"\"\"",
            "        return getattr(self.model_admin, \"export_filename\", super().get_filename())",
            "",
            "    def get_heading(self, queryset, field):",
            "        \"\"\"Get headings for exported spreadsheet column for the relevant field\"\"\"",
            "        heading_override = self.export_headings.get(field)",
            "        if heading_override:",
            "            return force_str(heading_override)",
            "        return force_str(",
            "            label_for_field(",
            "                field, model=self.model, model_admin=self.model_admin",
            "            ).title()",
            "        )",
            "",
            "    def to_row_dict(self, item):",
            "        \"\"\"Returns an OrderedDict (in the order given by list_export) of the exportable information for a model instance\"\"\"",
            "        row_dict = OrderedDict()",
            "        for field in self.list_export:",
            "            f, attr, value = lookup_field(field, item, self.model_admin)",
            "            if not value:",
            "                value = getattr(",
            "                    attr,",
            "                    \"empty_value_display\",",
            "                    self.model_admin.get_empty_value_display(field),",
            "                )",
            "            row_dict[field] = value",
            "",
            "        return row_dict",
            "",
            "    @property",
            "    def media(self):",
            "        return forms.Media(",
            "            css={\"all\": self.model_admin.get_index_view_extra_css()},",
            "            js=self.model_admin.get_index_view_extra_js(),",
            "        )",
            "",
            "    def get_buttons_for_obj(self, obj):",
            "        return self.button_helper.get_buttons_for_obj(",
            "            obj, classnames_add=[\"button-small\"]",
            "        )",
            "",
            "    def get_search_results(self, request, queryset, search_term):",
            "        kwargs = self.model_admin.get_extra_search_kwargs(request, search_term)",
            "        kwargs[\"preserve_order\"] = self.ORDER_VAR in request.GET",
            "        return self.search_handler.search_queryset(queryset, search_term, **kwargs)",
            "",
            "    def get_filters_params(self, params=None):",
            "        \"\"\"",
            "        Returns all params except IGNORED_PARAMS",
            "        \"\"\"",
            "        if not params:",
            "            params = self.params",
            "        lookup_params = params.copy()  # a dictionary of the query string",
            "        # Remove all the parameters that are globally and systematically",
            "        # ignored.",
            "        for ignored in self.IGNORED_PARAMS:",
            "            if ignored in lookup_params:",
            "                del lookup_params[ignored]",
            "        return lookup_params",
            "",
            "    def get_filters(self, request):",
            "        lookup_params = self.get_filters_params()",
            "        use_distinct = False",
            "",
            "        filter_specs = []",
            "        if self.list_filter:",
            "            for list_filter in self.list_filter:",
            "                if callable(list_filter):",
            "                    # This is simply a custom list filter class.",
            "                    spec = list_filter(",
            "                        request, lookup_params, self.model, self.model_admin",
            "                    )",
            "                else:",
            "                    field_path = None",
            "                    if isinstance(list_filter, (tuple, list)):",
            "                        # This is a custom FieldListFilter class for a given",
            "                        # field.",
            "                        field, field_list_filter_class = list_filter",
            "                    else:",
            "                        # This is simply a field name, so use the default",
            "                        # FieldListFilter class that has been registered for",
            "                        # the type of the given field.",
            "                        field = list_filter",
            "                        field_list_filter_class = FieldListFilter.create",
            "                    if not isinstance(field, models.Field):",
            "                        field_path = field",
            "                        field = get_fields_from_path(self.model, field_path)[-1]",
            "                    spec = field_list_filter_class(",
            "                        field,",
            "                        request,",
            "                        lookup_params,",
            "                        self.model,",
            "                        self.model_admin,",
            "                        field_path=field_path,",
            "                    )",
            "",
            "                    # Check if we need to use distinct()",
            "                    use_distinct = use_distinct or lookup_spawns_duplicates(",
            "                        self.opts, field_path",
            "                    )",
            "                if spec and spec.has_output():",
            "                    filter_specs.append(spec)",
            "",
            "        # At this point, all the parameters used by the various ListFilters",
            "        # have been removed from lookup_params, which now only contains other",
            "        # parameters passed via the query string. We now loop through the",
            "        # remaining parameters both to ensure that all the parameters are valid",
            "        # fields and to determine if at least one of them needs distinct(). If",
            "        # the lookup parameters aren't real fields, then bail out.",
            "        try:",
            "            for key, value in lookup_params.items():",
            "                lookup_params[key] = prepare_lookup_value(key, value)",
            "                use_distinct = use_distinct or lookup_spawns_duplicates(self.opts, key)",
            "            return (filter_specs, bool(filter_specs), lookup_params, use_distinct)",
            "        except FieldDoesNotExist as e:",
            "            raise IncorrectLookupParameters from e",
            "",
            "    def get_query_string(self, new_params=None, remove=None):",
            "        if new_params is None:",
            "            new_params = {}",
            "        if remove is None:",
            "            remove = []",
            "        p = self.params.copy()",
            "        for r in remove:",
            "            for k in list(p):",
            "                if k.startswith(r):",
            "                    del p[k]",
            "        for k, v in new_params.items():",
            "            if v is None:",
            "                if k in p:",
            "                    del p[k]",
            "            else:",
            "                p[k] = v",
            "        return \"?%s\" % urlencode(sorted(p.items()))",
            "",
            "    def _get_default_ordering(self):",
            "        ordering = []",
            "        if self.model_admin.ordering:",
            "            ordering = self.model_admin.ordering",
            "        elif self.opts.ordering:",
            "            ordering = self.opts.ordering",
            "        return ordering",
            "",
            "    def get_default_ordering(self, request):",
            "        if self.model_admin.get_ordering(request):",
            "            return self.model_admin.get_ordering(request)",
            "        if self.opts.ordering:",
            "            return self.opts.ordering",
            "        return ()",
            "",
            "    def get_ordering_field(self, field_name):",
            "        \"\"\"",
            "        Returns the proper model field name corresponding to the given",
            "        field_name to use for ordering. field_name may either be the name of a",
            "        proper model field or the name of a method (on the admin or model) or a",
            "        callable with the 'admin_order_field' attribute. Returns None if no",
            "        proper model field name can be matched.",
            "        \"\"\"",
            "        try:",
            "            field = self.opts.get_field(field_name)",
            "            return field.name",
            "        except FieldDoesNotExist:",
            "            # See whether field_name is a name of a non-field",
            "            # that allows sorting.",
            "            if callable(field_name):",
            "                attr = field_name",
            "            elif hasattr(self.model_admin, field_name):",
            "                attr = getattr(self.model_admin, field_name)",
            "            else:",
            "                attr = getattr(self.model, field_name)",
            "            return getattr(attr, \"admin_order_field\", None)",
            "",
            "    def get_ordering(self, request, queryset):",
            "        \"\"\"",
            "        Returns the list of ordering fields for the change list.",
            "        First we check the get_ordering() method in model admin, then we check",
            "        the object's default ordering. Then, any manually-specified ordering",
            "        from the query string overrides anything. Finally, a deterministic",
            "        order is guaranteed by ensuring the primary key is used as the last",
            "        ordering field.",
            "        \"\"\"",
            "        params = self.params",
            "        ordering = list(self.get_default_ordering(request))",
            "        if self.ORDER_VAR in params:",
            "            # Clear ordering and used params",
            "            ordering = []",
            "            order_params = params[self.ORDER_VAR].split(\".\")",
            "            for p in order_params:",
            "                try:",
            "                    none, pfx, idx = p.rpartition(\"-\")",
            "                    field_name = self.list_display[int(idx)]",
            "                    order_field = self.get_ordering_field(field_name)",
            "                    if not order_field:",
            "                        continue  # No 'admin_order_field', skip it",
            "                    # reverse order if order_field has already \"-\" as prefix",
            "                    if order_field.startswith(\"-\") and pfx == \"-\":",
            "                        ordering.append(order_field[1:])",
            "                    else:",
            "                        ordering.append(pfx + order_field)",
            "                except (IndexError, ValueError):",
            "                    continue  # Invalid ordering specified, skip it.",
            "",
            "        # Add the given query's ordering fields, if any.",
            "        ordering.extend(queryset.query.order_by)",
            "",
            "        # Ensure that the primary key is systematically present in the list of",
            "        # ordering fields so we can guarantee a deterministic order across all",
            "        # database backends.",
            "        pk_name = self.opts.pk.name",
            "",
            "        if not (set(ordering) & {\"pk\", \"-pk\", pk_name, \"-\" + pk_name}):",
            "            # ordering isn't already being applied to pk",
            "            ordering.append(\"-\" + pk_name)",
            "",
            "        return ordering",
            "",
            "    def get_ordering_field_columns(self):",
            "        \"\"\"",
            "        Returns an OrderedDict of ordering field column numbers and asc/desc",
            "        \"\"\"",
            "",
            "        # We must cope with more than one column having the same underlying",
            "        # sort field, so we base things on column numbers.",
            "        ordering = self._get_default_ordering()",
            "        ordering_fields = OrderedDict()",
            "        if self.ORDER_VAR not in self.params:",
            "            # for ordering specified on model_admin or model Meta, we don't",
            "            # know the right column numbers absolutely, because there might be",
            "            # morr than one column associated with that ordering, so we guess.",
            "            for field in ordering:",
            "                if field.startswith(\"-\"):",
            "                    field = field[1:]",
            "                    order_type = \"desc\"",
            "                else:",
            "                    order_type = \"asc\"",
            "                for index, attr in enumerate(self.list_display):",
            "                    if self.get_ordering_field(attr) == field:",
            "                        ordering_fields[index] = order_type",
            "                        break",
            "        else:",
            "            for p in self.params[self.ORDER_VAR].split(\".\"):",
            "                none, pfx, idx = p.rpartition(\"-\")",
            "                try:",
            "                    idx = int(idx)",
            "                except ValueError:",
            "                    continue  # skip it",
            "                ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"",
            "        return ordering_fields",
            "",
            "    def get_queryset(self, request=None):",
            "        request = request or self.request",
            "",
            "        # First, we collect all the declared list filters.",
            "        (",
            "            self.filter_specs,",
            "            self.has_filters,",
            "            remaining_lookup_params,",
            "            filters_use_distinct,",
            "        ) = self.get_filters(request)",
            "",
            "        # Then, we let every list filter modify the queryset to its liking.",
            "        qs = self.get_base_queryset(request)",
            "        for filter_spec in self.filter_specs:",
            "            new_qs = filter_spec.queryset(request, qs)",
            "            if new_qs is not None:",
            "                qs = new_qs",
            "",
            "        try:",
            "            # Finally, we apply the remaining lookup parameters from the query",
            "            # string (i.e. those that haven't already been processed by the",
            "            # filters).",
            "            qs = qs.filter(**remaining_lookup_params)",
            "        except (SuspiciousOperation, ImproperlyConfigured):",
            "            # Allow certain types of errors to be re-raised as-is so that the",
            "            # caller can treat them in a special way.",
            "            raise",
            "        except Exception as e:",
            "            # Every other error is caught with a naked except, because we don't",
            "            # have any other way of validating lookup parameters. They might be",
            "            # invalid if the keyword arguments are incorrect, or if the values",
            "            # are not in the correct type, so we might get FieldError,",
            "            # ValueError, ValidationError, or ?.",
            "            raise IncorrectLookupParameters(e)",
            "",
            "        if not qs.query.select_related:",
            "            qs = self.apply_select_related(qs)",
            "",
            "        # Set ordering.",
            "        ordering = self.get_ordering(request, qs)",
            "        qs = qs.order_by(*ordering)",
            "",
            "        # Remove duplicates from results, if necessary",
            "        if filters_use_distinct:",
            "            qs = qs.distinct()",
            "",
            "        # Apply search results",
            "        return self.get_search_results(request, qs, self.query)",
            "",
            "    def apply_select_related(self, qs):",
            "        if self.select_related is True:",
            "            return qs.select_related()",
            "",
            "        if self.select_related is False:",
            "            if self.has_related_field_in_list_display():",
            "                return qs.select_related()",
            "",
            "        if self.select_related:",
            "            return qs.select_related(*self.select_related)",
            "        return qs",
            "",
            "    def has_related_field_in_list_display(self):",
            "        for field_name in self.list_display:",
            "            try:",
            "                field = self.opts.get_field(field_name)",
            "            except FieldDoesNotExist:",
            "                pass",
            "            else:",
            "                if isinstance(field, models.ManyToOneRel):",
            "                    return True",
            "        return False",
            "",
            "    def get_context_data(self, **kwargs):",
            "        user = self.request.user",
            "        all_count = self.get_base_queryset().count()",
            "        queryset = self.get_queryset()",
            "        result_count = queryset.count()",
            "        paginator = Paginator(queryset, self.items_per_page)",
            "",
            "        try:",
            "            page_obj = paginator.page(self.page_num + 1)",
            "        except InvalidPage:",
            "            page_obj = paginator.page(1)",
            "",
            "        context = {",
            "            \"view\": self,",
            "            \"all_count\": all_count,",
            "            \"result_count\": result_count,",
            "            \"paginator\": paginator,",
            "            \"page_obj\": page_obj,",
            "            \"object_list\": page_obj.object_list,",
            "            \"user_can_create\": self.permission_helper.user_can_create(user),",
            "            \"show_search\": self.search_handler.show_search_form,",
            "        }",
            "",
            "        if self.is_pagemodel:",
            "            models = self.model.allowed_parent_page_models()",
            "            allowed_parent_types = [m._meta.verbose_name for m in models]",
            "            valid_parents = self.permission_helper.get_valid_parent_pages(user)",
            "            valid_parent_count = valid_parents.count()",
            "            context.update(",
            "                {",
            "                    \"no_valid_parents\": not valid_parent_count,",
            "                    \"required_parent_types\": allowed_parent_types,",
            "                }",
            "            )",
            "",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_index_template()",
            "",
            "",
            "class CreateView(ModelFormView):",
            "    page_title = gettext_lazy(\"New\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_create(user)",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if self.is_pagemodel:",
            "            user = request.user",
            "            parents = self.permission_helper.get_valid_parent_pages(user)",
            "            parent_count = parents.count()",
            "",
            "            # There's only one available parent for this page type for this",
            "            # user, so we send them along with that as the chosen parent page",
            "            if parent_count == 1:",
            "                parent = parents.get()",
            "                parent_pk = quote(parent.pk)",
            "                return redirect(",
            "                    self.url_helper.get_action_url(",
            "                        \"add\", self.app_label, self.model_name, parent_pk",
            "                    )",
            "                )",
            "",
            "            # The page can be added in multiple places, so redirect to the",
            "            # choose_parent view so that the parent can be specified",
            "            return redirect(self.url_helper.get_action_url(\"choose_parent\"))",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model, TranslatableMixin",
            "        ):",
            "            selected_locale = self.request.GET.get(\"locale\")",
            "            if selected_locale:",
            "                locale = get_object_or_404(Locale, language_code=selected_locale)",
            "            else:",
            "                locale = Locale.get_default()",
            "",
            "            kwargs.update(",
            "                {",
            "                    \"locale\": locale,",
            "                    \"translations\": [",
            "                        {",
            "                            \"locale\": locale,",
            "                            \"url\": self.create_url + \"?locale=\" + locale.language_code,",
            "                        }",
            "                        for locale in Locale.objects.all().exclude(id=locale.id)",
            "                    ],",
            "                }",
            "            )",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def form_valid(self, form):",
            "        response = super().form_valid(form)",
            "        revision = None",
            "",
            "        # Save revision if the model inherits from RevisionMixin",
            "        if isinstance(self.instance, RevisionMixin):",
            "            revision = self.instance.save_revision(user=self.request.user)",
            "",
            "        log(",
            "            instance=self.instance,",
            "            action=\"wagtail.create\",",
            "            revision=revision,",
            "            content_changed=True,",
            "        )",
            "        return response",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Create new %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_page_subtitle(self):",
            "        return capfirst(self.verbose_name)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_create_template()",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model, TranslatableMixin",
            "        ):",
            "            selected_locale = self.request.GET.get(\"locale\")",
            "            if selected_locale:",
            "                kwargs[\"instance\"].locale = get_object_or_404(",
            "                    Locale, language_code=selected_locale",
            "                )",
            "",
            "        return kwargs",
            "",
            "",
            "class EditView(ModelFormView, InstanceSpecificView):",
            "    page_title = gettext_lazy(\"Editing\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_edit_obj(user, self.instance)",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if self.is_pagemodel:",
            "            return redirect(self.url_helper.get_action_url(\"edit\", self.pk_quoted))",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model, TranslatableMixin",
            "        ):",
            "            translations = []",
            "            for translation in self.instance.get_translations().select_related(",
            "                \"locale\"",
            "            ):",
            "                locale = translation.locale",
            "                url = (",
            "                    self.url_helper.get_action_url(\"edit\", translation.pk)",
            "                    + \"?locale=\"",
            "                    + locale.language_code",
            "                )",
            "                translations.append({\"locale\": locale, \"url\": url})",
            "",
            "            if translations:",
            "                kwargs.update(",
            "                    {",
            "                        \"locale\": self.locale,",
            "                        \"translations\": translations,",
            "                    }",
            "                )",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Editing %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_success_message(self, instance):",
            "        return _(\"%(model_name)s '%(object)s' updated.\") % {",
            "            \"model_name\": capfirst(self.verbose_name),",
            "            \"object\": instance,",
            "        }",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {",
            "            \"user_can_delete\": self.permission_helper.user_can_delete_obj(",
            "                self.request.user, self.instance",
            "            )",
            "        }",
            "        context.update(kwargs)",
            "        if self.model_admin.history_view_enabled:",
            "            context[\"latest_log_entry\"] = log_registry.get_logs_for_instance(",
            "                self.instance",
            "            ).first()",
            "            context[\"history_url\"] = self.url_helper.get_action_url(",
            "                \"history\", quote(self.instance.pk)",
            "            )",
            "        else:",
            "            context[\"latest_log_entry\"] = None",
            "            context[\"history_url\"] = None",
            "",
            "        return super().get_context_data(**context)",
            "",
            "    def get_error_message(self):",
            "        name = self.verbose_name",
            "        return _(\"The %(object)s could not be saved due to errors.\") % {\"object\": name}",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_edit_template()",
            "",
            "    def form_valid(self, form):",
            "        response = super().form_valid(form)",
            "        revision = None",
            "",
            "        self.has_content_changes = form.has_changed()",
            "",
            "        # Save revision if the model inherits from RevisionMixin",
            "        if isinstance(self.instance, RevisionMixin):",
            "            revision = self.instance.save_revision(",
            "                user=self.request.user,",
            "                changed=self.has_content_changes,",
            "            )",
            "",
            "        log(",
            "            instance=self.instance,",
            "            action=\"wagtail.edit\",",
            "            revision=revision,",
            "            content_changed=self.has_content_changes,",
            "        )",
            "        return response",
            "",
            "",
            "class ChooseParentView(WMABaseView):",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.permission_helper.user_can_create(request.user):",
            "            raise PermissionDenied",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_page_title(self):",
            "        return _(\"Add %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_form(self, request):",
            "        parents = self.permission_helper.get_valid_parent_pages(request.user)",
            "        return ParentChooserForm(parents, request.POST or None)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        form = self.get_form(request)",
            "        context = self.get_context_data(form=form)",
            "        return self.render_to_response(context)",
            "",
            "    def post(self, request, *args, **kargs):",
            "        form = self.get_form(request)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        return self.form_invalid(form)",
            "",
            "    def form_valid(self, form):",
            "        parent_pk = quote(form.cleaned_data[\"parent_page\"].pk)",
            "        return redirect(",
            "            self.url_helper.get_action_url(",
            "                \"add\", self.app_label, self.model_name, parent_pk",
            "            )",
            "        )",
            "",
            "    def form_invalid(self, form):",
            "        context = self.get_context_data(form=form)",
            "        return self.render_to_response(context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_choose_parent_template()",
            "",
            "",
            "class DeleteView(InstanceSpecificView):",
            "    page_title = gettext_lazy(\"Delete\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_delete_obj(user, self.instance)",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.check_action_permitted(request.user):",
            "            raise PermissionDenied",
            "        if self.is_pagemodel:",
            "            return redirect(self.url_helper.get_action_url(\"delete\", self.pk_quoted))",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Confirm deletion of %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def confirmation_message(self):",
            "        return _(",
            "            \"Are you sure you want to delete this %(object)s? If other things in your \"",
            "            \"site are related to it, they may also be affected.\"",
            "        ) % {\"object\": self.verbose_name}",
            "",
            "    def delete_instance(self):",
            "        self.instance.delete()",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        try:",
            "            msg = _(\"%(model_name)s '%(object)s' deleted.\") % {",
            "                \"model_name\": self.verbose_name,",
            "                \"object\": self.instance,",
            "            }",
            "            with transaction.atomic():",
            "                log(instance=self.instance, action=\"wagtail.delete\")",
            "                self.delete_instance()",
            "            messages.success(request, msg)",
            "            return redirect(self.index_url)",
            "        except models.ProtectedError:",
            "            linked_objects = []",
            "            fields = self.model._meta.fields_map.values()",
            "            fields = (",
            "                obj for obj in fields if not isinstance(obj.field, ManyToManyField)",
            "            )",
            "            for rel in fields:",
            "                if rel.on_delete == models.PROTECT:",
            "                    if isinstance(rel, OneToOneRel):",
            "                        try:",
            "                            obj = getattr(self.instance, rel.get_accessor_name())",
            "                        except ObjectDoesNotExist:",
            "                            pass",
            "                        else:",
            "                            linked_objects.append(obj)",
            "                    else:",
            "                        qs = getattr(self.instance, rel.get_accessor_name())",
            "                        for obj in qs.all():",
            "                            linked_objects.append(obj)",
            "            context = self.get_context_data(",
            "                protected_error=True, linked_objects=linked_objects",
            "            )",
            "            return self.render_to_response(context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_delete_template()",
            "",
            "",
            "class InspectView(InstanceSpecificView):",
            "",
            "    page_title = gettext_lazy(\"Inspecting\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_inspect_obj(user, self.instance)",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model_admin.model, TranslatableMixin",
            "        ):",
            "            translations = []",
            "            for translation in self.instance.get_translations().select_related(",
            "                \"locale\"",
            "            ):",
            "                locale = translation.locale",
            "                url = (",
            "                    self.url_helper.get_action_url(\"inspect\", translation.pk)",
            "                    + \"?locale=\"",
            "                    + locale.language_code",
            "                )",
            "                translations.append({\"locale\": locale, \"url\": url})",
            "",
            "            if translations:",
            "                kwargs.update(",
            "                    {",
            "                        \"locale\": self.locale,",
            "                        \"translations\": translations,",
            "                    }",
            "                )",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    @property",
            "    def media(self):",
            "        return forms.Media(",
            "            css={\"all\": self.model_admin.get_inspect_view_extra_css()},",
            "            js=self.model_admin.get_inspect_view_extra_js(),",
            "        )",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Inspecting %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_field_label(self, field_name, field=None):",
            "        \"\"\"Return a label to display for a field\"\"\"",
            "        return label_for_field(field_name, model=self.model)",
            "",
            "    def get_field_display_value(self, field_name, field=None):",
            "        \"\"\"Return a display value for a field/attribute\"\"\"",
            "",
            "        # First we check for a 'get_fieldname_display' property/method on",
            "        # the model, and return the value of that, if present.",
            "        val_funct = getattr(self.instance, \"get_%s_display\" % field_name, None)",
            "        if val_funct is not None:",
            "            if callable(val_funct):",
            "                return val_funct()",
            "            return val_funct",
            "",
            "        # Now let's get the attribute value from the instance itself and see if",
            "        # we can render something useful. raises AttributeError appropriately.",
            "        val = getattr(self.instance, field_name)",
            "",
            "        if isinstance(val, models.Manager):",
            "            val = val.all()",
            "",
            "        if isinstance(val, models.QuerySet):",
            "            if val.exists():",
            "                return \", \".join([\"%s\" % obj for obj in val])",
            "            return self.model_admin.get_empty_value_display(field_name)",
            "",
            "        # wagtail.images might not be installed",
            "        try:",
            "            from wagtail.images.models import AbstractImage",
            "",
            "            if isinstance(val, AbstractImage):",
            "                # Render a rendition of the image",
            "                return self.get_image_field_display(field_name, field)",
            "        except RuntimeError:",
            "            pass",
            "",
            "        # wagtail.wagtaildocuments might not be installed",
            "        try:",
            "            from wagtail.documents.models import AbstractDocument",
            "",
            "            if isinstance(val, AbstractDocument):",
            "                # Render a link to the document",
            "                return self.get_document_field_display(field_name, field)",
            "        except RuntimeError:",
            "            pass",
            "",
            "        # Resort to returning the real value or 'empty value'",
            "        if val or val is False:",
            "            return val",
            "        return self.model_admin.get_empty_value_display(field_name)",
            "",
            "    def get_image_field_display(self, field_name, field):",
            "        \"\"\"Render an image\"\"\"",
            "        from wagtail.images.shortcuts import get_rendition_or_not_found",
            "",
            "        image = getattr(self.instance, field_name)",
            "        if image:",
            "            return get_rendition_or_not_found(image, \"max-400x400\").img_tag",
            "        return self.model_admin.get_empty_value_display(field_name)",
            "",
            "    def get_document_field_display(self, field_name, field):",
            "        \"\"\"Render a link to a document\"\"\"",
            "        document = getattr(self.instance, field_name)",
            "        if document:",
            "            return mark_safe(",
            "                '<a href=\"%s\">%s <span class=\"meta\">(%s, %s)</span></a>'",
            "                % (",
            "                    document.url,",
            "                    document.title,",
            "                    document.file_extension.upper(),",
            "                    filesizeformat(document.file.size),",
            "                )",
            "            )",
            "        return self.model_admin.get_empty_value_display(field_name)",
            "",
            "    def get_dict_for_field(self, field_name):",
            "        \"\"\"",
            "        Return a dictionary containing `label` and `value` values to display",
            "        for a field.",
            "        \"\"\"",
            "        try:",
            "            field = self.model._meta.get_field(field_name)",
            "        except FieldDoesNotExist:",
            "            field = None",
            "        return {",
            "            \"label\": self.get_field_label(field_name, field),",
            "            \"value\": self.get_field_display_value(field_name, field),",
            "        }",
            "",
            "    def get_fields_dict(self):",
            "        \"\"\"",
            "        Return a list of `label`/`value` dictionaries to represent the",
            "        fields named by the model_admin class's `get_inspect_view_fields` method",
            "        \"\"\"",
            "        fields = []",
            "        for field_name in self.model_admin.get_inspect_view_fields():",
            "            fields.append(self.get_dict_for_field(field_name))",
            "        return fields",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {",
            "            \"fields\": self.get_fields_dict(),",
            "            \"buttons\": self.button_helper.get_buttons_for_obj(",
            "                self.instance, exclude=[\"inspect\"]",
            "            ),",
            "        }",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_inspect_template()",
            "",
            "",
            "class HistoryView(MultipleObjectMixin, WagtailAdminTemplateMixin, InstanceSpecificView):",
            "    page_title = gettext_lazy(\"History\")",
            "    paginate_by = 50",
            "    columns = [",
            "        Column(\"message\", label=gettext_lazy(\"Action\")),",
            "        UserColumn(\"user\", blank_display_name=\"system\"),",
            "        DateColumn(\"timestamp\", label=gettext_lazy(\"Date\")),",
            "    ]",
            "",
            "    def get_page_subtitle(self):",
            "        return str(self.instance)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_history_template()",
            "",
            "    def get_queryset(self):",
            "        return log_registry.get_logs_for_instance(self.instance).prefetch_related(",
            "            \"user__wagtail_userprofile\"",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        self.object_list = self.get_queryset()",
            "        context = super().get_context_data(**kwargs)",
            "        index_url = self.url_helper.get_action_url(\"history\", quote(self.instance.pk))",
            "        table = Table(",
            "            self.columns,",
            "            context[\"object_list\"],",
            "            base_url=index_url,",
            "            ordering=self.get_ordering(),",
            "        )",
            "",
            "        context[\"table\"] = table",
            "        context[\"media\"] = table.media",
            "        context[\"index_url\"] = index_url",
            "        context[\"is_paginated\"] = True",
            "        return context"
        ],
        "afterPatchFile": [
            "import warnings",
            "from collections import OrderedDict",
            "",
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.admin import FieldListFilter",
            "from django.contrib.admin.options import IncorrectLookupParameters",
            "from django.contrib.admin.utils import (",
            "    get_fields_from_path,",
            "    label_for_field,",
            "    lookup_field,",
            "    prepare_lookup_value,",
            "    quote,",
            "    unquote,",
            ")",
            "from django.contrib.auth.decorators import login_required",
            "from django.core.exceptions import (",
            "    FieldDoesNotExist,",
            "    ImproperlyConfigured,",
            "    ObjectDoesNotExist,",
            "    PermissionDenied,",
            "    SuspiciousOperation,",
            ")",
            "from django.core.paginator import InvalidPage, Paginator",
            "from django.db import models, transaction",
            "from django.db.models.fields.related import ManyToManyField, OneToOneRel",
            "from django.shortcuts import get_object_or_404, redirect",
            "from django.template.defaultfilters import filesizeformat",
            "from django.utils.decorators import method_decorator",
            "from django.utils.encoding import force_str",
            "from django.utils.functional import cached_property",
            "from django.utils.html import format_html",
            "from django.utils.http import urlencode",
            "from django.utils.text import capfirst",
            "from django.utils.translation import gettext as _",
            "from django.utils.translation import gettext_lazy",
            "from django.views.generic import TemplateView",
            "from django.views.generic.edit import FormView",
            "from django.views.generic.list import MultipleObjectMixin",
            "",
            "from wagtail.admin import messages",
            "from wagtail.admin.ui.tables import Column, DateColumn, Table, UserColumn",
            "from wagtail.admin.views.generic.base import WagtailAdminTemplateMixin",
            "from wagtail.admin.views.mixins import SpreadsheetExportMixin",
            "from wagtail.log_actions import log",
            "from wagtail.log_actions import registry as log_registry",
            "from wagtail.models import Locale, RevisionMixin, TranslatableMixin",
            "from wagtail.utils.deprecation import RemovedInWagtail50Warning",
            "",
            "from .forms import ParentChooserForm",
            "",
            "try:",
            "    from django.contrib.admin.utils import lookup_spawns_duplicates",
            "except ImportError:",
            "    # fallback for Django <4.0",
            "    from django.contrib.admin.utils import (",
            "        lookup_needs_distinct as lookup_spawns_duplicates,",
            "    )",
            "",
            "",
            "QUERY_TERMS = {",
            "    \"contains\",",
            "    \"day\",",
            "    \"endswith\",",
            "    \"exact\",",
            "    \"gt\",",
            "    \"gte\",",
            "    \"hour\",",
            "    \"icontains\",",
            "    \"iendswith\",",
            "    \"iexact\",",
            "    \"in\",",
            "    \"iregex\",",
            "    \"isnull\",",
            "    \"istartswith\",",
            "    \"lt\",",
            "    \"lte\",",
            "    \"minute\",",
            "    \"month\",",
            "    \"range\",",
            "    \"regex\",",
            "    \"search\",",
            "    \"second\",",
            "    \"startswith\",",
            "    \"week_day\",",
            "    \"year\",",
            "}",
            "",
            "",
            "class WMABaseView(TemplateView):",
            "    \"\"\"",
            "    Groups together common functionality for all app views.",
            "    \"\"\"",
            "",
            "    model_admin = None",
            "    meta_title = \"\"",
            "    page_title = \"\"",
            "    page_subtitle = \"\"",
            "",
            "    def __init__(self, model_admin):",
            "        self.model_admin = model_admin",
            "        self.model = model_admin.model",
            "        self.opts = self.model._meta",
            "        self.app_label = force_str(self.opts.app_label)",
            "        self.model_name = force_str(self.opts.model_name)",
            "        self.verbose_name = force_str(self.opts.verbose_name)",
            "        self.verbose_name_plural = force_str(self.opts.verbose_name_plural)",
            "        self.pk_attname = self.opts.pk.attname",
            "        self.is_pagemodel = model_admin.is_pagemodel",
            "        self.permission_helper = model_admin.permission_helper",
            "        self.url_helper = model_admin.url_helper",
            "",
            "    def check_action_permitted(self, user):",
            "        return True",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.check_action_permitted(request.user):",
            "            raise PermissionDenied",
            "        button_helper_class = self.model_admin.get_button_helper_class()",
            "        self.button_helper = button_helper_class(self, request)",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    @cached_property",
            "    def menu_icon(self):",
            "        return self.model_admin.get_menu_icon()",
            "",
            "    @cached_property",
            "    def header_icon(self):",
            "        return self.menu_icon",
            "",
            "    def get_page_title(self):",
            "        return self.page_title or capfirst(self.opts.verbose_name_plural)",
            "",
            "    def get_meta_title(self):",
            "        return self.meta_title or self.get_page_title()",
            "",
            "    @cached_property",
            "    def index_url(self):",
            "        return self.url_helper.index_url",
            "",
            "    @cached_property",
            "    def create_url(self):",
            "        return self.url_helper.create_url",
            "",
            "    def get_base_queryset(self, request=None):",
            "        return self.model_admin.get_queryset(request or self.request)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {",
            "            \"view\": self,",
            "            \"model_admin\": self.model_admin,",
            "        }",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "",
            "class ModelFormView(WMABaseView, FormView):",
            "    def setup(self, request, *args, **kwargs):",
            "        super().setup(request, *args, **kwargs)",
            "        self.edit_handler = self.get_edit_handler()",
            "",
            "    def get_form(self):",
            "        form = super().get_form()",
            "        return form",
            "",
            "    def get_edit_handler(self):",
            "        try:",
            "            edit_handler = self.model_admin.get_edit_handler()",
            "        except TypeError:",
            "            edit_handler = self.model_admin.get_edit_handler(",
            "                instance=None, request=None",
            "            )",
            "            warnings.warn(",
            "                \"%s.get_edit_handler should not accept instance or request arguments\"",
            "                % type(self.model_admin).__name__,",
            "                category=RemovedInWagtail50Warning,",
            "            )",
            "",
            "        return edit_handler.bind_to_model(self.model_admin.model)",
            "",
            "    def get_form_class(self):",
            "        return self.edit_handler.get_form_class()",
            "",
            "    def get_success_url(self):",
            "        return self.index_url",
            "",
            "    def get_instance(self):",
            "        return getattr(self, \"instance\", None) or self.model()",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "        kwargs.update({\"instance\": self.get_instance(), \"for_user\": self.request.user})",
            "        return kwargs",
            "",
            "    @property",
            "    def media(self):",
            "        return forms.Media(",
            "            css={\"all\": self.model_admin.get_form_view_extra_css()},",
            "            js=self.model_admin.get_form_view_extra_js(),",
            "        )",
            "",
            "    def get_context_data(self, form=None, **kwargs):",
            "        if form is None:",
            "            form = self.get_form()",
            "",
            "        bound_panel = self.edit_handler.get_bound_panel(",
            "            form=form, instance=form.instance, request=self.request",
            "        )",
            "",
            "        prepopulated_fields = self.get_prepopulated_fields(form)",
            "        context = {",
            "            \"is_multipart\": form.is_multipart(),",
            "            \"edit_handler\": bound_panel,",
            "            \"form\": form,",
            "            \"prepopulated_fields\": prepopulated_fields,",
            "            \"media\": self.media + bound_panel.media + form.media,",
            "        }",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "    def get_prepopulated_fields(self, form):",
            "        fields = []",
            "        for field_name, dependencies in self.model_admin.get_prepopulated_fields(",
            "            self.request",
            "        ).items():",
            "            missing_dependencies = [",
            "                f\"'{f}'\" for f in dependencies if f not in form.fields",
            "            ]",
            "            if len(missing_dependencies) != 0:",
            "                missing_deps_string = \", \".join(missing_dependencies)",
            "                dependency_string = (",
            "                    \"dependencies\" if len(missing_dependencies) > 1 else \"dependency\"",
            "                )",
            "                warnings.warn(",
            "                    f\"Missing {dependency_string} {missing_deps_string} for prepopulated_field '{field_name}''.\",",
            "                    category=RuntimeWarning,",
            "                )",
            "            elif field_name in form.fields:",
            "                fields.append(",
            "                    {",
            "                        \"field\": form[field_name],",
            "                        \"dependencies\": [form[f] for f in dependencies],",
            "                    }",
            "                )",
            "        return fields",
            "",
            "    def get_success_message(self, instance):",
            "        return _(\"%(model_name)s '%(object)s' created.\") % {",
            "            \"model_name\": capfirst(self.opts.verbose_name),",
            "            \"object\": instance,",
            "        }",
            "",
            "    def get_success_message_buttons(self, instance):",
            "        button_url = self.url_helper.get_action_url(\"edit\", quote(instance.pk))",
            "        return [messages.button(button_url, _(\"Edit\"))]",
            "",
            "    def get_error_message(self):",
            "        model_name = self.verbose_name",
            "        return _(\"The %(object)s could not be created due to errors.\") % {",
            "            \"object\": model_name",
            "        }",
            "",
            "    def form_valid(self, form):",
            "        self.instance = form.save()",
            "        messages.success(",
            "            self.request,",
            "            self.get_success_message(self.instance),",
            "            buttons=self.get_success_message_buttons(self.instance),",
            "        )",
            "        return redirect(self.get_success_url())",
            "",
            "    def form_invalid(self, form):",
            "        messages.validation_error(self.request, self.get_error_message(), form)",
            "        return self.render_to_response(self.get_context_data(form=form))",
            "",
            "",
            "class InstanceSpecificView(WMABaseView):",
            "",
            "    instance_pk = None",
            "    pk_quoted = None",
            "    instance = None",
            "    locale = None",
            "",
            "    def __init__(self, model_admin, instance_pk):",
            "        super().__init__(model_admin)",
            "        self.instance_pk = unquote(instance_pk)",
            "        self.pk_quoted = quote(self.instance_pk)",
            "        filter_kwargs = {}",
            "        filter_kwargs[self.pk_attname] = self.instance_pk",
            "        object_qs = model_admin.model._default_manager.get_queryset().filter(",
            "            **filter_kwargs",
            "        )",
            "        self.instance = get_object_or_404(object_qs)",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            model_admin.model, TranslatableMixin",
            "        ):",
            "            self.locale = self.instance.locale",
            "",
            "    def get_page_subtitle(self):",
            "        return self.instance",
            "",
            "    @cached_property",
            "    def edit_url(self):",
            "        return self.url_helper.get_action_url(\"edit\", self.pk_quoted)",
            "",
            "    @cached_property",
            "    def delete_url(self):",
            "        return self.url_helper.get_action_url(\"delete\", self.pk_quoted)",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {\"instance\": self.instance}",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "",
            "class IndexView(SpreadsheetExportMixin, WMABaseView):",
            "",
            "    ORDER_VAR = \"o\"",
            "    ORDER_TYPE_VAR = \"ot\"",
            "    PAGE_VAR = \"p\"",
            "    SEARCH_VAR = \"q\"",
            "    ERROR_FLAG = \"e\"",
            "    EXPORT_VAR = \"export\"",
            "    IGNORED_PARAMS = (ORDER_VAR, ORDER_TYPE_VAR, SEARCH_VAR, EXPORT_VAR)",
            "",
            "    # sortable_by is required by the django.contrib.admin.templatetags.admin_list.result_headers",
            "    # template tag - see https://docs.djangoproject.com/en/stable/ref/contrib/admin/#django.contrib.admin.ModelAdmin.sortable_by",
            "    sortable_by = None",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        # Only continue if logged in user has list permission",
            "        if not self.permission_helper.user_can_list(request.user):",
            "            raise PermissionDenied",
            "",
            "        self.list_export = self.model_admin.get_list_export(request)",
            "        self.list_display = self.model_admin.get_list_display(request)",
            "        self.list_filter = self.model_admin.get_list_filter(request)",
            "        self.search_fields = self.model_admin.get_search_fields(request)",
            "        self.items_per_page = self.model_admin.list_per_page",
            "        self.select_related = self.model_admin.list_select_related",
            "        self.search_handler = self.model_admin.get_search_handler(",
            "            request, self.search_fields",
            "        )",
            "        self.export = request.GET.get(self.EXPORT_VAR)",
            "",
            "        # Get search parameters from the query string.",
            "        try:",
            "            self.page_num = int(request.GET.get(self.PAGE_VAR, 0))",
            "        except ValueError:",
            "            self.page_num = 0",
            "",
            "        self.params = dict(request.GET.items())",
            "        if self.PAGE_VAR in self.params:",
            "            del self.params[self.PAGE_VAR]",
            "        if self.ERROR_FLAG in self.params:",
            "            del self.params[self.ERROR_FLAG]",
            "        if self.EXPORT_VAR in self.params:",
            "            del self.params[self.EXPORT_VAR]",
            "",
            "        self.query = request.GET.get(self.SEARCH_VAR, \"\")",
            "",
            "        self.queryset = self.get_queryset(request)",
            "",
            "        if self.export in self.FORMATS:",
            "            return self.as_spreadsheet(self.queryset, self.export)",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_filename(self):",
            "        \"\"\"Get filename for exported spreadsheet, without extension\"\"\"",
            "        return getattr(self.model_admin, \"export_filename\", super().get_filename())",
            "",
            "    def get_heading(self, queryset, field):",
            "        \"\"\"Get headings for exported spreadsheet column for the relevant field\"\"\"",
            "        heading_override = self.export_headings.get(field)",
            "        if heading_override:",
            "            return force_str(heading_override)",
            "        return force_str(",
            "            label_for_field(",
            "                field, model=self.model, model_admin=self.model_admin",
            "            ).title()",
            "        )",
            "",
            "    def to_row_dict(self, item):",
            "        \"\"\"Returns an OrderedDict (in the order given by list_export) of the exportable information for a model instance\"\"\"",
            "        row_dict = OrderedDict()",
            "        for field in self.list_export:",
            "            f, attr, value = lookup_field(field, item, self.model_admin)",
            "            if not value:",
            "                value = getattr(",
            "                    attr,",
            "                    \"empty_value_display\",",
            "                    self.model_admin.get_empty_value_display(field),",
            "                )",
            "            row_dict[field] = value",
            "",
            "        return row_dict",
            "",
            "    @property",
            "    def media(self):",
            "        return forms.Media(",
            "            css={\"all\": self.model_admin.get_index_view_extra_css()},",
            "            js=self.model_admin.get_index_view_extra_js(),",
            "        )",
            "",
            "    def get_buttons_for_obj(self, obj):",
            "        return self.button_helper.get_buttons_for_obj(",
            "            obj, classnames_add=[\"button-small\"]",
            "        )",
            "",
            "    def get_search_results(self, request, queryset, search_term):",
            "        kwargs = self.model_admin.get_extra_search_kwargs(request, search_term)",
            "        kwargs[\"preserve_order\"] = self.ORDER_VAR in request.GET",
            "        return self.search_handler.search_queryset(queryset, search_term, **kwargs)",
            "",
            "    def get_filters_params(self, params=None):",
            "        \"\"\"",
            "        Returns all params except IGNORED_PARAMS",
            "        \"\"\"",
            "        if not params:",
            "            params = self.params",
            "        lookup_params = params.copy()  # a dictionary of the query string",
            "        # Remove all the parameters that are globally and systematically",
            "        # ignored.",
            "        for ignored in self.IGNORED_PARAMS:",
            "            if ignored in lookup_params:",
            "                del lookup_params[ignored]",
            "        return lookup_params",
            "",
            "    def get_filters(self, request):",
            "        lookup_params = self.get_filters_params()",
            "        use_distinct = False",
            "",
            "        filter_specs = []",
            "        if self.list_filter:",
            "            for list_filter in self.list_filter:",
            "                if callable(list_filter):",
            "                    # This is simply a custom list filter class.",
            "                    spec = list_filter(",
            "                        request, lookup_params, self.model, self.model_admin",
            "                    )",
            "                else:",
            "                    field_path = None",
            "                    if isinstance(list_filter, (tuple, list)):",
            "                        # This is a custom FieldListFilter class for a given",
            "                        # field.",
            "                        field, field_list_filter_class = list_filter",
            "                    else:",
            "                        # This is simply a field name, so use the default",
            "                        # FieldListFilter class that has been registered for",
            "                        # the type of the given field.",
            "                        field = list_filter",
            "                        field_list_filter_class = FieldListFilter.create",
            "                    if not isinstance(field, models.Field):",
            "                        field_path = field",
            "                        field = get_fields_from_path(self.model, field_path)[-1]",
            "                    spec = field_list_filter_class(",
            "                        field,",
            "                        request,",
            "                        lookup_params,",
            "                        self.model,",
            "                        self.model_admin,",
            "                        field_path=field_path,",
            "                    )",
            "",
            "                    # Check if we need to use distinct()",
            "                    use_distinct = use_distinct or lookup_spawns_duplicates(",
            "                        self.opts, field_path",
            "                    )",
            "                if spec and spec.has_output():",
            "                    filter_specs.append(spec)",
            "",
            "        # At this point, all the parameters used by the various ListFilters",
            "        # have been removed from lookup_params, which now only contains other",
            "        # parameters passed via the query string. We now loop through the",
            "        # remaining parameters both to ensure that all the parameters are valid",
            "        # fields and to determine if at least one of them needs distinct(). If",
            "        # the lookup parameters aren't real fields, then bail out.",
            "        try:",
            "            for key, value in lookup_params.items():",
            "                lookup_params[key] = prepare_lookup_value(key, value)",
            "                use_distinct = use_distinct or lookup_spawns_duplicates(self.opts, key)",
            "            return (filter_specs, bool(filter_specs), lookup_params, use_distinct)",
            "        except FieldDoesNotExist as e:",
            "            raise IncorrectLookupParameters from e",
            "",
            "    def get_query_string(self, new_params=None, remove=None):",
            "        if new_params is None:",
            "            new_params = {}",
            "        if remove is None:",
            "            remove = []",
            "        p = self.params.copy()",
            "        for r in remove:",
            "            for k in list(p):",
            "                if k.startswith(r):",
            "                    del p[k]",
            "        for k, v in new_params.items():",
            "            if v is None:",
            "                if k in p:",
            "                    del p[k]",
            "            else:",
            "                p[k] = v",
            "        return \"?%s\" % urlencode(sorted(p.items()))",
            "",
            "    def _get_default_ordering(self):",
            "        ordering = []",
            "        if self.model_admin.ordering:",
            "            ordering = self.model_admin.ordering",
            "        elif self.opts.ordering:",
            "            ordering = self.opts.ordering",
            "        return ordering",
            "",
            "    def get_default_ordering(self, request):",
            "        if self.model_admin.get_ordering(request):",
            "            return self.model_admin.get_ordering(request)",
            "        if self.opts.ordering:",
            "            return self.opts.ordering",
            "        return ()",
            "",
            "    def get_ordering_field(self, field_name):",
            "        \"\"\"",
            "        Returns the proper model field name corresponding to the given",
            "        field_name to use for ordering. field_name may either be the name of a",
            "        proper model field or the name of a method (on the admin or model) or a",
            "        callable with the 'admin_order_field' attribute. Returns None if no",
            "        proper model field name can be matched.",
            "        \"\"\"",
            "        try:",
            "            field = self.opts.get_field(field_name)",
            "            return field.name",
            "        except FieldDoesNotExist:",
            "            # See whether field_name is a name of a non-field",
            "            # that allows sorting.",
            "            if callable(field_name):",
            "                attr = field_name",
            "            elif hasattr(self.model_admin, field_name):",
            "                attr = getattr(self.model_admin, field_name)",
            "            else:",
            "                attr = getattr(self.model, field_name)",
            "            return getattr(attr, \"admin_order_field\", None)",
            "",
            "    def get_ordering(self, request, queryset):",
            "        \"\"\"",
            "        Returns the list of ordering fields for the change list.",
            "        First we check the get_ordering() method in model admin, then we check",
            "        the object's default ordering. Then, any manually-specified ordering",
            "        from the query string overrides anything. Finally, a deterministic",
            "        order is guaranteed by ensuring the primary key is used as the last",
            "        ordering field.",
            "        \"\"\"",
            "        params = self.params",
            "        ordering = list(self.get_default_ordering(request))",
            "        if self.ORDER_VAR in params:",
            "            # Clear ordering and used params",
            "            ordering = []",
            "            order_params = params[self.ORDER_VAR].split(\".\")",
            "            for p in order_params:",
            "                try:",
            "                    none, pfx, idx = p.rpartition(\"-\")",
            "                    field_name = self.list_display[int(idx)]",
            "                    order_field = self.get_ordering_field(field_name)",
            "                    if not order_field:",
            "                        continue  # No 'admin_order_field', skip it",
            "                    # reverse order if order_field has already \"-\" as prefix",
            "                    if order_field.startswith(\"-\") and pfx == \"-\":",
            "                        ordering.append(order_field[1:])",
            "                    else:",
            "                        ordering.append(pfx + order_field)",
            "                except (IndexError, ValueError):",
            "                    continue  # Invalid ordering specified, skip it.",
            "",
            "        # Add the given query's ordering fields, if any.",
            "        ordering.extend(queryset.query.order_by)",
            "",
            "        # Ensure that the primary key is systematically present in the list of",
            "        # ordering fields so we can guarantee a deterministic order across all",
            "        # database backends.",
            "        pk_name = self.opts.pk.name",
            "",
            "        if not (set(ordering) & {\"pk\", \"-pk\", pk_name, \"-\" + pk_name}):",
            "            # ordering isn't already being applied to pk",
            "            ordering.append(\"-\" + pk_name)",
            "",
            "        return ordering",
            "",
            "    def get_ordering_field_columns(self):",
            "        \"\"\"",
            "        Returns an OrderedDict of ordering field column numbers and asc/desc",
            "        \"\"\"",
            "",
            "        # We must cope with more than one column having the same underlying",
            "        # sort field, so we base things on column numbers.",
            "        ordering = self._get_default_ordering()",
            "        ordering_fields = OrderedDict()",
            "        if self.ORDER_VAR not in self.params:",
            "            # for ordering specified on model_admin or model Meta, we don't",
            "            # know the right column numbers absolutely, because there might be",
            "            # morr than one column associated with that ordering, so we guess.",
            "            for field in ordering:",
            "                if field.startswith(\"-\"):",
            "                    field = field[1:]",
            "                    order_type = \"desc\"",
            "                else:",
            "                    order_type = \"asc\"",
            "                for index, attr in enumerate(self.list_display):",
            "                    if self.get_ordering_field(attr) == field:",
            "                        ordering_fields[index] = order_type",
            "                        break",
            "        else:",
            "            for p in self.params[self.ORDER_VAR].split(\".\"):",
            "                none, pfx, idx = p.rpartition(\"-\")",
            "                try:",
            "                    idx = int(idx)",
            "                except ValueError:",
            "                    continue  # skip it",
            "                ordering_fields[idx] = \"desc\" if pfx == \"-\" else \"asc\"",
            "        return ordering_fields",
            "",
            "    def get_queryset(self, request=None):",
            "        request = request or self.request",
            "",
            "        # First, we collect all the declared list filters.",
            "        (",
            "            self.filter_specs,",
            "            self.has_filters,",
            "            remaining_lookup_params,",
            "            filters_use_distinct,",
            "        ) = self.get_filters(request)",
            "",
            "        # Then, we let every list filter modify the queryset to its liking.",
            "        qs = self.get_base_queryset(request)",
            "        for filter_spec in self.filter_specs:",
            "            new_qs = filter_spec.queryset(request, qs)",
            "            if new_qs is not None:",
            "                qs = new_qs",
            "",
            "        try:",
            "            # Finally, we apply the remaining lookup parameters from the query",
            "            # string (i.e. those that haven't already been processed by the",
            "            # filters).",
            "            qs = qs.filter(**remaining_lookup_params)",
            "        except (SuspiciousOperation, ImproperlyConfigured):",
            "            # Allow certain types of errors to be re-raised as-is so that the",
            "            # caller can treat them in a special way.",
            "            raise",
            "        except Exception as e:",
            "            # Every other error is caught with a naked except, because we don't",
            "            # have any other way of validating lookup parameters. They might be",
            "            # invalid if the keyword arguments are incorrect, or if the values",
            "            # are not in the correct type, so we might get FieldError,",
            "            # ValueError, ValidationError, or ?.",
            "            raise IncorrectLookupParameters(e)",
            "",
            "        if not qs.query.select_related:",
            "            qs = self.apply_select_related(qs)",
            "",
            "        # Set ordering.",
            "        ordering = self.get_ordering(request, qs)",
            "        qs = qs.order_by(*ordering)",
            "",
            "        # Remove duplicates from results, if necessary",
            "        if filters_use_distinct:",
            "            qs = qs.distinct()",
            "",
            "        # Apply search results",
            "        return self.get_search_results(request, qs, self.query)",
            "",
            "    def apply_select_related(self, qs):",
            "        if self.select_related is True:",
            "            return qs.select_related()",
            "",
            "        if self.select_related is False:",
            "            if self.has_related_field_in_list_display():",
            "                return qs.select_related()",
            "",
            "        if self.select_related:",
            "            return qs.select_related(*self.select_related)",
            "        return qs",
            "",
            "    def has_related_field_in_list_display(self):",
            "        for field_name in self.list_display:",
            "            try:",
            "                field = self.opts.get_field(field_name)",
            "            except FieldDoesNotExist:",
            "                pass",
            "            else:",
            "                if isinstance(field, models.ManyToOneRel):",
            "                    return True",
            "        return False",
            "",
            "    def get_context_data(self, **kwargs):",
            "        user = self.request.user",
            "        all_count = self.get_base_queryset().count()",
            "        queryset = self.get_queryset()",
            "        result_count = queryset.count()",
            "        paginator = Paginator(queryset, self.items_per_page)",
            "",
            "        try:",
            "            page_obj = paginator.page(self.page_num + 1)",
            "        except InvalidPage:",
            "            page_obj = paginator.page(1)",
            "",
            "        context = {",
            "            \"view\": self,",
            "            \"all_count\": all_count,",
            "            \"result_count\": result_count,",
            "            \"paginator\": paginator,",
            "            \"page_obj\": page_obj,",
            "            \"object_list\": page_obj.object_list,",
            "            \"user_can_create\": self.permission_helper.user_can_create(user),",
            "            \"show_search\": self.search_handler.show_search_form,",
            "        }",
            "",
            "        if self.is_pagemodel:",
            "            models = self.model.allowed_parent_page_models()",
            "            allowed_parent_types = [m._meta.verbose_name for m in models]",
            "            valid_parents = self.permission_helper.get_valid_parent_pages(user)",
            "            valid_parent_count = valid_parents.count()",
            "            context.update(",
            "                {",
            "                    \"no_valid_parents\": not valid_parent_count,",
            "                    \"required_parent_types\": allowed_parent_types,",
            "                }",
            "            )",
            "",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_index_template()",
            "",
            "",
            "class CreateView(ModelFormView):",
            "    page_title = gettext_lazy(\"New\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_create(user)",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if self.is_pagemodel:",
            "            user = request.user",
            "            parents = self.permission_helper.get_valid_parent_pages(user)",
            "            parent_count = parents.count()",
            "",
            "            # There's only one available parent for this page type for this",
            "            # user, so we send them along with that as the chosen parent page",
            "            if parent_count == 1:",
            "                parent = parents.get()",
            "                parent_pk = quote(parent.pk)",
            "                return redirect(",
            "                    self.url_helper.get_action_url(",
            "                        \"add\", self.app_label, self.model_name, parent_pk",
            "                    )",
            "                )",
            "",
            "            # The page can be added in multiple places, so redirect to the",
            "            # choose_parent view so that the parent can be specified",
            "            return redirect(self.url_helper.get_action_url(\"choose_parent\"))",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model, TranslatableMixin",
            "        ):",
            "            selected_locale = self.request.GET.get(\"locale\")",
            "            if selected_locale:",
            "                locale = get_object_or_404(Locale, language_code=selected_locale)",
            "            else:",
            "                locale = Locale.get_default()",
            "",
            "            kwargs.update(",
            "                {",
            "                    \"locale\": locale,",
            "                    \"translations\": [",
            "                        {",
            "                            \"locale\": locale,",
            "                            \"url\": self.create_url + \"?locale=\" + locale.language_code,",
            "                        }",
            "                        for locale in Locale.objects.all().exclude(id=locale.id)",
            "                    ],",
            "                }",
            "            )",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def form_valid(self, form):",
            "        response = super().form_valid(form)",
            "        revision = None",
            "",
            "        # Save revision if the model inherits from RevisionMixin",
            "        if isinstance(self.instance, RevisionMixin):",
            "            revision = self.instance.save_revision(user=self.request.user)",
            "",
            "        log(",
            "            instance=self.instance,",
            "            action=\"wagtail.create\",",
            "            revision=revision,",
            "            content_changed=True,",
            "        )",
            "        return response",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Create new %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_page_subtitle(self):",
            "        return capfirst(self.verbose_name)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_create_template()",
            "",
            "    def get_form_kwargs(self):",
            "        kwargs = super().get_form_kwargs()",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model, TranslatableMixin",
            "        ):",
            "            selected_locale = self.request.GET.get(\"locale\")",
            "            if selected_locale:",
            "                kwargs[\"instance\"].locale = get_object_or_404(",
            "                    Locale, language_code=selected_locale",
            "                )",
            "",
            "        return kwargs",
            "",
            "",
            "class EditView(ModelFormView, InstanceSpecificView):",
            "    page_title = gettext_lazy(\"Editing\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_edit_obj(user, self.instance)",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if self.is_pagemodel:",
            "            return redirect(self.url_helper.get_action_url(\"edit\", self.pk_quoted))",
            "",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model, TranslatableMixin",
            "        ):",
            "            translations = []",
            "            for translation in self.instance.get_translations().select_related(",
            "                \"locale\"",
            "            ):",
            "                locale = translation.locale",
            "                url = (",
            "                    self.url_helper.get_action_url(\"edit\", translation.pk)",
            "                    + \"?locale=\"",
            "                    + locale.language_code",
            "                )",
            "                translations.append({\"locale\": locale, \"url\": url})",
            "",
            "            if translations:",
            "                kwargs.update(",
            "                    {",
            "                        \"locale\": self.locale,",
            "                        \"translations\": translations,",
            "                    }",
            "                )",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Editing %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_success_message(self, instance):",
            "        return _(\"%(model_name)s '%(object)s' updated.\") % {",
            "            \"model_name\": capfirst(self.verbose_name),",
            "            \"object\": instance,",
            "        }",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {",
            "            \"user_can_delete\": self.permission_helper.user_can_delete_obj(",
            "                self.request.user, self.instance",
            "            )",
            "        }",
            "        context.update(kwargs)",
            "        if self.model_admin.history_view_enabled:",
            "            context[\"latest_log_entry\"] = log_registry.get_logs_for_instance(",
            "                self.instance",
            "            ).first()",
            "            context[\"history_url\"] = self.url_helper.get_action_url(",
            "                \"history\", quote(self.instance.pk)",
            "            )",
            "        else:",
            "            context[\"latest_log_entry\"] = None",
            "            context[\"history_url\"] = None",
            "",
            "        return super().get_context_data(**context)",
            "",
            "    def get_error_message(self):",
            "        name = self.verbose_name",
            "        return _(\"The %(object)s could not be saved due to errors.\") % {\"object\": name}",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_edit_template()",
            "",
            "    def form_valid(self, form):",
            "        response = super().form_valid(form)",
            "        revision = None",
            "",
            "        self.has_content_changes = form.has_changed()",
            "",
            "        # Save revision if the model inherits from RevisionMixin",
            "        if isinstance(self.instance, RevisionMixin):",
            "            revision = self.instance.save_revision(",
            "                user=self.request.user,",
            "                changed=self.has_content_changes,",
            "            )",
            "",
            "        log(",
            "            instance=self.instance,",
            "            action=\"wagtail.edit\",",
            "            revision=revision,",
            "            content_changed=self.has_content_changes,",
            "        )",
            "        return response",
            "",
            "",
            "class ChooseParentView(WMABaseView):",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.permission_helper.user_can_create(request.user):",
            "            raise PermissionDenied",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_page_title(self):",
            "        return _(\"Add %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_form(self, request):",
            "        parents = self.permission_helper.get_valid_parent_pages(request.user)",
            "        return ParentChooserForm(parents, request.POST or None)",
            "",
            "    def get(self, request, *args, **kwargs):",
            "        form = self.get_form(request)",
            "        context = self.get_context_data(form=form)",
            "        return self.render_to_response(context)",
            "",
            "    def post(self, request, *args, **kargs):",
            "        form = self.get_form(request)",
            "        if form.is_valid():",
            "            return self.form_valid(form)",
            "        return self.form_invalid(form)",
            "",
            "    def form_valid(self, form):",
            "        parent_pk = quote(form.cleaned_data[\"parent_page\"].pk)",
            "        return redirect(",
            "            self.url_helper.get_action_url(",
            "                \"add\", self.app_label, self.model_name, parent_pk",
            "            )",
            "        )",
            "",
            "    def form_invalid(self, form):",
            "        context = self.get_context_data(form=form)",
            "        return self.render_to_response(context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_choose_parent_template()",
            "",
            "",
            "class DeleteView(InstanceSpecificView):",
            "    page_title = gettext_lazy(\"Delete\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_delete_obj(user, self.instance)",
            "",
            "    @method_decorator(login_required)",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if not self.check_action_permitted(request.user):",
            "            raise PermissionDenied",
            "        if self.is_pagemodel:",
            "            return redirect(self.url_helper.get_action_url(\"delete\", self.pk_quoted))",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Confirm deletion of %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def confirmation_message(self):",
            "        return _(",
            "            \"Are you sure you want to delete this %(object)s? If other things in your \"",
            "            \"site are related to it, they may also be affected.\"",
            "        ) % {\"object\": self.verbose_name}",
            "",
            "    def delete_instance(self):",
            "        self.instance.delete()",
            "",
            "    def post(self, request, *args, **kwargs):",
            "        try:",
            "            msg = _(\"%(model_name)s '%(object)s' deleted.\") % {",
            "                \"model_name\": self.verbose_name,",
            "                \"object\": self.instance,",
            "            }",
            "            with transaction.atomic():",
            "                log(instance=self.instance, action=\"wagtail.delete\")",
            "                self.delete_instance()",
            "            messages.success(request, msg)",
            "            return redirect(self.index_url)",
            "        except models.ProtectedError:",
            "            linked_objects = []",
            "            fields = self.model._meta.fields_map.values()",
            "            fields = (",
            "                obj for obj in fields if not isinstance(obj.field, ManyToManyField)",
            "            )",
            "            for rel in fields:",
            "                if rel.on_delete == models.PROTECT:",
            "                    if isinstance(rel, OneToOneRel):",
            "                        try:",
            "                            obj = getattr(self.instance, rel.get_accessor_name())",
            "                        except ObjectDoesNotExist:",
            "                            pass",
            "                        else:",
            "                            linked_objects.append(obj)",
            "                    else:",
            "                        qs = getattr(self.instance, rel.get_accessor_name())",
            "                        for obj in qs.all():",
            "                            linked_objects.append(obj)",
            "            context = self.get_context_data(",
            "                protected_error=True, linked_objects=linked_objects",
            "            )",
            "            return self.render_to_response(context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_delete_template()",
            "",
            "",
            "class InspectView(InstanceSpecificView):",
            "",
            "    page_title = gettext_lazy(\"Inspecting\")",
            "",
            "    def check_action_permitted(self, user):",
            "        return self.permission_helper.user_can_inspect_obj(user, self.instance)",
            "",
            "    def dispatch(self, request, *args, **kwargs):",
            "        if getattr(settings, \"WAGTAIL_I18N_ENABLED\", False) and issubclass(",
            "            self.model_admin.model, TranslatableMixin",
            "        ):",
            "            translations = []",
            "            for translation in self.instance.get_translations().select_related(",
            "                \"locale\"",
            "            ):",
            "                locale = translation.locale",
            "                url = (",
            "                    self.url_helper.get_action_url(\"inspect\", translation.pk)",
            "                    + \"?locale=\"",
            "                    + locale.language_code",
            "                )",
            "                translations.append({\"locale\": locale, \"url\": url})",
            "",
            "            if translations:",
            "                kwargs.update(",
            "                    {",
            "                        \"locale\": self.locale,",
            "                        \"translations\": translations,",
            "                    }",
            "                )",
            "",
            "        return super().dispatch(request, *args, **kwargs)",
            "",
            "    @property",
            "    def media(self):",
            "        return forms.Media(",
            "            css={\"all\": self.model_admin.get_inspect_view_extra_css()},",
            "            js=self.model_admin.get_inspect_view_extra_js(),",
            "        )",
            "",
            "    def get_meta_title(self):",
            "        return _(\"Inspecting %(object)s\") % {\"object\": self.verbose_name}",
            "",
            "    def get_field_label(self, field_name, field=None):",
            "        \"\"\"Return a label to display for a field\"\"\"",
            "        return label_for_field(field_name, model=self.model)",
            "",
            "    def get_field_display_value(self, field_name, field=None):",
            "        \"\"\"Return a display value for a field/attribute\"\"\"",
            "",
            "        # First we check for a 'get_fieldname_display' property/method on",
            "        # the model, and return the value of that, if present.",
            "        val_funct = getattr(self.instance, \"get_%s_display\" % field_name, None)",
            "        if val_funct is not None:",
            "            if callable(val_funct):",
            "                return val_funct()",
            "            return val_funct",
            "",
            "        # Now let's get the attribute value from the instance itself and see if",
            "        # we can render something useful. raises AttributeError appropriately.",
            "        val = getattr(self.instance, field_name)",
            "",
            "        if isinstance(val, models.Manager):",
            "            val = val.all()",
            "",
            "        if isinstance(val, models.QuerySet):",
            "            if val.exists():",
            "                return \", \".join([\"%s\" % obj for obj in val])",
            "            return self.model_admin.get_empty_value_display(field_name)",
            "",
            "        # wagtail.images might not be installed",
            "        try:",
            "            from wagtail.images.models import AbstractImage",
            "",
            "            if isinstance(val, AbstractImage):",
            "                # Render a rendition of the image",
            "                return self.get_image_field_display(field_name, field)",
            "        except RuntimeError:",
            "            pass",
            "",
            "        # wagtail.wagtaildocuments might not be installed",
            "        try:",
            "            from wagtail.documents.models import AbstractDocument",
            "",
            "            if isinstance(val, AbstractDocument):",
            "                # Render a link to the document",
            "                return self.get_document_field_display(field_name, field)",
            "        except RuntimeError:",
            "            pass",
            "",
            "        # Resort to returning the real value or 'empty value'",
            "        if val or val is False:",
            "            return val",
            "        return self.model_admin.get_empty_value_display(field_name)",
            "",
            "    def get_image_field_display(self, field_name, field):",
            "        \"\"\"Render an image\"\"\"",
            "        from wagtail.images.shortcuts import get_rendition_or_not_found",
            "",
            "        image = getattr(self.instance, field_name)",
            "        if image:",
            "            return get_rendition_or_not_found(image, \"max-400x400\").img_tag",
            "        return self.model_admin.get_empty_value_display(field_name)",
            "",
            "    def get_document_field_display(self, field_name, field):",
            "        \"\"\"Render a link to a document\"\"\"",
            "        document = getattr(self.instance, field_name)",
            "        if document:",
            "            return format_html(",
            "                '<a href=\"{}\">{} <span class=\"meta\">({}, {})</span></a>',",
            "                document.url,",
            "                document.title,",
            "                document.file_extension.upper(),",
            "                filesizeformat(document.file.size),",
            "            )",
            "        return self.model_admin.get_empty_value_display(field_name)",
            "",
            "    def get_dict_for_field(self, field_name):",
            "        \"\"\"",
            "        Return a dictionary containing `label` and `value` values to display",
            "        for a field.",
            "        \"\"\"",
            "        try:",
            "            field = self.model._meta.get_field(field_name)",
            "        except FieldDoesNotExist:",
            "            field = None",
            "        return {",
            "            \"label\": self.get_field_label(field_name, field),",
            "            \"value\": self.get_field_display_value(field_name, field),",
            "        }",
            "",
            "    def get_fields_dict(self):",
            "        \"\"\"",
            "        Return a list of `label`/`value` dictionaries to represent the",
            "        fields named by the model_admin class's `get_inspect_view_fields` method",
            "        \"\"\"",
            "        fields = []",
            "        for field_name in self.model_admin.get_inspect_view_fields():",
            "            fields.append(self.get_dict_for_field(field_name))",
            "        return fields",
            "",
            "    def get_context_data(self, **kwargs):",
            "        context = {",
            "            \"fields\": self.get_fields_dict(),",
            "            \"buttons\": self.button_helper.get_buttons_for_obj(",
            "                self.instance, exclude=[\"inspect\"]",
            "            ),",
            "        }",
            "        context.update(kwargs)",
            "        return super().get_context_data(**context)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_inspect_template()",
            "",
            "",
            "class HistoryView(MultipleObjectMixin, WagtailAdminTemplateMixin, InstanceSpecificView):",
            "    page_title = gettext_lazy(\"History\")",
            "    paginate_by = 50",
            "    columns = [",
            "        Column(\"message\", label=gettext_lazy(\"Action\")),",
            "        UserColumn(\"user\", blank_display_name=\"system\"),",
            "        DateColumn(\"timestamp\", label=gettext_lazy(\"Date\")),",
            "    ]",
            "",
            "    def get_page_subtitle(self):",
            "        return str(self.instance)",
            "",
            "    def get_template_names(self):",
            "        return self.model_admin.get_history_template()",
            "",
            "    def get_queryset(self):",
            "        return log_registry.get_logs_for_instance(self.instance).prefetch_related(",
            "            \"user__wagtail_userprofile\"",
            "        )",
            "",
            "    def get_context_data(self, **kwargs):",
            "        self.object_list = self.get_queryset()",
            "        context = super().get_context_data(**kwargs)",
            "        index_url = self.url_helper.get_action_url(\"history\", quote(self.instance.pk))",
            "        table = Table(",
            "            self.columns,",
            "            context[\"object_list\"],",
            "            base_url=index_url,",
            "            ordering=self.get_ordering(),",
            "        )",
            "",
            "        context[\"table\"] = table",
            "        context[\"media\"] = table.media",
            "        context[\"index_url\"] = index_url",
            "        context[\"is_paginated\"] = True",
            "        return context"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "33": [],
            "1134": [
                "InspectView",
                "get_document_field_display"
            ],
            "1135": [
                "InspectView",
                "get_document_field_display"
            ],
            "1136": [
                "InspectView",
                "get_document_field_display"
            ],
            "1137": [
                "InspectView",
                "get_document_field_display"
            ],
            "1138": [
                "InspectView",
                "get_document_field_display"
            ],
            "1139": [
                "InspectView",
                "get_document_field_display"
            ],
            "1140": [
                "InspectView",
                "get_document_field_display"
            ],
            "1141": [
                "InspectView",
                "get_document_field_display"
            ]
        },
        "addLocation": []
    }
}