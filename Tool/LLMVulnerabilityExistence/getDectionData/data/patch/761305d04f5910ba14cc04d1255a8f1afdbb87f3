{
    "tcms/kiwi_auth/forms.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     kiwitcms-tenants is installed."
            },
            "1": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    captcha = ("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        fields.CaptchaField("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        )"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        if settings.USE_CAPTCHA"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        else None"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+    )"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     def save(  # pylint: disable=too-many-arguments"
            },
            "12": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "         self,"
            },
            "13": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "         domain_override=None,"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from captcha import fields",
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.auth.forms import PasswordResetForm as DjangoPasswordResetForm",
            "from django.contrib.auth.forms import UserCreationForm",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import Site",
            "from django.urls import reverse",
            "from django.utils.translation import gettext_lazy as _",
            "from django.utils.translation import override",
            "",
            "from tcms.core.utils import request_host_link",
            "from tcms.core.utils.mailto import mailto",
            "from tcms.kiwi_auth.models import UserActivationKey",
            "from tcms.utils.permissions import initiate_user_with_default_setups",
            "",
            "User = get_user_model()  # pylint: disable=invalid-name",
            "",
            "",
            "class CustomCaptchaTextInput(fields.CaptchaTextInput):",
            "    template_name = \"captcha_field.html\"",
            "",
            "",
            "class RegistrationForm(UserCreationForm):",
            "    email = forms.EmailField()",
            "    captcha = (",
            "        fields.CaptchaField(",
            "            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})",
            "        )",
            "        if settings.USE_CAPTCHA",
            "        else None",
            "    )",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "",
            "    def clean_email(self):",
            "        email = self.cleaned_data[\"email\"]",
            "        try:",
            "            User.objects.get(email=email)",
            "        except User.DoesNotExist:",
            "            return email",
            "        raise forms.ValidationError(_(\"A user with that email already exists.\"))",
            "",
            "    def save(self, commit=True):",
            "        user = super().save(commit=False)",
            "        user.email = self.cleaned_data[\"email\"]",
            "        user.is_active = False",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "",
            "        if User.objects.filter(is_superuser=True).count() == 0:",
            "            user.is_superuser = True",
            "            user.is_active = True",
            "",
            "        if commit:",
            "            user.save()",
            "            initiate_user_with_default_setups(user)",
            "        return user",
            "",
            "    def set_activation_key(self):",
            "        return UserActivationKey.set_random_key_for_user(user=self.instance)",
            "",
            "    @override(settings.LANGUAGE_CODE)",
            "    def send_confirm_mail(self, request, activation_key):",
            "        current_site = Site.objects.get(pk=settings.SITE_ID)",
            "        confirm_url = request_host_link(request, current_site.domain) + reverse(",
            "            \"tcms-confirm\",",
            "            args=[",
            "                activation_key.activation_key,",
            "            ],",
            "        )",
            "",
            "        mailto(",
            "            template_name=\"email/confirm_registration.txt\",",
            "            recipients=self.cleaned_data[\"email\"],",
            "            subject=_(\"Your new %s account confirmation\") % current_site.domain,",
            "            context={",
            "                \"user\": self.instance,",
            "                \"site_domain\": current_site.domain,",
            "                \"confirm_url\": confirm_url,",
            "            },",
            "        )",
            "",
            "",
            "class PasswordResetForm(",
            "    DjangoPasswordResetForm",
            "):  # pylint: disable=must-inherit-from-model-form",
            "    \"\"\"",
            "    Overrides the default form b/c it uses Site.objects.get_current()",
            "    which uses an internal cache and produces wrong results when",
            "    kiwitcms-tenants is installed.",
            "    \"\"\"",
            "",
            "    def save(  # pylint: disable=too-many-arguments",
            "        self,",
            "        domain_override=None,",
            "        subject_template_name=\"registration/password_reset_subject.txt\",",
            "        email_template_name=\"registration/password_reset_email.html\",",
            "        use_https=False,",
            "        token_generator=default_token_generator,",
            "        from_email=None,",
            "        request=None,",
            "        html_email_template_name=None,",
            "        extra_email_context=None,",
            "    ):",
            "        current_site = Site.objects.get(pk=settings.SITE_ID)",
            "        # call the stock method and just overrides the domain",
            "        super().save(",
            "            current_site.domain,",
            "            subject_template_name,",
            "            email_template_name,",
            "            use_https,",
            "            token_generator,",
            "            from_email,",
            "            request,",
            "            html_email_template_name,",
            "            extra_email_context,",
            "        )"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "from captcha import fields",
            "from django import forms",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.auth.forms import PasswordResetForm as DjangoPasswordResetForm",
            "from django.contrib.auth.forms import UserCreationForm",
            "from django.contrib.auth.tokens import default_token_generator",
            "from django.contrib.sites.models import Site",
            "from django.urls import reverse",
            "from django.utils.translation import gettext_lazy as _",
            "from django.utils.translation import override",
            "",
            "from tcms.core.utils import request_host_link",
            "from tcms.core.utils.mailto import mailto",
            "from tcms.kiwi_auth.models import UserActivationKey",
            "from tcms.utils.permissions import initiate_user_with_default_setups",
            "",
            "User = get_user_model()  # pylint: disable=invalid-name",
            "",
            "",
            "class CustomCaptchaTextInput(fields.CaptchaTextInput):",
            "    template_name = \"captcha_field.html\"",
            "",
            "",
            "class RegistrationForm(UserCreationForm):",
            "    email = forms.EmailField()",
            "    captcha = (",
            "        fields.CaptchaField(",
            "            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})",
            "        )",
            "        if settings.USE_CAPTCHA",
            "        else None",
            "    )",
            "",
            "    class Meta:",
            "        model = User",
            "        fields = (\"username\",)",
            "",
            "    def clean_email(self):",
            "        email = self.cleaned_data[\"email\"]",
            "        try:",
            "            User.objects.get(email=email)",
            "        except User.DoesNotExist:",
            "            return email",
            "        raise forms.ValidationError(_(\"A user with that email already exists.\"))",
            "",
            "    def save(self, commit=True):",
            "        user = super().save(commit=False)",
            "        user.email = self.cleaned_data[\"email\"]",
            "        user.is_active = False",
            "        user.set_password(self.cleaned_data[\"password1\"])",
            "",
            "        if User.objects.filter(is_superuser=True).count() == 0:",
            "            user.is_superuser = True",
            "            user.is_active = True",
            "",
            "        if commit:",
            "            user.save()",
            "            initiate_user_with_default_setups(user)",
            "        return user",
            "",
            "    def set_activation_key(self):",
            "        return UserActivationKey.set_random_key_for_user(user=self.instance)",
            "",
            "    @override(settings.LANGUAGE_CODE)",
            "    def send_confirm_mail(self, request, activation_key):",
            "        current_site = Site.objects.get(pk=settings.SITE_ID)",
            "        confirm_url = request_host_link(request, current_site.domain) + reverse(",
            "            \"tcms-confirm\",",
            "            args=[",
            "                activation_key.activation_key,",
            "            ],",
            "        )",
            "",
            "        mailto(",
            "            template_name=\"email/confirm_registration.txt\",",
            "            recipients=self.cleaned_data[\"email\"],",
            "            subject=_(\"Your new %s account confirmation\") % current_site.domain,",
            "            context={",
            "                \"user\": self.instance,",
            "                \"site_domain\": current_site.domain,",
            "                \"confirm_url\": confirm_url,",
            "            },",
            "        )",
            "",
            "",
            "class PasswordResetForm(",
            "    DjangoPasswordResetForm",
            "):  # pylint: disable=must-inherit-from-model-form",
            "    \"\"\"",
            "    Overrides the default form b/c it uses Site.objects.get_current()",
            "    which uses an internal cache and produces wrong results when",
            "    kiwitcms-tenants is installed.",
            "    \"\"\"",
            "",
            "    captcha = (",
            "        fields.CaptchaField(",
            "            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})",
            "        )",
            "        if settings.USE_CAPTCHA",
            "        else None",
            "    )",
            "",
            "    def save(  # pylint: disable=too-many-arguments",
            "        self,",
            "        domain_override=None,",
            "        subject_template_name=\"registration/password_reset_subject.txt\",",
            "        email_template_name=\"registration/password_reset_email.html\",",
            "        use_https=False,",
            "        token_generator=default_token_generator,",
            "        from_email=None,",
            "        request=None,",
            "        html_email_template_name=None,",
            "        extra_email_context=None,",
            "    ):",
            "        current_site = Site.objects.get(pk=settings.SITE_ID)",
            "        # call the stock method and just overrides the domain",
            "        super().save(",
            "            current_site.domain,",
            "            subject_template_name,",
            "            email_template_name,",
            "            use_https,",
            "            token_generator,",
            "            from_email,",
            "            request,",
            "            html_email_template_name,",
            "            extra_email_context,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tcms.kiwi_auth.forms",
            "tcms.kiwi_auth.forms.PasswordResetForm",
            "tcms.kiwi_auth.forms.PasswordResetForm.self",
            "tcms.kiwi_auth.forms.DjangoPasswordResetForm"
        ]
    },
    "tcms/kiwi_auth/tests/test_views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "         user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")"
            },
            "1": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         user.is_active = True"
            },
            "2": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         user.save()"
            },
            "3": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        data = {\"email\": \"tester@example.com\"}"
            },
            "4": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        response = self.client.post(self.password_reset_url, data, follow=True)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 403,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 404,
                "PatchRowcode": "+        try:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 405,
                "PatchRowcode": "+            # https://github.com/mbi/django-simple-captcha/issues/84"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+            # pylint: disable=import-outside-toplevel"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 407,
                "PatchRowcode": "+            from captcha.conf import settings as captcha_settings"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 408,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 409,
                "PatchRowcode": "+            captcha_settings.CAPTCHA_TEST_MODE = True"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            response = self.client.post("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+                self.password_reset_url,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+                {"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+                    \"email\": \"tester@example.com\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+                    \"captcha_0\": \"PASSED\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+                    \"captcha_1\": \"PASSED\","
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+                },"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+                follow=True,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+            )"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+        finally:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+            captcha_settings.CAPTCHA_TEST_MODE = False"
            },
            "24": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 422,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "         self.assertContains(response, _(\"Password reset email was sent\"))"
            },
            "26": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 424,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# pylint: disable=invalid-name",
            "",
            "import datetime",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.sites.models import Site",
            "from django.test import TestCase, override_settings",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.translation import gettext_lazy as _",
            "from mock import patch",
            "",
            "from tcms import signals",
            "from tcms.kiwi_auth import forms",
            "from tcms.kiwi_auth.models import UserActivationKey",
            "from tcms.tests.factories import UserFactory",
            "",
            "from . import __FOR_TESTING__",
            "",
            "User = get_user_model()  # pylint: disable=invalid-name",
            "",
            "",
            "class TestSetRandomKey(TestCase):",
            "    \"\"\"Test case for UserActivationKey.set_random_key_for_user\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.new_user = UserFactory()",
            "",
            "    @patch(\"tcms.kiwi_auth.models.datetime\")",
            "    def test_set_random_key(self, mock_datetime):",
            "        now = timezone.now()",
            "        in_7_days = datetime.timedelta(7)",
            "",
            "        mock_datetime.datetime.today.return_value = now",
            "        mock_datetime.timedelta.return_value = in_7_days",
            "",
            "        activation_key = UserActivationKey.set_random_key_for_user(self.new_user)",
            "        self.assertEqual(self.new_user, activation_key.user)",
            "        self.assertNotEqual(\"\", activation_key.activation_key)",
            "        self.assertEqual(now + in_7_days, activation_key.key_expires)",
            "",
            "",
            "class TestForceToSetRandomKey(TestCase):",
            "    \"\"\"Test case for UserActivationKey.set_random_key_for_user forcely\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.new_user = UserFactory()",
            "        cls.origin_activation_key = UserActivationKey.set_random_key_for_user(",
            "            cls.new_user",
            "        )",
            "",
            "    def test_set_random_key_forcely(self):",
            "        new_activation_key = UserActivationKey.set_random_key_for_user(",
            "            self.new_user, force=True",
            "        )",
            "        self.assertEqual(self.origin_activation_key.user, new_activation_key.user)",
            "        self.assertNotEqual(",
            "            self.origin_activation_key.activation_key, new_activation_key.activation_key",
            "        )",
            "",
            "",
            "# ### Test cases for view methods ###",
            "",
            "",
            "class TestLogout(TestCase):",
            "    \"\"\"Test for logout view method\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super(TestLogout, cls).setUpTestData()",
            "",
            "        cls.tester = UserFactory()",
            "        cls.tester.set_password(\"password\")",
            "        cls.tester.save()",
            "        cls.logout_url = reverse(\"tcms-logout\")",
            "",
            "    def test_logout_redirects_to_login_page(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.tester.username, password=\"password\"",
            "        )",
            "        response = self.client.get(self.logout_url, follow=True)",
            "        self.assertRedirects(response, reverse(\"tcms-login\"))",
            "",
            "    def test_logout_then_goto_next(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.tester.username, password=\"password\"",
            "        )",
            "        next_url = reverse(\"tcms-login\") + \"?next=\" + reverse(\"plans-search\")",
            "        response = self.client.get(self.logout_url, {\"next\": next_url}, follow=True)",
            "        self.assertRedirects(response, next_url)",
            "",
            "",
            "class TestRegistration(TestCase):",
            "    def setUp(self):",
            "        self.register_url = reverse(\"tcms-register\")",
            "        self.fake_activate_key = \"secret-activate-key\"",
            "",
            "    def test_open_registration_page(self):",
            "        response = self.client.get(self.register_url)",
            "        _register = _(\"Register\")",
            "        self.assertContains(response, f\">{_register}</button>\")",
            "",
            "    def assert_user_registration(self, username, follow=False):",
            "        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:",
            "            _secrets.token_hex.return_value = self.fake_activate_key",
            "",
            "            try:",
            "                # https://github.com/mbi/django-simple-captcha/issues/84",
            "                # pylint: disable=import-outside-toplevel",
            "                from captcha.conf import settings as captcha_settings",
            "",
            "                captcha_settings.CAPTCHA_TEST_MODE = True",
            "",
            "                response = self.client.post(",
            "                    self.register_url,",
            "                    {",
            "                        \"username\": username,",
            "                        \"password1\": __FOR_TESTING__,",
            "                        \"password2\": __FOR_TESTING__,",
            "                        \"email\": \"new-tester@example.com\",",
            "                        \"captcha_0\": \"PASSED\",",
            "                        \"captcha_1\": \"PASSED\",",
            "                    },",
            "                    follow=follow,",
            "                )",
            "            finally:",
            "                captcha_settings.CAPTCHA_TEST_MODE = False",
            "",
            "        user = User.objects.get(username=username)",
            "        self.assertEqual(\"new-tester@example.com\", user.email)",
            "        if User.objects.filter(is_superuser=True).count() == 1 and user.is_superuser:",
            "            self.assertTrue(user.is_active)",
            "        else:",
            "            self.assertFalse(user.is_active)",
            "",
            "        key = UserActivationKey.objects.get(user=user)",
            "        self.assertEqual(self.fake_activate_key, key.activation_key)",
            "",
            "        return response, user",
            "",
            "    @patch(\"tcms.signals.USER_REGISTERED_SIGNAL.send\")",
            "    def test_register_user_sends_signal(self, signal_mock):",
            "        self.assert_user_registration(\"new-signal-tester\")",
            "        self.assertTrue(signal_mock.called)",
            "        self.assertEqual(1, signal_mock.call_count)",
            "",
            "    @override_settings(ADMINS=[(\"Test Admin\", \"admin@kiwitcms.org\")])",
            "    @patch(\"tcms.core.utils.mailto.send_mail\")",
            "    def test_signal_handler_notifies_admins(self, send_mail):",
            "        # connect the handler b/c it is not connected by default",
            "        signals.USER_REGISTERED_SIGNAL.connect(signals.notify_admins)",
            "",
            "        try:",
            "            response, user = self.assert_user_registration(\"signal-handler\")",
            "            self.assertRedirects(",
            "                response, reverse(\"core-views-index\"), target_status_code=302",
            "            )",
            "",
            "            # 1 - verification mail, 2 - email to admin",
            "            self.assertTrue(send_mail.called)",
            "            self.assertEqual(2, send_mail.call_count)",
            "",
            "            # verify we've actually sent the admin email",
            "            self.assertIn(",
            "                str(_(\"New user awaiting approval\")), send_mail.call_args_list[0][0][0]",
            "            )",
            "            values = {",
            "                \"username\": \"signal-handler\",",
            "                \"user_url\": f\"http://testserver/admin/auth/user/{user.pk}/change/\",",
            "            }",
            "            expected = (",
            "                _(",
            "                    \"\"\"Dear Administrator,",
            "somebody just registered an account with username %(username)s at your",
            "Kiwi TCMS instance and is awaiting your approval!",
            "",
            "Go to %(user_url)s to activate the account!\"\"\"",
            "                )",
            "                % values",
            "            )",
            "            self.assertEqual(",
            "                expected.strip(), send_mail.call_args_list[0][0][1].strip()",
            "            )",
            "            self.assertIn(\"admin@kiwitcms.org\", send_mail.call_args_list[0][0][-1])",
            "        finally:",
            "            signals.USER_REGISTERED_SIGNAL.disconnect(signals.notify_admins)",
            "",
            "    @patch(\"tcms.core.utils.mailto.send_mail\")",
            "    def test_register_user_by_email_confirmation(self, send_mail):",
            "        response, user = self.assert_user_registration(\"new-tester\", follow=True)",
            "        self.assertContains(",
            "            response,",
            "            _(",
            "                \"Your account has been created, please check your mailbox for confirmation\"",
            "            ),",
            "        )",
            "",
            "        site = Site.objects.get(pk=settings.SITE_ID)",
            "        _confirm_url = reverse(\"tcms-confirm\", args=[self.fake_activate_key])",
            "        confirm_url = f\"http://{site.domain}{_confirm_url}\"",
            "",
            "        # Verify notification mail",
            "        values = {",
            "            \"user\": user.username,",
            "            \"site_domain\": site.domain,",
            "            \"confirm_url\": confirm_url,",
            "        }",
            "        expected_subject = (",
            "            settings.EMAIL_SUBJECT_PREFIX",
            "            + _(\"Your new %s account confirmation\") % site.domain",
            "        )",
            "        expected_body = (",
            "            _(",
            "                \"\"\"Welcome %(user)s,",
            "thank you for signing up for an %(site_domain)s account!",
            "",
            "To activate your account, click this link:",
            "%(confirm_url)s\"\"\"",
            "            )",
            "            % values",
            "            + \"\\n\"",
            "        )",
            "        send_mail.assert_called_once_with(",
            "            expected_subject,",
            "            expected_body,",
            "            settings.DEFAULT_FROM_EMAIL,",
            "            [\"new-tester@example.com\"],",
            "            fail_silently=False,",
            "        )",
            "",
            "    @override_settings(",
            "        AUTO_APPROVE_NEW_USERS=False,",
            "        ADMINS=[(\"admin1\", \"admin1@example.com\"), (\"admin2\", \"admin2@example.com\")],",
            "    )",
            "    def test_register_user_and_activate_by_admin(self):",
            "        response, _user = self.assert_user_registration(\"plan-tester\", follow=True)",
            "",
            "        self.assertContains(",
            "            response,",
            "            _(",
            "                \"Your account has been created, but you need an administrator to activate it\"",
            "            ),",
            "        )",
            "",
            "        for name, email in settings.ADMINS:",
            "            self.assertContains(",
            "                response, f'<a href=\"mailto:{email}\">{name}</a>', html=True",
            "            )",
            "",
            "    def test_invalid_form(self):",
            "        response = self.client.post(",
            "            self.register_url,",
            "            {",
            "                \"username\": \"kiwi-tester\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": f\"000-{__FOR_TESTING__}\",",
            "                \"email\": \"new-tester@example.com\",",
            "            },",
            "            follow=False,",
            "        )",
            "",
            "        self.assertContains(response, _(\"The two password fields didn\u2019t match.\"))",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTemplateUsed(response, \"registration/registration_form.html\")",
            "",
            "    def test_register_user_already_registered(self):",
            "        User.objects.create_user(\"kiwi-tester\", \"new-tester@example.com\", \"password\")",
            "",
            "        response = self.client.post(",
            "            self.register_url,",
            "            {",
            "                \"username\": \"test_user\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "                \"email\": \"new-tester@example.com\",",
            "            },",
            "            follow=False,",
            "        )",
            "        self.assertContains(response, _(\"A user with that email already exists.\"))",
            "",
            "        user = User.objects.filter(username=\"test_user\")",
            "        self.assertEqual(user.count(), 0)",
            "",
            "    def test_first_user_is_superuser(self):",
            "        _response, user = self.assert_user_registration(\"tester_1\")",
            "",
            "        self.assertTrue(user.is_superuser)",
            "        self.assertTrue(user.is_active)",
            "",
            "    def test_only_one_superuser(self):",
            "        user1 = User.objects.create_user(",
            "            \"kiwi-tester\", \"tester@example.com\", \"password\"",
            "        )",
            "        user1.is_superuser = True",
            "        user1.save()",
            "",
            "        self.assertTrue(user1.is_superuser)",
            "",
            "        _response, user2 = self.assert_user_registration(\"plan-tester\")",
            "        self.assertFalse(user2.is_superuser)",
            "",
            "",
            "class TestConfirm(TestCase):",
            "    \"\"\"Test for activation key confirmation\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.new_user = UserFactory()",
            "",
            "    def setUp(self):",
            "        self.new_user.is_active = False",
            "        self.new_user.save()",
            "",
            "    def test_fail_if_activation_key_does_not_exist(self):",
            "        confirm_url = reverse(\"tcms-confirm\", args=[\"nonexisting-activation-key\"])",
            "        response = self.client.get(confirm_url, follow=True)",
            "",
            "        self.assertContains(",
            "            response, _(\"This activation key no longer exists in the database\")",
            "        )",
            "",
            "        # user account not activated",
            "        user = User.objects.get(username=self.new_user.username)",
            "        self.assertFalse(user.is_active)",
            "",
            "    def test_fail_if_activation_key_expired(self):",
            "        fake_activation_key = \"secret-activation-key\"",
            "",
            "        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:",
            "            _secrets.token_hex.return_value = fake_activation_key",
            "            key = UserActivationKey.set_random_key_for_user(self.new_user)",
            "            key.key_expires = timezone.now() - datetime.timedelta(days=10)",
            "            key.save()",
            "",
            "        confirm_url = reverse(\"tcms-confirm\", args=[fake_activation_key])",
            "        response = self.client.get(confirm_url, follow=True)",
            "",
            "        self.assertContains(response, _(\"This activation key has expired\"))",
            "",
            "        # user account not activated",
            "        user = User.objects.get(username=self.new_user.username)",
            "        self.assertFalse(user.is_active)",
            "",
            "    def test_confirm(self):",
            "        fake_activate_key = \"secret-activate-key\"",
            "",
            "        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:",
            "            _secrets.token_hex.return_value = fake_activate_key",
            "            UserActivationKey.set_random_key_for_user(self.new_user)",
            "",
            "        confirm_url = reverse(\"tcms-confirm\", args=[fake_activate_key])",
            "        response = self.client.get(confirm_url, follow=True)",
            "",
            "        self.assertContains(response, _(\"Your account has been activated successfully\"))",
            "",
            "        # user account activated",
            "        user = User.objects.get(username=self.new_user.username)",
            "        self.assertTrue(user.is_active)",
            "        activate_key_deleted = not UserActivationKey.objects.filter(user=user).exists()",
            "        self.assertTrue(activate_key_deleted)",
            "",
            "",
            "class TestLoginViewWithCustomTemplate(TestCase):",
            "    \"\"\"Test for login view with custom template\"\"\"",
            "",
            "    def test_get_template_names(self):",
            "        response = self.client.get(reverse(\"tcms-login\"))",
            "        self.assertIsNotNone(response.template_name)",
            "        self.assertEqual(",
            "            response.template_name,",
            "            [\"registration/custom_login.html\", \"registration/login.html\"],",
            "        )",
            "",
            "",
            "class TestPasswordResetView(TestCase):",
            "    \"\"\"Test for password reset view\"\"\"",
            "",
            "    def setUp(self):",
            "        self.password_reset_url = reverse(\"tcms-password_reset\")",
            "",
            "    def test_form_class(self):",
            "        response = self.client.get(self.password_reset_url)",
            "        self.assertEqual(",
            "            str(type(response.context[\"form\"])),",
            "            str(forms.PasswordResetForm),",
            "        )",
            "",
            "    def test_open_password_reset_page(self):",
            "        response = self.client.get(self.password_reset_url)",
            "",
            "        _password_reset = _(\"Password reset\")",
            "        self.assertContains(response, f\">{_password_reset}</button>\")",
            "",
            "    @patch(\"tcms.kiwi_auth.forms.DjangoPasswordResetForm.send_mail\")",
            "    def test_send_mail_for_password_reset(self, mail_sent):",
            "        user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")",
            "        user.is_active = True",
            "        user.save()",
            "        data = {\"email\": \"tester@example.com\"}",
            "        response = self.client.post(self.password_reset_url, data, follow=True)",
            "",
            "        self.assertContains(response, _(\"Password reset email was sent\"))",
            "",
            "        # Verify mail is sent",
            "        mail_sent.assert_called_once()"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# pylint: disable=invalid-name",
            "",
            "import datetime",
            "",
            "from django.conf import settings",
            "from django.contrib.auth import get_user_model",
            "from django.contrib.sites.models import Site",
            "from django.test import TestCase, override_settings",
            "from django.urls import reverse",
            "from django.utils import timezone",
            "from django.utils.translation import gettext_lazy as _",
            "from mock import patch",
            "",
            "from tcms import signals",
            "from tcms.kiwi_auth import forms",
            "from tcms.kiwi_auth.models import UserActivationKey",
            "from tcms.tests.factories import UserFactory",
            "",
            "from . import __FOR_TESTING__",
            "",
            "User = get_user_model()  # pylint: disable=invalid-name",
            "",
            "",
            "class TestSetRandomKey(TestCase):",
            "    \"\"\"Test case for UserActivationKey.set_random_key_for_user\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.new_user = UserFactory()",
            "",
            "    @patch(\"tcms.kiwi_auth.models.datetime\")",
            "    def test_set_random_key(self, mock_datetime):",
            "        now = timezone.now()",
            "        in_7_days = datetime.timedelta(7)",
            "",
            "        mock_datetime.datetime.today.return_value = now",
            "        mock_datetime.timedelta.return_value = in_7_days",
            "",
            "        activation_key = UserActivationKey.set_random_key_for_user(self.new_user)",
            "        self.assertEqual(self.new_user, activation_key.user)",
            "        self.assertNotEqual(\"\", activation_key.activation_key)",
            "        self.assertEqual(now + in_7_days, activation_key.key_expires)",
            "",
            "",
            "class TestForceToSetRandomKey(TestCase):",
            "    \"\"\"Test case for UserActivationKey.set_random_key_for_user forcely\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.new_user = UserFactory()",
            "        cls.origin_activation_key = UserActivationKey.set_random_key_for_user(",
            "            cls.new_user",
            "        )",
            "",
            "    def test_set_random_key_forcely(self):",
            "        new_activation_key = UserActivationKey.set_random_key_for_user(",
            "            self.new_user, force=True",
            "        )",
            "        self.assertEqual(self.origin_activation_key.user, new_activation_key.user)",
            "        self.assertNotEqual(",
            "            self.origin_activation_key.activation_key, new_activation_key.activation_key",
            "        )",
            "",
            "",
            "# ### Test cases for view methods ###",
            "",
            "",
            "class TestLogout(TestCase):",
            "    \"\"\"Test for logout view method\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        super(TestLogout, cls).setUpTestData()",
            "",
            "        cls.tester = UserFactory()",
            "        cls.tester.set_password(\"password\")",
            "        cls.tester.save()",
            "        cls.logout_url = reverse(\"tcms-logout\")",
            "",
            "    def test_logout_redirects_to_login_page(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.tester.username, password=\"password\"",
            "        )",
            "        response = self.client.get(self.logout_url, follow=True)",
            "        self.assertRedirects(response, reverse(\"tcms-login\"))",
            "",
            "    def test_logout_then_goto_next(self):",
            "        self.client.login(  # nosec:B106:hardcoded_password_funcarg",
            "            username=self.tester.username, password=\"password\"",
            "        )",
            "        next_url = reverse(\"tcms-login\") + \"?next=\" + reverse(\"plans-search\")",
            "        response = self.client.get(self.logout_url, {\"next\": next_url}, follow=True)",
            "        self.assertRedirects(response, next_url)",
            "",
            "",
            "class TestRegistration(TestCase):",
            "    def setUp(self):",
            "        self.register_url = reverse(\"tcms-register\")",
            "        self.fake_activate_key = \"secret-activate-key\"",
            "",
            "    def test_open_registration_page(self):",
            "        response = self.client.get(self.register_url)",
            "        _register = _(\"Register\")",
            "        self.assertContains(response, f\">{_register}</button>\")",
            "",
            "    def assert_user_registration(self, username, follow=False):",
            "        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:",
            "            _secrets.token_hex.return_value = self.fake_activate_key",
            "",
            "            try:",
            "                # https://github.com/mbi/django-simple-captcha/issues/84",
            "                # pylint: disable=import-outside-toplevel",
            "                from captcha.conf import settings as captcha_settings",
            "",
            "                captcha_settings.CAPTCHA_TEST_MODE = True",
            "",
            "                response = self.client.post(",
            "                    self.register_url,",
            "                    {",
            "                        \"username\": username,",
            "                        \"password1\": __FOR_TESTING__,",
            "                        \"password2\": __FOR_TESTING__,",
            "                        \"email\": \"new-tester@example.com\",",
            "                        \"captcha_0\": \"PASSED\",",
            "                        \"captcha_1\": \"PASSED\",",
            "                    },",
            "                    follow=follow,",
            "                )",
            "            finally:",
            "                captcha_settings.CAPTCHA_TEST_MODE = False",
            "",
            "        user = User.objects.get(username=username)",
            "        self.assertEqual(\"new-tester@example.com\", user.email)",
            "        if User.objects.filter(is_superuser=True).count() == 1 and user.is_superuser:",
            "            self.assertTrue(user.is_active)",
            "        else:",
            "            self.assertFalse(user.is_active)",
            "",
            "        key = UserActivationKey.objects.get(user=user)",
            "        self.assertEqual(self.fake_activate_key, key.activation_key)",
            "",
            "        return response, user",
            "",
            "    @patch(\"tcms.signals.USER_REGISTERED_SIGNAL.send\")",
            "    def test_register_user_sends_signal(self, signal_mock):",
            "        self.assert_user_registration(\"new-signal-tester\")",
            "        self.assertTrue(signal_mock.called)",
            "        self.assertEqual(1, signal_mock.call_count)",
            "",
            "    @override_settings(ADMINS=[(\"Test Admin\", \"admin@kiwitcms.org\")])",
            "    @patch(\"tcms.core.utils.mailto.send_mail\")",
            "    def test_signal_handler_notifies_admins(self, send_mail):",
            "        # connect the handler b/c it is not connected by default",
            "        signals.USER_REGISTERED_SIGNAL.connect(signals.notify_admins)",
            "",
            "        try:",
            "            response, user = self.assert_user_registration(\"signal-handler\")",
            "            self.assertRedirects(",
            "                response, reverse(\"core-views-index\"), target_status_code=302",
            "            )",
            "",
            "            # 1 - verification mail, 2 - email to admin",
            "            self.assertTrue(send_mail.called)",
            "            self.assertEqual(2, send_mail.call_count)",
            "",
            "            # verify we've actually sent the admin email",
            "            self.assertIn(",
            "                str(_(\"New user awaiting approval\")), send_mail.call_args_list[0][0][0]",
            "            )",
            "            values = {",
            "                \"username\": \"signal-handler\",",
            "                \"user_url\": f\"http://testserver/admin/auth/user/{user.pk}/change/\",",
            "            }",
            "            expected = (",
            "                _(",
            "                    \"\"\"Dear Administrator,",
            "somebody just registered an account with username %(username)s at your",
            "Kiwi TCMS instance and is awaiting your approval!",
            "",
            "Go to %(user_url)s to activate the account!\"\"\"",
            "                )",
            "                % values",
            "            )",
            "            self.assertEqual(",
            "                expected.strip(), send_mail.call_args_list[0][0][1].strip()",
            "            )",
            "            self.assertIn(\"admin@kiwitcms.org\", send_mail.call_args_list[0][0][-1])",
            "        finally:",
            "            signals.USER_REGISTERED_SIGNAL.disconnect(signals.notify_admins)",
            "",
            "    @patch(\"tcms.core.utils.mailto.send_mail\")",
            "    def test_register_user_by_email_confirmation(self, send_mail):",
            "        response, user = self.assert_user_registration(\"new-tester\", follow=True)",
            "        self.assertContains(",
            "            response,",
            "            _(",
            "                \"Your account has been created, please check your mailbox for confirmation\"",
            "            ),",
            "        )",
            "",
            "        site = Site.objects.get(pk=settings.SITE_ID)",
            "        _confirm_url = reverse(\"tcms-confirm\", args=[self.fake_activate_key])",
            "        confirm_url = f\"http://{site.domain}{_confirm_url}\"",
            "",
            "        # Verify notification mail",
            "        values = {",
            "            \"user\": user.username,",
            "            \"site_domain\": site.domain,",
            "            \"confirm_url\": confirm_url,",
            "        }",
            "        expected_subject = (",
            "            settings.EMAIL_SUBJECT_PREFIX",
            "            + _(\"Your new %s account confirmation\") % site.domain",
            "        )",
            "        expected_body = (",
            "            _(",
            "                \"\"\"Welcome %(user)s,",
            "thank you for signing up for an %(site_domain)s account!",
            "",
            "To activate your account, click this link:",
            "%(confirm_url)s\"\"\"",
            "            )",
            "            % values",
            "            + \"\\n\"",
            "        )",
            "        send_mail.assert_called_once_with(",
            "            expected_subject,",
            "            expected_body,",
            "            settings.DEFAULT_FROM_EMAIL,",
            "            [\"new-tester@example.com\"],",
            "            fail_silently=False,",
            "        )",
            "",
            "    @override_settings(",
            "        AUTO_APPROVE_NEW_USERS=False,",
            "        ADMINS=[(\"admin1\", \"admin1@example.com\"), (\"admin2\", \"admin2@example.com\")],",
            "    )",
            "    def test_register_user_and_activate_by_admin(self):",
            "        response, _user = self.assert_user_registration(\"plan-tester\", follow=True)",
            "",
            "        self.assertContains(",
            "            response,",
            "            _(",
            "                \"Your account has been created, but you need an administrator to activate it\"",
            "            ),",
            "        )",
            "",
            "        for name, email in settings.ADMINS:",
            "            self.assertContains(",
            "                response, f'<a href=\"mailto:{email}\">{name}</a>', html=True",
            "            )",
            "",
            "    def test_invalid_form(self):",
            "        response = self.client.post(",
            "            self.register_url,",
            "            {",
            "                \"username\": \"kiwi-tester\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": f\"000-{__FOR_TESTING__}\",",
            "                \"email\": \"new-tester@example.com\",",
            "            },",
            "            follow=False,",
            "        )",
            "",
            "        self.assertContains(response, _(\"The two password fields didn\u2019t match.\"))",
            "        self.assertEqual(response.status_code, 200)",
            "        self.assertTemplateUsed(response, \"registration/registration_form.html\")",
            "",
            "    def test_register_user_already_registered(self):",
            "        User.objects.create_user(\"kiwi-tester\", \"new-tester@example.com\", \"password\")",
            "",
            "        response = self.client.post(",
            "            self.register_url,",
            "            {",
            "                \"username\": \"test_user\",",
            "                \"password1\": __FOR_TESTING__,",
            "                \"password2\": __FOR_TESTING__,",
            "                \"email\": \"new-tester@example.com\",",
            "            },",
            "            follow=False,",
            "        )",
            "        self.assertContains(response, _(\"A user with that email already exists.\"))",
            "",
            "        user = User.objects.filter(username=\"test_user\")",
            "        self.assertEqual(user.count(), 0)",
            "",
            "    def test_first_user_is_superuser(self):",
            "        _response, user = self.assert_user_registration(\"tester_1\")",
            "",
            "        self.assertTrue(user.is_superuser)",
            "        self.assertTrue(user.is_active)",
            "",
            "    def test_only_one_superuser(self):",
            "        user1 = User.objects.create_user(",
            "            \"kiwi-tester\", \"tester@example.com\", \"password\"",
            "        )",
            "        user1.is_superuser = True",
            "        user1.save()",
            "",
            "        self.assertTrue(user1.is_superuser)",
            "",
            "        _response, user2 = self.assert_user_registration(\"plan-tester\")",
            "        self.assertFalse(user2.is_superuser)",
            "",
            "",
            "class TestConfirm(TestCase):",
            "    \"\"\"Test for activation key confirmation\"\"\"",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        cls.new_user = UserFactory()",
            "",
            "    def setUp(self):",
            "        self.new_user.is_active = False",
            "        self.new_user.save()",
            "",
            "    def test_fail_if_activation_key_does_not_exist(self):",
            "        confirm_url = reverse(\"tcms-confirm\", args=[\"nonexisting-activation-key\"])",
            "        response = self.client.get(confirm_url, follow=True)",
            "",
            "        self.assertContains(",
            "            response, _(\"This activation key no longer exists in the database\")",
            "        )",
            "",
            "        # user account not activated",
            "        user = User.objects.get(username=self.new_user.username)",
            "        self.assertFalse(user.is_active)",
            "",
            "    def test_fail_if_activation_key_expired(self):",
            "        fake_activation_key = \"secret-activation-key\"",
            "",
            "        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:",
            "            _secrets.token_hex.return_value = fake_activation_key",
            "            key = UserActivationKey.set_random_key_for_user(self.new_user)",
            "            key.key_expires = timezone.now() - datetime.timedelta(days=10)",
            "            key.save()",
            "",
            "        confirm_url = reverse(\"tcms-confirm\", args=[fake_activation_key])",
            "        response = self.client.get(confirm_url, follow=True)",
            "",
            "        self.assertContains(response, _(\"This activation key has expired\"))",
            "",
            "        # user account not activated",
            "        user = User.objects.get(username=self.new_user.username)",
            "        self.assertFalse(user.is_active)",
            "",
            "    def test_confirm(self):",
            "        fake_activate_key = \"secret-activate-key\"",
            "",
            "        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:",
            "            _secrets.token_hex.return_value = fake_activate_key",
            "            UserActivationKey.set_random_key_for_user(self.new_user)",
            "",
            "        confirm_url = reverse(\"tcms-confirm\", args=[fake_activate_key])",
            "        response = self.client.get(confirm_url, follow=True)",
            "",
            "        self.assertContains(response, _(\"Your account has been activated successfully\"))",
            "",
            "        # user account activated",
            "        user = User.objects.get(username=self.new_user.username)",
            "        self.assertTrue(user.is_active)",
            "        activate_key_deleted = not UserActivationKey.objects.filter(user=user).exists()",
            "        self.assertTrue(activate_key_deleted)",
            "",
            "",
            "class TestLoginViewWithCustomTemplate(TestCase):",
            "    \"\"\"Test for login view with custom template\"\"\"",
            "",
            "    def test_get_template_names(self):",
            "        response = self.client.get(reverse(\"tcms-login\"))",
            "        self.assertIsNotNone(response.template_name)",
            "        self.assertEqual(",
            "            response.template_name,",
            "            [\"registration/custom_login.html\", \"registration/login.html\"],",
            "        )",
            "",
            "",
            "class TestPasswordResetView(TestCase):",
            "    \"\"\"Test for password reset view\"\"\"",
            "",
            "    def setUp(self):",
            "        self.password_reset_url = reverse(\"tcms-password_reset\")",
            "",
            "    def test_form_class(self):",
            "        response = self.client.get(self.password_reset_url)",
            "        self.assertEqual(",
            "            str(type(response.context[\"form\"])),",
            "            str(forms.PasswordResetForm),",
            "        )",
            "",
            "    def test_open_password_reset_page(self):",
            "        response = self.client.get(self.password_reset_url)",
            "",
            "        _password_reset = _(\"Password reset\")",
            "        self.assertContains(response, f\">{_password_reset}</button>\")",
            "",
            "    @patch(\"tcms.kiwi_auth.forms.DjangoPasswordResetForm.send_mail\")",
            "    def test_send_mail_for_password_reset(self, mail_sent):",
            "        user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")",
            "        user.is_active = True",
            "        user.save()",
            "",
            "        try:",
            "            # https://github.com/mbi/django-simple-captcha/issues/84",
            "            # pylint: disable=import-outside-toplevel",
            "            from captcha.conf import settings as captcha_settings",
            "",
            "            captcha_settings.CAPTCHA_TEST_MODE = True",
            "",
            "            response = self.client.post(",
            "                self.password_reset_url,",
            "                {",
            "                    \"email\": \"tester@example.com\",",
            "                    \"captcha_0\": \"PASSED\",",
            "                    \"captcha_1\": \"PASSED\",",
            "                },",
            "                follow=True,",
            "            )",
            "        finally:",
            "            captcha_settings.CAPTCHA_TEST_MODE = False",
            "",
            "        self.assertContains(response, _(\"Password reset email was sent\"))",
            "",
            "        # Verify mail is sent",
            "        mail_sent.assert_called_once()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "403": [
                "TestPasswordResetView",
                "test_send_mail_for_password_reset"
            ],
            "404": [
                "TestPasswordResetView",
                "test_send_mail_for_password_reset"
            ]
        },
        "addLocation": []
    }
}