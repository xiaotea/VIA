{
    "lib/ansible/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " LOCALHOST = ('127.0.0.1', 'localhost', '::1')"
            },
            "1": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " MODULE_REQUIRE_ARGS = ('command', 'win_command', 'shell', 'win_shell', 'raw', 'script')"
            },
            "2": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " MODULE_NO_JSON = ('command', 'win_command', 'shell', 'win_shell', 'raw')"
            },
            "3": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-RESTRICTED_RESULT_KEYS = ('ansible_rsync_path', 'ansible_playbook_python')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+RESTRICTED_RESULT_KEYS = ('ansible_rsync_path', 'ansible_playbook_python', 'ansible_facts')"
            },
            "5": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": " TREE_DIR = None"
            },
            "6": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " VAULT_VERSION_MIN = 1.0"
            },
            "7": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " VAULT_VERSION_MAX = 1.0"
            }
        },
        "frontPatchFile": [
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2017, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "",
            "from ast import literal_eval",
            "from jinja2 import Template",
            "from string import ascii_letters, digits",
            "",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils.parsing.convert_bool import boolean, BOOLEANS_TRUE",
            "from ansible.module_utils.six import string_types",
            "from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value",
            "",
            "",
            "def _warning(msg):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.warning(msg)",
            "    except Exception:",
            "        import sys",
            "        sys.stderr.write(' [WARNING] %s\\n' % (msg))",
            "",
            "",
            "def _deprecated(msg, version='2.8'):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.deprecated(msg, version=version)",
            "    except Exception:",
            "        import sys",
            "        sys.stderr.write(' [DEPRECATED] %s, to be removed in %s\\n' % (msg, version))",
            "",
            "",
            "def mk_boolean(value):",
            "    ''' moved to module_utils'''",
            "    _deprecated('ansible.constants.mk_boolean() is deprecated.  Use ansible.module_utils.parsing.convert_bool.boolean() instead')",
            "    return boolean(value, strict=False)",
            "",
            "",
            "def get_config(parser, section, key, env_var, default_value, value_type=None, expand_relative_paths=False):",
            "    ''' kept for backwarsd compatibility, but deprecated '''",
            "    _deprecated('ansible.constants.get_config() is deprecated. There is new config API, see porting docs.')",
            "",
            "    value = None",
            "    # small reconstruction of the old code env/ini/default",
            "    value = os.environ.get(env_var, None)",
            "    if value is None:",
            "        try:",
            "            value = get_ini_config_value(parser, {'key': key, 'section': section})",
            "        except Exception:",
            "            pass",
            "    if value is None:",
            "        value = default_value",
            "",
            "    value = ensure_type(value, value_type)",
            "",
            "    return value",
            "",
            "",
            "def set_constant(name, value, export=vars()):",
            "    ''' sets constants and returns resolved options dict '''",
            "    export[name] = value",
            "",
            "",
            "# CONSTANTS ### yes, actual ones",
            "BECOME_METHODS = ['sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas', 'pmrun', 'enable', 'machinectl']",
            "BECOME_ERROR_STRINGS = {",
            "    'sudo': 'Sorry, try again.',",
            "    'su': 'Authentication failure',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Permission denied',",
            "    'dzdo': '',",
            "    'ksu': 'Password incorrect',",
            "    'pmrun': 'You are not permitted to run this command',",
            "    'enable': '',",
            "    'machinectl': '',",
            "}  # FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS = {",
            "    'sudo': 'sorry, a password is required to run sudo',",
            "    'su': '',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Authorization required',",
            "    'dzdo': '',",
            "    'ksu': 'No password given',",
            "    'pmrun': '',",
            "    'enable': '',",
            "    'machinectl': '',",
            "}  # FIXME: deal with i18n",
            "BLACKLIST_EXTS = ('.pyc', '.pyo', '.swp', '.bak', '~', '.rpm', '.md', '.txt', '.rst')",
            "BOOL_TRUE = BOOLEANS_TRUE",
            "CONTROLER_LANG = os.getenv('LANG', 'en_US.UTF-8')",
            "DEFAULT_BECOME_PASS = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS = None",
            "DEFAULT_REMOTE_PASS = None",
            "DEFAULT_SUBSET = None",
            "DEFAULT_SU_PASS = None",
            "# FIXME: expand to other plugins, but never doc fragments",
            "CONFIGURABLE_PLUGINS = ('cache', 'callback', 'connection', 'inventory', 'lookup', 'shell', 'cliconf', 'httpapi')",
            "# NOTE: always update the docs/docsite/Makefile to match",
            "DOCUMENTABLE_PLUGINS = ('cache', 'callback', 'connection', 'inventory', 'lookup', 'shell', 'module', 'strategy', 'vars')",
            "IGNORE_FILES = (\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\")  # ignore during module search",
            "INTERNAL_RESULT_KEYS = ('add_host', 'add_group')",
            "LOCALHOST = ('127.0.0.1', 'localhost', '::1')",
            "MODULE_REQUIRE_ARGS = ('command', 'win_command', 'shell', 'win_shell', 'raw', 'script')",
            "MODULE_NO_JSON = ('command', 'win_command', 'shell', 'win_shell', 'raw')",
            "RESTRICTED_RESULT_KEYS = ('ansible_rsync_path', 'ansible_playbook_python')",
            "TREE_DIR = None",
            "VAULT_VERSION_MIN = 1.0",
            "VAULT_VERSION_MAX = 1.0",
            "",
            "# FIXME: remove once play_context mangling is removed",
            "# the magic variable mapping dictionary below is used to translate",
            "# host/inventory variables to fields in the PlayContext",
            "# object. The dictionary values are tuples, to account for aliases",
            "# in variable names.",
            "",
            "COMMON_CONNECTION_VARS = frozenset(('ansible_connection', 'ansible_host', 'ansible_user', 'ansible_shell_executable',",
            "                                    'ansible_port', 'ansible_pipelining', 'ansible_password', 'ansible_timeout',",
            "                                    'ansible_shell_type', 'ansible_module_compression', 'ansible_private_key_file'))",
            "",
            "MAGIC_VARIABLE_MAPPING = dict(",
            "",
            "    # base",
            "    connection=('ansible_connection', ),",
            "    module_compression=('ansible_module_compression', ),",
            "    shell=('ansible_shell_type', ),",
            "    executable=('ansible_shell_executable', ),",
            "",
            "    # connection common",
            "    remote_addr=('ansible_ssh_host', 'ansible_host'),",
            "    remote_user=('ansible_ssh_user', 'ansible_user'),",
            "    password=('ansible_ssh_pass', 'ansible_password'),",
            "    port=('ansible_ssh_port', 'ansible_port'),",
            "    pipelining=('ansible_ssh_pipelining', 'ansible_pipelining'),",
            "    timeout=('ansible_ssh_timeout', 'ansible_timeout'),",
            "    private_key_file=('ansible_ssh_private_key_file', 'ansible_private_key_file'),",
            "",
            "    # networking modules",
            "    network_os=('ansible_network_os', ),",
            "    connection_user=('ansible_connection_user',),",
            "",
            "    # ssh TODO: remove",
            "    ssh_executable=('ansible_ssh_executable', ),",
            "    ssh_common_args=('ansible_ssh_common_args', ),",
            "    sftp_extra_args=('ansible_sftp_extra_args', ),",
            "    scp_extra_args=('ansible_scp_extra_args', ),",
            "    ssh_extra_args=('ansible_ssh_extra_args', ),",
            "    ssh_transfer_method=('ansible_ssh_transfer_method', ),",
            "",
            "    # docker TODO: remove",
            "    docker_extra_args=('ansible_docker_extra_args', ),",
            "",
            "    # become",
            "    become=('ansible_become', ),",
            "    become_method=('ansible_become_method', ),",
            "    become_user=('ansible_become_user', ),",
            "    become_pass=('ansible_become_password', 'ansible_become_pass'),",
            "    become_exe=('ansible_become_exe', ),",
            "    become_flags=('ansible_become_flags', ),",
            "",
            "    # deprecated",
            "    sudo=('ansible_sudo', ),",
            "    sudo_user=('ansible_sudo_user', ),",
            "    sudo_pass=('ansible_sudo_password', 'ansible_sudo_pass'),",
            "    sudo_exe=('ansible_sudo_exe', ),",
            "    sudo_flags=('ansible_sudo_flags', ),",
            "    su=('ansible_su', ),",
            "    su_user=('ansible_su_user', ),",
            "    su_pass=('ansible_su_password', 'ansible_su_pass'),",
            "    su_exe=('ansible_su_exe', ),",
            "    su_flags=('ansible_su_flags', ),",
            ")",
            "",
            "# POPULATE SETTINGS FROM CONFIG ###",
            "config = ConfigManager()",
            "",
            "# Generate constants from config",
            "for setting in config.data.get_settings():",
            "",
            "    value = setting.value",
            "    if setting.origin == 'default' and \\",
            "       isinstance(setting.value, string_types) and \\",
            "       (setting.value.startswith('{{') and setting.value.endswith('}}')):",
            "        try:",
            "            t = Template(setting.value)",
            "            value = t.render(vars())",
            "            try:",
            "                value = literal_eval(value)",
            "            except ValueError:",
            "                pass  # not a python data structure",
            "        except Exception:",
            "            pass  # not templatable",
            "",
            "        value = ensure_type(value, setting.type)",
            "",
            "    set_constant(setting.name, value)",
            "",
            "for warn in config.WARNINGS:",
            "    _warning(warn)"
        ],
        "afterPatchFile": [
            "# Copyright: (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright: (c) 2017, Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "",
            "from ast import literal_eval",
            "from jinja2 import Template",
            "from string import ascii_letters, digits",
            "",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils.parsing.convert_bool import boolean, BOOLEANS_TRUE",
            "from ansible.module_utils.six import string_types",
            "from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value",
            "",
            "",
            "def _warning(msg):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.warning(msg)",
            "    except Exception:",
            "        import sys",
            "        sys.stderr.write(' [WARNING] %s\\n' % (msg))",
            "",
            "",
            "def _deprecated(msg, version='2.8'):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.deprecated(msg, version=version)",
            "    except Exception:",
            "        import sys",
            "        sys.stderr.write(' [DEPRECATED] %s, to be removed in %s\\n' % (msg, version))",
            "",
            "",
            "def mk_boolean(value):",
            "    ''' moved to module_utils'''",
            "    _deprecated('ansible.constants.mk_boolean() is deprecated.  Use ansible.module_utils.parsing.convert_bool.boolean() instead')",
            "    return boolean(value, strict=False)",
            "",
            "",
            "def get_config(parser, section, key, env_var, default_value, value_type=None, expand_relative_paths=False):",
            "    ''' kept for backwarsd compatibility, but deprecated '''",
            "    _deprecated('ansible.constants.get_config() is deprecated. There is new config API, see porting docs.')",
            "",
            "    value = None",
            "    # small reconstruction of the old code env/ini/default",
            "    value = os.environ.get(env_var, None)",
            "    if value is None:",
            "        try:",
            "            value = get_ini_config_value(parser, {'key': key, 'section': section})",
            "        except Exception:",
            "            pass",
            "    if value is None:",
            "        value = default_value",
            "",
            "    value = ensure_type(value, value_type)",
            "",
            "    return value",
            "",
            "",
            "def set_constant(name, value, export=vars()):",
            "    ''' sets constants and returns resolved options dict '''",
            "    export[name] = value",
            "",
            "",
            "# CONSTANTS ### yes, actual ones",
            "BECOME_METHODS = ['sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas', 'pmrun', 'enable', 'machinectl']",
            "BECOME_ERROR_STRINGS = {",
            "    'sudo': 'Sorry, try again.',",
            "    'su': 'Authentication failure',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Permission denied',",
            "    'dzdo': '',",
            "    'ksu': 'Password incorrect',",
            "    'pmrun': 'You are not permitted to run this command',",
            "    'enable': '',",
            "    'machinectl': '',",
            "}  # FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS = {",
            "    'sudo': 'sorry, a password is required to run sudo',",
            "    'su': '',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Authorization required',",
            "    'dzdo': '',",
            "    'ksu': 'No password given',",
            "    'pmrun': '',",
            "    'enable': '',",
            "    'machinectl': '',",
            "}  # FIXME: deal with i18n",
            "BLACKLIST_EXTS = ('.pyc', '.pyo', '.swp', '.bak', '~', '.rpm', '.md', '.txt', '.rst')",
            "BOOL_TRUE = BOOLEANS_TRUE",
            "CONTROLER_LANG = os.getenv('LANG', 'en_US.UTF-8')",
            "DEFAULT_BECOME_PASS = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS = None",
            "DEFAULT_REMOTE_PASS = None",
            "DEFAULT_SUBSET = None",
            "DEFAULT_SU_PASS = None",
            "# FIXME: expand to other plugins, but never doc fragments",
            "CONFIGURABLE_PLUGINS = ('cache', 'callback', 'connection', 'inventory', 'lookup', 'shell', 'cliconf', 'httpapi')",
            "# NOTE: always update the docs/docsite/Makefile to match",
            "DOCUMENTABLE_PLUGINS = ('cache', 'callback', 'connection', 'inventory', 'lookup', 'shell', 'module', 'strategy', 'vars')",
            "IGNORE_FILES = (\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\")  # ignore during module search",
            "INTERNAL_RESULT_KEYS = ('add_host', 'add_group')",
            "LOCALHOST = ('127.0.0.1', 'localhost', '::1')",
            "MODULE_REQUIRE_ARGS = ('command', 'win_command', 'shell', 'win_shell', 'raw', 'script')",
            "MODULE_NO_JSON = ('command', 'win_command', 'shell', 'win_shell', 'raw')",
            "RESTRICTED_RESULT_KEYS = ('ansible_rsync_path', 'ansible_playbook_python', 'ansible_facts')",
            "TREE_DIR = None",
            "VAULT_VERSION_MIN = 1.0",
            "VAULT_VERSION_MAX = 1.0",
            "",
            "# FIXME: remove once play_context mangling is removed",
            "# the magic variable mapping dictionary below is used to translate",
            "# host/inventory variables to fields in the PlayContext",
            "# object. The dictionary values are tuples, to account for aliases",
            "# in variable names.",
            "",
            "COMMON_CONNECTION_VARS = frozenset(('ansible_connection', 'ansible_host', 'ansible_user', 'ansible_shell_executable',",
            "                                    'ansible_port', 'ansible_pipelining', 'ansible_password', 'ansible_timeout',",
            "                                    'ansible_shell_type', 'ansible_module_compression', 'ansible_private_key_file'))",
            "",
            "MAGIC_VARIABLE_MAPPING = dict(",
            "",
            "    # base",
            "    connection=('ansible_connection', ),",
            "    module_compression=('ansible_module_compression', ),",
            "    shell=('ansible_shell_type', ),",
            "    executable=('ansible_shell_executable', ),",
            "",
            "    # connection common",
            "    remote_addr=('ansible_ssh_host', 'ansible_host'),",
            "    remote_user=('ansible_ssh_user', 'ansible_user'),",
            "    password=('ansible_ssh_pass', 'ansible_password'),",
            "    port=('ansible_ssh_port', 'ansible_port'),",
            "    pipelining=('ansible_ssh_pipelining', 'ansible_pipelining'),",
            "    timeout=('ansible_ssh_timeout', 'ansible_timeout'),",
            "    private_key_file=('ansible_ssh_private_key_file', 'ansible_private_key_file'),",
            "",
            "    # networking modules",
            "    network_os=('ansible_network_os', ),",
            "    connection_user=('ansible_connection_user',),",
            "",
            "    # ssh TODO: remove",
            "    ssh_executable=('ansible_ssh_executable', ),",
            "    ssh_common_args=('ansible_ssh_common_args', ),",
            "    sftp_extra_args=('ansible_sftp_extra_args', ),",
            "    scp_extra_args=('ansible_scp_extra_args', ),",
            "    ssh_extra_args=('ansible_ssh_extra_args', ),",
            "    ssh_transfer_method=('ansible_ssh_transfer_method', ),",
            "",
            "    # docker TODO: remove",
            "    docker_extra_args=('ansible_docker_extra_args', ),",
            "",
            "    # become",
            "    become=('ansible_become', ),",
            "    become_method=('ansible_become_method', ),",
            "    become_user=('ansible_become_user', ),",
            "    become_pass=('ansible_become_password', 'ansible_become_pass'),",
            "    become_exe=('ansible_become_exe', ),",
            "    become_flags=('ansible_become_flags', ),",
            "",
            "    # deprecated",
            "    sudo=('ansible_sudo', ),",
            "    sudo_user=('ansible_sudo_user', ),",
            "    sudo_pass=('ansible_sudo_password', 'ansible_sudo_pass'),",
            "    sudo_exe=('ansible_sudo_exe', ),",
            "    sudo_flags=('ansible_sudo_flags', ),",
            "    su=('ansible_su', ),",
            "    su_user=('ansible_su_user', ),",
            "    su_pass=('ansible_su_password', 'ansible_su_pass'),",
            "    su_exe=('ansible_su_exe', ),",
            "    su_flags=('ansible_su_flags', ),",
            ")",
            "",
            "# POPULATE SETTINGS FROM CONFIG ###",
            "config = ConfigManager()",
            "",
            "# Generate constants from config",
            "for setting in config.data.get_settings():",
            "",
            "    value = setting.value",
            "    if setting.origin == 'default' and \\",
            "       isinstance(setting.value, string_types) and \\",
            "       (setting.value.startswith('{{') and setting.value.endswith('}}')):",
            "        try:",
            "            t = Template(setting.value)",
            "            value = t.render(vars())",
            "            try:",
            "                value = literal_eval(value)",
            "            except ValueError:",
            "                pass  # not a python data structure",
            "        except Exception:",
            "            pass  # not templatable",
            "",
            "        value = ensure_type(value, setting.type)",
            "",
            "    set_constant(setting.name, value)",
            "",
            "for warn in config.WARNINGS:",
            "    _warning(warn)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "115": [
                "RESTRICTED_RESULT_KEYS"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/vars/clean.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     ''' return all facts inside 'ansible_facts' w/o an ansible_ prefix '''"
            },
            "1": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     deprefixed = {}"
            },
            "2": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     for k in facts:"
            },
            "3": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if k in ('ansible_local',):"
            },
            "4": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # exceptions to 'deprefixing'"
            },
            "5": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            deprefixed[k] = module_response_deepcopy(facts[k])"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        if k.startswith('ansible_') and k not in ('ansible_local',):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            deprefixed[k[8:]] = module_response_deepcopy(facts[k])"
            },
            "8": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         else:"
            },
            "9": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            deprefixed[k.replace('ansible_', '', 1)] = module_response_deepcopy(facts[k])"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            deprefixed[k] = module_response_deepcopy(facts[k])"
            },
            "11": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     return {'ansible_facts': deprefixed}"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import re",
            "",
            "from ansible import constants as C",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils import six",
            "from ansible.plugins.loader import connection_loader",
            "",
            "try:",
            "    from __main__ import display",
            "except ImportError:",
            "    from ansible.utils.display import Display",
            "    display = Display()",
            "",
            "",
            "def module_response_deepcopy(v):",
            "    \"\"\"Function to create a deep copy of module response data",
            "",
            "    Designed to be used within the Ansible \"engine\" to improve performance",
            "    issues where ``copy.deepcopy`` was used previously, largely with CPU",
            "    and memory contention.",
            "",
            "    This only supports the following data types, and was designed to only",
            "    handle specific workloads:",
            "",
            "    * ``dict``",
            "    * ``list``",
            "",
            "    The data we pass here will come from a serialization such",
            "    as JSON, so we shouldn't have need for other data types such as",
            "    ``set`` or ``tuple``.",
            "",
            "    Take note that this function should not be used extensively as a",
            "    replacement for ``deepcopy`` due to the naive way in which this",
            "    handles other data types.",
            "",
            "    Do not expect uses outside of those listed below to maintain",
            "    backwards compatibility, in case we need to extend this function",
            "    to handle our specific needs:",
            "",
            "    * ``ansible.executor.task_result.TaskResult.clean_copy``",
            "    * ``ansible.vars.clean.clean_facts``",
            "    * ``ansible.vars.namespace_facts``",
            "    \"\"\"",
            "    if isinstance(v, dict):",
            "        ret = v.copy()",
            "        items = six.iteritems(ret)",
            "    elif isinstance(v, list):",
            "        ret = v[:]",
            "        items = enumerate(ret)",
            "    else:",
            "        return v",
            "",
            "    for key, value in items:",
            "        if isinstance(value, (dict, list)):",
            "            ret[key] = module_response_deepcopy(value)",
            "        else:",
            "            ret[key] = value",
            "",
            "    return ret",
            "",
            "",
            "def strip_internal_keys(dirty, exceptions=None):",
            "    '''",
            "    All keys starting with _ansible_ are internal, so create a copy of the 'dirty' dict",
            "    and remove them from the clean one before returning it",
            "    '''",
            "",
            "    if exceptions is None:",
            "        exceptions = ()",
            "    clean = dirty.copy()",
            "    for k in dirty.keys():",
            "        if isinstance(k, six.string_types) and k.startswith('_ansible_'):",
            "            if k not in exceptions:",
            "                del clean[k]",
            "        elif isinstance(dirty[k], dict):",
            "            clean[k] = strip_internal_keys(dirty[k])",
            "    return clean",
            "",
            "",
            "def remove_internal_keys(data):",
            "    '''",
            "    More nuanced version of strip_internal_keys",
            "    '''",
            "    for key in list(data.keys()):",
            "        if (key.startswith('_ansible_') and key != '_ansible_parsed') or key in C.INTERNAL_RESULT_KEYS:",
            "            display.warning(\"Removed unexpected internal key in module return: %s = %s\" % (key, data[key]))",
            "            del data[key]",
            "",
            "    # remove bad/empty internal keys",
            "    for key in ['warnings', 'deprecations']:",
            "        if key in data and not data[key]:",
            "            del data[key]",
            "",
            "",
            "def clean_facts(facts):",
            "    ''' remove facts that can override internal keys or otherwise deemed unsafe '''",
            "    data = module_response_deepcopy(facts)",
            "",
            "    remove_keys = set()",
            "    fact_keys = set(data.keys())",
            "    # first we add all of our magic variable names to the set of",
            "    # keys we want to remove from facts",
            "    # NOTE: these will eventually disappear in favor of others below",
            "    for magic_var in C.MAGIC_VARIABLE_MAPPING:",
            "        remove_keys.update(fact_keys.intersection(C.MAGIC_VARIABLE_MAPPING[magic_var]))",
            "",
            "    # remove common connection vars",
            "    remove_keys.update(fact_keys.intersection(C.COMMON_CONNECTION_VARS))",
            "",
            "    # next we remove any connection plugin specific vars",
            "    for conn_path in connection_loader.all(path_only=True):",
            "        try:",
            "            conn_name = os.path.splitext(os.path.basename(conn_path))[0]",
            "            re_key = re.compile('^ansible_%s_' % conn_name)",
            "            for fact_key in fact_keys:",
            "                # most lightweight VM or container tech creates devices with this pattern, this avoids filtering them out",
            "                if (re_key.match(fact_key) and not fact_key.endswith(('_bridge', '_gwbridge'))) or re_key.startswith('ansible_become_'):",
            "                    remove_keys.add(fact_key)",
            "        except AttributeError:",
            "            pass",
            "",
            "    # remove some KNOWN keys",
            "    for hard in C.RESTRICTED_RESULT_KEYS + C.INTERNAL_RESULT_KEYS:",
            "        if hard in fact_keys:",
            "            remove_keys.add(hard)",
            "",
            "    # finally, we search for interpreter keys to remove",
            "    re_interp = re.compile('^ansible_.*_interpreter$')",
            "    for fact_key in fact_keys:",
            "        if re_interp.match(fact_key):",
            "            remove_keys.add(fact_key)",
            "    # then we remove them (except for ssh host keys)",
            "    for r_key in remove_keys:",
            "        if not r_key.startswith('ansible_ssh_host_key_'):",
            "            try:",
            "                r_val = to_text(data[r_key])",
            "                if len(r_val) > 24:",
            "                    r_val = '%s ... %s' % (r_val[:13], r_val[-6:])",
            "            except Exception:",
            "                r_val = ' <failed to convert value to a string> '",
            "            display.warning(\"Removed restricted key from module data: %s = %s\" % (r_key, r_val))",
            "            del data[r_key]",
            "",
            "    return strip_internal_keys(data)",
            "",
            "",
            "def namespace_facts(facts):",
            "    ''' return all facts inside 'ansible_facts' w/o an ansible_ prefix '''",
            "    deprefixed = {}",
            "    for k in facts:",
            "        if k in ('ansible_local',):",
            "            # exceptions to 'deprefixing'",
            "            deprefixed[k] = module_response_deepcopy(facts[k])",
            "        else:",
            "            deprefixed[k.replace('ansible_', '', 1)] = module_response_deepcopy(facts[k])",
            "",
            "    return {'ansible_facts': deprefixed}"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import re",
            "",
            "from ansible import constants as C",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils import six",
            "from ansible.plugins.loader import connection_loader",
            "",
            "try:",
            "    from __main__ import display",
            "except ImportError:",
            "    from ansible.utils.display import Display",
            "    display = Display()",
            "",
            "",
            "def module_response_deepcopy(v):",
            "    \"\"\"Function to create a deep copy of module response data",
            "",
            "    Designed to be used within the Ansible \"engine\" to improve performance",
            "    issues where ``copy.deepcopy`` was used previously, largely with CPU",
            "    and memory contention.",
            "",
            "    This only supports the following data types, and was designed to only",
            "    handle specific workloads:",
            "",
            "    * ``dict``",
            "    * ``list``",
            "",
            "    The data we pass here will come from a serialization such",
            "    as JSON, so we shouldn't have need for other data types such as",
            "    ``set`` or ``tuple``.",
            "",
            "    Take note that this function should not be used extensively as a",
            "    replacement for ``deepcopy`` due to the naive way in which this",
            "    handles other data types.",
            "",
            "    Do not expect uses outside of those listed below to maintain",
            "    backwards compatibility, in case we need to extend this function",
            "    to handle our specific needs:",
            "",
            "    * ``ansible.executor.task_result.TaskResult.clean_copy``",
            "    * ``ansible.vars.clean.clean_facts``",
            "    * ``ansible.vars.namespace_facts``",
            "    \"\"\"",
            "    if isinstance(v, dict):",
            "        ret = v.copy()",
            "        items = six.iteritems(ret)",
            "    elif isinstance(v, list):",
            "        ret = v[:]",
            "        items = enumerate(ret)",
            "    else:",
            "        return v",
            "",
            "    for key, value in items:",
            "        if isinstance(value, (dict, list)):",
            "            ret[key] = module_response_deepcopy(value)",
            "        else:",
            "            ret[key] = value",
            "",
            "    return ret",
            "",
            "",
            "def strip_internal_keys(dirty, exceptions=None):",
            "    '''",
            "    All keys starting with _ansible_ are internal, so create a copy of the 'dirty' dict",
            "    and remove them from the clean one before returning it",
            "    '''",
            "",
            "    if exceptions is None:",
            "        exceptions = ()",
            "    clean = dirty.copy()",
            "    for k in dirty.keys():",
            "        if isinstance(k, six.string_types) and k.startswith('_ansible_'):",
            "            if k not in exceptions:",
            "                del clean[k]",
            "        elif isinstance(dirty[k], dict):",
            "            clean[k] = strip_internal_keys(dirty[k])",
            "    return clean",
            "",
            "",
            "def remove_internal_keys(data):",
            "    '''",
            "    More nuanced version of strip_internal_keys",
            "    '''",
            "    for key in list(data.keys()):",
            "        if (key.startswith('_ansible_') and key != '_ansible_parsed') or key in C.INTERNAL_RESULT_KEYS:",
            "            display.warning(\"Removed unexpected internal key in module return: %s = %s\" % (key, data[key]))",
            "            del data[key]",
            "",
            "    # remove bad/empty internal keys",
            "    for key in ['warnings', 'deprecations']:",
            "        if key in data and not data[key]:",
            "            del data[key]",
            "",
            "",
            "def clean_facts(facts):",
            "    ''' remove facts that can override internal keys or otherwise deemed unsafe '''",
            "    data = module_response_deepcopy(facts)",
            "",
            "    remove_keys = set()",
            "    fact_keys = set(data.keys())",
            "    # first we add all of our magic variable names to the set of",
            "    # keys we want to remove from facts",
            "    # NOTE: these will eventually disappear in favor of others below",
            "    for magic_var in C.MAGIC_VARIABLE_MAPPING:",
            "        remove_keys.update(fact_keys.intersection(C.MAGIC_VARIABLE_MAPPING[magic_var]))",
            "",
            "    # remove common connection vars",
            "    remove_keys.update(fact_keys.intersection(C.COMMON_CONNECTION_VARS))",
            "",
            "    # next we remove any connection plugin specific vars",
            "    for conn_path in connection_loader.all(path_only=True):",
            "        try:",
            "            conn_name = os.path.splitext(os.path.basename(conn_path))[0]",
            "            re_key = re.compile('^ansible_%s_' % conn_name)",
            "            for fact_key in fact_keys:",
            "                # most lightweight VM or container tech creates devices with this pattern, this avoids filtering them out",
            "                if (re_key.match(fact_key) and not fact_key.endswith(('_bridge', '_gwbridge'))) or re_key.startswith('ansible_become_'):",
            "                    remove_keys.add(fact_key)",
            "        except AttributeError:",
            "            pass",
            "",
            "    # remove some KNOWN keys",
            "    for hard in C.RESTRICTED_RESULT_KEYS + C.INTERNAL_RESULT_KEYS:",
            "        if hard in fact_keys:",
            "            remove_keys.add(hard)",
            "",
            "    # finally, we search for interpreter keys to remove",
            "    re_interp = re.compile('^ansible_.*_interpreter$')",
            "    for fact_key in fact_keys:",
            "        if re_interp.match(fact_key):",
            "            remove_keys.add(fact_key)",
            "    # then we remove them (except for ssh host keys)",
            "    for r_key in remove_keys:",
            "        if not r_key.startswith('ansible_ssh_host_key_'):",
            "            try:",
            "                r_val = to_text(data[r_key])",
            "                if len(r_val) > 24:",
            "                    r_val = '%s ... %s' % (r_val[:13], r_val[-6:])",
            "            except Exception:",
            "                r_val = ' <failed to convert value to a string> '",
            "            display.warning(\"Removed restricted key from module data: %s = %s\" % (r_key, r_val))",
            "            del data[r_key]",
            "",
            "    return strip_internal_keys(data)",
            "",
            "",
            "def namespace_facts(facts):",
            "    ''' return all facts inside 'ansible_facts' w/o an ansible_ prefix '''",
            "    deprefixed = {}",
            "    for k in facts:",
            "        if k.startswith('ansible_') and k not in ('ansible_local',):",
            "            deprefixed[k[8:]] = module_response_deepcopy(facts[k])",
            "        else:",
            "            deprefixed[k] = module_response_deepcopy(facts[k])",
            "",
            "    return {'ansible_facts': deprefixed}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "159": [
                "namespace_facts"
            ],
            "160": [
                "namespace_facts"
            ],
            "161": [
                "namespace_facts"
            ],
            "163": [
                "namespace_facts"
            ]
        },
        "addLocation": []
    }
}