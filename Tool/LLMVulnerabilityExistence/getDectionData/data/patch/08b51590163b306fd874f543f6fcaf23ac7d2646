{
    "gradio/blocks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     get_render_context,"
            },
            "1": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "     set_render_context,"
            },
            "2": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from gradio.data_classes import BlocksConfigDict, FileData, GradioModel, GradioRootModel"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+from gradio.data_classes import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    BlocksConfigDict,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    DeveloperPath,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    FileData,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    GradioModel,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    GradioRootModel,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+)"
            },
            "11": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 66,
                "PatchRowcode": " from gradio.events import ("
            },
            "12": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "     EventData,"
            },
            "13": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "     EventListener,"
            },
            "14": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 415,
                "PatchRowcode": "             render=render,"
            },
            "15": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "         )"
            },
            "16": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 417,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    TEMPLATE_DIR = \"./templates/\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+    TEMPLATE_DIR = DeveloperPath(\"./templates/\")"
            },
            "19": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 419,
                "PatchRowcode": "     FRONTEND_DIR = \"../../frontend/\""
            },
            "20": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 420,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 421,
                "PatchRowcode": "     @property"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import copy",
            "import dataclasses",
            "import hashlib",
            "import inspect",
            "import json",
            "import os",
            "import random",
            "import secrets",
            "import string",
            "import sys",
            "import threading",
            "import time",
            "import warnings",
            "import webbrowser",
            "from collections import defaultdict",
            "from pathlib import Path",
            "from types import ModuleType",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    AbstractSet,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Literal,",
            "    Sequence,",
            "    cast,",
            ")",
            "from urllib.parse import urlparse, urlunparse",
            "",
            "import anyio",
            "import fastapi",
            "import httpx",
            "from anyio import CapacityLimiter",
            "from gradio_client import utils as client_utils",
            "from gradio_client.documentation import document",
            "",
            "from gradio import (",
            "    analytics,",
            "    components,",
            "    networking,",
            "    processing_utils,",
            "    queueing,",
            "    routes,",
            "    strings,",
            "    themes,",
            "    utils,",
            "    wasm_utils,",
            ")",
            "from gradio.blocks_events import BlocksEvents, BlocksMeta",
            "from gradio.context import (",
            "    Context,",
            "    LocalContext,",
            "    get_blocks_context,",
            "    get_render_context,",
            "    set_render_context,",
            ")",
            "from gradio.data_classes import BlocksConfigDict, FileData, GradioModel, GradioRootModel",
            "from gradio.events import (",
            "    EventData,",
            "    EventListener,",
            "    EventListenerMethod,",
            ")",
            "from gradio.exceptions import (",
            "    DuplicateBlockError,",
            "    InvalidApiNameError,",
            "    InvalidComponentError,",
            ")",
            "from gradio.helpers import create_tracker, skip, special_args",
            "from gradio.state_holder import SessionState, StateHolder",
            "from gradio.themes import Default as DefaultTheme",
            "from gradio.themes import ThemeClass as Theme",
            "from gradio.tunneling import (",
            "    BINARY_FILENAME,",
            "    BINARY_FOLDER,",
            "    BINARY_PATH,",
            "    BINARY_URL,",
            "    CURRENT_TUNNELS,",
            ")",
            "from gradio.utils import (",
            "    TupleNoPrint,",
            "    check_function_inputs_match,",
            "    component_or_layout_class,",
            "    get_cancelled_fn_indices,",
            "    get_package_version,",
            "    get_upload_folder,",
            ")",
            "",
            "try:",
            "    import spaces  # type: ignore",
            "except Exception:",
            "    spaces = None",
            "",
            "",
            "if TYPE_CHECKING:  # Only import for type checking (is False at runtime).",
            "    from fastapi.applications import FastAPI",
            "",
            "    from gradio.components.base import Component",
            "    from gradio.renderable import Renderable",
            "",
            "BUILT_IN_THEMES: dict[str, Theme] = {",
            "    t.name: t",
            "    for t in [",
            "        themes.Base(),",
            "        themes.Default(),",
            "        themes.Monochrome(),",
            "        themes.Soft(),",
            "        themes.Glass(),",
            "    ]",
            "}",
            "",
            "",
            "class Block:",
            "    def __init__(",
            "        self,",
            "        *,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        render: bool = True,",
            "        key: int | str | None = None,",
            "        visible: bool = True,",
            "        proxy_url: str | None = None,",
            "    ):",
            "        self._id = Context.id",
            "        Context.id += 1",
            "        self.visible = visible",
            "        self.elem_id = elem_id",
            "        self.elem_classes = (",
            "            [elem_classes] if isinstance(elem_classes, str) else elem_classes",
            "        )",
            "        self.proxy_url = proxy_url",
            "        self.share_token = secrets.token_urlsafe(32)",
            "        self.parent: BlockContext | None = None",
            "        self.rendered_in: Renderable | None = None",
            "        self.is_rendered: bool = False",
            "        self._constructor_args: list[dict]",
            "        self.state_session_capacity = 10000",
            "        self.temp_files: set[str] = set()",
            "        self.GRADIO_CACHE = get_upload_folder()",
            "        self.key = key",
            "        # Keep tracks of files that should not be deleted when the delete_cache parmameter is set",
            "        # These files are the default value of the component and files that are used in examples",
            "        self.keep_in_cache = set()",
            "",
            "        if render:",
            "            self.render()",
            "",
            "    @property",
            "    def stateful(self) -> bool:",
            "        return False",
            "",
            "    @property",
            "    def skip_api(self) -> bool:",
            "        return False",
            "",
            "    @property",
            "    def constructor_args(self) -> dict[str, Any]:",
            "        \"\"\"Get the arguments passed to the component's initializer.",
            "",
            "        Only set classes whose metaclass is ComponentMeta",
            "        \"\"\"",
            "        # the _constructor_args list is appended based on the mro of the class",
            "        # so the first entry is for the bottom of the hierarchy",
            "        return self._constructor_args[0] if self._constructor_args else {}",
            "",
            "    @property",
            "    def events(",
            "        self,",
            "    ) -> list[EventListener]:",
            "        return getattr(self, \"EVENTS\", [])",
            "",
            "    def render(self):",
            "        \"\"\"",
            "        Adds self into appropriate BlockContext",
            "        \"\"\"",
            "        root_context = get_blocks_context()",
            "        render_context = get_render_context()",
            "        self.rendered_in = LocalContext.renderable.get()",
            "        if root_context is not None and self._id in root_context.blocks:",
            "            raise DuplicateBlockError(",
            "                f\"A block with id: {self._id} has already been rendered in the current Blocks.\"",
            "            )",
            "        if render_context is not None:",
            "            render_context.add(self)",
            "        if root_context is not None:",
            "            root_context.blocks[self._id] = self",
            "            self.is_rendered = True",
            "            if isinstance(self, components.Component):",
            "                root_context.root_block.temp_file_sets.append(self.temp_files)",
            "        return self",
            "",
            "    def unrender(self):",
            "        \"\"\"",
            "        Removes self from BlockContext if it has been rendered (otherwise does nothing).",
            "        Removes self from the layout and collection of blocks, but does not delete any event triggers.",
            "        \"\"\"",
            "        root_context = get_blocks_context()",
            "        render_context = get_render_context()",
            "        if render_context is not None:",
            "            try:",
            "                render_context.children.remove(self)",
            "            except ValueError:",
            "                pass",
            "        if root_context is not None:",
            "            try:",
            "                del root_context.blocks[self._id]",
            "                self.is_rendered = False",
            "            except KeyError:",
            "                pass",
            "        return self",
            "",
            "    def get_block_name(self) -> str:",
            "        \"\"\"",
            "        Gets block's class name. If it is template component it gets the parent's class name.",
            "        This is used to identify the Svelte file to use in the frontend. Override this method",
            "        if a component should use a different Svelte file than the default naming convention.",
            "        \"\"\"",
            "        return (",
            "            self.__class__.__base__.__name__.lower()  # type: ignore",
            "            if hasattr(self, \"is_template\")",
            "            else self.__class__.__name__.lower()",
            "        )",
            "",
            "    def get_block_class(self) -> str:",
            "        \"\"\"",
            "        Gets block's class name. If it is template component it gets the parent's class name.",
            "        Very similar to the get_block_name method, but this method is used to reconstruct a",
            "        Gradio app that is loaded from a Space using gr.load(). This should generally",
            "        NOT be overridden.",
            "        \"\"\"",
            "        return (",
            "            self.__class__.__base__.__name__.lower()  # type: ignore",
            "            if hasattr(self, \"is_template\")",
            "            else self.__class__.__name__.lower()",
            "        )",
            "",
            "    def get_expected_parent(self) -> type[BlockContext] | None:",
            "        return None",
            "",
            "    def get_config(self):",
            "        config = {}",
            "        signature = inspect.signature(self.__class__.__init__)",
            "        for parameter in signature.parameters.values():",
            "            if hasattr(self, parameter.name):",
            "                value = getattr(self, parameter.name)",
            "                if dataclasses.is_dataclass(value):",
            "                    value = dataclasses.asdict(value)  # type: ignore",
            "                config[parameter.name] = value",
            "        for e in self.events:",
            "            to_add = e.config_data()",
            "            if to_add:",
            "                config = {**to_add, **config}",
            "        config.pop(\"render\", None)",
            "        config = {**config, \"proxy_url\": self.proxy_url, \"name\": self.get_block_class()}",
            "        if self.rendered_in is not None:",
            "            config[\"rendered_in\"] = self.rendered_in._id",
            "        if (_selectable := getattr(self, \"_selectable\", None)) is not None:",
            "            config[\"_selectable\"] = _selectable",
            "        return config",
            "",
            "    @classmethod",
            "    def recover_kwargs(",
            "        cls, props: dict[str, Any], additional_keys: list[str] | None = None",
            "    ):",
            "        \"\"\"",
            "        Recovers kwargs from a dict of props.",
            "        \"\"\"",
            "        additional_keys = additional_keys or []",
            "        signature = inspect.signature(cls.__init__)",
            "        kwargs = {}",
            "        for parameter in signature.parameters.values():",
            "            if parameter.name in props and parameter.name not in additional_keys:",
            "                kwargs[parameter.name] = props[parameter.name]",
            "        return kwargs",
            "",
            "    async def async_move_resource_to_block_cache(",
            "        self, url_or_file_path: str | Path | None",
            "    ) -> str | None:",
            "        \"\"\"Moves a file or downloads a file from a url to a block's cache directory, adds",
            "        to to the block's temp_files, and returns the path to the file in cache. This",
            "        ensures that the file is accessible to the Block and can be served to users.",
            "",
            "        This async version of the function is used when this is being called within",
            "        a FastAPI route, as this is not blocking.",
            "        \"\"\"",
            "        if url_or_file_path is None:",
            "            return None",
            "        if isinstance(url_or_file_path, Path):",
            "            url_or_file_path = str(url_or_file_path)",
            "",
            "        if client_utils.is_http_url_like(url_or_file_path):",
            "            temp_file_path = await processing_utils.async_save_url_to_cache(",
            "                url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "            )",
            "",
            "            self.temp_files.add(temp_file_path)",
            "        else:",
            "            url_or_file_path = str(utils.abspath(url_or_file_path))",
            "            if not utils.is_in_or_equal(url_or_file_path, self.GRADIO_CACHE):",
            "                try:",
            "                    temp_file_path = processing_utils.save_file_to_cache(",
            "                        url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "                    )",
            "                except FileNotFoundError:",
            "                    # This can happen if when using gr.load() and the file is on a remote Space",
            "                    # but the file is not the `value` of the component. For example, if the file",
            "                    # is the `avatar_image` of the `Chatbot` component. In this case, we skip",
            "                    # copying the file to the cache and just use the remote file path.",
            "                    return url_or_file_path",
            "            else:",
            "                temp_file_path = url_or_file_path",
            "            self.temp_files.add(temp_file_path)",
            "",
            "        return temp_file_path",
            "",
            "    def move_resource_to_block_cache(",
            "        self, url_or_file_path: str | Path | None",
            "    ) -> str | None:",
            "        \"\"\"Moves a file or downloads a file from a url to a block's cache directory, adds",
            "        to to the block's temp_files, and returns the path to the file in cache. This",
            "        ensures that the file is accessible to the Block and can be served to users.",
            "",
            "        This sync version of the function is used when this is being called outside of",
            "        a FastAPI route, e.g. when examples are being cached.",
            "        \"\"\"",
            "        if url_or_file_path is None:",
            "            return None",
            "        if isinstance(url_or_file_path, Path):",
            "            url_or_file_path = str(url_or_file_path)",
            "",
            "        if client_utils.is_http_url_like(url_or_file_path):",
            "            temp_file_path = processing_utils.save_url_to_cache(",
            "                url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "            )",
            "",
            "            self.temp_files.add(temp_file_path)",
            "        else:",
            "            url_or_file_path = str(utils.abspath(url_or_file_path))",
            "            if not utils.is_in_or_equal(url_or_file_path, self.GRADIO_CACHE):",
            "                try:",
            "                    temp_file_path = processing_utils.save_file_to_cache(",
            "                        url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "                    )",
            "                except FileNotFoundError:",
            "                    # This can happen if when using gr.load() and the file is on a remote Space",
            "                    # but the file is not the `value` of the component. For example, if the file",
            "                    # is the `avatar_image` of the `Chatbot` component. In this case, we skip",
            "                    # copying the file to the cache and just use the remote file path.",
            "                    return url_or_file_path",
            "            else:",
            "                temp_file_path = url_or_file_path",
            "            self.temp_files.add(temp_file_path)",
            "",
            "        return temp_file_path",
            "",
            "    def serve_static_file(",
            "        self, url_or_file_path: str | Path | dict | None",
            "    ) -> dict | None:",
            "        \"\"\"If a file is a local file, moves it to the block's cache directory and returns",
            "        a FileData-type dictionary corresponding to the file. If the file is a URL, returns a",
            "        FileData-type dictionary corresponding to the URL. This ensures that the file is",
            "        accessible in the frontend and can be served to users.",
            "",
            "        Examples:",
            "        >>> block.serve_static_file(\"https://gradio.app/logo.png\") -> {\"path\": \"https://gradio.app/logo.png\", \"url\": \"https://gradio.app/logo.png\"}",
            "        >>> block.serve_static_file(\"logo.png\") -> {\"path\": \"logo.png\", \"url\": \"/file=logo.png\"}",
            "        >>> block.serve_static_file({\"path\": \"logo.png\", \"url\": \"/file=logo.png\"}) -> {\"path\": \"logo.png\", \"url\": \"/file=logo.png\"}",
            "        \"\"\"",
            "        if url_or_file_path is None:",
            "            return None",
            "        if isinstance(url_or_file_path, dict):",
            "            return url_or_file_path",
            "        if isinstance(url_or_file_path, Path):",
            "            url_or_file_path = str(url_or_file_path)",
            "        if client_utils.is_http_url_like(url_or_file_path):",
            "            return FileData(path=url_or_file_path, url=url_or_file_path).model_dump()",
            "        else:",
            "            data = {\"path\": url_or_file_path}",
            "            try:",
            "                return client_utils.synchronize_async(",
            "                    processing_utils.async_move_files_to_cache, data, self",
            "                )",
            "            except AttributeError:  # Can be raised if this function is called before the Block is fully initialized.",
            "                return data",
            "",
            "",
            "class BlockContext(Block):",
            "    def __init__(",
            "        self,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        visible: bool = True,",
            "        render: bool = True,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            elem_id: An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            elem_classes: An optional string or list of strings that are assigned as the class of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            visible: If False, this will be hidden but included in the Blocks config file (its visibility can later be updated).",
            "            render: If False, this will not be included in the Blocks config file at all.",
            "        \"\"\"",
            "        self.children: list[Block] = []",
            "        Block.__init__(",
            "            self,",
            "            elem_id=elem_id,",
            "            elem_classes=elem_classes,",
            "            visible=visible,",
            "            render=render,",
            "        )",
            "",
            "    TEMPLATE_DIR = \"./templates/\"",
            "    FRONTEND_DIR = \"../../frontend/\"",
            "",
            "    @property",
            "    def skip_api(self):",
            "        return True",
            "",
            "    @classmethod",
            "    def get_component_class_id(cls) -> str:",
            "        module_name = cls.__module__",
            "        module_path = sys.modules[module_name].__file__",
            "        module_hash = hashlib.md5(f\"{cls.__name__}_{module_path}\".encode()).hexdigest()",
            "        return module_hash",
            "",
            "    @property",
            "    def component_class_id(self):",
            "        return self.get_component_class_id()",
            "",
            "    def add_child(self, child: Block):",
            "        self.children.append(child)",
            "",
            "    def __enter__(self):",
            "        render_context = get_render_context()",
            "        self.parent = render_context",
            "        set_render_context(self)",
            "        return self",
            "",
            "    def add(self, child: Block):",
            "        child.parent = self",
            "        self.children.append(child)",
            "",
            "    def fill_expected_parents(self):",
            "        root_context = get_blocks_context()",
            "        children = []",
            "        pseudo_parent = None",
            "        for child in self.children:",
            "            expected_parent = child.get_expected_parent()",
            "            if not expected_parent or isinstance(self, expected_parent):",
            "                pseudo_parent = None",
            "                children.append(child)",
            "            else:",
            "                if pseudo_parent is not None and isinstance(",
            "                    pseudo_parent, expected_parent",
            "                ):",
            "                    pseudo_parent.add_child(child)",
            "                else:",
            "                    pseudo_parent = expected_parent(render=False)",
            "                    pseudo_parent.parent = self",
            "                    children.append(pseudo_parent)",
            "                    pseudo_parent.add_child(child)",
            "                    if root_context:",
            "                        root_context.blocks[pseudo_parent._id] = pseudo_parent",
            "                child.parent = pseudo_parent",
            "        self.children = children",
            "",
            "    def __exit__(self, exc_type: type[BaseException] | None = None, *args):",
            "        set_render_context(self.parent)",
            "        if exc_type is not None:",
            "            return",
            "        if getattr(self, \"allow_expected_parents\", True):",
            "            self.fill_expected_parents()",
            "",
            "    def postprocess(self, y):",
            "        \"\"\"",
            "        Any postprocessing needed to be performed on a block context.",
            "        \"\"\"",
            "        return y",
            "",
            "",
            "class BlockFunction:",
            "    def __init__(",
            "        self,",
            "        fn: Callable | None,",
            "        inputs: Sequence[Component | BlockContext],",
            "        outputs: Sequence[Component | BlockContext],",
            "        preprocess: bool,",
            "        postprocess: bool,",
            "        inputs_as_dict: bool,",
            "        targets: list[tuple[int | None, str]],",
            "        _id: int,",
            "        batch: bool = False,",
            "        max_batch_size: int = 4,",
            "        concurrency_limit: int | None | Literal[\"default\"] = \"default\",",
            "        concurrency_id: str | None = None,",
            "        tracks_progress: bool = False,",
            "        api_name: str | Literal[False] = False,",
            "        js: str | None = None,",
            "        show_progress: Literal[\"full\", \"minimal\", \"hidden\"] = \"full\",",
            "        cancels: list[int] | None = None,",
            "        collects_event_data: bool = False,",
            "        trigger_after: int | None = None,",
            "        trigger_only_on_success: bool = False,",
            "        trigger_mode: Literal[\"always_last\", \"once\", \"multiple\"] = \"once\",",
            "        queue: bool = True,",
            "        scroll_to_output: bool = False,",
            "        show_api: bool = True,",
            "        renderable: Renderable | None = None,",
            "        rendered_in: Renderable | None = None,",
            "        is_cancel_function: bool = False,",
            "    ):",
            "        self.fn = fn",
            "        self._id = _id",
            "        self.inputs = inputs",
            "        self.outputs = outputs",
            "        self.preprocess = preprocess",
            "        self.postprocess = postprocess",
            "        self.tracks_progress = tracks_progress",
            "        self.concurrency_limit: int | None | Literal[\"default\"] = concurrency_limit",
            "        self.concurrency_id = concurrency_id or str(id(fn))",
            "        self.batch = batch",
            "        self.max_batch_size = max_batch_size",
            "        self.total_runtime = 0",
            "        self.total_runs = 0",
            "        self.inputs_as_dict = inputs_as_dict",
            "        self.targets = targets",
            "        self.name = getattr(fn, \"__name__\", \"fn\") if fn is not None else None",
            "        self.api_name = api_name",
            "        self.js = js",
            "        self.show_progress = show_progress",
            "        self.cancels = cancels or []",
            "        self.collects_event_data = collects_event_data",
            "        self.trigger_after = trigger_after",
            "        self.trigger_only_on_success = trigger_only_on_success",
            "        self.trigger_mode = trigger_mode",
            "        self.queue = False if fn is None else queue",
            "        self.scroll_to_output = False if utils.get_space() else scroll_to_output",
            "        self.show_api = show_api",
            "        self.zero_gpu = hasattr(self.fn, \"zerogpu\")",
            "        self.types_generator = inspect.isgeneratorfunction(",
            "            self.fn",
            "        ) or inspect.isasyncgenfunction(self.fn)",
            "        self.renderable = renderable",
            "        self.rendered_in = rendered_in",
            "",
            "        # We need to keep track of which events are cancel events",
            "        # so that the client can call the /cancel route directly",
            "        self.is_cancel_function = is_cancel_function",
            "",
            "        self.spaces_auto_wrap()",
            "",
            "    def spaces_auto_wrap(self):",
            "        if spaces is None:",
            "            return",
            "        if utils.get_space() is None:",
            "            return",
            "        self.fn = spaces.gradio_auto_wrap(self.fn)",
            "",
            "    def __str__(self):",
            "        return str(",
            "            {",
            "                \"fn\": self.name,",
            "                \"preprocess\": self.preprocess,",
            "                \"postprocess\": self.postprocess,",
            "            }",
            "        )",
            "",
            "    def __repr__(self):",
            "        return str(self)",
            "",
            "    def get_config(self):",
            "        return {",
            "            \"id\": self._id,",
            "            \"targets\": self.targets,",
            "            \"inputs\": [block._id for block in self.inputs],",
            "            \"outputs\": [block._id for block in self.outputs],",
            "            \"backend_fn\": self.fn is not None,",
            "            \"js\": self.js,",
            "            \"queue\": self.queue,",
            "            \"api_name\": self.api_name,",
            "            \"scroll_to_output\": self.scroll_to_output,",
            "            \"show_progress\": self.show_progress,",
            "            \"batch\": self.batch,",
            "            \"max_batch_size\": self.max_batch_size,",
            "            \"cancels\": self.cancels,",
            "            \"types\": {",
            "                \"generator\": self.types_generator,",
            "                \"cancel\": self.is_cancel_function,",
            "            },",
            "            \"collects_event_data\": self.collects_event_data,",
            "            \"trigger_after\": self.trigger_after,",
            "            \"trigger_only_on_success\": self.trigger_only_on_success,",
            "            \"trigger_mode\": self.trigger_mode,",
            "            \"show_api\": self.show_api,",
            "            \"zerogpu\": self.zero_gpu,",
            "            \"rendered_in\": self.rendered_in._id if self.rendered_in else None,",
            "        }",
            "",
            "",
            "def postprocess_update_dict(",
            "    block: Component | BlockContext, update_dict: dict, postprocess: bool = True",
            "):",
            "    \"\"\"",
            "    Converts a dictionary of updates into a format that can be sent to the frontend to update the component.",
            "    E.g. {\"value\": \"2\", \"visible\": True, \"invalid_arg\": \"hello\"}",
            "    Into -> {\"__type__\": \"update\", \"value\": 2.0, \"visible\": True}",
            "    Parameters:",
            "        block: The Block that is being updated with this update dictionary.",
            "        update_dict: The original update dictionary",
            "        postprocess: Whether to postprocess the \"value\" key of the update dictionary.",
            "    \"\"\"",
            "    value = update_dict.pop(\"value\", components._Keywords.NO_VALUE)",
            "    update_dict = {k: getattr(block, k) for k in update_dict if hasattr(block, k)}",
            "    if value is not components._Keywords.NO_VALUE:",
            "        if postprocess:",
            "            update_dict[\"value\"] = block.postprocess(value)",
            "            if isinstance(update_dict[\"value\"], (GradioModel, GradioRootModel)):",
            "                update_dict[\"value\"] = update_dict[\"value\"].model_dump()",
            "        else:",
            "            update_dict[\"value\"] = value",
            "    update_dict[\"__type__\"] = \"update\"",
            "    return update_dict",
            "",
            "",
            "def convert_component_dict_to_list(",
            "    outputs_ids: list[int], predictions: dict",
            ") -> list | dict:",
            "    \"\"\"",
            "    Converts a dictionary of component updates into a list of updates in the order of",
            "    the outputs_ids and including every output component. Leaves other types of dictionaries unchanged.",
            "    E.g. {\"textbox\": \"hello\", \"number\": {\"__type__\": \"generic_update\", \"value\": \"2\"}}",
            "    Into -> [\"hello\", {\"__type__\": \"generic_update\"}, {\"__type__\": \"generic_update\", \"value\": \"2\"}]",
            "    \"\"\"",
            "    keys_are_blocks = [isinstance(key, Block) for key in predictions]",
            "    if all(keys_are_blocks):",
            "        reordered_predictions = [skip() for _ in outputs_ids]",
            "        for component, value in predictions.items():",
            "            if component._id not in outputs_ids:",
            "                raise ValueError(",
            "                    f\"Returned component {component} not specified as output of function.\"",
            "                )",
            "            output_index = outputs_ids.index(component._id)",
            "            reordered_predictions[output_index] = value",
            "        predictions = utils.resolve_singleton(reordered_predictions)",
            "    elif any(keys_are_blocks):",
            "        raise ValueError(",
            "            \"Returned dictionary included some keys as Components. Either all keys must be Components to assign Component values, or return a List of values to assign output values in order.\"",
            "        )",
            "    return predictions",
            "",
            "",
            "class BlocksConfig:",
            "    def __init__(self, root_block: Blocks):",
            "        self._id: int = 0",
            "        self.root_block = root_block",
            "        self.blocks: dict[int, Component | Block] = {}",
            "        self.fns: dict[int, BlockFunction] = {}",
            "        self.fn_id: int = 0",
            "",
            "    def set_event_trigger(",
            "        self,",
            "        targets: Sequence[EventListenerMethod],",
            "        fn: Callable | None,",
            "        inputs: Component",
            "        | BlockContext",
            "        | Sequence[Component | BlockContext]",
            "        | AbstractSet[Component | BlockContext]",
            "        | None,",
            "        outputs: Component",
            "        | BlockContext",
            "        | Sequence[Component | BlockContext]",
            "        | AbstractSet[Component | BlockContext]",
            "        | None,",
            "        preprocess: bool = True,",
            "        postprocess: bool = True,",
            "        scroll_to_output: bool = False,",
            "        show_progress: Literal[\"full\", \"minimal\", \"hidden\"] = \"full\",",
            "        api_name: str | None | Literal[False] = None,",
            "        js: str | None = None,",
            "        no_target: bool = False,",
            "        queue: bool = True,",
            "        batch: bool = False,",
            "        max_batch_size: int = 4,",
            "        cancels: list[int] | None = None,",
            "        collects_event_data: bool | None = None,",
            "        trigger_after: int | None = None,",
            "        trigger_only_on_success: bool = False,",
            "        trigger_mode: Literal[\"once\", \"multiple\", \"always_last\"] | None = \"once\",",
            "        concurrency_limit: int | None | Literal[\"default\"] = \"default\",",
            "        concurrency_id: str | None = None,",
            "        show_api: bool = True,",
            "        renderable: Renderable | None = None,",
            "        is_cancel_function: bool = False,",
            "    ) -> tuple[BlockFunction, int]:",
            "        \"\"\"",
            "        Adds an event to the component's dependencies.",
            "        Parameters:",
            "            targets: a list of EventListenerMethod objects that define the event trigger",
            "            fn: the function to run when the event is triggered",
            "            inputs: the list of input components whose values will be passed to the function",
            "            outputs: the list of output components whose values will be updated by the function",
            "            preprocess: whether to run the preprocess methods of the input components before running the function",
            "            postprocess: whether to run the postprocess methods of the output components after running the function",
            "            scroll_to_output: whether to scroll to output of dependency on trigger",
            "            show_progress: how to show the progress animation while event is running: \"full\" shows a spinner which covers the output component area as well as a runtime display in the upper right corner, \"minimal\" only shows the runtime display, \"hidden\" shows no progress animation at all",
            "            api_name: defines how the endpoint appears in the API docs. Can be a string, None, or False. If set to a string, the endpoint will be exposed in the API docs with the given name. If None (default), the name of the function will be used as the API endpoint. If False, the endpoint will not be exposed in the API docs and downstream apps (including those that `gr.load` this app) will not be able to use this event.",
            "            js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components",
            "            no_target: if True, sets \"targets\" to [], used for the Blocks.load() event and .then() events",
            "            queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.",
            "            batch: whether this function takes in a batch of inputs",
            "            max_batch_size: the maximum batch size to send to the function",
            "            cancels: a list of other events to cancel when this event is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method.",
            "            collects_event_data: whether to collect event data for this event",
            "            trigger_after: if set, this event will be triggered after 'trigger_after' function index",
            "            trigger_only_on_success: if True, this event will only be triggered if the previous event was successful (only applies if `trigger_after` is set)",
            "            trigger_mode: If \"once\" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to \"multiple\", unlimited submissions are allowed while pending, and \"always_last\" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.",
            "            concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to \"default\" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `queue()`, which itself is 1 by default).",
            "            concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.",
            "            show_api: whether to show this event in the \"view API\" page of the Gradio app, or in the \".view_api()\" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps as well as the Clients to use this event. If fn is None, show_api will automatically be set to False.",
            "            is_cancel_function: whether this event cancels another running event.",
            "        Returns: dependency information, dependency index",
            "        \"\"\"",
            "        # Support for singular parameter",
            "        _targets = [",
            "            (",
            "                target.block._id if not no_target and target.block else None,",
            "                target.event_name,",
            "            )",
            "            for target in targets",
            "        ]",
            "        if isinstance(inputs, AbstractSet):",
            "            inputs_as_dict = True",
            "            inputs = sorted(inputs, key=lambda x: x._id)",
            "        else:",
            "            inputs_as_dict = False",
            "            if inputs is None:",
            "                inputs = []",
            "            elif not isinstance(inputs, Sequence):",
            "                inputs = [inputs]",
            "",
            "        if isinstance(outputs, AbstractSet):",
            "            outputs = sorted(outputs, key=lambda x: x._id)",
            "        elif outputs is None:",
            "            outputs = []",
            "        elif not isinstance(outputs, Sequence):",
            "            outputs = [outputs]",
            "",
            "        if fn is not None and not cancels:",
            "            check_function_inputs_match(fn, inputs, inputs_as_dict)",
            "",
            "        if _targets[0][1] in [\"change\", \"key_up\"] and trigger_mode is None:",
            "            trigger_mode = \"always_last\"",
            "        elif trigger_mode is None:",
            "            trigger_mode = \"once\"",
            "        elif trigger_mode not in [\"once\", \"multiple\", \"always_last\"]:",
            "            raise ValueError(",
            "                f\"Invalid value for parameter `trigger_mode`: {trigger_mode}. Please choose from: {['once', 'multiple', 'always_last']}\"",
            "            )",
            "",
            "        _, progress_index, event_data_index = (",
            "            special_args(fn) if fn else (None, None, None)",
            "        )",
            "",
            "        # If api_name is None or empty string, use the function name",
            "        if api_name is None or isinstance(api_name, str) and api_name.strip() == \"\":",
            "            if fn is not None:",
            "                if not hasattr(fn, \"__name__\"):",
            "                    if hasattr(fn, \"__class__\") and hasattr(fn.__class__, \"__name__\"):",
            "                        name = fn.__class__.__name__",
            "                    else:",
            "                        name = \"unnamed\"",
            "                else:",
            "                    name = fn.__name__",
            "                api_name = \"\".join(",
            "                    [s for s in name if s not in set(string.punctuation) - {\"-\", \"_\"}]",
            "                )",
            "            elif js is not None:",
            "                api_name = \"js_fn\"",
            "                show_api = False",
            "            else:",
            "                api_name = \"unnamed\"",
            "                show_api = False",
            "",
            "        if api_name is not False:",
            "            api_name = utils.append_unique_suffix(",
            "                api_name,",
            "                [",
            "                    fn.api_name",
            "                    for fn in self.fns.values()",
            "                    if isinstance(fn.api_name, str)",
            "                ],",
            "            )",
            "        else:",
            "            show_api = False",
            "",
            "        # The `show_api` parameter is False if: (1) the user explicitly sets it (2) the user sets `api_name` to False",
            "        # or (3) the user sets `fn` to None (there's no backend function)",
            "",
            "        if collects_event_data is None:",
            "            collects_event_data = event_data_index is not None",
            "",
            "        rendered_in = LocalContext.renderable.get()",
            "",
            "        block_fn = BlockFunction(",
            "            fn,",
            "            inputs,",
            "            outputs,",
            "            preprocess,",
            "            postprocess,",
            "            _id=self.fn_id,",
            "            inputs_as_dict=inputs_as_dict,",
            "            targets=_targets,",
            "            batch=batch,",
            "            max_batch_size=max_batch_size,",
            "            concurrency_limit=concurrency_limit,",
            "            concurrency_id=concurrency_id,",
            "            tracks_progress=progress_index is not None,",
            "            api_name=api_name,",
            "            js=js,",
            "            show_progress=show_progress,",
            "            cancels=cancels,",
            "            collects_event_data=collects_event_data,",
            "            trigger_after=trigger_after,",
            "            trigger_only_on_success=trigger_only_on_success,",
            "            trigger_mode=trigger_mode,",
            "            queue=queue,",
            "            scroll_to_output=scroll_to_output,",
            "            show_api=show_api,",
            "            renderable=renderable,",
            "            rendered_in=rendered_in,",
            "            is_cancel_function=is_cancel_function,",
            "        )",
            "",
            "        self.fns[self.fn_id] = block_fn",
            "        self.fn_id += 1",
            "        return block_fn, block_fn._id",
            "",
            "    def get_config(self, renderable: Renderable | None = None):",
            "        config = {}",
            "",
            "        rendered_ids = []",
            "",
            "        def get_layout(block: Block):",
            "            rendered_ids.append(block._id)",
            "            if not isinstance(block, BlockContext):",
            "                return {\"id\": block._id}",
            "            children_layout = []",
            "            for child in block.children:",
            "                children_layout.append(get_layout(child))",
            "            return {\"id\": block._id, \"children\": children_layout}",
            "",
            "        if renderable:",
            "            root_block = self.blocks[renderable.container_id]",
            "        else:",
            "            root_block = self.root_block",
            "        config[\"layout\"] = get_layout(root_block)",
            "",
            "        config[\"components\"] = []",
            "        for _id, block in self.blocks.items():",
            "            if renderable:",
            "                if _id not in rendered_ids:",
            "                    continue",
            "                if block.key:",
            "                    block.key = f\"{renderable._id}-{block.key}\"",
            "            props = block.get_config() if hasattr(block, \"get_config\") else {}",
            "            block_config = {",
            "                \"id\": _id,",
            "                \"type\": block.get_block_name(),",
            "                \"props\": utils.delete_none(props),",
            "                \"skip_api\": block.skip_api,",
            "                \"component_class_id\": getattr(block, \"component_class_id\", None),",
            "                \"key\": block.key,",
            "            }",
            "            if renderable:",
            "                block_config[\"renderable\"] = renderable._id",
            "            if not block.skip_api:",
            "                block_config[\"api_info\"] = block.api_info()  # type: ignore",
            "                # .example_inputs() has been renamed .example_payload() but",
            "                # we use the old name for backwards compatibility with custom components",
            "                # created on Gradio 4.20.0 or earlier",
            "                block_config[\"example_inputs\"] = block.example_inputs()  # type: ignore",
            "            config[\"components\"].append(block_config)",
            "",
            "        dependencies = []",
            "        for fn in self.fns.values():",
            "            if renderable is None or fn.rendered_in == renderable:",
            "                dependencies.append(fn.get_config())",
            "        config[\"dependencies\"] = dependencies",
            "        return config",
            "",
            "    def __copy__(self):",
            "        new = BlocksConfig(self.root_block)",
            "        new.blocks = copy.copy(self.blocks)",
            "        new.fns = copy.copy(self.fns)",
            "        new.fn_id = self.fn_id",
            "        return new",
            "",
            "",
            "@document(\"launch\", \"queue\", \"integrate\", \"load\", \"unload\")",
            "class Blocks(BlockContext, BlocksEvents, metaclass=BlocksMeta):",
            "    \"\"\"",
            "    Blocks is Gradio's low-level API that allows you to create more custom web",
            "    applications and demos than Interfaces (yet still entirely in Python).",
            "",
            "",
            "    Compared to the Interface class, Blocks offers more flexibility and control over:",
            "    (1) the layout of components (2) the events that",
            "    trigger the execution of functions (3) data flows (e.g. inputs can trigger outputs,",
            "    which can trigger the next level of outputs). Blocks also offers ways to group",
            "    together related demos such as with tabs.",
            "",
            "",
            "    The basic usage of Blocks is as follows: create a Blocks object, then use it as a",
            "    context (with the \"with\" statement), and then define layouts, components, or events",
            "    within the Blocks context. Finally, call the launch() method to launch the demo.",
            "",
            "    Example:",
            "        import gradio as gr",
            "        def update(name):",
            "            return f\"Welcome to Gradio, {name}!\"",
            "",
            "        with gr.Blocks() as demo:",
            "            gr.Markdown(\"Start typing below and then click **Run** to see the output.\")",
            "            with gr.Row():",
            "                inp = gr.Textbox(placeholder=\"What is your name?\")",
            "                out = gr.Textbox()",
            "            btn = gr.Button(\"Run\")",
            "            btn.click(fn=update, inputs=inp, outputs=out)",
            "",
            "        demo.launch()",
            "    Demos: blocks_hello, blocks_flipper, blocks_kinematics",
            "    Guides: blocks-and-event-listeners, controlling-layout, state-in-blocks, custom-CSS-and-JS, using-blocks-like-functions",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        theme: Theme | str | None = None,",
            "        analytics_enabled: bool | None = None,",
            "        mode: str = \"blocks\",",
            "        title: str = \"Gradio\",",
            "        css: str | None = None,",
            "        js: str | None = None,",
            "        head: str | None = None,",
            "        fill_height: bool = False,",
            "        fill_width: bool = False,",
            "        delete_cache: tuple[int, int] | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            theme: A Theme object or a string representing a theme. If a string, will look for a built-in theme with that name (e.g. \"soft\" or \"default\"), or will attempt to load a theme from the Hugging Face Hub (e.g. \"gradio/monochrome\"). If None, will use the Default theme.",
            "            analytics_enabled: Whether to allow basic telemetry. If None, will use GRADIO_ANALYTICS_ENABLED environment variable or default to True.",
            "            mode: A human-friendly name for the kind of Blocks or Interface being created. Used internally for analytics.",
            "            title: The tab title to display when this is opened in a browser window.",
            "            css: Custom css as a string or path to a css file. This css will be included in the demo webpage.",
            "            js: Custom js as a string or path to a js file. The custom js should be in the form of a single js function. This function will automatically be executed when the page loads. For more flexibility, use the head parameter to insert js inside <script> tags.",
            "            head: Custom html to insert into the head of the demo webpage. This can be used to add custom meta tags, multiple scripts, stylesheets, etc. to the page.",
            "            fill_height: Whether to vertically expand top-level child components to the height of the window. If True, expansion occurs when the scale value of the child components >= 1.",
            "            fill_width: Whether to horizontally expand to fill container fully. If False, centers and constrains app to a maximum width. Only applies if this is the outermost `Blocks` in your Gradio app.",
            "            delete_cache: A tuple corresponding [frequency, age] both expressed in number of seconds. Every `frequency` seconds, the temporary files created by this Blocks instance will be deleted if more than `age` seconds have passed since the file was created. For example, setting this to (86400, 86400) will delete temporary files every day. The cache will be deleted entirely when the server restarts. If None, no cache deletion will occur.",
            "        \"\"\"",
            "        self.limiter = None",
            "        if theme is None:",
            "            theme = DefaultTheme()",
            "        elif isinstance(theme, str):",
            "            if theme.lower() in BUILT_IN_THEMES:",
            "                theme = BUILT_IN_THEMES[theme.lower()]",
            "            else:",
            "                try:",
            "                    theme = Theme.from_hub(theme)",
            "                except Exception as e:",
            "                    warnings.warn(f\"Cannot load {theme}. Caught Exception: {str(e)}\")",
            "                    theme = DefaultTheme()",
            "        if not isinstance(theme, Theme):",
            "            warnings.warn(\"Theme should be a class loaded from gradio.themes\")",
            "            theme = DefaultTheme()",
            "        self.theme: Theme = theme",
            "        self.theme_css = theme._get_theme_css()",
            "        self.stylesheets = theme._stylesheets",
            "        theme_hasher = hashlib.sha256()",
            "        theme_hasher.update(self.theme_css.encode(\"utf-8\"))",
            "        self.theme_hash = theme_hasher.hexdigest()",
            "",
            "        self.encrypt = False",
            "        self.share = False",
            "        self.enable_queue = True",
            "        self.max_threads = 40",
            "        self.pending_streams = defaultdict(dict)",
            "        self.pending_diff_streams = defaultdict(dict)",
            "        self.show_error = True",
            "        self.head = head",
            "        self.fill_height = fill_height",
            "        self.fill_width = fill_width",
            "        self.delete_cache = delete_cache",
            "        if css is not None and os.path.exists(css):",
            "            with open(css, encoding=\"utf-8\") as css_file:",
            "                self.css = css_file.read()",
            "        else:",
            "            self.css = css",
            "        if js is not None and os.path.exists(js):",
            "            with open(js, encoding=\"utf-8\") as js_file:",
            "                self.js = js_file.read()",
            "        else:",
            "            self.js = js",
            "        self.renderables: list[Renderable] = []",
            "        self.state_holder: StateHolder",
            "",
            "        # For analytics_enabled and allow_flagging: (1) first check for",
            "        # parameter, (2) check for env variable, (3) default to True/\"manual\"",
            "        self.analytics_enabled = (",
            "            analytics_enabled",
            "            if analytics_enabled is not None",
            "            else analytics.analytics_enabled()",
            "        )",
            "        if self.analytics_enabled:",
            "            if not wasm_utils.IS_WASM:",
            "                t = threading.Thread(target=analytics.version_check)",
            "                t.start()",
            "        else:",
            "            os.environ[\"HF_HUB_DISABLE_TELEMETRY\"] = \"True\"",
            "",
            "        self.default_config = BlocksConfig(self)",
            "        super().__init__(render=False, **kwargs)",
            "",
            "        self.mode = mode",
            "        self.is_running = False",
            "        self.local_url = None",
            "        self.share_url = None",
            "        self.width = None",
            "        self.height = None",
            "        self.api_open = utils.get_space() is None",
            "",
            "        self.space_id = utils.get_space()",
            "        self.favicon_path = None",
            "        self.auth = None",
            "        self.dev_mode = bool(os.getenv(\"GRADIO_WATCH_DIRS\", \"\"))",
            "        self.app_id = random.getrandbits(64)",
            "        self.upload_file_set = set()",
            "        self.temp_file_sets = [self.upload_file_set]",
            "        self.title = title",
            "        self.show_api = not wasm_utils.IS_WASM",
            "",
            "        # Only used when an Interface is loaded from a config",
            "        self.predict = None",
            "        self.input_components = None",
            "        self.output_components = None",
            "        self.__name__ = None  # type: ignore",
            "        self.api_mode = None",
            "",
            "        self.progress_tracking = None",
            "        self.ssl_verify = True",
            "        self.allowed_paths = []",
            "        self.blocked_paths = []",
            "        self.root_path = os.environ.get(\"GRADIO_ROOT_PATH\", \"\")",
            "        self.proxy_urls = set()",
            "",
            "        if self.analytics_enabled:",
            "            is_custom_theme = not any(",
            "                self.theme.to_dict() == built_in_theme.to_dict()",
            "                for built_in_theme in BUILT_IN_THEMES.values()",
            "            )",
            "            data = {",
            "                \"mode\": self.mode,",
            "                \"custom_css\": self.css is not None,",
            "                \"theme\": self.theme.name,",
            "                \"is_custom_theme\": is_custom_theme,",
            "                \"version\": get_package_version(),",
            "            }",
            "            analytics.initiated_analytics(data)",
            "",
            "        self.queue()",
            "",
            "    @property",
            "    def blocks(self) -> dict[int, Component | Block]:",
            "        return self.default_config.blocks",
            "",
            "    @blocks.setter",
            "    def blocks(self, value: dict[int, Component | Block]):",
            "        self.default_config.blocks = value",
            "",
            "    @property",
            "    def fns(self) -> dict[int, BlockFunction]:",
            "        return self.default_config.fns",
            "",
            "    def get_component(self, id: int) -> Component | BlockContext:",
            "        comp = self.blocks[id]",
            "        if not isinstance(comp, (components.Component, BlockContext)):",
            "            raise TypeError(f\"Block with id {id} is not a Component or BlockContext\")",
            "        return comp",
            "",
            "    @property",
            "    def _is_running_in_reload_thread(self):",
            "        if wasm_utils.IS_WASM:",
            "            # Wasm (Pyodide) doesn't support threading,",
            "            # so the return value is always False.",
            "            return False",
            "",
            "        from gradio.cli.commands.reload import reload_thread",
            "",
            "        return getattr(reload_thread, \"running_reload\", False)",
            "",
            "    @classmethod",
            "    def from_config(",
            "        cls,",
            "        config: BlocksConfigDict,",
            "        fns: list[Callable],",
            "        proxy_url: str,",
            "    ) -> Blocks:",
            "        \"\"\"",
            "        Factory method that creates a Blocks from a config and list of functions. Used",
            "        internally by the gradio.external.load() method.",
            "",
            "        Parameters:",
            "        config: a dictionary containing the configuration of the Blocks.",
            "        fns: a list of functions that are used in the Blocks. Must be in the same order as the dependencies in the config.",
            "        proxy_url: an external url to use as a root URL when serving files for components in the Blocks.",
            "        \"\"\"",
            "        config = copy.deepcopy(config)",
            "        components_config = config[\"components\"]",
            "        theme = config.get(\"theme\", \"default\")",
            "        original_mapping: dict[int, Block] = {}",
            "        proxy_urls = {proxy_url}",
            "",
            "        def get_block_instance(id: int) -> Block:",
            "            for block_config in components_config:",
            "                if block_config[\"id\"] == id:",
            "                    break",
            "            else:",
            "                raise ValueError(f\"Cannot find block with id {id}\")",
            "            cls = component_or_layout_class(block_config[\"props\"][\"name\"])",
            "",
            "            # If a Gradio app B is loaded into a Gradio app A, and B itself loads a",
            "            # Gradio app C, then the proxy_urls of the components in A need to be the",
            "            # URL of C, not B. The else clause below handles this case.",
            "            if block_config[\"props\"].get(\"proxy_url\") is None:",
            "                block_config[\"props\"][\"proxy_url\"] = f\"{proxy_url}/\"",
            "            postprocessed_value = block_config[\"props\"].pop(\"value\", None)",
            "",
            "            constructor_args = cls.recover_kwargs(block_config[\"props\"])",
            "            block = cls(**constructor_args)",
            "            if postprocessed_value is not None:",
            "                block.value = postprocessed_value  # type: ignore",
            "",
            "            block_proxy_url = block_config[\"props\"][\"proxy_url\"]",
            "            block.proxy_url = block_proxy_url",
            "            proxy_urls.add(block_proxy_url)",
            "            if (",
            "                _selectable := block_config[\"props\"].pop(\"_selectable\", None)",
            "            ) is not None:",
            "                block._selectable = _selectable  # type: ignore",
            "",
            "            return block",
            "",
            "        def iterate_over_children(children_list):",
            "            for child_config in children_list:",
            "                id = child_config[\"id\"]",
            "                block = get_block_instance(id)",
            "",
            "                original_mapping[id] = block",
            "",
            "                children = child_config.get(\"children\")",
            "                if children is not None:",
            "                    if not isinstance(block, BlockContext):",
            "                        raise ValueError(",
            "                            f\"Invalid config, Block with id {id} has children but is not a BlockContext.\"",
            "                        )",
            "                    with block:",
            "                        iterate_over_children(children)",
            "",
            "        derived_fields = [\"types\"]",
            "",
            "        with Blocks(theme=theme) as blocks:",
            "            # ID 0 should be the root Blocks component",
            "            original_mapping[0] = root_block = Context.root_block or blocks",
            "",
            "            if \"layout\" in config:",
            "                iterate_over_children(config[\"layout\"][\"children\"])  #",
            "",
            "            first_dependency = None",
            "",
            "            # add the event triggers",
            "            if \"dependencies\" not in config:",
            "                raise ValueError(",
            "                    \"This config is missing the 'dependencies' field and cannot be loaded.\"",
            "                )",
            "            for dependency, fn in zip(config[\"dependencies\"], fns):",
            "                # We used to add a \"fake_event\" to the config to cache examples",
            "                # without removing it. This was causing bugs in calling gr.load",
            "                # We fixed the issue by removing \"fake_event\" from the config in examples.py",
            "                # but we still need to skip these events when loading the config to support",
            "                # older demos",
            "                if \"trigger\" in dependency and dependency[\"trigger\"] == \"fake_event\":",
            "                    continue",
            "                for field in derived_fields:",
            "                    dependency.pop(field, None)",
            "",
            "                # older versions had a separate trigger field, but now it is part of the",
            "                # targets field",
            "                _targets = dependency.pop(\"targets\")",
            "                trigger = dependency.pop(\"trigger\", None)",
            "                is_then_event = False",
            "",
            "                # This assumes that you cannot combine multiple .then() events in a single",
            "                # gr.on() event, which is true for now. If this changes, we will need to",
            "                # update this code.",
            "                if not isinstance(_targets[0], int) and _targets[0][1] in [",
            "                    \"then\",",
            "                    \"success\",",
            "                ]:",
            "                    if len(_targets) != 1:",
            "                        raise ValueError(",
            "                            \"This logic assumes that .then() events are not combined with other events in a single gr.on() event\"",
            "                        )",
            "                    is_then_event = True",
            "",
            "                dependency.pop(\"backend_fn\")",
            "                dependency.pop(\"documentation\", None)",
            "                dependency[\"inputs\"] = [",
            "                    original_mapping[i] for i in dependency[\"inputs\"]",
            "                ]",
            "                dependency[\"outputs\"] = [",
            "                    original_mapping[o] for o in dependency[\"outputs\"]",
            "                ]",
            "                dependency.pop(\"status_tracker\", None)",
            "                dependency.pop(\"zerogpu\", None)",
            "                dependency.pop(\"id\", None)",
            "                dependency.pop(\"rendered_in\", None)",
            "                dependency[\"preprocess\"] = False",
            "                dependency[\"postprocess\"] = False",
            "                if is_then_event:",
            "                    targets = [EventListenerMethod(None, \"then\")]",
            "                    dependency[\"trigger_after\"] = dependency.pop(\"trigger_after\")",
            "                    dependency[\"trigger_only_on_success\"] = dependency.pop(",
            "                        \"trigger_only_on_success\"",
            "                    )",
            "                    dependency[\"no_target\"] = True",
            "                else:",
            "                    targets = [",
            "                        getattr(",
            "                            original_mapping[",
            "                                target if isinstance(target, int) else target[0]",
            "                            ],",
            "                            trigger if isinstance(target, int) else target[1],",
            "                        )",
            "                        for target in _targets",
            "                    ]",
            "                    targets = [",
            "                        EventListenerMethod(",
            "                            t.__self__ if t.has_trigger else None,",
            "                            t.event_name,  # type: ignore",
            "                        )",
            "                        for t in targets",
            "                    ]",
            "                dependency = root_block.default_config.set_event_trigger(",
            "                    targets=targets, fn=fn, **dependency",
            "                )[0]",
            "                if first_dependency is None:",
            "                    first_dependency = dependency",
            "",
            "            # Allows some use of Interface-specific methods with loaded Spaces",
            "            if first_dependency and get_blocks_context():",
            "                blocks.predict = [fns[0]]",
            "                blocks.input_components = first_dependency.inputs",
            "                blocks.output_components = first_dependency.outputs",
            "                blocks.__name__ = \"Interface\"",
            "                blocks.api_mode = True",
            "        blocks.proxy_urls = proxy_urls",
            "        return blocks",
            "",
            "    def __str__(self):",
            "        return self.__repr__()",
            "",
            "    def __repr__(self):",
            "        num_backend_fns = len([d for d in self.fns.values() if d.fn])",
            "        repr = f\"Gradio Blocks instance: {num_backend_fns} backend functions\"",
            "        repr += f\"\\n{'-' * len(repr)}\"",
            "        for d, dependency in self.fns.items():",
            "            if dependency.fn:",
            "                repr += f\"\\nfn_index={d}\"",
            "                repr += \"\\n inputs:\"",
            "                for block in dependency.inputs:",
            "                    block = self.blocks[block._id]",
            "                    repr += f\"\\n |-{block}\"",
            "                repr += \"\\n outputs:\"",
            "                for block in dependency.outputs:",
            "                    block = self.blocks[block._id]",
            "                    repr += f\"\\n |-{block}\"",
            "        return repr",
            "",
            "    @property",
            "    def expects_oauth(self):",
            "        \"\"\"Return whether the app expects user to authenticate via OAuth.\"\"\"",
            "        return any(",
            "            isinstance(block, (components.LoginButton, components.LogoutButton))",
            "            for block in self.blocks.values()",
            "        )",
            "",
            "    def unload(self, fn: Callable[..., Any]) -> None:",
            "        \"\"\"This listener is triggered when the user closes or refreshes the tab, ending the user session.",
            "        It is useful for cleaning up resources when the app is closed.",
            "        Parameters:",
            "            fn: Callable function to run to clear resources. The function should not take any arguments and the output is not used.",
            "        Example:",
            "            import gradio as gr",
            "            with gr.Blocks() as demo:",
            "                gr.Markdown(\"# When you close the tab, hello will be printed to the console\")",
            "                demo.unload(lambda: print(\"hello\"))",
            "            demo.launch()",
            "        \"\"\"",
            "        self.default_config.set_event_trigger(",
            "            targets=[EventListenerMethod(None, \"unload\")],",
            "            fn=fn,",
            "            inputs=None,",
            "            outputs=None,",
            "            preprocess=False,",
            "            postprocess=False,",
            "            show_progress=\"hidden\",",
            "            api_name=None,",
            "            js=None,",
            "            no_target=True,",
            "            batch=False,",
            "            max_batch_size=4,",
            "            cancels=None,",
            "            collects_event_data=None,",
            "            trigger_after=None,",
            "            trigger_only_on_success=False,",
            "            trigger_mode=\"once\",",
            "            concurrency_limit=\"default\",",
            "            concurrency_id=None,",
            "            show_api=False,",
            "        )",
            "",
            "    def render(self):",
            "        root_context = get_blocks_context()",
            "        if root_context is not None and Context.root_block is not None:",
            "            if self._id in root_context.blocks:",
            "                raise DuplicateBlockError(",
            "                    f\"A block with id: {self._id} has already been rendered in the current Blocks.\"",
            "                )",
            "            overlapping_ids = set(root_context.blocks).intersection(self.blocks)",
            "            for id in overlapping_ids:",
            "                # State components are allowed to be reused between Blocks",
            "                if not isinstance(self.blocks[id], components.State):",
            "                    raise DuplicateBlockError(",
            "                        \"At least one block in this Blocks has already been rendered.\"",
            "                    )",
            "",
            "            root_context.blocks.update(self.blocks)",
            "            dependency_offset = max(root_context.fns.keys(), default=-1) + 1",
            "            existing_api_names = [",
            "                dep.api_name",
            "                for dep in root_context.fns.values()",
            "                if isinstance(dep.api_name, str)",
            "            ]",
            "            for dependency in self.fns.values():",
            "                dependency._id += dependency_offset",
            "                api_name = dependency.api_name",
            "                if isinstance(api_name, str):",
            "                    api_name_ = utils.append_unique_suffix(",
            "                        api_name,",
            "                        existing_api_names,",
            "                    )",
            "                    if api_name != api_name_:",
            "                        dependency.api_name = api_name_",
            "                dependency.cancels = [c + dependency_offset for c in dependency.cancels]",
            "                if dependency.trigger_after is not None:",
            "                    dependency.trigger_after += dependency_offset",
            "                # Recreate the cancel function so that it has the latest",
            "                # dependency fn indices. This is necessary to properly cancel",
            "                # events in the backend",
            "                if dependency.cancels:",
            "                    updated_cancels = [",
            "                        root_context.fns[i].get_config() for i in dependency.cancels",
            "                    ]",
            "                    dependency.cancels = get_cancelled_fn_indices(updated_cancels)",
            "                root_context.fns[dependency._id] = dependency",
            "            root_context.fn_id = max(root_context.fns.keys(), default=-1) + 1",
            "            Context.root_block.temp_file_sets.extend(self.temp_file_sets)",
            "            Context.root_block.proxy_urls.update(self.proxy_urls)",
            "",
            "        render_context = get_render_context()",
            "        if render_context is not None:",
            "            render_context.children.extend(self.children)",
            "        return self",
            "",
            "    def is_callable(self, fn_index: int = 0) -> bool:",
            "        \"\"\"Checks if a particular Blocks function is callable (i.e. not stateful or a generator).\"\"\"",
            "        block_fn = self.fns[fn_index]",
            "        dependency = self.fns[fn_index]",
            "",
            "        if inspect.isasyncgenfunction(block_fn.fn):",
            "            return False",
            "        if inspect.isgeneratorfunction(block_fn.fn):",
            "            return False",
            "        if any(block.stateful for block in dependency.inputs):",
            "            return False",
            "        if any(block.stateful for block in dependency.outputs):",
            "            return False",
            "",
            "        return True",
            "",
            "    def __call__(self, *inputs, fn_index: int = 0, api_name: str | None = None):",
            "        \"\"\"",
            "        Allows Blocks objects to be called as functions. Supply the parameters to the",
            "        function as positional arguments. To choose which function to call, use the",
            "        fn_index parameter, which must be a keyword argument.",
            "",
            "        Parameters:",
            "        *inputs: the parameters to pass to the function",
            "        fn_index: the index of the function to call (defaults to 0, which for Interfaces, is the default prediction function)",
            "        api_name: The api_name of the dependency to call. Will take precedence over fn_index.",
            "        \"\"\"",
            "        if api_name is not None:",
            "            inferred_fn_index = next(",
            "                (i for i, d in self.fns.items() if d.api_name == api_name),",
            "                None,",
            "            )",
            "            if inferred_fn_index is None:",
            "                raise InvalidApiNameError(",
            "                    f\"Cannot find a function with api_name {api_name}\"",
            "                )",
            "            fn_index = inferred_fn_index",
            "        if not (self.is_callable(fn_index)):",
            "            raise ValueError(",
            "                \"This function is not callable because it is either stateful or is a generator. Please use the .launch() method instead to create an interactive user interface.\"",
            "            )",
            "",
            "        inputs = list(inputs)",
            "        processed_inputs = self.serialize_data(fn_index, inputs)",
            "        fn = self.fns[fn_index]",
            "        if fn.batch:",
            "            processed_inputs = [[inp] for inp in processed_inputs]",
            "",
            "        outputs = client_utils.synchronize_async(",
            "            self.process_api,",
            "            block_fn=fn,",
            "            inputs=processed_inputs,",
            "            request=None,",
            "            state={},",
            "            explicit_call=True,",
            "        )",
            "        outputs = outputs[\"data\"]",
            "",
            "        if fn.batch:",
            "            outputs = [out[0] for out in outputs]",
            "",
            "        outputs = self.deserialize_data(fn_index, outputs)",
            "        processed_outputs = utils.resolve_singleton(outputs)",
            "",
            "        return processed_outputs",
            "",
            "    async def call_function(",
            "        self,",
            "        block_fn: BlockFunction | int,",
            "        processed_input: list[Any],",
            "        iterator: AsyncIterator[Any] | None = None,",
            "        requests: routes.Request | list[routes.Request] | None = None,",
            "        event_id: str | None = None,",
            "        event_data: EventData | None = None,",
            "        in_event_listener: bool = False,",
            "        state: SessionState | None = None,",
            "    ):",
            "        \"\"\"",
            "        Calls function with given index and preprocessed input, and measures process time.",
            "        Parameters:",
            "            fn_index: index of function to call",
            "            processed_input: preprocessed input to pass to function",
            "            iterator: iterator to use if function is a generator",
            "            requests: requests to pass to function",
            "            event_id: id of event in queue",
            "            event_data: data associated with event trigger",
            "        \"\"\"",
            "        if isinstance(block_fn, int):",
            "            block_fn = self.fns[block_fn]",
            "        if not block_fn.fn:",
            "            raise IndexError(\"function has no backend method.\")",
            "        is_generating = False",
            "        request = requests[0] if isinstance(requests, list) else requests",
            "        start = time.time()",
            "",
            "        fn = utils.get_function_with_locals(",
            "            fn=block_fn.fn,",
            "            blocks=self,",
            "            event_id=event_id,",
            "            in_event_listener=in_event_listener,",
            "            request=request,",
            "            state=state,",
            "        )",
            "",
            "        if iterator is None:  # If not a generator function that has already run",
            "            if block_fn.inputs_as_dict:",
            "                processed_input = [dict(zip(block_fn.inputs, processed_input))]",
            "",
            "            processed_input, progress_index, _ = special_args(",
            "                block_fn.fn, processed_input, request, event_data",
            "            )",
            "            progress_tracker = (",
            "                processed_input[progress_index] if progress_index is not None else None",
            "            )",
            "",
            "            if progress_tracker is not None and progress_index is not None:",
            "                progress_tracker, fn = create_tracker(fn, progress_tracker.track_tqdm)",
            "                processed_input[progress_index] = progress_tracker",
            "",
            "            if inspect.iscoroutinefunction(fn):",
            "                prediction = await fn(*processed_input)",
            "            else:",
            "                prediction = await anyio.to_thread.run_sync(  # type: ignore",
            "                    fn, *processed_input, limiter=self.limiter",
            "                )",
            "        else:",
            "            prediction = None",
            "",
            "        if inspect.isgeneratorfunction(fn) or inspect.isasyncgenfunction(fn):",
            "            try:",
            "                if iterator is None:",
            "                    iterator = cast(AsyncIterator[Any], prediction)",
            "                if inspect.isgenerator(iterator):",
            "                    iterator = utils.SyncToAsyncIterator(iterator, self.limiter)",
            "                prediction = await utils.async_iteration(iterator)",
            "                is_generating = True",
            "            except StopAsyncIteration:",
            "                n_outputs = len(block_fn.outputs)",
            "                prediction = (",
            "                    components._Keywords.FINISHED_ITERATING",
            "                    if n_outputs == 1",
            "                    else (components._Keywords.FINISHED_ITERATING,) * n_outputs",
            "                )",
            "                iterator = None",
            "",
            "        duration = time.time() - start",
            "",
            "        return {",
            "            \"prediction\": prediction,",
            "            \"duration\": duration,",
            "            \"is_generating\": is_generating,",
            "            \"iterator\": iterator,",
            "        }",
            "",
            "    def serialize_data(self, fn_index: int, inputs: list[Any]) -> list[Any]:",
            "        dependency = self.fns[fn_index]",
            "        processed_input = []",
            "",
            "        def format_file(s):",
            "            return FileData(path=s).model_dump()",
            "",
            "        for i, block in enumerate(dependency.inputs):",
            "            if not isinstance(block, components.Component):",
            "                raise InvalidComponentError(",
            "                    f\"{block.__class__} Component not a valid input component.\"",
            "                )",
            "            api_info = block.api_info()",
            "            if client_utils.value_is_file(api_info):",
            "                serialized_input = client_utils.traverse(",
            "                    inputs[i],",
            "                    format_file,",
            "                    lambda s: client_utils.is_filepath(s)",
            "                    or client_utils.is_http_url_like(s),",
            "                )",
            "            else:",
            "                serialized_input = inputs[i]",
            "            processed_input.append(serialized_input)",
            "",
            "        return processed_input",
            "",
            "    def deserialize_data(self, fn_index: int, outputs: list[Any]) -> list[Any]:",
            "        dependency = self.fns[fn_index]",
            "        predictions = []",
            "",
            "        for o, block in enumerate(dependency.outputs):",
            "            if not isinstance(block, components.Component):",
            "                raise InvalidComponentError(",
            "                    f\"{block.__class__} Component not a valid output component.\"",
            "                )",
            "",
            "            deserialized = client_utils.traverse(",
            "                outputs[o], lambda s: s[\"path\"], client_utils.is_file_obj",
            "            )",
            "            predictions.append(deserialized)",
            "",
            "        return predictions",
            "",
            "    def validate_inputs(self, block_fn: BlockFunction, inputs: list[Any]):",
            "        dep_inputs = block_fn.inputs",
            "",
            "        # This handles incorrect inputs when args are changed by a JS function",
            "        # Only check not enough args case, ignore extra arguments (for now)",
            "        # TODO: make this stricter?",
            "        if len(inputs) < len(dep_inputs):",
            "            name = (",
            "                f\" ({block_fn.name})\"",
            "                if block_fn.name and block_fn.name != \"<lambda>\"",
            "                else \"\"",
            "            )",
            "",
            "            wanted_args = []",
            "            received_args = []",
            "            for block in dep_inputs:",
            "                wanted_args.append(str(block))",
            "            for inp in inputs:",
            "                v = f'\"{inp}\"' if isinstance(inp, str) else str(inp)",
            "                received_args.append(v)",
            "",
            "            wanted = \", \".join(wanted_args)",
            "            received = \", \".join(received_args)",
            "",
            "            # JS func didn't pass enough arguments",
            "            raise ValueError(",
            "                f\"\"\"An event handler{name} didn't receive enough input values (needed: {len(dep_inputs)}, got: {len(inputs)}).",
            "Check if the event handler calls a Javascript function, and make sure its return value is correct.",
            "Wanted inputs:",
            "    [{wanted}]",
            "Received inputs:",
            "    [{received}]\"\"\"",
            "            )",
            "",
            "    async def preprocess_data(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        inputs: list[Any],",
            "        state: SessionState | None,",
            "        explicit_call: bool = False,",
            "    ):",
            "        state = state or SessionState(self)",
            "",
            "        self.validate_inputs(block_fn, inputs)",
            "",
            "        if block_fn.preprocess:",
            "            processed_input = []",
            "            for i, block in enumerate(block_fn.inputs):",
            "                if not isinstance(block, components.Component):",
            "                    raise InvalidComponentError(",
            "                        f\"{block.__class__} Component not a valid input component.\"",
            "                    )",
            "                if block.stateful:",
            "                    processed_input.append(state[block._id])",
            "                else:",
            "                    if block._id in state:",
            "                        block = state[block._id]",
            "                    inputs_cached = await processing_utils.async_move_files_to_cache(",
            "                        inputs[i],",
            "                        block,",
            "                        check_in_upload_folder=not explicit_call,",
            "                    )",
            "                    if getattr(block, \"data_model\", None) and inputs_cached is not None:",
            "                        if issubclass(block.data_model, GradioModel):  # type: ignore",
            "                            inputs_cached = block.data_model(**inputs_cached)  # type: ignore",
            "                        elif issubclass(block.data_model, GradioRootModel):  # type: ignore",
            "                            inputs_cached = block.data_model(root=inputs_cached)  # type: ignore",
            "                    processed_input.append(block.preprocess(inputs_cached))",
            "        else:",
            "            processed_input = inputs",
            "        return processed_input",
            "",
            "    def validate_outputs(self, block_fn: BlockFunction, predictions: Any | list[Any]):",
            "        dep_outputs = block_fn.outputs",
            "",
            "        if not isinstance(predictions, (list, tuple)):",
            "            predictions = [predictions]",
            "",
            "        if len(predictions) < len(dep_outputs):",
            "            name = (",
            "                f\" ({block_fn.name})\"",
            "                if block_fn.name and block_fn.name != \"<lambda>\"",
            "                else \"\"",
            "            )",
            "",
            "            wanted_args = []",
            "            received_args = []",
            "            for block in dep_outputs:",
            "                wanted_args.append(str(block))",
            "            for pred in predictions:",
            "                v = f'\"{pred}\"' if isinstance(pred, str) else str(pred)",
            "                received_args.append(v)",
            "",
            "            wanted = \", \".join(wanted_args)",
            "            received = \", \".join(received_args)",
            "",
            "            raise ValueError(",
            "                f\"\"\"An event handler{name} didn't receive enough output values (needed: {len(dep_outputs)}, received: {len(predictions)}).",
            "Wanted outputs:",
            "    [{wanted}]",
            "Received outputs:",
            "    [{received}]\"\"\"",
            "            )",
            "",
            "    async def postprocess_data(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        predictions: list | dict,",
            "        state: SessionState | None,",
            "    ) -> list[Any]:",
            "        state = state or SessionState(self)",
            "",
            "        if isinstance(predictions, dict) and len(predictions) > 0:",
            "            predictions = convert_component_dict_to_list(",
            "                [block._id for block in block_fn.outputs], predictions",
            "            )",
            "",
            "        if len(block_fn.outputs) == 1 and not block_fn.batch:",
            "            predictions = [",
            "                predictions,",
            "            ]",
            "",
            "        self.validate_outputs(block_fn, predictions)  # type: ignore",
            "",
            "        output = []",
            "        for i, block in enumerate(block_fn.outputs):",
            "            try:",
            "                if predictions[i] is components._Keywords.FINISHED_ITERATING:",
            "                    output.append(None)",
            "                    continue",
            "            except (IndexError, KeyError) as err:",
            "                raise ValueError(",
            "                    \"Number of output components does not match number \"",
            "                    f\"of values returned from from function {block_fn.name}\"",
            "                ) from err",
            "",
            "            if block.stateful:",
            "                if not utils.is_prop_update(predictions[i]):",
            "                    state[block._id] = predictions[i]",
            "                output.append(None)",
            "            else:",
            "                prediction_value = predictions[i]",
            "                if utils.is_prop_update(",
            "                    prediction_value",
            "                ):  # if update is passed directly (deprecated), remove Nones",
            "                    prediction_value = utils.delete_none(",
            "                        prediction_value, skip_value=True",
            "                    )",
            "",
            "                if isinstance(prediction_value, Block):",
            "                    prediction_value = prediction_value.constructor_args.copy()",
            "                    prediction_value[\"__type__\"] = \"update\"",
            "                if utils.is_prop_update(prediction_value):",
            "                    kwargs = state[block._id].constructor_args.copy()",
            "                    kwargs.update(prediction_value)",
            "                    kwargs.pop(\"value\", None)",
            "                    kwargs.pop(\"__type__\")",
            "                    kwargs[\"render\"] = False",
            "",
            "                    state[block._id] = block.__class__(**kwargs)",
            "",
            "                    prediction_value = postprocess_update_dict(",
            "                        block=state[block._id],",
            "                        update_dict=prediction_value,",
            "                        postprocess=block_fn.postprocess,",
            "                    )",
            "                elif block_fn.postprocess:",
            "                    if not isinstance(block, components.Component):",
            "                        raise InvalidComponentError(",
            "                            f\"{block.__class__} Component not a valid output component.\"",
            "                        )",
            "                    if block._id in state:",
            "                        block = state[block._id]",
            "                    prediction_value = block.postprocess(prediction_value)",
            "",
            "                outputs_cached = await processing_utils.async_move_files_to_cache(",
            "                    prediction_value,",
            "                    block,",
            "                    postprocess=True,",
            "                )",
            "                output.append(outputs_cached)",
            "",
            "        return output",
            "",
            "    async def handle_streaming_outputs(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        data: list,",
            "        session_hash: str | None,",
            "        run: int | None,",
            "        root_path: str | None = None,",
            "    ) -> list:",
            "        if session_hash is None or run is None:",
            "            return data",
            "        if run not in self.pending_streams[session_hash]:",
            "            self.pending_streams[session_hash][run] = {}",
            "        stream_run = self.pending_streams[session_hash][run]",
            "",
            "        for i, block in enumerate(block_fn.outputs):",
            "            output_id = block._id",
            "            if isinstance(block, components.StreamingOutput) and block.streaming:",
            "                first_chunk = output_id not in stream_run",
            "                binary_data, output_data = block.stream_output(",
            "                    data[i], f\"{session_hash}/{run}/{output_id}\", first_chunk",
            "                )",
            "                if first_chunk:",
            "                    stream_run[output_id] = []",
            "                self.pending_streams[session_hash][run][output_id].append(binary_data)",
            "                output_data = await processing_utils.async_move_files_to_cache(",
            "                    output_data,",
            "                    block,",
            "                    postprocess=True,",
            "                )",
            "                if root_path is not None:",
            "                    output_data = processing_utils.add_root_url(",
            "                        output_data, root_path, None",
            "                    )",
            "                data[i] = output_data",
            "",
            "        return data",
            "",
            "    def handle_streaming_diffs(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        data: list,",
            "        session_hash: str | None,",
            "        run: int | None,",
            "        final: bool,",
            "        simple_format: bool = False,",
            "    ) -> list:",
            "        if session_hash is None or run is None:",
            "            return data",
            "        first_run = run not in self.pending_diff_streams[session_hash]",
            "        if first_run:",
            "            self.pending_diff_streams[session_hash][run] = [None] * len(data)",
            "        last_diffs = self.pending_diff_streams[session_hash][run]",
            "",
            "        for i in range(len(block_fn.outputs)):",
            "            if final:",
            "                data[i] = last_diffs[i]",
            "                continue",
            "",
            "            if first_run:",
            "                last_diffs[i] = data[i]",
            "            else:",
            "                prev_chunk = last_diffs[i]",
            "                last_diffs[i] = data[i]",
            "                if not simple_format:",
            "                    data[i] = utils.diff(prev_chunk, data[i])",
            "",
            "        if final:",
            "            del self.pending_diff_streams[session_hash][run]",
            "",
            "        return data",
            "",
            "    async def process_api(",
            "        self,",
            "        block_fn: BlockFunction | int,",
            "        inputs: list[Any],",
            "        state: SessionState | None = None,",
            "        request: routes.Request | list[routes.Request] | None = None,",
            "        iterator: AsyncIterator | None = None,",
            "        session_hash: str | None = None,",
            "        event_id: str | None = None,",
            "        event_data: EventData | None = None,",
            "        in_event_listener: bool = True,",
            "        simple_format: bool = False,",
            "        explicit_call: bool = False,",
            "        root_path: str | None = None,",
            "    ) -> dict[str, Any]:",
            "        \"\"\"",
            "        Processes API calls from the frontend. First preprocesses the data,",
            "        then runs the relevant function, then postprocesses the output.",
            "        Parameters:",
            "            fn_index: Index of function to run.",
            "            inputs: input data received from the frontend",
            "            state: data stored from stateful components for session (key is input block id)",
            "            request: the gr.Request object containing information about the network request (e.g. IP address, headers, query parameters, username)",
            "            iterators: the in-progress iterators for each generator function (key is function index)",
            "            event_id: id of event that triggered this API call",
            "            event_data: data associated with the event trigger itself",
            "            in_event_listener: whether this API call is being made in response to an event listener",
            "            explicit_call: whether this call is being made directly by calling the Blocks function, instead of through an event listener or API route",
            "            root_path: if provided, the root path of the server. All file URLs will be prefixed with this path.",
            "        Returns: None",
            "        \"\"\"",
            "        if isinstance(block_fn, int):",
            "            block_fn = self.fns[block_fn]",
            "        batch = block_fn.batch",
            "        state_ids_to_track, hashed_values = self.get_state_ids_to_track(block_fn, state)",
            "        changed_state_ids = []",
            "",
            "        if batch:",
            "            max_batch_size = block_fn.max_batch_size",
            "            batch_sizes = [len(inp) for inp in inputs]",
            "            batch_size = batch_sizes[0]",
            "            if inspect.isasyncgenfunction(block_fn.fn) or inspect.isgeneratorfunction(",
            "                block_fn.fn",
            "            ):",
            "                raise ValueError(\"Gradio does not support generators in batch mode.\")",
            "            if not all(x == batch_size for x in batch_sizes):",
            "                raise ValueError(",
            "                    f\"All inputs to a batch function must have the same length but instead have sizes: {batch_sizes}.\"",
            "                )",
            "            if batch_size > max_batch_size:",
            "                raise ValueError(",
            "                    f\"Batch size ({batch_size}) exceeds the max_batch_size for this function ({max_batch_size})\"",
            "                )",
            "            inputs = [",
            "                await self.preprocess_data(block_fn, list(i), state, explicit_call)",
            "                for i in zip(*inputs)",
            "            ]",
            "            result = await self.call_function(",
            "                block_fn,",
            "                list(zip(*inputs)),",
            "                None,",
            "                request,",
            "                event_id,",
            "                event_data,",
            "                in_event_listener,",
            "                state,",
            "            )",
            "            preds = result[\"prediction\"]",
            "            data = [",
            "                await self.postprocess_data(block_fn, list(o), state)",
            "                for o in zip(*preds)",
            "            ]",
            "            if root_path is not None:",
            "                data = processing_utils.add_root_url(data, root_path, None)  # type: ignore",
            "            data = list(zip(*data))",
            "            is_generating, iterator = None, None",
            "        else:",
            "            old_iterator = iterator",
            "            if old_iterator:",
            "                inputs = []",
            "            else:",
            "                inputs = await self.preprocess_data(",
            "                    block_fn, inputs, state, explicit_call",
            "                )",
            "            was_generating = old_iterator is not None",
            "            result = await self.call_function(",
            "                block_fn,",
            "                inputs,",
            "                old_iterator,",
            "                request,",
            "                event_id,",
            "                event_data,",
            "                in_event_listener,",
            "                state,",
            "            )",
            "            data = await self.postprocess_data(block_fn, result[\"prediction\"], state)",
            "            if state:",
            "                changed_state_ids = [",
            "                    state_id",
            "                    for hash_value, state_id in zip(hashed_values, state_ids_to_track)",
            "                    if hash_value != utils.deep_hash(state[state_id])",
            "                ]",
            "",
            "            if root_path is not None:",
            "                data = processing_utils.add_root_url(data, root_path, None)",
            "            is_generating, iterator = result[\"is_generating\"], result[\"iterator\"]",
            "            if is_generating or was_generating:",
            "                run = id(old_iterator) if was_generating else id(iterator)",
            "                data = await self.handle_streaming_outputs(",
            "                    block_fn,",
            "                    data,",
            "                    session_hash=session_hash,",
            "                    run=run,",
            "                    root_path=root_path,",
            "                )",
            "                data = self.handle_streaming_diffs(",
            "                    block_fn,",
            "                    data,",
            "                    session_hash=session_hash,",
            "                    run=run,",
            "                    final=not is_generating,",
            "                    simple_format=simple_format,",
            "                )",
            "",
            "        block_fn.total_runtime += result[\"duration\"]",
            "        block_fn.total_runs += 1",
            "        output = {",
            "            \"data\": data,",
            "            \"is_generating\": is_generating,",
            "            \"iterator\": iterator,",
            "            \"duration\": result[\"duration\"],",
            "            \"average_duration\": block_fn.total_runtime / block_fn.total_runs,",
            "            \"render_config\": None,",
            "            \"changed_state_ids\": changed_state_ids,",
            "        }",
            "        if block_fn.renderable and state:",
            "            output[\"render_config\"] = state.blocks_config.get_config(",
            "                block_fn.renderable",
            "            )",
            "            output[\"render_config\"][\"render_id\"] = block_fn.renderable._id",
            "",
            "        return output",
            "",
            "    def get_state_ids_to_track(",
            "        self, block_fn: BlockFunction, state: SessionState | None",
            "    ) -> tuple[list[int], list]:",
            "        if state is None:",
            "            return [], []",
            "        state_ids_to_track = []",
            "        hashed_values = []",
            "        for block in block_fn.outputs:",
            "            if block.stateful and any(",
            "                (block._id, \"change\") in fn.targets for fn in self.fns.values()",
            "            ):",
            "                value = state[block._id]",
            "                state_ids_to_track.append(block._id)",
            "                hashed_values.append(utils.deep_hash(value))",
            "        return state_ids_to_track, hashed_values",
            "",
            "    def create_limiter(self):",
            "        self.limiter = (",
            "            None",
            "            if self.max_threads == 40",
            "            else CapacityLimiter(total_tokens=self.max_threads)",
            "        )",
            "",
            "    def get_config(self):",
            "        return {\"type\": \"column\"}",
            "",
            "    def get_config_file(self) -> BlocksConfigDict:",
            "        config: BlocksConfigDict = {",
            "            \"version\": routes.VERSION,",
            "            \"mode\": self.mode,",
            "            \"app_id\": self.app_id,",
            "            \"dev_mode\": self.dev_mode,",
            "            \"analytics_enabled\": self.analytics_enabled,",
            "            \"components\": [],",
            "            \"css\": self.css,",
            "            \"connect_heartbeat\": False,",
            "            \"js\": self.js,",
            "            \"head\": self.head,",
            "            \"title\": self.title or \"Gradio\",",
            "            \"space_id\": self.space_id,",
            "            \"enable_queue\": True,  # launch attributes",
            "            \"show_error\": getattr(self, \"show_error\", False),",
            "            \"show_api\": self.show_api,",
            "            \"is_colab\": utils.colab_check(),",
            "            \"max_file_size\": getattr(self, \"max_file_size\", None),",
            "            \"stylesheets\": self.stylesheets,",
            "            \"theme\": self.theme.name,",
            "            \"protocol\": \"sse_v3\",",
            "            \"body_css\": {",
            "                \"body_background_fill\": self.theme._get_computed_value(",
            "                    \"body_background_fill\"",
            "                ),",
            "                \"body_text_color\": self.theme._get_computed_value(\"body_text_color\"),",
            "                \"body_background_fill_dark\": self.theme._get_computed_value(",
            "                    \"body_background_fill_dark\"",
            "                ),",
            "                \"body_text_color_dark\": self.theme._get_computed_value(",
            "                    \"body_text_color_dark\"",
            "                ),",
            "            },",
            "            \"fill_height\": self.fill_height,",
            "            \"fill_width\": self.fill_width,",
            "            \"theme_hash\": self.theme_hash,",
            "        }",
            "        config.update(self.default_config.get_config())  # type: ignore",
            "        config[\"connect_heartbeat\"] = utils.connect_heartbeat(",
            "            config, self.blocks.values()",
            "        )",
            "        return config",
            "",
            "    def __enter__(self):",
            "        render_context = get_render_context()",
            "        if render_context is None:",
            "            Context.root_block = self",
            "        self.parent = render_context",
            "        set_render_context(self)",
            "        self.exited = False",
            "        return self",
            "",
            "    def __exit__(self, exc_type: type[BaseException] | None = None, *args):",
            "        if exc_type is not None:",
            "            set_render_context(None)",
            "            Context.root_block = None",
            "            return",
            "        super().fill_expected_parents()",
            "        set_render_context(self.parent)",
            "        # Configure the load events before root_block is reset",
            "        self.attach_load_events()",
            "        if self.parent is None:",
            "            Context.root_block = None",
            "        else:",
            "            self.parent.children.extend(self.children)",
            "        self.config = self.get_config_file()",
            "        self.app = routes.App.create_app(self)",
            "        self.progress_tracking = any(",
            "            block_fn.tracks_progress for block_fn in self.fns.values()",
            "        )",
            "        self.exited = True",
            "",
            "    def clear(self):",
            "        \"\"\"Resets the layout of the Blocks object.\"\"\"",
            "        self.default_config.blocks = {}",
            "        self.default_config.fns = {}",
            "        self.children = []",
            "        return self",
            "",
            "    @document()",
            "    def queue(",
            "        self,",
            "        status_update_rate: float | Literal[\"auto\"] = \"auto\",",
            "        api_open: bool | None = None,",
            "        max_size: int | None = None,",
            "        concurrency_count: int | None = None,",
            "        *,",
            "        default_concurrency_limit: int | None | Literal[\"not_set\"] = \"not_set\",",
            "    ):",
            "        \"\"\"",
            "        By enabling the queue you can control when users know their position in the queue, and set a limit on maximum number of events allowed.",
            "        Parameters:",
            "            status_update_rate: If \"auto\", Queue will send status estimations to all clients whenever a job is finished. Otherwise Queue will send status at regular intervals set by this parameter as the number of seconds.",
            "            api_open: If True, the REST routes of the backend will be open, allowing requests made directly to those endpoints to skip the queue.",
            "            max_size: The maximum number of events the queue will store at any given moment. If the queue is full, new events will not be added and a user will receive a message saying that the queue is full. If None, the queue size will be unlimited.",
            "            concurrency_count: Deprecated. Set the concurrency_limit directly on event listeners e.g. btn.click(fn, ..., concurrency_limit=10) or gr.Interface(concurrency_limit=10). If necessary, the total number of workers can be configured via `max_threads` in launch().",
            "            default_concurrency_limit: The default value of `concurrency_limit` to use for event listeners that don't specify a value. Can be set by environment variable GRADIO_DEFAULT_CONCURRENCY_LIMIT. Defaults to 1 if not set otherwise.",
            "        Example: (Blocks)",
            "            with gr.Blocks() as demo:",
            "                button = gr.Button(label=\"Generate Image\")",
            "                button.click(fn=image_generator, inputs=gr.Textbox(), outputs=gr.Image())",
            "            demo.queue(max_size=10)",
            "            demo.launch()",
            "        Example: (Interface)",
            "            demo = gr.Interface(image_generator, gr.Textbox(), gr.Image())",
            "            demo.queue(max_size=20)",
            "            demo.launch()",
            "        \"\"\"",
            "        if concurrency_count:",
            "            raise DeprecationWarning(",
            "                \"concurrency_count has been deprecated. Set the concurrency_limit directly on event listeners e.g. btn.click(fn, ..., concurrency_limit=10) or gr.Interface(concurrency_limit=10). If necessary, the total number of workers can be configured via `max_threads` in launch().\"",
            "            )",
            "        if api_open is not None:",
            "            self.api_open = api_open",
            "        if utils.is_zero_gpu_space():",
            "            max_size = 1 if max_size is None else max_size",
            "        self._queue = queueing.Queue(",
            "            live_updates=status_update_rate == \"auto\",",
            "            concurrency_count=self.max_threads,",
            "            update_intervals=status_update_rate if status_update_rate != \"auto\" else 1,",
            "            max_size=max_size,",
            "            blocks=self,",
            "            default_concurrency_limit=default_concurrency_limit,",
            "        )",
            "        self.config = self.get_config_file()",
            "        self.app = routes.App.create_app(self)",
            "        return self",
            "",
            "    def validate_queue_settings(self):",
            "        for dep in self.fns.values():",
            "            for i in dep.cancels:",
            "                if not self.fns[i].queue:",
            "                    raise ValueError(",
            "                        \"Queue needs to be enabled! \"",
            "                        \"You may get this error by either 1) passing a function that uses the yield keyword \"",
            "                        \"into an interface without enabling the queue or 2) defining an event that cancels \"",
            "                        \"another event without enabling the queue. Both can be solved by calling .queue() \"",
            "                        \"before .launch()\"",
            "                    )",
            "            if dep.batch and dep.queue is False:",
            "                raise ValueError(\"In order to use batching, the queue must be enabled.\")",
            "",
            "    def launch(",
            "        self,",
            "        inline: bool | None = None,",
            "        inbrowser: bool = False,",
            "        share: bool | None = None,",
            "        debug: bool = False,",
            "        max_threads: int = 40,",
            "        auth: Callable | tuple[str, str] | list[tuple[str, str]] | None = None,",
            "        auth_message: str | None = None,",
            "        prevent_thread_lock: bool = False,",
            "        show_error: bool = False,",
            "        server_name: str | None = None,",
            "        server_port: int | None = None,",
            "        *,",
            "        height: int = 500,",
            "        width: int | str = \"100%\",",
            "        favicon_path: str | None = None,",
            "        ssl_keyfile: str | None = None,",
            "        ssl_certfile: str | None = None,",
            "        ssl_keyfile_password: str | None = None,",
            "        ssl_verify: bool = True,",
            "        quiet: bool = False,",
            "        show_api: bool = not wasm_utils.IS_WASM,",
            "        allowed_paths: list[str] | None = None,",
            "        blocked_paths: list[str] | None = None,",
            "        root_path: str | None = None,",
            "        app_kwargs: dict[str, Any] | None = None,",
            "        state_session_capacity: int = 10000,",
            "        share_server_address: str | None = None,",
            "        share_server_protocol: Literal[\"http\", \"https\"] | None = None,",
            "        auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "        max_file_size: str | int | None = None,",
            "        _frontend: bool = True,",
            "        enable_monitoring: bool = False,",
            "    ) -> tuple[FastAPI, str, str]:",
            "        \"\"\"",
            "        Launches a simple web server that serves the demo. Can also be used to create a",
            "        public link used by anyone to access the demo from their browser by setting share=True.",
            "",
            "        Parameters:",
            "            inline: whether to display in the gradio app inline in an iframe. Defaults to True in python notebooks; False otherwise.",
            "            inbrowser: whether to automatically launch the gradio app in a new tab on the default browser.",
            "            share: whether to create a publicly shareable link for the gradio app. Creates an SSH tunnel to make your UI accessible from anywhere. If not provided, it is set to False by default every time, except when running in Google Colab. When localhost is not accessible (e.g. Google Colab), setting share=False is not supported. Can be set by environment variable GRADIO_SHARE=True.",
            "            debug: if True, blocks the main thread from running. If running in Google Colab, this is needed to print the errors in the cell output.",
            "            auth: If provided, username and password (or list of username-password tuples) required to access app. Can also provide function that takes username and password and returns True if valid login.",
            "            auth_message: If provided, HTML message provided on login page.",
            "            prevent_thread_lock: By default, the gradio app blocks the main thread while the server is running. If set to True, the gradio app will not block and the gradio server will terminate as soon as the script finishes.",
            "            show_error: If True, any errors in the gradio app will be displayed in an alert modal and printed in the browser console log",
            "            server_port: will start gradio app on this port (if available). Can be set by environment variable GRADIO_SERVER_PORT. If None, will search for an available port starting at 7860.",
            "            server_name: to make app accessible on local network, set this to \"0.0.0.0\". Can be set by environment variable GRADIO_SERVER_NAME. If None, will use \"127.0.0.1\".",
            "            max_threads: the maximum number of total threads that the Gradio app can generate in parallel. The default is inherited from the starlette library (currently 40).",
            "            width: The width in pixels of the iframe element containing the gradio app (used if inline=True)",
            "            height: The height in pixels of the iframe element containing the gradio app (used if inline=True)",
            "            favicon_path: If a path to a file (.png, .gif, or .ico) is provided, it will be used as the favicon for the web page.",
            "            ssl_keyfile: If a path to a file is provided, will use this as the private key file to create a local server running on https.",
            "            ssl_certfile: If a path to a file is provided, will use this as the signed certificate for https. Needs to be provided if ssl_keyfile is provided.",
            "            ssl_keyfile_password: If a password is provided, will use this with the ssl certificate for https.",
            "            ssl_verify: If False, skips certificate validation which allows self-signed certificates to be used.",
            "            quiet: If True, suppresses most print statements.",
            "            show_api: If True, shows the api docs in the footer of the app. Default True.",
            "            allowed_paths: List of complete filepaths or parent directories that gradio is allowed to serve. Must be absolute paths. Warning: if you provide directories, any files in these directories or their subdirectories are accessible to all users of your app. Can be set by comma separated environment variable GRADIO_ALLOWED_PATHS.",
            "            blocked_paths: List of complete filepaths or parent directories that gradio is not allowed to serve (i.e. users of your app are not allowed to access). Must be absolute paths. Warning: takes precedence over `allowed_paths` and all other directories exposed by Gradio by default. Can be set by comma separated environment variable GRADIO_BLOCKED_PATHS.",
            "            root_path: The root path (or \"mount point\") of the application, if it's not served from the root (\"/\") of the domain. Often used when the application is behind a reverse proxy that forwards requests to the application. For example, if the application is served at \"https://example.com/myapp\", the `root_path` should be set to \"/myapp\". A full URL beginning with http:// or https:// can be provided, which will be used as the root path in its entirety. Can be set by environment variable GRADIO_ROOT_PATH. Defaults to \"\".",
            "            app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{\"docs_url\": \"/docs\"}`",
            "            state_session_capacity: The maximum number of sessions whose information to store in memory. If the number of sessions exceeds this number, the oldest sessions will be removed. Reduce capacity to reduce memory usage when using gradio.State or returning updated components from functions. Defaults to 10000.",
            "            share_server_address: Use this to specify a custom FRP server and port for sharing Gradio apps (only applies if share=True). If not provided, will use the default FRP server at https://gradio.live. See https://github.com/huggingface/frp for more information.",
            "            share_server_protocol: Use this to specify the protocol to use for the share links. Defaults to \"https\", unless a custom share_server_address is provided, in which case it defaults to \"http\". If you are using a custom share_server_address and want to use https, you must set this to \"https\".",
            "            auth_dependency: A function that takes a FastAPI request and returns a string user ID or None. If the function returns None for a specific request, that user is not authorized to access the app (they will see a 401 Unauthorized response). To be used with external authentication systems like OAuth. Cannot be used with `auth`.",
            "            max_file_size: The maximum file size in bytes that can be uploaded. Can be a string of the form \"<value><unit>\", where value is any positive integer and unit is one of \"b\", \"kb\", \"mb\", \"gb\", \"tb\". If None, no limit is set.",
            "        Returns:",
            "            app: FastAPI app object that is running the demo",
            "            local_url: Locally accessible link to the demo",
            "            share_url: Publicly accessible link to the demo (if share=True, otherwise None)",
            "        Example: (Blocks)",
            "            import gradio as gr",
            "            def reverse(text):",
            "                return text[::-1]",
            "            with gr.Blocks() as demo:",
            "                button = gr.Button(value=\"Reverse\")",
            "                button.click(reverse, gr.Textbox(), gr.Textbox())",
            "            demo.launch(share=True, auth=(\"username\", \"password\"))",
            "        Example:  (Interface)",
            "            import gradio as gr",
            "            def reverse(text):",
            "                return text[::-1]",
            "            demo = gr.Interface(reverse, \"text\", \"text\")",
            "            demo.launch(share=True, auth=(\"username\", \"password\"))",
            "        \"\"\"",
            "        from gradio.routes import App",
            "",
            "        if self._is_running_in_reload_thread:",
            "            # We have already launched the demo",
            "            return None, None, None  # type: ignore",
            "",
            "        if not self.exited:",
            "            self.__exit__()",
            "",
            "        if auth is not None and auth_dependency is not None:",
            "            raise ValueError(",
            "                \"You cannot provide both `auth` and `auth_dependency` in launch(). Please choose one.\"",
            "            )",
            "        if (",
            "            auth",
            "            and not callable(auth)",
            "            and not isinstance(auth[0], tuple)",
            "            and not isinstance(auth[0], list)",
            "        ):",
            "            self.auth = [auth]",
            "        else:",
            "            self.auth = auth",
            "",
            "        if self.auth and not callable(self.auth):",
            "            if any(not authenticable[0] for authenticable in self.auth):",
            "                warnings.warn(",
            "                    \"You have provided an empty username in `auth`. Please provide a valid username.\"",
            "                )",
            "            if any(not authenticable[1] for authenticable in self.auth):",
            "                warnings.warn(",
            "                    \"You have provided an empty password in `auth`. Please provide a valid password.\"",
            "                )",
            "",
            "        self.auth_message = auth_message",
            "        self.show_error = show_error",
            "        self.height = height",
            "        self.width = width",
            "        self.favicon_path = favicon_path",
            "        self.ssl_verify = ssl_verify",
            "        self.state_session_capacity = state_session_capacity",
            "        if root_path is None:",
            "            self.root_path = os.environ.get(\"GRADIO_ROOT_PATH\", \"\")",
            "        else:",
            "            self.root_path = root_path",
            "",
            "        self.show_api = show_api",
            "",
            "        if allowed_paths:",
            "            self.allowed_paths = allowed_paths",
            "        else:",
            "            allowed_paths_env = os.environ.get(\"GRADIO_ALLOWED_PATHS\", \"\")",
            "            if len(allowed_paths_env) > 0:",
            "                self.allowed_paths = [",
            "                    item.strip() for item in allowed_paths_env.split(\",\")",
            "                ]",
            "            else:",
            "                self.allowed_paths = []",
            "",
            "        if blocked_paths:",
            "            self.blocked_paths = blocked_paths",
            "        else:",
            "            blocked_paths_env = os.environ.get(\"GRADIO_BLOCKED_PATHS\", \"\")",
            "            if len(blocked_paths_env) > 0:",
            "                self.blocked_paths = [",
            "                    item.strip() for item in blocked_paths_env.split(\",\")",
            "                ]",
            "            else:",
            "                self.blocked_paths = []",
            "",
            "        if not isinstance(self.allowed_paths, list):",
            "            raise ValueError(\"`allowed_paths` must be a list of directories.\")",
            "        if not isinstance(self.blocked_paths, list):",
            "            raise ValueError(\"`blocked_paths` must be a list of directories.\")",
            "",
            "        self.validate_queue_settings()",
            "        self.max_file_size = utils._parse_file_size(max_file_size)",
            "",
            "        if self.dev_mode:",
            "            for block in self.blocks.values():",
            "                if block.key is None:",
            "                    block.key = f\"__{block._id}__\"",
            "",
            "        self.config = self.get_config_file()",
            "        self.max_threads = max_threads",
            "        self._queue.max_thread_count = max_threads",
            "        # self.server_app is included for backwards compatibility",
            "        self.server_app = self.app = App.create_app(",
            "            self, auth_dependency=auth_dependency, app_kwargs=app_kwargs",
            "        )",
            "",
            "        if self.is_running:",
            "            if not isinstance(self.local_url, str):",
            "                raise ValueError(f\"Invalid local_url: {self.local_url}\")",
            "            if not (quiet):",
            "                print(",
            "                    \"Rerunning server... use `close()` to stop if you need to change `launch()` parameters.\\n----\"",
            "                )",
            "        else:",
            "            if wasm_utils.IS_WASM:",
            "                server_name = \"xxx\"",
            "                server_port = 99999",
            "                local_url = \"\"",
            "                server = None",
            "                # In the Wasm environment, we only need the app object",
            "                # which the frontend app will directly communicate with through the Worker API,",
            "                # and we don't need to start a server.",
            "                wasm_utils.register_app(self.app)",
            "            else:",
            "                from gradio import http_server",
            "",
            "                (",
            "                    server_name,",
            "                    server_port,",
            "                    local_url,",
            "                    server,",
            "                ) = http_server.start_server(",
            "                    app=self.app,",
            "                    server_name=server_name,",
            "                    server_port=server_port,",
            "                    ssl_keyfile=ssl_keyfile,",
            "                    ssl_certfile=ssl_certfile,",
            "                    ssl_keyfile_password=ssl_keyfile_password,",
            "                )",
            "            self.server_name = server_name",
            "            self.local_url = local_url",
            "            self.server_port = server_port",
            "            self.server = server",
            "            self.is_running = True",
            "            self.is_colab = utils.colab_check()",
            "            self.is_kaggle = utils.kaggle_check()",
            "            self.share_server_address = share_server_address",
            "            self.share_server_protocol = share_server_protocol or (",
            "                \"http\" if share_server_address is not None else \"https\"",
            "            )",
            "",
            "            self.protocol = (",
            "                \"https\"",
            "                if self.local_url.startswith(\"https\") or self.is_colab",
            "                else \"http\"",
            "            )",
            "            if not wasm_utils.IS_WASM and not self.is_colab and not quiet:",
            "                print(",
            "                    strings.en[\"RUNNING_LOCALLY_SEPARATED\"].format(",
            "                        self.protocol, self.server_name, self.server_port",
            "                    )",
            "                )",
            "",
            "            self._queue.set_server_app(self.server_app)",
            "",
            "            if not wasm_utils.IS_WASM:",
            "                # Cannot run async functions in background other than app's scope.",
            "                # Workaround by triggering the app endpoint",
            "                httpx.get(",
            "                    f\"{self.local_url}startup-events\", verify=ssl_verify, timeout=None",
            "                )",
            "            else:",
            "                # NOTE: One benefit of the code above dispatching `startup_events()` via a self HTTP request is",
            "                # that `self._queue.start()` is called in another thread which is managed by the HTTP server, `uvicorn`",
            "                # so all the asyncio tasks created by the queue runs in an event loop in that thread and",
            "                # will be cancelled just by stopping the server.",
            "                # In contrast, in the Wasm env, we can't do that because `threading` is not supported and all async tasks will run in the same event loop, `pyodide.webloop.WebLoop` in the main thread.",
            "                # So we need to manually cancel them. See `self.close()`..",
            "                self.startup_events()",
            "",
            "        utils.launch_counter()",
            "        self.is_sagemaker = utils.sagemaker_check()",
            "        if share is None:",
            "            if self.is_colab:",
            "                if not quiet:",
            "                    print(",
            "                        \"Setting queue=True in a Colab notebook requires sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\\n\"",
            "                    )",
            "                self.share = True",
            "            elif self.is_kaggle:",
            "                if not quiet:",
            "                    print(",
            "                        \"Kaggle notebooks require sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\\n\"",
            "                    )",
            "                self.share = True",
            "            elif self.is_sagemaker:",
            "                if not quiet:",
            "                    print(",
            "                        \"Sagemaker notebooks may require sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\\n\"",
            "                    )",
            "                self.share = True",
            "            else:",
            "                self.share = False",
            "                # GRADIO_SHARE environment variable for forcing 'share=True'",
            "                # GRADIO_SHARE=True => share=True",
            "                share_env = os.getenv(\"GRADIO_SHARE\")",
            "                if share_env is not None and share_env.lower() == \"true\":",
            "                    self.share = True",
            "        else:",
            "            self.share = share",
            "",
            "        if enable_monitoring:",
            "            print(",
            "                f\"Monitoring URL: {self.local_url}monitoring/{self.app.analytics_key}\"",
            "            )",
            "",
            "        # If running in a colab or not able to access localhost,",
            "        # a shareable link must be created.",
            "        if (",
            "            _frontend",
            "            and not wasm_utils.IS_WASM",
            "            and not networking.url_ok(self.local_url)",
            "            and not self.share",
            "        ):",
            "            raise ValueError(",
            "                \"When localhost is not accessible, a shareable link must be created. Please set share=True or check your proxy settings to allow access to localhost.\"",
            "            )",
            "",
            "        if self.is_colab and not quiet:",
            "            if debug:",
            "                print(strings.en[\"COLAB_DEBUG_TRUE\"])",
            "            else:",
            "                print(strings.en[\"COLAB_DEBUG_FALSE\"])",
            "            if not self.share:",
            "                print(strings.en[\"COLAB_WARNING\"].format(self.server_port))",
            "",
            "        if self.share:",
            "            if self.space_id:",
            "                warnings.warn(",
            "                    \"Setting share=True is not supported on Hugging Face Spaces\"",
            "                )",
            "                self.share = False",
            "            if wasm_utils.IS_WASM:",
            "                warnings.warn(",
            "                    \"Setting share=True is not supported in the Wasm environment\"",
            "                )",
            "                self.share = False",
            "",
            "        if self.share:",
            "            try:",
            "                if self.share_url is None:",
            "                    share_url = networking.setup_tunnel(",
            "                        local_host=self.server_name,",
            "                        local_port=self.server_port,",
            "                        share_token=self.share_token,",
            "                        share_server_address=self.share_server_address,",
            "                    )",
            "                    parsed_url = urlparse(share_url)",
            "                    self.share_url = urlunparse(",
            "                        (self.share_server_protocol,) + parsed_url[1:]",
            "                    )",
            "                print(strings.en[\"SHARE_LINK_DISPLAY\"].format(self.share_url))",
            "                if not (quiet):",
            "                    print(strings.en[\"SHARE_LINK_MESSAGE\"])",
            "            except (RuntimeError, httpx.ConnectError):",
            "                if self.analytics_enabled:",
            "                    analytics.error_analytics(\"Not able to set up tunnel\")",
            "                self.share_url = None",
            "                self.share = False",
            "                if Path(BINARY_PATH).exists():",
            "                    print(strings.en[\"COULD_NOT_GET_SHARE_LINK\"])",
            "                else:",
            "                    print(",
            "                        strings.en[\"COULD_NOT_GET_SHARE_LINK_MISSING_FILE\"].format(",
            "                            BINARY_PATH,",
            "                            BINARY_URL,",
            "                            BINARY_FILENAME,",
            "                            BINARY_FOLDER,",
            "                        )",
            "                    )",
            "        else:",
            "            if not quiet and not wasm_utils.IS_WASM:",
            "                print(strings.en[\"PUBLIC_SHARE_TRUE\"])",
            "            self.share_url = None",
            "",
            "        if inbrowser and not wasm_utils.IS_WASM:",
            "            link = self.share_url if self.share and self.share_url else self.local_url",
            "            webbrowser.open(link)",
            "",
            "        # Check if running in a Python notebook in which case, display inline",
            "        if inline is None:",
            "            inline = utils.ipython_check()",
            "        if inline:",
            "            try:",
            "                from IPython.display import HTML, Javascript, display  # type: ignore",
            "",
            "                if self.share and self.share_url:",
            "                    while not networking.url_ok(self.share_url):",
            "                        time.sleep(0.25)",
            "                    artifact = HTML(",
            "                        f'<div><iframe src=\"{self.share_url}\" width=\"{self.width}\" height=\"{self.height}\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>'",
            "                    )",
            "",
            "                elif self.is_colab:",
            "                    # modified from /usr/local/lib/python3.7/dist-packages/google/colab/output/_util.py within Colab environment",
            "                    code = \"\"\"(async (port, path, width, height, cache, element) => {",
            "                        if (!google.colab.kernel.accessAllowed && !cache) {",
            "                            return;",
            "                        }",
            "                        element.appendChild(document.createTextNode(''));",
            "                        const url = await google.colab.kernel.proxyPort(port, {cache});",
            "",
            "                        const external_link = document.createElement('div');",
            "                        external_link.innerHTML = `",
            "                            <div style=\"font-family: monospace; margin-bottom: 0.5rem\">",
            "                                Running on <a href=${new URL(path, url).toString()} target=\"_blank\">",
            "                                    https://localhost:${port}${path}",
            "                                </a>",
            "                            </div>",
            "                        `;",
            "                        element.appendChild(external_link);",
            "",
            "                        const iframe = document.createElement('iframe');",
            "                        iframe.src = new URL(path, url).toString();",
            "                        iframe.height = height;",
            "                        iframe.allow = \"autoplay; camera; microphone; clipboard-read; clipboard-write;\"",
            "                        iframe.width = width;",
            "                        iframe.style.border = 0;",
            "                        element.appendChild(iframe);",
            "                    })\"\"\" + \"({port}, {path}, {width}, {height}, {cache}, window.element)\".format(",
            "                        port=json.dumps(self.server_port),",
            "                        path=json.dumps(\"/\"),",
            "                        width=json.dumps(self.width),",
            "                        height=json.dumps(self.height),",
            "                        cache=json.dumps(False),",
            "                    )",
            "",
            "                    artifact = Javascript(code)",
            "                else:",
            "                    artifact = HTML(",
            "                        f'<div><iframe src=\"{self.local_url}\" width=\"{self.width}\" height=\"{self.height}\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>'",
            "                    )",
            "                self.artifact = artifact",
            "                display(artifact)",
            "            except ImportError:",
            "                pass",
            "",
            "        if getattr(self, \"analytics_enabled\", False):",
            "            data = {",
            "                \"launch_method\": \"browser\" if inbrowser else \"inline\",",
            "                \"is_google_colab\": self.is_colab,",
            "                \"is_sharing_on\": self.share,",
            "                \"is_space\": self.space_id is not None,",
            "                \"mode\": self.mode,",
            "            }",
            "            analytics.launched_analytics(self, data)",
            "",
            "        is_in_interactive_mode = bool(getattr(sys, \"ps1\", sys.flags.interactive))",
            "",
            "        # Block main thread if debug==True",
            "        if (",
            "            debug",
            "            or int(os.getenv(\"GRADIO_DEBUG\", \"0\")) == 1",
            "            and not wasm_utils.IS_WASM",
            "            or (",
            "                # Block main thread if running in a script to stop script from exiting",
            "                not prevent_thread_lock",
            "                and not is_in_interactive_mode",
            "                # In the Wasm env, we don't have to block the main thread because the server won't be shut down after the execution finishes.",
            "                # Moreover, we MUST NOT do it because there is only one thread in the Wasm env and blocking it will stop the subsequent code from running.",
            "                and not wasm_utils.IS_WASM",
            "            )",
            "        ):",
            "            self.block_thread()",
            "",
            "        return TupleNoPrint((self.server_app, self.local_url, self.share_url))  # type: ignore",
            "",
            "    def integrate(",
            "        self,",
            "        comet_ml=None,",
            "        wandb: ModuleType | None = None,",
            "        mlflow: ModuleType | None = None,",
            "    ) -> None:",
            "        \"\"\"",
            "        A catch-all method for integrating with other libraries. This method should be run after launch()",
            "        Parameters:",
            "            comet_ml: If a comet_ml Experiment object is provided, will integrate with the experiment and appear on Comet dashboard",
            "            wandb: If the wandb module is provided, will integrate with it and appear on WandB dashboard",
            "            mlflow: If the mlflow module  is provided, will integrate with the experiment and appear on ML Flow dashboard",
            "        \"\"\"",
            "        analytics_integration = \"\"",
            "        if comet_ml is not None:",
            "            analytics_integration = \"CometML\"",
            "            comet_ml.log_other(\"Created from\", \"Gradio\")",
            "            if self.share_url is not None:",
            "                comet_ml.log_text(f\"gradio: {self.share_url}\")",
            "                comet_ml.end()",
            "            elif self.local_url:",
            "                comet_ml.log_text(f\"gradio: {self.local_url}\")",
            "                comet_ml.end()",
            "            else:",
            "                raise ValueError(\"Please run `launch()` first.\")",
            "        if wandb is not None:",
            "            analytics_integration = \"WandB\"",
            "            if self.share_url is not None:",
            "                wandb.log(",
            "                    {",
            "                        \"Gradio panel\": wandb.Html(",
            "                            '<iframe src=\"'",
            "                            + self.share_url",
            "                            + '\" width=\"'",
            "                            + str(self.width)",
            "                            + '\" height=\"'",
            "                            + str(self.height)",
            "                            + '\" frameBorder=\"0\"></iframe>'",
            "                        )",
            "                    }",
            "                )",
            "            else:",
            "                print(",
            "                    \"The WandB integration requires you to \"",
            "                    \"`launch(share=True)` first.\"",
            "                )",
            "        if mlflow is not None:",
            "            analytics_integration = \"MLFlow\"",
            "            if self.share_url is not None:",
            "                mlflow.log_param(\"Gradio Interface Share Link\", self.share_url)",
            "            else:",
            "                mlflow.log_param(\"Gradio Interface Local Link\", self.local_url)",
            "        if self.analytics_enabled and analytics_integration:",
            "            data = {\"integration\": analytics_integration}",
            "            analytics.integration_analytics(data)",
            "",
            "    def close(self, verbose: bool = True) -> None:",
            "        \"\"\"",
            "        Closes the Interface that was launched and frees the port.",
            "        \"\"\"",
            "        try:",
            "            if wasm_utils.IS_WASM:",
            "                # NOTE:",
            "                # Normally, queue-related async tasks whose async tasks are started at the `/queue/data` endpoint function)",
            "                # are running in an event loop in the server thread,",
            "                # so they will be cancelled by `self.server.close()` below.",
            "                # However, in the Wasm env, we don't have the `server` and",
            "                # all async tasks are running in the same event loop, `pyodide.webloop.WebLoop` in the main thread,",
            "                # so we have to cancel them explicitly so that these tasks won't run after a new app is launched.",
            "                self._queue._cancel_asyncio_tasks()",
            "                self.server_app._cancel_asyncio_tasks()",
            "            self._queue.close()",
            "            # set this before closing server to shut down heartbeats",
            "            self.is_running = False",
            "            self.app.stop_event.set()",
            "            if self.server:",
            "                self.server.close()",
            "            # So that the startup events (starting the queue)",
            "            # happen the next time the app is launched",
            "            self.app.startup_events_triggered = False",
            "            if verbose:",
            "                print(f\"Closing server running on port: {self.server_port}\")",
            "        except (AttributeError, OSError):  # can't close if not running",
            "            pass",
            "",
            "    def block_thread(",
            "        self,",
            "    ) -> None:",
            "        \"\"\"Block main thread until interrupted by user.\"\"\"",
            "        try:",
            "            while True:",
            "                time.sleep(0.1)",
            "        except (KeyboardInterrupt, OSError):",
            "            print(\"Keyboard interruption in main thread... closing server.\")",
            "            if self.server:",
            "                self.server.close()",
            "            for tunnel in CURRENT_TUNNELS:",
            "                tunnel.kill()",
            "",
            "    def attach_load_events(self):",
            "        \"\"\"Add a load event for every component whose initial value should be randomized.\"\"\"",
            "        root_context = Context.root_block",
            "        if root_context:",
            "            for component in root_context.blocks.values():",
            "                if (",
            "                    isinstance(component, components.Component)",
            "                    and component.load_event_to_attach",
            "                ):",
            "                    load_fn, triggers, inputs = component.load_event_to_attach",
            "                    has_target = len(triggers) > 0",
            "                    triggers += [(self, \"load\")]",
            "                    # Use set_event_trigger to avoid ambiguity between load class/instance method",
            "",
            "                    dep = self.default_config.set_event_trigger(",
            "                        [EventListenerMethod(*trigger) for trigger in triggers],",
            "                        load_fn,",
            "                        inputs,",
            "                        component,",
            "                        no_target=not has_target,",
            "                        show_progress=\"hidden\" if has_target else \"full\",",
            "                    )[0]",
            "                    component.load_event = dep.get_config()",
            "",
            "    def startup_events(self):",
            "        \"\"\"Events that should be run when the app containing this block starts up.\"\"\"",
            "        self._queue.start()",
            "        # So that processing can resume in case the queue was stopped",
            "        self._queue.stopped = False",
            "        self.is_running = True",
            "        self.create_limiter()",
            "",
            "    def get_api_info(self, all_endpoints: bool = False) -> dict[str, Any] | None:",
            "        \"\"\"",
            "        Gets the information needed to generate the API docs from a Blocks.",
            "        Parameters:",
            "            all_endpoints: If True, returns information about all endpoints, including those with show_api=False.",
            "        \"\"\"",
            "        config = self.config",
            "        api_info = {\"named_endpoints\": {}, \"unnamed_endpoints\": {}}",
            "",
            "        for fn in self.fns.values():",
            "            if not fn.fn or fn.api_name is False:",
            "                continue",
            "            if not all_endpoints and not fn.show_api:",
            "                continue",
            "",
            "            dependency_info = {\"parameters\": [], \"returns\": [], \"show_api\": fn.show_api}",
            "            fn_info = utils.get_function_params(fn.fn)  # type: ignore",
            "            skip_endpoint = False",
            "",
            "            inputs = fn.inputs",
            "            for index, input_block in enumerate(inputs):",
            "                for component in config[\"components\"]:",
            "                    if component[\"id\"] == input_block._id:",
            "                        break",
            "                else:",
            "                    skip_endpoint = True  # if component not found, skip endpoint",
            "                    break",
            "                type = component[\"props\"][\"name\"]",
            "                if self.blocks[component[\"id\"]].skip_api:",
            "                    continue",
            "                label = component[\"props\"].get(\"label\", f\"parameter_{input_block._id}\")",
            "                comp = self.get_component(component[\"id\"])",
            "                if not isinstance(comp, components.Component):",
            "                    raise TypeError(f\"{comp!r} is not a Component\")",
            "                info = component[\"api_info\"]",
            "                example = comp.example_inputs()",
            "                python_type = client_utils.json_schema_to_python_type(info)",
            "",
            "                # Since the clients use \"api_name\" and \"fn_index\" to designate the endpoint and",
            "                # \"result_callbacks\" to specify the callbacks, we need to make sure that no parameters",
            "                # have those names. Hence the final checks.",
            "                if (",
            "                    fn.fn",
            "                    and index < len(fn_info)",
            "                    and fn_info[index][0]",
            "                    not in [\"api_name\", \"fn_index\", \"result_callbacks\"]",
            "                ):",
            "                    parameter_name = fn_info[index][0]",
            "                else:",
            "                    parameter_name = f\"param_{index}\"",
            "",
            "                # How default values are set for the client: if a component has an initial value, then that parameter",
            "                # is optional in the client and the initial value from the config is used as default in the client.",
            "                # If the component does not have an initial value, but if the corresponding argument in the predict function has",
            "                # a default value of None, then that parameter is also optional in the client and the None is used as default in the client.",
            "                if component[\"props\"].get(\"value\") is not None:",
            "                    parameter_has_default = True",
            "                    parameter_default = component[\"props\"][\"value\"]",
            "                elif (",
            "                    fn.fn",
            "                    and index < len(fn_info)",
            "                    and fn_info[index][1]",
            "                    and fn_info[index][2] is None",
            "                ):",
            "                    parameter_has_default = True",
            "                    parameter_default = None",
            "                else:",
            "                    parameter_has_default = False",
            "                    parameter_default = None",
            "",
            "                dependency_info[\"parameters\"].append(",
            "                    {",
            "                        \"label\": label,",
            "                        \"parameter_name\": parameter_name,",
            "                        \"parameter_has_default\": parameter_has_default,",
            "                        \"parameter_default\": parameter_default,",
            "                        \"type\": info,",
            "                        \"python_type\": {",
            "                            \"type\": python_type,",
            "                            \"description\": info.get(\"description\", \"\"),",
            "                        },",
            "                        \"component\": type.capitalize(),",
            "                        \"example_input\": example,",
            "                    }",
            "                )",
            "",
            "            outputs = fn.outputs",
            "            for o in outputs:",
            "                for component in config[\"components\"]:",
            "                    if component[\"id\"] == o._id:",
            "                        break",
            "                else:",
            "                    skip_endpoint = True  # if component not found, skip endpoint",
            "                    break",
            "                type = component[\"props\"][\"name\"]",
            "                if self.blocks[component[\"id\"]].skip_api:",
            "                    continue",
            "                label = component[\"props\"].get(\"label\", f\"value_{o._id}\")",
            "                comp = self.get_component(component[\"id\"])",
            "                if not isinstance(comp, components.Component):",
            "                    raise TypeError(f\"{comp!r} is not a Component\")",
            "                info = component[\"api_info\"]",
            "                example = comp.example_inputs()",
            "                python_type = client_utils.json_schema_to_python_type(info)",
            "                dependency_info[\"returns\"].append(",
            "                    {",
            "                        \"label\": label,",
            "                        \"type\": info,",
            "                        \"python_type\": {",
            "                            \"type\": python_type,",
            "                            \"description\": info.get(\"description\", \"\"),",
            "                        },",
            "                        \"component\": type.capitalize(),",
            "                    }",
            "                )",
            "",
            "            if not skip_endpoint:",
            "                api_info[\"named_endpoints\"][f\"/{fn.api_name}\"] = dependency_info",
            "",
            "        return api_info"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import copy",
            "import dataclasses",
            "import hashlib",
            "import inspect",
            "import json",
            "import os",
            "import random",
            "import secrets",
            "import string",
            "import sys",
            "import threading",
            "import time",
            "import warnings",
            "import webbrowser",
            "from collections import defaultdict",
            "from pathlib import Path",
            "from types import ModuleType",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    AbstractSet,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Literal,",
            "    Sequence,",
            "    cast,",
            ")",
            "from urllib.parse import urlparse, urlunparse",
            "",
            "import anyio",
            "import fastapi",
            "import httpx",
            "from anyio import CapacityLimiter",
            "from gradio_client import utils as client_utils",
            "from gradio_client.documentation import document",
            "",
            "from gradio import (",
            "    analytics,",
            "    components,",
            "    networking,",
            "    processing_utils,",
            "    queueing,",
            "    routes,",
            "    strings,",
            "    themes,",
            "    utils,",
            "    wasm_utils,",
            ")",
            "from gradio.blocks_events import BlocksEvents, BlocksMeta",
            "from gradio.context import (",
            "    Context,",
            "    LocalContext,",
            "    get_blocks_context,",
            "    get_render_context,",
            "    set_render_context,",
            ")",
            "from gradio.data_classes import (",
            "    BlocksConfigDict,",
            "    DeveloperPath,",
            "    FileData,",
            "    GradioModel,",
            "    GradioRootModel,",
            ")",
            "from gradio.events import (",
            "    EventData,",
            "    EventListener,",
            "    EventListenerMethod,",
            ")",
            "from gradio.exceptions import (",
            "    DuplicateBlockError,",
            "    InvalidApiNameError,",
            "    InvalidComponentError,",
            ")",
            "from gradio.helpers import create_tracker, skip, special_args",
            "from gradio.state_holder import SessionState, StateHolder",
            "from gradio.themes import Default as DefaultTheme",
            "from gradio.themes import ThemeClass as Theme",
            "from gradio.tunneling import (",
            "    BINARY_FILENAME,",
            "    BINARY_FOLDER,",
            "    BINARY_PATH,",
            "    BINARY_URL,",
            "    CURRENT_TUNNELS,",
            ")",
            "from gradio.utils import (",
            "    TupleNoPrint,",
            "    check_function_inputs_match,",
            "    component_or_layout_class,",
            "    get_cancelled_fn_indices,",
            "    get_package_version,",
            "    get_upload_folder,",
            ")",
            "",
            "try:",
            "    import spaces  # type: ignore",
            "except Exception:",
            "    spaces = None",
            "",
            "",
            "if TYPE_CHECKING:  # Only import for type checking (is False at runtime).",
            "    from fastapi.applications import FastAPI",
            "",
            "    from gradio.components.base import Component",
            "    from gradio.renderable import Renderable",
            "",
            "BUILT_IN_THEMES: dict[str, Theme] = {",
            "    t.name: t",
            "    for t in [",
            "        themes.Base(),",
            "        themes.Default(),",
            "        themes.Monochrome(),",
            "        themes.Soft(),",
            "        themes.Glass(),",
            "    ]",
            "}",
            "",
            "",
            "class Block:",
            "    def __init__(",
            "        self,",
            "        *,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        render: bool = True,",
            "        key: int | str | None = None,",
            "        visible: bool = True,",
            "        proxy_url: str | None = None,",
            "    ):",
            "        self._id = Context.id",
            "        Context.id += 1",
            "        self.visible = visible",
            "        self.elem_id = elem_id",
            "        self.elem_classes = (",
            "            [elem_classes] if isinstance(elem_classes, str) else elem_classes",
            "        )",
            "        self.proxy_url = proxy_url",
            "        self.share_token = secrets.token_urlsafe(32)",
            "        self.parent: BlockContext | None = None",
            "        self.rendered_in: Renderable | None = None",
            "        self.is_rendered: bool = False",
            "        self._constructor_args: list[dict]",
            "        self.state_session_capacity = 10000",
            "        self.temp_files: set[str] = set()",
            "        self.GRADIO_CACHE = get_upload_folder()",
            "        self.key = key",
            "        # Keep tracks of files that should not be deleted when the delete_cache parmameter is set",
            "        # These files are the default value of the component and files that are used in examples",
            "        self.keep_in_cache = set()",
            "",
            "        if render:",
            "            self.render()",
            "",
            "    @property",
            "    def stateful(self) -> bool:",
            "        return False",
            "",
            "    @property",
            "    def skip_api(self) -> bool:",
            "        return False",
            "",
            "    @property",
            "    def constructor_args(self) -> dict[str, Any]:",
            "        \"\"\"Get the arguments passed to the component's initializer.",
            "",
            "        Only set classes whose metaclass is ComponentMeta",
            "        \"\"\"",
            "        # the _constructor_args list is appended based on the mro of the class",
            "        # so the first entry is for the bottom of the hierarchy",
            "        return self._constructor_args[0] if self._constructor_args else {}",
            "",
            "    @property",
            "    def events(",
            "        self,",
            "    ) -> list[EventListener]:",
            "        return getattr(self, \"EVENTS\", [])",
            "",
            "    def render(self):",
            "        \"\"\"",
            "        Adds self into appropriate BlockContext",
            "        \"\"\"",
            "        root_context = get_blocks_context()",
            "        render_context = get_render_context()",
            "        self.rendered_in = LocalContext.renderable.get()",
            "        if root_context is not None and self._id in root_context.blocks:",
            "            raise DuplicateBlockError(",
            "                f\"A block with id: {self._id} has already been rendered in the current Blocks.\"",
            "            )",
            "        if render_context is not None:",
            "            render_context.add(self)",
            "        if root_context is not None:",
            "            root_context.blocks[self._id] = self",
            "            self.is_rendered = True",
            "            if isinstance(self, components.Component):",
            "                root_context.root_block.temp_file_sets.append(self.temp_files)",
            "        return self",
            "",
            "    def unrender(self):",
            "        \"\"\"",
            "        Removes self from BlockContext if it has been rendered (otherwise does nothing).",
            "        Removes self from the layout and collection of blocks, but does not delete any event triggers.",
            "        \"\"\"",
            "        root_context = get_blocks_context()",
            "        render_context = get_render_context()",
            "        if render_context is not None:",
            "            try:",
            "                render_context.children.remove(self)",
            "            except ValueError:",
            "                pass",
            "        if root_context is not None:",
            "            try:",
            "                del root_context.blocks[self._id]",
            "                self.is_rendered = False",
            "            except KeyError:",
            "                pass",
            "        return self",
            "",
            "    def get_block_name(self) -> str:",
            "        \"\"\"",
            "        Gets block's class name. If it is template component it gets the parent's class name.",
            "        This is used to identify the Svelte file to use in the frontend. Override this method",
            "        if a component should use a different Svelte file than the default naming convention.",
            "        \"\"\"",
            "        return (",
            "            self.__class__.__base__.__name__.lower()  # type: ignore",
            "            if hasattr(self, \"is_template\")",
            "            else self.__class__.__name__.lower()",
            "        )",
            "",
            "    def get_block_class(self) -> str:",
            "        \"\"\"",
            "        Gets block's class name. If it is template component it gets the parent's class name.",
            "        Very similar to the get_block_name method, but this method is used to reconstruct a",
            "        Gradio app that is loaded from a Space using gr.load(). This should generally",
            "        NOT be overridden.",
            "        \"\"\"",
            "        return (",
            "            self.__class__.__base__.__name__.lower()  # type: ignore",
            "            if hasattr(self, \"is_template\")",
            "            else self.__class__.__name__.lower()",
            "        )",
            "",
            "    def get_expected_parent(self) -> type[BlockContext] | None:",
            "        return None",
            "",
            "    def get_config(self):",
            "        config = {}",
            "        signature = inspect.signature(self.__class__.__init__)",
            "        for parameter in signature.parameters.values():",
            "            if hasattr(self, parameter.name):",
            "                value = getattr(self, parameter.name)",
            "                if dataclasses.is_dataclass(value):",
            "                    value = dataclasses.asdict(value)  # type: ignore",
            "                config[parameter.name] = value",
            "        for e in self.events:",
            "            to_add = e.config_data()",
            "            if to_add:",
            "                config = {**to_add, **config}",
            "        config.pop(\"render\", None)",
            "        config = {**config, \"proxy_url\": self.proxy_url, \"name\": self.get_block_class()}",
            "        if self.rendered_in is not None:",
            "            config[\"rendered_in\"] = self.rendered_in._id",
            "        if (_selectable := getattr(self, \"_selectable\", None)) is not None:",
            "            config[\"_selectable\"] = _selectable",
            "        return config",
            "",
            "    @classmethod",
            "    def recover_kwargs(",
            "        cls, props: dict[str, Any], additional_keys: list[str] | None = None",
            "    ):",
            "        \"\"\"",
            "        Recovers kwargs from a dict of props.",
            "        \"\"\"",
            "        additional_keys = additional_keys or []",
            "        signature = inspect.signature(cls.__init__)",
            "        kwargs = {}",
            "        for parameter in signature.parameters.values():",
            "            if parameter.name in props and parameter.name not in additional_keys:",
            "                kwargs[parameter.name] = props[parameter.name]",
            "        return kwargs",
            "",
            "    async def async_move_resource_to_block_cache(",
            "        self, url_or_file_path: str | Path | None",
            "    ) -> str | None:",
            "        \"\"\"Moves a file or downloads a file from a url to a block's cache directory, adds",
            "        to to the block's temp_files, and returns the path to the file in cache. This",
            "        ensures that the file is accessible to the Block and can be served to users.",
            "",
            "        This async version of the function is used when this is being called within",
            "        a FastAPI route, as this is not blocking.",
            "        \"\"\"",
            "        if url_or_file_path is None:",
            "            return None",
            "        if isinstance(url_or_file_path, Path):",
            "            url_or_file_path = str(url_or_file_path)",
            "",
            "        if client_utils.is_http_url_like(url_or_file_path):",
            "            temp_file_path = await processing_utils.async_save_url_to_cache(",
            "                url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "            )",
            "",
            "            self.temp_files.add(temp_file_path)",
            "        else:",
            "            url_or_file_path = str(utils.abspath(url_or_file_path))",
            "            if not utils.is_in_or_equal(url_or_file_path, self.GRADIO_CACHE):",
            "                try:",
            "                    temp_file_path = processing_utils.save_file_to_cache(",
            "                        url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "                    )",
            "                except FileNotFoundError:",
            "                    # This can happen if when using gr.load() and the file is on a remote Space",
            "                    # but the file is not the `value` of the component. For example, if the file",
            "                    # is the `avatar_image` of the `Chatbot` component. In this case, we skip",
            "                    # copying the file to the cache and just use the remote file path.",
            "                    return url_or_file_path",
            "            else:",
            "                temp_file_path = url_or_file_path",
            "            self.temp_files.add(temp_file_path)",
            "",
            "        return temp_file_path",
            "",
            "    def move_resource_to_block_cache(",
            "        self, url_or_file_path: str | Path | None",
            "    ) -> str | None:",
            "        \"\"\"Moves a file or downloads a file from a url to a block's cache directory, adds",
            "        to to the block's temp_files, and returns the path to the file in cache. This",
            "        ensures that the file is accessible to the Block and can be served to users.",
            "",
            "        This sync version of the function is used when this is being called outside of",
            "        a FastAPI route, e.g. when examples are being cached.",
            "        \"\"\"",
            "        if url_or_file_path is None:",
            "            return None",
            "        if isinstance(url_or_file_path, Path):",
            "            url_or_file_path = str(url_or_file_path)",
            "",
            "        if client_utils.is_http_url_like(url_or_file_path):",
            "            temp_file_path = processing_utils.save_url_to_cache(",
            "                url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "            )",
            "",
            "            self.temp_files.add(temp_file_path)",
            "        else:",
            "            url_or_file_path = str(utils.abspath(url_or_file_path))",
            "            if not utils.is_in_or_equal(url_or_file_path, self.GRADIO_CACHE):",
            "                try:",
            "                    temp_file_path = processing_utils.save_file_to_cache(",
            "                        url_or_file_path, cache_dir=self.GRADIO_CACHE",
            "                    )",
            "                except FileNotFoundError:",
            "                    # This can happen if when using gr.load() and the file is on a remote Space",
            "                    # but the file is not the `value` of the component. For example, if the file",
            "                    # is the `avatar_image` of the `Chatbot` component. In this case, we skip",
            "                    # copying the file to the cache and just use the remote file path.",
            "                    return url_or_file_path",
            "            else:",
            "                temp_file_path = url_or_file_path",
            "            self.temp_files.add(temp_file_path)",
            "",
            "        return temp_file_path",
            "",
            "    def serve_static_file(",
            "        self, url_or_file_path: str | Path | dict | None",
            "    ) -> dict | None:",
            "        \"\"\"If a file is a local file, moves it to the block's cache directory and returns",
            "        a FileData-type dictionary corresponding to the file. If the file is a URL, returns a",
            "        FileData-type dictionary corresponding to the URL. This ensures that the file is",
            "        accessible in the frontend and can be served to users.",
            "",
            "        Examples:",
            "        >>> block.serve_static_file(\"https://gradio.app/logo.png\") -> {\"path\": \"https://gradio.app/logo.png\", \"url\": \"https://gradio.app/logo.png\"}",
            "        >>> block.serve_static_file(\"logo.png\") -> {\"path\": \"logo.png\", \"url\": \"/file=logo.png\"}",
            "        >>> block.serve_static_file({\"path\": \"logo.png\", \"url\": \"/file=logo.png\"}) -> {\"path\": \"logo.png\", \"url\": \"/file=logo.png\"}",
            "        \"\"\"",
            "        if url_or_file_path is None:",
            "            return None",
            "        if isinstance(url_or_file_path, dict):",
            "            return url_or_file_path",
            "        if isinstance(url_or_file_path, Path):",
            "            url_or_file_path = str(url_or_file_path)",
            "        if client_utils.is_http_url_like(url_or_file_path):",
            "            return FileData(path=url_or_file_path, url=url_or_file_path).model_dump()",
            "        else:",
            "            data = {\"path\": url_or_file_path}",
            "            try:",
            "                return client_utils.synchronize_async(",
            "                    processing_utils.async_move_files_to_cache, data, self",
            "                )",
            "            except AttributeError:  # Can be raised if this function is called before the Block is fully initialized.",
            "                return data",
            "",
            "",
            "class BlockContext(Block):",
            "    def __init__(",
            "        self,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        visible: bool = True,",
            "        render: bool = True,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            elem_id: An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            elem_classes: An optional string or list of strings that are assigned as the class of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            visible: If False, this will be hidden but included in the Blocks config file (its visibility can later be updated).",
            "            render: If False, this will not be included in the Blocks config file at all.",
            "        \"\"\"",
            "        self.children: list[Block] = []",
            "        Block.__init__(",
            "            self,",
            "            elem_id=elem_id,",
            "            elem_classes=elem_classes,",
            "            visible=visible,",
            "            render=render,",
            "        )",
            "",
            "    TEMPLATE_DIR = DeveloperPath(\"./templates/\")",
            "    FRONTEND_DIR = \"../../frontend/\"",
            "",
            "    @property",
            "    def skip_api(self):",
            "        return True",
            "",
            "    @classmethod",
            "    def get_component_class_id(cls) -> str:",
            "        module_name = cls.__module__",
            "        module_path = sys.modules[module_name].__file__",
            "        module_hash = hashlib.md5(f\"{cls.__name__}_{module_path}\".encode()).hexdigest()",
            "        return module_hash",
            "",
            "    @property",
            "    def component_class_id(self):",
            "        return self.get_component_class_id()",
            "",
            "    def add_child(self, child: Block):",
            "        self.children.append(child)",
            "",
            "    def __enter__(self):",
            "        render_context = get_render_context()",
            "        self.parent = render_context",
            "        set_render_context(self)",
            "        return self",
            "",
            "    def add(self, child: Block):",
            "        child.parent = self",
            "        self.children.append(child)",
            "",
            "    def fill_expected_parents(self):",
            "        root_context = get_blocks_context()",
            "        children = []",
            "        pseudo_parent = None",
            "        for child in self.children:",
            "            expected_parent = child.get_expected_parent()",
            "            if not expected_parent or isinstance(self, expected_parent):",
            "                pseudo_parent = None",
            "                children.append(child)",
            "            else:",
            "                if pseudo_parent is not None and isinstance(",
            "                    pseudo_parent, expected_parent",
            "                ):",
            "                    pseudo_parent.add_child(child)",
            "                else:",
            "                    pseudo_parent = expected_parent(render=False)",
            "                    pseudo_parent.parent = self",
            "                    children.append(pseudo_parent)",
            "                    pseudo_parent.add_child(child)",
            "                    if root_context:",
            "                        root_context.blocks[pseudo_parent._id] = pseudo_parent",
            "                child.parent = pseudo_parent",
            "        self.children = children",
            "",
            "    def __exit__(self, exc_type: type[BaseException] | None = None, *args):",
            "        set_render_context(self.parent)",
            "        if exc_type is not None:",
            "            return",
            "        if getattr(self, \"allow_expected_parents\", True):",
            "            self.fill_expected_parents()",
            "",
            "    def postprocess(self, y):",
            "        \"\"\"",
            "        Any postprocessing needed to be performed on a block context.",
            "        \"\"\"",
            "        return y",
            "",
            "",
            "class BlockFunction:",
            "    def __init__(",
            "        self,",
            "        fn: Callable | None,",
            "        inputs: Sequence[Component | BlockContext],",
            "        outputs: Sequence[Component | BlockContext],",
            "        preprocess: bool,",
            "        postprocess: bool,",
            "        inputs_as_dict: bool,",
            "        targets: list[tuple[int | None, str]],",
            "        _id: int,",
            "        batch: bool = False,",
            "        max_batch_size: int = 4,",
            "        concurrency_limit: int | None | Literal[\"default\"] = \"default\",",
            "        concurrency_id: str | None = None,",
            "        tracks_progress: bool = False,",
            "        api_name: str | Literal[False] = False,",
            "        js: str | None = None,",
            "        show_progress: Literal[\"full\", \"minimal\", \"hidden\"] = \"full\",",
            "        cancels: list[int] | None = None,",
            "        collects_event_data: bool = False,",
            "        trigger_after: int | None = None,",
            "        trigger_only_on_success: bool = False,",
            "        trigger_mode: Literal[\"always_last\", \"once\", \"multiple\"] = \"once\",",
            "        queue: bool = True,",
            "        scroll_to_output: bool = False,",
            "        show_api: bool = True,",
            "        renderable: Renderable | None = None,",
            "        rendered_in: Renderable | None = None,",
            "        is_cancel_function: bool = False,",
            "    ):",
            "        self.fn = fn",
            "        self._id = _id",
            "        self.inputs = inputs",
            "        self.outputs = outputs",
            "        self.preprocess = preprocess",
            "        self.postprocess = postprocess",
            "        self.tracks_progress = tracks_progress",
            "        self.concurrency_limit: int | None | Literal[\"default\"] = concurrency_limit",
            "        self.concurrency_id = concurrency_id or str(id(fn))",
            "        self.batch = batch",
            "        self.max_batch_size = max_batch_size",
            "        self.total_runtime = 0",
            "        self.total_runs = 0",
            "        self.inputs_as_dict = inputs_as_dict",
            "        self.targets = targets",
            "        self.name = getattr(fn, \"__name__\", \"fn\") if fn is not None else None",
            "        self.api_name = api_name",
            "        self.js = js",
            "        self.show_progress = show_progress",
            "        self.cancels = cancels or []",
            "        self.collects_event_data = collects_event_data",
            "        self.trigger_after = trigger_after",
            "        self.trigger_only_on_success = trigger_only_on_success",
            "        self.trigger_mode = trigger_mode",
            "        self.queue = False if fn is None else queue",
            "        self.scroll_to_output = False if utils.get_space() else scroll_to_output",
            "        self.show_api = show_api",
            "        self.zero_gpu = hasattr(self.fn, \"zerogpu\")",
            "        self.types_generator = inspect.isgeneratorfunction(",
            "            self.fn",
            "        ) or inspect.isasyncgenfunction(self.fn)",
            "        self.renderable = renderable",
            "        self.rendered_in = rendered_in",
            "",
            "        # We need to keep track of which events are cancel events",
            "        # so that the client can call the /cancel route directly",
            "        self.is_cancel_function = is_cancel_function",
            "",
            "        self.spaces_auto_wrap()",
            "",
            "    def spaces_auto_wrap(self):",
            "        if spaces is None:",
            "            return",
            "        if utils.get_space() is None:",
            "            return",
            "        self.fn = spaces.gradio_auto_wrap(self.fn)",
            "",
            "    def __str__(self):",
            "        return str(",
            "            {",
            "                \"fn\": self.name,",
            "                \"preprocess\": self.preprocess,",
            "                \"postprocess\": self.postprocess,",
            "            }",
            "        )",
            "",
            "    def __repr__(self):",
            "        return str(self)",
            "",
            "    def get_config(self):",
            "        return {",
            "            \"id\": self._id,",
            "            \"targets\": self.targets,",
            "            \"inputs\": [block._id for block in self.inputs],",
            "            \"outputs\": [block._id for block in self.outputs],",
            "            \"backend_fn\": self.fn is not None,",
            "            \"js\": self.js,",
            "            \"queue\": self.queue,",
            "            \"api_name\": self.api_name,",
            "            \"scroll_to_output\": self.scroll_to_output,",
            "            \"show_progress\": self.show_progress,",
            "            \"batch\": self.batch,",
            "            \"max_batch_size\": self.max_batch_size,",
            "            \"cancels\": self.cancels,",
            "            \"types\": {",
            "                \"generator\": self.types_generator,",
            "                \"cancel\": self.is_cancel_function,",
            "            },",
            "            \"collects_event_data\": self.collects_event_data,",
            "            \"trigger_after\": self.trigger_after,",
            "            \"trigger_only_on_success\": self.trigger_only_on_success,",
            "            \"trigger_mode\": self.trigger_mode,",
            "            \"show_api\": self.show_api,",
            "            \"zerogpu\": self.zero_gpu,",
            "            \"rendered_in\": self.rendered_in._id if self.rendered_in else None,",
            "        }",
            "",
            "",
            "def postprocess_update_dict(",
            "    block: Component | BlockContext, update_dict: dict, postprocess: bool = True",
            "):",
            "    \"\"\"",
            "    Converts a dictionary of updates into a format that can be sent to the frontend to update the component.",
            "    E.g. {\"value\": \"2\", \"visible\": True, \"invalid_arg\": \"hello\"}",
            "    Into -> {\"__type__\": \"update\", \"value\": 2.0, \"visible\": True}",
            "    Parameters:",
            "        block: The Block that is being updated with this update dictionary.",
            "        update_dict: The original update dictionary",
            "        postprocess: Whether to postprocess the \"value\" key of the update dictionary.",
            "    \"\"\"",
            "    value = update_dict.pop(\"value\", components._Keywords.NO_VALUE)",
            "    update_dict = {k: getattr(block, k) for k in update_dict if hasattr(block, k)}",
            "    if value is not components._Keywords.NO_VALUE:",
            "        if postprocess:",
            "            update_dict[\"value\"] = block.postprocess(value)",
            "            if isinstance(update_dict[\"value\"], (GradioModel, GradioRootModel)):",
            "                update_dict[\"value\"] = update_dict[\"value\"].model_dump()",
            "        else:",
            "            update_dict[\"value\"] = value",
            "    update_dict[\"__type__\"] = \"update\"",
            "    return update_dict",
            "",
            "",
            "def convert_component_dict_to_list(",
            "    outputs_ids: list[int], predictions: dict",
            ") -> list | dict:",
            "    \"\"\"",
            "    Converts a dictionary of component updates into a list of updates in the order of",
            "    the outputs_ids and including every output component. Leaves other types of dictionaries unchanged.",
            "    E.g. {\"textbox\": \"hello\", \"number\": {\"__type__\": \"generic_update\", \"value\": \"2\"}}",
            "    Into -> [\"hello\", {\"__type__\": \"generic_update\"}, {\"__type__\": \"generic_update\", \"value\": \"2\"}]",
            "    \"\"\"",
            "    keys_are_blocks = [isinstance(key, Block) for key in predictions]",
            "    if all(keys_are_blocks):",
            "        reordered_predictions = [skip() for _ in outputs_ids]",
            "        for component, value in predictions.items():",
            "            if component._id not in outputs_ids:",
            "                raise ValueError(",
            "                    f\"Returned component {component} not specified as output of function.\"",
            "                )",
            "            output_index = outputs_ids.index(component._id)",
            "            reordered_predictions[output_index] = value",
            "        predictions = utils.resolve_singleton(reordered_predictions)",
            "    elif any(keys_are_blocks):",
            "        raise ValueError(",
            "            \"Returned dictionary included some keys as Components. Either all keys must be Components to assign Component values, or return a List of values to assign output values in order.\"",
            "        )",
            "    return predictions",
            "",
            "",
            "class BlocksConfig:",
            "    def __init__(self, root_block: Blocks):",
            "        self._id: int = 0",
            "        self.root_block = root_block",
            "        self.blocks: dict[int, Component | Block] = {}",
            "        self.fns: dict[int, BlockFunction] = {}",
            "        self.fn_id: int = 0",
            "",
            "    def set_event_trigger(",
            "        self,",
            "        targets: Sequence[EventListenerMethod],",
            "        fn: Callable | None,",
            "        inputs: Component",
            "        | BlockContext",
            "        | Sequence[Component | BlockContext]",
            "        | AbstractSet[Component | BlockContext]",
            "        | None,",
            "        outputs: Component",
            "        | BlockContext",
            "        | Sequence[Component | BlockContext]",
            "        | AbstractSet[Component | BlockContext]",
            "        | None,",
            "        preprocess: bool = True,",
            "        postprocess: bool = True,",
            "        scroll_to_output: bool = False,",
            "        show_progress: Literal[\"full\", \"minimal\", \"hidden\"] = \"full\",",
            "        api_name: str | None | Literal[False] = None,",
            "        js: str | None = None,",
            "        no_target: bool = False,",
            "        queue: bool = True,",
            "        batch: bool = False,",
            "        max_batch_size: int = 4,",
            "        cancels: list[int] | None = None,",
            "        collects_event_data: bool | None = None,",
            "        trigger_after: int | None = None,",
            "        trigger_only_on_success: bool = False,",
            "        trigger_mode: Literal[\"once\", \"multiple\", \"always_last\"] | None = \"once\",",
            "        concurrency_limit: int | None | Literal[\"default\"] = \"default\",",
            "        concurrency_id: str | None = None,",
            "        show_api: bool = True,",
            "        renderable: Renderable | None = None,",
            "        is_cancel_function: bool = False,",
            "    ) -> tuple[BlockFunction, int]:",
            "        \"\"\"",
            "        Adds an event to the component's dependencies.",
            "        Parameters:",
            "            targets: a list of EventListenerMethod objects that define the event trigger",
            "            fn: the function to run when the event is triggered",
            "            inputs: the list of input components whose values will be passed to the function",
            "            outputs: the list of output components whose values will be updated by the function",
            "            preprocess: whether to run the preprocess methods of the input components before running the function",
            "            postprocess: whether to run the postprocess methods of the output components after running the function",
            "            scroll_to_output: whether to scroll to output of dependency on trigger",
            "            show_progress: how to show the progress animation while event is running: \"full\" shows a spinner which covers the output component area as well as a runtime display in the upper right corner, \"minimal\" only shows the runtime display, \"hidden\" shows no progress animation at all",
            "            api_name: defines how the endpoint appears in the API docs. Can be a string, None, or False. If set to a string, the endpoint will be exposed in the API docs with the given name. If None (default), the name of the function will be used as the API endpoint. If False, the endpoint will not be exposed in the API docs and downstream apps (including those that `gr.load` this app) will not be able to use this event.",
            "            js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components",
            "            no_target: if True, sets \"targets\" to [], used for the Blocks.load() event and .then() events",
            "            queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.",
            "            batch: whether this function takes in a batch of inputs",
            "            max_batch_size: the maximum batch size to send to the function",
            "            cancels: a list of other events to cancel when this event is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method.",
            "            collects_event_data: whether to collect event data for this event",
            "            trigger_after: if set, this event will be triggered after 'trigger_after' function index",
            "            trigger_only_on_success: if True, this event will only be triggered if the previous event was successful (only applies if `trigger_after` is set)",
            "            trigger_mode: If \"once\" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to \"multiple\", unlimited submissions are allowed while pending, and \"always_last\" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.",
            "            concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to \"default\" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `queue()`, which itself is 1 by default).",
            "            concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.",
            "            show_api: whether to show this event in the \"view API\" page of the Gradio app, or in the \".view_api()\" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps as well as the Clients to use this event. If fn is None, show_api will automatically be set to False.",
            "            is_cancel_function: whether this event cancels another running event.",
            "        Returns: dependency information, dependency index",
            "        \"\"\"",
            "        # Support for singular parameter",
            "        _targets = [",
            "            (",
            "                target.block._id if not no_target and target.block else None,",
            "                target.event_name,",
            "            )",
            "            for target in targets",
            "        ]",
            "        if isinstance(inputs, AbstractSet):",
            "            inputs_as_dict = True",
            "            inputs = sorted(inputs, key=lambda x: x._id)",
            "        else:",
            "            inputs_as_dict = False",
            "            if inputs is None:",
            "                inputs = []",
            "            elif not isinstance(inputs, Sequence):",
            "                inputs = [inputs]",
            "",
            "        if isinstance(outputs, AbstractSet):",
            "            outputs = sorted(outputs, key=lambda x: x._id)",
            "        elif outputs is None:",
            "            outputs = []",
            "        elif not isinstance(outputs, Sequence):",
            "            outputs = [outputs]",
            "",
            "        if fn is not None and not cancels:",
            "            check_function_inputs_match(fn, inputs, inputs_as_dict)",
            "",
            "        if _targets[0][1] in [\"change\", \"key_up\"] and trigger_mode is None:",
            "            trigger_mode = \"always_last\"",
            "        elif trigger_mode is None:",
            "            trigger_mode = \"once\"",
            "        elif trigger_mode not in [\"once\", \"multiple\", \"always_last\"]:",
            "            raise ValueError(",
            "                f\"Invalid value for parameter `trigger_mode`: {trigger_mode}. Please choose from: {['once', 'multiple', 'always_last']}\"",
            "            )",
            "",
            "        _, progress_index, event_data_index = (",
            "            special_args(fn) if fn else (None, None, None)",
            "        )",
            "",
            "        # If api_name is None or empty string, use the function name",
            "        if api_name is None or isinstance(api_name, str) and api_name.strip() == \"\":",
            "            if fn is not None:",
            "                if not hasattr(fn, \"__name__\"):",
            "                    if hasattr(fn, \"__class__\") and hasattr(fn.__class__, \"__name__\"):",
            "                        name = fn.__class__.__name__",
            "                    else:",
            "                        name = \"unnamed\"",
            "                else:",
            "                    name = fn.__name__",
            "                api_name = \"\".join(",
            "                    [s for s in name if s not in set(string.punctuation) - {\"-\", \"_\"}]",
            "                )",
            "            elif js is not None:",
            "                api_name = \"js_fn\"",
            "                show_api = False",
            "            else:",
            "                api_name = \"unnamed\"",
            "                show_api = False",
            "",
            "        if api_name is not False:",
            "            api_name = utils.append_unique_suffix(",
            "                api_name,",
            "                [",
            "                    fn.api_name",
            "                    for fn in self.fns.values()",
            "                    if isinstance(fn.api_name, str)",
            "                ],",
            "            )",
            "        else:",
            "            show_api = False",
            "",
            "        # The `show_api` parameter is False if: (1) the user explicitly sets it (2) the user sets `api_name` to False",
            "        # or (3) the user sets `fn` to None (there's no backend function)",
            "",
            "        if collects_event_data is None:",
            "            collects_event_data = event_data_index is not None",
            "",
            "        rendered_in = LocalContext.renderable.get()",
            "",
            "        block_fn = BlockFunction(",
            "            fn,",
            "            inputs,",
            "            outputs,",
            "            preprocess,",
            "            postprocess,",
            "            _id=self.fn_id,",
            "            inputs_as_dict=inputs_as_dict,",
            "            targets=_targets,",
            "            batch=batch,",
            "            max_batch_size=max_batch_size,",
            "            concurrency_limit=concurrency_limit,",
            "            concurrency_id=concurrency_id,",
            "            tracks_progress=progress_index is not None,",
            "            api_name=api_name,",
            "            js=js,",
            "            show_progress=show_progress,",
            "            cancels=cancels,",
            "            collects_event_data=collects_event_data,",
            "            trigger_after=trigger_after,",
            "            trigger_only_on_success=trigger_only_on_success,",
            "            trigger_mode=trigger_mode,",
            "            queue=queue,",
            "            scroll_to_output=scroll_to_output,",
            "            show_api=show_api,",
            "            renderable=renderable,",
            "            rendered_in=rendered_in,",
            "            is_cancel_function=is_cancel_function,",
            "        )",
            "",
            "        self.fns[self.fn_id] = block_fn",
            "        self.fn_id += 1",
            "        return block_fn, block_fn._id",
            "",
            "    def get_config(self, renderable: Renderable | None = None):",
            "        config = {}",
            "",
            "        rendered_ids = []",
            "",
            "        def get_layout(block: Block):",
            "            rendered_ids.append(block._id)",
            "            if not isinstance(block, BlockContext):",
            "                return {\"id\": block._id}",
            "            children_layout = []",
            "            for child in block.children:",
            "                children_layout.append(get_layout(child))",
            "            return {\"id\": block._id, \"children\": children_layout}",
            "",
            "        if renderable:",
            "            root_block = self.blocks[renderable.container_id]",
            "        else:",
            "            root_block = self.root_block",
            "        config[\"layout\"] = get_layout(root_block)",
            "",
            "        config[\"components\"] = []",
            "        for _id, block in self.blocks.items():",
            "            if renderable:",
            "                if _id not in rendered_ids:",
            "                    continue",
            "                if block.key:",
            "                    block.key = f\"{renderable._id}-{block.key}\"",
            "            props = block.get_config() if hasattr(block, \"get_config\") else {}",
            "            block_config = {",
            "                \"id\": _id,",
            "                \"type\": block.get_block_name(),",
            "                \"props\": utils.delete_none(props),",
            "                \"skip_api\": block.skip_api,",
            "                \"component_class_id\": getattr(block, \"component_class_id\", None),",
            "                \"key\": block.key,",
            "            }",
            "            if renderable:",
            "                block_config[\"renderable\"] = renderable._id",
            "            if not block.skip_api:",
            "                block_config[\"api_info\"] = block.api_info()  # type: ignore",
            "                # .example_inputs() has been renamed .example_payload() but",
            "                # we use the old name for backwards compatibility with custom components",
            "                # created on Gradio 4.20.0 or earlier",
            "                block_config[\"example_inputs\"] = block.example_inputs()  # type: ignore",
            "            config[\"components\"].append(block_config)",
            "",
            "        dependencies = []",
            "        for fn in self.fns.values():",
            "            if renderable is None or fn.rendered_in == renderable:",
            "                dependencies.append(fn.get_config())",
            "        config[\"dependencies\"] = dependencies",
            "        return config",
            "",
            "    def __copy__(self):",
            "        new = BlocksConfig(self.root_block)",
            "        new.blocks = copy.copy(self.blocks)",
            "        new.fns = copy.copy(self.fns)",
            "        new.fn_id = self.fn_id",
            "        return new",
            "",
            "",
            "@document(\"launch\", \"queue\", \"integrate\", \"load\", \"unload\")",
            "class Blocks(BlockContext, BlocksEvents, metaclass=BlocksMeta):",
            "    \"\"\"",
            "    Blocks is Gradio's low-level API that allows you to create more custom web",
            "    applications and demos than Interfaces (yet still entirely in Python).",
            "",
            "",
            "    Compared to the Interface class, Blocks offers more flexibility and control over:",
            "    (1) the layout of components (2) the events that",
            "    trigger the execution of functions (3) data flows (e.g. inputs can trigger outputs,",
            "    which can trigger the next level of outputs). Blocks also offers ways to group",
            "    together related demos such as with tabs.",
            "",
            "",
            "    The basic usage of Blocks is as follows: create a Blocks object, then use it as a",
            "    context (with the \"with\" statement), and then define layouts, components, or events",
            "    within the Blocks context. Finally, call the launch() method to launch the demo.",
            "",
            "    Example:",
            "        import gradio as gr",
            "        def update(name):",
            "            return f\"Welcome to Gradio, {name}!\"",
            "",
            "        with gr.Blocks() as demo:",
            "            gr.Markdown(\"Start typing below and then click **Run** to see the output.\")",
            "            with gr.Row():",
            "                inp = gr.Textbox(placeholder=\"What is your name?\")",
            "                out = gr.Textbox()",
            "            btn = gr.Button(\"Run\")",
            "            btn.click(fn=update, inputs=inp, outputs=out)",
            "",
            "        demo.launch()",
            "    Demos: blocks_hello, blocks_flipper, blocks_kinematics",
            "    Guides: blocks-and-event-listeners, controlling-layout, state-in-blocks, custom-CSS-and-JS, using-blocks-like-functions",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        theme: Theme | str | None = None,",
            "        analytics_enabled: bool | None = None,",
            "        mode: str = \"blocks\",",
            "        title: str = \"Gradio\",",
            "        css: str | None = None,",
            "        js: str | None = None,",
            "        head: str | None = None,",
            "        fill_height: bool = False,",
            "        fill_width: bool = False,",
            "        delete_cache: tuple[int, int] | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            theme: A Theme object or a string representing a theme. If a string, will look for a built-in theme with that name (e.g. \"soft\" or \"default\"), or will attempt to load a theme from the Hugging Face Hub (e.g. \"gradio/monochrome\"). If None, will use the Default theme.",
            "            analytics_enabled: Whether to allow basic telemetry. If None, will use GRADIO_ANALYTICS_ENABLED environment variable or default to True.",
            "            mode: A human-friendly name for the kind of Blocks or Interface being created. Used internally for analytics.",
            "            title: The tab title to display when this is opened in a browser window.",
            "            css: Custom css as a string or path to a css file. This css will be included in the demo webpage.",
            "            js: Custom js as a string or path to a js file. The custom js should be in the form of a single js function. This function will automatically be executed when the page loads. For more flexibility, use the head parameter to insert js inside <script> tags.",
            "            head: Custom html to insert into the head of the demo webpage. This can be used to add custom meta tags, multiple scripts, stylesheets, etc. to the page.",
            "            fill_height: Whether to vertically expand top-level child components to the height of the window. If True, expansion occurs when the scale value of the child components >= 1.",
            "            fill_width: Whether to horizontally expand to fill container fully. If False, centers and constrains app to a maximum width. Only applies if this is the outermost `Blocks` in your Gradio app.",
            "            delete_cache: A tuple corresponding [frequency, age] both expressed in number of seconds. Every `frequency` seconds, the temporary files created by this Blocks instance will be deleted if more than `age` seconds have passed since the file was created. For example, setting this to (86400, 86400) will delete temporary files every day. The cache will be deleted entirely when the server restarts. If None, no cache deletion will occur.",
            "        \"\"\"",
            "        self.limiter = None",
            "        if theme is None:",
            "            theme = DefaultTheme()",
            "        elif isinstance(theme, str):",
            "            if theme.lower() in BUILT_IN_THEMES:",
            "                theme = BUILT_IN_THEMES[theme.lower()]",
            "            else:",
            "                try:",
            "                    theme = Theme.from_hub(theme)",
            "                except Exception as e:",
            "                    warnings.warn(f\"Cannot load {theme}. Caught Exception: {str(e)}\")",
            "                    theme = DefaultTheme()",
            "        if not isinstance(theme, Theme):",
            "            warnings.warn(\"Theme should be a class loaded from gradio.themes\")",
            "            theme = DefaultTheme()",
            "        self.theme: Theme = theme",
            "        self.theme_css = theme._get_theme_css()",
            "        self.stylesheets = theme._stylesheets",
            "        theme_hasher = hashlib.sha256()",
            "        theme_hasher.update(self.theme_css.encode(\"utf-8\"))",
            "        self.theme_hash = theme_hasher.hexdigest()",
            "",
            "        self.encrypt = False",
            "        self.share = False",
            "        self.enable_queue = True",
            "        self.max_threads = 40",
            "        self.pending_streams = defaultdict(dict)",
            "        self.pending_diff_streams = defaultdict(dict)",
            "        self.show_error = True",
            "        self.head = head",
            "        self.fill_height = fill_height",
            "        self.fill_width = fill_width",
            "        self.delete_cache = delete_cache",
            "        if css is not None and os.path.exists(css):",
            "            with open(css, encoding=\"utf-8\") as css_file:",
            "                self.css = css_file.read()",
            "        else:",
            "            self.css = css",
            "        if js is not None and os.path.exists(js):",
            "            with open(js, encoding=\"utf-8\") as js_file:",
            "                self.js = js_file.read()",
            "        else:",
            "            self.js = js",
            "        self.renderables: list[Renderable] = []",
            "        self.state_holder: StateHolder",
            "",
            "        # For analytics_enabled and allow_flagging: (1) first check for",
            "        # parameter, (2) check for env variable, (3) default to True/\"manual\"",
            "        self.analytics_enabled = (",
            "            analytics_enabled",
            "            if analytics_enabled is not None",
            "            else analytics.analytics_enabled()",
            "        )",
            "        if self.analytics_enabled:",
            "            if not wasm_utils.IS_WASM:",
            "                t = threading.Thread(target=analytics.version_check)",
            "                t.start()",
            "        else:",
            "            os.environ[\"HF_HUB_DISABLE_TELEMETRY\"] = \"True\"",
            "",
            "        self.default_config = BlocksConfig(self)",
            "        super().__init__(render=False, **kwargs)",
            "",
            "        self.mode = mode",
            "        self.is_running = False",
            "        self.local_url = None",
            "        self.share_url = None",
            "        self.width = None",
            "        self.height = None",
            "        self.api_open = utils.get_space() is None",
            "",
            "        self.space_id = utils.get_space()",
            "        self.favicon_path = None",
            "        self.auth = None",
            "        self.dev_mode = bool(os.getenv(\"GRADIO_WATCH_DIRS\", \"\"))",
            "        self.app_id = random.getrandbits(64)",
            "        self.upload_file_set = set()",
            "        self.temp_file_sets = [self.upload_file_set]",
            "        self.title = title",
            "        self.show_api = not wasm_utils.IS_WASM",
            "",
            "        # Only used when an Interface is loaded from a config",
            "        self.predict = None",
            "        self.input_components = None",
            "        self.output_components = None",
            "        self.__name__ = None  # type: ignore",
            "        self.api_mode = None",
            "",
            "        self.progress_tracking = None",
            "        self.ssl_verify = True",
            "        self.allowed_paths = []",
            "        self.blocked_paths = []",
            "        self.root_path = os.environ.get(\"GRADIO_ROOT_PATH\", \"\")",
            "        self.proxy_urls = set()",
            "",
            "        if self.analytics_enabled:",
            "            is_custom_theme = not any(",
            "                self.theme.to_dict() == built_in_theme.to_dict()",
            "                for built_in_theme in BUILT_IN_THEMES.values()",
            "            )",
            "            data = {",
            "                \"mode\": self.mode,",
            "                \"custom_css\": self.css is not None,",
            "                \"theme\": self.theme.name,",
            "                \"is_custom_theme\": is_custom_theme,",
            "                \"version\": get_package_version(),",
            "            }",
            "            analytics.initiated_analytics(data)",
            "",
            "        self.queue()",
            "",
            "    @property",
            "    def blocks(self) -> dict[int, Component | Block]:",
            "        return self.default_config.blocks",
            "",
            "    @blocks.setter",
            "    def blocks(self, value: dict[int, Component | Block]):",
            "        self.default_config.blocks = value",
            "",
            "    @property",
            "    def fns(self) -> dict[int, BlockFunction]:",
            "        return self.default_config.fns",
            "",
            "    def get_component(self, id: int) -> Component | BlockContext:",
            "        comp = self.blocks[id]",
            "        if not isinstance(comp, (components.Component, BlockContext)):",
            "            raise TypeError(f\"Block with id {id} is not a Component or BlockContext\")",
            "        return comp",
            "",
            "    @property",
            "    def _is_running_in_reload_thread(self):",
            "        if wasm_utils.IS_WASM:",
            "            # Wasm (Pyodide) doesn't support threading,",
            "            # so the return value is always False.",
            "            return False",
            "",
            "        from gradio.cli.commands.reload import reload_thread",
            "",
            "        return getattr(reload_thread, \"running_reload\", False)",
            "",
            "    @classmethod",
            "    def from_config(",
            "        cls,",
            "        config: BlocksConfigDict,",
            "        fns: list[Callable],",
            "        proxy_url: str,",
            "    ) -> Blocks:",
            "        \"\"\"",
            "        Factory method that creates a Blocks from a config and list of functions. Used",
            "        internally by the gradio.external.load() method.",
            "",
            "        Parameters:",
            "        config: a dictionary containing the configuration of the Blocks.",
            "        fns: a list of functions that are used in the Blocks. Must be in the same order as the dependencies in the config.",
            "        proxy_url: an external url to use as a root URL when serving files for components in the Blocks.",
            "        \"\"\"",
            "        config = copy.deepcopy(config)",
            "        components_config = config[\"components\"]",
            "        theme = config.get(\"theme\", \"default\")",
            "        original_mapping: dict[int, Block] = {}",
            "        proxy_urls = {proxy_url}",
            "",
            "        def get_block_instance(id: int) -> Block:",
            "            for block_config in components_config:",
            "                if block_config[\"id\"] == id:",
            "                    break",
            "            else:",
            "                raise ValueError(f\"Cannot find block with id {id}\")",
            "            cls = component_or_layout_class(block_config[\"props\"][\"name\"])",
            "",
            "            # If a Gradio app B is loaded into a Gradio app A, and B itself loads a",
            "            # Gradio app C, then the proxy_urls of the components in A need to be the",
            "            # URL of C, not B. The else clause below handles this case.",
            "            if block_config[\"props\"].get(\"proxy_url\") is None:",
            "                block_config[\"props\"][\"proxy_url\"] = f\"{proxy_url}/\"",
            "            postprocessed_value = block_config[\"props\"].pop(\"value\", None)",
            "",
            "            constructor_args = cls.recover_kwargs(block_config[\"props\"])",
            "            block = cls(**constructor_args)",
            "            if postprocessed_value is not None:",
            "                block.value = postprocessed_value  # type: ignore",
            "",
            "            block_proxy_url = block_config[\"props\"][\"proxy_url\"]",
            "            block.proxy_url = block_proxy_url",
            "            proxy_urls.add(block_proxy_url)",
            "            if (",
            "                _selectable := block_config[\"props\"].pop(\"_selectable\", None)",
            "            ) is not None:",
            "                block._selectable = _selectable  # type: ignore",
            "",
            "            return block",
            "",
            "        def iterate_over_children(children_list):",
            "            for child_config in children_list:",
            "                id = child_config[\"id\"]",
            "                block = get_block_instance(id)",
            "",
            "                original_mapping[id] = block",
            "",
            "                children = child_config.get(\"children\")",
            "                if children is not None:",
            "                    if not isinstance(block, BlockContext):",
            "                        raise ValueError(",
            "                            f\"Invalid config, Block with id {id} has children but is not a BlockContext.\"",
            "                        )",
            "                    with block:",
            "                        iterate_over_children(children)",
            "",
            "        derived_fields = [\"types\"]",
            "",
            "        with Blocks(theme=theme) as blocks:",
            "            # ID 0 should be the root Blocks component",
            "            original_mapping[0] = root_block = Context.root_block or blocks",
            "",
            "            if \"layout\" in config:",
            "                iterate_over_children(config[\"layout\"][\"children\"])  #",
            "",
            "            first_dependency = None",
            "",
            "            # add the event triggers",
            "            if \"dependencies\" not in config:",
            "                raise ValueError(",
            "                    \"This config is missing the 'dependencies' field and cannot be loaded.\"",
            "                )",
            "            for dependency, fn in zip(config[\"dependencies\"], fns):",
            "                # We used to add a \"fake_event\" to the config to cache examples",
            "                # without removing it. This was causing bugs in calling gr.load",
            "                # We fixed the issue by removing \"fake_event\" from the config in examples.py",
            "                # but we still need to skip these events when loading the config to support",
            "                # older demos",
            "                if \"trigger\" in dependency and dependency[\"trigger\"] == \"fake_event\":",
            "                    continue",
            "                for field in derived_fields:",
            "                    dependency.pop(field, None)",
            "",
            "                # older versions had a separate trigger field, but now it is part of the",
            "                # targets field",
            "                _targets = dependency.pop(\"targets\")",
            "                trigger = dependency.pop(\"trigger\", None)",
            "                is_then_event = False",
            "",
            "                # This assumes that you cannot combine multiple .then() events in a single",
            "                # gr.on() event, which is true for now. If this changes, we will need to",
            "                # update this code.",
            "                if not isinstance(_targets[0], int) and _targets[0][1] in [",
            "                    \"then\",",
            "                    \"success\",",
            "                ]:",
            "                    if len(_targets) != 1:",
            "                        raise ValueError(",
            "                            \"This logic assumes that .then() events are not combined with other events in a single gr.on() event\"",
            "                        )",
            "                    is_then_event = True",
            "",
            "                dependency.pop(\"backend_fn\")",
            "                dependency.pop(\"documentation\", None)",
            "                dependency[\"inputs\"] = [",
            "                    original_mapping[i] for i in dependency[\"inputs\"]",
            "                ]",
            "                dependency[\"outputs\"] = [",
            "                    original_mapping[o] for o in dependency[\"outputs\"]",
            "                ]",
            "                dependency.pop(\"status_tracker\", None)",
            "                dependency.pop(\"zerogpu\", None)",
            "                dependency.pop(\"id\", None)",
            "                dependency.pop(\"rendered_in\", None)",
            "                dependency[\"preprocess\"] = False",
            "                dependency[\"postprocess\"] = False",
            "                if is_then_event:",
            "                    targets = [EventListenerMethod(None, \"then\")]",
            "                    dependency[\"trigger_after\"] = dependency.pop(\"trigger_after\")",
            "                    dependency[\"trigger_only_on_success\"] = dependency.pop(",
            "                        \"trigger_only_on_success\"",
            "                    )",
            "                    dependency[\"no_target\"] = True",
            "                else:",
            "                    targets = [",
            "                        getattr(",
            "                            original_mapping[",
            "                                target if isinstance(target, int) else target[0]",
            "                            ],",
            "                            trigger if isinstance(target, int) else target[1],",
            "                        )",
            "                        for target in _targets",
            "                    ]",
            "                    targets = [",
            "                        EventListenerMethod(",
            "                            t.__self__ if t.has_trigger else None,",
            "                            t.event_name,  # type: ignore",
            "                        )",
            "                        for t in targets",
            "                    ]",
            "                dependency = root_block.default_config.set_event_trigger(",
            "                    targets=targets, fn=fn, **dependency",
            "                )[0]",
            "                if first_dependency is None:",
            "                    first_dependency = dependency",
            "",
            "            # Allows some use of Interface-specific methods with loaded Spaces",
            "            if first_dependency and get_blocks_context():",
            "                blocks.predict = [fns[0]]",
            "                blocks.input_components = first_dependency.inputs",
            "                blocks.output_components = first_dependency.outputs",
            "                blocks.__name__ = \"Interface\"",
            "                blocks.api_mode = True",
            "        blocks.proxy_urls = proxy_urls",
            "        return blocks",
            "",
            "    def __str__(self):",
            "        return self.__repr__()",
            "",
            "    def __repr__(self):",
            "        num_backend_fns = len([d for d in self.fns.values() if d.fn])",
            "        repr = f\"Gradio Blocks instance: {num_backend_fns} backend functions\"",
            "        repr += f\"\\n{'-' * len(repr)}\"",
            "        for d, dependency in self.fns.items():",
            "            if dependency.fn:",
            "                repr += f\"\\nfn_index={d}\"",
            "                repr += \"\\n inputs:\"",
            "                for block in dependency.inputs:",
            "                    block = self.blocks[block._id]",
            "                    repr += f\"\\n |-{block}\"",
            "                repr += \"\\n outputs:\"",
            "                for block in dependency.outputs:",
            "                    block = self.blocks[block._id]",
            "                    repr += f\"\\n |-{block}\"",
            "        return repr",
            "",
            "    @property",
            "    def expects_oauth(self):",
            "        \"\"\"Return whether the app expects user to authenticate via OAuth.\"\"\"",
            "        return any(",
            "            isinstance(block, (components.LoginButton, components.LogoutButton))",
            "            for block in self.blocks.values()",
            "        )",
            "",
            "    def unload(self, fn: Callable[..., Any]) -> None:",
            "        \"\"\"This listener is triggered when the user closes or refreshes the tab, ending the user session.",
            "        It is useful for cleaning up resources when the app is closed.",
            "        Parameters:",
            "            fn: Callable function to run to clear resources. The function should not take any arguments and the output is not used.",
            "        Example:",
            "            import gradio as gr",
            "            with gr.Blocks() as demo:",
            "                gr.Markdown(\"# When you close the tab, hello will be printed to the console\")",
            "                demo.unload(lambda: print(\"hello\"))",
            "            demo.launch()",
            "        \"\"\"",
            "        self.default_config.set_event_trigger(",
            "            targets=[EventListenerMethod(None, \"unload\")],",
            "            fn=fn,",
            "            inputs=None,",
            "            outputs=None,",
            "            preprocess=False,",
            "            postprocess=False,",
            "            show_progress=\"hidden\",",
            "            api_name=None,",
            "            js=None,",
            "            no_target=True,",
            "            batch=False,",
            "            max_batch_size=4,",
            "            cancels=None,",
            "            collects_event_data=None,",
            "            trigger_after=None,",
            "            trigger_only_on_success=False,",
            "            trigger_mode=\"once\",",
            "            concurrency_limit=\"default\",",
            "            concurrency_id=None,",
            "            show_api=False,",
            "        )",
            "",
            "    def render(self):",
            "        root_context = get_blocks_context()",
            "        if root_context is not None and Context.root_block is not None:",
            "            if self._id in root_context.blocks:",
            "                raise DuplicateBlockError(",
            "                    f\"A block with id: {self._id} has already been rendered in the current Blocks.\"",
            "                )",
            "            overlapping_ids = set(root_context.blocks).intersection(self.blocks)",
            "            for id in overlapping_ids:",
            "                # State components are allowed to be reused between Blocks",
            "                if not isinstance(self.blocks[id], components.State):",
            "                    raise DuplicateBlockError(",
            "                        \"At least one block in this Blocks has already been rendered.\"",
            "                    )",
            "",
            "            root_context.blocks.update(self.blocks)",
            "            dependency_offset = max(root_context.fns.keys(), default=-1) + 1",
            "            existing_api_names = [",
            "                dep.api_name",
            "                for dep in root_context.fns.values()",
            "                if isinstance(dep.api_name, str)",
            "            ]",
            "            for dependency in self.fns.values():",
            "                dependency._id += dependency_offset",
            "                api_name = dependency.api_name",
            "                if isinstance(api_name, str):",
            "                    api_name_ = utils.append_unique_suffix(",
            "                        api_name,",
            "                        existing_api_names,",
            "                    )",
            "                    if api_name != api_name_:",
            "                        dependency.api_name = api_name_",
            "                dependency.cancels = [c + dependency_offset for c in dependency.cancels]",
            "                if dependency.trigger_after is not None:",
            "                    dependency.trigger_after += dependency_offset",
            "                # Recreate the cancel function so that it has the latest",
            "                # dependency fn indices. This is necessary to properly cancel",
            "                # events in the backend",
            "                if dependency.cancels:",
            "                    updated_cancels = [",
            "                        root_context.fns[i].get_config() for i in dependency.cancels",
            "                    ]",
            "                    dependency.cancels = get_cancelled_fn_indices(updated_cancels)",
            "                root_context.fns[dependency._id] = dependency",
            "            root_context.fn_id = max(root_context.fns.keys(), default=-1) + 1",
            "            Context.root_block.temp_file_sets.extend(self.temp_file_sets)",
            "            Context.root_block.proxy_urls.update(self.proxy_urls)",
            "",
            "        render_context = get_render_context()",
            "        if render_context is not None:",
            "            render_context.children.extend(self.children)",
            "        return self",
            "",
            "    def is_callable(self, fn_index: int = 0) -> bool:",
            "        \"\"\"Checks if a particular Blocks function is callable (i.e. not stateful or a generator).\"\"\"",
            "        block_fn = self.fns[fn_index]",
            "        dependency = self.fns[fn_index]",
            "",
            "        if inspect.isasyncgenfunction(block_fn.fn):",
            "            return False",
            "        if inspect.isgeneratorfunction(block_fn.fn):",
            "            return False",
            "        if any(block.stateful for block in dependency.inputs):",
            "            return False",
            "        if any(block.stateful for block in dependency.outputs):",
            "            return False",
            "",
            "        return True",
            "",
            "    def __call__(self, *inputs, fn_index: int = 0, api_name: str | None = None):",
            "        \"\"\"",
            "        Allows Blocks objects to be called as functions. Supply the parameters to the",
            "        function as positional arguments. To choose which function to call, use the",
            "        fn_index parameter, which must be a keyword argument.",
            "",
            "        Parameters:",
            "        *inputs: the parameters to pass to the function",
            "        fn_index: the index of the function to call (defaults to 0, which for Interfaces, is the default prediction function)",
            "        api_name: The api_name of the dependency to call. Will take precedence over fn_index.",
            "        \"\"\"",
            "        if api_name is not None:",
            "            inferred_fn_index = next(",
            "                (i for i, d in self.fns.items() if d.api_name == api_name),",
            "                None,",
            "            )",
            "            if inferred_fn_index is None:",
            "                raise InvalidApiNameError(",
            "                    f\"Cannot find a function with api_name {api_name}\"",
            "                )",
            "            fn_index = inferred_fn_index",
            "        if not (self.is_callable(fn_index)):",
            "            raise ValueError(",
            "                \"This function is not callable because it is either stateful or is a generator. Please use the .launch() method instead to create an interactive user interface.\"",
            "            )",
            "",
            "        inputs = list(inputs)",
            "        processed_inputs = self.serialize_data(fn_index, inputs)",
            "        fn = self.fns[fn_index]",
            "        if fn.batch:",
            "            processed_inputs = [[inp] for inp in processed_inputs]",
            "",
            "        outputs = client_utils.synchronize_async(",
            "            self.process_api,",
            "            block_fn=fn,",
            "            inputs=processed_inputs,",
            "            request=None,",
            "            state={},",
            "            explicit_call=True,",
            "        )",
            "        outputs = outputs[\"data\"]",
            "",
            "        if fn.batch:",
            "            outputs = [out[0] for out in outputs]",
            "",
            "        outputs = self.deserialize_data(fn_index, outputs)",
            "        processed_outputs = utils.resolve_singleton(outputs)",
            "",
            "        return processed_outputs",
            "",
            "    async def call_function(",
            "        self,",
            "        block_fn: BlockFunction | int,",
            "        processed_input: list[Any],",
            "        iterator: AsyncIterator[Any] | None = None,",
            "        requests: routes.Request | list[routes.Request] | None = None,",
            "        event_id: str | None = None,",
            "        event_data: EventData | None = None,",
            "        in_event_listener: bool = False,",
            "        state: SessionState | None = None,",
            "    ):",
            "        \"\"\"",
            "        Calls function with given index and preprocessed input, and measures process time.",
            "        Parameters:",
            "            fn_index: index of function to call",
            "            processed_input: preprocessed input to pass to function",
            "            iterator: iterator to use if function is a generator",
            "            requests: requests to pass to function",
            "            event_id: id of event in queue",
            "            event_data: data associated with event trigger",
            "        \"\"\"",
            "        if isinstance(block_fn, int):",
            "            block_fn = self.fns[block_fn]",
            "        if not block_fn.fn:",
            "            raise IndexError(\"function has no backend method.\")",
            "        is_generating = False",
            "        request = requests[0] if isinstance(requests, list) else requests",
            "        start = time.time()",
            "",
            "        fn = utils.get_function_with_locals(",
            "            fn=block_fn.fn,",
            "            blocks=self,",
            "            event_id=event_id,",
            "            in_event_listener=in_event_listener,",
            "            request=request,",
            "            state=state,",
            "        )",
            "",
            "        if iterator is None:  # If not a generator function that has already run",
            "            if block_fn.inputs_as_dict:",
            "                processed_input = [dict(zip(block_fn.inputs, processed_input))]",
            "",
            "            processed_input, progress_index, _ = special_args(",
            "                block_fn.fn, processed_input, request, event_data",
            "            )",
            "            progress_tracker = (",
            "                processed_input[progress_index] if progress_index is not None else None",
            "            )",
            "",
            "            if progress_tracker is not None and progress_index is not None:",
            "                progress_tracker, fn = create_tracker(fn, progress_tracker.track_tqdm)",
            "                processed_input[progress_index] = progress_tracker",
            "",
            "            if inspect.iscoroutinefunction(fn):",
            "                prediction = await fn(*processed_input)",
            "            else:",
            "                prediction = await anyio.to_thread.run_sync(  # type: ignore",
            "                    fn, *processed_input, limiter=self.limiter",
            "                )",
            "        else:",
            "            prediction = None",
            "",
            "        if inspect.isgeneratorfunction(fn) or inspect.isasyncgenfunction(fn):",
            "            try:",
            "                if iterator is None:",
            "                    iterator = cast(AsyncIterator[Any], prediction)",
            "                if inspect.isgenerator(iterator):",
            "                    iterator = utils.SyncToAsyncIterator(iterator, self.limiter)",
            "                prediction = await utils.async_iteration(iterator)",
            "                is_generating = True",
            "            except StopAsyncIteration:",
            "                n_outputs = len(block_fn.outputs)",
            "                prediction = (",
            "                    components._Keywords.FINISHED_ITERATING",
            "                    if n_outputs == 1",
            "                    else (components._Keywords.FINISHED_ITERATING,) * n_outputs",
            "                )",
            "                iterator = None",
            "",
            "        duration = time.time() - start",
            "",
            "        return {",
            "            \"prediction\": prediction,",
            "            \"duration\": duration,",
            "            \"is_generating\": is_generating,",
            "            \"iterator\": iterator,",
            "        }",
            "",
            "    def serialize_data(self, fn_index: int, inputs: list[Any]) -> list[Any]:",
            "        dependency = self.fns[fn_index]",
            "        processed_input = []",
            "",
            "        def format_file(s):",
            "            return FileData(path=s).model_dump()",
            "",
            "        for i, block in enumerate(dependency.inputs):",
            "            if not isinstance(block, components.Component):",
            "                raise InvalidComponentError(",
            "                    f\"{block.__class__} Component not a valid input component.\"",
            "                )",
            "            api_info = block.api_info()",
            "            if client_utils.value_is_file(api_info):",
            "                serialized_input = client_utils.traverse(",
            "                    inputs[i],",
            "                    format_file,",
            "                    lambda s: client_utils.is_filepath(s)",
            "                    or client_utils.is_http_url_like(s),",
            "                )",
            "            else:",
            "                serialized_input = inputs[i]",
            "            processed_input.append(serialized_input)",
            "",
            "        return processed_input",
            "",
            "    def deserialize_data(self, fn_index: int, outputs: list[Any]) -> list[Any]:",
            "        dependency = self.fns[fn_index]",
            "        predictions = []",
            "",
            "        for o, block in enumerate(dependency.outputs):",
            "            if not isinstance(block, components.Component):",
            "                raise InvalidComponentError(",
            "                    f\"{block.__class__} Component not a valid output component.\"",
            "                )",
            "",
            "            deserialized = client_utils.traverse(",
            "                outputs[o], lambda s: s[\"path\"], client_utils.is_file_obj",
            "            )",
            "            predictions.append(deserialized)",
            "",
            "        return predictions",
            "",
            "    def validate_inputs(self, block_fn: BlockFunction, inputs: list[Any]):",
            "        dep_inputs = block_fn.inputs",
            "",
            "        # This handles incorrect inputs when args are changed by a JS function",
            "        # Only check not enough args case, ignore extra arguments (for now)",
            "        # TODO: make this stricter?",
            "        if len(inputs) < len(dep_inputs):",
            "            name = (",
            "                f\" ({block_fn.name})\"",
            "                if block_fn.name and block_fn.name != \"<lambda>\"",
            "                else \"\"",
            "            )",
            "",
            "            wanted_args = []",
            "            received_args = []",
            "            for block in dep_inputs:",
            "                wanted_args.append(str(block))",
            "            for inp in inputs:",
            "                v = f'\"{inp}\"' if isinstance(inp, str) else str(inp)",
            "                received_args.append(v)",
            "",
            "            wanted = \", \".join(wanted_args)",
            "            received = \", \".join(received_args)",
            "",
            "            # JS func didn't pass enough arguments",
            "            raise ValueError(",
            "                f\"\"\"An event handler{name} didn't receive enough input values (needed: {len(dep_inputs)}, got: {len(inputs)}).",
            "Check if the event handler calls a Javascript function, and make sure its return value is correct.",
            "Wanted inputs:",
            "    [{wanted}]",
            "Received inputs:",
            "    [{received}]\"\"\"",
            "            )",
            "",
            "    async def preprocess_data(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        inputs: list[Any],",
            "        state: SessionState | None,",
            "        explicit_call: bool = False,",
            "    ):",
            "        state = state or SessionState(self)",
            "",
            "        self.validate_inputs(block_fn, inputs)",
            "",
            "        if block_fn.preprocess:",
            "            processed_input = []",
            "            for i, block in enumerate(block_fn.inputs):",
            "                if not isinstance(block, components.Component):",
            "                    raise InvalidComponentError(",
            "                        f\"{block.__class__} Component not a valid input component.\"",
            "                    )",
            "                if block.stateful:",
            "                    processed_input.append(state[block._id])",
            "                else:",
            "                    if block._id in state:",
            "                        block = state[block._id]",
            "                    inputs_cached = await processing_utils.async_move_files_to_cache(",
            "                        inputs[i],",
            "                        block,",
            "                        check_in_upload_folder=not explicit_call,",
            "                    )",
            "                    if getattr(block, \"data_model\", None) and inputs_cached is not None:",
            "                        if issubclass(block.data_model, GradioModel):  # type: ignore",
            "                            inputs_cached = block.data_model(**inputs_cached)  # type: ignore",
            "                        elif issubclass(block.data_model, GradioRootModel):  # type: ignore",
            "                            inputs_cached = block.data_model(root=inputs_cached)  # type: ignore",
            "                    processed_input.append(block.preprocess(inputs_cached))",
            "        else:",
            "            processed_input = inputs",
            "        return processed_input",
            "",
            "    def validate_outputs(self, block_fn: BlockFunction, predictions: Any | list[Any]):",
            "        dep_outputs = block_fn.outputs",
            "",
            "        if not isinstance(predictions, (list, tuple)):",
            "            predictions = [predictions]",
            "",
            "        if len(predictions) < len(dep_outputs):",
            "            name = (",
            "                f\" ({block_fn.name})\"",
            "                if block_fn.name and block_fn.name != \"<lambda>\"",
            "                else \"\"",
            "            )",
            "",
            "            wanted_args = []",
            "            received_args = []",
            "            for block in dep_outputs:",
            "                wanted_args.append(str(block))",
            "            for pred in predictions:",
            "                v = f'\"{pred}\"' if isinstance(pred, str) else str(pred)",
            "                received_args.append(v)",
            "",
            "            wanted = \", \".join(wanted_args)",
            "            received = \", \".join(received_args)",
            "",
            "            raise ValueError(",
            "                f\"\"\"An event handler{name} didn't receive enough output values (needed: {len(dep_outputs)}, received: {len(predictions)}).",
            "Wanted outputs:",
            "    [{wanted}]",
            "Received outputs:",
            "    [{received}]\"\"\"",
            "            )",
            "",
            "    async def postprocess_data(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        predictions: list | dict,",
            "        state: SessionState | None,",
            "    ) -> list[Any]:",
            "        state = state or SessionState(self)",
            "",
            "        if isinstance(predictions, dict) and len(predictions) > 0:",
            "            predictions = convert_component_dict_to_list(",
            "                [block._id for block in block_fn.outputs], predictions",
            "            )",
            "",
            "        if len(block_fn.outputs) == 1 and not block_fn.batch:",
            "            predictions = [",
            "                predictions,",
            "            ]",
            "",
            "        self.validate_outputs(block_fn, predictions)  # type: ignore",
            "",
            "        output = []",
            "        for i, block in enumerate(block_fn.outputs):",
            "            try:",
            "                if predictions[i] is components._Keywords.FINISHED_ITERATING:",
            "                    output.append(None)",
            "                    continue",
            "            except (IndexError, KeyError) as err:",
            "                raise ValueError(",
            "                    \"Number of output components does not match number \"",
            "                    f\"of values returned from from function {block_fn.name}\"",
            "                ) from err",
            "",
            "            if block.stateful:",
            "                if not utils.is_prop_update(predictions[i]):",
            "                    state[block._id] = predictions[i]",
            "                output.append(None)",
            "            else:",
            "                prediction_value = predictions[i]",
            "                if utils.is_prop_update(",
            "                    prediction_value",
            "                ):  # if update is passed directly (deprecated), remove Nones",
            "                    prediction_value = utils.delete_none(",
            "                        prediction_value, skip_value=True",
            "                    )",
            "",
            "                if isinstance(prediction_value, Block):",
            "                    prediction_value = prediction_value.constructor_args.copy()",
            "                    prediction_value[\"__type__\"] = \"update\"",
            "                if utils.is_prop_update(prediction_value):",
            "                    kwargs = state[block._id].constructor_args.copy()",
            "                    kwargs.update(prediction_value)",
            "                    kwargs.pop(\"value\", None)",
            "                    kwargs.pop(\"__type__\")",
            "                    kwargs[\"render\"] = False",
            "",
            "                    state[block._id] = block.__class__(**kwargs)",
            "",
            "                    prediction_value = postprocess_update_dict(",
            "                        block=state[block._id],",
            "                        update_dict=prediction_value,",
            "                        postprocess=block_fn.postprocess,",
            "                    )",
            "                elif block_fn.postprocess:",
            "                    if not isinstance(block, components.Component):",
            "                        raise InvalidComponentError(",
            "                            f\"{block.__class__} Component not a valid output component.\"",
            "                        )",
            "                    if block._id in state:",
            "                        block = state[block._id]",
            "                    prediction_value = block.postprocess(prediction_value)",
            "",
            "                outputs_cached = await processing_utils.async_move_files_to_cache(",
            "                    prediction_value,",
            "                    block,",
            "                    postprocess=True,",
            "                )",
            "                output.append(outputs_cached)",
            "",
            "        return output",
            "",
            "    async def handle_streaming_outputs(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        data: list,",
            "        session_hash: str | None,",
            "        run: int | None,",
            "        root_path: str | None = None,",
            "    ) -> list:",
            "        if session_hash is None or run is None:",
            "            return data",
            "        if run not in self.pending_streams[session_hash]:",
            "            self.pending_streams[session_hash][run] = {}",
            "        stream_run = self.pending_streams[session_hash][run]",
            "",
            "        for i, block in enumerate(block_fn.outputs):",
            "            output_id = block._id",
            "            if isinstance(block, components.StreamingOutput) and block.streaming:",
            "                first_chunk = output_id not in stream_run",
            "                binary_data, output_data = block.stream_output(",
            "                    data[i], f\"{session_hash}/{run}/{output_id}\", first_chunk",
            "                )",
            "                if first_chunk:",
            "                    stream_run[output_id] = []",
            "                self.pending_streams[session_hash][run][output_id].append(binary_data)",
            "                output_data = await processing_utils.async_move_files_to_cache(",
            "                    output_data,",
            "                    block,",
            "                    postprocess=True,",
            "                )",
            "                if root_path is not None:",
            "                    output_data = processing_utils.add_root_url(",
            "                        output_data, root_path, None",
            "                    )",
            "                data[i] = output_data",
            "",
            "        return data",
            "",
            "    def handle_streaming_diffs(",
            "        self,",
            "        block_fn: BlockFunction,",
            "        data: list,",
            "        session_hash: str | None,",
            "        run: int | None,",
            "        final: bool,",
            "        simple_format: bool = False,",
            "    ) -> list:",
            "        if session_hash is None or run is None:",
            "            return data",
            "        first_run = run not in self.pending_diff_streams[session_hash]",
            "        if first_run:",
            "            self.pending_diff_streams[session_hash][run] = [None] * len(data)",
            "        last_diffs = self.pending_diff_streams[session_hash][run]",
            "",
            "        for i in range(len(block_fn.outputs)):",
            "            if final:",
            "                data[i] = last_diffs[i]",
            "                continue",
            "",
            "            if first_run:",
            "                last_diffs[i] = data[i]",
            "            else:",
            "                prev_chunk = last_diffs[i]",
            "                last_diffs[i] = data[i]",
            "                if not simple_format:",
            "                    data[i] = utils.diff(prev_chunk, data[i])",
            "",
            "        if final:",
            "            del self.pending_diff_streams[session_hash][run]",
            "",
            "        return data",
            "",
            "    async def process_api(",
            "        self,",
            "        block_fn: BlockFunction | int,",
            "        inputs: list[Any],",
            "        state: SessionState | None = None,",
            "        request: routes.Request | list[routes.Request] | None = None,",
            "        iterator: AsyncIterator | None = None,",
            "        session_hash: str | None = None,",
            "        event_id: str | None = None,",
            "        event_data: EventData | None = None,",
            "        in_event_listener: bool = True,",
            "        simple_format: bool = False,",
            "        explicit_call: bool = False,",
            "        root_path: str | None = None,",
            "    ) -> dict[str, Any]:",
            "        \"\"\"",
            "        Processes API calls from the frontend. First preprocesses the data,",
            "        then runs the relevant function, then postprocesses the output.",
            "        Parameters:",
            "            fn_index: Index of function to run.",
            "            inputs: input data received from the frontend",
            "            state: data stored from stateful components for session (key is input block id)",
            "            request: the gr.Request object containing information about the network request (e.g. IP address, headers, query parameters, username)",
            "            iterators: the in-progress iterators for each generator function (key is function index)",
            "            event_id: id of event that triggered this API call",
            "            event_data: data associated with the event trigger itself",
            "            in_event_listener: whether this API call is being made in response to an event listener",
            "            explicit_call: whether this call is being made directly by calling the Blocks function, instead of through an event listener or API route",
            "            root_path: if provided, the root path of the server. All file URLs will be prefixed with this path.",
            "        Returns: None",
            "        \"\"\"",
            "        if isinstance(block_fn, int):",
            "            block_fn = self.fns[block_fn]",
            "        batch = block_fn.batch",
            "        state_ids_to_track, hashed_values = self.get_state_ids_to_track(block_fn, state)",
            "        changed_state_ids = []",
            "",
            "        if batch:",
            "            max_batch_size = block_fn.max_batch_size",
            "            batch_sizes = [len(inp) for inp in inputs]",
            "            batch_size = batch_sizes[0]",
            "            if inspect.isasyncgenfunction(block_fn.fn) or inspect.isgeneratorfunction(",
            "                block_fn.fn",
            "            ):",
            "                raise ValueError(\"Gradio does not support generators in batch mode.\")",
            "            if not all(x == batch_size for x in batch_sizes):",
            "                raise ValueError(",
            "                    f\"All inputs to a batch function must have the same length but instead have sizes: {batch_sizes}.\"",
            "                )",
            "            if batch_size > max_batch_size:",
            "                raise ValueError(",
            "                    f\"Batch size ({batch_size}) exceeds the max_batch_size for this function ({max_batch_size})\"",
            "                )",
            "            inputs = [",
            "                await self.preprocess_data(block_fn, list(i), state, explicit_call)",
            "                for i in zip(*inputs)",
            "            ]",
            "            result = await self.call_function(",
            "                block_fn,",
            "                list(zip(*inputs)),",
            "                None,",
            "                request,",
            "                event_id,",
            "                event_data,",
            "                in_event_listener,",
            "                state,",
            "            )",
            "            preds = result[\"prediction\"]",
            "            data = [",
            "                await self.postprocess_data(block_fn, list(o), state)",
            "                for o in zip(*preds)",
            "            ]",
            "            if root_path is not None:",
            "                data = processing_utils.add_root_url(data, root_path, None)  # type: ignore",
            "            data = list(zip(*data))",
            "            is_generating, iterator = None, None",
            "        else:",
            "            old_iterator = iterator",
            "            if old_iterator:",
            "                inputs = []",
            "            else:",
            "                inputs = await self.preprocess_data(",
            "                    block_fn, inputs, state, explicit_call",
            "                )",
            "            was_generating = old_iterator is not None",
            "            result = await self.call_function(",
            "                block_fn,",
            "                inputs,",
            "                old_iterator,",
            "                request,",
            "                event_id,",
            "                event_data,",
            "                in_event_listener,",
            "                state,",
            "            )",
            "            data = await self.postprocess_data(block_fn, result[\"prediction\"], state)",
            "            if state:",
            "                changed_state_ids = [",
            "                    state_id",
            "                    for hash_value, state_id in zip(hashed_values, state_ids_to_track)",
            "                    if hash_value != utils.deep_hash(state[state_id])",
            "                ]",
            "",
            "            if root_path is not None:",
            "                data = processing_utils.add_root_url(data, root_path, None)",
            "            is_generating, iterator = result[\"is_generating\"], result[\"iterator\"]",
            "            if is_generating or was_generating:",
            "                run = id(old_iterator) if was_generating else id(iterator)",
            "                data = await self.handle_streaming_outputs(",
            "                    block_fn,",
            "                    data,",
            "                    session_hash=session_hash,",
            "                    run=run,",
            "                    root_path=root_path,",
            "                )",
            "                data = self.handle_streaming_diffs(",
            "                    block_fn,",
            "                    data,",
            "                    session_hash=session_hash,",
            "                    run=run,",
            "                    final=not is_generating,",
            "                    simple_format=simple_format,",
            "                )",
            "",
            "        block_fn.total_runtime += result[\"duration\"]",
            "        block_fn.total_runs += 1",
            "        output = {",
            "            \"data\": data,",
            "            \"is_generating\": is_generating,",
            "            \"iterator\": iterator,",
            "            \"duration\": result[\"duration\"],",
            "            \"average_duration\": block_fn.total_runtime / block_fn.total_runs,",
            "            \"render_config\": None,",
            "            \"changed_state_ids\": changed_state_ids,",
            "        }",
            "        if block_fn.renderable and state:",
            "            output[\"render_config\"] = state.blocks_config.get_config(",
            "                block_fn.renderable",
            "            )",
            "            output[\"render_config\"][\"render_id\"] = block_fn.renderable._id",
            "",
            "        return output",
            "",
            "    def get_state_ids_to_track(",
            "        self, block_fn: BlockFunction, state: SessionState | None",
            "    ) -> tuple[list[int], list]:",
            "        if state is None:",
            "            return [], []",
            "        state_ids_to_track = []",
            "        hashed_values = []",
            "        for block in block_fn.outputs:",
            "            if block.stateful and any(",
            "                (block._id, \"change\") in fn.targets for fn in self.fns.values()",
            "            ):",
            "                value = state[block._id]",
            "                state_ids_to_track.append(block._id)",
            "                hashed_values.append(utils.deep_hash(value))",
            "        return state_ids_to_track, hashed_values",
            "",
            "    def create_limiter(self):",
            "        self.limiter = (",
            "            None",
            "            if self.max_threads == 40",
            "            else CapacityLimiter(total_tokens=self.max_threads)",
            "        )",
            "",
            "    def get_config(self):",
            "        return {\"type\": \"column\"}",
            "",
            "    def get_config_file(self) -> BlocksConfigDict:",
            "        config: BlocksConfigDict = {",
            "            \"version\": routes.VERSION,",
            "            \"mode\": self.mode,",
            "            \"app_id\": self.app_id,",
            "            \"dev_mode\": self.dev_mode,",
            "            \"analytics_enabled\": self.analytics_enabled,",
            "            \"components\": [],",
            "            \"css\": self.css,",
            "            \"connect_heartbeat\": False,",
            "            \"js\": self.js,",
            "            \"head\": self.head,",
            "            \"title\": self.title or \"Gradio\",",
            "            \"space_id\": self.space_id,",
            "            \"enable_queue\": True,  # launch attributes",
            "            \"show_error\": getattr(self, \"show_error\", False),",
            "            \"show_api\": self.show_api,",
            "            \"is_colab\": utils.colab_check(),",
            "            \"max_file_size\": getattr(self, \"max_file_size\", None),",
            "            \"stylesheets\": self.stylesheets,",
            "            \"theme\": self.theme.name,",
            "            \"protocol\": \"sse_v3\",",
            "            \"body_css\": {",
            "                \"body_background_fill\": self.theme._get_computed_value(",
            "                    \"body_background_fill\"",
            "                ),",
            "                \"body_text_color\": self.theme._get_computed_value(\"body_text_color\"),",
            "                \"body_background_fill_dark\": self.theme._get_computed_value(",
            "                    \"body_background_fill_dark\"",
            "                ),",
            "                \"body_text_color_dark\": self.theme._get_computed_value(",
            "                    \"body_text_color_dark\"",
            "                ),",
            "            },",
            "            \"fill_height\": self.fill_height,",
            "            \"fill_width\": self.fill_width,",
            "            \"theme_hash\": self.theme_hash,",
            "        }",
            "        config.update(self.default_config.get_config())  # type: ignore",
            "        config[\"connect_heartbeat\"] = utils.connect_heartbeat(",
            "            config, self.blocks.values()",
            "        )",
            "        return config",
            "",
            "    def __enter__(self):",
            "        render_context = get_render_context()",
            "        if render_context is None:",
            "            Context.root_block = self",
            "        self.parent = render_context",
            "        set_render_context(self)",
            "        self.exited = False",
            "        return self",
            "",
            "    def __exit__(self, exc_type: type[BaseException] | None = None, *args):",
            "        if exc_type is not None:",
            "            set_render_context(None)",
            "            Context.root_block = None",
            "            return",
            "        super().fill_expected_parents()",
            "        set_render_context(self.parent)",
            "        # Configure the load events before root_block is reset",
            "        self.attach_load_events()",
            "        if self.parent is None:",
            "            Context.root_block = None",
            "        else:",
            "            self.parent.children.extend(self.children)",
            "        self.config = self.get_config_file()",
            "        self.app = routes.App.create_app(self)",
            "        self.progress_tracking = any(",
            "            block_fn.tracks_progress for block_fn in self.fns.values()",
            "        )",
            "        self.exited = True",
            "",
            "    def clear(self):",
            "        \"\"\"Resets the layout of the Blocks object.\"\"\"",
            "        self.default_config.blocks = {}",
            "        self.default_config.fns = {}",
            "        self.children = []",
            "        return self",
            "",
            "    @document()",
            "    def queue(",
            "        self,",
            "        status_update_rate: float | Literal[\"auto\"] = \"auto\",",
            "        api_open: bool | None = None,",
            "        max_size: int | None = None,",
            "        concurrency_count: int | None = None,",
            "        *,",
            "        default_concurrency_limit: int | None | Literal[\"not_set\"] = \"not_set\",",
            "    ):",
            "        \"\"\"",
            "        By enabling the queue you can control when users know their position in the queue, and set a limit on maximum number of events allowed.",
            "        Parameters:",
            "            status_update_rate: If \"auto\", Queue will send status estimations to all clients whenever a job is finished. Otherwise Queue will send status at regular intervals set by this parameter as the number of seconds.",
            "            api_open: If True, the REST routes of the backend will be open, allowing requests made directly to those endpoints to skip the queue.",
            "            max_size: The maximum number of events the queue will store at any given moment. If the queue is full, new events will not be added and a user will receive a message saying that the queue is full. If None, the queue size will be unlimited.",
            "            concurrency_count: Deprecated. Set the concurrency_limit directly on event listeners e.g. btn.click(fn, ..., concurrency_limit=10) or gr.Interface(concurrency_limit=10). If necessary, the total number of workers can be configured via `max_threads` in launch().",
            "            default_concurrency_limit: The default value of `concurrency_limit` to use for event listeners that don't specify a value. Can be set by environment variable GRADIO_DEFAULT_CONCURRENCY_LIMIT. Defaults to 1 if not set otherwise.",
            "        Example: (Blocks)",
            "            with gr.Blocks() as demo:",
            "                button = gr.Button(label=\"Generate Image\")",
            "                button.click(fn=image_generator, inputs=gr.Textbox(), outputs=gr.Image())",
            "            demo.queue(max_size=10)",
            "            demo.launch()",
            "        Example: (Interface)",
            "            demo = gr.Interface(image_generator, gr.Textbox(), gr.Image())",
            "            demo.queue(max_size=20)",
            "            demo.launch()",
            "        \"\"\"",
            "        if concurrency_count:",
            "            raise DeprecationWarning(",
            "                \"concurrency_count has been deprecated. Set the concurrency_limit directly on event listeners e.g. btn.click(fn, ..., concurrency_limit=10) or gr.Interface(concurrency_limit=10). If necessary, the total number of workers can be configured via `max_threads` in launch().\"",
            "            )",
            "        if api_open is not None:",
            "            self.api_open = api_open",
            "        if utils.is_zero_gpu_space():",
            "            max_size = 1 if max_size is None else max_size",
            "        self._queue = queueing.Queue(",
            "            live_updates=status_update_rate == \"auto\",",
            "            concurrency_count=self.max_threads,",
            "            update_intervals=status_update_rate if status_update_rate != \"auto\" else 1,",
            "            max_size=max_size,",
            "            blocks=self,",
            "            default_concurrency_limit=default_concurrency_limit,",
            "        )",
            "        self.config = self.get_config_file()",
            "        self.app = routes.App.create_app(self)",
            "        return self",
            "",
            "    def validate_queue_settings(self):",
            "        for dep in self.fns.values():",
            "            for i in dep.cancels:",
            "                if not self.fns[i].queue:",
            "                    raise ValueError(",
            "                        \"Queue needs to be enabled! \"",
            "                        \"You may get this error by either 1) passing a function that uses the yield keyword \"",
            "                        \"into an interface without enabling the queue or 2) defining an event that cancels \"",
            "                        \"another event without enabling the queue. Both can be solved by calling .queue() \"",
            "                        \"before .launch()\"",
            "                    )",
            "            if dep.batch and dep.queue is False:",
            "                raise ValueError(\"In order to use batching, the queue must be enabled.\")",
            "",
            "    def launch(",
            "        self,",
            "        inline: bool | None = None,",
            "        inbrowser: bool = False,",
            "        share: bool | None = None,",
            "        debug: bool = False,",
            "        max_threads: int = 40,",
            "        auth: Callable | tuple[str, str] | list[tuple[str, str]] | None = None,",
            "        auth_message: str | None = None,",
            "        prevent_thread_lock: bool = False,",
            "        show_error: bool = False,",
            "        server_name: str | None = None,",
            "        server_port: int | None = None,",
            "        *,",
            "        height: int = 500,",
            "        width: int | str = \"100%\",",
            "        favicon_path: str | None = None,",
            "        ssl_keyfile: str | None = None,",
            "        ssl_certfile: str | None = None,",
            "        ssl_keyfile_password: str | None = None,",
            "        ssl_verify: bool = True,",
            "        quiet: bool = False,",
            "        show_api: bool = not wasm_utils.IS_WASM,",
            "        allowed_paths: list[str] | None = None,",
            "        blocked_paths: list[str] | None = None,",
            "        root_path: str | None = None,",
            "        app_kwargs: dict[str, Any] | None = None,",
            "        state_session_capacity: int = 10000,",
            "        share_server_address: str | None = None,",
            "        share_server_protocol: Literal[\"http\", \"https\"] | None = None,",
            "        auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "        max_file_size: str | int | None = None,",
            "        _frontend: bool = True,",
            "        enable_monitoring: bool = False,",
            "    ) -> tuple[FastAPI, str, str]:",
            "        \"\"\"",
            "        Launches a simple web server that serves the demo. Can also be used to create a",
            "        public link used by anyone to access the demo from their browser by setting share=True.",
            "",
            "        Parameters:",
            "            inline: whether to display in the gradio app inline in an iframe. Defaults to True in python notebooks; False otherwise.",
            "            inbrowser: whether to automatically launch the gradio app in a new tab on the default browser.",
            "            share: whether to create a publicly shareable link for the gradio app. Creates an SSH tunnel to make your UI accessible from anywhere. If not provided, it is set to False by default every time, except when running in Google Colab. When localhost is not accessible (e.g. Google Colab), setting share=False is not supported. Can be set by environment variable GRADIO_SHARE=True.",
            "            debug: if True, blocks the main thread from running. If running in Google Colab, this is needed to print the errors in the cell output.",
            "            auth: If provided, username and password (or list of username-password tuples) required to access app. Can also provide function that takes username and password and returns True if valid login.",
            "            auth_message: If provided, HTML message provided on login page.",
            "            prevent_thread_lock: By default, the gradio app blocks the main thread while the server is running. If set to True, the gradio app will not block and the gradio server will terminate as soon as the script finishes.",
            "            show_error: If True, any errors in the gradio app will be displayed in an alert modal and printed in the browser console log",
            "            server_port: will start gradio app on this port (if available). Can be set by environment variable GRADIO_SERVER_PORT. If None, will search for an available port starting at 7860.",
            "            server_name: to make app accessible on local network, set this to \"0.0.0.0\". Can be set by environment variable GRADIO_SERVER_NAME. If None, will use \"127.0.0.1\".",
            "            max_threads: the maximum number of total threads that the Gradio app can generate in parallel. The default is inherited from the starlette library (currently 40).",
            "            width: The width in pixels of the iframe element containing the gradio app (used if inline=True)",
            "            height: The height in pixels of the iframe element containing the gradio app (used if inline=True)",
            "            favicon_path: If a path to a file (.png, .gif, or .ico) is provided, it will be used as the favicon for the web page.",
            "            ssl_keyfile: If a path to a file is provided, will use this as the private key file to create a local server running on https.",
            "            ssl_certfile: If a path to a file is provided, will use this as the signed certificate for https. Needs to be provided if ssl_keyfile is provided.",
            "            ssl_keyfile_password: If a password is provided, will use this with the ssl certificate for https.",
            "            ssl_verify: If False, skips certificate validation which allows self-signed certificates to be used.",
            "            quiet: If True, suppresses most print statements.",
            "            show_api: If True, shows the api docs in the footer of the app. Default True.",
            "            allowed_paths: List of complete filepaths or parent directories that gradio is allowed to serve. Must be absolute paths. Warning: if you provide directories, any files in these directories or their subdirectories are accessible to all users of your app. Can be set by comma separated environment variable GRADIO_ALLOWED_PATHS.",
            "            blocked_paths: List of complete filepaths or parent directories that gradio is not allowed to serve (i.e. users of your app are not allowed to access). Must be absolute paths. Warning: takes precedence over `allowed_paths` and all other directories exposed by Gradio by default. Can be set by comma separated environment variable GRADIO_BLOCKED_PATHS.",
            "            root_path: The root path (or \"mount point\") of the application, if it's not served from the root (\"/\") of the domain. Often used when the application is behind a reverse proxy that forwards requests to the application. For example, if the application is served at \"https://example.com/myapp\", the `root_path` should be set to \"/myapp\". A full URL beginning with http:// or https:// can be provided, which will be used as the root path in its entirety. Can be set by environment variable GRADIO_ROOT_PATH. Defaults to \"\".",
            "            app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{\"docs_url\": \"/docs\"}`",
            "            state_session_capacity: The maximum number of sessions whose information to store in memory. If the number of sessions exceeds this number, the oldest sessions will be removed. Reduce capacity to reduce memory usage when using gradio.State or returning updated components from functions. Defaults to 10000.",
            "            share_server_address: Use this to specify a custom FRP server and port for sharing Gradio apps (only applies if share=True). If not provided, will use the default FRP server at https://gradio.live. See https://github.com/huggingface/frp for more information.",
            "            share_server_protocol: Use this to specify the protocol to use for the share links. Defaults to \"https\", unless a custom share_server_address is provided, in which case it defaults to \"http\". If you are using a custom share_server_address and want to use https, you must set this to \"https\".",
            "            auth_dependency: A function that takes a FastAPI request and returns a string user ID or None. If the function returns None for a specific request, that user is not authorized to access the app (they will see a 401 Unauthorized response). To be used with external authentication systems like OAuth. Cannot be used with `auth`.",
            "            max_file_size: The maximum file size in bytes that can be uploaded. Can be a string of the form \"<value><unit>\", where value is any positive integer and unit is one of \"b\", \"kb\", \"mb\", \"gb\", \"tb\". If None, no limit is set.",
            "        Returns:",
            "            app: FastAPI app object that is running the demo",
            "            local_url: Locally accessible link to the demo",
            "            share_url: Publicly accessible link to the demo (if share=True, otherwise None)",
            "        Example: (Blocks)",
            "            import gradio as gr",
            "            def reverse(text):",
            "                return text[::-1]",
            "            with gr.Blocks() as demo:",
            "                button = gr.Button(value=\"Reverse\")",
            "                button.click(reverse, gr.Textbox(), gr.Textbox())",
            "            demo.launch(share=True, auth=(\"username\", \"password\"))",
            "        Example:  (Interface)",
            "            import gradio as gr",
            "            def reverse(text):",
            "                return text[::-1]",
            "            demo = gr.Interface(reverse, \"text\", \"text\")",
            "            demo.launch(share=True, auth=(\"username\", \"password\"))",
            "        \"\"\"",
            "        from gradio.routes import App",
            "",
            "        if self._is_running_in_reload_thread:",
            "            # We have already launched the demo",
            "            return None, None, None  # type: ignore",
            "",
            "        if not self.exited:",
            "            self.__exit__()",
            "",
            "        if auth is not None and auth_dependency is not None:",
            "            raise ValueError(",
            "                \"You cannot provide both `auth` and `auth_dependency` in launch(). Please choose one.\"",
            "            )",
            "        if (",
            "            auth",
            "            and not callable(auth)",
            "            and not isinstance(auth[0], tuple)",
            "            and not isinstance(auth[0], list)",
            "        ):",
            "            self.auth = [auth]",
            "        else:",
            "            self.auth = auth",
            "",
            "        if self.auth and not callable(self.auth):",
            "            if any(not authenticable[0] for authenticable in self.auth):",
            "                warnings.warn(",
            "                    \"You have provided an empty username in `auth`. Please provide a valid username.\"",
            "                )",
            "            if any(not authenticable[1] for authenticable in self.auth):",
            "                warnings.warn(",
            "                    \"You have provided an empty password in `auth`. Please provide a valid password.\"",
            "                )",
            "",
            "        self.auth_message = auth_message",
            "        self.show_error = show_error",
            "        self.height = height",
            "        self.width = width",
            "        self.favicon_path = favicon_path",
            "        self.ssl_verify = ssl_verify",
            "        self.state_session_capacity = state_session_capacity",
            "        if root_path is None:",
            "            self.root_path = os.environ.get(\"GRADIO_ROOT_PATH\", \"\")",
            "        else:",
            "            self.root_path = root_path",
            "",
            "        self.show_api = show_api",
            "",
            "        if allowed_paths:",
            "            self.allowed_paths = allowed_paths",
            "        else:",
            "            allowed_paths_env = os.environ.get(\"GRADIO_ALLOWED_PATHS\", \"\")",
            "            if len(allowed_paths_env) > 0:",
            "                self.allowed_paths = [",
            "                    item.strip() for item in allowed_paths_env.split(\",\")",
            "                ]",
            "            else:",
            "                self.allowed_paths = []",
            "",
            "        if blocked_paths:",
            "            self.blocked_paths = blocked_paths",
            "        else:",
            "            blocked_paths_env = os.environ.get(\"GRADIO_BLOCKED_PATHS\", \"\")",
            "            if len(blocked_paths_env) > 0:",
            "                self.blocked_paths = [",
            "                    item.strip() for item in blocked_paths_env.split(\",\")",
            "                ]",
            "            else:",
            "                self.blocked_paths = []",
            "",
            "        if not isinstance(self.allowed_paths, list):",
            "            raise ValueError(\"`allowed_paths` must be a list of directories.\")",
            "        if not isinstance(self.blocked_paths, list):",
            "            raise ValueError(\"`blocked_paths` must be a list of directories.\")",
            "",
            "        self.validate_queue_settings()",
            "        self.max_file_size = utils._parse_file_size(max_file_size)",
            "",
            "        if self.dev_mode:",
            "            for block in self.blocks.values():",
            "                if block.key is None:",
            "                    block.key = f\"__{block._id}__\"",
            "",
            "        self.config = self.get_config_file()",
            "        self.max_threads = max_threads",
            "        self._queue.max_thread_count = max_threads",
            "        # self.server_app is included for backwards compatibility",
            "        self.server_app = self.app = App.create_app(",
            "            self, auth_dependency=auth_dependency, app_kwargs=app_kwargs",
            "        )",
            "",
            "        if self.is_running:",
            "            if not isinstance(self.local_url, str):",
            "                raise ValueError(f\"Invalid local_url: {self.local_url}\")",
            "            if not (quiet):",
            "                print(",
            "                    \"Rerunning server... use `close()` to stop if you need to change `launch()` parameters.\\n----\"",
            "                )",
            "        else:",
            "            if wasm_utils.IS_WASM:",
            "                server_name = \"xxx\"",
            "                server_port = 99999",
            "                local_url = \"\"",
            "                server = None",
            "                # In the Wasm environment, we only need the app object",
            "                # which the frontend app will directly communicate with through the Worker API,",
            "                # and we don't need to start a server.",
            "                wasm_utils.register_app(self.app)",
            "            else:",
            "                from gradio import http_server",
            "",
            "                (",
            "                    server_name,",
            "                    server_port,",
            "                    local_url,",
            "                    server,",
            "                ) = http_server.start_server(",
            "                    app=self.app,",
            "                    server_name=server_name,",
            "                    server_port=server_port,",
            "                    ssl_keyfile=ssl_keyfile,",
            "                    ssl_certfile=ssl_certfile,",
            "                    ssl_keyfile_password=ssl_keyfile_password,",
            "                )",
            "            self.server_name = server_name",
            "            self.local_url = local_url",
            "            self.server_port = server_port",
            "            self.server = server",
            "            self.is_running = True",
            "            self.is_colab = utils.colab_check()",
            "            self.is_kaggle = utils.kaggle_check()",
            "            self.share_server_address = share_server_address",
            "            self.share_server_protocol = share_server_protocol or (",
            "                \"http\" if share_server_address is not None else \"https\"",
            "            )",
            "",
            "            self.protocol = (",
            "                \"https\"",
            "                if self.local_url.startswith(\"https\") or self.is_colab",
            "                else \"http\"",
            "            )",
            "            if not wasm_utils.IS_WASM and not self.is_colab and not quiet:",
            "                print(",
            "                    strings.en[\"RUNNING_LOCALLY_SEPARATED\"].format(",
            "                        self.protocol, self.server_name, self.server_port",
            "                    )",
            "                )",
            "",
            "            self._queue.set_server_app(self.server_app)",
            "",
            "            if not wasm_utils.IS_WASM:",
            "                # Cannot run async functions in background other than app's scope.",
            "                # Workaround by triggering the app endpoint",
            "                httpx.get(",
            "                    f\"{self.local_url}startup-events\", verify=ssl_verify, timeout=None",
            "                )",
            "            else:",
            "                # NOTE: One benefit of the code above dispatching `startup_events()` via a self HTTP request is",
            "                # that `self._queue.start()` is called in another thread which is managed by the HTTP server, `uvicorn`",
            "                # so all the asyncio tasks created by the queue runs in an event loop in that thread and",
            "                # will be cancelled just by stopping the server.",
            "                # In contrast, in the Wasm env, we can't do that because `threading` is not supported and all async tasks will run in the same event loop, `pyodide.webloop.WebLoop` in the main thread.",
            "                # So we need to manually cancel them. See `self.close()`..",
            "                self.startup_events()",
            "",
            "        utils.launch_counter()",
            "        self.is_sagemaker = utils.sagemaker_check()",
            "        if share is None:",
            "            if self.is_colab:",
            "                if not quiet:",
            "                    print(",
            "                        \"Setting queue=True in a Colab notebook requires sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\\n\"",
            "                    )",
            "                self.share = True",
            "            elif self.is_kaggle:",
            "                if not quiet:",
            "                    print(",
            "                        \"Kaggle notebooks require sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\\n\"",
            "                    )",
            "                self.share = True",
            "            elif self.is_sagemaker:",
            "                if not quiet:",
            "                    print(",
            "                        \"Sagemaker notebooks may require sharing enabled. Setting `share=True` (you can turn this off by setting `share=False` in `launch()` explicitly).\\n\"",
            "                    )",
            "                self.share = True",
            "            else:",
            "                self.share = False",
            "                # GRADIO_SHARE environment variable for forcing 'share=True'",
            "                # GRADIO_SHARE=True => share=True",
            "                share_env = os.getenv(\"GRADIO_SHARE\")",
            "                if share_env is not None and share_env.lower() == \"true\":",
            "                    self.share = True",
            "        else:",
            "            self.share = share",
            "",
            "        if enable_monitoring:",
            "            print(",
            "                f\"Monitoring URL: {self.local_url}monitoring/{self.app.analytics_key}\"",
            "            )",
            "",
            "        # If running in a colab or not able to access localhost,",
            "        # a shareable link must be created.",
            "        if (",
            "            _frontend",
            "            and not wasm_utils.IS_WASM",
            "            and not networking.url_ok(self.local_url)",
            "            and not self.share",
            "        ):",
            "            raise ValueError(",
            "                \"When localhost is not accessible, a shareable link must be created. Please set share=True or check your proxy settings to allow access to localhost.\"",
            "            )",
            "",
            "        if self.is_colab and not quiet:",
            "            if debug:",
            "                print(strings.en[\"COLAB_DEBUG_TRUE\"])",
            "            else:",
            "                print(strings.en[\"COLAB_DEBUG_FALSE\"])",
            "            if not self.share:",
            "                print(strings.en[\"COLAB_WARNING\"].format(self.server_port))",
            "",
            "        if self.share:",
            "            if self.space_id:",
            "                warnings.warn(",
            "                    \"Setting share=True is not supported on Hugging Face Spaces\"",
            "                )",
            "                self.share = False",
            "            if wasm_utils.IS_WASM:",
            "                warnings.warn(",
            "                    \"Setting share=True is not supported in the Wasm environment\"",
            "                )",
            "                self.share = False",
            "",
            "        if self.share:",
            "            try:",
            "                if self.share_url is None:",
            "                    share_url = networking.setup_tunnel(",
            "                        local_host=self.server_name,",
            "                        local_port=self.server_port,",
            "                        share_token=self.share_token,",
            "                        share_server_address=self.share_server_address,",
            "                    )",
            "                    parsed_url = urlparse(share_url)",
            "                    self.share_url = urlunparse(",
            "                        (self.share_server_protocol,) + parsed_url[1:]",
            "                    )",
            "                print(strings.en[\"SHARE_LINK_DISPLAY\"].format(self.share_url))",
            "                if not (quiet):",
            "                    print(strings.en[\"SHARE_LINK_MESSAGE\"])",
            "            except (RuntimeError, httpx.ConnectError):",
            "                if self.analytics_enabled:",
            "                    analytics.error_analytics(\"Not able to set up tunnel\")",
            "                self.share_url = None",
            "                self.share = False",
            "                if Path(BINARY_PATH).exists():",
            "                    print(strings.en[\"COULD_NOT_GET_SHARE_LINK\"])",
            "                else:",
            "                    print(",
            "                        strings.en[\"COULD_NOT_GET_SHARE_LINK_MISSING_FILE\"].format(",
            "                            BINARY_PATH,",
            "                            BINARY_URL,",
            "                            BINARY_FILENAME,",
            "                            BINARY_FOLDER,",
            "                        )",
            "                    )",
            "        else:",
            "            if not quiet and not wasm_utils.IS_WASM:",
            "                print(strings.en[\"PUBLIC_SHARE_TRUE\"])",
            "            self.share_url = None",
            "",
            "        if inbrowser and not wasm_utils.IS_WASM:",
            "            link = self.share_url if self.share and self.share_url else self.local_url",
            "            webbrowser.open(link)",
            "",
            "        # Check if running in a Python notebook in which case, display inline",
            "        if inline is None:",
            "            inline = utils.ipython_check()",
            "        if inline:",
            "            try:",
            "                from IPython.display import HTML, Javascript, display  # type: ignore",
            "",
            "                if self.share and self.share_url:",
            "                    while not networking.url_ok(self.share_url):",
            "                        time.sleep(0.25)",
            "                    artifact = HTML(",
            "                        f'<div><iframe src=\"{self.share_url}\" width=\"{self.width}\" height=\"{self.height}\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>'",
            "                    )",
            "",
            "                elif self.is_colab:",
            "                    # modified from /usr/local/lib/python3.7/dist-packages/google/colab/output/_util.py within Colab environment",
            "                    code = \"\"\"(async (port, path, width, height, cache, element) => {",
            "                        if (!google.colab.kernel.accessAllowed && !cache) {",
            "                            return;",
            "                        }",
            "                        element.appendChild(document.createTextNode(''));",
            "                        const url = await google.colab.kernel.proxyPort(port, {cache});",
            "",
            "                        const external_link = document.createElement('div');",
            "                        external_link.innerHTML = `",
            "                            <div style=\"font-family: monospace; margin-bottom: 0.5rem\">",
            "                                Running on <a href=${new URL(path, url).toString()} target=\"_blank\">",
            "                                    https://localhost:${port}${path}",
            "                                </a>",
            "                            </div>",
            "                        `;",
            "                        element.appendChild(external_link);",
            "",
            "                        const iframe = document.createElement('iframe');",
            "                        iframe.src = new URL(path, url).toString();",
            "                        iframe.height = height;",
            "                        iframe.allow = \"autoplay; camera; microphone; clipboard-read; clipboard-write;\"",
            "                        iframe.width = width;",
            "                        iframe.style.border = 0;",
            "                        element.appendChild(iframe);",
            "                    })\"\"\" + \"({port}, {path}, {width}, {height}, {cache}, window.element)\".format(",
            "                        port=json.dumps(self.server_port),",
            "                        path=json.dumps(\"/\"),",
            "                        width=json.dumps(self.width),",
            "                        height=json.dumps(self.height),",
            "                        cache=json.dumps(False),",
            "                    )",
            "",
            "                    artifact = Javascript(code)",
            "                else:",
            "                    artifact = HTML(",
            "                        f'<div><iframe src=\"{self.local_url}\" width=\"{self.width}\" height=\"{self.height}\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>'",
            "                    )",
            "                self.artifact = artifact",
            "                display(artifact)",
            "            except ImportError:",
            "                pass",
            "",
            "        if getattr(self, \"analytics_enabled\", False):",
            "            data = {",
            "                \"launch_method\": \"browser\" if inbrowser else \"inline\",",
            "                \"is_google_colab\": self.is_colab,",
            "                \"is_sharing_on\": self.share,",
            "                \"is_space\": self.space_id is not None,",
            "                \"mode\": self.mode,",
            "            }",
            "            analytics.launched_analytics(self, data)",
            "",
            "        is_in_interactive_mode = bool(getattr(sys, \"ps1\", sys.flags.interactive))",
            "",
            "        # Block main thread if debug==True",
            "        if (",
            "            debug",
            "            or int(os.getenv(\"GRADIO_DEBUG\", \"0\")) == 1",
            "            and not wasm_utils.IS_WASM",
            "            or (",
            "                # Block main thread if running in a script to stop script from exiting",
            "                not prevent_thread_lock",
            "                and not is_in_interactive_mode",
            "                # In the Wasm env, we don't have to block the main thread because the server won't be shut down after the execution finishes.",
            "                # Moreover, we MUST NOT do it because there is only one thread in the Wasm env and blocking it will stop the subsequent code from running.",
            "                and not wasm_utils.IS_WASM",
            "            )",
            "        ):",
            "            self.block_thread()",
            "",
            "        return TupleNoPrint((self.server_app, self.local_url, self.share_url))  # type: ignore",
            "",
            "    def integrate(",
            "        self,",
            "        comet_ml=None,",
            "        wandb: ModuleType | None = None,",
            "        mlflow: ModuleType | None = None,",
            "    ) -> None:",
            "        \"\"\"",
            "        A catch-all method for integrating with other libraries. This method should be run after launch()",
            "        Parameters:",
            "            comet_ml: If a comet_ml Experiment object is provided, will integrate with the experiment and appear on Comet dashboard",
            "            wandb: If the wandb module is provided, will integrate with it and appear on WandB dashboard",
            "            mlflow: If the mlflow module  is provided, will integrate with the experiment and appear on ML Flow dashboard",
            "        \"\"\"",
            "        analytics_integration = \"\"",
            "        if comet_ml is not None:",
            "            analytics_integration = \"CometML\"",
            "            comet_ml.log_other(\"Created from\", \"Gradio\")",
            "            if self.share_url is not None:",
            "                comet_ml.log_text(f\"gradio: {self.share_url}\")",
            "                comet_ml.end()",
            "            elif self.local_url:",
            "                comet_ml.log_text(f\"gradio: {self.local_url}\")",
            "                comet_ml.end()",
            "            else:",
            "                raise ValueError(\"Please run `launch()` first.\")",
            "        if wandb is not None:",
            "            analytics_integration = \"WandB\"",
            "            if self.share_url is not None:",
            "                wandb.log(",
            "                    {",
            "                        \"Gradio panel\": wandb.Html(",
            "                            '<iframe src=\"'",
            "                            + self.share_url",
            "                            + '\" width=\"'",
            "                            + str(self.width)",
            "                            + '\" height=\"'",
            "                            + str(self.height)",
            "                            + '\" frameBorder=\"0\"></iframe>'",
            "                        )",
            "                    }",
            "                )",
            "            else:",
            "                print(",
            "                    \"The WandB integration requires you to \"",
            "                    \"`launch(share=True)` first.\"",
            "                )",
            "        if mlflow is not None:",
            "            analytics_integration = \"MLFlow\"",
            "            if self.share_url is not None:",
            "                mlflow.log_param(\"Gradio Interface Share Link\", self.share_url)",
            "            else:",
            "                mlflow.log_param(\"Gradio Interface Local Link\", self.local_url)",
            "        if self.analytics_enabled and analytics_integration:",
            "            data = {\"integration\": analytics_integration}",
            "            analytics.integration_analytics(data)",
            "",
            "    def close(self, verbose: bool = True) -> None:",
            "        \"\"\"",
            "        Closes the Interface that was launched and frees the port.",
            "        \"\"\"",
            "        try:",
            "            if wasm_utils.IS_WASM:",
            "                # NOTE:",
            "                # Normally, queue-related async tasks whose async tasks are started at the `/queue/data` endpoint function)",
            "                # are running in an event loop in the server thread,",
            "                # so they will be cancelled by `self.server.close()` below.",
            "                # However, in the Wasm env, we don't have the `server` and",
            "                # all async tasks are running in the same event loop, `pyodide.webloop.WebLoop` in the main thread,",
            "                # so we have to cancel them explicitly so that these tasks won't run after a new app is launched.",
            "                self._queue._cancel_asyncio_tasks()",
            "                self.server_app._cancel_asyncio_tasks()",
            "            self._queue.close()",
            "            # set this before closing server to shut down heartbeats",
            "            self.is_running = False",
            "            self.app.stop_event.set()",
            "            if self.server:",
            "                self.server.close()",
            "            # So that the startup events (starting the queue)",
            "            # happen the next time the app is launched",
            "            self.app.startup_events_triggered = False",
            "            if verbose:",
            "                print(f\"Closing server running on port: {self.server_port}\")",
            "        except (AttributeError, OSError):  # can't close if not running",
            "            pass",
            "",
            "    def block_thread(",
            "        self,",
            "    ) -> None:",
            "        \"\"\"Block main thread until interrupted by user.\"\"\"",
            "        try:",
            "            while True:",
            "                time.sleep(0.1)",
            "        except (KeyboardInterrupt, OSError):",
            "            print(\"Keyboard interruption in main thread... closing server.\")",
            "            if self.server:",
            "                self.server.close()",
            "            for tunnel in CURRENT_TUNNELS:",
            "                tunnel.kill()",
            "",
            "    def attach_load_events(self):",
            "        \"\"\"Add a load event for every component whose initial value should be randomized.\"\"\"",
            "        root_context = Context.root_block",
            "        if root_context:",
            "            for component in root_context.blocks.values():",
            "                if (",
            "                    isinstance(component, components.Component)",
            "                    and component.load_event_to_attach",
            "                ):",
            "                    load_fn, triggers, inputs = component.load_event_to_attach",
            "                    has_target = len(triggers) > 0",
            "                    triggers += [(self, \"load\")]",
            "                    # Use set_event_trigger to avoid ambiguity between load class/instance method",
            "",
            "                    dep = self.default_config.set_event_trigger(",
            "                        [EventListenerMethod(*trigger) for trigger in triggers],",
            "                        load_fn,",
            "                        inputs,",
            "                        component,",
            "                        no_target=not has_target,",
            "                        show_progress=\"hidden\" if has_target else \"full\",",
            "                    )[0]",
            "                    component.load_event = dep.get_config()",
            "",
            "    def startup_events(self):",
            "        \"\"\"Events that should be run when the app containing this block starts up.\"\"\"",
            "        self._queue.start()",
            "        # So that processing can resume in case the queue was stopped",
            "        self._queue.stopped = False",
            "        self.is_running = True",
            "        self.create_limiter()",
            "",
            "    def get_api_info(self, all_endpoints: bool = False) -> dict[str, Any] | None:",
            "        \"\"\"",
            "        Gets the information needed to generate the API docs from a Blocks.",
            "        Parameters:",
            "            all_endpoints: If True, returns information about all endpoints, including those with show_api=False.",
            "        \"\"\"",
            "        config = self.config",
            "        api_info = {\"named_endpoints\": {}, \"unnamed_endpoints\": {}}",
            "",
            "        for fn in self.fns.values():",
            "            if not fn.fn or fn.api_name is False:",
            "                continue",
            "            if not all_endpoints and not fn.show_api:",
            "                continue",
            "",
            "            dependency_info = {\"parameters\": [], \"returns\": [], \"show_api\": fn.show_api}",
            "            fn_info = utils.get_function_params(fn.fn)  # type: ignore",
            "            skip_endpoint = False",
            "",
            "            inputs = fn.inputs",
            "            for index, input_block in enumerate(inputs):",
            "                for component in config[\"components\"]:",
            "                    if component[\"id\"] == input_block._id:",
            "                        break",
            "                else:",
            "                    skip_endpoint = True  # if component not found, skip endpoint",
            "                    break",
            "                type = component[\"props\"][\"name\"]",
            "                if self.blocks[component[\"id\"]].skip_api:",
            "                    continue",
            "                label = component[\"props\"].get(\"label\", f\"parameter_{input_block._id}\")",
            "                comp = self.get_component(component[\"id\"])",
            "                if not isinstance(comp, components.Component):",
            "                    raise TypeError(f\"{comp!r} is not a Component\")",
            "                info = component[\"api_info\"]",
            "                example = comp.example_inputs()",
            "                python_type = client_utils.json_schema_to_python_type(info)",
            "",
            "                # Since the clients use \"api_name\" and \"fn_index\" to designate the endpoint and",
            "                # \"result_callbacks\" to specify the callbacks, we need to make sure that no parameters",
            "                # have those names. Hence the final checks.",
            "                if (",
            "                    fn.fn",
            "                    and index < len(fn_info)",
            "                    and fn_info[index][0]",
            "                    not in [\"api_name\", \"fn_index\", \"result_callbacks\"]",
            "                ):",
            "                    parameter_name = fn_info[index][0]",
            "                else:",
            "                    parameter_name = f\"param_{index}\"",
            "",
            "                # How default values are set for the client: if a component has an initial value, then that parameter",
            "                # is optional in the client and the initial value from the config is used as default in the client.",
            "                # If the component does not have an initial value, but if the corresponding argument in the predict function has",
            "                # a default value of None, then that parameter is also optional in the client and the None is used as default in the client.",
            "                if component[\"props\"].get(\"value\") is not None:",
            "                    parameter_has_default = True",
            "                    parameter_default = component[\"props\"][\"value\"]",
            "                elif (",
            "                    fn.fn",
            "                    and index < len(fn_info)",
            "                    and fn_info[index][1]",
            "                    and fn_info[index][2] is None",
            "                ):",
            "                    parameter_has_default = True",
            "                    parameter_default = None",
            "                else:",
            "                    parameter_has_default = False",
            "                    parameter_default = None",
            "",
            "                dependency_info[\"parameters\"].append(",
            "                    {",
            "                        \"label\": label,",
            "                        \"parameter_name\": parameter_name,",
            "                        \"parameter_has_default\": parameter_has_default,",
            "                        \"parameter_default\": parameter_default,",
            "                        \"type\": info,",
            "                        \"python_type\": {",
            "                            \"type\": python_type,",
            "                            \"description\": info.get(\"description\", \"\"),",
            "                        },",
            "                        \"component\": type.capitalize(),",
            "                        \"example_input\": example,",
            "                    }",
            "                )",
            "",
            "            outputs = fn.outputs",
            "            for o in outputs:",
            "                for component in config[\"components\"]:",
            "                    if component[\"id\"] == o._id:",
            "                        break",
            "                else:",
            "                    skip_endpoint = True  # if component not found, skip endpoint",
            "                    break",
            "                type = component[\"props\"][\"name\"]",
            "                if self.blocks[component[\"id\"]].skip_api:",
            "                    continue",
            "                label = component[\"props\"].get(\"label\", f\"value_{o._id}\")",
            "                comp = self.get_component(component[\"id\"])",
            "                if not isinstance(comp, components.Component):",
            "                    raise TypeError(f\"{comp!r} is not a Component\")",
            "                info = component[\"api_info\"]",
            "                example = comp.example_inputs()",
            "                python_type = client_utils.json_schema_to_python_type(info)",
            "                dependency_info[\"returns\"].append(",
            "                    {",
            "                        \"label\": label,",
            "                        \"type\": info,",
            "                        \"python_type\": {",
            "                            \"type\": python_type,",
            "                            \"description\": info.get(\"description\", \"\"),",
            "                        },",
            "                        \"component\": type.capitalize(),",
            "                    }",
            "                )",
            "",
            "            if not skip_endpoint:",
            "                api_info[\"named_endpoints\"][f\"/{fn.api_name}\"] = dependency_info",
            "",
            "        return api_info"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "59": [],
            "412": [
                "BlockContext"
            ]
        },
        "addLocation": []
    },
    "gradio/components/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from gradio import utils"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from gradio.blocks import Block, BlockContext"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from gradio.component_meta import ComponentMeta"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from gradio.data_classes import BaseModel, GradioDataModel"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from gradio.data_classes import BaseModel, DeveloperPath, GradioDataModel"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from gradio.events import EventListener"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from gradio.layouts import Form"
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from gradio.processing_utils import move_files_to_cache"
            },
            "8": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         self.component_class_id = self.__class__.get_component_class_id()"
            },
            "10": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    TEMPLATE_DIR = \"./templates/\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+    TEMPLATE_DIR = DeveloperPath(\"./templates/\")"
            },
            "13": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "     FRONTEND_DIR = \"../../frontend/\""
            },
            "14": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "     def get_config(self):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Contains all of the components that can be used with Gradio Interface / Blocks.",
            "Along with the docs for each component, you can find the names of example demos that use",
            "each component. These demos are located in the `demo` directory.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import abc",
            "import hashlib",
            "import json",
            "import sys",
            "import warnings",
            "from abc import ABC, abstractmethod",
            "from enum import Enum",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, Callable, Sequence, Type",
            "",
            "import gradio_client.utils as client_utils",
            "",
            "from gradio import utils",
            "from gradio.blocks import Block, BlockContext",
            "from gradio.component_meta import ComponentMeta",
            "from gradio.data_classes import BaseModel, GradioDataModel",
            "from gradio.events import EventListener",
            "from gradio.layouts import Form",
            "from gradio.processing_utils import move_files_to_cache",
            "",
            "if TYPE_CHECKING:",
            "    from typing import TypedDict",
            "",
            "    class DataframeData(TypedDict):",
            "        headers: list[str]",
            "        data: list[list[str | int | bool]]",
            "",
            "    from gradio.components import Timer",
            "",
            "",
            "class _Keywords(Enum):",
            "    NO_VALUE = \"NO_VALUE\"  # Used as a sentinel to determine if nothing is provided as a argument for `value` in `Component.update()`",
            "    FINISHED_ITERATING = \"FINISHED_ITERATING\"  # Used to skip processing of a component's value (needed for generators + state)",
            "",
            "",
            "class ComponentBase(ABC, metaclass=ComponentMeta):",
            "    EVENTS: list[EventListener | str] = []",
            "",
            "    @abstractmethod",
            "    def preprocess(self, payload: Any) -> Any:",
            "        \"\"\"",
            "        Any preprocessing needed to be performed on function input.",
            "        Parameters:",
            "            payload: The input data received by the component from the frontend.",
            "        Returns:",
            "            The preprocessed input data sent to the user's function in the backend.",
            "        \"\"\"",
            "        return payload",
            "",
            "    @abstractmethod",
            "    def postprocess(self, value):",
            "        \"\"\"",
            "        Any postprocessing needed to be performed on function output.",
            "        Parameters:",
            "            value: The output data received by the component from the user's function in the backend.",
            "        Returns:",
            "            The postprocessed output data sent to the frontend.",
            "        \"\"\"",
            "        return value",
            "",
            "    @abstractmethod",
            "    def process_example(self, value):",
            "        \"\"\"",
            "        Process the input data in a way that can be displayed by the examples dataset component in the front-end.",
            "",
            "        For example, only return the name of a file as opposed to a full path. Or get the head of a dataframe.",
            "        The return value must be able to be json-serializable to put in the config.",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def api_info(self) -> dict[str, list[str]]:",
            "        \"\"\"",
            "        The typing information for this component as a dictionary whose values are a list of 2 strings: [Python type, language-agnostic description].",
            "        Keys of the dictionary are: raw_input, raw_output, serialized_input, serialized_output",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def example_inputs(self) -> Any:",
            "        \"\"\"",
            "        Deprecated and replaced by `example_payload()` and `example_value()`.",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def flag(self, payload: Any | GradioDataModel, flag_dir: str | Path = \"\") -> str:",
            "        \"\"\"",
            "        Write the component's value to a format that can be stored in a csv or jsonl format for flagging.",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def read_from_flag(self, payload: Any) -> GradioDataModel | Any:",
            "        \"\"\"",
            "        Convert the data from the csv or jsonl file into the component state.",
            "        \"\"\"",
            "        return payload",
            "",
            "    @property",
            "    @abstractmethod",
            "    def skip_api(self) -> bool:",
            "        \"\"\"Whether this component should be skipped from the api return value\"\"\"",
            "",
            "    @classmethod",
            "    def has_event(cls, event: str | EventListener) -> bool:",
            "        return event in cls.EVENTS",
            "",
            "    @classmethod",
            "    def get_component_class_id(cls) -> str:",
            "        module_name = cls.__module__",
            "        module_path = sys.modules[module_name].__file__",
            "        module_hash = hashlib.md5(f\"{cls.__name__}_{module_path}\".encode()).hexdigest()",
            "        return module_hash",
            "",
            "",
            "def server(fn):",
            "    fn._is_server_fn = True",
            "    return fn",
            "",
            "",
            "class Component(ComponentBase, Block):",
            "    \"\"\"",
            "    A base class for defining methods that all input/output components should have.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        value: Any = None,",
            "        *,",
            "        label: str | None = None,",
            "        info: str | None = None,",
            "        show_label: bool | None = None,",
            "        container: bool = True,",
            "        scale: int | None = None,",
            "        min_width: int | None = None,",
            "        interactive: bool | None = None,",
            "        visible: bool = True,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        render: bool = True,",
            "        key: int | str | None = None,",
            "        load_fn: Callable | None = None,",
            "        every: Timer | float | None = None,",
            "        inputs: Component | Sequence[Component] | set[Component] | None = None,",
            "    ):",
            "        self.server_fns = [",
            "            getattr(self, value)",
            "            for value in dir(self.__class__)",
            "            if callable(getattr(self, value))",
            "            and getattr(getattr(self, value), \"_is_server_fn\", False)",
            "        ]",
            "",
            "        # Svelte components expect elem_classes to be a list",
            "        # If we don't do this, returning a new component for an",
            "        # update will break the frontend",
            "        if not elem_classes:",
            "            elem_classes = []",
            "",
            "        # This gets overridden when `select` is called",
            "        self._selectable = False",
            "        if not hasattr(self, \"data_model\"):",
            "            self.data_model: Type[GradioDataModel] | None = None",
            "",
            "        Block.__init__(",
            "            self,",
            "            elem_id=elem_id,",
            "            elem_classes=elem_classes,",
            "            visible=visible,",
            "            render=render,",
            "            key=key,",
            "        )",
            "        if isinstance(self, StreamingInput):",
            "            self.check_streamable()",
            "",
            "        self.label = label",
            "        self.info = info",
            "        if not container:",
            "            if show_label:",
            "                warnings.warn(\"show_label has no effect when container is False.\")",
            "            show_label = False",
            "        if show_label is None:",
            "            show_label = True",
            "        self.show_label = show_label",
            "        self.container = container",
            "        if scale is not None and scale != round(scale):",
            "            warnings.warn(",
            "                f\"'scale' value should be an integer. Using {scale} will cause issues.\"",
            "            )",
            "        self.scale = scale",
            "        self.min_width = min_width",
            "        self.interactive = interactive",
            "",
            "        # load_event is set in the Blocks.attach_load_events method",
            "        self.load_event: None | dict[str, Any] = None",
            "        self.load_event_to_attach: (",
            "            None",
            "            | tuple[",
            "                Callable,",
            "                list[tuple[Block, str]],",
            "                Component | Sequence[Component] | set[Component] | None,",
            "            ]",
            "        ) = None",
            "        load_fn, initial_value = self.get_load_fn_and_initial_value(value, inputs)",
            "        initial_value = self.postprocess(initial_value)",
            "        # Serialize the json value so that it gets stored in the",
            "        # config as plain json, for images/audio etc. `move_files_to_cache`",
            "        # will call model_dump",
            "        if isinstance(initial_value, BaseModel):",
            "            initial_value = initial_value.model_dump()",
            "        self.value = move_files_to_cache(",
            "            initial_value,",
            "            self,  # type: ignore",
            "            postprocess=True,",
            "            keep_in_cache=True,",
            "        )",
            "        if client_utils.is_file_obj(self.value):",
            "            self.keep_in_cache.add(self.value[\"path\"])",
            "",
            "        if callable(load_fn):",
            "            self.attach_load_event(load_fn, every, inputs)",
            "",
            "        self.component_class_id = self.__class__.get_component_class_id()",
            "",
            "    TEMPLATE_DIR = \"./templates/\"",
            "    FRONTEND_DIR = \"../../frontend/\"",
            "",
            "    def get_config(self):",
            "        config = super().get_config()",
            "        if self.info:",
            "            config[\"info\"] = self.info",
            "        if len(self.server_fns):",
            "            config[\"server_fns\"] = [fn.__name__ for fn in self.server_fns]",
            "        config.pop(\"render\", None)",
            "        return config",
            "",
            "    @property",
            "    def skip_api(self):",
            "        return False",
            "",
            "    @staticmethod",
            "    def get_load_fn_and_initial_value(value, inputs=None):",
            "        initial_value = None",
            "        if callable(value):",
            "            if not inputs:",
            "                initial_value = value()",
            "            load_fn = value",
            "        else:",
            "            initial_value = value",
            "            load_fn = None",
            "        return load_fn, initial_value",
            "",
            "    def attach_load_event(",
            "        self,",
            "        callable: Callable,",
            "        every: Timer | float | None,",
            "        inputs: Component | Sequence[Component] | set[Component] | None = None,",
            "    ):",
            "        \"\"\"Add an event that runs `callable`, optionally at interval specified by `every`.\"\"\"",
            "        if isinstance(inputs, Component):",
            "            inputs = [inputs]",
            "        changeable_events: list[tuple[Block, str]] = (",
            "            [(i, \"change\") for i in inputs if hasattr(i, \"change\")] if inputs else []",
            "        )",
            "        if isinstance(every, (int, float)):",
            "            from gradio.components import Timer",
            "",
            "            every = Timer(every)",
            "        if every:",
            "            changeable_events.append((every, \"tick\"))",
            "        self.load_event_to_attach = (",
            "            callable,",
            "            changeable_events,",
            "            inputs,",
            "        )",
            "",
            "    def process_example(self, value):",
            "        \"\"\"",
            "        Process the input data in a way that can be displayed by the examples dataset component in the front-end.",
            "        By default, this calls the `.postprocess()` method of the component. However, if the `.postprocess()` method is",
            "        computationally intensive, or returns a large payload, a custom implementation may be appropriate.",
            "",
            "        For example,  the `process_example()` method of the `gr.Audio()` component only returns the name of the file, not",
            "        the processed audio file. The `.process_example()` method of the `gr.Dataframe()` returns the head of a dataframe",
            "        instead of the full dataframe.",
            "",
            "        The return value of this method must be json-serializable to put in the config.",
            "        \"\"\"",
            "        return self.postprocess(value)",
            "",
            "    def as_example(self, value):",
            "        \"\"\"Deprecated and replaced by `process_example()`.\"\"\"",
            "        return self.process_example(value)",
            "",
            "    def example_inputs(self) -> Any:",
            "        \"\"\"Deprecated and replaced by `example_payload()` and `example_value()`.\"\"\"",
            "        return self.example_payload()",
            "",
            "    def example_payload(self) -> Any:",
            "        \"\"\"",
            "        An example input data for this component, e.g. what is passed to this component's preprocess() method.",
            "        This is used to generate the docs for the View API page for Gradio apps using this component.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def example_value(self) -> Any:",
            "        \"\"\"",
            "        An example output data for this component, e.g. what is passed to this component's postprocess() method.",
            "        This is used to generate an example value if this component is used as a template for a custom component.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def api_info(self) -> dict[str, Any]:",
            "        \"\"\"",
            "        The typing information for this component as a dictionary whose values are a list of 2 strings: [Python type, language-agnostic description].",
            "        Keys of the dictionary are: raw_input, raw_output, serialized_input, serialized_output",
            "        \"\"\"",
            "        if self.data_model is not None:",
            "            schema = self.data_model.model_json_schema()",
            "            schema.pop(\"description\", None)",
            "            return schema",
            "        raise NotImplementedError(",
            "            f\"The api_info method has not been implemented for {self.get_block_name()}\"",
            "        )",
            "",
            "    def flag(self, payload: Any, flag_dir: str | Path = \"\") -> str:",
            "        \"\"\"",
            "        Write the component's value to a format that can be stored in a csv or jsonl format for flagging.",
            "        \"\"\"",
            "        if self.data_model:",
            "            payload = self.data_model.from_json(payload)",
            "            Path(flag_dir).mkdir(exist_ok=True)",
            "            payload = payload.copy_to_dir(flag_dir).model_dump()",
            "        if isinstance(payload, BaseModel):",
            "            payload = payload.model_dump()",
            "        if not isinstance(payload, str):",
            "            payload = json.dumps(payload)",
            "        return payload",
            "",
            "    def read_from_flag(self, payload: Any):",
            "        \"\"\"",
            "        Convert the data from the csv or jsonl file into the component state.",
            "        \"\"\"",
            "        if self.data_model:",
            "            return self.data_model.from_json(json.loads(payload))",
            "        return payload",
            "",
            "",
            "class FormComponent(Component):",
            "    def get_expected_parent(self) -> type[Form] | None:",
            "        if getattr(self, \"container\", None) is False:",
            "            return None",
            "        return Form",
            "",
            "    def preprocess(self, payload: Any) -> Any:",
            "        return payload",
            "",
            "    def postprocess(self, value):",
            "        return value",
            "",
            "",
            "class StreamingOutput(metaclass=abc.ABCMeta):",
            "    def __init__(self, *args, **kwargs) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.streaming: bool",
            "",
            "    @abc.abstractmethod",
            "    def stream_output(",
            "        self, value, output_id: str, first_chunk: bool",
            "    ) -> tuple[bytes | None, Any]:",
            "        pass",
            "",
            "",
            "class StreamingInput(metaclass=abc.ABCMeta):",
            "    def __init__(self, *args, **kwargs) -> None:",
            "        super().__init__(*args, **kwargs)",
            "",
            "    @abc.abstractmethod",
            "    def check_streamable(self):",
            "        \"\"\"Used to check if streaming is supported given the input.\"\"\"",
            "        pass",
            "",
            "",
            "def component(cls_name: str, render: bool) -> Component:",
            "    obj = utils.component_or_layout_class(cls_name)(render=render)",
            "    if isinstance(obj, BlockContext):",
            "        raise ValueError(f\"Invalid component: {obj.__class__}\")",
            "    if not isinstance(obj, Component):",
            "        raise TypeError(f\"Expected a Component instance, but got {obj.__class__}\")",
            "    return obj",
            "",
            "",
            "def get_component_instance(",
            "    comp: str | dict | Component, render: bool = False, unrender: bool = False",
            ") -> Component:",
            "    \"\"\"",
            "    Returns a component instance from a string, dict, or Component object.",
            "    Parameters:",
            "        comp: the component to instantiate. If a string, must be the name of a component, e.g. \"dropdown\". If a dict, must have a \"name\" key, e.g. {\"name\": \"dropdown\", \"choices\": [\"a\", \"b\"]}. If a Component object, will be returned as is.",
            "        render: whether to render the component. If True, renders the component (if not already rendered). If False, does not do anything.",
            "        unrender: whether to unrender the component. If True, unrenders the the component (if already rendered) -- this is useful when constructing an Interface or ChatInterface inside of a Blocks. If False, does not do anything.",
            "    \"\"\"",
            "    if isinstance(comp, str):",
            "        component_obj = component(comp, render=render)",
            "    elif isinstance(comp, dict):",
            "        name = comp.pop(\"name\")",
            "        component_cls = utils.component_or_layout_class(name)",
            "        component_obj = component_cls(**comp, render=render)",
            "        if isinstance(component_obj, BlockContext):",
            "            raise ValueError(f\"Invalid component: {name}\")",
            "    elif isinstance(comp, Component):",
            "        component_obj = comp",
            "    else:",
            "        raise ValueError(",
            "            f\"Component must provided as a `str` or `dict` or `Component` but is {comp}\"",
            "        )",
            "",
            "    if render and not component_obj.is_rendered:",
            "        component_obj.render()",
            "    elif unrender and component_obj.is_rendered:",
            "        component_obj.unrender()",
            "    if not isinstance(component_obj, Component):",
            "        raise TypeError(",
            "            f\"Expected a Component instance, but got {component_obj.__class__}\"",
            "        )",
            "    return component_obj"
        ],
        "afterPatchFile": [
            "\"\"\"Contains all of the components that can be used with Gradio Interface / Blocks.",
            "Along with the docs for each component, you can find the names of example demos that use",
            "each component. These demos are located in the `demo` directory.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import abc",
            "import hashlib",
            "import json",
            "import sys",
            "import warnings",
            "from abc import ABC, abstractmethod",
            "from enum import Enum",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, Callable, Sequence, Type",
            "",
            "import gradio_client.utils as client_utils",
            "",
            "from gradio import utils",
            "from gradio.blocks import Block, BlockContext",
            "from gradio.component_meta import ComponentMeta",
            "from gradio.data_classes import BaseModel, DeveloperPath, GradioDataModel",
            "from gradio.events import EventListener",
            "from gradio.layouts import Form",
            "from gradio.processing_utils import move_files_to_cache",
            "",
            "if TYPE_CHECKING:",
            "    from typing import TypedDict",
            "",
            "    class DataframeData(TypedDict):",
            "        headers: list[str]",
            "        data: list[list[str | int | bool]]",
            "",
            "    from gradio.components import Timer",
            "",
            "",
            "class _Keywords(Enum):",
            "    NO_VALUE = \"NO_VALUE\"  # Used as a sentinel to determine if nothing is provided as a argument for `value` in `Component.update()`",
            "    FINISHED_ITERATING = \"FINISHED_ITERATING\"  # Used to skip processing of a component's value (needed for generators + state)",
            "",
            "",
            "class ComponentBase(ABC, metaclass=ComponentMeta):",
            "    EVENTS: list[EventListener | str] = []",
            "",
            "    @abstractmethod",
            "    def preprocess(self, payload: Any) -> Any:",
            "        \"\"\"",
            "        Any preprocessing needed to be performed on function input.",
            "        Parameters:",
            "            payload: The input data received by the component from the frontend.",
            "        Returns:",
            "            The preprocessed input data sent to the user's function in the backend.",
            "        \"\"\"",
            "        return payload",
            "",
            "    @abstractmethod",
            "    def postprocess(self, value):",
            "        \"\"\"",
            "        Any postprocessing needed to be performed on function output.",
            "        Parameters:",
            "            value: The output data received by the component from the user's function in the backend.",
            "        Returns:",
            "            The postprocessed output data sent to the frontend.",
            "        \"\"\"",
            "        return value",
            "",
            "    @abstractmethod",
            "    def process_example(self, value):",
            "        \"\"\"",
            "        Process the input data in a way that can be displayed by the examples dataset component in the front-end.",
            "",
            "        For example, only return the name of a file as opposed to a full path. Or get the head of a dataframe.",
            "        The return value must be able to be json-serializable to put in the config.",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def api_info(self) -> dict[str, list[str]]:",
            "        \"\"\"",
            "        The typing information for this component as a dictionary whose values are a list of 2 strings: [Python type, language-agnostic description].",
            "        Keys of the dictionary are: raw_input, raw_output, serialized_input, serialized_output",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def example_inputs(self) -> Any:",
            "        \"\"\"",
            "        Deprecated and replaced by `example_payload()` and `example_value()`.",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def flag(self, payload: Any | GradioDataModel, flag_dir: str | Path = \"\") -> str:",
            "        \"\"\"",
            "        Write the component's value to a format that can be stored in a csv or jsonl format for flagging.",
            "        \"\"\"",
            "        pass",
            "",
            "    @abstractmethod",
            "    def read_from_flag(self, payload: Any) -> GradioDataModel | Any:",
            "        \"\"\"",
            "        Convert the data from the csv or jsonl file into the component state.",
            "        \"\"\"",
            "        return payload",
            "",
            "    @property",
            "    @abstractmethod",
            "    def skip_api(self) -> bool:",
            "        \"\"\"Whether this component should be skipped from the api return value\"\"\"",
            "",
            "    @classmethod",
            "    def has_event(cls, event: str | EventListener) -> bool:",
            "        return event in cls.EVENTS",
            "",
            "    @classmethod",
            "    def get_component_class_id(cls) -> str:",
            "        module_name = cls.__module__",
            "        module_path = sys.modules[module_name].__file__",
            "        module_hash = hashlib.md5(f\"{cls.__name__}_{module_path}\".encode()).hexdigest()",
            "        return module_hash",
            "",
            "",
            "def server(fn):",
            "    fn._is_server_fn = True",
            "    return fn",
            "",
            "",
            "class Component(ComponentBase, Block):",
            "    \"\"\"",
            "    A base class for defining methods that all input/output components should have.",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        value: Any = None,",
            "        *,",
            "        label: str | None = None,",
            "        info: str | None = None,",
            "        show_label: bool | None = None,",
            "        container: bool = True,",
            "        scale: int | None = None,",
            "        min_width: int | None = None,",
            "        interactive: bool | None = None,",
            "        visible: bool = True,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        render: bool = True,",
            "        key: int | str | None = None,",
            "        load_fn: Callable | None = None,",
            "        every: Timer | float | None = None,",
            "        inputs: Component | Sequence[Component] | set[Component] | None = None,",
            "    ):",
            "        self.server_fns = [",
            "            getattr(self, value)",
            "            for value in dir(self.__class__)",
            "            if callable(getattr(self, value))",
            "            and getattr(getattr(self, value), \"_is_server_fn\", False)",
            "        ]",
            "",
            "        # Svelte components expect elem_classes to be a list",
            "        # If we don't do this, returning a new component for an",
            "        # update will break the frontend",
            "        if not elem_classes:",
            "            elem_classes = []",
            "",
            "        # This gets overridden when `select` is called",
            "        self._selectable = False",
            "        if not hasattr(self, \"data_model\"):",
            "            self.data_model: Type[GradioDataModel] | None = None",
            "",
            "        Block.__init__(",
            "            self,",
            "            elem_id=elem_id,",
            "            elem_classes=elem_classes,",
            "            visible=visible,",
            "            render=render,",
            "            key=key,",
            "        )",
            "        if isinstance(self, StreamingInput):",
            "            self.check_streamable()",
            "",
            "        self.label = label",
            "        self.info = info",
            "        if not container:",
            "            if show_label:",
            "                warnings.warn(\"show_label has no effect when container is False.\")",
            "            show_label = False",
            "        if show_label is None:",
            "            show_label = True",
            "        self.show_label = show_label",
            "        self.container = container",
            "        if scale is not None and scale != round(scale):",
            "            warnings.warn(",
            "                f\"'scale' value should be an integer. Using {scale} will cause issues.\"",
            "            )",
            "        self.scale = scale",
            "        self.min_width = min_width",
            "        self.interactive = interactive",
            "",
            "        # load_event is set in the Blocks.attach_load_events method",
            "        self.load_event: None | dict[str, Any] = None",
            "        self.load_event_to_attach: (",
            "            None",
            "            | tuple[",
            "                Callable,",
            "                list[tuple[Block, str]],",
            "                Component | Sequence[Component] | set[Component] | None,",
            "            ]",
            "        ) = None",
            "        load_fn, initial_value = self.get_load_fn_and_initial_value(value, inputs)",
            "        initial_value = self.postprocess(initial_value)",
            "        # Serialize the json value so that it gets stored in the",
            "        # config as plain json, for images/audio etc. `move_files_to_cache`",
            "        # will call model_dump",
            "        if isinstance(initial_value, BaseModel):",
            "            initial_value = initial_value.model_dump()",
            "        self.value = move_files_to_cache(",
            "            initial_value,",
            "            self,  # type: ignore",
            "            postprocess=True,",
            "            keep_in_cache=True,",
            "        )",
            "        if client_utils.is_file_obj(self.value):",
            "            self.keep_in_cache.add(self.value[\"path\"])",
            "",
            "        if callable(load_fn):",
            "            self.attach_load_event(load_fn, every, inputs)",
            "",
            "        self.component_class_id = self.__class__.get_component_class_id()",
            "",
            "    TEMPLATE_DIR = DeveloperPath(\"./templates/\")",
            "    FRONTEND_DIR = \"../../frontend/\"",
            "",
            "    def get_config(self):",
            "        config = super().get_config()",
            "        if self.info:",
            "            config[\"info\"] = self.info",
            "        if len(self.server_fns):",
            "            config[\"server_fns\"] = [fn.__name__ for fn in self.server_fns]",
            "        config.pop(\"render\", None)",
            "        return config",
            "",
            "    @property",
            "    def skip_api(self):",
            "        return False",
            "",
            "    @staticmethod",
            "    def get_load_fn_and_initial_value(value, inputs=None):",
            "        initial_value = None",
            "        if callable(value):",
            "            if not inputs:",
            "                initial_value = value()",
            "            load_fn = value",
            "        else:",
            "            initial_value = value",
            "            load_fn = None",
            "        return load_fn, initial_value",
            "",
            "    def attach_load_event(",
            "        self,",
            "        callable: Callable,",
            "        every: Timer | float | None,",
            "        inputs: Component | Sequence[Component] | set[Component] | None = None,",
            "    ):",
            "        \"\"\"Add an event that runs `callable`, optionally at interval specified by `every`.\"\"\"",
            "        if isinstance(inputs, Component):",
            "            inputs = [inputs]",
            "        changeable_events: list[tuple[Block, str]] = (",
            "            [(i, \"change\") for i in inputs if hasattr(i, \"change\")] if inputs else []",
            "        )",
            "        if isinstance(every, (int, float)):",
            "            from gradio.components import Timer",
            "",
            "            every = Timer(every)",
            "        if every:",
            "            changeable_events.append((every, \"tick\"))",
            "        self.load_event_to_attach = (",
            "            callable,",
            "            changeable_events,",
            "            inputs,",
            "        )",
            "",
            "    def process_example(self, value):",
            "        \"\"\"",
            "        Process the input data in a way that can be displayed by the examples dataset component in the front-end.",
            "        By default, this calls the `.postprocess()` method of the component. However, if the `.postprocess()` method is",
            "        computationally intensive, or returns a large payload, a custom implementation may be appropriate.",
            "",
            "        For example,  the `process_example()` method of the `gr.Audio()` component only returns the name of the file, not",
            "        the processed audio file. The `.process_example()` method of the `gr.Dataframe()` returns the head of a dataframe",
            "        instead of the full dataframe.",
            "",
            "        The return value of this method must be json-serializable to put in the config.",
            "        \"\"\"",
            "        return self.postprocess(value)",
            "",
            "    def as_example(self, value):",
            "        \"\"\"Deprecated and replaced by `process_example()`.\"\"\"",
            "        return self.process_example(value)",
            "",
            "    def example_inputs(self) -> Any:",
            "        \"\"\"Deprecated and replaced by `example_payload()` and `example_value()`.\"\"\"",
            "        return self.example_payload()",
            "",
            "    def example_payload(self) -> Any:",
            "        \"\"\"",
            "        An example input data for this component, e.g. what is passed to this component's preprocess() method.",
            "        This is used to generate the docs for the View API page for Gradio apps using this component.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def example_value(self) -> Any:",
            "        \"\"\"",
            "        An example output data for this component, e.g. what is passed to this component's postprocess() method.",
            "        This is used to generate an example value if this component is used as a template for a custom component.",
            "        \"\"\"",
            "        raise NotImplementedError()",
            "",
            "    def api_info(self) -> dict[str, Any]:",
            "        \"\"\"",
            "        The typing information for this component as a dictionary whose values are a list of 2 strings: [Python type, language-agnostic description].",
            "        Keys of the dictionary are: raw_input, raw_output, serialized_input, serialized_output",
            "        \"\"\"",
            "        if self.data_model is not None:",
            "            schema = self.data_model.model_json_schema()",
            "            schema.pop(\"description\", None)",
            "            return schema",
            "        raise NotImplementedError(",
            "            f\"The api_info method has not been implemented for {self.get_block_name()}\"",
            "        )",
            "",
            "    def flag(self, payload: Any, flag_dir: str | Path = \"\") -> str:",
            "        \"\"\"",
            "        Write the component's value to a format that can be stored in a csv or jsonl format for flagging.",
            "        \"\"\"",
            "        if self.data_model:",
            "            payload = self.data_model.from_json(payload)",
            "            Path(flag_dir).mkdir(exist_ok=True)",
            "            payload = payload.copy_to_dir(flag_dir).model_dump()",
            "        if isinstance(payload, BaseModel):",
            "            payload = payload.model_dump()",
            "        if not isinstance(payload, str):",
            "            payload = json.dumps(payload)",
            "        return payload",
            "",
            "    def read_from_flag(self, payload: Any):",
            "        \"\"\"",
            "        Convert the data from the csv or jsonl file into the component state.",
            "        \"\"\"",
            "        if self.data_model:",
            "            return self.data_model.from_json(json.loads(payload))",
            "        return payload",
            "",
            "",
            "class FormComponent(Component):",
            "    def get_expected_parent(self) -> type[Form] | None:",
            "        if getattr(self, \"container\", None) is False:",
            "            return None",
            "        return Form",
            "",
            "    def preprocess(self, payload: Any) -> Any:",
            "        return payload",
            "",
            "    def postprocess(self, value):",
            "        return value",
            "",
            "",
            "class StreamingOutput(metaclass=abc.ABCMeta):",
            "    def __init__(self, *args, **kwargs) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.streaming: bool",
            "",
            "    @abc.abstractmethod",
            "    def stream_output(",
            "        self, value, output_id: str, first_chunk: bool",
            "    ) -> tuple[bytes | None, Any]:",
            "        pass",
            "",
            "",
            "class StreamingInput(metaclass=abc.ABCMeta):",
            "    def __init__(self, *args, **kwargs) -> None:",
            "        super().__init__(*args, **kwargs)",
            "",
            "    @abc.abstractmethod",
            "    def check_streamable(self):",
            "        \"\"\"Used to check if streaming is supported given the input.\"\"\"",
            "        pass",
            "",
            "",
            "def component(cls_name: str, render: bool) -> Component:",
            "    obj = utils.component_or_layout_class(cls_name)(render=render)",
            "    if isinstance(obj, BlockContext):",
            "        raise ValueError(f\"Invalid component: {obj.__class__}\")",
            "    if not isinstance(obj, Component):",
            "        raise TypeError(f\"Expected a Component instance, but got {obj.__class__}\")",
            "    return obj",
            "",
            "",
            "def get_component_instance(",
            "    comp: str | dict | Component, render: bool = False, unrender: bool = False",
            ") -> Component:",
            "    \"\"\"",
            "    Returns a component instance from a string, dict, or Component object.",
            "    Parameters:",
            "        comp: the component to instantiate. If a string, must be the name of a component, e.g. \"dropdown\". If a dict, must have a \"name\" key, e.g. {\"name\": \"dropdown\", \"choices\": [\"a\", \"b\"]}. If a Component object, will be returned as is.",
            "        render: whether to render the component. If True, renders the component (if not already rendered). If False, does not do anything.",
            "        unrender: whether to unrender the component. If True, unrenders the the component (if already rendered) -- this is useful when constructing an Interface or ChatInterface inside of a Blocks. If False, does not do anything.",
            "    \"\"\"",
            "    if isinstance(comp, str):",
            "        component_obj = component(comp, render=render)",
            "    elif isinstance(comp, dict):",
            "        name = comp.pop(\"name\")",
            "        component_cls = utils.component_or_layout_class(name)",
            "        component_obj = component_cls(**comp, render=render)",
            "        if isinstance(component_obj, BlockContext):",
            "            raise ValueError(f\"Invalid component: {name}\")",
            "    elif isinstance(comp, Component):",
            "        component_obj = comp",
            "    else:",
            "        raise ValueError(",
            "            f\"Component must provided as a `str` or `dict` or `Component` but is {comp}\"",
            "        )",
            "",
            "    if render and not component_obj.is_rendered:",
            "        component_obj.render()",
            "    elif unrender and component_obj.is_rendered:",
            "        component_obj.unrender()",
            "    if not isinstance(component_obj, Component):",
            "        raise TypeError(",
            "            f\"Expected a Component instance, but got {component_obj.__class__}\"",
            "        )",
            "    return component_obj"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "231": [
                "Component"
            ]
        },
        "addLocation": []
    },
    "gradio/components/file_explorer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from gradio_client.documentation import document"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from gradio.components.base import Component, server"
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from gradio.data_classes import GradioRootModel"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from gradio.data_classes import DeveloperPath, GradioRootModel, UserProvidedPath"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+from gradio.utils import safe_join"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     from gradio.components import Timer"
            },
            "9": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             )"
            },
            "10": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             root_dir = root"
            },
            "11": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "             self._constructor_args[0][\"root_dir\"] = root"
            },
            "12": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.root_dir = os.path.abspath(root_dir)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        self.root_dir = DeveloperPath(os.path.abspath(root_dir))"
            },
            "14": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         self.glob = glob"
            },
            "15": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.ignore_glob = ignore_glob"
            },
            "16": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         valid_file_count = [\"single\", \"multiple\"]"
            },
            "17": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 203,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         return folders + files"
            },
            "19": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 205,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _safe_join(self, folders):"
            },
            "21": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        combined_path = os.path.join(self.root_dir, *folders)"
            },
            "22": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        absolute_path = os.path.abspath(combined_path)"
            },
            "23": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if os.path.commonprefix([self.root_dir, absolute_path]) != os.path.abspath("
            },
            "24": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.root_dir"
            },
            "25": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ):"
            },
            "26": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError(\"Attempted to navigate outside of root directory\")"
            },
            "27": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return absolute_path"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+    def _safe_join(self, folders: list[str]):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        if not folders or len(folders) == 0:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+            return self.root_dir"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        combined_path = UserProvidedPath(os.path.join(*folders))"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        return safe_join(self.root_dir, combined_path)"
            }
        },
        "frontPatchFile": [
            "\"\"\"gr.FileExplorer() component\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import fnmatch",
            "import os",
            "import warnings",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, Callable, List, Literal, Sequence",
            "",
            "from gradio_client.documentation import document",
            "",
            "from gradio.components.base import Component, server",
            "from gradio.data_classes import GradioRootModel",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.components import Timer",
            "",
            "",
            "class FileExplorerData(GradioRootModel):",
            "    root: List[List[str]]",
            "",
            "",
            "@document()",
            "class FileExplorer(Component):",
            "    \"\"\"",
            "    Creates a file explorer component that allows users to browse files on the machine hosting the Gradio app. As an input component,",
            "    it also allows users to select files to be used as input to a function, while as an output component, it displays selected files.",
            "",
            "    Demos: file_explorer",
            "    \"\"\"",
            "",
            "    EVENTS = [\"change\"]",
            "    data_model = FileExplorerData",
            "",
            "    def __init__(",
            "        self,",
            "        glob: str = \"**/*\",",
            "        *,",
            "        value: str | list[str] | Callable | None = None,",
            "        file_count: Literal[\"single\", \"multiple\"] = \"multiple\",",
            "        root_dir: str | Path = \".\",",
            "        ignore_glob: str | None = None,",
            "        label: str | None = None,",
            "        every: Timer | float | None = None,",
            "        inputs: Component | Sequence[Component] | set[Component] | None = None,",
            "        show_label: bool | None = None,",
            "        container: bool = True,",
            "        scale: int | None = None,",
            "        min_width: int = 160,",
            "        height: int | float | str | None = None,",
            "        interactive: bool | None = None,",
            "        visible: bool = True,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        render: bool = True,",
            "        key: int | str | None = None,",
            "        root: None = None,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            glob: The glob-style pattern used to select which files to display, e.g. \"*\" to match all files, \"*.png\" to match all .png files, \"**/*.txt\" to match any .txt file in any subdirectory, etc. The default value matches all files and folders recursively. See the Python glob documentation at https://docs.python.org/3/library/glob.html for more information.",
            "            value: The file (or list of files, depending on the `file_count` parameter) to show as \"selected\" when the component is first loaded. If a callable is provided, it will be called when the app loads to set the initial value of the component. If not provided, no files are shown as selected.",
            "            file_count: Whether to allow single or multiple files to be selected. If \"single\", the component will return a single absolute file path as a string. If \"multiple\", the component will return a list of absolute file paths as a list of strings.",
            "            root_dir: Path to root directory to select files from. If not provided, defaults to current working directory.",
            "            ignore_glob: The glob-style, case-sensitive pattern that will be used to exclude files from the list. For example, \"*.py\" will exclude all .py files from the list. See the Python glob documentation at https://docs.python.org/3/library/glob.html for more information.",
            "            label: The label for this component. Appears above the component and is also used as the header if there are a table of examples for this component. If None and used in a `gr.Interface`, the label will be the name of the parameter this component is assigned to.",
            "            every: Continously calls `value` to recalculate it if `value` is a function (has no effect otherwise). Can provide a Timer whose tick resets `value`, or a float that provides the regular interval for the reset Timer.",
            "            inputs: Components that are used as inputs to calculate `value` if `value` is a function (has no effect otherwise). `value` is recalculated any time the inputs change.",
            "            show_label: if True, will display label.",
            "            container: If True, will place the component in a container - providing some extra padding around the border.",
            "            scale: relative size compared to adjacent Components. For example if Components A and B are in a Row, and A has scale=2, and B has scale=1, A will be twice as wide as B. Should be an integer. scale applies in Rows, and to top-level Components in Blocks where fill_height=True.",
            "            min_width: minimum pixel width, will wrap if not sufficient screen space to satisfy this value. If a certain scale value results in this Component being narrower than min_width, the min_width parameter will be respected first.",
            "            height: The maximum height of the file component, specified in pixels if a number is passed, or in CSS units if a string is passed. If more files are uploaded than can fit in the height, a scrollbar will appear.",
            "            interactive: if True, will allow users to select file(s); if False, will only display files. If not provided, this is inferred based on whether the component is used as an input or output.",
            "            visible: If False, component will be hidden.",
            "            elem_id: An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            elem_classes: An optional list of strings that are assigned as the classes of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            render: If False, component will not render be rendered in the Blocks context. Should be used if the intention is to assign event listeners now but render the component later.",
            "            key: if assigned, will be used to assume identity across a re-render. Components that have the same key across a re-render will have their value preserved.",
            "        \"\"\"",
            "        if root is not None:",
            "            warnings.warn(",
            "                \"The `root` parameter has been deprecated. Please use `root_dir` instead.\"",
            "            )",
            "            root_dir = root",
            "            self._constructor_args[0][\"root_dir\"] = root",
            "        self.root_dir = os.path.abspath(root_dir)",
            "        self.glob = glob",
            "        self.ignore_glob = ignore_glob",
            "        valid_file_count = [\"single\", \"multiple\"]",
            "        if file_count not in valid_file_count:",
            "            raise ValueError(",
            "                f\"Invalid value for parameter `file_count`: {file_count}. Please choose from one of: {valid_file_count}\"",
            "            )",
            "        self.file_count = file_count",
            "        self.height = height",
            "",
            "        super().__init__(",
            "            label=label,",
            "            every=every,",
            "            inputs=inputs,",
            "            show_label=show_label,",
            "            container=container,",
            "            scale=scale,",
            "            min_width=min_width,",
            "            interactive=interactive,",
            "            visible=visible,",
            "            elem_id=elem_id,",
            "            elem_classes=elem_classes,",
            "            render=render,",
            "            key=key,",
            "            value=value,",
            "        )",
            "",
            "    def example_payload(self) -> Any:",
            "        return [[\"Users\", \"gradio\", \"app.py\"]]",
            "",
            "    def example_value(self) -> Any:",
            "        return [\"Users\", \"gradio\", \"app.py\"]",
            "",
            "    def preprocess(self, payload: FileExplorerData | None) -> list[str] | str | None:",
            "        \"\"\"",
            "        Parameters:",
            "            payload: List of selected files as a FileExplorerData object.",
            "        Returns:",
            "            Passes the selected file or directory as a `str` path (relative to `root`) or `list[str}` depending on `file_count`",
            "        \"\"\"",
            "        if payload is None:",
            "            return None",
            "",
            "        if self.file_count == \"single\":",
            "            if len(payload.root) > 1:",
            "                raise ValueError(",
            "                    f\"Expected only one file, but {len(payload.root)} were selected.\"",
            "                )",
            "            elif len(payload.root) == 0:",
            "                return None",
            "            else:",
            "                return self._safe_join(payload.root[0])",
            "        files = []",
            "        for file in payload.root:",
            "            file_ = self._safe_join(file)",
            "            files.append(file_)",
            "        return files",
            "",
            "    def _strip_root(self, path):",
            "        if path.startswith(self.root_dir):",
            "            return path[len(self.root_dir) + 1 :]",
            "        return path",
            "",
            "    def postprocess(self, value: str | list[str] | None) -> FileExplorerData | None:",
            "        \"\"\"",
            "        Parameters:",
            "            value: Expects function to return a `str` path to a file, or `list[str]` consisting of paths to files.",
            "        Returns:",
            "            A FileExplorerData object containing the selected files as a list of strings.",
            "        \"\"\"",
            "        if value is None:",
            "            return None",
            "",
            "        files = [value] if isinstance(value, str) else value",
            "        root = []",
            "        for file in files:",
            "            root.append(self._strip_root(file).split(os.path.sep))",
            "",
            "        return FileExplorerData(root=root)",
            "",
            "    @server",
            "    def ls(self, subdirectory: list | None = None) -> list[dict[str, str]] | None:",
            "        \"\"\"",
            "        Returns:",
            "            a list of dictionaries, where each dictionary represents a file or subdirectory in the given subdirectory",
            "        \"\"\"",
            "        if subdirectory is None:",
            "            subdirectory = []",
            "",
            "        full_subdir_path = self._safe_join(subdirectory)",
            "",
            "        try:",
            "            subdir_items = sorted(os.listdir(full_subdir_path))",
            "        except FileNotFoundError:",
            "            return []",
            "",
            "        files, folders = [], []",
            "        for item in subdir_items:",
            "            full_path = os.path.join(full_subdir_path, item)",
            "            is_file = not os.path.isdir(full_path)",
            "            valid_by_glob = fnmatch.fnmatch(full_path, self.glob)",
            "            if is_file and not valid_by_glob:",
            "                continue",
            "            if self.ignore_glob and fnmatch.fnmatch(full_path, self.ignore_glob):",
            "                continue",
            "            target = files if is_file else folders",
            "            target.append(",
            "                {",
            "                    \"name\": item,",
            "                    \"type\": \"file\" if is_file else \"folder\",",
            "                    \"valid\": valid_by_glob,",
            "                }",
            "            )",
            "",
            "        return folders + files",
            "",
            "    def _safe_join(self, folders):",
            "        combined_path = os.path.join(self.root_dir, *folders)",
            "        absolute_path = os.path.abspath(combined_path)",
            "        if os.path.commonprefix([self.root_dir, absolute_path]) != os.path.abspath(",
            "            self.root_dir",
            "        ):",
            "            raise ValueError(\"Attempted to navigate outside of root directory\")",
            "        return absolute_path"
        ],
        "afterPatchFile": [
            "\"\"\"gr.FileExplorer() component\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import fnmatch",
            "import os",
            "import warnings",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, Callable, List, Literal, Sequence",
            "",
            "from gradio_client.documentation import document",
            "",
            "from gradio.components.base import Component, server",
            "from gradio.data_classes import DeveloperPath, GradioRootModel, UserProvidedPath",
            "from gradio.utils import safe_join",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.components import Timer",
            "",
            "",
            "class FileExplorerData(GradioRootModel):",
            "    root: List[List[str]]",
            "",
            "",
            "@document()",
            "class FileExplorer(Component):",
            "    \"\"\"",
            "    Creates a file explorer component that allows users to browse files on the machine hosting the Gradio app. As an input component,",
            "    it also allows users to select files to be used as input to a function, while as an output component, it displays selected files.",
            "",
            "    Demos: file_explorer",
            "    \"\"\"",
            "",
            "    EVENTS = [\"change\"]",
            "    data_model = FileExplorerData",
            "",
            "    def __init__(",
            "        self,",
            "        glob: str = \"**/*\",",
            "        *,",
            "        value: str | list[str] | Callable | None = None,",
            "        file_count: Literal[\"single\", \"multiple\"] = \"multiple\",",
            "        root_dir: str | Path = \".\",",
            "        ignore_glob: str | None = None,",
            "        label: str | None = None,",
            "        every: Timer | float | None = None,",
            "        inputs: Component | Sequence[Component] | set[Component] | None = None,",
            "        show_label: bool | None = None,",
            "        container: bool = True,",
            "        scale: int | None = None,",
            "        min_width: int = 160,",
            "        height: int | float | str | None = None,",
            "        interactive: bool | None = None,",
            "        visible: bool = True,",
            "        elem_id: str | None = None,",
            "        elem_classes: list[str] | str | None = None,",
            "        render: bool = True,",
            "        key: int | str | None = None,",
            "        root: None = None,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            glob: The glob-style pattern used to select which files to display, e.g. \"*\" to match all files, \"*.png\" to match all .png files, \"**/*.txt\" to match any .txt file in any subdirectory, etc. The default value matches all files and folders recursively. See the Python glob documentation at https://docs.python.org/3/library/glob.html for more information.",
            "            value: The file (or list of files, depending on the `file_count` parameter) to show as \"selected\" when the component is first loaded. If a callable is provided, it will be called when the app loads to set the initial value of the component. If not provided, no files are shown as selected.",
            "            file_count: Whether to allow single or multiple files to be selected. If \"single\", the component will return a single absolute file path as a string. If \"multiple\", the component will return a list of absolute file paths as a list of strings.",
            "            root_dir: Path to root directory to select files from. If not provided, defaults to current working directory.",
            "            ignore_glob: The glob-style, case-sensitive pattern that will be used to exclude files from the list. For example, \"*.py\" will exclude all .py files from the list. See the Python glob documentation at https://docs.python.org/3/library/glob.html for more information.",
            "            label: The label for this component. Appears above the component and is also used as the header if there are a table of examples for this component. If None and used in a `gr.Interface`, the label will be the name of the parameter this component is assigned to.",
            "            every: Continously calls `value` to recalculate it if `value` is a function (has no effect otherwise). Can provide a Timer whose tick resets `value`, or a float that provides the regular interval for the reset Timer.",
            "            inputs: Components that are used as inputs to calculate `value` if `value` is a function (has no effect otherwise). `value` is recalculated any time the inputs change.",
            "            show_label: if True, will display label.",
            "            container: If True, will place the component in a container - providing some extra padding around the border.",
            "            scale: relative size compared to adjacent Components. For example if Components A and B are in a Row, and A has scale=2, and B has scale=1, A will be twice as wide as B. Should be an integer. scale applies in Rows, and to top-level Components in Blocks where fill_height=True.",
            "            min_width: minimum pixel width, will wrap if not sufficient screen space to satisfy this value. If a certain scale value results in this Component being narrower than min_width, the min_width parameter will be respected first.",
            "            height: The maximum height of the file component, specified in pixels if a number is passed, or in CSS units if a string is passed. If more files are uploaded than can fit in the height, a scrollbar will appear.",
            "            interactive: if True, will allow users to select file(s); if False, will only display files. If not provided, this is inferred based on whether the component is used as an input or output.",
            "            visible: If False, component will be hidden.",
            "            elem_id: An optional string that is assigned as the id of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            elem_classes: An optional list of strings that are assigned as the classes of this component in the HTML DOM. Can be used for targeting CSS styles.",
            "            render: If False, component will not render be rendered in the Blocks context. Should be used if the intention is to assign event listeners now but render the component later.",
            "            key: if assigned, will be used to assume identity across a re-render. Components that have the same key across a re-render will have their value preserved.",
            "        \"\"\"",
            "        if root is not None:",
            "            warnings.warn(",
            "                \"The `root` parameter has been deprecated. Please use `root_dir` instead.\"",
            "            )",
            "            root_dir = root",
            "            self._constructor_args[0][\"root_dir\"] = root",
            "        self.root_dir = DeveloperPath(os.path.abspath(root_dir))",
            "        self.glob = glob",
            "        self.ignore_glob = ignore_glob",
            "        valid_file_count = [\"single\", \"multiple\"]",
            "        if file_count not in valid_file_count:",
            "            raise ValueError(",
            "                f\"Invalid value for parameter `file_count`: {file_count}. Please choose from one of: {valid_file_count}\"",
            "            )",
            "        self.file_count = file_count",
            "        self.height = height",
            "",
            "        super().__init__(",
            "            label=label,",
            "            every=every,",
            "            inputs=inputs,",
            "            show_label=show_label,",
            "            container=container,",
            "            scale=scale,",
            "            min_width=min_width,",
            "            interactive=interactive,",
            "            visible=visible,",
            "            elem_id=elem_id,",
            "            elem_classes=elem_classes,",
            "            render=render,",
            "            key=key,",
            "            value=value,",
            "        )",
            "",
            "    def example_payload(self) -> Any:",
            "        return [[\"Users\", \"gradio\", \"app.py\"]]",
            "",
            "    def example_value(self) -> Any:",
            "        return [\"Users\", \"gradio\", \"app.py\"]",
            "",
            "    def preprocess(self, payload: FileExplorerData | None) -> list[str] | str | None:",
            "        \"\"\"",
            "        Parameters:",
            "            payload: List of selected files as a FileExplorerData object.",
            "        Returns:",
            "            Passes the selected file or directory as a `str` path (relative to `root`) or `list[str}` depending on `file_count`",
            "        \"\"\"",
            "        if payload is None:",
            "            return None",
            "",
            "        if self.file_count == \"single\":",
            "            if len(payload.root) > 1:",
            "                raise ValueError(",
            "                    f\"Expected only one file, but {len(payload.root)} were selected.\"",
            "                )",
            "            elif len(payload.root) == 0:",
            "                return None",
            "            else:",
            "                return self._safe_join(payload.root[0])",
            "        files = []",
            "        for file in payload.root:",
            "            file_ = self._safe_join(file)",
            "            files.append(file_)",
            "        return files",
            "",
            "    def _strip_root(self, path):",
            "        if path.startswith(self.root_dir):",
            "            return path[len(self.root_dir) + 1 :]",
            "        return path",
            "",
            "    def postprocess(self, value: str | list[str] | None) -> FileExplorerData | None:",
            "        \"\"\"",
            "        Parameters:",
            "            value: Expects function to return a `str` path to a file, or `list[str]` consisting of paths to files.",
            "        Returns:",
            "            A FileExplorerData object containing the selected files as a list of strings.",
            "        \"\"\"",
            "        if value is None:",
            "            return None",
            "",
            "        files = [value] if isinstance(value, str) else value",
            "        root = []",
            "        for file in files:",
            "            root.append(self._strip_root(file).split(os.path.sep))",
            "",
            "        return FileExplorerData(root=root)",
            "",
            "    @server",
            "    def ls(self, subdirectory: list | None = None) -> list[dict[str, str]] | None:",
            "        \"\"\"",
            "        Returns:",
            "            a list of dictionaries, where each dictionary represents a file or subdirectory in the given subdirectory",
            "        \"\"\"",
            "        if subdirectory is None:",
            "            subdirectory = []",
            "",
            "        full_subdir_path = self._safe_join(subdirectory)",
            "",
            "        try:",
            "            subdir_items = sorted(os.listdir(full_subdir_path))",
            "        except FileNotFoundError:",
            "            return []",
            "",
            "        files, folders = [], []",
            "        for item in subdir_items:",
            "            full_path = os.path.join(full_subdir_path, item)",
            "            is_file = not os.path.isdir(full_path)",
            "            valid_by_glob = fnmatch.fnmatch(full_path, self.glob)",
            "            if is_file and not valid_by_glob:",
            "                continue",
            "            if self.ignore_glob and fnmatch.fnmatch(full_path, self.ignore_glob):",
            "                continue",
            "            target = files if is_file else folders",
            "            target.append(",
            "                {",
            "                    \"name\": item,",
            "                    \"type\": \"file\" if is_file else \"folder\",",
            "                    \"valid\": valid_by_glob,",
            "                }",
            "            )",
            "",
            "        return folders + files",
            "",
            "    def _safe_join(self, folders: list[str]):",
            "        if not folders or len(folders) == 0:",
            "            return self.root_dir",
            "        combined_path = UserProvidedPath(os.path.join(*folders))",
            "        return safe_join(self.root_dir, combined_path)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "14": [],
            "88": [
                "FileExplorer",
                "__init__"
            ],
            "205": [
                "FileExplorer",
                "_safe_join"
            ],
            "206": [
                "FileExplorer",
                "_safe_join"
            ],
            "207": [
                "FileExplorer",
                "_safe_join"
            ],
            "208": [
                "FileExplorer",
                "_safe_join"
            ],
            "209": [
                "FileExplorer",
                "_safe_join"
            ],
            "210": [
                "FileExplorer",
                "_safe_join"
            ],
            "211": [
                "FileExplorer",
                "_safe_join"
            ],
            "212": [
                "FileExplorer",
                "_safe_join"
            ]
        },
        "addLocation": []
    },
    "gradio/data_classes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import shutil"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from abc import ABC, abstractmethod"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from enum import Enum, auto"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import Any, Iterator, List, Literal, Optional, Tuple, TypedDict, Union"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from typing import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+    Any,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    Iterator,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    List,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    Literal,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    NewType,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+    Optional,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    Tuple,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+    TypedDict,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    Union,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+)"
            },
            "15": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from fastapi import Request"
            },
            "17": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from gradio_client.documentation import document"
            },
            "18": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " except ImportError:"
            },
            "19": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     JsonValue = Any"
            },
            "20": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+DeveloperPath = NewType(\"DeveloperPath\", str)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+UserProvidedPath = NewType(\"UserProvidedPath\", str)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " class CancelBody(BaseModel):"
            },
            "26": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "     session_hash: str"
            }
        },
        "frontPatchFile": [
            "\"\"\"Pydantic data models and other dataclasses. This is the only file that uses Optional[]",
            "typing syntax instead of | None syntax to work with pydantic\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import pathlib",
            "import secrets",
            "import shutil",
            "from abc import ABC, abstractmethod",
            "from enum import Enum, auto",
            "from typing import Any, Iterator, List, Literal, Optional, Tuple, TypedDict, Union",
            "",
            "from fastapi import Request",
            "from gradio_client.documentation import document",
            "from gradio_client.utils import traverse",
            "from pydantic import BaseModel, RootModel, ValidationError",
            "from typing_extensions import NotRequired",
            "",
            "try:",
            "    from pydantic import JsonValue",
            "except ImportError:",
            "    JsonValue = Any",
            "",
            "",
            "class CancelBody(BaseModel):",
            "    session_hash: str",
            "    fn_index: int",
            "    event_id: str",
            "",
            "",
            "class SimplePredictBody(BaseModel):",
            "    data: List[Any]",
            "    session_hash: Optional[str] = None",
            "",
            "",
            "class PredictBody(BaseModel):",
            "    model_config = {\"arbitrary_types_allowed\": True}",
            "",
            "    session_hash: Optional[str] = None",
            "    event_id: Optional[str] = None",
            "    data: List[Any]",
            "    event_data: Optional[Any] = None",
            "    fn_index: Optional[int] = None",
            "    trigger_id: Optional[int] = None",
            "    simple_format: bool = False",
            "    batched: Optional[bool] = (",
            "        False  # Whether the data is a batch of samples (i.e. called from the queue if batch=True) or a single sample (i.e. called from the UI)",
            "    )",
            "    request: Optional[Request] = (",
            "        None  # dictionary of request headers, query parameters, url, etc. (used to to pass in request for queuing)",
            "    )",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(cls, core_schema, handler):",
            "        return {",
            "            \"title\": \"PredictBody\",",
            "            \"type\": \"object\",",
            "            \"properties\": {",
            "                \"session_hash\": {\"type\": \"string\"},",
            "                \"event_id\": {\"type\": \"string\"},",
            "                \"data\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},",
            "                \"event_data\": {\"type\": \"object\"},",
            "                \"fn_index\": {\"type\": \"integer\"},",
            "                \"trigger_id\": {\"type\": \"integer\"},",
            "                \"simple_format\": {\"type\": \"boolean\"},",
            "                \"batched\": {\"type\": \"boolean\"},",
            "                \"request\": {\"type\": \"object\"},",
            "            },",
            "            \"required\": [\"data\"],",
            "        }",
            "",
            "",
            "class ResetBody(BaseModel):",
            "    event_id: str",
            "",
            "",
            "class ComponentServerJSONBody(BaseModel):",
            "    session_hash: str",
            "    component_id: int",
            "    fn_name: str",
            "    data: Any",
            "",
            "",
            "class DataWithFiles(BaseModel):",
            "    data: Any",
            "    files: List[Tuple[str, bytes]]",
            "",
            "",
            "class ComponentServerBlobBody(BaseModel):",
            "    session_hash: str",
            "    component_id: int",
            "    fn_name: str",
            "    data: DataWithFiles",
            "",
            "",
            "class InterfaceTypes(Enum):",
            "    STANDARD = auto()",
            "    INPUT_ONLY = auto()",
            "    OUTPUT_ONLY = auto()",
            "    UNIFIED = auto()",
            "",
            "",
            "class GradioBaseModel(ABC):",
            "    def copy_to_dir(self, dir: str | pathlib.Path) -> GradioDataModel:",
            "        if not isinstance(self, (BaseModel, RootModel)):",
            "            raise TypeError(\"must be used in a Pydantic model\")",
            "        dir = pathlib.Path(dir)",
            "",
            "        # TODO: Making sure path is unique should be done in caller",
            "        def unique_copy(obj: dict):",
            "            data = FileData(**obj)",
            "            return data._copy_to_dir(",
            "                str(pathlib.Path(dir / secrets.token_hex(10)))",
            "            ).model_dump()",
            "",
            "        return self.__class__.from_json(",
            "            x=traverse(",
            "                self.model_dump(),",
            "                unique_copy,",
            "                FileData.is_file_data,",
            "            )",
            "        )",
            "",
            "    @classmethod",
            "    @abstractmethod",
            "    def from_json(cls, x) -> GradioDataModel:",
            "        pass",
            "",
            "",
            "class JsonData(RootModel):",
            "    \"\"\"JSON data returned from a component that should not be modified further.\"\"\"",
            "",
            "    root: JsonValue",
            "",
            "",
            "class GradioModel(GradioBaseModel, BaseModel):",
            "    @classmethod",
            "    def from_json(cls, x) -> GradioModel:",
            "        return cls(**x)",
            "",
            "",
            "class GradioRootModel(GradioBaseModel, RootModel):",
            "    @classmethod",
            "    def from_json(cls, x) -> GradioRootModel:",
            "        return cls(root=x)",
            "",
            "",
            "GradioDataModel = Union[GradioModel, GradioRootModel]",
            "",
            "",
            "class FileDataDict(TypedDict):",
            "    path: str  # server filepath",
            "    url: Optional[str]  # normalised server url",
            "    size: Optional[int]  # size in bytes",
            "    orig_name: Optional[str]  # original filename",
            "    mime_type: Optional[str]",
            "    is_stream: bool",
            "    meta: dict",
            "",
            "",
            "@document()",
            "class FileData(GradioModel):",
            "    \"\"\"",
            "    The FileData class is a subclass of the GradioModel class that represents a file object within a Gradio interface. It is used to store file data and metadata when a file is uploaded.",
            "",
            "    Attributes:",
            "        path: The server file path where the file is stored.",
            "        url: The normalized server URL pointing to the file.",
            "        size: The size of the file in bytes.",
            "        orig_name: The original filename before upload.",
            "        mime_type: The MIME type of the file.",
            "        is_stream: Indicates whether the file is a stream.",
            "        meta: Additional metadata used internally (should not be changed).",
            "    \"\"\"",
            "",
            "    path: str  # server filepath",
            "    url: Optional[str] = None  # normalised server url",
            "    size: Optional[int] = None  # size in bytes",
            "    orig_name: Optional[str] = None  # original filename",
            "    mime_type: Optional[str] = None",
            "    is_stream: bool = False",
            "    meta: dict = {\"_type\": \"gradio.FileData\"}",
            "",
            "    @property",
            "    def is_none(self) -> bool:",
            "        \"\"\"",
            "        Checks if the FileData object is empty, i.e., all attributes are None.",
            "",
            "        Returns:",
            "            bool: True if all attributes (except 'is_stream' and 'meta') are None, False otherwise.",
            "        \"\"\"",
            "        return all(",
            "            f is None",
            "            for f in [",
            "                self.path,",
            "                self.url,",
            "                self.size,",
            "                self.orig_name,",
            "                self.mime_type,",
            "            ]",
            "        )",
            "",
            "    @classmethod",
            "    def from_path(cls, path: str) -> FileData:",
            "        \"\"\"",
            "        Creates a FileData object from a given file path.",
            "",
            "        Args:",
            "            path: The file path.",
            "",
            "        Returns:",
            "            FileData: An instance of FileData representing the file at the specified path.",
            "        \"\"\"",
            "        return cls(path=path)",
            "",
            "    def _copy_to_dir(self, dir: str) -> FileData:",
            "        \"\"\"",
            "        Copies the file to a specified directory and returns a new FileData object representing the copied file.",
            "",
            "        Args:",
            "            dir: The destination directory.",
            "",
            "        Returns:",
            "            FileData: A new FileData object representing the copied file.",
            "",
            "        Raises:",
            "            ValueError: If the source file path is not set.",
            "        \"\"\"",
            "        pathlib.Path(dir).mkdir(exist_ok=True)",
            "        new_obj = dict(self)",
            "",
            "        if not self.path:",
            "            raise ValueError(\"Source file path is not set\")",
            "        new_name = shutil.copy(self.path, dir)",
            "        new_obj[\"path\"] = new_name",
            "        return self.__class__(**new_obj)",
            "",
            "    @classmethod",
            "    def is_file_data(cls, obj: Any) -> bool:",
            "        \"\"\"",
            "        Checks if an object is a valid FileData instance.",
            "",
            "        Args:",
            "            obj: The object to check.",
            "",
            "        Returns:",
            "            bool: True if the object is a valid FileData instance, False otherwise.",
            "        \"\"\"",
            "        if isinstance(obj, dict):",
            "            try:",
            "                return not FileData(**obj).is_none",
            "            except (TypeError, ValidationError):",
            "                return False",
            "        return False",
            "",
            "",
            "class ListFiles(GradioRootModel):",
            "    root: List[FileData]",
            "",
            "    def __getitem__(self, index):",
            "        return self.root[index]",
            "",
            "    def __iter__(self) -> Iterator[FileData]:  # type: ignore[override]",
            "        return iter(self.root)",
            "",
            "",
            "class _StaticFiles:",
            "    \"\"\"",
            "    Class to hold all static files for an app",
            "    \"\"\"",
            "",
            "    all_paths = []",
            "",
            "    def __init__(self, paths: list[str | pathlib.Path]) -> None:",
            "        self.paths = paths",
            "        self.all_paths = [pathlib.Path(p).resolve() for p in paths]",
            "",
            "    @classmethod",
            "    def clear(cls):",
            "        cls.all_paths = []",
            "",
            "",
            "class BodyCSS(TypedDict):",
            "    body_background_fill: str",
            "    body_text_color: str",
            "    body_background_fill_dark: str",
            "    body_text_color_dark: str",
            "",
            "",
            "class Layout(TypedDict):",
            "    id: int",
            "    children: list[int | Layout]",
            "",
            "",
            "class BlocksConfigDict(TypedDict):",
            "    version: str",
            "    mode: str",
            "    app_id: int",
            "    dev_mode: bool",
            "    analytics_enabled: bool",
            "    components: list[dict[str, Any]]",
            "    css: str | None",
            "    connect_heartbeat: bool",
            "    js: str | None",
            "    head: str | None",
            "    title: str",
            "    space_id: str | None",
            "    enable_queue: bool",
            "    show_error: bool",
            "    show_api: bool",
            "    is_colab: bool",
            "    max_file_size: int | None",
            "    stylesheets: list[str]",
            "    theme: str | None",
            "    protocol: Literal[\"ws\", \"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"]",
            "    body_css: BodyCSS",
            "    fill_height: bool",
            "    fill_width: bool",
            "    theme_hash: str",
            "    layout: NotRequired[Layout]",
            "    dependencies: NotRequired[list[dict[str, Any]]]",
            "    root: NotRequired[str | None]",
            "    username: NotRequired[str | None]"
        ],
        "afterPatchFile": [
            "\"\"\"Pydantic data models and other dataclasses. This is the only file that uses Optional[]",
            "typing syntax instead of | None syntax to work with pydantic\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import pathlib",
            "import secrets",
            "import shutil",
            "from abc import ABC, abstractmethod",
            "from enum import Enum, auto",
            "from typing import (",
            "    Any,",
            "    Iterator,",
            "    List,",
            "    Literal,",
            "    NewType,",
            "    Optional,",
            "    Tuple,",
            "    TypedDict,",
            "    Union,",
            ")",
            "",
            "from fastapi import Request",
            "from gradio_client.documentation import document",
            "from gradio_client.utils import traverse",
            "from pydantic import BaseModel, RootModel, ValidationError",
            "from typing_extensions import NotRequired",
            "",
            "try:",
            "    from pydantic import JsonValue",
            "except ImportError:",
            "    JsonValue = Any",
            "",
            "DeveloperPath = NewType(\"DeveloperPath\", str)",
            "UserProvidedPath = NewType(\"UserProvidedPath\", str)",
            "",
            "",
            "class CancelBody(BaseModel):",
            "    session_hash: str",
            "    fn_index: int",
            "    event_id: str",
            "",
            "",
            "class SimplePredictBody(BaseModel):",
            "    data: List[Any]",
            "    session_hash: Optional[str] = None",
            "",
            "",
            "class PredictBody(BaseModel):",
            "    model_config = {\"arbitrary_types_allowed\": True}",
            "",
            "    session_hash: Optional[str] = None",
            "    event_id: Optional[str] = None",
            "    data: List[Any]",
            "    event_data: Optional[Any] = None",
            "    fn_index: Optional[int] = None",
            "    trigger_id: Optional[int] = None",
            "    simple_format: bool = False",
            "    batched: Optional[bool] = (",
            "        False  # Whether the data is a batch of samples (i.e. called from the queue if batch=True) or a single sample (i.e. called from the UI)",
            "    )",
            "    request: Optional[Request] = (",
            "        None  # dictionary of request headers, query parameters, url, etc. (used to to pass in request for queuing)",
            "    )",
            "",
            "    @classmethod",
            "    def __get_pydantic_json_schema__(cls, core_schema, handler):",
            "        return {",
            "            \"title\": \"PredictBody\",",
            "            \"type\": \"object\",",
            "            \"properties\": {",
            "                \"session_hash\": {\"type\": \"string\"},",
            "                \"event_id\": {\"type\": \"string\"},",
            "                \"data\": {\"type\": \"array\", \"items\": {\"type\": \"object\"}},",
            "                \"event_data\": {\"type\": \"object\"},",
            "                \"fn_index\": {\"type\": \"integer\"},",
            "                \"trigger_id\": {\"type\": \"integer\"},",
            "                \"simple_format\": {\"type\": \"boolean\"},",
            "                \"batched\": {\"type\": \"boolean\"},",
            "                \"request\": {\"type\": \"object\"},",
            "            },",
            "            \"required\": [\"data\"],",
            "        }",
            "",
            "",
            "class ResetBody(BaseModel):",
            "    event_id: str",
            "",
            "",
            "class ComponentServerJSONBody(BaseModel):",
            "    session_hash: str",
            "    component_id: int",
            "    fn_name: str",
            "    data: Any",
            "",
            "",
            "class DataWithFiles(BaseModel):",
            "    data: Any",
            "    files: List[Tuple[str, bytes]]",
            "",
            "",
            "class ComponentServerBlobBody(BaseModel):",
            "    session_hash: str",
            "    component_id: int",
            "    fn_name: str",
            "    data: DataWithFiles",
            "",
            "",
            "class InterfaceTypes(Enum):",
            "    STANDARD = auto()",
            "    INPUT_ONLY = auto()",
            "    OUTPUT_ONLY = auto()",
            "    UNIFIED = auto()",
            "",
            "",
            "class GradioBaseModel(ABC):",
            "    def copy_to_dir(self, dir: str | pathlib.Path) -> GradioDataModel:",
            "        if not isinstance(self, (BaseModel, RootModel)):",
            "            raise TypeError(\"must be used in a Pydantic model\")",
            "        dir = pathlib.Path(dir)",
            "",
            "        # TODO: Making sure path is unique should be done in caller",
            "        def unique_copy(obj: dict):",
            "            data = FileData(**obj)",
            "            return data._copy_to_dir(",
            "                str(pathlib.Path(dir / secrets.token_hex(10)))",
            "            ).model_dump()",
            "",
            "        return self.__class__.from_json(",
            "            x=traverse(",
            "                self.model_dump(),",
            "                unique_copy,",
            "                FileData.is_file_data,",
            "            )",
            "        )",
            "",
            "    @classmethod",
            "    @abstractmethod",
            "    def from_json(cls, x) -> GradioDataModel:",
            "        pass",
            "",
            "",
            "class JsonData(RootModel):",
            "    \"\"\"JSON data returned from a component that should not be modified further.\"\"\"",
            "",
            "    root: JsonValue",
            "",
            "",
            "class GradioModel(GradioBaseModel, BaseModel):",
            "    @classmethod",
            "    def from_json(cls, x) -> GradioModel:",
            "        return cls(**x)",
            "",
            "",
            "class GradioRootModel(GradioBaseModel, RootModel):",
            "    @classmethod",
            "    def from_json(cls, x) -> GradioRootModel:",
            "        return cls(root=x)",
            "",
            "",
            "GradioDataModel = Union[GradioModel, GradioRootModel]",
            "",
            "",
            "class FileDataDict(TypedDict):",
            "    path: str  # server filepath",
            "    url: Optional[str]  # normalised server url",
            "    size: Optional[int]  # size in bytes",
            "    orig_name: Optional[str]  # original filename",
            "    mime_type: Optional[str]",
            "    is_stream: bool",
            "    meta: dict",
            "",
            "",
            "@document()",
            "class FileData(GradioModel):",
            "    \"\"\"",
            "    The FileData class is a subclass of the GradioModel class that represents a file object within a Gradio interface. It is used to store file data and metadata when a file is uploaded.",
            "",
            "    Attributes:",
            "        path: The server file path where the file is stored.",
            "        url: The normalized server URL pointing to the file.",
            "        size: The size of the file in bytes.",
            "        orig_name: The original filename before upload.",
            "        mime_type: The MIME type of the file.",
            "        is_stream: Indicates whether the file is a stream.",
            "        meta: Additional metadata used internally (should not be changed).",
            "    \"\"\"",
            "",
            "    path: str  # server filepath",
            "    url: Optional[str] = None  # normalised server url",
            "    size: Optional[int] = None  # size in bytes",
            "    orig_name: Optional[str] = None  # original filename",
            "    mime_type: Optional[str] = None",
            "    is_stream: bool = False",
            "    meta: dict = {\"_type\": \"gradio.FileData\"}",
            "",
            "    @property",
            "    def is_none(self) -> bool:",
            "        \"\"\"",
            "        Checks if the FileData object is empty, i.e., all attributes are None.",
            "",
            "        Returns:",
            "            bool: True if all attributes (except 'is_stream' and 'meta') are None, False otherwise.",
            "        \"\"\"",
            "        return all(",
            "            f is None",
            "            for f in [",
            "                self.path,",
            "                self.url,",
            "                self.size,",
            "                self.orig_name,",
            "                self.mime_type,",
            "            ]",
            "        )",
            "",
            "    @classmethod",
            "    def from_path(cls, path: str) -> FileData:",
            "        \"\"\"",
            "        Creates a FileData object from a given file path.",
            "",
            "        Args:",
            "            path: The file path.",
            "",
            "        Returns:",
            "            FileData: An instance of FileData representing the file at the specified path.",
            "        \"\"\"",
            "        return cls(path=path)",
            "",
            "    def _copy_to_dir(self, dir: str) -> FileData:",
            "        \"\"\"",
            "        Copies the file to a specified directory and returns a new FileData object representing the copied file.",
            "",
            "        Args:",
            "            dir: The destination directory.",
            "",
            "        Returns:",
            "            FileData: A new FileData object representing the copied file.",
            "",
            "        Raises:",
            "            ValueError: If the source file path is not set.",
            "        \"\"\"",
            "        pathlib.Path(dir).mkdir(exist_ok=True)",
            "        new_obj = dict(self)",
            "",
            "        if not self.path:",
            "            raise ValueError(\"Source file path is not set\")",
            "        new_name = shutil.copy(self.path, dir)",
            "        new_obj[\"path\"] = new_name",
            "        return self.__class__(**new_obj)",
            "",
            "    @classmethod",
            "    def is_file_data(cls, obj: Any) -> bool:",
            "        \"\"\"",
            "        Checks if an object is a valid FileData instance.",
            "",
            "        Args:",
            "            obj: The object to check.",
            "",
            "        Returns:",
            "            bool: True if the object is a valid FileData instance, False otherwise.",
            "        \"\"\"",
            "        if isinstance(obj, dict):",
            "            try:",
            "                return not FileData(**obj).is_none",
            "            except (TypeError, ValidationError):",
            "                return False",
            "        return False",
            "",
            "",
            "class ListFiles(GradioRootModel):",
            "    root: List[FileData]",
            "",
            "    def __getitem__(self, index):",
            "        return self.root[index]",
            "",
            "    def __iter__(self) -> Iterator[FileData]:  # type: ignore[override]",
            "        return iter(self.root)",
            "",
            "",
            "class _StaticFiles:",
            "    \"\"\"",
            "    Class to hold all static files for an app",
            "    \"\"\"",
            "",
            "    all_paths = []",
            "",
            "    def __init__(self, paths: list[str | pathlib.Path]) -> None:",
            "        self.paths = paths",
            "        self.all_paths = [pathlib.Path(p).resolve() for p in paths]",
            "",
            "    @classmethod",
            "    def clear(cls):",
            "        cls.all_paths = []",
            "",
            "",
            "class BodyCSS(TypedDict):",
            "    body_background_fill: str",
            "    body_text_color: str",
            "    body_background_fill_dark: str",
            "    body_text_color_dark: str",
            "",
            "",
            "class Layout(TypedDict):",
            "    id: int",
            "    children: list[int | Layout]",
            "",
            "",
            "class BlocksConfigDict(TypedDict):",
            "    version: str",
            "    mode: str",
            "    app_id: int",
            "    dev_mode: bool",
            "    analytics_enabled: bool",
            "    components: list[dict[str, Any]]",
            "    css: str | None",
            "    connect_heartbeat: bool",
            "    js: str | None",
            "    head: str | None",
            "    title: str",
            "    space_id: str | None",
            "    enable_queue: bool",
            "    show_error: bool",
            "    show_api: bool",
            "    is_colab: bool",
            "    max_file_size: int | None",
            "    stylesheets: list[str]",
            "    theme: str | None",
            "    protocol: Literal[\"ws\", \"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"]",
            "    body_css: BodyCSS",
            "    fill_height: bool",
            "    fill_width: bool",
            "    theme_hash: str",
            "    layout: NotRequired[Layout]",
            "    dependencies: NotRequired[list[dict[str, Any]]]",
            "    root: NotRequired[str | None]",
            "    username: NotRequired[str | None]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": []
        },
        "addLocation": []
    },
    "gradio/exceptions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " class ComponentDefinitionError(NotImplementedError):"
            },
            "2": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     pass"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+class InvalidPathError(ValueError):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+    pass"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from gradio_client.documentation import document",
            "",
            "",
            "class DuplicateBlockError(ValueError):",
            "    \"\"\"Raised when a Blocks contains more than one Block with the same id\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class InvalidComponentError(ValueError):",
            "    \"\"\"Raised when invalid components are used.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class TooManyRequestsError(Exception):",
            "    \"\"\"Raised when the Hugging Face API returns a 429 status code.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class ModelNotFoundError(Exception):",
            "    \"\"\"Raised when the provided model doesn't exists or is not found by the provided api url.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class RenderError(Exception):",
            "    \"\"\"Raised when a component has not been rendered in the current Blocks but is expected to have been rendered.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class InvalidApiNameError(ValueError):",
            "    pass",
            "",
            "",
            "class ServerFailedToStartError(Exception):",
            "    pass",
            "",
            "",
            "class InvalidBlockError(ValueError):",
            "    \"\"\"Raised when an event in a Blocks contains a reference to a Block that is not in the original Blocks\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class ReloadError(ValueError):",
            "    \"\"\"Raised when something goes wrong when reloading the gradio app.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class GradioVersionIncompatibleError(Exception):",
            "    \"\"\"Raised when loading a 3.x space with 4.0\"\"\"",
            "",
            "    pass",
            "",
            "",
            "InvalidApiName = InvalidApiNameError  # backwards compatibility",
            "",
            "",
            "@document(documentation_group=\"modals\")",
            "class Error(Exception):",
            "    \"\"\"",
            "    This class allows you to pass custom error messages to the user. You can do so by raising a gr.Error(\"custom message\") anywhere in the code, and when that line is executed the custom message will appear in a modal on the demo.",
            "    Example:",
            "        import gradio as gr",
            "        def divide(numerator, denominator):",
            "            if denominator == 0:",
            "                raise gr.Error(\"Cannot divide by zero!\")",
            "        gr.Interface(divide, [\"number\", \"number\"], \"number\").launch()",
            "    Demos: calculator, blocks_chained_events",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        message: str = \"Error raised.\",",
            "        duration: float | None = 10,",
            "        visible: bool = True,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            message: The error message to be displayed to the user. Can be HTML, which will be rendered in the modal.",
            "            duration: The duration in seconds to display the error message. If None or 0, the error message will be displayed until the user closes it.",
            "            visible: Whether the error message should be displayed in the UI.",
            "        \"\"\"",
            "        self.message = message",
            "        self.duration = duration",
            "        self.visible = visible",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self):",
            "        return repr(self.message)",
            "",
            "",
            "class ComponentDefinitionError(NotImplementedError):",
            "    pass"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from gradio_client.documentation import document",
            "",
            "",
            "class DuplicateBlockError(ValueError):",
            "    \"\"\"Raised when a Blocks contains more than one Block with the same id\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class InvalidComponentError(ValueError):",
            "    \"\"\"Raised when invalid components are used.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class TooManyRequestsError(Exception):",
            "    \"\"\"Raised when the Hugging Face API returns a 429 status code.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class ModelNotFoundError(Exception):",
            "    \"\"\"Raised when the provided model doesn't exists or is not found by the provided api url.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class RenderError(Exception):",
            "    \"\"\"Raised when a component has not been rendered in the current Blocks but is expected to have been rendered.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class InvalidApiNameError(ValueError):",
            "    pass",
            "",
            "",
            "class ServerFailedToStartError(Exception):",
            "    pass",
            "",
            "",
            "class InvalidBlockError(ValueError):",
            "    \"\"\"Raised when an event in a Blocks contains a reference to a Block that is not in the original Blocks\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class ReloadError(ValueError):",
            "    \"\"\"Raised when something goes wrong when reloading the gradio app.\"\"\"",
            "",
            "    pass",
            "",
            "",
            "class GradioVersionIncompatibleError(Exception):",
            "    \"\"\"Raised when loading a 3.x space with 4.0\"\"\"",
            "",
            "    pass",
            "",
            "",
            "InvalidApiName = InvalidApiNameError  # backwards compatibility",
            "",
            "",
            "@document(documentation_group=\"modals\")",
            "class Error(Exception):",
            "    \"\"\"",
            "    This class allows you to pass custom error messages to the user. You can do so by raising a gr.Error(\"custom message\") anywhere in the code, and when that line is executed the custom message will appear in a modal on the demo.",
            "    Example:",
            "        import gradio as gr",
            "        def divide(numerator, denominator):",
            "            if denominator == 0:",
            "                raise gr.Error(\"Cannot divide by zero!\")",
            "        gr.Interface(divide, [\"number\", \"number\"], \"number\").launch()",
            "    Demos: calculator, blocks_chained_events",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        message: str = \"Error raised.\",",
            "        duration: float | None = 10,",
            "        visible: bool = True,",
            "    ):",
            "        \"\"\"",
            "        Parameters:",
            "            message: The error message to be displayed to the user. Can be HTML, which will be rendered in the modal.",
            "            duration: The duration in seconds to display the error message. If None or 0, the error message will be displayed until the user closes it.",
            "            visible: Whether the error message should be displayed in the UI.",
            "        \"\"\"",
            "        self.message = message",
            "        self.duration = duration",
            "        self.visible = visible",
            "        super().__init__(self.message)",
            "",
            "    def __str__(self):",
            "        return repr(self.message)",
            "",
            "",
            "class ComponentDefinitionError(NotImplementedError):",
            "    pass",
            "",
            "",
            "class InvalidPathError(ValueError):",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "gradio/route_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " from starlette.types import ASGIApp, Message, Receive, Scope, Send"
            },
            "1": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from gradio import processing_utils, utils"
            },
            "3": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from gradio.data_classes import BlocksConfigDict, PredictBody"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+from gradio.data_classes import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+    BlocksConfigDict,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    PredictBody,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+)"
            },
            "8": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " from gradio.exceptions import Error"
            },
            "9": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " from gradio.helpers import EventData"
            },
            "10": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " from gradio.state_holder import SessionState"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import functools",
            "import hashlib",
            "import hmac",
            "import json",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import threading",
            "from collections import deque",
            "from contextlib import AsyncExitStack, asynccontextmanager",
            "from dataclasses import dataclass as python_dataclass",
            "from datetime import datetime",
            "from pathlib import Path",
            "from tempfile import NamedTemporaryFile, _TemporaryFileWrapper",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    AsyncContextManager,",
            "    AsyncGenerator,",
            "    BinaryIO,",
            "    Callable,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "from urllib.parse import urlparse",
            "",
            "import anyio",
            "import fastapi",
            "import gradio_client.utils as client_utils",
            "import httpx",
            "import multipart",
            "from gradio_client.documentation import document",
            "from multipart.multipart import parse_options_header",
            "from starlette.datastructures import FormData, Headers, MutableHeaders, UploadFile",
            "from starlette.formparsers import MultiPartException, MultipartPart",
            "from starlette.responses import PlainTextResponse, Response",
            "from starlette.types import ASGIApp, Message, Receive, Scope, Send",
            "",
            "from gradio import processing_utils, utils",
            "from gradio.data_classes import BlocksConfigDict, PredictBody",
            "from gradio.exceptions import Error",
            "from gradio.helpers import EventData",
            "from gradio.state_holder import SessionState",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import BlockFunction, Blocks",
            "    from gradio.routes import App",
            "",
            "",
            "config_lock = threading.Lock()",
            "",
            "",
            "class Obj:",
            "    \"\"\"",
            "    Using a class to convert dictionaries into objects. Used by the `Request` class.",
            "    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/",
            "    \"\"\"",
            "",
            "    def __init__(self, dict_):",
            "        self.__dict__.update(dict_)",
            "        for key, value in dict_.items():",
            "            if isinstance(value, (dict, list)):",
            "                value = Obj(value)",
            "            setattr(self, key, value)",
            "",
            "    def __getitem__(self, item):",
            "        return self.__dict__[item]",
            "",
            "    def __setitem__(self, item, value):",
            "        self.__dict__[item] = value",
            "",
            "    def __iter__(self):",
            "        for key, value in self.__dict__.items():",
            "            if isinstance(value, Obj):",
            "                yield (key, dict(value))",
            "            else:",
            "                yield (key, value)",
            "",
            "    def __contains__(self, item) -> bool:",
            "        if item in self.__dict__:",
            "            return True",
            "        for value in self.__dict__.values():",
            "            if isinstance(value, Obj) and item in value:",
            "                return True",
            "        return False",
            "",
            "    def get(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__[item]",
            "        return default",
            "",
            "    def keys(self):",
            "        return self.__dict__.keys()",
            "",
            "    def values(self):",
            "        return self.__dict__.values()",
            "",
            "    def items(self):",
            "        return self.__dict__.items()",
            "",
            "    def __str__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def pop(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__.pop(item)",
            "        return default",
            "",
            "",
            "@document()",
            "class Request:",
            "    \"\"\"",
            "    A Gradio request object that can be used to access the request headers, cookies,",
            "    query parameters and other information about the request from within the prediction",
            "    function. The class is a thin wrapper around the fastapi.Request class. Attributes",
            "    of this class include: `headers`, `client`, `query_params`, `session_hash`, and `path_params`. If",
            "    auth is enabled, the `username` attribute can be used to get the logged in user.",
            "    Example:",
            "        import gradio as gr",
            "        def echo(text, request: gr.Request):",
            "            if request:",
            "                print(\"Request headers dictionary:\", request.headers)",
            "                print(\"IP address:\", request.client.host)",
            "                print(\"Query parameters:\", dict(request.query_params))",
            "                print(\"Session hash:\", request.session_hash)",
            "            return text",
            "        io = gr.Interface(echo, \"textbox\", \"textbox\").launch()",
            "    Demos: request_ip_headers",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        request: fastapi.Request | None = None,",
            "        username: str | None = None,",
            "        session_hash: str | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Can be instantiated with either a fastapi.Request or by manually passing in",
            "        attributes (needed for queueing).",
            "        Parameters:",
            "            request: A fastapi.Request",
            "            username: The username of the logged in user (if auth is enabled)",
            "            session_hash: The session hash of the current session. It is unique for each page load.",
            "        \"\"\"",
            "        self.request = request",
            "        self.username = username",
            "        self.session_hash = session_hash",
            "        self.kwargs: dict = kwargs",
            "",
            "    def dict_to_obj(self, d):",
            "        if isinstance(d, dict):",
            "            return json.loads(json.dumps(d), object_hook=Obj)",
            "        else:",
            "            return d",
            "",
            "    def __getattr__(self, name):",
            "        if self.request:",
            "            return self.dict_to_obj(getattr(self.request, name))",
            "        else:",
            "            try:",
            "                obj = self.kwargs[name]",
            "            except KeyError as ke:",
            "                raise AttributeError(",
            "                    f\"'Request' object has no attribute '{name}'\"",
            "                ) from ke",
            "            return self.dict_to_obj(obj)",
            "",
            "",
            "class FnIndexInferError(Exception):",
            "    pass",
            "",
            "",
            "def get_fn(blocks: Blocks, api_name: str | None, body: PredictBody) -> BlockFunction:",
            "    if body.session_hash:",
            "        session_state = blocks.state_holder[body.session_hash]",
            "        fns = session_state.blocks_config.fns",
            "    else:",
            "        fns = blocks.fns",
            "",
            "    if body.fn_index is None:",
            "        if api_name is not None:",
            "            for fn in fns.values():",
            "                if fn.api_name == api_name:",
            "                    return fn",
            "        raise FnIndexInferError(",
            "            f\"Could not infer function index for API name: {api_name}\"",
            "        )",
            "    else:",
            "        return fns[body.fn_index]",
            "",
            "",
            "def compile_gr_request(",
            "    body: PredictBody,",
            "    fn: BlockFunction,",
            "    username: Optional[str],",
            "    request: Optional[fastapi.Request],",
            "):",
            "    # If this fn_index cancels jobs, then the only input we need is the",
            "    # current session hash",
            "    if fn.cancels:",
            "        body.data = [body.session_hash]",
            "    if body.request:",
            "        if body.batched:",
            "            gr_request = [Request(username=username, request=request)]",
            "        else:",
            "            gr_request = Request(",
            "                username=username, request=body.request, session_hash=body.session_hash",
            "            )",
            "    else:",
            "        if request is None:",
            "            raise ValueError(\"request must be provided if body.request is None\")",
            "        gr_request = Request(",
            "            username=username, request=request, session_hash=body.session_hash",
            "        )",
            "",
            "    return gr_request",
            "",
            "",
            "def restore_session_state(app: App, body: PredictBody):",
            "    event_id = body.event_id",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    if session_hash is not None:",
            "        session_state = app.state_holder[session_hash]",
            "        # The should_reset set keeps track of the fn_indices",
            "        # that have been cancelled. When a job is cancelled,",
            "        # the /reset route will mark the jobs as having been reset.",
            "        # That way if the cancel job finishes BEFORE the job being cancelled",
            "        # the job being cancelled will not overwrite the state of the iterator.",
            "        if event_id is None:",
            "            iterator = None",
            "        elif event_id in app.iterators_to_reset:",
            "            iterator = None",
            "            app.iterators_to_reset.remove(event_id)",
            "        else:",
            "            iterator = app.iterators.get(event_id)",
            "    else:",
            "        session_state = SessionState(app.get_blocks())",
            "        iterator = None",
            "",
            "    return session_state, iterator",
            "",
            "",
            "def prepare_event_data(",
            "    blocks: Blocks,",
            "    body: PredictBody,",
            ") -> EventData:",
            "    target = body.trigger_id",
            "    event_data = EventData(",
            "        blocks.blocks.get(target) if target else None,",
            "        body.event_data,",
            "    )",
            "    return event_data",
            "",
            "",
            "async def call_process_api(",
            "    app: App,",
            "    body: PredictBody,",
            "    gr_request: Union[Request, list[Request]],",
            "    fn: BlockFunction,",
            "    root_path: str,",
            "):",
            "    session_state, iterator = restore_session_state(app=app, body=body)",
            "",
            "    event_data = prepare_event_data(app.get_blocks(), body)",
            "    event_id = body.event_id",
            "",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    inputs = body.data",
            "",
            "    batch_in_single_out = not body.batched and fn.batch",
            "    if batch_in_single_out:",
            "        inputs = [inputs]",
            "",
            "    try:",
            "        with utils.MatplotlibBackendMananger():",
            "            output = await app.get_blocks().process_api(",
            "                block_fn=fn,",
            "                inputs=inputs,",
            "                request=gr_request,",
            "                state=session_state,",
            "                iterator=iterator,",
            "                session_hash=session_hash,",
            "                event_id=event_id,",
            "                event_data=event_data,",
            "                in_event_listener=True,",
            "                simple_format=body.simple_format,",
            "                root_path=root_path,",
            "            )",
            "        iterator = output.pop(\"iterator\", None)",
            "        if event_id is not None:",
            "            app.iterators[event_id] = iterator  # type: ignore",
            "        if isinstance(output, Error):",
            "            raise output",
            "    except BaseException:",
            "        iterator = app.iterators.get(event_id) if event_id is not None else None",
            "        if iterator is not None:  # close off any streams that are still open",
            "            run_id = id(iterator)",
            "            pending_streams: dict[int, list] = (",
            "                app.get_blocks().pending_streams[session_hash].get(run_id, {})",
            "            )",
            "            for stream in pending_streams.values():",
            "                stream.append(None)",
            "        raise",
            "",
            "    if batch_in_single_out:",
            "        output[\"data\"] = output[\"data\"][0]",
            "",
            "    return output",
            "",
            "",
            "def get_root_url(",
            "    request: fastapi.Request, route_path: str, root_path: str | None",
            ") -> str:",
            "    \"\"\"",
            "    Gets the root url of the Gradio app (i.e. the public url of the app) without a trailing slash.",
            "",
            "    This is how the root_url is resolved:",
            "    1. If a user provides a `root_path` manually that is a full URL, it is returned directly.",
            "    2. If the request has an x-forwarded-host header (e.g. because it is behind a proxy), the root url is",
            "    constructed from the x-forwarded-host header. In this case, `route_path` is not used to construct the root url.",
            "    3. Otherwise, the root url is constructed from the request url. The query parameters and `route_path` are stripped off.",
            "    And if a relative `root_path` is provided, and it is not already the subpath of the URL, it is appended to the root url.",
            "",
            "    In cases (2) and (3), We also check to see if the x-forwarded-proto header is present, and if so, convert the root url to https.",
            "    And if there are multiple hosts in the x-forwarded-host or multiple protocols in the x-forwarded-proto, the first one is used.",
            "    \"\"\"",
            "",
            "    def get_first_header_value(header_name: str):",
            "        header_value = request.headers.get(header_name)",
            "        if header_value:",
            "            return header_value.split(\",\")[0].strip()",
            "        return None",
            "",
            "    if root_path and client_utils.is_http_url_like(root_path):",
            "        return root_path.rstrip(\"/\")",
            "",
            "    x_forwarded_host = get_first_header_value(\"x-forwarded-host\")",
            "    root_url = f\"http://{x_forwarded_host}\" if x_forwarded_host else str(request.url)",
            "    root_url = httpx.URL(root_url)",
            "    root_url = root_url.copy_with(query=None)",
            "    root_url = str(root_url).rstrip(\"/\")",
            "    if get_first_header_value(\"x-forwarded-proto\") == \"https\":",
            "        root_url = root_url.replace(\"http://\", \"https://\")",
            "",
            "    route_path = route_path.rstrip(\"/\")",
            "    if len(route_path) > 0 and not x_forwarded_host:",
            "        root_url = root_url[: -len(route_path)]",
            "    root_url = root_url.rstrip(\"/\")",
            "",
            "    root_url = httpx.URL(root_url)",
            "    if root_path and root_url.path != root_path:",
            "        root_url = root_url.copy_with(path=root_path)",
            "",
            "    return str(root_url).rstrip(\"/\")",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class GradioUploadFile(UploadFile):",
            "    \"\"\"UploadFile with a sha attribute.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        file: BinaryIO,",
            "        *,",
            "        size: int | None = None,",
            "        filename: str | None = None,",
            "        headers: Headers | None = None,",
            "    ) -> None:",
            "        super().__init__(file, size=size, filename=filename, headers=headers)",
            "        self.sha = hashlib.sha1()",
            "",
            "",
            "@python_dataclass(frozen=True)",
            "class FileUploadProgressUnit:",
            "    filename: str",
            "    chunk_size: int",
            "",
            "",
            "@python_dataclass",
            "class FileUploadProgressTracker:",
            "    deque: deque[FileUploadProgressUnit]",
            "    is_done: bool",
            "",
            "",
            "class FileUploadProgressNotTrackedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgressNotQueuedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgress:",
            "    def __init__(self) -> None:",
            "        self._statuses: dict[str, FileUploadProgressTracker] = {}",
            "",
            "    def track(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self._statuses[upload_id] = FileUploadProgressTracker(deque(), False)",
            "",
            "    def append(self, upload_id: str, filename: str, message_bytes: bytes):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        queue = self._statuses[upload_id].deque",
            "",
            "        if len(queue) == 0:",
            "            queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "        else:",
            "            last_unit = queue.popleft()",
            "            if last_unit.filename != filename:",
            "                queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "            else:",
            "                queue.append(",
            "                    FileUploadProgressUnit(",
            "                        filename,",
            "                        last_unit.chunk_size + len(message_bytes),",
            "                    )",
            "                )",
            "",
            "    def set_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        self._statuses[upload_id].is_done = True",
            "",
            "    def is_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        return self._statuses[upload_id].is_done",
            "",
            "    def stop_tracking(self, upload_id: str):",
            "        if upload_id in self._statuses:",
            "            del self._statuses[upload_id]",
            "",
            "    def pop(self, upload_id: str) -> FileUploadProgressUnit:",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        try:",
            "            return self._statuses[upload_id].deque.pop()",
            "        except IndexError as e:",
            "            raise FileUploadProgressNotQueuedError() from e",
            "",
            "",
            "class GradioMultiPartParser:",
            "    \"\"\"Vendored from starlette.MultipartParser.",
            "",
            "    Thanks starlette!",
            "",
            "    Made the following modifications",
            "        - Use GradioUploadFile instead of UploadFile",
            "        - Use NamedTemporaryFile instead of SpooledTemporaryFile",
            "        - Compute hash of data as the request is streamed",
            "",
            "    \"\"\"",
            "",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: Union[int, float] = 1000,",
            "        max_fields: Union[int, float] = 1000,",
            "        upload_id: str | None = None,",
            "        upload_progress: FileUploadProgress | None = None,",
            "        max_file_size: int | float,",
            "    ) -> None:",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: List[Tuple[str, Union[str, UploadFile]]] = []",
            "        self.upload_id = upload_id",
            "        self.upload_progress = upload_progress",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self.max_file_size = max_file_size",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: List[Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: List[MultipartPart] = []",
            "        self._files_to_close_on_error: List[_TemporaryFileWrapper] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.append(",
            "                self.upload_id,  # type: ignore",
            "                self._current_part.file.filename,  # type: ignore",
            "                message_bytes,",
            "            )",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, str(self._charset)),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        _, options = parse_options_header(self._current_part.content_disposition or b\"\")",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], str(self._charset)",
            "            )",
            "        except KeyError as e:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            ) from e",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], str(self._charset))",
            "            tempfile = NamedTemporaryFile(delete=False)",
            "            self._files_to_close_on_error.append(tempfile)",
            "            self._current_part.file = GradioUploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if isinstance(charset, bytes):",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError as e:",
            "            raise MultiPartException(\"Missing boundary in multipart.\") from e",
            "",
            "        # Callbacks dictionary.",
            "        callbacks: multipart.multipart.MultipartCallbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        try:",
            "            # Feed the parser with data from the request.",
            "            async for chunk in self.stream:",
            "                parser.write(chunk)",
            "                # Write file data, it needs to use await with the UploadFile methods",
            "                # that call the corresponding file methods *in a threadpool*,",
            "                # otherwise, if they were called directly in the callback methods above",
            "                # (regular, non-async functions), that would block the event loop in",
            "                # the main thread.",
            "                for part, data in self._file_parts_to_write:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.write(data)",
            "                    part.file.sha.update(data)  # type: ignore",
            "                    if os.stat(part.file.file.name).st_size > self.max_file_size:",
            "                        if self.upload_progress is not None:",
            "                            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "                        raise MultiPartException(",
            "                            f\"File size exceeded maximum allowed size of {self.max_file_size} bytes.\"",
            "                        )",
            "                for part in self._file_parts_to_finish:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.seek(0)",
            "                self._file_parts_to_write.clear()",
            "                self._file_parts_to_finish.clear()",
            "        except MultiPartException as exc:",
            "            # Close all the files if there was an error.",
            "            for file in self._files_to_close_on_error:",
            "                file.close()",
            "                Path(file.name).unlink()",
            "            raise exc",
            "",
            "        parser.finalize()",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "        return FormData(self.items)",
            "",
            "",
            "def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None:",
            "    for file, dest in zip(files, destinations):",
            "        shutil.move(file, dest)",
            "",
            "",
            "def update_root_in_config(config: BlocksConfigDict, root: str) -> BlocksConfigDict:",
            "    \"\"\"",
            "    Updates the root \"key\" in the config dictionary to the new root url. If the",
            "    root url has changed, all of the urls in the config that correspond to component",
            "    file urls are updated to use the new root url.",
            "    \"\"\"",
            "    with config_lock:",
            "        previous_root = config.get(\"root\")",
            "        if previous_root is None or previous_root != root:",
            "            config[\"root\"] = root",
            "            config = processing_utils.add_root_url(config, root, previous_root)  # type: ignore",
            "    return config",
            "",
            "",
            "def compare_passwords_securely(input_password: str, correct_password: str) -> bool:",
            "    return hmac.compare_digest(input_password.encode(), correct_password.encode())",
            "",
            "",
            "def starts_with_protocol(string: str) -> bool:",
            "    \"\"\"This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)",
            "    followed by ://, or start with just //, \\\\/, /\\\\, or \\\\ as they are interpreted as SMB paths on Windows.",
            "    \"\"\"",
            "    pattern = r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-.]*://|//|\\\\\\\\|\\\\/|/\\\\)\"",
            "    return re.match(pattern, string) is not None",
            "",
            "",
            "def get_hostname(url: str) -> str:",
            "    \"\"\"",
            "    Returns the hostname of a given url, or an empty string if the url cannot be parsed.",
            "    Examples:",
            "        get_hostname(\"https://www.gradio.app\") -> \"www.gradio.app\"",
            "        get_hostname(\"localhost:7860\") -> \"localhost\"",
            "        get_hostname(\"127.0.0.1\") -> \"127.0.0.1\"",
            "    \"\"\"",
            "    if not url:",
            "        return \"\"",
            "    if \"://\" not in url:",
            "        url = \"http://\" + url",
            "    try:",
            "        return urlparse(url).hostname or \"\"",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "class CustomCORSMiddleware:",
            "    # This is a modified version of the Starlette CORSMiddleware that restricts the allowed origins when the host is localhost.",
            "    # Adapted from: https://github.com/encode/starlette/blob/89fae174a1ea10f59ae248fe030d9b7e83d0b8a0/starlette/middleware/cors.py",
            "",
            "    def __init__(",
            "        self,",
            "        app: ASGIApp,",
            "    ) -> None:",
            "        self.app = app",
            "        self.all_methods = (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\")",
            "        self.preflight_headers = {",
            "            \"Access-Control-Allow-Methods\": \", \".join(self.all_methods),",
            "            \"Access-Control-Max-Age\": str(600),",
            "            \"Access-Control-Allow-Credentials\": \"true\",",
            "        }",
            "        self.simple_headers = {\"Access-Control-Allow-Credentials\": \"true\"}",
            "        # Any of these hosts suggests that the Gradio app is running locally.",
            "        # Note: \"null\" is a special case that happens if a Gradio app is running",
            "        # as an embedded web component in a local static webpage.",
            "        self.localhost_aliases = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\", \"null\"]",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        if scope[\"type\"] != \"http\":",
            "            await self.app(scope, receive, send)",
            "            return",
            "        headers = Headers(scope=scope)",
            "        origin = headers.get(\"origin\")",
            "        if origin is None:",
            "            await self.app(scope, receive, send)",
            "            return",
            "        if scope[\"method\"] == \"OPTIONS\" and \"access-control-request-method\" in headers:",
            "            response = self.preflight_response(request_headers=headers)",
            "            await response(scope, receive, send)",
            "            return",
            "        await self.simple_response(scope, receive, send, request_headers=headers)",
            "",
            "    def preflight_response(self, request_headers: Headers) -> Response:",
            "        headers = dict(self.preflight_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            headers[\"Access-Control-Allow-Origin\"] = origin",
            "        requested_headers = request_headers.get(\"access-control-request-headers\")",
            "        if requested_headers is not None:",
            "            headers[\"Access-Control-Allow-Headers\"] = requested_headers",
            "        return PlainTextResponse(\"OK\", status_code=200, headers=headers)",
            "",
            "    async def simple_response(",
            "        self, scope: Scope, receive: Receive, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        send = functools.partial(self._send, send=send, request_headers=request_headers)",
            "        await self.app(scope, receive, send)",
            "",
            "    async def _send(",
            "        self, message: Message, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        if message[\"type\"] != \"http.response.start\":",
            "            await send(message)",
            "            return",
            "        message.setdefault(\"headers\", [])",
            "        headers = MutableHeaders(scope=message)",
            "        headers.update(self.simple_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            self.allow_explicit_origin(headers, origin)",
            "        await send(message)",
            "",
            "    def is_valid_origin(self, request_headers: Headers) -> bool:",
            "        origin = request_headers[\"Origin\"]",
            "        host = request_headers[\"Host\"]",
            "        host_name = get_hostname(host)",
            "        origin_name = get_hostname(origin)",
            "        return (",
            "            host_name not in self.localhost_aliases",
            "            or origin_name in self.localhost_aliases",
            "        )",
            "",
            "    @staticmethod",
            "    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:",
            "        headers[\"Access-Control-Allow-Origin\"] = origin",
            "        headers.add_vary_header(\"Origin\")",
            "",
            "",
            "def delete_files_created_by_app(blocks: Blocks, age: int | None) -> None:",
            "    \"\"\"Delete files that are older than age. If age is None, delete all files.\"\"\"",
            "    dont_delete = set()",
            "    for component in blocks.blocks.values():",
            "        dont_delete.update(getattr(component, \"keep_in_cache\", set()))",
            "    for temp_set in blocks.temp_file_sets:",
            "        # We use a copy of the set to avoid modifying the set while iterating over it",
            "        # otherwise we would get an exception: Set changed size during iteration",
            "        to_remove = set()",
            "        for file in temp_set:",
            "            if file in dont_delete:",
            "                continue",
            "            try:",
            "                file_path = Path(file)",
            "                modified_time = datetime.fromtimestamp(file_path.lstat().st_ctime)",
            "                if age is None or (datetime.now() - modified_time).seconds > age:",
            "                    os.remove(file)",
            "                    to_remove.add(file)",
            "            except FileNotFoundError:",
            "                continue",
            "        temp_set -= to_remove",
            "",
            "",
            "async def delete_files_on_schedule(app: App, frequency: int, age: int) -> None:",
            "    \"\"\"Startup task to delete files created by the app based on time since last modification.\"\"\"",
            "    while True:",
            "        await asyncio.sleep(frequency)",
            "        await anyio.to_thread.run_sync(",
            "            delete_files_created_by_app, app.get_blocks(), age",
            "        )",
            "",
            "",
            "@asynccontextmanager",
            "async def _lifespan_handler(",
            "    app: App, frequency: int = 1, age: int = 1",
            ") -> AsyncGenerator:",
            "    \"\"\"A context manager that triggers the startup and shutdown events of the app.\"\"\"",
            "    asyncio.create_task(delete_files_on_schedule(app, frequency, age))",
            "    yield",
            "    delete_files_created_by_app(app.get_blocks(), age=None)",
            "",
            "",
            "async def _delete_state(app: App):",
            "    \"\"\"Delete all expired state every second.\"\"\"",
            "    while True:",
            "        app.state_holder.delete_all_expired_state()",
            "        await asyncio.sleep(1)",
            "",
            "",
            "@asynccontextmanager",
            "async def _delete_state_handler(app: App):",
            "    \"\"\"When the server launches, regularly delete expired state.\"\"\"",
            "    # The stop event needs to get the current event loop for python 3.8",
            "    # but the loop parameter is deprecated for 3.8+",
            "    if sys.version_info < (3, 10):",
            "        loop = asyncio.get_running_loop()",
            "        app.stop_event = asyncio.Event(loop=loop)",
            "    asyncio.create_task(_delete_state(app))",
            "    yield",
            "",
            "",
            "def create_lifespan_handler(",
            "    user_lifespan: Callable[[App], AsyncContextManager] | None,",
            "    frequency: int | None = 1,",
            "    age: int | None = 1,",
            ") -> Callable[[App], AsyncContextManager]:",
            "    \"\"\"Return a context manager that applies _lifespan_handler and user_lifespan if it exists.\"\"\"",
            "",
            "    @asynccontextmanager",
            "    async def _handler(app: App):",
            "        async with AsyncExitStack() as stack:",
            "            await stack.enter_async_context(_delete_state_handler(app))",
            "            if frequency and age:",
            "                await stack.enter_async_context(_lifespan_handler(app, frequency, age))",
            "            if user_lifespan is not None:",
            "                await stack.enter_async_context(user_lifespan(app))",
            "            yield",
            "",
            "    return _handler"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import functools",
            "import hashlib",
            "import hmac",
            "import json",
            "import os",
            "import re",
            "import shutil",
            "import sys",
            "import threading",
            "from collections import deque",
            "from contextlib import AsyncExitStack, asynccontextmanager",
            "from dataclasses import dataclass as python_dataclass",
            "from datetime import datetime",
            "from pathlib import Path",
            "from tempfile import NamedTemporaryFile, _TemporaryFileWrapper",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    AsyncContextManager,",
            "    AsyncGenerator,",
            "    BinaryIO,",
            "    Callable,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "from urllib.parse import urlparse",
            "",
            "import anyio",
            "import fastapi",
            "import gradio_client.utils as client_utils",
            "import httpx",
            "import multipart",
            "from gradio_client.documentation import document",
            "from multipart.multipart import parse_options_header",
            "from starlette.datastructures import FormData, Headers, MutableHeaders, UploadFile",
            "from starlette.formparsers import MultiPartException, MultipartPart",
            "from starlette.responses import PlainTextResponse, Response",
            "from starlette.types import ASGIApp, Message, Receive, Scope, Send",
            "",
            "from gradio import processing_utils, utils",
            "from gradio.data_classes import (",
            "    BlocksConfigDict,",
            "    PredictBody,",
            ")",
            "from gradio.exceptions import Error",
            "from gradio.helpers import EventData",
            "from gradio.state_holder import SessionState",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import BlockFunction, Blocks",
            "    from gradio.routes import App",
            "",
            "",
            "config_lock = threading.Lock()",
            "",
            "",
            "class Obj:",
            "    \"\"\"",
            "    Using a class to convert dictionaries into objects. Used by the `Request` class.",
            "    Credit: https://www.geeksforgeeks.org/convert-nested-python-dictionary-to-object/",
            "    \"\"\"",
            "",
            "    def __init__(self, dict_):",
            "        self.__dict__.update(dict_)",
            "        for key, value in dict_.items():",
            "            if isinstance(value, (dict, list)):",
            "                value = Obj(value)",
            "            setattr(self, key, value)",
            "",
            "    def __getitem__(self, item):",
            "        return self.__dict__[item]",
            "",
            "    def __setitem__(self, item, value):",
            "        self.__dict__[item] = value",
            "",
            "    def __iter__(self):",
            "        for key, value in self.__dict__.items():",
            "            if isinstance(value, Obj):",
            "                yield (key, dict(value))",
            "            else:",
            "                yield (key, value)",
            "",
            "    def __contains__(self, item) -> bool:",
            "        if item in self.__dict__:",
            "            return True",
            "        for value in self.__dict__.values():",
            "            if isinstance(value, Obj) and item in value:",
            "                return True",
            "        return False",
            "",
            "    def get(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__[item]",
            "        return default",
            "",
            "    def keys(self):",
            "        return self.__dict__.keys()",
            "",
            "    def values(self):",
            "        return self.__dict__.values()",
            "",
            "    def items(self):",
            "        return self.__dict__.items()",
            "",
            "    def __str__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def __repr__(self) -> str:",
            "        return str(self.__dict__)",
            "",
            "    def pop(self, item, default=None):",
            "        if item in self:",
            "            return self.__dict__.pop(item)",
            "        return default",
            "",
            "",
            "@document()",
            "class Request:",
            "    \"\"\"",
            "    A Gradio request object that can be used to access the request headers, cookies,",
            "    query parameters and other information about the request from within the prediction",
            "    function. The class is a thin wrapper around the fastapi.Request class. Attributes",
            "    of this class include: `headers`, `client`, `query_params`, `session_hash`, and `path_params`. If",
            "    auth is enabled, the `username` attribute can be used to get the logged in user.",
            "    Example:",
            "        import gradio as gr",
            "        def echo(text, request: gr.Request):",
            "            if request:",
            "                print(\"Request headers dictionary:\", request.headers)",
            "                print(\"IP address:\", request.client.host)",
            "                print(\"Query parameters:\", dict(request.query_params))",
            "                print(\"Session hash:\", request.session_hash)",
            "            return text",
            "        io = gr.Interface(echo, \"textbox\", \"textbox\").launch()",
            "    Demos: request_ip_headers",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        request: fastapi.Request | None = None,",
            "        username: str | None = None,",
            "        session_hash: str | None = None,",
            "        **kwargs,",
            "    ):",
            "        \"\"\"",
            "        Can be instantiated with either a fastapi.Request or by manually passing in",
            "        attributes (needed for queueing).",
            "        Parameters:",
            "            request: A fastapi.Request",
            "            username: The username of the logged in user (if auth is enabled)",
            "            session_hash: The session hash of the current session. It is unique for each page load.",
            "        \"\"\"",
            "        self.request = request",
            "        self.username = username",
            "        self.session_hash = session_hash",
            "        self.kwargs: dict = kwargs",
            "",
            "    def dict_to_obj(self, d):",
            "        if isinstance(d, dict):",
            "            return json.loads(json.dumps(d), object_hook=Obj)",
            "        else:",
            "            return d",
            "",
            "    def __getattr__(self, name):",
            "        if self.request:",
            "            return self.dict_to_obj(getattr(self.request, name))",
            "        else:",
            "            try:",
            "                obj = self.kwargs[name]",
            "            except KeyError as ke:",
            "                raise AttributeError(",
            "                    f\"'Request' object has no attribute '{name}'\"",
            "                ) from ke",
            "            return self.dict_to_obj(obj)",
            "",
            "",
            "class FnIndexInferError(Exception):",
            "    pass",
            "",
            "",
            "def get_fn(blocks: Blocks, api_name: str | None, body: PredictBody) -> BlockFunction:",
            "    if body.session_hash:",
            "        session_state = blocks.state_holder[body.session_hash]",
            "        fns = session_state.blocks_config.fns",
            "    else:",
            "        fns = blocks.fns",
            "",
            "    if body.fn_index is None:",
            "        if api_name is not None:",
            "            for fn in fns.values():",
            "                if fn.api_name == api_name:",
            "                    return fn",
            "        raise FnIndexInferError(",
            "            f\"Could not infer function index for API name: {api_name}\"",
            "        )",
            "    else:",
            "        return fns[body.fn_index]",
            "",
            "",
            "def compile_gr_request(",
            "    body: PredictBody,",
            "    fn: BlockFunction,",
            "    username: Optional[str],",
            "    request: Optional[fastapi.Request],",
            "):",
            "    # If this fn_index cancels jobs, then the only input we need is the",
            "    # current session hash",
            "    if fn.cancels:",
            "        body.data = [body.session_hash]",
            "    if body.request:",
            "        if body.batched:",
            "            gr_request = [Request(username=username, request=request)]",
            "        else:",
            "            gr_request = Request(",
            "                username=username, request=body.request, session_hash=body.session_hash",
            "            )",
            "    else:",
            "        if request is None:",
            "            raise ValueError(\"request must be provided if body.request is None\")",
            "        gr_request = Request(",
            "            username=username, request=request, session_hash=body.session_hash",
            "        )",
            "",
            "    return gr_request",
            "",
            "",
            "def restore_session_state(app: App, body: PredictBody):",
            "    event_id = body.event_id",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    if session_hash is not None:",
            "        session_state = app.state_holder[session_hash]",
            "        # The should_reset set keeps track of the fn_indices",
            "        # that have been cancelled. When a job is cancelled,",
            "        # the /reset route will mark the jobs as having been reset.",
            "        # That way if the cancel job finishes BEFORE the job being cancelled",
            "        # the job being cancelled will not overwrite the state of the iterator.",
            "        if event_id is None:",
            "            iterator = None",
            "        elif event_id in app.iterators_to_reset:",
            "            iterator = None",
            "            app.iterators_to_reset.remove(event_id)",
            "        else:",
            "            iterator = app.iterators.get(event_id)",
            "    else:",
            "        session_state = SessionState(app.get_blocks())",
            "        iterator = None",
            "",
            "    return session_state, iterator",
            "",
            "",
            "def prepare_event_data(",
            "    blocks: Blocks,",
            "    body: PredictBody,",
            ") -> EventData:",
            "    target = body.trigger_id",
            "    event_data = EventData(",
            "        blocks.blocks.get(target) if target else None,",
            "        body.event_data,",
            "    )",
            "    return event_data",
            "",
            "",
            "async def call_process_api(",
            "    app: App,",
            "    body: PredictBody,",
            "    gr_request: Union[Request, list[Request]],",
            "    fn: BlockFunction,",
            "    root_path: str,",
            "):",
            "    session_state, iterator = restore_session_state(app=app, body=body)",
            "",
            "    event_data = prepare_event_data(app.get_blocks(), body)",
            "    event_id = body.event_id",
            "",
            "    session_hash = getattr(body, \"session_hash\", None)",
            "    inputs = body.data",
            "",
            "    batch_in_single_out = not body.batched and fn.batch",
            "    if batch_in_single_out:",
            "        inputs = [inputs]",
            "",
            "    try:",
            "        with utils.MatplotlibBackendMananger():",
            "            output = await app.get_blocks().process_api(",
            "                block_fn=fn,",
            "                inputs=inputs,",
            "                request=gr_request,",
            "                state=session_state,",
            "                iterator=iterator,",
            "                session_hash=session_hash,",
            "                event_id=event_id,",
            "                event_data=event_data,",
            "                in_event_listener=True,",
            "                simple_format=body.simple_format,",
            "                root_path=root_path,",
            "            )",
            "        iterator = output.pop(\"iterator\", None)",
            "        if event_id is not None:",
            "            app.iterators[event_id] = iterator  # type: ignore",
            "        if isinstance(output, Error):",
            "            raise output",
            "    except BaseException:",
            "        iterator = app.iterators.get(event_id) if event_id is not None else None",
            "        if iterator is not None:  # close off any streams that are still open",
            "            run_id = id(iterator)",
            "            pending_streams: dict[int, list] = (",
            "                app.get_blocks().pending_streams[session_hash].get(run_id, {})",
            "            )",
            "            for stream in pending_streams.values():",
            "                stream.append(None)",
            "        raise",
            "",
            "    if batch_in_single_out:",
            "        output[\"data\"] = output[\"data\"][0]",
            "",
            "    return output",
            "",
            "",
            "def get_root_url(",
            "    request: fastapi.Request, route_path: str, root_path: str | None",
            ") -> str:",
            "    \"\"\"",
            "    Gets the root url of the Gradio app (i.e. the public url of the app) without a trailing slash.",
            "",
            "    This is how the root_url is resolved:",
            "    1. If a user provides a `root_path` manually that is a full URL, it is returned directly.",
            "    2. If the request has an x-forwarded-host header (e.g. because it is behind a proxy), the root url is",
            "    constructed from the x-forwarded-host header. In this case, `route_path` is not used to construct the root url.",
            "    3. Otherwise, the root url is constructed from the request url. The query parameters and `route_path` are stripped off.",
            "    And if a relative `root_path` is provided, and it is not already the subpath of the URL, it is appended to the root url.",
            "",
            "    In cases (2) and (3), We also check to see if the x-forwarded-proto header is present, and if so, convert the root url to https.",
            "    And if there are multiple hosts in the x-forwarded-host or multiple protocols in the x-forwarded-proto, the first one is used.",
            "    \"\"\"",
            "",
            "    def get_first_header_value(header_name: str):",
            "        header_value = request.headers.get(header_name)",
            "        if header_value:",
            "            return header_value.split(\",\")[0].strip()",
            "        return None",
            "",
            "    if root_path and client_utils.is_http_url_like(root_path):",
            "        return root_path.rstrip(\"/\")",
            "",
            "    x_forwarded_host = get_first_header_value(\"x-forwarded-host\")",
            "    root_url = f\"http://{x_forwarded_host}\" if x_forwarded_host else str(request.url)",
            "    root_url = httpx.URL(root_url)",
            "    root_url = root_url.copy_with(query=None)",
            "    root_url = str(root_url).rstrip(\"/\")",
            "    if get_first_header_value(\"x-forwarded-proto\") == \"https\":",
            "        root_url = root_url.replace(\"http://\", \"https://\")",
            "",
            "    route_path = route_path.rstrip(\"/\")",
            "    if len(route_path) > 0 and not x_forwarded_host:",
            "        root_url = root_url[: -len(route_path)]",
            "    root_url = root_url.rstrip(\"/\")",
            "",
            "    root_url = httpx.URL(root_url)",
            "    if root_path and root_url.path != root_path:",
            "        root_url = root_url.copy_with(path=root_path)",
            "",
            "    return str(root_url).rstrip(\"/\")",
            "",
            "",
            "def _user_safe_decode(src: bytes, codec: str) -> str:",
            "    try:",
            "        return src.decode(codec)",
            "    except (UnicodeDecodeError, LookupError):",
            "        return src.decode(\"latin-1\")",
            "",
            "",
            "class GradioUploadFile(UploadFile):",
            "    \"\"\"UploadFile with a sha attribute.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        file: BinaryIO,",
            "        *,",
            "        size: int | None = None,",
            "        filename: str | None = None,",
            "        headers: Headers | None = None,",
            "    ) -> None:",
            "        super().__init__(file, size=size, filename=filename, headers=headers)",
            "        self.sha = hashlib.sha1()",
            "",
            "",
            "@python_dataclass(frozen=True)",
            "class FileUploadProgressUnit:",
            "    filename: str",
            "    chunk_size: int",
            "",
            "",
            "@python_dataclass",
            "class FileUploadProgressTracker:",
            "    deque: deque[FileUploadProgressUnit]",
            "    is_done: bool",
            "",
            "",
            "class FileUploadProgressNotTrackedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgressNotQueuedError(Exception):",
            "    pass",
            "",
            "",
            "class FileUploadProgress:",
            "    def __init__(self) -> None:",
            "        self._statuses: dict[str, FileUploadProgressTracker] = {}",
            "",
            "    def track(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self._statuses[upload_id] = FileUploadProgressTracker(deque(), False)",
            "",
            "    def append(self, upload_id: str, filename: str, message_bytes: bytes):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        queue = self._statuses[upload_id].deque",
            "",
            "        if len(queue) == 0:",
            "            queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "        else:",
            "            last_unit = queue.popleft()",
            "            if last_unit.filename != filename:",
            "                queue.append(FileUploadProgressUnit(filename, len(message_bytes)))",
            "            else:",
            "                queue.append(",
            "                    FileUploadProgressUnit(",
            "                        filename,",
            "                        last_unit.chunk_size + len(message_bytes),",
            "                    )",
            "                )",
            "",
            "    def set_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            self.track(upload_id)",
            "        self._statuses[upload_id].is_done = True",
            "",
            "    def is_done(self, upload_id: str):",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        return self._statuses[upload_id].is_done",
            "",
            "    def stop_tracking(self, upload_id: str):",
            "        if upload_id in self._statuses:",
            "            del self._statuses[upload_id]",
            "",
            "    def pop(self, upload_id: str) -> FileUploadProgressUnit:",
            "        if upload_id not in self._statuses:",
            "            raise FileUploadProgressNotTrackedError()",
            "        try:",
            "            return self._statuses[upload_id].deque.pop()",
            "        except IndexError as e:",
            "            raise FileUploadProgressNotQueuedError() from e",
            "",
            "",
            "class GradioMultiPartParser:",
            "    \"\"\"Vendored from starlette.MultipartParser.",
            "",
            "    Thanks starlette!",
            "",
            "    Made the following modifications",
            "        - Use GradioUploadFile instead of UploadFile",
            "        - Use NamedTemporaryFile instead of SpooledTemporaryFile",
            "        - Compute hash of data as the request is streamed",
            "",
            "    \"\"\"",
            "",
            "    max_file_size = 1024 * 1024",
            "",
            "    def __init__(",
            "        self,",
            "        headers: Headers,",
            "        stream: AsyncGenerator[bytes, None],",
            "        *,",
            "        max_files: Union[int, float] = 1000,",
            "        max_fields: Union[int, float] = 1000,",
            "        upload_id: str | None = None,",
            "        upload_progress: FileUploadProgress | None = None,",
            "        max_file_size: int | float,",
            "    ) -> None:",
            "        self.headers = headers",
            "        self.stream = stream",
            "        self.max_files = max_files",
            "        self.max_fields = max_fields",
            "        self.items: List[Tuple[str, Union[str, UploadFile]]] = []",
            "        self.upload_id = upload_id",
            "        self.upload_progress = upload_progress",
            "        self._current_files = 0",
            "        self._current_fields = 0",
            "        self.max_file_size = max_file_size",
            "        self._current_partial_header_name: bytes = b\"\"",
            "        self._current_partial_header_value: bytes = b\"\"",
            "        self._current_part = MultipartPart()",
            "        self._charset = \"\"",
            "        self._file_parts_to_write: List[Tuple[MultipartPart, bytes]] = []",
            "        self._file_parts_to_finish: List[MultipartPart] = []",
            "        self._files_to_close_on_error: List[_TemporaryFileWrapper] = []",
            "",
            "    def on_part_begin(self) -> None:",
            "        self._current_part = MultipartPart()",
            "",
            "    def on_part_data(self, data: bytes, start: int, end: int) -> None:",
            "        message_bytes = data[start:end]",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.append(",
            "                self.upload_id,  # type: ignore",
            "                self._current_part.file.filename,  # type: ignore",
            "                message_bytes,",
            "            )",
            "        if self._current_part.file is None:",
            "            self._current_part.data += message_bytes",
            "        else:",
            "            self._file_parts_to_write.append((self._current_part, message_bytes))",
            "",
            "    def on_part_end(self) -> None:",
            "        if self._current_part.file is None:",
            "            self.items.append(",
            "                (",
            "                    self._current_part.field_name,",
            "                    _user_safe_decode(self._current_part.data, str(self._charset)),",
            "                )",
            "            )",
            "        else:",
            "            self._file_parts_to_finish.append(self._current_part)",
            "            # The file can be added to the items right now even though it's not",
            "            # finished yet, because it will be finished in the `parse()` method, before",
            "            # self.items is used in the return value.",
            "            self.items.append((self._current_part.field_name, self._current_part.file))",
            "",
            "    def on_header_field(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_name += data[start:end]",
            "",
            "    def on_header_value(self, data: bytes, start: int, end: int) -> None:",
            "        self._current_partial_header_value += data[start:end]",
            "",
            "    def on_header_end(self) -> None:",
            "        field = self._current_partial_header_name.lower()",
            "        if field == b\"content-disposition\":",
            "            self._current_part.content_disposition = self._current_partial_header_value",
            "        self._current_part.item_headers.append(",
            "            (field, self._current_partial_header_value)",
            "        )",
            "        self._current_partial_header_name = b\"\"",
            "        self._current_partial_header_value = b\"\"",
            "",
            "    def on_headers_finished(self) -> None:",
            "        _, options = parse_options_header(self._current_part.content_disposition or b\"\")",
            "        try:",
            "            self._current_part.field_name = _user_safe_decode(",
            "                options[b\"name\"], str(self._charset)",
            "            )",
            "        except KeyError as e:",
            "            raise MultiPartException(",
            "                'The Content-Disposition header field \"name\" must be ' \"provided.\"",
            "            ) from e",
            "        if b\"filename\" in options:",
            "            self._current_files += 1",
            "            if self._current_files > self.max_files:",
            "                raise MultiPartException(",
            "                    f\"Too many files. Maximum number of files is {self.max_files}.\"",
            "                )",
            "            filename = _user_safe_decode(options[b\"filename\"], str(self._charset))",
            "            tempfile = NamedTemporaryFile(delete=False)",
            "            self._files_to_close_on_error.append(tempfile)",
            "            self._current_part.file = GradioUploadFile(",
            "                file=tempfile,  # type: ignore[arg-type]",
            "                size=0,",
            "                filename=filename,",
            "                headers=Headers(raw=self._current_part.item_headers),",
            "            )",
            "        else:",
            "            self._current_fields += 1",
            "            if self._current_fields > self.max_fields:",
            "                raise MultiPartException(",
            "                    f\"Too many fields. Maximum number of fields is {self.max_fields}.\"",
            "                )",
            "            self._current_part.file = None",
            "",
            "    def on_end(self) -> None:",
            "        pass",
            "",
            "    async def parse(self) -> FormData:",
            "        # Parse the Content-Type header to get the multipart boundary.",
            "        _, params = parse_options_header(self.headers[\"Content-Type\"])",
            "        charset = params.get(b\"charset\", \"utf-8\")",
            "        if isinstance(charset, bytes):",
            "            charset = charset.decode(\"latin-1\")",
            "        self._charset = charset",
            "        try:",
            "            boundary = params[b\"boundary\"]",
            "        except KeyError as e:",
            "            raise MultiPartException(\"Missing boundary in multipart.\") from e",
            "",
            "        # Callbacks dictionary.",
            "        callbacks: multipart.multipart.MultipartCallbacks = {",
            "            \"on_part_begin\": self.on_part_begin,",
            "            \"on_part_data\": self.on_part_data,",
            "            \"on_part_end\": self.on_part_end,",
            "            \"on_header_field\": self.on_header_field,",
            "            \"on_header_value\": self.on_header_value,",
            "            \"on_header_end\": self.on_header_end,",
            "            \"on_headers_finished\": self.on_headers_finished,",
            "            \"on_end\": self.on_end,",
            "        }",
            "",
            "        # Create the parser.",
            "        parser = multipart.MultipartParser(boundary, callbacks)",
            "        try:",
            "            # Feed the parser with data from the request.",
            "            async for chunk in self.stream:",
            "                parser.write(chunk)",
            "                # Write file data, it needs to use await with the UploadFile methods",
            "                # that call the corresponding file methods *in a threadpool*,",
            "                # otherwise, if they were called directly in the callback methods above",
            "                # (regular, non-async functions), that would block the event loop in",
            "                # the main thread.",
            "                for part, data in self._file_parts_to_write:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.write(data)",
            "                    part.file.sha.update(data)  # type: ignore",
            "                    if os.stat(part.file.file.name).st_size > self.max_file_size:",
            "                        if self.upload_progress is not None:",
            "                            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "                        raise MultiPartException(",
            "                            f\"File size exceeded maximum allowed size of {self.max_file_size} bytes.\"",
            "                        )",
            "                for part in self._file_parts_to_finish:",
            "                    assert part.file  # for type checkers  # noqa: S101",
            "                    await part.file.seek(0)",
            "                self._file_parts_to_write.clear()",
            "                self._file_parts_to_finish.clear()",
            "        except MultiPartException as exc:",
            "            # Close all the files if there was an error.",
            "            for file in self._files_to_close_on_error:",
            "                file.close()",
            "                Path(file.name).unlink()",
            "            raise exc",
            "",
            "        parser.finalize()",
            "        if self.upload_progress is not None:",
            "            self.upload_progress.set_done(self.upload_id)  # type: ignore",
            "        return FormData(self.items)",
            "",
            "",
            "def move_uploaded_files_to_cache(files: list[str], destinations: list[str]) -> None:",
            "    for file, dest in zip(files, destinations):",
            "        shutil.move(file, dest)",
            "",
            "",
            "def update_root_in_config(config: BlocksConfigDict, root: str) -> BlocksConfigDict:",
            "    \"\"\"",
            "    Updates the root \"key\" in the config dictionary to the new root url. If the",
            "    root url has changed, all of the urls in the config that correspond to component",
            "    file urls are updated to use the new root url.",
            "    \"\"\"",
            "    with config_lock:",
            "        previous_root = config.get(\"root\")",
            "        if previous_root is None or previous_root != root:",
            "            config[\"root\"] = root",
            "            config = processing_utils.add_root_url(config, root, previous_root)  # type: ignore",
            "    return config",
            "",
            "",
            "def compare_passwords_securely(input_password: str, correct_password: str) -> bool:",
            "    return hmac.compare_digest(input_password.encode(), correct_password.encode())",
            "",
            "",
            "def starts_with_protocol(string: str) -> bool:",
            "    \"\"\"This regex matches strings that start with a scheme (one or more characters not including colon, slash, or space)",
            "    followed by ://, or start with just //, \\\\/, /\\\\, or \\\\ as they are interpreted as SMB paths on Windows.",
            "    \"\"\"",
            "    pattern = r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-.]*://|//|\\\\\\\\|\\\\/|/\\\\)\"",
            "    return re.match(pattern, string) is not None",
            "",
            "",
            "def get_hostname(url: str) -> str:",
            "    \"\"\"",
            "    Returns the hostname of a given url, or an empty string if the url cannot be parsed.",
            "    Examples:",
            "        get_hostname(\"https://www.gradio.app\") -> \"www.gradio.app\"",
            "        get_hostname(\"localhost:7860\") -> \"localhost\"",
            "        get_hostname(\"127.0.0.1\") -> \"127.0.0.1\"",
            "    \"\"\"",
            "    if not url:",
            "        return \"\"",
            "    if \"://\" not in url:",
            "        url = \"http://\" + url",
            "    try:",
            "        return urlparse(url).hostname or \"\"",
            "    except Exception:",
            "        return \"\"",
            "",
            "",
            "class CustomCORSMiddleware:",
            "    # This is a modified version of the Starlette CORSMiddleware that restricts the allowed origins when the host is localhost.",
            "    # Adapted from: https://github.com/encode/starlette/blob/89fae174a1ea10f59ae248fe030d9b7e83d0b8a0/starlette/middleware/cors.py",
            "",
            "    def __init__(",
            "        self,",
            "        app: ASGIApp,",
            "    ) -> None:",
            "        self.app = app",
            "        self.all_methods = (\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\")",
            "        self.preflight_headers = {",
            "            \"Access-Control-Allow-Methods\": \", \".join(self.all_methods),",
            "            \"Access-Control-Max-Age\": str(600),",
            "            \"Access-Control-Allow-Credentials\": \"true\",",
            "        }",
            "        self.simple_headers = {\"Access-Control-Allow-Credentials\": \"true\"}",
            "        # Any of these hosts suggests that the Gradio app is running locally.",
            "        # Note: \"null\" is a special case that happens if a Gradio app is running",
            "        # as an embedded web component in a local static webpage.",
            "        self.localhost_aliases = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\", \"null\"]",
            "",
            "    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:",
            "        if scope[\"type\"] != \"http\":",
            "            await self.app(scope, receive, send)",
            "            return",
            "        headers = Headers(scope=scope)",
            "        origin = headers.get(\"origin\")",
            "        if origin is None:",
            "            await self.app(scope, receive, send)",
            "            return",
            "        if scope[\"method\"] == \"OPTIONS\" and \"access-control-request-method\" in headers:",
            "            response = self.preflight_response(request_headers=headers)",
            "            await response(scope, receive, send)",
            "            return",
            "        await self.simple_response(scope, receive, send, request_headers=headers)",
            "",
            "    def preflight_response(self, request_headers: Headers) -> Response:",
            "        headers = dict(self.preflight_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            headers[\"Access-Control-Allow-Origin\"] = origin",
            "        requested_headers = request_headers.get(\"access-control-request-headers\")",
            "        if requested_headers is not None:",
            "            headers[\"Access-Control-Allow-Headers\"] = requested_headers",
            "        return PlainTextResponse(\"OK\", status_code=200, headers=headers)",
            "",
            "    async def simple_response(",
            "        self, scope: Scope, receive: Receive, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        send = functools.partial(self._send, send=send, request_headers=request_headers)",
            "        await self.app(scope, receive, send)",
            "",
            "    async def _send(",
            "        self, message: Message, send: Send, request_headers: Headers",
            "    ) -> None:",
            "        if message[\"type\"] != \"http.response.start\":",
            "            await send(message)",
            "            return",
            "        message.setdefault(\"headers\", [])",
            "        headers = MutableHeaders(scope=message)",
            "        headers.update(self.simple_headers)",
            "        origin = request_headers[\"Origin\"]",
            "        if self.is_valid_origin(request_headers):",
            "            self.allow_explicit_origin(headers, origin)",
            "        await send(message)",
            "",
            "    def is_valid_origin(self, request_headers: Headers) -> bool:",
            "        origin = request_headers[\"Origin\"]",
            "        host = request_headers[\"Host\"]",
            "        host_name = get_hostname(host)",
            "        origin_name = get_hostname(origin)",
            "        return (",
            "            host_name not in self.localhost_aliases",
            "            or origin_name in self.localhost_aliases",
            "        )",
            "",
            "    @staticmethod",
            "    def allow_explicit_origin(headers: MutableHeaders, origin: str) -> None:",
            "        headers[\"Access-Control-Allow-Origin\"] = origin",
            "        headers.add_vary_header(\"Origin\")",
            "",
            "",
            "def delete_files_created_by_app(blocks: Blocks, age: int | None) -> None:",
            "    \"\"\"Delete files that are older than age. If age is None, delete all files.\"\"\"",
            "    dont_delete = set()",
            "    for component in blocks.blocks.values():",
            "        dont_delete.update(getattr(component, \"keep_in_cache\", set()))",
            "    for temp_set in blocks.temp_file_sets:",
            "        # We use a copy of the set to avoid modifying the set while iterating over it",
            "        # otherwise we would get an exception: Set changed size during iteration",
            "        to_remove = set()",
            "        for file in temp_set:",
            "            if file in dont_delete:",
            "                continue",
            "            try:",
            "                file_path = Path(file)",
            "                modified_time = datetime.fromtimestamp(file_path.lstat().st_ctime)",
            "                if age is None or (datetime.now() - modified_time).seconds > age:",
            "                    os.remove(file)",
            "                    to_remove.add(file)",
            "            except FileNotFoundError:",
            "                continue",
            "        temp_set -= to_remove",
            "",
            "",
            "async def delete_files_on_schedule(app: App, frequency: int, age: int) -> None:",
            "    \"\"\"Startup task to delete files created by the app based on time since last modification.\"\"\"",
            "    while True:",
            "        await asyncio.sleep(frequency)",
            "        await anyio.to_thread.run_sync(",
            "            delete_files_created_by_app, app.get_blocks(), age",
            "        )",
            "",
            "",
            "@asynccontextmanager",
            "async def _lifespan_handler(",
            "    app: App, frequency: int = 1, age: int = 1",
            ") -> AsyncGenerator:",
            "    \"\"\"A context manager that triggers the startup and shutdown events of the app.\"\"\"",
            "    asyncio.create_task(delete_files_on_schedule(app, frequency, age))",
            "    yield",
            "    delete_files_created_by_app(app.get_blocks(), age=None)",
            "",
            "",
            "async def _delete_state(app: App):",
            "    \"\"\"Delete all expired state every second.\"\"\"",
            "    while True:",
            "        app.state_holder.delete_all_expired_state()",
            "        await asyncio.sleep(1)",
            "",
            "",
            "@asynccontextmanager",
            "async def _delete_state_handler(app: App):",
            "    \"\"\"When the server launches, regularly delete expired state.\"\"\"",
            "    # The stop event needs to get the current event loop for python 3.8",
            "    # but the loop parameter is deprecated for 3.8+",
            "    if sys.version_info < (3, 10):",
            "        loop = asyncio.get_running_loop()",
            "        app.stop_event = asyncio.Event(loop=loop)",
            "    asyncio.create_task(_delete_state(app))",
            "    yield",
            "",
            "",
            "def create_lifespan_handler(",
            "    user_lifespan: Callable[[App], AsyncContextManager] | None,",
            "    frequency: int | None = 1,",
            "    age: int | None = 1,",
            ") -> Callable[[App], AsyncContextManager]:",
            "    \"\"\"Return a context manager that applies _lifespan_handler and user_lifespan if it exists.\"\"\"",
            "",
            "    @asynccontextmanager",
            "    async def _handler(app: App):",
            "        async with AsyncExitStack() as stack:",
            "            await stack.enter_async_context(_delete_state_handler(app))",
            "            if frequency and age:",
            "                await stack.enter_async_context(_lifespan_handler(app, frequency, age))",
            "            if user_lifespan is not None:",
            "                await stack.enter_async_context(user_lifespan(app))",
            "            yield",
            "",
            "    return _handler"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "45": []
        },
        "addLocation": []
    },
    "gradio/routes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import json"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import mimetypes"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import posixpath"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import secrets"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import time"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import traceback"
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "     Optional,"
            },
            "8": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     Type,"
            },
            "9": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     Union,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    cast,"
            },
            "11": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " )"
            },
            "12": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " import fastapi"
            },
            "14": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     ComponentServerBlobBody,"
            },
            "15": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "     ComponentServerJSONBody,"
            },
            "16": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     DataWithFiles,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+    DeveloperPath,"
            },
            "18": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     PredictBody,"
            },
            "19": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     ResetBody,"
            },
            "20": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "     SimplePredictBody,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    UserProvidedPath,"
            },
            "22": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " )"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+from gradio.exceptions import InvalidPathError"
            },
            "24": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " from gradio.oauth import attach_oauth"
            },
            "25": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " from gradio.route_utils import (  # noqa: F401"
            },
            "26": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     CustomCORSMiddleware,"
            },
            "27": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 112,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 113,
                "PatchRowcode": " mimetypes.init()"
            },
            "29": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-STATIC_TEMPLATE_LIB = files(\"gradio\").joinpath(\"templates\").as_posix()  # type: ignore"
            },
            "31": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-STATIC_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix()  # type: ignore"
            },
            "32": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-BUILD_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix()  # type: ignore"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+STATIC_TEMPLATE_LIB = cast("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+    DeveloperPath,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+    files(\"gradio\").joinpath(\"templates\").as_posix(),  # type: ignore"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+STATIC_PATH_LIB = cast("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+    DeveloperPath,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix(),  # type: ignore"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+BUILD_PATH_LIB = cast("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    DeveloperPath,"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix(),  # type: ignore"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+)"
            },
            "45": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " VERSION = get_package_version()"
            },
            "46": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 458,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 459,
                "PatchRowcode": "         @app.get(\"/static/{path:path}\")"
            },
            "50": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "         def static_resource(path: str):"
            },
            "51": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            static_file = safe_join(STATIC_PATH_LIB, path)"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+            static_file = routes_safe_join(STATIC_PATH_LIB, UserProvidedPath(path))"
            },
            "53": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "             return FileResponse(static_file)"
            },
            "54": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": 463,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": 464,
                "PatchRowcode": "         @app.get(\"/custom_component/{id}/{type}/{file_name}\")"
            },
            "56": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "             location = next("
            },
            "57": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "                 (item for item in components if item[\"component_class_id\"] == id), None"
            },
            "58": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "             )"
            },
            "59": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "60": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 473,
                "PatchRowcode": "             if location is None:"
            },
            "61": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 474,
                "PatchRowcode": "                 raise HTTPException(status_code=404, detail=\"Component not found.\")"
            },
            "62": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 475,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 470,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "             if module_path is None or component_instance is None:"
            },
            "64": {
                "beforePatchRowNumber": 471,
                "afterPatchRowNumber": 482,
                "PatchRowcode": "                 raise HTTPException(status_code=404, detail=\"Component not found.\")"
            },
            "65": {
                "beforePatchRowNumber": 472,
                "afterPatchRowNumber": 483,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path = safe_join("
            },
            "67": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                str(Path(module_path).parent),"
            },
            "68": {
                "beforePatchRowNumber": 475,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                f\"{component_instance.__class__.TEMPLATE_DIR}/{type}/{file_name}\","
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+            requested_path = utils.safe_join("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+                component_instance.__class__.TEMPLATE_DIR,"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+                UserProvidedPath(f\"{type}/{file_name}\"),"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+            )"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+            path = routes_safe_join("
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+                DeveloperPath(str(Path(module_path).parent)),"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+                UserProvidedPath(requested_path),"
            },
            "77": {
                "beforePatchRowNumber": 476,
                "afterPatchRowNumber": 492,
                "PatchRowcode": "             )"
            },
            "78": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": 493,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 478,
                "afterPatchRowNumber": 494,
                "PatchRowcode": "             key = f\"{id}-{type}-{file_name}\""
            },
            "80": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 510,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "         @app.get(\"/assets/{path:path}\")"
            },
            "82": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "         def build_resource(path: str):"
            },
            "83": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            build_file = safe_join(BUILD_PATH_LIB, path)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 513,
                "PatchRowcode": "+            build_file = routes_safe_join(BUILD_PATH_LIB, UserProvidedPath(path))"
            },
            "85": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "             return FileResponse(build_file)"
            },
            "86": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 515,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 516,
                "PatchRowcode": "         @app.get(\"/favicon.ico\")"
            },
            "88": {
                "beforePatchRowNumber": 543,
                "afterPatchRowNumber": 559,
                "PatchRowcode": " "
            },
            "89": {
                "beforePatchRowNumber": 544,
                "afterPatchRowNumber": 560,
                "PatchRowcode": "             is_dir = abs_path.is_dir()"
            },
            "90": {
                "beforePatchRowNumber": 545,
                "afterPatchRowNumber": 561,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 546,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if in_blocklist or is_dir:"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 562,
                "PatchRowcode": "+            if is_dir or in_blocklist:"
            },
            "93": {
                "beforePatchRowNumber": 547,
                "afterPatchRowNumber": 563,
                "PatchRowcode": "                 raise HTTPException(403, f\"File not allowed: {path_or_url}.\")"
            },
            "94": {
                "beforePatchRowNumber": 548,
                "afterPatchRowNumber": 564,
                "PatchRowcode": " "
            },
            "95": {
                "beforePatchRowNumber": 549,
                "afterPatchRowNumber": 565,
                "PatchRowcode": "             created_by_app = False"
            },
            "96": {
                "beforePatchRowNumber": 1142,
                "afterPatchRowNumber": 1158,
                "PatchRowcode": "                     name = f\"tmp{secrets.token_hex(5)}\""
            },
            "97": {
                "beforePatchRowNumber": 1143,
                "afterPatchRowNumber": 1159,
                "PatchRowcode": "                 directory = Path(app.uploaded_file_dir) / temp_file.sha.hexdigest()"
            },
            "98": {
                "beforePatchRowNumber": 1144,
                "afterPatchRowNumber": 1160,
                "PatchRowcode": "                 directory.mkdir(exist_ok=True, parents=True)"
            },
            "99": {
                "beforePatchRowNumber": 1145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                dest = (directory / name).resolve()"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1161,
                "PatchRowcode": "+                try:"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1162,
                "PatchRowcode": "+                    dest = utils.safe_join("
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1163,
                "PatchRowcode": "+                        DeveloperPath(str(directory)), UserProvidedPath(name)"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1164,
                "PatchRowcode": "+                    )"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1165,
                "PatchRowcode": "+                except InvalidPathError as err:"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1166,
                "PatchRowcode": "+                    raise HTTPException("
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1167,
                "PatchRowcode": "+                        status_code=400, detail=f\"Invalid file name: {name}\""
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1168,
                "PatchRowcode": "+                    ) from err"
            },
            "108": {
                "beforePatchRowNumber": 1146,
                "afterPatchRowNumber": 1169,
                "PatchRowcode": "                 temp_file.file.close()"
            },
            "109": {
                "beforePatchRowNumber": 1147,
                "afterPatchRowNumber": 1170,
                "PatchRowcode": "                 # we need to move the temp file to the cache directory"
            },
            "110": {
                "beforePatchRowNumber": 1148,
                "afterPatchRowNumber": 1171,
                "PatchRowcode": "                 # but that's possibly blocking and we're in an async function"
            },
            "111": {
                "beforePatchRowNumber": 1153,
                "afterPatchRowNumber": 1176,
                "PatchRowcode": "                     os.rename(temp_file.file.name, dest)"
            },
            "112": {
                "beforePatchRowNumber": 1154,
                "afterPatchRowNumber": 1177,
                "PatchRowcode": "                 except OSError:"
            },
            "113": {
                "beforePatchRowNumber": 1155,
                "afterPatchRowNumber": 1178,
                "PatchRowcode": "                     files_to_copy.append(temp_file.file.name)"
            },
            "114": {
                "beforePatchRowNumber": 1156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    locations.append(str(dest))"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1179,
                "PatchRowcode": "+                    locations.append(dest)"
            },
            "116": {
                "beforePatchRowNumber": 1157,
                "afterPatchRowNumber": 1180,
                "PatchRowcode": "                 output_files.append(dest)"
            },
            "117": {
                "beforePatchRowNumber": 1158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                blocks.upload_file_set.add(str(dest))"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1181,
                "PatchRowcode": "+                blocks.upload_file_set.add(dest)"
            },
            "119": {
                "beforePatchRowNumber": 1159,
                "afterPatchRowNumber": 1182,
                "PatchRowcode": "             if files_to_copy:"
            },
            "120": {
                "beforePatchRowNumber": 1160,
                "afterPatchRowNumber": 1183,
                "PatchRowcode": "                 bg_tasks.add_task("
            },
            "121": {
                "beforePatchRowNumber": 1161,
                "afterPatchRowNumber": 1184,
                "PatchRowcode": "                     move_uploaded_files_to_cache, files_to_copy, locations"
            },
            "122": {
                "beforePatchRowNumber": 1218,
                "afterPatchRowNumber": 1241,
                "PatchRowcode": " ########"
            },
            "123": {
                "beforePatchRowNumber": 1219,
                "afterPatchRowNumber": 1242,
                "PatchRowcode": " "
            },
            "124": {
                "beforePatchRowNumber": 1220,
                "afterPatchRowNumber": 1243,
                "PatchRowcode": " "
            },
            "125": {
                "beforePatchRowNumber": 1221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def safe_join(directory: str, path: str) -> str:"
            },
            "126": {
                "beforePatchRowNumber": 1222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"Safely path to a base directory to avoid escaping the base directory."
            },
            "127": {
                "beforePatchRowNumber": 1223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Borrowed from: werkzeug.security.safe_join\"\"\""
            },
            "128": {
                "beforePatchRowNumber": 1224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    _os_alt_seps: List[str] = ["
            },
            "129": {
                "beforePatchRowNumber": 1225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sep for sep in [os.path.sep, os.path.altsep] if sep is not None and sep != \"/\""
            },
            "130": {
                "beforePatchRowNumber": 1226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ]"
            },
            "131": {
                "beforePatchRowNumber": 1227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1244,
                "PatchRowcode": "+def routes_safe_join(directory: DeveloperPath, path: UserProvidedPath) -> str:"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1245,
                "PatchRowcode": "+    \"\"\"Safely join the user path to the directory while performing some additional http-related checks,"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1246,
                "PatchRowcode": "+    e.g. ensuring that the full path exists on the local file system and is not a directory\"\"\""
            },
            "135": {
                "beforePatchRowNumber": 1228,
                "afterPatchRowNumber": 1247,
                "PatchRowcode": "     if path == \"\":"
            },
            "136": {
                "beforePatchRowNumber": 1229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(400)"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1248,
                "PatchRowcode": "+        raise fastapi.HTTPException(400)"
            },
            "138": {
                "beforePatchRowNumber": 1230,
                "afterPatchRowNumber": 1249,
                "PatchRowcode": "     if route_utils.starts_with_protocol(path):"
            },
            "139": {
                "beforePatchRowNumber": 1231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(403)"
            },
            "140": {
                "beforePatchRowNumber": 1232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    filename = posixpath.normpath(path)"
            },
            "141": {
                "beforePatchRowNumber": 1233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fullpath = os.path.join(directory, filename)"
            },
            "142": {
                "beforePatchRowNumber": 1234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if ("
            },
            "143": {
                "beforePatchRowNumber": 1235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        any(sep in filename for sep in _os_alt_seps)"
            },
            "144": {
                "beforePatchRowNumber": 1236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or os.path.isabs(filename)"
            },
            "145": {
                "beforePatchRowNumber": 1237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or filename == \"..\""
            },
            "146": {
                "beforePatchRowNumber": 1238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or filename.startswith(\"../\")"
            },
            "147": {
                "beforePatchRowNumber": 1239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        or os.path.isdir(fullpath)"
            },
            "148": {
                "beforePatchRowNumber": 1240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    ):"
            },
            "149": {
                "beforePatchRowNumber": 1241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(403)"
            },
            "150": {
                "beforePatchRowNumber": 1242,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "151": {
                "beforePatchRowNumber": 1243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not os.path.exists(fullpath):"
            },
            "152": {
                "beforePatchRowNumber": 1244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(404, \"File not found\")"
            },
            "153": {
                "beforePatchRowNumber": 1245,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "154": {
                "beforePatchRowNumber": 1246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return fullpath"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1250,
                "PatchRowcode": "+        raise fastapi.HTTPException(403)"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1251,
                "PatchRowcode": "+    try:"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1252,
                "PatchRowcode": "+        fullpath = Path(utils.safe_join(directory, path))"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1253,
                "PatchRowcode": "+    except InvalidPathError as e:"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1254,
                "PatchRowcode": "+        raise fastapi.HTTPException(403) from e"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1255,
                "PatchRowcode": "+    if fullpath.is_dir():"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1256,
                "PatchRowcode": "+        raise fastapi.HTTPException(403)"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1257,
                "PatchRowcode": "+    if not fullpath.exists():"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1258,
                "PatchRowcode": "+        raise fastapi.HTTPException(404)"
            },
            "164": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1259,
                "PatchRowcode": "+    return str(fullpath)"
            },
            "165": {
                "beforePatchRowNumber": 1247,
                "afterPatchRowNumber": 1260,
                "PatchRowcode": " "
            },
            "166": {
                "beforePatchRowNumber": 1248,
                "afterPatchRowNumber": 1261,
                "PatchRowcode": " "
            },
            "167": {
                "beforePatchRowNumber": 1249,
                "afterPatchRowNumber": 1262,
                "PatchRowcode": " def get_types(cls_set: List[Type]):"
            }
        },
        "frontPatchFile": [
            "\"\"\"Implements a FastAPI server to run the gradio interface. Note that some types in this",
            "module use the Optional/Union notation so that they work correctly with pydantic.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import contextlib",
            "import math",
            "import sys",
            "import warnings",
            "",
            "if sys.version_info >= (3, 9):",
            "    from importlib.resources import files",
            "else:",
            "    from importlib_resources import files",
            "import hashlib",
            "import inspect",
            "import json",
            "import mimetypes",
            "import os",
            "import posixpath",
            "import secrets",
            "import time",
            "import traceback",
            "from pathlib import Path",
            "from queue import Empty as EmptyQueue",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Literal,",
            "    Optional,",
            "    Type,",
            "    Union,",
            ")",
            "",
            "import fastapi",
            "import httpx",
            "import markupsafe",
            "import orjson",
            "from fastapi import (",
            "    BackgroundTasks,",
            "    Depends,",
            "    FastAPI,",
            "    HTTPException,",
            "    status,",
            ")",
            "from fastapi.responses import (",
            "    FileResponse,",
            "    HTMLResponse,",
            "    JSONResponse,",
            "    PlainTextResponse,",
            ")",
            "from fastapi.security import OAuth2PasswordRequestForm",
            "from fastapi.templating import Jinja2Templates",
            "from gradio_client import utils as client_utils",
            "from gradio_client.documentation import document",
            "from gradio_client.utils import ServerMessage",
            "from jinja2.exceptions import TemplateNotFound",
            "from multipart.multipart import parse_options_header",
            "from starlette.background import BackgroundTask",
            "from starlette.datastructures import UploadFile as StarletteUploadFile",
            "from starlette.responses import RedirectResponse, StreamingResponse",
            "",
            "import gradio",
            "from gradio import ranged_response, route_utils, utils, wasm_utils",
            "from gradio.context import Context",
            "from gradio.data_classes import (",
            "    CancelBody,",
            "    ComponentServerBlobBody,",
            "    ComponentServerJSONBody,",
            "    DataWithFiles,",
            "    PredictBody,",
            "    ResetBody,",
            "    SimplePredictBody,",
            ")",
            "from gradio.oauth import attach_oauth",
            "from gradio.route_utils import (  # noqa: F401",
            "    CustomCORSMiddleware,",
            "    FileUploadProgress,",
            "    FileUploadProgressNotQueuedError,",
            "    FileUploadProgressNotTrackedError,",
            "    GradioMultiPartParser,",
            "    GradioUploadFile,",
            "    MultiPartException,",
            "    Request,",
            "    compare_passwords_securely,",
            "    create_lifespan_handler,",
            "    move_uploaded_files_to_cache,",
            ")",
            "from gradio.server_messages import (",
            "    CloseStreamMessage,",
            "    EstimationMessage,",
            "    EventMessage,",
            "    HeartbeatMessage,",
            "    ProcessCompletedMessage,",
            "    ProcessGeneratingMessage,",
            "    UnexpectedErrorMessage,",
            ")",
            "from gradio.state_holder import StateHolder",
            "from gradio.utils import cancel_tasks, get_package_version, get_upload_folder",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Block",
            "",
            "",
            "mimetypes.init()",
            "",
            "STATIC_TEMPLATE_LIB = files(\"gradio\").joinpath(\"templates\").as_posix()  # type: ignore",
            "STATIC_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix()  # type: ignore",
            "BUILD_PATH_LIB = files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix()  # type: ignore",
            "VERSION = get_package_version()",
            "",
            "",
            "class ORJSONResponse(JSONResponse):",
            "    media_type = \"application/json\"",
            "",
            "    @staticmethod",
            "    def _render(content: Any) -> bytes:",
            "        return orjson.dumps(",
            "            content,",
            "            option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
            "            default=str,",
            "        )",
            "",
            "    def render(self, content: Any) -> bytes:",
            "        return ORJSONResponse._render(content)",
            "",
            "    @staticmethod",
            "    def _render_str(content: Any) -> str:",
            "        return ORJSONResponse._render(content).decode(\"utf-8\")",
            "",
            "",
            "def toorjson(value):",
            "    return markupsafe.Markup(",
            "        ORJSONResponse._render_str(value)",
            "        .replace(\"<\", \"\\\\u003c\")",
            "        .replace(\">\", \"\\\\u003e\")",
            "        .replace(\"&\", \"\\\\u0026\")",
            "        .replace(\"'\", \"\\\\u0027\")",
            "    )",
            "",
            "",
            "templates = Jinja2Templates(directory=STATIC_TEMPLATE_LIB)",
            "templates.env.filters[\"toorjson\"] = toorjson",
            "",
            "client = httpx.AsyncClient()",
            "",
            "file_upload_statuses = FileUploadProgress()",
            "",
            "",
            "class App(FastAPI):",
            "    \"\"\"",
            "    FastAPI App Wrapper",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "        **kwargs,",
            "    ):",
            "        self.tokens = {}",
            "        self.auth = None",
            "        self.analytics_key = secrets.token_urlsafe(16)",
            "        self.monitoring_enabled = False",
            "        self.blocks: gradio.Blocks | None = None",
            "        self.state_holder = StateHolder()",
            "        self.iterators: dict[str, AsyncIterator] = {}",
            "        self.iterators_to_reset: set[str] = set()",
            "        self.lock = utils.safe_get_lock()",
            "        self.stop_event = utils.safe_get_stop_event()",
            "        self.cookie_id = secrets.token_urlsafe(32)",
            "        self.queue_token = secrets.token_urlsafe(32)",
            "        self.startup_events_triggered = False",
            "        self.uploaded_file_dir = get_upload_folder()",
            "        self.change_count: int = 0",
            "        self.change_type: Literal[\"reload\", \"error\"] | None = None",
            "        self.reload_error_message: str | None = None",
            "        self._asyncio_tasks: list[asyncio.Task] = []",
            "        self.auth_dependency = auth_dependency",
            "        self.api_info = None",
            "        self.all_app_info = None",
            "        # Allow user to manually set `docs_url` and `redoc_url`",
            "        # when instantiating an App; when they're not set, disable docs and redoc.",
            "        kwargs.setdefault(\"docs_url\", None)",
            "        kwargs.setdefault(\"redoc_url\", None)",
            "        self.custom_component_hashes: dict[str, str] = {}",
            "        super().__init__(**kwargs)",
            "",
            "    def configure_app(self, blocks: gradio.Blocks) -> None:",
            "        auth = blocks.auth",
            "        if auth is not None:",
            "            if not callable(auth):",
            "                self.auth = {account[0]: account[1] for account in auth}",
            "            else:",
            "                self.auth = auth",
            "        else:",
            "            self.auth = None",
            "",
            "        self.blocks = blocks",
            "        self.cwd = os.getcwd()",
            "        self.favicon_path = blocks.favicon_path",
            "        self.tokens = {}",
            "        self.root_path = blocks.root_path",
            "        self.state_holder.set_blocks(blocks)",
            "",
            "    def get_blocks(self) -> gradio.Blocks:",
            "        if self.blocks is None:",
            "            raise ValueError(\"No Blocks has been configured for this app.\")",
            "        return self.blocks",
            "",
            "    def build_proxy_request(self, url_path):",
            "        url = httpx.URL(url_path)",
            "        assert self.blocks  # noqa: S101",
            "        # Don't proxy a URL unless it's a URL specifically loaded by the user using",
            "        # gr.load() to prevent SSRF or harvesting of HF tokens by malicious Spaces.",
            "        is_safe_url = any(",
            "            url.host == httpx.URL(root).host for root in self.blocks.proxy_urls",
            "        )",
            "        if not is_safe_url:",
            "            raise PermissionError(\"This URL cannot be proxied.\")",
            "        is_hf_url = url.host.endswith(\".hf.space\")",
            "        headers = {}",
            "        if Context.hf_token is not None and is_hf_url:",
            "            headers[\"Authorization\"] = f\"Bearer {Context.hf_token}\"",
            "        rp_req = client.build_request(\"GET\", url, headers=headers)",
            "        return rp_req",
            "",
            "    def _cancel_asyncio_tasks(self):",
            "        for task in self._asyncio_tasks:",
            "            task.cancel()",
            "        self._asyncio_tasks = []",
            "",
            "    @staticmethod",
            "    def create_app(",
            "        blocks: gradio.Blocks,",
            "        app_kwargs: Dict[str, Any] | None = None,",
            "        auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "    ) -> App:",
            "        app_kwargs = app_kwargs or {}",
            "        app_kwargs.setdefault(\"default_response_class\", ORJSONResponse)",
            "        delete_cache = blocks.delete_cache or (None, None)",
            "        app_kwargs[\"lifespan\"] = create_lifespan_handler(",
            "            app_kwargs.get(\"lifespan\", None), *delete_cache",
            "        )",
            "        app = App(auth_dependency=auth_dependency, **app_kwargs)",
            "        app.configure_app(blocks)",
            "",
            "        if not wasm_utils.IS_WASM:",
            "            app.add_middleware(CustomCORSMiddleware)",
            "",
            "        @app.get(\"/user\")",
            "        @app.get(\"/user/\")",
            "        def get_current_user(request: fastapi.Request) -> Optional[str]:",
            "            if app.auth_dependency is not None:",
            "                return app.auth_dependency(request)",
            "            token = request.cookies.get(",
            "                f\"access-token-{app.cookie_id}\"",
            "            ) or request.cookies.get(f\"access-token-unsecure-{app.cookie_id}\")",
            "            return app.tokens.get(token)",
            "",
            "        @app.get(\"/login_check\")",
            "        @app.get(\"/login_check/\")",
            "        def login_check(user: str = Depends(get_current_user)):",
            "            if (app.auth is None and app.auth_dependency is None) or user is not None:",
            "                return",
            "            raise HTTPException(",
            "                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
            "            )",
            "",
            "        @app.get(\"/token\")",
            "        @app.get(\"/token/\")",
            "        def get_token(request: fastapi.Request) -> dict:",
            "            token = request.cookies.get(f\"access-token-{app.cookie_id}\")",
            "            return {\"token\": token, \"user\": app.tokens.get(token)}",
            "",
            "        @app.get(\"/app_id\")",
            "        @app.get(\"/app_id/\")",
            "        def app_id(request: fastapi.Request) -> dict:  # noqa: ARG001",
            "            return {\"app_id\": app.get_blocks().app_id}",
            "",
            "        @app.get(\"/dev/reload\", dependencies=[Depends(login_check)])",
            "        async def notify_changes(",
            "            request: fastapi.Request,",
            "        ):",
            "            async def reload_checker(request: fastapi.Request):",
            "                heartbeat_rate = 15",
            "                check_rate = 0.05",
            "                last_heartbeat = time.perf_counter()",
            "                current_count = app.change_count",
            "",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        return",
            "",
            "                    if app.change_count != current_count:",
            "                        current_count = app.change_count",
            "                        msg = (",
            "                            json.dumps(f\"{app.reload_error_message}\")",
            "                            if app.change_type == \"error\"",
            "                            else \"{}\"",
            "                        )",
            "                        yield f\"\"\"event: {app.change_type}\\ndata: {msg}\\n\\n\"\"\"",
            "",
            "                    await asyncio.sleep(check_rate)",
            "                    if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                        yield \"\"\"event: heartbeat\\ndata: {}\\n\\n\"\"\"",
            "                        last_heartbeat = time.time()",
            "",
            "            return StreamingResponse(",
            "                reload_checker(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/login\")",
            "        @app.post(\"/login/\")",
            "        def login(form_data: OAuth2PasswordRequestForm = Depends()):",
            "            username, password = form_data.username.strip(), form_data.password",
            "            if app.auth is None:",
            "                return RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
            "            if (",
            "                not callable(app.auth)",
            "                and username in app.auth",
            "                and compare_passwords_securely(password, app.auth[username])  # type: ignore",
            "            ) or (callable(app.auth) and app.auth.__call__(username, password)):  # type: ignore",
            "                token = secrets.token_urlsafe(16)",
            "                app.tokens[token] = username",
            "                response = JSONResponse(content={\"success\": True})",
            "                response.set_cookie(",
            "                    key=f\"access-token-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                    samesite=\"none\",",
            "                    secure=True,",
            "                )",
            "                response.set_cookie(",
            "                    key=f\"access-token-unsecure-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                )",
            "                return response",
            "            else:",
            "                raise HTTPException(status_code=400, detail=\"Incorrect credentials.\")",
            "",
            "        ###############",
            "        # OAuth Routes",
            "        ###############",
            "",
            "        # Define OAuth routes if the app expects it (i.e. a LoginButton is defined).",
            "        # It allows users to \"Sign in with HuggingFace\". Otherwise, add the default",
            "        # logout route.",
            "        if app.blocks is not None and app.blocks.expects_oauth:",
            "            attach_oauth(app)",
            "        else:",
            "",
            "            @app.get(\"/logout\")",
            "            def logout(user: str = Depends(get_current_user)):",
            "                response = RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
            "                response.delete_cookie(key=f\"access-token-{app.cookie_id}\", path=\"/\")",
            "                response.delete_cookie(",
            "                    key=f\"access-token-unsecure-{app.cookie_id}\", path=\"/\"",
            "                )",
            "                # A user may have multiple tokens, so we need to delete all of them.",
            "                for token in list(app.tokens.keys()):",
            "                    if app.tokens[token] == user:",
            "                        del app.tokens[token]",
            "                return response",
            "",
            "        ###############",
            "        # Main Routes",
            "        ###############",
            "",
            "        @app.head(\"/\", response_class=HTMLResponse)",
            "        @app.get(\"/\", response_class=HTMLResponse)",
            "        def main(request: fastapi.Request, user: str = Depends(get_current_user)):",
            "            mimetypes.add_type(\"application/javascript\", \".js\")",
            "            blocks = app.get_blocks()",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/\", root_path=app.root_path",
            "            )",
            "            if (app.auth is None and app.auth_dependency is None) or user is not None:",
            "                config = blocks.config",
            "                config = route_utils.update_root_in_config(config, root)",
            "                config[\"username\"] = user",
            "            elif app.auth_dependency:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
            "                )",
            "            else:",
            "                config = {",
            "                    \"auth_required\": True,",
            "                    \"auth_message\": blocks.auth_message,",
            "                    \"space_id\": blocks.space_id,",
            "                    \"root\": root,",
            "                }",
            "",
            "            try:",
            "                template = (",
            "                    \"frontend/share.html\" if blocks.share else \"frontend/index.html\"",
            "                )",
            "                gradio_api_info = api_info(False)",
            "                return templates.TemplateResponse(",
            "                    template,",
            "                    {",
            "                        \"request\": request,",
            "                        \"config\": config,",
            "                        \"gradio_api_info\": gradio_api_info,",
            "                    },",
            "                )",
            "            except TemplateNotFound as err:",
            "                if blocks.share:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? Share mode only \"",
            "                        \"works when Gradio is installed through the pip package.\"",
            "                    ) from err",
            "                else:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? You need to build \"",
            "                        \"the frontend by running /scripts/build_frontend.sh\"",
            "                    ) from err",
            "",
            "        @app.get(\"/info/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/info\", dependencies=[Depends(login_check)])",
            "        def api_info(all_endpoints: bool = False):",
            "            if all_endpoints:",
            "                if not app.all_app_info:",
            "                    app.all_app_info = app.get_blocks().get_api_info(all_endpoints=True)",
            "                return app.all_app_info",
            "            if not app.api_info:",
            "                app.api_info = app.get_blocks().get_api_info()",
            "            return app.api_info",
            "",
            "        @app.get(\"/config/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/config\", dependencies=[Depends(login_check)])",
            "        def get_config(request: fastapi.Request):",
            "            config = app.get_blocks().config",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/config\", root_path=app.root_path",
            "            )",
            "            config = route_utils.update_root_in_config(config, root)",
            "            config[\"username\"] = get_current_user(request)",
            "            return ORJSONResponse(content=config)",
            "",
            "        @app.get(\"/static/{path:path}\")",
            "        def static_resource(path: str):",
            "            static_file = safe_join(STATIC_PATH_LIB, path)",
            "            return FileResponse(static_file)",
            "",
            "        @app.get(\"/custom_component/{id}/{type}/{file_name}\")",
            "        def custom_component_path(",
            "            id: str, type: str, file_name: str, req: fastapi.Request",
            "        ):",
            "            config = app.get_blocks().config",
            "            components = config[\"components\"]",
            "            location = next(",
            "                (item for item in components if item[\"component_class_id\"] == id), None",
            "            )",
            "",
            "            if location is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            component_instance = app.get_blocks().get_component(location[\"id\"])",
            "",
            "            module_name = component_instance.__class__.__module__",
            "            module_path = sys.modules[module_name].__file__",
            "",
            "            if module_path is None or component_instance is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            path = safe_join(",
            "                str(Path(module_path).parent),",
            "                f\"{component_instance.__class__.TEMPLATE_DIR}/{type}/{file_name}\",",
            "            )",
            "",
            "            key = f\"{id}-{type}-{file_name}\"",
            "",
            "            if key not in app.custom_component_hashes:",
            "                app.custom_component_hashes[key] = hashlib.md5(",
            "                    Path(path).read_text(encoding=\"utf-8\").encode()",
            "                ).hexdigest()",
            "",
            "            version = app.custom_component_hashes.get(key)",
            "            headers = {\"Cache-Control\": \"max-age=0, must-revalidate\"}",
            "            if version:",
            "                headers[\"ETag\"] = version",
            "",
            "            if version and req.headers.get(\"if-none-match\") == version:",
            "                return PlainTextResponse(status_code=304, headers=headers)",
            "",
            "            return FileResponse(path, headers=headers)",
            "",
            "        @app.get(\"/assets/{path:path}\")",
            "        def build_resource(path: str):",
            "            build_file = safe_join(BUILD_PATH_LIB, path)",
            "            return FileResponse(build_file)",
            "",
            "        @app.get(\"/favicon.ico\")",
            "        async def favicon():",
            "            blocks = app.get_blocks()",
            "            if blocks.favicon_path is None:",
            "                return static_resource(\"img/logo.svg\")",
            "            else:",
            "                return FileResponse(blocks.favicon_path)",
            "",
            "        @app.head(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        async def reverse_proxy(url_path: str):",
            "            # Adapted from: https://github.com/tiangolo/fastapi/issues/1788",
            "            try:",
            "                rp_req = app.build_proxy_request(url_path)",
            "            except PermissionError as err:",
            "                raise HTTPException(status_code=400, detail=str(err)) from err",
            "            rp_resp = await client.send(rp_req, stream=True)",
            "            rp_resp.headers.update({\"Content-Disposition\": \"attachment\"})",
            "            return StreamingResponse(",
            "                rp_resp.aiter_raw(),",
            "                status_code=rp_resp.status_code,",
            "                headers=rp_resp.headers,  # type: ignore",
            "                background=BackgroundTask(rp_resp.aclose),",
            "            )",
            "",
            "        @app.head(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        async def file(path_or_url: str, request: fastapi.Request):",
            "            blocks = app.get_blocks()",
            "            if client_utils.is_http_url_like(path_or_url):",
            "                return RedirectResponse(",
            "                    url=path_or_url, status_code=status.HTTP_302_FOUND",
            "                )",
            "",
            "            if route_utils.starts_with_protocol(path_or_url):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            abs_path = utils.abspath(path_or_url)",
            "",
            "            in_blocklist = any(",
            "                utils.is_in_or_equal(abs_path, blocked_path)",
            "                for blocked_path in blocks.blocked_paths",
            "            )",
            "",
            "            is_dir = abs_path.is_dir()",
            "",
            "            if in_blocklist or is_dir:",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            created_by_app = False",
            "            for temp_file_set in blocks.temp_file_sets:",
            "                if abs_path in temp_file_set:",
            "                    created_by_app = True",
            "                    break",
            "            in_allowlist = any(",
            "                utils.is_in_or_equal(abs_path, allowed_path)",
            "                for allowed_path in blocks.allowed_paths",
            "            )",
            "            is_static_file = utils.is_static_file(abs_path)",
            "            was_uploaded = utils.is_in_or_equal(abs_path, app.uploaded_file_dir)",
            "            is_cached_example = utils.is_in_or_equal(",
            "                abs_path, utils.abspath(utils.get_cache_folder())",
            "            )",
            "",
            "            if not (",
            "                created_by_app",
            "                or in_allowlist",
            "                or was_uploaded",
            "                or is_cached_example",
            "                or is_static_file",
            "            ):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            if not abs_path.exists():",
            "                raise HTTPException(404, f\"File not found: {path_or_url}.\")",
            "",
            "            range_val = request.headers.get(\"Range\", \"\").strip()",
            "            if range_val.startswith(\"bytes=\") and \"-\" in range_val:",
            "                range_val = range_val[6:]",
            "                start, end = range_val.split(\"-\")",
            "                if start.isnumeric() and end.isnumeric():",
            "                    start = int(start)",
            "                    end = int(end)",
            "                    headers = dict(request.headers)",
            "                    headers[\"Content-Disposition\"] = \"attachment\"",
            "                    response = ranged_response.RangedFileResponse(",
            "                        abs_path,",
            "                        ranged_response.OpenRange(start, end),",
            "                        headers,",
            "                        stat_result=os.stat(abs_path),",
            "                    )",
            "                    return response",
            "",
            "            return FileResponse(",
            "                abs_path,",
            "                headers={\"Accept-Ranges\": \"bytes\"},",
            "                content_disposition_type=\"attachment\",",
            "                media_type=\"application/octet-stream\",",
            "            )",
            "",
            "        @app.get(",
            "            \"/stream/{session_hash}/{run}/{component_id}\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        async def stream(",
            "            session_hash: str,",
            "            run: int,",
            "            component_id: int,",
            "            request: fastapi.Request,  # noqa: ARG001",
            "        ):",
            "            stream: list = (",
            "                app.get_blocks()",
            "                .pending_streams[session_hash]",
            "                .get(run, {})",
            "                .get(component_id, None)",
            "            )",
            "            if stream is None:",
            "                raise HTTPException(404, \"Stream not found.\")",
            "",
            "            def stream_wrapper():",
            "                check_stream_rate = 0.01",
            "                max_wait_time = 120  # maximum wait between yields - assume generator thread has crashed otherwise.",
            "                wait_time = 0",
            "                while True:",
            "                    if len(stream) == 0:",
            "                        if wait_time > max_wait_time:",
            "                            return",
            "                        wait_time += check_stream_rate",
            "                        time.sleep(check_stream_rate)",
            "                        continue",
            "                    wait_time = 0",
            "                    next_stream = stream.pop(0)",
            "                    if next_stream is None:",
            "                        return",
            "                    yield next_stream",
            "",
            "            return StreamingResponse(stream_wrapper())",
            "",
            "        @app.get(\"/file/{path:path}\", dependencies=[Depends(login_check)])",
            "        async def file_deprecated(path: str, request: fastapi.Request):",
            "            return await file(path, request)",
            "",
            "        @app.post(\"/reset/\")",
            "        @app.post(\"/reset\")",
            "        async def reset_iterator(body: ResetBody):  # noqa: ARG001",
            "            # No-op, all the cancelling/reset logic handled by /cancel",
            "            return {\"success\": True}",
            "",
            "        @app.get(\"/heartbeat/{session_hash}\")",
            "        def heartbeat(",
            "            session_hash: str,",
            "            request: fastapi.Request,",
            "            background_tasks: BackgroundTasks,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            \"\"\"Clients make a persistent connection to this endpoint to keep the session alive.",
            "            When the client disconnects, the session state is deleted.",
            "            \"\"\"",
            "            heartbeat_rate = 0.25 if os.getenv(\"GRADIO_IS_E2E_TEST\", None) else 15",
            "",
            "            async def wait():",
            "                await asyncio.sleep(heartbeat_rate)",
            "                return \"wait\"",
            "",
            "            async def stop_stream():",
            "                await app.stop_event.wait()",
            "                return \"stop\"",
            "",
            "            async def iterator():",
            "                while True:",
            "                    try:",
            "                        yield \"data: ALIVE\\n\\n\"",
            "                        # We need to close the heartbeat connections as soon as the server stops",
            "                        # otherwise the server can take forever to close",
            "                        wait_task = asyncio.create_task(wait())",
            "                        stop_stream_task = asyncio.create_task(stop_stream())",
            "                        done, _ = await asyncio.wait(",
            "                            [wait_task, stop_stream_task],",
            "                            return_when=asyncio.FIRST_COMPLETED,",
            "                        )",
            "                        done = [d.result() for d in done]",
            "                        if \"stop\" in done:",
            "                            raise asyncio.CancelledError()",
            "                    except asyncio.CancelledError:",
            "                        req = Request(request, username, session_hash=session_hash)",
            "                        root_path = route_utils.get_root_url(",
            "                            request=request,",
            "                            route_path=f\"/hearbeat/{session_hash}\",",
            "                            root_path=app.root_path,",
            "                        )",
            "                        body = PredictBody(",
            "                            session_hash=session_hash, data=[], request=request",
            "                        )",
            "                        unload_fn_indices = [",
            "                            i",
            "                            for i, dep in app.get_blocks().fns.items()",
            "                            if any(t for t in dep.targets if t[1] == \"unload\")",
            "                        ]",
            "                        for fn_index in unload_fn_indices:",
            "                            # The task runnning this loop has been cancelled",
            "                            # so we add tasks in the background",
            "                            background_tasks.add_task(",
            "                                route_utils.call_process_api,",
            "                                app=app,",
            "                                body=body,",
            "                                gr_request=req,",
            "                                fn=app.get_blocks().fns[fn_index],",
            "                                root_path=root_path,",
            "                            )",
            "                        # This will mark the state to be deleted in an hour",
            "                        if session_hash in app.state_holder.session_data:",
            "                            app.state_holder.session_data[session_hash].is_closed = True",
            "                        return",
            "",
            "            return StreamingResponse(iterator(), media_type=\"text/event-stream\")",
            "",
            "        # had to use '/run' endpoint for Colab compatibility, '/api' supported for backwards compatibility",
            "        @app.post(\"/run/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/run/{api_name}/\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}/\", dependencies=[Depends(login_check)])",
            "        async def predict(",
            "            api_name: str,",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            fn = route_utils.get_fn(",
            "                blocks=app.get_blocks(), api_name=api_name, body=body",
            "            )",
            "",
            "            if not app.get_blocks().api_open and fn.queue:",
            "                raise HTTPException(",
            "                    detail=\"This API endpoint does not accept direct HTTP POST requests. Please join the queue to use this API.\",",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                )",
            "",
            "            gr_request = route_utils.compile_gr_request(",
            "                body,",
            "                fn=fn,",
            "                username=username,",
            "                request=request,",
            "            )",
            "            root_path = route_utils.get_root_url(",
            "                request=request, route_path=f\"/api/{api_name}\", root_path=app.root_path",
            "            )",
            "            try:",
            "                output = await route_utils.call_process_api(",
            "                    app=app,",
            "                    body=body,",
            "                    gr_request=gr_request,",
            "                    fn=fn,",
            "                    root_path=root_path,",
            "                )",
            "            except BaseException as error:",
            "                content = utils.error_payload(error, app.get_blocks().show_error)",
            "                traceback.print_exc()",
            "                return JSONResponse(",
            "                    content=content,",
            "                    status_code=500,",
            "                )",
            "            return output",
            "",
            "        @app.post(\"/call/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/call/{api_name}/\", dependencies=[Depends(login_check)])",
            "        async def simple_predict_post(",
            "            api_name: str,",
            "            body: SimplePredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            full_body = PredictBody(",
            "                **body.model_dump(), request=request, simple_format=True",
            "            )",
            "            fn = route_utils.get_fn(",
            "                blocks=app.get_blocks(), api_name=api_name, body=full_body",
            "            )",
            "            full_body.fn_index = fn._id",
            "            return await queue_join_helper(full_body, request, username)",
            "",
            "        @app.post(\"/queue/join\", dependencies=[Depends(login_check)])",
            "        async def queue_join(",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            if body.session_hash is None:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_400_BAD_REQUEST,",
            "                    detail=\"Session hash not found.\",",
            "                )",
            "            return await queue_join_helper(body, request, username)",
            "",
            "        async def queue_join_helper(",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str,",
            "        ):",
            "            blocks = app.get_blocks()",
            "",
            "            if blocks._queue.server_app is None:",
            "                blocks._queue.set_server_app(app)",
            "",
            "            if blocks._queue.stopped:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_503_SERVICE_UNAVAILABLE,",
            "                    detail=\"Queue is stopped.\",",
            "                )",
            "",
            "            success, event_id = await blocks._queue.push(",
            "                body=body, request=request, username=username",
            "            )",
            "            if not success:",
            "                status_code = (",
            "                    status.HTTP_503_SERVICE_UNAVAILABLE",
            "                    if \"Queue is full.\" in event_id",
            "                    else status.HTTP_400_BAD_REQUEST",
            "                )",
            "                raise HTTPException(status_code=status_code, detail=event_id)",
            "            return {\"event_id\": event_id}",
            "",
            "        @app.post(\"/cancel\")",
            "        async def cancel_event(body: CancelBody):",
            "            await cancel_tasks({f\"{body.session_hash}_{body.fn_index}\"})",
            "            blocks = app.get_blocks()",
            "            # Need to complete the job so that the client disconnects",
            "            session_open = (",
            "                body.session_hash in blocks._queue.pending_messages_per_session",
            "            )",
            "            event_running = (",
            "                body.event_id",
            "                in blocks._queue.pending_event_ids_session.get(body.session_hash, {})",
            "            )",
            "            if session_open and event_running:",
            "                message = ProcessCompletedMessage(",
            "                    output={}, success=True, event_id=body.event_id",
            "                )",
            "                blocks._queue.pending_messages_per_session[",
            "                    body.session_hash",
            "                ].put_nowait(message)",
            "            if body.event_id in app.iterators:",
            "                async with app.lock:",
            "                    del app.iterators[body.event_id]",
            "                    app.iterators_to_reset.add(body.event_id)",
            "            return {\"success\": True}",
            "",
            "        @app.get(\"/call/{api_name}/{event_id}\", dependencies=[Depends(login_check)])",
            "        async def simple_predict_get(",
            "            request: fastapi.Request,",
            "            event_id: str,",
            "        ):",
            "            def process_msg(message: EventMessage) -> str | None:",
            "                if isinstance(message, ProcessCompletedMessage):",
            "                    event = \"complete\" if message.success else \"error\"",
            "                    data = message.output.get(\"data\")",
            "                elif isinstance(message, ProcessGeneratingMessage):",
            "                    event = \"generating\" if message.success else \"error\"",
            "                    data = message.output.get(\"data\")",
            "                elif isinstance(message, HeartbeatMessage):",
            "                    event = \"heartbeat\"",
            "                    data = None",
            "                elif isinstance(message, UnexpectedErrorMessage):",
            "                    event = \"error\"",
            "                    data = message.message",
            "                else:",
            "                    return None",
            "                return f\"event: {event}\\ndata: {json.dumps(data)}\\n\\n\"",
            "",
            "            return await queue_data_helper(request, event_id, process_msg)",
            "",
            "        @app.get(\"/queue/data\", dependencies=[Depends(login_check)])",
            "        async def queue_data(",
            "            request: fastapi.Request,",
            "            session_hash: str,",
            "        ):",
            "            def process_msg(message: EventMessage) -> str:",
            "                return f\"data: {orjson.dumps(message.model_dump(), default=str).decode('utf-8')}\\n\\n\"",
            "",
            "            return await queue_data_helper(request, session_hash, process_msg)",
            "",
            "        async def queue_data_helper(",
            "            request: fastapi.Request,",
            "            session_hash: str,",
            "            process_msg: Callable[[EventMessage], str | None],",
            "        ):",
            "            blocks = app.get_blocks()",
            "",
            "            async def sse_stream(request: fastapi.Request):",
            "                try:",
            "                    last_heartbeat = time.perf_counter()",
            "                    while True:",
            "                        if await request.is_disconnected():",
            "                            await blocks._queue.clean_events(session_hash=session_hash)",
            "                            return",
            "",
            "                        if (",
            "                            session_hash",
            "                            not in blocks._queue.pending_messages_per_session",
            "                        ):",
            "                            raise HTTPException(",
            "                                status_code=status.HTTP_404_NOT_FOUND,",
            "                                detail=\"Session not found.\",",
            "                            )",
            "",
            "                        heartbeat_rate = 15",
            "                        check_rate = 0.05",
            "                        message = None",
            "                        try:",
            "                            messages = blocks._queue.pending_messages_per_session[",
            "                                session_hash",
            "                            ]",
            "                            message = messages.get_nowait()",
            "                        except EmptyQueue:",
            "                            await asyncio.sleep(check_rate)",
            "                            if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                                # Fix this",
            "                                message = HeartbeatMessage()",
            "                                # Need to reset last_heartbeat with perf_counter",
            "                                # otherwise only a single hearbeat msg will be sent",
            "                                # and then the stream will retry leading to infinite queue \ud83d\ude2c",
            "                                last_heartbeat = time.perf_counter()",
            "",
            "                        if blocks._queue.stopped:",
            "                            message = UnexpectedErrorMessage(",
            "                                message=\"Server stopped unexpectedly.\",",
            "                                success=False,",
            "                            )",
            "                        if message:",
            "                            response = process_msg(message)",
            "                            if response is not None:",
            "                                yield response",
            "                            if (",
            "                                isinstance(message, ProcessCompletedMessage)",
            "                                and message.event_id",
            "                            ):",
            "                                blocks._queue.pending_event_ids_session[",
            "                                    session_hash",
            "                                ].remove(message.event_id)",
            "                                if message.msg == ServerMessage.server_stopped or (",
            "                                    message.msg == ServerMessage.process_completed",
            "                                    and (",
            "                                        len(",
            "                                            blocks._queue.pending_event_ids_session[",
            "                                                session_hash",
            "                                            ]",
            "                                        )",
            "                                        == 0",
            "                                    )",
            "                                ):",
            "                                    message = CloseStreamMessage()",
            "                                    response = process_msg(message)",
            "                                    if response is not None:",
            "                                        yield response",
            "                                    return",
            "                except BaseException as e:",
            "                    message = UnexpectedErrorMessage(",
            "                        message=str(e),",
            "                    )",
            "                    response = process_msg(message)",
            "                    if isinstance(e, asyncio.CancelledError):",
            "                        del blocks._queue.pending_messages_per_session[session_hash]",
            "                        await blocks._queue.clean_events(session_hash=session_hash)",
            "                    if response is not None:",
            "                        yield response",
            "                    raise e",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        async def get_item_or_file(",
            "            request: fastapi.Request,",
            "        ) -> Union[ComponentServerJSONBody, ComponentServerBlobBody]:",
            "            content_type = request.headers.get(\"Content-Type\")",
            "",
            "            if isinstance(content_type, str) and content_type.startswith(",
            "                \"multipart/form-data\"",
            "            ):",
            "                files = []",
            "                data = {}",
            "                async with request.form() as form:",
            "                    for key, value in form.items():",
            "                        if (",
            "                            isinstance(value, list)",
            "                            and len(value) > 1",
            "                            and isinstance(value[0], StarletteUploadFile)",
            "                        ):",
            "                            for i, v in enumerate(value):",
            "                                if isinstance(v, StarletteUploadFile):",
            "                                    filename = v.filename",
            "                                    contents = await v.read()",
            "                                    files.append((filename, contents))",
            "                                else:",
            "                                    data[f\"{key}-{i}\"] = v",
            "                        elif isinstance(value, StarletteUploadFile):",
            "                            filename = value.filename",
            "                            contents = await value.read()",
            "                            files.append((filename, contents))",
            "                        else:",
            "                            data[key] = value",
            "",
            "                return ComponentServerBlobBody(",
            "                    data=DataWithFiles(data=data, files=files),",
            "                    component_id=data[\"component_id\"],",
            "                    session_hash=data[\"session_hash\"],",
            "                    fn_name=data[\"fn_name\"],",
            "                )",
            "            else:",
            "                try:",
            "                    data = await request.json()",
            "                    return ComponentServerJSONBody(",
            "                        data=data[\"data\"],",
            "                        component_id=data[\"component_id\"],",
            "                        session_hash=data[\"session_hash\"],",
            "                        fn_name=data[\"fn_name\"],",
            "                    )",
            "",
            "                except Exception:",
            "                    raise HTTPException(",
            "                        status_code=status.HTTP_400_BAD_REQUEST,",
            "                        detail=\"Invalid JSON body.\",",
            "                    ) from None",
            "",
            "        @app.post(",
            "            \"/component_server\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        @app.post(",
            "            \"/component_server/\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        async def component_server(",
            "            request: fastapi.Request,",
            "        ):",
            "            body = await get_item_or_file(request)",
            "            state = app.state_holder[body.session_hash]",
            "            component_id = body.component_id",
            "            block: Block",
            "            if component_id in state:",
            "                block = state[component_id]",
            "            else:",
            "                block = app.get_blocks().blocks[component_id]",
            "            fn = getattr(block, body.fn_name, None)",
            "            if fn is None or not getattr(fn, \"_is_server_fn\", False):",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                    detail=\"Function not found.\",",
            "                )",
            "            return fn(body.data)",
            "",
            "        @app.get(",
            "            \"/queue/status\",",
            "            dependencies=[Depends(login_check)],",
            "            response_model=EstimationMessage,",
            "        )",
            "        async def get_queue_status():",
            "            return app.get_blocks()._queue.get_status()",
            "",
            "        @app.get(\"/upload_progress\")",
            "        def get_upload_progress(upload_id: str, request: fastapi.Request):",
            "            async def sse_stream(request: fastapi.Request):",
            "                last_heartbeat = time.perf_counter()",
            "                is_done = False",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "                    if is_done:",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "",
            "                    heartbeat_rate = 15",
            "                    check_rate = 0.05",
            "                    try:",
            "                        if file_upload_statuses.is_done(upload_id):",
            "                            message = {\"msg\": \"done\"}",
            "                            is_done = True",
            "                        else:",
            "                            update = file_upload_statuses.pop(upload_id)",
            "                            message = {",
            "                                \"msg\": \"update\",",
            "                                \"orig_name\": update.filename,",
            "                                \"chunk_size\": update.chunk_size,",
            "                            }",
            "                        yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                    except FileUploadProgressNotTrackedError:",
            "                        return",
            "                    except FileUploadProgressNotQueuedError:",
            "                        await asyncio.sleep(check_rate)",
            "                        if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                            message = {\"msg\": \"heartbeat\"}",
            "                            yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                            last_heartbeat = time.perf_counter()",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/upload\", dependencies=[Depends(login_check)])",
            "        async def upload_file(",
            "            request: fastapi.Request,",
            "            bg_tasks: BackgroundTasks,",
            "            upload_id: Optional[str] = None,",
            "        ):",
            "            content_type_header = request.headers.get(\"Content-Type\")",
            "            content_type: bytes",
            "            content_type, _ = parse_options_header(content_type_header or \"\")",
            "            if content_type != b\"multipart/form-data\":",
            "                raise HTTPException(status_code=400, detail=\"Invalid content type.\")",
            "",
            "            try:",
            "                if upload_id:",
            "                    file_upload_statuses.track(upload_id)",
            "                max_file_size = app.get_blocks().max_file_size",
            "                max_file_size = max_file_size if max_file_size is not None else math.inf",
            "                multipart_parser = GradioMultiPartParser(",
            "                    request.headers,",
            "                    request.stream(),",
            "                    max_files=1000,",
            "                    max_fields=1000,",
            "                    max_file_size=max_file_size,",
            "                    upload_id=upload_id if upload_id else None,",
            "                    upload_progress=file_upload_statuses if upload_id else None,",
            "                )",
            "                form = await multipart_parser.parse()",
            "            except MultiPartException as exc:",
            "                code = 413 if \"maximum allowed size\" in exc.message else 400",
            "                return PlainTextResponse(exc.message, status_code=code)",
            "",
            "            output_files = []",
            "            files_to_copy = []",
            "            locations: list[str] = []",
            "",
            "            for temp_file in form.getlist(\"files\"):",
            "                if not isinstance(temp_file, GradioUploadFile):",
            "                    raise TypeError(\"File is not an instance of GradioUploadFile\")",
            "                if temp_file.filename:",
            "                    file_name = Path(temp_file.filename).name",
            "                    name = client_utils.strip_invalid_filename_characters(file_name)",
            "                else:",
            "                    name = f\"tmp{secrets.token_hex(5)}\"",
            "                directory = Path(app.uploaded_file_dir) / temp_file.sha.hexdigest()",
            "                directory.mkdir(exist_ok=True, parents=True)",
            "                dest = (directory / name).resolve()",
            "                temp_file.file.close()",
            "                # we need to move the temp file to the cache directory",
            "                # but that's possibly blocking and we're in an async function",
            "                # so we try to rename (this is what shutil.move tries first)",
            "                # which should be super fast.",
            "                # if that fails, we move in the background.",
            "                try:",
            "                    os.rename(temp_file.file.name, dest)",
            "                except OSError:",
            "                    files_to_copy.append(temp_file.file.name)",
            "                    locations.append(str(dest))",
            "                output_files.append(dest)",
            "                blocks.upload_file_set.add(str(dest))",
            "            if files_to_copy:",
            "                bg_tasks.add_task(",
            "                    move_uploaded_files_to_cache, files_to_copy, locations",
            "                )",
            "            return output_files",
            "",
            "        @app.on_event(\"startup\")",
            "        @app.get(\"/startup-events\")",
            "        async def startup_events():",
            "            if not app.startup_events_triggered:",
            "                app.get_blocks().startup_events()",
            "                app.startup_events_triggered = True",
            "                return True",
            "            return False",
            "",
            "        @app.get(\"/theme.css\", response_class=PlainTextResponse)",
            "        def theme_css():",
            "            return PlainTextResponse(app.get_blocks().theme_css, media_type=\"text/css\")",
            "",
            "        @app.get(\"/robots.txt\", response_class=PlainTextResponse)",
            "        def robots_txt():",
            "            if app.get_blocks().share:",
            "                return \"User-agent: *\\nDisallow: /\"",
            "            else:",
            "                return \"User-agent: *\\nDisallow: \"",
            "",
            "        @app.get(\"/monitoring\", dependencies=[Depends(login_check)])",
            "        async def analytics_login(request: fastapi.Request):",
            "            root_url = route_utils.get_root_url(",
            "                request=request, route_path=\"/monitoring\", root_path=app.root_path",
            "            )",
            "            monitoring_url = f\"{root_url}/monitoring/{app.analytics_key}\"",
            "            print(f\"* Monitoring URL: {monitoring_url} *\")",
            "            return HTMLResponse(\"See console for monitoring URL.\")",
            "",
            "        @app.get(\"/monitoring/{key}\")",
            "        async def analytics_dashboard(key: str):",
            "            if compare_passwords_securely(key, app.analytics_key):",
            "                analytics_url = f\"/monitoring/{app.analytics_key}/dashboard\"",
            "                if not app.monitoring_enabled:",
            "                    from gradio.monitoring_dashboard import data",
            "                    from gradio.monitoring_dashboard import demo as dashboard",
            "",
            "                    mount_gradio_app(app, dashboard, path=analytics_url)",
            "                    dashboard._queue.start()",
            "                    analytics = app.get_blocks()._queue.event_analytics",
            "                    data[\"data\"] = analytics",
            "                    app.monitoring_enabled = True",
            "                return RedirectResponse(",
            "                    url=analytics_url, status_code=status.HTTP_302_FOUND",
            "                )",
            "            else:",
            "                raise HTTPException(status_code=403, detail=\"Invalid key.\")",
            "",
            "        return app",
            "",
            "",
            "########",
            "# Helper functions",
            "########",
            "",
            "",
            "def safe_join(directory: str, path: str) -> str:",
            "    \"\"\"Safely path to a base directory to avoid escaping the base directory.",
            "    Borrowed from: werkzeug.security.safe_join\"\"\"",
            "    _os_alt_seps: List[str] = [",
            "        sep for sep in [os.path.sep, os.path.altsep] if sep is not None and sep != \"/\"",
            "    ]",
            "",
            "    if path == \"\":",
            "        raise HTTPException(400)",
            "    if route_utils.starts_with_protocol(path):",
            "        raise HTTPException(403)",
            "    filename = posixpath.normpath(path)",
            "    fullpath = os.path.join(directory, filename)",
            "    if (",
            "        any(sep in filename for sep in _os_alt_seps)",
            "        or os.path.isabs(filename)",
            "        or filename == \"..\"",
            "        or filename.startswith(\"../\")",
            "        or os.path.isdir(fullpath)",
            "    ):",
            "        raise HTTPException(403)",
            "",
            "    if not os.path.exists(fullpath):",
            "        raise HTTPException(404, \"File not found\")",
            "",
            "    return fullpath",
            "",
            "",
            "def get_types(cls_set: List[Type]):",
            "    docset = []",
            "    types = []",
            "    for cls in cls_set:",
            "        doc = inspect.getdoc(cls) or \"\"",
            "        doc_lines = doc.split(\"\\n\")",
            "        for line in doc_lines:",
            "            if \"value (\" in line:",
            "                types.append(line.split(\"value (\")[1].split(\")\")[0])",
            "        docset.append(doc_lines[1].split(\":\")[-1])",
            "    return docset, types",
            "",
            "",
            "@document()",
            "def mount_gradio_app(",
            "    app: fastapi.FastAPI,",
            "    blocks: gradio.Blocks,",
            "    path: str,",
            "    app_kwargs: dict[str, Any] | None = None,",
            "    *,",
            "    auth: Callable | tuple[str, str] | list[tuple[str, str]] | None = None,",
            "    auth_message: str | None = None,",
            "    auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "    root_path: str | None = None,",
            "    allowed_paths: list[str] | None = None,",
            "    blocked_paths: list[str] | None = None,",
            "    favicon_path: str | None = None,",
            "    show_error: bool = True,",
            "    max_file_size: str | int | None = None,",
            ") -> fastapi.FastAPI:",
            "    \"\"\"Mount a gradio.Blocks to an existing FastAPI application.",
            "",
            "    Parameters:",
            "        app: The parent FastAPI application.",
            "        blocks: The blocks object we want to mount to the parent app.",
            "        path: The path at which the gradio application will be mounted.",
            "        app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{\"docs_url\": \"/docs\"}`",
            "        auth: If provided, username and password (or list of username-password tuples) required to access the gradio app. Can also provide function that takes username and password and returns True if valid login.",
            "        auth_message: If provided, HTML message provided on login page for this gradio app.",
            "        auth_dependency: A function that takes a FastAPI request and returns a string user ID or None. If the function returns None for a specific request, that user is not authorized to access the gradio app (they will see a 401 Unauthorized response). To be used with external authentication systems like OAuth. Cannot be used with `auth`.",
            "        root_path: The subpath corresponding to the public deployment of this FastAPI application. For example, if the application is served at \"https://example.com/myapp\", the `root_path` should be set to \"/myapp\". A full URL beginning with http:// or https:// can be provided, which will be used in its entirety. Normally, this does not need to provided (even if you are using a custom `path`). However, if you are serving the FastAPI app behind a proxy, the proxy may not provide the full path to the Gradio app in the request headers. In which case, you can provide the root path here.",
            "        allowed_paths: List of complete filepaths or parent directories that this gradio app is allowed to serve. Must be absolute paths. Warning: if you provide directories, any files in these directories or their subdirectories are accessible to all users of your app.",
            "        blocked_paths: List of complete filepaths or parent directories that this gradio app is not allowed to serve (i.e. users of your app are not allowed to access). Must be absolute paths. Warning: takes precedence over `allowed_paths` and all other directories exposed by Gradio by default.",
            "        favicon_path: If a path to a file (.png, .gif, or .ico) is provided, it will be used as the favicon for this gradio app's page.",
            "        show_error: If True, any errors in the gradio app will be displayed in an alert modal and printed in the browser console log. Otherwise, errors will only be visible in the terminal session running the Gradio app.",
            "        max_file_size: The maximum file size in bytes that can be uploaded. Can be a string of the form \"<value><unit>\", where value is any positive integer and unit is one of \"b\", \"kb\", \"mb\", \"gb\", \"tb\". If None, no limit is set.",
            "    Example:",
            "        from fastapi import FastAPI",
            "        import gradio as gr",
            "        app = FastAPI()",
            "        @app.get(\"/\")",
            "        def read_main():",
            "            return {\"message\": \"This is your main app\"}",
            "        io = gr.Interface(lambda x: \"Hello, \" + x + \"!\", \"textbox\", \"textbox\")",
            "        app = gr.mount_gradio_app(app, io, path=\"/gradio\")",
            "        # Then run `uvicorn run:app` from the terminal and navigate to http://localhost:8000/gradio.",
            "    \"\"\"",
            "    if favicon_path is not None and path != \"/\":",
            "        warnings.warn(",
            "            \"The 'favicon_path' parameter is set but will be ignored because 'path' is not '/'. \"",
            "            \"Please add the favicon directly to your FastAPI app.\"",
            "        )",
            "",
            "    blocks.dev_mode = False",
            "    blocks.max_file_size = utils._parse_file_size(max_file_size)",
            "    blocks.config = blocks.get_config_file()",
            "    blocks.validate_queue_settings()",
            "    if auth is not None and auth_dependency is not None:",
            "        raise ValueError(",
            "            \"You cannot provide both `auth` and `auth_dependency` in mount_gradio_app(). Please choose one.\"",
            "        )",
            "    if (",
            "        auth",
            "        and not callable(auth)",
            "        and not isinstance(auth[0], tuple)",
            "        and not isinstance(auth[0], list)",
            "    ):",
            "        blocks.auth = [auth]",
            "    else:",
            "        blocks.auth = auth",
            "    blocks.auth_message = auth_message",
            "    blocks.favicon_path = favicon_path",
            "    blocks.allowed_paths = allowed_paths or []",
            "    blocks.blocked_paths = blocked_paths or []",
            "    blocks.show_error = show_error",
            "",
            "    if not isinstance(blocks.allowed_paths, list):",
            "        raise ValueError(\"`allowed_paths` must be a list of directories.\")",
            "    if not isinstance(blocks.blocked_paths, list):",
            "        raise ValueError(\"`blocked_paths` must be a list of directories.\")",
            "",
            "    if root_path is not None:",
            "        blocks.root_path = root_path",
            "",
            "    gradio_app = App.create_app(",
            "        blocks, app_kwargs=app_kwargs, auth_dependency=auth_dependency",
            "    )",
            "    old_lifespan = app.router.lifespan_context",
            "",
            "    @contextlib.asynccontextmanager",
            "    async def new_lifespan(app: FastAPI):",
            "        async with old_lifespan(",
            "            app",
            "        ):  # Instert the startup events inside the FastAPI context manager",
            "            async with gradio_app.router.lifespan_context(gradio_app):",
            "                gradio_app.get_blocks().startup_events()",
            "                yield",
            "",
            "    app.router.lifespan_context = new_lifespan",
            "",
            "    app.mount(path, gradio_app)",
            "    return app"
        ],
        "afterPatchFile": [
            "\"\"\"Implements a FastAPI server to run the gradio interface. Note that some types in this",
            "module use the Optional/Union notation so that they work correctly with pydantic.\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import asyncio",
            "import contextlib",
            "import math",
            "import sys",
            "import warnings",
            "",
            "if sys.version_info >= (3, 9):",
            "    from importlib.resources import files",
            "else:",
            "    from importlib_resources import files",
            "import hashlib",
            "import inspect",
            "import json",
            "import mimetypes",
            "import os",
            "import secrets",
            "import time",
            "import traceback",
            "from pathlib import Path",
            "from queue import Empty as EmptyQueue",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    AsyncIterator,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Literal,",
            "    Optional,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "import fastapi",
            "import httpx",
            "import markupsafe",
            "import orjson",
            "from fastapi import (",
            "    BackgroundTasks,",
            "    Depends,",
            "    FastAPI,",
            "    HTTPException,",
            "    status,",
            ")",
            "from fastapi.responses import (",
            "    FileResponse,",
            "    HTMLResponse,",
            "    JSONResponse,",
            "    PlainTextResponse,",
            ")",
            "from fastapi.security import OAuth2PasswordRequestForm",
            "from fastapi.templating import Jinja2Templates",
            "from gradio_client import utils as client_utils",
            "from gradio_client.documentation import document",
            "from gradio_client.utils import ServerMessage",
            "from jinja2.exceptions import TemplateNotFound",
            "from multipart.multipart import parse_options_header",
            "from starlette.background import BackgroundTask",
            "from starlette.datastructures import UploadFile as StarletteUploadFile",
            "from starlette.responses import RedirectResponse, StreamingResponse",
            "",
            "import gradio",
            "from gradio import ranged_response, route_utils, utils, wasm_utils",
            "from gradio.context import Context",
            "from gradio.data_classes import (",
            "    CancelBody,",
            "    ComponentServerBlobBody,",
            "    ComponentServerJSONBody,",
            "    DataWithFiles,",
            "    DeveloperPath,",
            "    PredictBody,",
            "    ResetBody,",
            "    SimplePredictBody,",
            "    UserProvidedPath,",
            ")",
            "from gradio.exceptions import InvalidPathError",
            "from gradio.oauth import attach_oauth",
            "from gradio.route_utils import (  # noqa: F401",
            "    CustomCORSMiddleware,",
            "    FileUploadProgress,",
            "    FileUploadProgressNotQueuedError,",
            "    FileUploadProgressNotTrackedError,",
            "    GradioMultiPartParser,",
            "    GradioUploadFile,",
            "    MultiPartException,",
            "    Request,",
            "    compare_passwords_securely,",
            "    create_lifespan_handler,",
            "    move_uploaded_files_to_cache,",
            ")",
            "from gradio.server_messages import (",
            "    CloseStreamMessage,",
            "    EstimationMessage,",
            "    EventMessage,",
            "    HeartbeatMessage,",
            "    ProcessCompletedMessage,",
            "    ProcessGeneratingMessage,",
            "    UnexpectedErrorMessage,",
            ")",
            "from gradio.state_holder import StateHolder",
            "from gradio.utils import cancel_tasks, get_package_version, get_upload_folder",
            "",
            "if TYPE_CHECKING:",
            "    from gradio.blocks import Block",
            "",
            "",
            "mimetypes.init()",
            "",
            "STATIC_TEMPLATE_LIB = cast(",
            "    DeveloperPath,",
            "    files(\"gradio\").joinpath(\"templates\").as_posix(),  # type: ignore",
            ")",
            "STATIC_PATH_LIB = cast(",
            "    DeveloperPath,",
            "    files(\"gradio\").joinpath(\"templates\", \"frontend\", \"static\").as_posix(),  # type: ignore",
            ")",
            "BUILD_PATH_LIB = cast(",
            "    DeveloperPath,",
            "    files(\"gradio\").joinpath(\"templates\", \"frontend\", \"assets\").as_posix(),  # type: ignore",
            ")",
            "VERSION = get_package_version()",
            "",
            "",
            "class ORJSONResponse(JSONResponse):",
            "    media_type = \"application/json\"",
            "",
            "    @staticmethod",
            "    def _render(content: Any) -> bytes:",
            "        return orjson.dumps(",
            "            content,",
            "            option=orjson.OPT_SERIALIZE_NUMPY | orjson.OPT_PASSTHROUGH_DATETIME,",
            "            default=str,",
            "        )",
            "",
            "    def render(self, content: Any) -> bytes:",
            "        return ORJSONResponse._render(content)",
            "",
            "    @staticmethod",
            "    def _render_str(content: Any) -> str:",
            "        return ORJSONResponse._render(content).decode(\"utf-8\")",
            "",
            "",
            "def toorjson(value):",
            "    return markupsafe.Markup(",
            "        ORJSONResponse._render_str(value)",
            "        .replace(\"<\", \"\\\\u003c\")",
            "        .replace(\">\", \"\\\\u003e\")",
            "        .replace(\"&\", \"\\\\u0026\")",
            "        .replace(\"'\", \"\\\\u0027\")",
            "    )",
            "",
            "",
            "templates = Jinja2Templates(directory=STATIC_TEMPLATE_LIB)",
            "templates.env.filters[\"toorjson\"] = toorjson",
            "",
            "client = httpx.AsyncClient()",
            "",
            "file_upload_statuses = FileUploadProgress()",
            "",
            "",
            "class App(FastAPI):",
            "    \"\"\"",
            "    FastAPI App Wrapper",
            "    \"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "        **kwargs,",
            "    ):",
            "        self.tokens = {}",
            "        self.auth = None",
            "        self.analytics_key = secrets.token_urlsafe(16)",
            "        self.monitoring_enabled = False",
            "        self.blocks: gradio.Blocks | None = None",
            "        self.state_holder = StateHolder()",
            "        self.iterators: dict[str, AsyncIterator] = {}",
            "        self.iterators_to_reset: set[str] = set()",
            "        self.lock = utils.safe_get_lock()",
            "        self.stop_event = utils.safe_get_stop_event()",
            "        self.cookie_id = secrets.token_urlsafe(32)",
            "        self.queue_token = secrets.token_urlsafe(32)",
            "        self.startup_events_triggered = False",
            "        self.uploaded_file_dir = get_upload_folder()",
            "        self.change_count: int = 0",
            "        self.change_type: Literal[\"reload\", \"error\"] | None = None",
            "        self.reload_error_message: str | None = None",
            "        self._asyncio_tasks: list[asyncio.Task] = []",
            "        self.auth_dependency = auth_dependency",
            "        self.api_info = None",
            "        self.all_app_info = None",
            "        # Allow user to manually set `docs_url` and `redoc_url`",
            "        # when instantiating an App; when they're not set, disable docs and redoc.",
            "        kwargs.setdefault(\"docs_url\", None)",
            "        kwargs.setdefault(\"redoc_url\", None)",
            "        self.custom_component_hashes: dict[str, str] = {}",
            "        super().__init__(**kwargs)",
            "",
            "    def configure_app(self, blocks: gradio.Blocks) -> None:",
            "        auth = blocks.auth",
            "        if auth is not None:",
            "            if not callable(auth):",
            "                self.auth = {account[0]: account[1] for account in auth}",
            "            else:",
            "                self.auth = auth",
            "        else:",
            "            self.auth = None",
            "",
            "        self.blocks = blocks",
            "        self.cwd = os.getcwd()",
            "        self.favicon_path = blocks.favicon_path",
            "        self.tokens = {}",
            "        self.root_path = blocks.root_path",
            "        self.state_holder.set_blocks(blocks)",
            "",
            "    def get_blocks(self) -> gradio.Blocks:",
            "        if self.blocks is None:",
            "            raise ValueError(\"No Blocks has been configured for this app.\")",
            "        return self.blocks",
            "",
            "    def build_proxy_request(self, url_path):",
            "        url = httpx.URL(url_path)",
            "        assert self.blocks  # noqa: S101",
            "        # Don't proxy a URL unless it's a URL specifically loaded by the user using",
            "        # gr.load() to prevent SSRF or harvesting of HF tokens by malicious Spaces.",
            "        is_safe_url = any(",
            "            url.host == httpx.URL(root).host for root in self.blocks.proxy_urls",
            "        )",
            "        if not is_safe_url:",
            "            raise PermissionError(\"This URL cannot be proxied.\")",
            "        is_hf_url = url.host.endswith(\".hf.space\")",
            "        headers = {}",
            "        if Context.hf_token is not None and is_hf_url:",
            "            headers[\"Authorization\"] = f\"Bearer {Context.hf_token}\"",
            "        rp_req = client.build_request(\"GET\", url, headers=headers)",
            "        return rp_req",
            "",
            "    def _cancel_asyncio_tasks(self):",
            "        for task in self._asyncio_tasks:",
            "            task.cancel()",
            "        self._asyncio_tasks = []",
            "",
            "    @staticmethod",
            "    def create_app(",
            "        blocks: gradio.Blocks,",
            "        app_kwargs: Dict[str, Any] | None = None,",
            "        auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "    ) -> App:",
            "        app_kwargs = app_kwargs or {}",
            "        app_kwargs.setdefault(\"default_response_class\", ORJSONResponse)",
            "        delete_cache = blocks.delete_cache or (None, None)",
            "        app_kwargs[\"lifespan\"] = create_lifespan_handler(",
            "            app_kwargs.get(\"lifespan\", None), *delete_cache",
            "        )",
            "        app = App(auth_dependency=auth_dependency, **app_kwargs)",
            "        app.configure_app(blocks)",
            "",
            "        if not wasm_utils.IS_WASM:",
            "            app.add_middleware(CustomCORSMiddleware)",
            "",
            "        @app.get(\"/user\")",
            "        @app.get(\"/user/\")",
            "        def get_current_user(request: fastapi.Request) -> Optional[str]:",
            "            if app.auth_dependency is not None:",
            "                return app.auth_dependency(request)",
            "            token = request.cookies.get(",
            "                f\"access-token-{app.cookie_id}\"",
            "            ) or request.cookies.get(f\"access-token-unsecure-{app.cookie_id}\")",
            "            return app.tokens.get(token)",
            "",
            "        @app.get(\"/login_check\")",
            "        @app.get(\"/login_check/\")",
            "        def login_check(user: str = Depends(get_current_user)):",
            "            if (app.auth is None and app.auth_dependency is None) or user is not None:",
            "                return",
            "            raise HTTPException(",
            "                status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
            "            )",
            "",
            "        @app.get(\"/token\")",
            "        @app.get(\"/token/\")",
            "        def get_token(request: fastapi.Request) -> dict:",
            "            token = request.cookies.get(f\"access-token-{app.cookie_id}\")",
            "            return {\"token\": token, \"user\": app.tokens.get(token)}",
            "",
            "        @app.get(\"/app_id\")",
            "        @app.get(\"/app_id/\")",
            "        def app_id(request: fastapi.Request) -> dict:  # noqa: ARG001",
            "            return {\"app_id\": app.get_blocks().app_id}",
            "",
            "        @app.get(\"/dev/reload\", dependencies=[Depends(login_check)])",
            "        async def notify_changes(",
            "            request: fastapi.Request,",
            "        ):",
            "            async def reload_checker(request: fastapi.Request):",
            "                heartbeat_rate = 15",
            "                check_rate = 0.05",
            "                last_heartbeat = time.perf_counter()",
            "                current_count = app.change_count",
            "",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        return",
            "",
            "                    if app.change_count != current_count:",
            "                        current_count = app.change_count",
            "                        msg = (",
            "                            json.dumps(f\"{app.reload_error_message}\")",
            "                            if app.change_type == \"error\"",
            "                            else \"{}\"",
            "                        )",
            "                        yield f\"\"\"event: {app.change_type}\\ndata: {msg}\\n\\n\"\"\"",
            "",
            "                    await asyncio.sleep(check_rate)",
            "                    if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                        yield \"\"\"event: heartbeat\\ndata: {}\\n\\n\"\"\"",
            "                        last_heartbeat = time.time()",
            "",
            "            return StreamingResponse(",
            "                reload_checker(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/login\")",
            "        @app.post(\"/login/\")",
            "        def login(form_data: OAuth2PasswordRequestForm = Depends()):",
            "            username, password = form_data.username.strip(), form_data.password",
            "            if app.auth is None:",
            "                return RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
            "            if (",
            "                not callable(app.auth)",
            "                and username in app.auth",
            "                and compare_passwords_securely(password, app.auth[username])  # type: ignore",
            "            ) or (callable(app.auth) and app.auth.__call__(username, password)):  # type: ignore",
            "                token = secrets.token_urlsafe(16)",
            "                app.tokens[token] = username",
            "                response = JSONResponse(content={\"success\": True})",
            "                response.set_cookie(",
            "                    key=f\"access-token-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                    samesite=\"none\",",
            "                    secure=True,",
            "                )",
            "                response.set_cookie(",
            "                    key=f\"access-token-unsecure-{app.cookie_id}\",",
            "                    value=token,",
            "                    httponly=True,",
            "                )",
            "                return response",
            "            else:",
            "                raise HTTPException(status_code=400, detail=\"Incorrect credentials.\")",
            "",
            "        ###############",
            "        # OAuth Routes",
            "        ###############",
            "",
            "        # Define OAuth routes if the app expects it (i.e. a LoginButton is defined).",
            "        # It allows users to \"Sign in with HuggingFace\". Otherwise, add the default",
            "        # logout route.",
            "        if app.blocks is not None and app.blocks.expects_oauth:",
            "            attach_oauth(app)",
            "        else:",
            "",
            "            @app.get(\"/logout\")",
            "            def logout(user: str = Depends(get_current_user)):",
            "                response = RedirectResponse(url=\"/\", status_code=status.HTTP_302_FOUND)",
            "                response.delete_cookie(key=f\"access-token-{app.cookie_id}\", path=\"/\")",
            "                response.delete_cookie(",
            "                    key=f\"access-token-unsecure-{app.cookie_id}\", path=\"/\"",
            "                )",
            "                # A user may have multiple tokens, so we need to delete all of them.",
            "                for token in list(app.tokens.keys()):",
            "                    if app.tokens[token] == user:",
            "                        del app.tokens[token]",
            "                return response",
            "",
            "        ###############",
            "        # Main Routes",
            "        ###############",
            "",
            "        @app.head(\"/\", response_class=HTMLResponse)",
            "        @app.get(\"/\", response_class=HTMLResponse)",
            "        def main(request: fastapi.Request, user: str = Depends(get_current_user)):",
            "            mimetypes.add_type(\"application/javascript\", \".js\")",
            "            blocks = app.get_blocks()",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/\", root_path=app.root_path",
            "            )",
            "            if (app.auth is None and app.auth_dependency is None) or user is not None:",
            "                config = blocks.config",
            "                config = route_utils.update_root_in_config(config, root)",
            "                config[\"username\"] = user",
            "            elif app.auth_dependency:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated\"",
            "                )",
            "            else:",
            "                config = {",
            "                    \"auth_required\": True,",
            "                    \"auth_message\": blocks.auth_message,",
            "                    \"space_id\": blocks.space_id,",
            "                    \"root\": root,",
            "                }",
            "",
            "            try:",
            "                template = (",
            "                    \"frontend/share.html\" if blocks.share else \"frontend/index.html\"",
            "                )",
            "                gradio_api_info = api_info(False)",
            "                return templates.TemplateResponse(",
            "                    template,",
            "                    {",
            "                        \"request\": request,",
            "                        \"config\": config,",
            "                        \"gradio_api_info\": gradio_api_info,",
            "                    },",
            "                )",
            "            except TemplateNotFound as err:",
            "                if blocks.share:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? Share mode only \"",
            "                        \"works when Gradio is installed through the pip package.\"",
            "                    ) from err",
            "                else:",
            "                    raise ValueError(",
            "                        \"Did you install Gradio from source files? You need to build \"",
            "                        \"the frontend by running /scripts/build_frontend.sh\"",
            "                    ) from err",
            "",
            "        @app.get(\"/info/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/info\", dependencies=[Depends(login_check)])",
            "        def api_info(all_endpoints: bool = False):",
            "            if all_endpoints:",
            "                if not app.all_app_info:",
            "                    app.all_app_info = app.get_blocks().get_api_info(all_endpoints=True)",
            "                return app.all_app_info",
            "            if not app.api_info:",
            "                app.api_info = app.get_blocks().get_api_info()",
            "            return app.api_info",
            "",
            "        @app.get(\"/config/\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/config\", dependencies=[Depends(login_check)])",
            "        def get_config(request: fastapi.Request):",
            "            config = app.get_blocks().config",
            "            root = route_utils.get_root_url(",
            "                request=request, route_path=\"/config\", root_path=app.root_path",
            "            )",
            "            config = route_utils.update_root_in_config(config, root)",
            "            config[\"username\"] = get_current_user(request)",
            "            return ORJSONResponse(content=config)",
            "",
            "        @app.get(\"/static/{path:path}\")",
            "        def static_resource(path: str):",
            "            static_file = routes_safe_join(STATIC_PATH_LIB, UserProvidedPath(path))",
            "            return FileResponse(static_file)",
            "",
            "        @app.get(\"/custom_component/{id}/{type}/{file_name}\")",
            "        def custom_component_path(",
            "            id: str, type: str, file_name: str, req: fastapi.Request",
            "        ):",
            "            config = app.get_blocks().config",
            "            components = config[\"components\"]",
            "            location = next(",
            "                (item for item in components if item[\"component_class_id\"] == id), None",
            "            )",
            "            if location is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            component_instance = app.get_blocks().get_component(location[\"id\"])",
            "",
            "            module_name = component_instance.__class__.__module__",
            "            module_path = sys.modules[module_name].__file__",
            "",
            "            if module_path is None or component_instance is None:",
            "                raise HTTPException(status_code=404, detail=\"Component not found.\")",
            "",
            "            requested_path = utils.safe_join(",
            "                component_instance.__class__.TEMPLATE_DIR,",
            "                UserProvidedPath(f\"{type}/{file_name}\"),",
            "            )",
            "",
            "            path = routes_safe_join(",
            "                DeveloperPath(str(Path(module_path).parent)),",
            "                UserProvidedPath(requested_path),",
            "            )",
            "",
            "            key = f\"{id}-{type}-{file_name}\"",
            "",
            "            if key not in app.custom_component_hashes:",
            "                app.custom_component_hashes[key] = hashlib.md5(",
            "                    Path(path).read_text(encoding=\"utf-8\").encode()",
            "                ).hexdigest()",
            "",
            "            version = app.custom_component_hashes.get(key)",
            "            headers = {\"Cache-Control\": \"max-age=0, must-revalidate\"}",
            "            if version:",
            "                headers[\"ETag\"] = version",
            "",
            "            if version and req.headers.get(\"if-none-match\") == version:",
            "                return PlainTextResponse(status_code=304, headers=headers)",
            "",
            "            return FileResponse(path, headers=headers)",
            "",
            "        @app.get(\"/assets/{path:path}\")",
            "        def build_resource(path: str):",
            "            build_file = routes_safe_join(BUILD_PATH_LIB, UserProvidedPath(path))",
            "            return FileResponse(build_file)",
            "",
            "        @app.get(\"/favicon.ico\")",
            "        async def favicon():",
            "            blocks = app.get_blocks()",
            "            if blocks.favicon_path is None:",
            "                return static_resource(\"img/logo.svg\")",
            "            else:",
            "                return FileResponse(blocks.favicon_path)",
            "",
            "        @app.head(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])",
            "        async def reverse_proxy(url_path: str):",
            "            # Adapted from: https://github.com/tiangolo/fastapi/issues/1788",
            "            try:",
            "                rp_req = app.build_proxy_request(url_path)",
            "            except PermissionError as err:",
            "                raise HTTPException(status_code=400, detail=str(err)) from err",
            "            rp_resp = await client.send(rp_req, stream=True)",
            "            rp_resp.headers.update({\"Content-Disposition\": \"attachment\"})",
            "            return StreamingResponse(",
            "                rp_resp.aiter_raw(),",
            "                status_code=rp_resp.status_code,",
            "                headers=rp_resp.headers,  # type: ignore",
            "                background=BackgroundTask(rp_resp.aclose),",
            "            )",
            "",
            "        @app.head(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        @app.get(\"/file={path_or_url:path}\", dependencies=[Depends(login_check)])",
            "        async def file(path_or_url: str, request: fastapi.Request):",
            "            blocks = app.get_blocks()",
            "            if client_utils.is_http_url_like(path_or_url):",
            "                return RedirectResponse(",
            "                    url=path_or_url, status_code=status.HTTP_302_FOUND",
            "                )",
            "",
            "            if route_utils.starts_with_protocol(path_or_url):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            abs_path = utils.abspath(path_or_url)",
            "",
            "            in_blocklist = any(",
            "                utils.is_in_or_equal(abs_path, blocked_path)",
            "                for blocked_path in blocks.blocked_paths",
            "            )",
            "",
            "            is_dir = abs_path.is_dir()",
            "",
            "            if is_dir or in_blocklist:",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            created_by_app = False",
            "            for temp_file_set in blocks.temp_file_sets:",
            "                if abs_path in temp_file_set:",
            "                    created_by_app = True",
            "                    break",
            "            in_allowlist = any(",
            "                utils.is_in_or_equal(abs_path, allowed_path)",
            "                for allowed_path in blocks.allowed_paths",
            "            )",
            "            is_static_file = utils.is_static_file(abs_path)",
            "            was_uploaded = utils.is_in_or_equal(abs_path, app.uploaded_file_dir)",
            "            is_cached_example = utils.is_in_or_equal(",
            "                abs_path, utils.abspath(utils.get_cache_folder())",
            "            )",
            "",
            "            if not (",
            "                created_by_app",
            "                or in_allowlist",
            "                or was_uploaded",
            "                or is_cached_example",
            "                or is_static_file",
            "            ):",
            "                raise HTTPException(403, f\"File not allowed: {path_or_url}.\")",
            "",
            "            if not abs_path.exists():",
            "                raise HTTPException(404, f\"File not found: {path_or_url}.\")",
            "",
            "            range_val = request.headers.get(\"Range\", \"\").strip()",
            "            if range_val.startswith(\"bytes=\") and \"-\" in range_val:",
            "                range_val = range_val[6:]",
            "                start, end = range_val.split(\"-\")",
            "                if start.isnumeric() and end.isnumeric():",
            "                    start = int(start)",
            "                    end = int(end)",
            "                    headers = dict(request.headers)",
            "                    headers[\"Content-Disposition\"] = \"attachment\"",
            "                    response = ranged_response.RangedFileResponse(",
            "                        abs_path,",
            "                        ranged_response.OpenRange(start, end),",
            "                        headers,",
            "                        stat_result=os.stat(abs_path),",
            "                    )",
            "                    return response",
            "",
            "            return FileResponse(",
            "                abs_path,",
            "                headers={\"Accept-Ranges\": \"bytes\"},",
            "                content_disposition_type=\"attachment\",",
            "                media_type=\"application/octet-stream\",",
            "            )",
            "",
            "        @app.get(",
            "            \"/stream/{session_hash}/{run}/{component_id}\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        async def stream(",
            "            session_hash: str,",
            "            run: int,",
            "            component_id: int,",
            "            request: fastapi.Request,  # noqa: ARG001",
            "        ):",
            "            stream: list = (",
            "                app.get_blocks()",
            "                .pending_streams[session_hash]",
            "                .get(run, {})",
            "                .get(component_id, None)",
            "            )",
            "            if stream is None:",
            "                raise HTTPException(404, \"Stream not found.\")",
            "",
            "            def stream_wrapper():",
            "                check_stream_rate = 0.01",
            "                max_wait_time = 120  # maximum wait between yields - assume generator thread has crashed otherwise.",
            "                wait_time = 0",
            "                while True:",
            "                    if len(stream) == 0:",
            "                        if wait_time > max_wait_time:",
            "                            return",
            "                        wait_time += check_stream_rate",
            "                        time.sleep(check_stream_rate)",
            "                        continue",
            "                    wait_time = 0",
            "                    next_stream = stream.pop(0)",
            "                    if next_stream is None:",
            "                        return",
            "                    yield next_stream",
            "",
            "            return StreamingResponse(stream_wrapper())",
            "",
            "        @app.get(\"/file/{path:path}\", dependencies=[Depends(login_check)])",
            "        async def file_deprecated(path: str, request: fastapi.Request):",
            "            return await file(path, request)",
            "",
            "        @app.post(\"/reset/\")",
            "        @app.post(\"/reset\")",
            "        async def reset_iterator(body: ResetBody):  # noqa: ARG001",
            "            # No-op, all the cancelling/reset logic handled by /cancel",
            "            return {\"success\": True}",
            "",
            "        @app.get(\"/heartbeat/{session_hash}\")",
            "        def heartbeat(",
            "            session_hash: str,",
            "            request: fastapi.Request,",
            "            background_tasks: BackgroundTasks,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            \"\"\"Clients make a persistent connection to this endpoint to keep the session alive.",
            "            When the client disconnects, the session state is deleted.",
            "            \"\"\"",
            "            heartbeat_rate = 0.25 if os.getenv(\"GRADIO_IS_E2E_TEST\", None) else 15",
            "",
            "            async def wait():",
            "                await asyncio.sleep(heartbeat_rate)",
            "                return \"wait\"",
            "",
            "            async def stop_stream():",
            "                await app.stop_event.wait()",
            "                return \"stop\"",
            "",
            "            async def iterator():",
            "                while True:",
            "                    try:",
            "                        yield \"data: ALIVE\\n\\n\"",
            "                        # We need to close the heartbeat connections as soon as the server stops",
            "                        # otherwise the server can take forever to close",
            "                        wait_task = asyncio.create_task(wait())",
            "                        stop_stream_task = asyncio.create_task(stop_stream())",
            "                        done, _ = await asyncio.wait(",
            "                            [wait_task, stop_stream_task],",
            "                            return_when=asyncio.FIRST_COMPLETED,",
            "                        )",
            "                        done = [d.result() for d in done]",
            "                        if \"stop\" in done:",
            "                            raise asyncio.CancelledError()",
            "                    except asyncio.CancelledError:",
            "                        req = Request(request, username, session_hash=session_hash)",
            "                        root_path = route_utils.get_root_url(",
            "                            request=request,",
            "                            route_path=f\"/hearbeat/{session_hash}\",",
            "                            root_path=app.root_path,",
            "                        )",
            "                        body = PredictBody(",
            "                            session_hash=session_hash, data=[], request=request",
            "                        )",
            "                        unload_fn_indices = [",
            "                            i",
            "                            for i, dep in app.get_blocks().fns.items()",
            "                            if any(t for t in dep.targets if t[1] == \"unload\")",
            "                        ]",
            "                        for fn_index in unload_fn_indices:",
            "                            # The task runnning this loop has been cancelled",
            "                            # so we add tasks in the background",
            "                            background_tasks.add_task(",
            "                                route_utils.call_process_api,",
            "                                app=app,",
            "                                body=body,",
            "                                gr_request=req,",
            "                                fn=app.get_blocks().fns[fn_index],",
            "                                root_path=root_path,",
            "                            )",
            "                        # This will mark the state to be deleted in an hour",
            "                        if session_hash in app.state_holder.session_data:",
            "                            app.state_holder.session_data[session_hash].is_closed = True",
            "                        return",
            "",
            "            return StreamingResponse(iterator(), media_type=\"text/event-stream\")",
            "",
            "        # had to use '/run' endpoint for Colab compatibility, '/api' supported for backwards compatibility",
            "        @app.post(\"/run/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/run/{api_name}/\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/api/{api_name}/\", dependencies=[Depends(login_check)])",
            "        async def predict(",
            "            api_name: str,",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            fn = route_utils.get_fn(",
            "                blocks=app.get_blocks(), api_name=api_name, body=body",
            "            )",
            "",
            "            if not app.get_blocks().api_open and fn.queue:",
            "                raise HTTPException(",
            "                    detail=\"This API endpoint does not accept direct HTTP POST requests. Please join the queue to use this API.\",",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                )",
            "",
            "            gr_request = route_utils.compile_gr_request(",
            "                body,",
            "                fn=fn,",
            "                username=username,",
            "                request=request,",
            "            )",
            "            root_path = route_utils.get_root_url(",
            "                request=request, route_path=f\"/api/{api_name}\", root_path=app.root_path",
            "            )",
            "            try:",
            "                output = await route_utils.call_process_api(",
            "                    app=app,",
            "                    body=body,",
            "                    gr_request=gr_request,",
            "                    fn=fn,",
            "                    root_path=root_path,",
            "                )",
            "            except BaseException as error:",
            "                content = utils.error_payload(error, app.get_blocks().show_error)",
            "                traceback.print_exc()",
            "                return JSONResponse(",
            "                    content=content,",
            "                    status_code=500,",
            "                )",
            "            return output",
            "",
            "        @app.post(\"/call/{api_name}\", dependencies=[Depends(login_check)])",
            "        @app.post(\"/call/{api_name}/\", dependencies=[Depends(login_check)])",
            "        async def simple_predict_post(",
            "            api_name: str,",
            "            body: SimplePredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            full_body = PredictBody(",
            "                **body.model_dump(), request=request, simple_format=True",
            "            )",
            "            fn = route_utils.get_fn(",
            "                blocks=app.get_blocks(), api_name=api_name, body=full_body",
            "            )",
            "            full_body.fn_index = fn._id",
            "            return await queue_join_helper(full_body, request, username)",
            "",
            "        @app.post(\"/queue/join\", dependencies=[Depends(login_check)])",
            "        async def queue_join(",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str = Depends(get_current_user),",
            "        ):",
            "            if body.session_hash is None:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_400_BAD_REQUEST,",
            "                    detail=\"Session hash not found.\",",
            "                )",
            "            return await queue_join_helper(body, request, username)",
            "",
            "        async def queue_join_helper(",
            "            body: PredictBody,",
            "            request: fastapi.Request,",
            "            username: str,",
            "        ):",
            "            blocks = app.get_blocks()",
            "",
            "            if blocks._queue.server_app is None:",
            "                blocks._queue.set_server_app(app)",
            "",
            "            if blocks._queue.stopped:",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_503_SERVICE_UNAVAILABLE,",
            "                    detail=\"Queue is stopped.\",",
            "                )",
            "",
            "            success, event_id = await blocks._queue.push(",
            "                body=body, request=request, username=username",
            "            )",
            "            if not success:",
            "                status_code = (",
            "                    status.HTTP_503_SERVICE_UNAVAILABLE",
            "                    if \"Queue is full.\" in event_id",
            "                    else status.HTTP_400_BAD_REQUEST",
            "                )",
            "                raise HTTPException(status_code=status_code, detail=event_id)",
            "            return {\"event_id\": event_id}",
            "",
            "        @app.post(\"/cancel\")",
            "        async def cancel_event(body: CancelBody):",
            "            await cancel_tasks({f\"{body.session_hash}_{body.fn_index}\"})",
            "            blocks = app.get_blocks()",
            "            # Need to complete the job so that the client disconnects",
            "            session_open = (",
            "                body.session_hash in blocks._queue.pending_messages_per_session",
            "            )",
            "            event_running = (",
            "                body.event_id",
            "                in blocks._queue.pending_event_ids_session.get(body.session_hash, {})",
            "            )",
            "            if session_open and event_running:",
            "                message = ProcessCompletedMessage(",
            "                    output={}, success=True, event_id=body.event_id",
            "                )",
            "                blocks._queue.pending_messages_per_session[",
            "                    body.session_hash",
            "                ].put_nowait(message)",
            "            if body.event_id in app.iterators:",
            "                async with app.lock:",
            "                    del app.iterators[body.event_id]",
            "                    app.iterators_to_reset.add(body.event_id)",
            "            return {\"success\": True}",
            "",
            "        @app.get(\"/call/{api_name}/{event_id}\", dependencies=[Depends(login_check)])",
            "        async def simple_predict_get(",
            "            request: fastapi.Request,",
            "            event_id: str,",
            "        ):",
            "            def process_msg(message: EventMessage) -> str | None:",
            "                if isinstance(message, ProcessCompletedMessage):",
            "                    event = \"complete\" if message.success else \"error\"",
            "                    data = message.output.get(\"data\")",
            "                elif isinstance(message, ProcessGeneratingMessage):",
            "                    event = \"generating\" if message.success else \"error\"",
            "                    data = message.output.get(\"data\")",
            "                elif isinstance(message, HeartbeatMessage):",
            "                    event = \"heartbeat\"",
            "                    data = None",
            "                elif isinstance(message, UnexpectedErrorMessage):",
            "                    event = \"error\"",
            "                    data = message.message",
            "                else:",
            "                    return None",
            "                return f\"event: {event}\\ndata: {json.dumps(data)}\\n\\n\"",
            "",
            "            return await queue_data_helper(request, event_id, process_msg)",
            "",
            "        @app.get(\"/queue/data\", dependencies=[Depends(login_check)])",
            "        async def queue_data(",
            "            request: fastapi.Request,",
            "            session_hash: str,",
            "        ):",
            "            def process_msg(message: EventMessage) -> str:",
            "                return f\"data: {orjson.dumps(message.model_dump(), default=str).decode('utf-8')}\\n\\n\"",
            "",
            "            return await queue_data_helper(request, session_hash, process_msg)",
            "",
            "        async def queue_data_helper(",
            "            request: fastapi.Request,",
            "            session_hash: str,",
            "            process_msg: Callable[[EventMessage], str | None],",
            "        ):",
            "            blocks = app.get_blocks()",
            "",
            "            async def sse_stream(request: fastapi.Request):",
            "                try:",
            "                    last_heartbeat = time.perf_counter()",
            "                    while True:",
            "                        if await request.is_disconnected():",
            "                            await blocks._queue.clean_events(session_hash=session_hash)",
            "                            return",
            "",
            "                        if (",
            "                            session_hash",
            "                            not in blocks._queue.pending_messages_per_session",
            "                        ):",
            "                            raise HTTPException(",
            "                                status_code=status.HTTP_404_NOT_FOUND,",
            "                                detail=\"Session not found.\",",
            "                            )",
            "",
            "                        heartbeat_rate = 15",
            "                        check_rate = 0.05",
            "                        message = None",
            "                        try:",
            "                            messages = blocks._queue.pending_messages_per_session[",
            "                                session_hash",
            "                            ]",
            "                            message = messages.get_nowait()",
            "                        except EmptyQueue:",
            "                            await asyncio.sleep(check_rate)",
            "                            if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                                # Fix this",
            "                                message = HeartbeatMessage()",
            "                                # Need to reset last_heartbeat with perf_counter",
            "                                # otherwise only a single hearbeat msg will be sent",
            "                                # and then the stream will retry leading to infinite queue \ud83d\ude2c",
            "                                last_heartbeat = time.perf_counter()",
            "",
            "                        if blocks._queue.stopped:",
            "                            message = UnexpectedErrorMessage(",
            "                                message=\"Server stopped unexpectedly.\",",
            "                                success=False,",
            "                            )",
            "                        if message:",
            "                            response = process_msg(message)",
            "                            if response is not None:",
            "                                yield response",
            "                            if (",
            "                                isinstance(message, ProcessCompletedMessage)",
            "                                and message.event_id",
            "                            ):",
            "                                blocks._queue.pending_event_ids_session[",
            "                                    session_hash",
            "                                ].remove(message.event_id)",
            "                                if message.msg == ServerMessage.server_stopped or (",
            "                                    message.msg == ServerMessage.process_completed",
            "                                    and (",
            "                                        len(",
            "                                            blocks._queue.pending_event_ids_session[",
            "                                                session_hash",
            "                                            ]",
            "                                        )",
            "                                        == 0",
            "                                    )",
            "                                ):",
            "                                    message = CloseStreamMessage()",
            "                                    response = process_msg(message)",
            "                                    if response is not None:",
            "                                        yield response",
            "                                    return",
            "                except BaseException as e:",
            "                    message = UnexpectedErrorMessage(",
            "                        message=str(e),",
            "                    )",
            "                    response = process_msg(message)",
            "                    if isinstance(e, asyncio.CancelledError):",
            "                        del blocks._queue.pending_messages_per_session[session_hash]",
            "                        await blocks._queue.clean_events(session_hash=session_hash)",
            "                    if response is not None:",
            "                        yield response",
            "                    raise e",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        async def get_item_or_file(",
            "            request: fastapi.Request,",
            "        ) -> Union[ComponentServerJSONBody, ComponentServerBlobBody]:",
            "            content_type = request.headers.get(\"Content-Type\")",
            "",
            "            if isinstance(content_type, str) and content_type.startswith(",
            "                \"multipart/form-data\"",
            "            ):",
            "                files = []",
            "                data = {}",
            "                async with request.form() as form:",
            "                    for key, value in form.items():",
            "                        if (",
            "                            isinstance(value, list)",
            "                            and len(value) > 1",
            "                            and isinstance(value[0], StarletteUploadFile)",
            "                        ):",
            "                            for i, v in enumerate(value):",
            "                                if isinstance(v, StarletteUploadFile):",
            "                                    filename = v.filename",
            "                                    contents = await v.read()",
            "                                    files.append((filename, contents))",
            "                                else:",
            "                                    data[f\"{key}-{i}\"] = v",
            "                        elif isinstance(value, StarletteUploadFile):",
            "                            filename = value.filename",
            "                            contents = await value.read()",
            "                            files.append((filename, contents))",
            "                        else:",
            "                            data[key] = value",
            "",
            "                return ComponentServerBlobBody(",
            "                    data=DataWithFiles(data=data, files=files),",
            "                    component_id=data[\"component_id\"],",
            "                    session_hash=data[\"session_hash\"],",
            "                    fn_name=data[\"fn_name\"],",
            "                )",
            "            else:",
            "                try:",
            "                    data = await request.json()",
            "                    return ComponentServerJSONBody(",
            "                        data=data[\"data\"],",
            "                        component_id=data[\"component_id\"],",
            "                        session_hash=data[\"session_hash\"],",
            "                        fn_name=data[\"fn_name\"],",
            "                    )",
            "",
            "                except Exception:",
            "                    raise HTTPException(",
            "                        status_code=status.HTTP_400_BAD_REQUEST,",
            "                        detail=\"Invalid JSON body.\",",
            "                    ) from None",
            "",
            "        @app.post(",
            "            \"/component_server\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        @app.post(",
            "            \"/component_server/\",",
            "            dependencies=[Depends(login_check)],",
            "        )",
            "        async def component_server(",
            "            request: fastapi.Request,",
            "        ):",
            "            body = await get_item_or_file(request)",
            "            state = app.state_holder[body.session_hash]",
            "            component_id = body.component_id",
            "            block: Block",
            "            if component_id in state:",
            "                block = state[component_id]",
            "            else:",
            "                block = app.get_blocks().blocks[component_id]",
            "            fn = getattr(block, body.fn_name, None)",
            "            if fn is None or not getattr(fn, \"_is_server_fn\", False):",
            "                raise HTTPException(",
            "                    status_code=status.HTTP_404_NOT_FOUND,",
            "                    detail=\"Function not found.\",",
            "                )",
            "            return fn(body.data)",
            "",
            "        @app.get(",
            "            \"/queue/status\",",
            "            dependencies=[Depends(login_check)],",
            "            response_model=EstimationMessage,",
            "        )",
            "        async def get_queue_status():",
            "            return app.get_blocks()._queue.get_status()",
            "",
            "        @app.get(\"/upload_progress\")",
            "        def get_upload_progress(upload_id: str, request: fastapi.Request):",
            "            async def sse_stream(request: fastapi.Request):",
            "                last_heartbeat = time.perf_counter()",
            "                is_done = False",
            "                while True:",
            "                    if await request.is_disconnected():",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "                    if is_done:",
            "                        file_upload_statuses.stop_tracking(upload_id)",
            "                        return",
            "",
            "                    heartbeat_rate = 15",
            "                    check_rate = 0.05",
            "                    try:",
            "                        if file_upload_statuses.is_done(upload_id):",
            "                            message = {\"msg\": \"done\"}",
            "                            is_done = True",
            "                        else:",
            "                            update = file_upload_statuses.pop(upload_id)",
            "                            message = {",
            "                                \"msg\": \"update\",",
            "                                \"orig_name\": update.filename,",
            "                                \"chunk_size\": update.chunk_size,",
            "                            }",
            "                        yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                    except FileUploadProgressNotTrackedError:",
            "                        return",
            "                    except FileUploadProgressNotQueuedError:",
            "                        await asyncio.sleep(check_rate)",
            "                        if time.perf_counter() - last_heartbeat > heartbeat_rate:",
            "                            message = {\"msg\": \"heartbeat\"}",
            "                            yield f\"data: {json.dumps(message)}\\n\\n\"",
            "                            last_heartbeat = time.perf_counter()",
            "",
            "            return StreamingResponse(",
            "                sse_stream(request),",
            "                media_type=\"text/event-stream\",",
            "            )",
            "",
            "        @app.post(\"/upload\", dependencies=[Depends(login_check)])",
            "        async def upload_file(",
            "            request: fastapi.Request,",
            "            bg_tasks: BackgroundTasks,",
            "            upload_id: Optional[str] = None,",
            "        ):",
            "            content_type_header = request.headers.get(\"Content-Type\")",
            "            content_type: bytes",
            "            content_type, _ = parse_options_header(content_type_header or \"\")",
            "            if content_type != b\"multipart/form-data\":",
            "                raise HTTPException(status_code=400, detail=\"Invalid content type.\")",
            "",
            "            try:",
            "                if upload_id:",
            "                    file_upload_statuses.track(upload_id)",
            "                max_file_size = app.get_blocks().max_file_size",
            "                max_file_size = max_file_size if max_file_size is not None else math.inf",
            "                multipart_parser = GradioMultiPartParser(",
            "                    request.headers,",
            "                    request.stream(),",
            "                    max_files=1000,",
            "                    max_fields=1000,",
            "                    max_file_size=max_file_size,",
            "                    upload_id=upload_id if upload_id else None,",
            "                    upload_progress=file_upload_statuses if upload_id else None,",
            "                )",
            "                form = await multipart_parser.parse()",
            "            except MultiPartException as exc:",
            "                code = 413 if \"maximum allowed size\" in exc.message else 400",
            "                return PlainTextResponse(exc.message, status_code=code)",
            "",
            "            output_files = []",
            "            files_to_copy = []",
            "            locations: list[str] = []",
            "",
            "            for temp_file in form.getlist(\"files\"):",
            "                if not isinstance(temp_file, GradioUploadFile):",
            "                    raise TypeError(\"File is not an instance of GradioUploadFile\")",
            "                if temp_file.filename:",
            "                    file_name = Path(temp_file.filename).name",
            "                    name = client_utils.strip_invalid_filename_characters(file_name)",
            "                else:",
            "                    name = f\"tmp{secrets.token_hex(5)}\"",
            "                directory = Path(app.uploaded_file_dir) / temp_file.sha.hexdigest()",
            "                directory.mkdir(exist_ok=True, parents=True)",
            "                try:",
            "                    dest = utils.safe_join(",
            "                        DeveloperPath(str(directory)), UserProvidedPath(name)",
            "                    )",
            "                except InvalidPathError as err:",
            "                    raise HTTPException(",
            "                        status_code=400, detail=f\"Invalid file name: {name}\"",
            "                    ) from err",
            "                temp_file.file.close()",
            "                # we need to move the temp file to the cache directory",
            "                # but that's possibly blocking and we're in an async function",
            "                # so we try to rename (this is what shutil.move tries first)",
            "                # which should be super fast.",
            "                # if that fails, we move in the background.",
            "                try:",
            "                    os.rename(temp_file.file.name, dest)",
            "                except OSError:",
            "                    files_to_copy.append(temp_file.file.name)",
            "                    locations.append(dest)",
            "                output_files.append(dest)",
            "                blocks.upload_file_set.add(dest)",
            "            if files_to_copy:",
            "                bg_tasks.add_task(",
            "                    move_uploaded_files_to_cache, files_to_copy, locations",
            "                )",
            "            return output_files",
            "",
            "        @app.on_event(\"startup\")",
            "        @app.get(\"/startup-events\")",
            "        async def startup_events():",
            "            if not app.startup_events_triggered:",
            "                app.get_blocks().startup_events()",
            "                app.startup_events_triggered = True",
            "                return True",
            "            return False",
            "",
            "        @app.get(\"/theme.css\", response_class=PlainTextResponse)",
            "        def theme_css():",
            "            return PlainTextResponse(app.get_blocks().theme_css, media_type=\"text/css\")",
            "",
            "        @app.get(\"/robots.txt\", response_class=PlainTextResponse)",
            "        def robots_txt():",
            "            if app.get_blocks().share:",
            "                return \"User-agent: *\\nDisallow: /\"",
            "            else:",
            "                return \"User-agent: *\\nDisallow: \"",
            "",
            "        @app.get(\"/monitoring\", dependencies=[Depends(login_check)])",
            "        async def analytics_login(request: fastapi.Request):",
            "            root_url = route_utils.get_root_url(",
            "                request=request, route_path=\"/monitoring\", root_path=app.root_path",
            "            )",
            "            monitoring_url = f\"{root_url}/monitoring/{app.analytics_key}\"",
            "            print(f\"* Monitoring URL: {monitoring_url} *\")",
            "            return HTMLResponse(\"See console for monitoring URL.\")",
            "",
            "        @app.get(\"/monitoring/{key}\")",
            "        async def analytics_dashboard(key: str):",
            "            if compare_passwords_securely(key, app.analytics_key):",
            "                analytics_url = f\"/monitoring/{app.analytics_key}/dashboard\"",
            "                if not app.monitoring_enabled:",
            "                    from gradio.monitoring_dashboard import data",
            "                    from gradio.monitoring_dashboard import demo as dashboard",
            "",
            "                    mount_gradio_app(app, dashboard, path=analytics_url)",
            "                    dashboard._queue.start()",
            "                    analytics = app.get_blocks()._queue.event_analytics",
            "                    data[\"data\"] = analytics",
            "                    app.monitoring_enabled = True",
            "                return RedirectResponse(",
            "                    url=analytics_url, status_code=status.HTTP_302_FOUND",
            "                )",
            "            else:",
            "                raise HTTPException(status_code=403, detail=\"Invalid key.\")",
            "",
            "        return app",
            "",
            "",
            "########",
            "# Helper functions",
            "########",
            "",
            "",
            "def routes_safe_join(directory: DeveloperPath, path: UserProvidedPath) -> str:",
            "    \"\"\"Safely join the user path to the directory while performing some additional http-related checks,",
            "    e.g. ensuring that the full path exists on the local file system and is not a directory\"\"\"",
            "    if path == \"\":",
            "        raise fastapi.HTTPException(400)",
            "    if route_utils.starts_with_protocol(path):",
            "        raise fastapi.HTTPException(403)",
            "    try:",
            "        fullpath = Path(utils.safe_join(directory, path))",
            "    except InvalidPathError as e:",
            "        raise fastapi.HTTPException(403) from e",
            "    if fullpath.is_dir():",
            "        raise fastapi.HTTPException(403)",
            "    if not fullpath.exists():",
            "        raise fastapi.HTTPException(404)",
            "    return str(fullpath)",
            "",
            "",
            "def get_types(cls_set: List[Type]):",
            "    docset = []",
            "    types = []",
            "    for cls in cls_set:",
            "        doc = inspect.getdoc(cls) or \"\"",
            "        doc_lines = doc.split(\"\\n\")",
            "        for line in doc_lines:",
            "            if \"value (\" in line:",
            "                types.append(line.split(\"value (\")[1].split(\")\")[0])",
            "        docset.append(doc_lines[1].split(\":\")[-1])",
            "    return docset, types",
            "",
            "",
            "@document()",
            "def mount_gradio_app(",
            "    app: fastapi.FastAPI,",
            "    blocks: gradio.Blocks,",
            "    path: str,",
            "    app_kwargs: dict[str, Any] | None = None,",
            "    *,",
            "    auth: Callable | tuple[str, str] | list[tuple[str, str]] | None = None,",
            "    auth_message: str | None = None,",
            "    auth_dependency: Callable[[fastapi.Request], str | None] | None = None,",
            "    root_path: str | None = None,",
            "    allowed_paths: list[str] | None = None,",
            "    blocked_paths: list[str] | None = None,",
            "    favicon_path: str | None = None,",
            "    show_error: bool = True,",
            "    max_file_size: str | int | None = None,",
            ") -> fastapi.FastAPI:",
            "    \"\"\"Mount a gradio.Blocks to an existing FastAPI application.",
            "",
            "    Parameters:",
            "        app: The parent FastAPI application.",
            "        blocks: The blocks object we want to mount to the parent app.",
            "        path: The path at which the gradio application will be mounted.",
            "        app_kwargs: Additional keyword arguments to pass to the underlying FastAPI app as a dictionary of parameter keys and argument values. For example, `{\"docs_url\": \"/docs\"}`",
            "        auth: If provided, username and password (or list of username-password tuples) required to access the gradio app. Can also provide function that takes username and password and returns True if valid login.",
            "        auth_message: If provided, HTML message provided on login page for this gradio app.",
            "        auth_dependency: A function that takes a FastAPI request and returns a string user ID or None. If the function returns None for a specific request, that user is not authorized to access the gradio app (they will see a 401 Unauthorized response). To be used with external authentication systems like OAuth. Cannot be used with `auth`.",
            "        root_path: The subpath corresponding to the public deployment of this FastAPI application. For example, if the application is served at \"https://example.com/myapp\", the `root_path` should be set to \"/myapp\". A full URL beginning with http:// or https:// can be provided, which will be used in its entirety. Normally, this does not need to provided (even if you are using a custom `path`). However, if you are serving the FastAPI app behind a proxy, the proxy may not provide the full path to the Gradio app in the request headers. In which case, you can provide the root path here.",
            "        allowed_paths: List of complete filepaths or parent directories that this gradio app is allowed to serve. Must be absolute paths. Warning: if you provide directories, any files in these directories or their subdirectories are accessible to all users of your app.",
            "        blocked_paths: List of complete filepaths or parent directories that this gradio app is not allowed to serve (i.e. users of your app are not allowed to access). Must be absolute paths. Warning: takes precedence over `allowed_paths` and all other directories exposed by Gradio by default.",
            "        favicon_path: If a path to a file (.png, .gif, or .ico) is provided, it will be used as the favicon for this gradio app's page.",
            "        show_error: If True, any errors in the gradio app will be displayed in an alert modal and printed in the browser console log. Otherwise, errors will only be visible in the terminal session running the Gradio app.",
            "        max_file_size: The maximum file size in bytes that can be uploaded. Can be a string of the form \"<value><unit>\", where value is any positive integer and unit is one of \"b\", \"kb\", \"mb\", \"gb\", \"tb\". If None, no limit is set.",
            "    Example:",
            "        from fastapi import FastAPI",
            "        import gradio as gr",
            "        app = FastAPI()",
            "        @app.get(\"/\")",
            "        def read_main():",
            "            return {\"message\": \"This is your main app\"}",
            "        io = gr.Interface(lambda x: \"Hello, \" + x + \"!\", \"textbox\", \"textbox\")",
            "        app = gr.mount_gradio_app(app, io, path=\"/gradio\")",
            "        # Then run `uvicorn run:app` from the terminal and navigate to http://localhost:8000/gradio.",
            "    \"\"\"",
            "    if favicon_path is not None and path != \"/\":",
            "        warnings.warn(",
            "            \"The 'favicon_path' parameter is set but will be ignored because 'path' is not '/'. \"",
            "            \"Please add the favicon directly to your FastAPI app.\"",
            "        )",
            "",
            "    blocks.dev_mode = False",
            "    blocks.max_file_size = utils._parse_file_size(max_file_size)",
            "    blocks.config = blocks.get_config_file()",
            "    blocks.validate_queue_settings()",
            "    if auth is not None and auth_dependency is not None:",
            "        raise ValueError(",
            "            \"You cannot provide both `auth` and `auth_dependency` in mount_gradio_app(). Please choose one.\"",
            "        )",
            "    if (",
            "        auth",
            "        and not callable(auth)",
            "        and not isinstance(auth[0], tuple)",
            "        and not isinstance(auth[0], list)",
            "    ):",
            "        blocks.auth = [auth]",
            "    else:",
            "        blocks.auth = auth",
            "    blocks.auth_message = auth_message",
            "    blocks.favicon_path = favicon_path",
            "    blocks.allowed_paths = allowed_paths or []",
            "    blocks.blocked_paths = blocked_paths or []",
            "    blocks.show_error = show_error",
            "",
            "    if not isinstance(blocks.allowed_paths, list):",
            "        raise ValueError(\"`allowed_paths` must be a list of directories.\")",
            "    if not isinstance(blocks.blocked_paths, list):",
            "        raise ValueError(\"`blocked_paths` must be a list of directories.\")",
            "",
            "    if root_path is not None:",
            "        blocks.root_path = root_path",
            "",
            "    gradio_app = App.create_app(",
            "        blocks, app_kwargs=app_kwargs, auth_dependency=auth_dependency",
            "    )",
            "    old_lifespan = app.router.lifespan_context",
            "",
            "    @contextlib.asynccontextmanager",
            "    async def new_lifespan(app: FastAPI):",
            "        async with old_lifespan(",
            "            app",
            "        ):  # Instert the startup events inside the FastAPI context manager",
            "            async with gradio_app.router.lifespan_context(gradio_app):",
            "                gradio_app.get_blocks().startup_events()",
            "                yield",
            "",
            "    app.router.lifespan_context = new_lifespan",
            "",
            "    app.mount(path, gradio_app)",
            "    return app"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [],
            "112": [
                "STATIC_TEMPLATE_LIB"
            ],
            "113": [
                "STATIC_PATH_LIB"
            ],
            "114": [
                "BUILD_PATH_LIB"
            ],
            "449": [
                "App",
                "create_app",
                "static_resource"
            ],
            "461": [
                "App",
                "create_app",
                "custom_component_path"
            ],
            "473": [
                "App",
                "create_app",
                "custom_component_path"
            ],
            "474": [
                "App",
                "create_app",
                "custom_component_path"
            ],
            "475": [
                "App",
                "create_app",
                "custom_component_path"
            ],
            "497": [
                "App",
                "create_app",
                "build_resource"
            ],
            "546": [
                "App",
                "create_app"
            ],
            "1145": [
                "App",
                "create_app"
            ],
            "1156": [
                "App",
                "create_app"
            ],
            "1158": [
                "App",
                "create_app"
            ],
            "1221": [
                "safe_join"
            ],
            "1222": [
                "safe_join"
            ],
            "1223": [
                "safe_join"
            ],
            "1224": [
                "safe_join"
            ],
            "1225": [
                "safe_join"
            ],
            "1226": [
                "safe_join"
            ],
            "1227": [
                "safe_join"
            ],
            "1229": [
                "safe_join"
            ],
            "1231": [
                "safe_join"
            ],
            "1232": [
                "safe_join"
            ],
            "1233": [
                "safe_join"
            ],
            "1234": [
                "safe_join"
            ],
            "1235": [
                "safe_join"
            ],
            "1236": [
                "safe_join"
            ],
            "1237": [
                "safe_join"
            ],
            "1238": [
                "safe_join"
            ],
            "1239": [
                "safe_join"
            ],
            "1240": [
                "safe_join"
            ],
            "1241": [
                "safe_join"
            ],
            "1242": [
                "safe_join"
            ],
            "1243": [
                "safe_join"
            ],
            "1244": [
                "safe_join"
            ],
            "1245": [
                "safe_join"
            ],
            "1246": [
                "safe_join"
            ]
        },
        "addLocation": []
    }
}