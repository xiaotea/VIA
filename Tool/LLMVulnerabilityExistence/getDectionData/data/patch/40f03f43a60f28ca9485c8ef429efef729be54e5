{
    "src/Products/CMFCore/PortalFolder.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " \"\"\" PortalFolder: CMF-enabled Folder objects."
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-import marshal"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import json"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " import re"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from AccessControl.class_init import InitializeClass"
            },
            "8": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "             Parse cookie string for using variables in dtml."
            },
            "10": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         \"\"\""
            },
            "11": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filter = {}"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+        folder_filter = {}"
            },
            "13": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         for key, value in REQUEST.items():"
            },
            "14": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "             if key[:10] == 'filter_by_':"
            },
            "15": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                filter[key[10:]] = value"
            },
            "16": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        encoded = base64_encode(marshal.dumps(filter))"
            },
            "17": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        encoded = ''.join(encoded.split('\\n'))"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+                folder_filter[key[10:]] = value"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+        encoded = base64_encode(json.dumps(folder_filter).encode())"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+        encoded = b''.join(encoded.split(b'\\n'))"
            },
            "21": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         return encoded"
            },
            "22": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     @security.public"
            },
            "24": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "     def decodeFolderFilter(self, encoded):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        \"\"\" Parse cookie string for using variables in dtml."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        This is a public method and the input is not under our control."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        To prevent a DOS this method will refuse to decode data that seems"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        conspicuously large."
            },
            "30": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         \"\"\""
            },
            "31": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            Parse cookie string for using variables in dtml."
            },
            "32": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "33": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filter = {}"
            },
            "34": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if encoded:"
            },
            "35": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            filter.update(marshal.loads(base64_decode(encoded)))"
            },
            "36": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return filter"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        folder_filter = {}"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        if encoded and len(encoded) < 1000:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+            folder_filter.update(json.loads(base64_decode(encoded)))"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        return folder_filter"
            },
            "41": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 258,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "     def content_type(self):"
            },
            "43": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         \"\"\""
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\" PortalFolder: CMF-enabled Folder objects.",
            "\"\"\"",
            "",
            "import marshal",
            "import re",
            "",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from AccessControl.SecurityManagement import getSecurityManager",
            "from Acquisition import aq_base",
            "from Acquisition import aq_inner",
            "from Acquisition import aq_parent",
            "from OFS.Folder import Folder",
            "from OFS.OrderSupport import OrderSupport",
            "from zope.component import getUtility",
            "from zope.component import queryUtility",
            "from zope.component.factory import Factory",
            "from zope.interface import implementer",
            "",
            "from .CMFCatalogAware import OpaqueItemManager",
            "from .DynamicType import DynamicType",
            "from .exceptions import AccessControl_Unauthorized",
            "from .exceptions import BadRequest",
            "from .exceptions import zExceptions_Unauthorized",
            "from .interfaces import IContentTypeRegistry",
            "from .interfaces import IFolderish",
            "from .interfaces import IMutableMinimalDublinCore",
            "from .interfaces import ISiteRoot",
            "from .interfaces import ITypesTool",
            "from .permissions import AddPortalContent",
            "from .permissions import AddPortalFolders",
            "from .permissions import DeleteObjects",
            "from .permissions import ListFolderContents",
            "from .permissions import ManagePortal",
            "from .permissions import ManageProperties",
            "from .permissions import View",
            "from .utils import _checkPermission",
            "from .utils import base64_decode",
            "from .utils import base64_encode",
            "",
            "",
            "@implementer(IFolderish, IMutableMinimalDublinCore)",
            "class PortalFolderBase(DynamicType, OpaqueItemManager, Folder):",
            "",
            "    \"\"\"Base class for portal folder.",
            "    \"\"\"",
            "",
            "    security = ClassSecurityInfo()",
            "",
            "    description = ''",
            "",
            "    manage_options = (Folder.manage_options[:1]",
            "                      + ({'label': 'Components',",
            "                          'action': 'manage_components'},)",
            "                      + ({'label': 'Components Folder',",
            "                          'action': '++etc++site/manage_main'},)",
            "                      + Folder.manage_options[1:])",
            "",
            "    def __init__(self, id, title='', description=''):",
            "        self.id = id",
            "        self.title = title",
            "        self.description = description",
            "",
            "    #",
            "    #   'IMutableMinimalDublinCore' interface methods",
            "    #",
            "    @security.protected(View)",
            "    def Title(self):",
            "        \"\"\" Dublin Core Title element - resource name.",
            "        \"\"\"",
            "        return self.title",
            "",
            "    @security.protected(View)",
            "    def Description(self):",
            "        \"\"\" Dublin Core Description element - resource summary.",
            "        \"\"\"",
            "        return self.description",
            "",
            "    @security.protected(View)",
            "    def Type(self):",
            "        \"\"\" Dublin Core Type element - resource type.",
            "        \"\"\"",
            "        ti = self.getTypeInfo()",
            "        return ti is not None and ti.Title() or 'Unknown'",
            "",
            "    @security.protected(ManageProperties)",
            "    def setTitle(self, title):",
            "        \"\"\" Set Dublin Core Title element - resource name.",
            "        \"\"\"",
            "        self.title = title",
            "",
            "    @security.protected(ManageProperties)",
            "    def setDescription(self, description):",
            "        \"\"\" Set Dublin Core Description element - resource summary.",
            "        \"\"\"",
            "        self.description = description",
            "",
            "    #",
            "    #   other methods",
            "    #",
            "    @security.protected(ManageProperties)",
            "    def edit(self, title='', description=''):",
            "        \"\"\"",
            "        Edit the folder title (and possibly other attributes later)",
            "        \"\"\"",
            "        self.setTitle(title)",
            "        self.setDescription(description)",
            "        # BBB: for ICatalogAware subclasses",
            "        if getattr(self, 'reindexObject', None) is not None:",
            "            self.reindexObject()",
            "",
            "    @security.public",
            "    def allowedContentTypes(self):",
            "        \"\"\"",
            "            List type info objects for types which can be added in",
            "            this folder.",
            "        \"\"\"",
            "        ttool = getUtility(ITypesTool)",
            "        myType = ttool.getTypeInfo(self)",
            "        result = ttool.listTypeInfo()",
            "",
            "        if myType is not None:",
            "            return [t for t in result if myType.allowType(t.getId()) and",
            "                    t.isConstructionAllowed(self)]",
            "",
            "        return [t for t in result if t.isConstructionAllowed(self)]",
            "",
            "    def _filteredItems(self, ids, filt):",
            "        \"\"\"",
            "            Apply filter, a mapping, to child objects indicated by 'ids',",
            "            returning a sequence of (id, obj) tuples.",
            "        \"\"\"",
            "        # Restrict allowed content types",
            "        if filt is None:",
            "            filt = {}",
            "        else:",
            "            # We'll modify it, work on a copy.",
            "            filt = filt.copy()",
            "        pt = filt.get('portal_type', [])",
            "        if isinstance(pt, str):",
            "            pt = [pt]",
            "        ttool = getUtility(ITypesTool)",
            "        allowed_types = ttool.listContentTypes()",
            "        if not pt:",
            "            pt = allowed_types",
            "        else:",
            "            pt = [t for t in pt if t in allowed_types]",
            "        if not pt:",
            "            # After filtering, no types remain, so nothing should be",
            "            # returned.",
            "            return []",
            "        filt['portal_type'] = pt",
            "",
            "        query = ContentFilter(**filt)",
            "        result = []",
            "        append = result.append",
            "        get = self._getOb",
            "        for id in ids:",
            "            obj = get(id)",
            "            if query(obj):",
            "                append((id, obj))",
            "        return result",
            "",
            "    #",
            "    #   'IFolderish' interface methods",
            "    #",
            "    @security.public",
            "    def contentItems(self, filter=None):",
            "        # List contentish and folderish sub-objects and their IDs.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        ids = self.objectIds()",
            "        return self._filteredItems(ids, filter)",
            "",
            "    @security.public",
            "    def contentIds(self, filter=None):",
            "        # List IDs of contentish and folderish sub-objects.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        return [item[0] for item in self.contentItems(filter)]",
            "",
            "    @security.public",
            "    def contentValues(self, filter=None):",
            "        # List contentish and folderish sub-objects.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        return [item[1] for item in self.contentItems(filter)]",
            "",
            "    @security.protected(ListFolderContents)",
            "    def listFolderContents(self, contentFilter=None):",
            "        \"\"\" List viewable contentish and folderish sub-objects.",
            "        \"\"\"",
            "        fc_list = []",
            "        for id, obj in self.contentItems(contentFilter):",
            "            # validate() can either raise Unauthorized or return 0 to",
            "            # mean unauthorized.",
            "            try:",
            "                if getSecurityManager().validate(self, self, id, obj):",
            "                    fc_list.append(obj)",
            "            except zExceptions_Unauthorized:  # Catch *all* Unauths!",
            "                pass",
            "        return fc_list",
            "",
            "    #",
            "    #   webdav Resource method",
            "    #",
            "",
            "    # protected by 'WebDAV access'",
            "    def listDAVObjects(self):",
            "        # List sub-objects for PROPFIND requests.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        if _checkPermission(ManagePortal, self):",
            "            return self.objectValues()",
            "        else:",
            "            return self.listFolderContents()",
            "",
            "    #",
            "    #   other methods",
            "    #",
            "    @security.public",
            "    def encodeFolderFilter(self, REQUEST):",
            "        \"\"\"",
            "            Parse cookie string for using variables in dtml.",
            "        \"\"\"",
            "        filter = {}",
            "        for key, value in REQUEST.items():",
            "            if key[:10] == 'filter_by_':",
            "                filter[key[10:]] = value",
            "        encoded = base64_encode(marshal.dumps(filter))",
            "        encoded = ''.join(encoded.split('\\n'))",
            "        return encoded",
            "",
            "    @security.public",
            "    def decodeFolderFilter(self, encoded):",
            "        \"\"\"",
            "            Parse cookie string for using variables in dtml.",
            "        \"\"\"",
            "        filter = {}",
            "        if encoded:",
            "            filter.update(marshal.loads(base64_decode(encoded)))",
            "        return filter",
            "",
            "    def content_type(self):",
            "        \"\"\"",
            "            WebDAV needs this to do the Right Thing (TM).",
            "        \"\"\"",
            "        return None",
            "",
            "    def PUT_factory(self, name, typ, body):",
            "        \"\"\" Factory for PUT requests to objects which do not yet exist.",
            "",
            "        Used by NullResource.PUT.",
            "",
            "        Returns -- Bare and empty object of the appropriate type (or None, if",
            "        we don't know what to do)",
            "        \"\"\"",
            "        ctr = queryUtility(IContentTypeRegistry)",
            "        if ctr is None:",
            "            return None",
            "",
            "        typeObjectName = ctr.findTypeName(name, typ, body)",
            "        if typeObjectName is None:",
            "            return None",
            "",
            "        self.invokeFactory(typeObjectName, name)",
            "",
            "        # invokeFactory does too much, so the object has to be removed again",
            "        obj = aq_base(self._getOb(name))",
            "        self._delObject(name)",
            "        return obj",
            "",
            "    @security.protected(AddPortalContent)",
            "    def invokeFactory(self, type_name, id, RESPONSE=None, *args, **kw):",
            "        \"\"\" Invokes the portal_types tool.",
            "        \"\"\"",
            "        ttool = getUtility(ITypesTool)",
            "        myType = ttool.getTypeInfo(self)",
            "",
            "        if myType is not None:",
            "            if not myType.allowType(type_name):",
            "                raise ValueError('Disallowed subobject type: %s' % type_name)",
            "",
            "        return ttool.constructContent(type_name, self, id, RESPONSE,",
            "                                      *args, **kw)",
            "",
            "    @security.protected(AddPortalContent)",
            "    def checkIdAvailable(self, id):",
            "        try:",
            "            self._checkId(id)",
            "        except BadRequest:",
            "            return False",
            "        else:",
            "            return True",
            "",
            "    def MKCOL_handler(self, id, REQUEST=None, RESPONSE=None):",
            "        \"\"\"",
            "            Handle WebDAV MKCOL.",
            "        \"\"\"",
            "        self.manage_addFolder(id=id, title='')",
            "",
            "    def _checkId(self, id, allow_dup=0):",
            "        PortalFolderBase.inheritedAttribute('_checkId')(self, id, allow_dup)",
            "",
            "        if allow_dup:",
            "            return",
            "",
            "        # FIXME: needed to allow index_html for join code",
            "        if id == 'index_html':",
            "            return",
            "",
            "        # Another exception: Must allow \"syndication_information\" to enable",
            "        # Syndication...",
            "        if id == 'syndication_information':",
            "            return",
            "",
            "        # IDs starting with '@@' are reserved for views.",
            "        if id[:2] == '@@':",
            "            raise BadRequest('The id \"%s\" is invalid because it begins with '",
            "                             '\"@@\".' % id)",
            "",
            "        # This code prevents people other than the portal manager from",
            "        # overriding skinned names and tools.",
            "        if not getSecurityManager().checkPermission(ManagePortal, self):",
            "            ob = aq_inner(self)",
            "            while ob is not None:",
            "                if ISiteRoot.providedBy(ob):",
            "                    break",
            "                ob = aq_parent(ob)",
            "",
            "            if ob is not None:",
            "                # If the portal root has a non-contentish object by this name,",
            "                # don't allow an override.",
            "                if hasattr(ob, id) and \\",
            "                   id not in ob.contentIds() and \\",
            "                   not id.startswith('.'):",
            "                    raise BadRequest('The id \"%s\" is reserved.' % id)",
            "            # Don't allow ids used by Method Aliases.",
            "            ti = self.getTypeInfo()",
            "            if ti and ti.queryMethodID(id, context=self):",
            "                raise BadRequest('The id \"%s\" is reserved.' % id)",
            "        # Otherwise we're ok.",
            "",
            "    def _verifyObjectPaste(self, object, validate_src=1):",
            "        # This assists the version in OFS.CopySupport.",
            "        # It enables the clipboard to function correctly",
            "        # with objects created by a multi-factory.",
            "        mt = getattr(object, '__factory_meta_type__', None)",
            "        meta_types = getattr(self, 'all_meta_types', None)",
            "",
            "        if mt is not None and meta_types is not None:",
            "            mt_permission = None",
            "",
            "            if callable(meta_types):",
            "                meta_types = meta_types()",
            "",
            "            for d in meta_types:",
            "                if d['name'] == mt:",
            "                    mt_permission = d.get('permission')",
            "                    break",
            "",
            "            if mt_permission is not None:",
            "                sm = getSecurityManager()",
            "",
            "                if sm.checkPermission(mt_permission, self):",
            "                    if validate_src:",
            "                        # Ensure the user is allowed to access the object on",
            "                        # the clipboard.",
            "                        parent = aq_parent(aq_inner(object))",
            "",
            "                        if not sm.validate(None, parent, None, object):",
            "                            raise AccessControl_Unauthorized(object.getId())",
            "",
            "                        if validate_src == 2:  # moving",
            "                            if not sm.checkPermission(DeleteObjects, parent):",
            "                                raise AccessControl_Unauthorized('Delete not '",
            "                                                                 'allowed.')",
            "                else:",
            "                    raise AccessControl_Unauthorized(",
            "                            'You do not possess the '",
            "                            '%r permission in the context of the container '",
            "                            'into which you are pasting, thus you are not '",
            "                            'able to perform this operation.' % mt_permission)",
            "            else:",
            "                raise AccessControl_Unauthorized(",
            "                        'The object %r does not '",
            "                        'support this operation.' % object.getId())",
            "        else:",
            "            # Call OFS' _verifyObjectPaste if necessary",
            "            PortalFolderBase.inheritedAttribute(",
            "                '_verifyObjectPaste')(self, object, validate_src)",
            "",
            "        # Finally, check allowed content types",
            "        if hasattr(aq_base(object), 'getPortalTypeName'):",
            "",
            "            type_name = object.getPortalTypeName()",
            "",
            "            if type_name is not None:",
            "",
            "                ttool = getUtility(ITypesTool)",
            "                myType = ttool.getTypeInfo(self)",
            "",
            "                if myType is not None and not myType.allowType(type_name):",
            "                    raise ValueError('Disallowed subobject type: %s' %",
            "                                     type_name)",
            "",
            "                # Check for workflow guards",
            "                objType = ttool.getTypeInfo(type_name)",
            "                if objType is not None and \\",
            "                   not objType._checkWorkflowAllowed(self):",
            "                    raise ValueError('Pasting not allowed in this workflow')",
            "",
            "    security.setPermissionDefault(AddPortalContent, ('Owner', 'Manager'))",
            "",
            "    @security.protected(AddPortalFolders)",
            "    def manage_addFolder(self, id, title='', REQUEST=None):",
            "        \"\"\" Add a new folder-like object with id *id*.",
            "",
            "        IF present, use the parent object's 'mkdir' alias; otherwise, just add",
            "        a PortalFolder.",
            "        \"\"\"",
            "        ti = self.getTypeInfo()",
            "        method_id = ti and ti.queryMethodID('mkdir', context=self)",
            "        if method_id:",
            "            # call it",
            "            getattr(self, method_id)(id=id)",
            "        else:",
            "            self.invokeFactory(type_name='Folder', id=id)",
            "",
            "        ob = self._getOb(id)",
            "        ob.setTitle(title)",
            "        try:",
            "            ob.reindexObject()",
            "        except AttributeError:",
            "            pass",
            "",
            "        if REQUEST is not None:",
            "            return self.manage_main(self, REQUEST, update_menu=1)",
            "",
            "",
            "InitializeClass(PortalFolderBase)",
            "",
            "",
            "class PortalFolder(OrderSupport, PortalFolderBase):",
            "",
            "    \"\"\"Implements portal content management, but not UI details.",
            "    \"\"\"",
            "",
            "    portal_type = 'Folder'",
            "",
            "    security = ClassSecurityInfo()",
            "",
            "    manage_options = (OrderSupport.manage_options +",
            "                      PortalFolderBase.manage_options[1:])",
            "",
            "    @security.protected(AddPortalFolders)",
            "    def manage_addPortalFolder(self, id, title='', REQUEST=None):",
            "        \"\"\"Add a new PortalFolder object with id *id*.",
            "        \"\"\"",
            "        ob = PortalFolder(id, title)",
            "        self._setObject(id, ob, suppress_events=True)",
            "        if REQUEST is not None:",
            "            return self.folder_contents(  # XXX: ick!",
            "                self, REQUEST, portal_status_message='Folder added')",
            "",
            "",
            "InitializeClass(PortalFolder)",
            "",
            "PortalFolderFactory = Factory(PortalFolder)",
            "",
            "manage_addPortalFolder = PortalFolder.manage_addPortalFolder",
            "",
            "",
            "class ContentFilter:",
            "",
            "    \"\"\"Represent a predicate against a content object's metadata.",
            "    \"\"\"",
            "",
            "    MARKER = []",
            "    filterSubject = []",
            "",
            "    def __init__(self, Title=MARKER, Creator=MARKER, Subject=MARKER,",
            "                 Description=MARKER, created=MARKER, created_usage='range:min',",
            "                 modified=MARKER, modified_usage='range:min', Type=MARKER,",
            "                 portal_type=MARKER, **Ignored):",
            "",
            "        self.predicates = []",
            "        self.description = []",
            "",
            "        if Title is not self.MARKER:",
            "            self.predicates.append(lambda x, pat=re.compile(Title):",
            "                                   pat.search(x.Title()))",
            "            self.description.append('Title: %s' % Title)",
            "",
            "        if Creator and Creator is not self.MARKER:",
            "            self.predicates.append(lambda x, creator=Creator:",
            "                                   creator in x.listCreators())",
            "            self.description.append('Creator: %s' % Creator)",
            "",
            "        if Subject and Subject is not self.MARKER:",
            "            self.filterSubject = Subject",
            "            self.predicates.append(self.hasSubject)",
            "            self.description.append('Subject: %s' % ', '.join(Subject))",
            "",
            "        if Description is not self.MARKER:",
            "            self.predicates.append(lambda x, pat=re.compile(Description):",
            "                                   pat.search(x.Description()))",
            "            self.description.append('Description: %s' % Description)",
            "",
            "        if created is not self.MARKER:",
            "            if created_usage == 'range:min':",
            "                self.predicates.append(lambda x, cd=created:",
            "                                       cd <= x.created())",
            "                self.description.append('Created since: %s' % created)",
            "            if created_usage == 'range:max':",
            "                self.predicates.append(lambda x, cd=created:",
            "                                       cd >= x.created())",
            "                self.description.append('Created before: %s' % created)",
            "",
            "        if modified is not self.MARKER:",
            "            if modified_usage == 'range:min':",
            "                self.predicates.append(lambda x, md=modified:",
            "                                       md <= x.modified())",
            "                self.description.append('Modified since: %s' % modified)",
            "            if modified_usage == 'range:max':",
            "                self.predicates.append(lambda x, md=modified:",
            "                                       md >= x.modified())",
            "                self.description.append('Modified before: %s' % modified)",
            "",
            "        if Type:",
            "            if isinstance(Type, str):",
            "                Type = [Type]",
            "            self.predicates.append(lambda x, Type=Type: x.Type() in Type)",
            "            self.description.append('Type: %s' % ', '.join(Type))",
            "",
            "        if portal_type and portal_type is not self.MARKER:",
            "            if isinstance(portal_type, str):",
            "                portal_type = [portal_type]",
            "            self.predicates.append(lambda x, pt=portal_type:",
            "                                   hasattr(aq_base(x), 'getPortalTypeName')",
            "                                   and x.getPortalTypeName() in pt)",
            "            self.description.append('Portal Type: %s' % ', '.join(portal_type))",
            "",
            "    def hasSubject(self, obj):",
            "        \"\"\"",
            "        Converts Subject string into a List for content filter view.",
            "        \"\"\"",
            "        for sub in obj.Subject():",
            "            if sub in self.filterSubject:",
            "                return 1",
            "        return 0",
            "",
            "    def __call__(self, content):",
            "",
            "        for predicate in self.predicates:",
            "",
            "            try:",
            "                if not predicate(content):",
            "                    return 0",
            "            except (AttributeError, KeyError, IndexError, ValueError):",
            "                # predicates are *not* allowed to throw exceptions",
            "                return 0",
            "",
            "        return 1",
            "",
            "    def __str__(self):",
            "        \"\"\"",
            "            Return a stringified description of the filter.",
            "        \"\"\"",
            "        return '; '.join(self.description)"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\" PortalFolder: CMF-enabled Folder objects.",
            "\"\"\"",
            "",
            "import json",
            "import re",
            "",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from AccessControl.SecurityManagement import getSecurityManager",
            "from Acquisition import aq_base",
            "from Acquisition import aq_inner",
            "from Acquisition import aq_parent",
            "from OFS.Folder import Folder",
            "from OFS.OrderSupport import OrderSupport",
            "from zope.component import getUtility",
            "from zope.component import queryUtility",
            "from zope.component.factory import Factory",
            "from zope.interface import implementer",
            "",
            "from .CMFCatalogAware import OpaqueItemManager",
            "from .DynamicType import DynamicType",
            "from .exceptions import AccessControl_Unauthorized",
            "from .exceptions import BadRequest",
            "from .exceptions import zExceptions_Unauthorized",
            "from .interfaces import IContentTypeRegistry",
            "from .interfaces import IFolderish",
            "from .interfaces import IMutableMinimalDublinCore",
            "from .interfaces import ISiteRoot",
            "from .interfaces import ITypesTool",
            "from .permissions import AddPortalContent",
            "from .permissions import AddPortalFolders",
            "from .permissions import DeleteObjects",
            "from .permissions import ListFolderContents",
            "from .permissions import ManagePortal",
            "from .permissions import ManageProperties",
            "from .permissions import View",
            "from .utils import _checkPermission",
            "from .utils import base64_decode",
            "from .utils import base64_encode",
            "",
            "",
            "@implementer(IFolderish, IMutableMinimalDublinCore)",
            "class PortalFolderBase(DynamicType, OpaqueItemManager, Folder):",
            "",
            "    \"\"\"Base class for portal folder.",
            "    \"\"\"",
            "",
            "    security = ClassSecurityInfo()",
            "",
            "    description = ''",
            "",
            "    manage_options = (Folder.manage_options[:1]",
            "                      + ({'label': 'Components',",
            "                          'action': 'manage_components'},)",
            "                      + ({'label': 'Components Folder',",
            "                          'action': '++etc++site/manage_main'},)",
            "                      + Folder.manage_options[1:])",
            "",
            "    def __init__(self, id, title='', description=''):",
            "        self.id = id",
            "        self.title = title",
            "        self.description = description",
            "",
            "    #",
            "    #   'IMutableMinimalDublinCore' interface methods",
            "    #",
            "    @security.protected(View)",
            "    def Title(self):",
            "        \"\"\" Dublin Core Title element - resource name.",
            "        \"\"\"",
            "        return self.title",
            "",
            "    @security.protected(View)",
            "    def Description(self):",
            "        \"\"\" Dublin Core Description element - resource summary.",
            "        \"\"\"",
            "        return self.description",
            "",
            "    @security.protected(View)",
            "    def Type(self):",
            "        \"\"\" Dublin Core Type element - resource type.",
            "        \"\"\"",
            "        ti = self.getTypeInfo()",
            "        return ti is not None and ti.Title() or 'Unknown'",
            "",
            "    @security.protected(ManageProperties)",
            "    def setTitle(self, title):",
            "        \"\"\" Set Dublin Core Title element - resource name.",
            "        \"\"\"",
            "        self.title = title",
            "",
            "    @security.protected(ManageProperties)",
            "    def setDescription(self, description):",
            "        \"\"\" Set Dublin Core Description element - resource summary.",
            "        \"\"\"",
            "        self.description = description",
            "",
            "    #",
            "    #   other methods",
            "    #",
            "    @security.protected(ManageProperties)",
            "    def edit(self, title='', description=''):",
            "        \"\"\"",
            "        Edit the folder title (and possibly other attributes later)",
            "        \"\"\"",
            "        self.setTitle(title)",
            "        self.setDescription(description)",
            "        # BBB: for ICatalogAware subclasses",
            "        if getattr(self, 'reindexObject', None) is not None:",
            "            self.reindexObject()",
            "",
            "    @security.public",
            "    def allowedContentTypes(self):",
            "        \"\"\"",
            "            List type info objects for types which can be added in",
            "            this folder.",
            "        \"\"\"",
            "        ttool = getUtility(ITypesTool)",
            "        myType = ttool.getTypeInfo(self)",
            "        result = ttool.listTypeInfo()",
            "",
            "        if myType is not None:",
            "            return [t for t in result if myType.allowType(t.getId()) and",
            "                    t.isConstructionAllowed(self)]",
            "",
            "        return [t for t in result if t.isConstructionAllowed(self)]",
            "",
            "    def _filteredItems(self, ids, filt):",
            "        \"\"\"",
            "            Apply filter, a mapping, to child objects indicated by 'ids',",
            "            returning a sequence of (id, obj) tuples.",
            "        \"\"\"",
            "        # Restrict allowed content types",
            "        if filt is None:",
            "            filt = {}",
            "        else:",
            "            # We'll modify it, work on a copy.",
            "            filt = filt.copy()",
            "        pt = filt.get('portal_type', [])",
            "        if isinstance(pt, str):",
            "            pt = [pt]",
            "        ttool = getUtility(ITypesTool)",
            "        allowed_types = ttool.listContentTypes()",
            "        if not pt:",
            "            pt = allowed_types",
            "        else:",
            "            pt = [t for t in pt if t in allowed_types]",
            "        if not pt:",
            "            # After filtering, no types remain, so nothing should be",
            "            # returned.",
            "            return []",
            "        filt['portal_type'] = pt",
            "",
            "        query = ContentFilter(**filt)",
            "        result = []",
            "        append = result.append",
            "        get = self._getOb",
            "        for id in ids:",
            "            obj = get(id)",
            "            if query(obj):",
            "                append((id, obj))",
            "        return result",
            "",
            "    #",
            "    #   'IFolderish' interface methods",
            "    #",
            "    @security.public",
            "    def contentItems(self, filter=None):",
            "        # List contentish and folderish sub-objects and their IDs.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        ids = self.objectIds()",
            "        return self._filteredItems(ids, filter)",
            "",
            "    @security.public",
            "    def contentIds(self, filter=None):",
            "        # List IDs of contentish and folderish sub-objects.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        return [item[0] for item in self.contentItems(filter)]",
            "",
            "    @security.public",
            "    def contentValues(self, filter=None):",
            "        # List contentish and folderish sub-objects.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        return [item[1] for item in self.contentItems(filter)]",
            "",
            "    @security.protected(ListFolderContents)",
            "    def listFolderContents(self, contentFilter=None):",
            "        \"\"\" List viewable contentish and folderish sub-objects.",
            "        \"\"\"",
            "        fc_list = []",
            "        for id, obj in self.contentItems(contentFilter):",
            "            # validate() can either raise Unauthorized or return 0 to",
            "            # mean unauthorized.",
            "            try:",
            "                if getSecurityManager().validate(self, self, id, obj):",
            "                    fc_list.append(obj)",
            "            except zExceptions_Unauthorized:  # Catch *all* Unauths!",
            "                pass",
            "        return fc_list",
            "",
            "    #",
            "    #   webdav Resource method",
            "    #",
            "",
            "    # protected by 'WebDAV access'",
            "    def listDAVObjects(self):",
            "        # List sub-objects for PROPFIND requests.",
            "        # (method is without docstring to disable publishing)",
            "        #",
            "        if _checkPermission(ManagePortal, self):",
            "            return self.objectValues()",
            "        else:",
            "            return self.listFolderContents()",
            "",
            "    #",
            "    #   other methods",
            "    #",
            "    @security.public",
            "    def encodeFolderFilter(self, REQUEST):",
            "        \"\"\"",
            "            Parse cookie string for using variables in dtml.",
            "        \"\"\"",
            "        folder_filter = {}",
            "        for key, value in REQUEST.items():",
            "            if key[:10] == 'filter_by_':",
            "                folder_filter[key[10:]] = value",
            "        encoded = base64_encode(json.dumps(folder_filter).encode())",
            "        encoded = b''.join(encoded.split(b'\\n'))",
            "        return encoded",
            "",
            "    @security.public",
            "    def decodeFolderFilter(self, encoded):",
            "        \"\"\" Parse cookie string for using variables in dtml.",
            "",
            "        This is a public method and the input is not under our control.",
            "        To prevent a DOS this method will refuse to decode data that seems",
            "        conspicuously large.",
            "        \"\"\"",
            "        folder_filter = {}",
            "        if encoded and len(encoded) < 1000:",
            "            folder_filter.update(json.loads(base64_decode(encoded)))",
            "        return folder_filter",
            "",
            "    def content_type(self):",
            "        \"\"\"",
            "            WebDAV needs this to do the Right Thing (TM).",
            "        \"\"\"",
            "        return None",
            "",
            "    def PUT_factory(self, name, typ, body):",
            "        \"\"\" Factory for PUT requests to objects which do not yet exist.",
            "",
            "        Used by NullResource.PUT.",
            "",
            "        Returns -- Bare and empty object of the appropriate type (or None, if",
            "        we don't know what to do)",
            "        \"\"\"",
            "        ctr = queryUtility(IContentTypeRegistry)",
            "        if ctr is None:",
            "            return None",
            "",
            "        typeObjectName = ctr.findTypeName(name, typ, body)",
            "        if typeObjectName is None:",
            "            return None",
            "",
            "        self.invokeFactory(typeObjectName, name)",
            "",
            "        # invokeFactory does too much, so the object has to be removed again",
            "        obj = aq_base(self._getOb(name))",
            "        self._delObject(name)",
            "        return obj",
            "",
            "    @security.protected(AddPortalContent)",
            "    def invokeFactory(self, type_name, id, RESPONSE=None, *args, **kw):",
            "        \"\"\" Invokes the portal_types tool.",
            "        \"\"\"",
            "        ttool = getUtility(ITypesTool)",
            "        myType = ttool.getTypeInfo(self)",
            "",
            "        if myType is not None:",
            "            if not myType.allowType(type_name):",
            "                raise ValueError('Disallowed subobject type: %s' % type_name)",
            "",
            "        return ttool.constructContent(type_name, self, id, RESPONSE,",
            "                                      *args, **kw)",
            "",
            "    @security.protected(AddPortalContent)",
            "    def checkIdAvailable(self, id):",
            "        try:",
            "            self._checkId(id)",
            "        except BadRequest:",
            "            return False",
            "        else:",
            "            return True",
            "",
            "    def MKCOL_handler(self, id, REQUEST=None, RESPONSE=None):",
            "        \"\"\"",
            "            Handle WebDAV MKCOL.",
            "        \"\"\"",
            "        self.manage_addFolder(id=id, title='')",
            "",
            "    def _checkId(self, id, allow_dup=0):",
            "        PortalFolderBase.inheritedAttribute('_checkId')(self, id, allow_dup)",
            "",
            "        if allow_dup:",
            "            return",
            "",
            "        # FIXME: needed to allow index_html for join code",
            "        if id == 'index_html':",
            "            return",
            "",
            "        # Another exception: Must allow \"syndication_information\" to enable",
            "        # Syndication...",
            "        if id == 'syndication_information':",
            "            return",
            "",
            "        # IDs starting with '@@' are reserved for views.",
            "        if id[:2] == '@@':",
            "            raise BadRequest('The id \"%s\" is invalid because it begins with '",
            "                             '\"@@\".' % id)",
            "",
            "        # This code prevents people other than the portal manager from",
            "        # overriding skinned names and tools.",
            "        if not getSecurityManager().checkPermission(ManagePortal, self):",
            "            ob = aq_inner(self)",
            "            while ob is not None:",
            "                if ISiteRoot.providedBy(ob):",
            "                    break",
            "                ob = aq_parent(ob)",
            "",
            "            if ob is not None:",
            "                # If the portal root has a non-contentish object by this name,",
            "                # don't allow an override.",
            "                if hasattr(ob, id) and \\",
            "                   id not in ob.contentIds() and \\",
            "                   not id.startswith('.'):",
            "                    raise BadRequest('The id \"%s\" is reserved.' % id)",
            "            # Don't allow ids used by Method Aliases.",
            "            ti = self.getTypeInfo()",
            "            if ti and ti.queryMethodID(id, context=self):",
            "                raise BadRequest('The id \"%s\" is reserved.' % id)",
            "        # Otherwise we're ok.",
            "",
            "    def _verifyObjectPaste(self, object, validate_src=1):",
            "        # This assists the version in OFS.CopySupport.",
            "        # It enables the clipboard to function correctly",
            "        # with objects created by a multi-factory.",
            "        mt = getattr(object, '__factory_meta_type__', None)",
            "        meta_types = getattr(self, 'all_meta_types', None)",
            "",
            "        if mt is not None and meta_types is not None:",
            "            mt_permission = None",
            "",
            "            if callable(meta_types):",
            "                meta_types = meta_types()",
            "",
            "            for d in meta_types:",
            "                if d['name'] == mt:",
            "                    mt_permission = d.get('permission')",
            "                    break",
            "",
            "            if mt_permission is not None:",
            "                sm = getSecurityManager()",
            "",
            "                if sm.checkPermission(mt_permission, self):",
            "                    if validate_src:",
            "                        # Ensure the user is allowed to access the object on",
            "                        # the clipboard.",
            "                        parent = aq_parent(aq_inner(object))",
            "",
            "                        if not sm.validate(None, parent, None, object):",
            "                            raise AccessControl_Unauthorized(object.getId())",
            "",
            "                        if validate_src == 2:  # moving",
            "                            if not sm.checkPermission(DeleteObjects, parent):",
            "                                raise AccessControl_Unauthorized('Delete not '",
            "                                                                 'allowed.')",
            "                else:",
            "                    raise AccessControl_Unauthorized(",
            "                            'You do not possess the '",
            "                            '%r permission in the context of the container '",
            "                            'into which you are pasting, thus you are not '",
            "                            'able to perform this operation.' % mt_permission)",
            "            else:",
            "                raise AccessControl_Unauthorized(",
            "                        'The object %r does not '",
            "                        'support this operation.' % object.getId())",
            "        else:",
            "            # Call OFS' _verifyObjectPaste if necessary",
            "            PortalFolderBase.inheritedAttribute(",
            "                '_verifyObjectPaste')(self, object, validate_src)",
            "",
            "        # Finally, check allowed content types",
            "        if hasattr(aq_base(object), 'getPortalTypeName'):",
            "",
            "            type_name = object.getPortalTypeName()",
            "",
            "            if type_name is not None:",
            "",
            "                ttool = getUtility(ITypesTool)",
            "                myType = ttool.getTypeInfo(self)",
            "",
            "                if myType is not None and not myType.allowType(type_name):",
            "                    raise ValueError('Disallowed subobject type: %s' %",
            "                                     type_name)",
            "",
            "                # Check for workflow guards",
            "                objType = ttool.getTypeInfo(type_name)",
            "                if objType is not None and \\",
            "                   not objType._checkWorkflowAllowed(self):",
            "                    raise ValueError('Pasting not allowed in this workflow')",
            "",
            "    security.setPermissionDefault(AddPortalContent, ('Owner', 'Manager'))",
            "",
            "    @security.protected(AddPortalFolders)",
            "    def manage_addFolder(self, id, title='', REQUEST=None):",
            "        \"\"\" Add a new folder-like object with id *id*.",
            "",
            "        IF present, use the parent object's 'mkdir' alias; otherwise, just add",
            "        a PortalFolder.",
            "        \"\"\"",
            "        ti = self.getTypeInfo()",
            "        method_id = ti and ti.queryMethodID('mkdir', context=self)",
            "        if method_id:",
            "            # call it",
            "            getattr(self, method_id)(id=id)",
            "        else:",
            "            self.invokeFactory(type_name='Folder', id=id)",
            "",
            "        ob = self._getOb(id)",
            "        ob.setTitle(title)",
            "        try:",
            "            ob.reindexObject()",
            "        except AttributeError:",
            "            pass",
            "",
            "        if REQUEST is not None:",
            "            return self.manage_main(self, REQUEST, update_menu=1)",
            "",
            "",
            "InitializeClass(PortalFolderBase)",
            "",
            "",
            "class PortalFolder(OrderSupport, PortalFolderBase):",
            "",
            "    \"\"\"Implements portal content management, but not UI details.",
            "    \"\"\"",
            "",
            "    portal_type = 'Folder'",
            "",
            "    security = ClassSecurityInfo()",
            "",
            "    manage_options = (OrderSupport.manage_options +",
            "                      PortalFolderBase.manage_options[1:])",
            "",
            "    @security.protected(AddPortalFolders)",
            "    def manage_addPortalFolder(self, id, title='', REQUEST=None):",
            "        \"\"\"Add a new PortalFolder object with id *id*.",
            "        \"\"\"",
            "        ob = PortalFolder(id, title)",
            "        self._setObject(id, ob, suppress_events=True)",
            "        if REQUEST is not None:",
            "            return self.folder_contents(  # XXX: ick!",
            "                self, REQUEST, portal_status_message='Folder added')",
            "",
            "",
            "InitializeClass(PortalFolder)",
            "",
            "PortalFolderFactory = Factory(PortalFolder)",
            "",
            "manage_addPortalFolder = PortalFolder.manage_addPortalFolder",
            "",
            "",
            "class ContentFilter:",
            "",
            "    \"\"\"Represent a predicate against a content object's metadata.",
            "    \"\"\"",
            "",
            "    MARKER = []",
            "    filterSubject = []",
            "",
            "    def __init__(self, Title=MARKER, Creator=MARKER, Subject=MARKER,",
            "                 Description=MARKER, created=MARKER, created_usage='range:min',",
            "                 modified=MARKER, modified_usage='range:min', Type=MARKER,",
            "                 portal_type=MARKER, **Ignored):",
            "",
            "        self.predicates = []",
            "        self.description = []",
            "",
            "        if Title is not self.MARKER:",
            "            self.predicates.append(lambda x, pat=re.compile(Title):",
            "                                   pat.search(x.Title()))",
            "            self.description.append('Title: %s' % Title)",
            "",
            "        if Creator and Creator is not self.MARKER:",
            "            self.predicates.append(lambda x, creator=Creator:",
            "                                   creator in x.listCreators())",
            "            self.description.append('Creator: %s' % Creator)",
            "",
            "        if Subject and Subject is not self.MARKER:",
            "            self.filterSubject = Subject",
            "            self.predicates.append(self.hasSubject)",
            "            self.description.append('Subject: %s' % ', '.join(Subject))",
            "",
            "        if Description is not self.MARKER:",
            "            self.predicates.append(lambda x, pat=re.compile(Description):",
            "                                   pat.search(x.Description()))",
            "            self.description.append('Description: %s' % Description)",
            "",
            "        if created is not self.MARKER:",
            "            if created_usage == 'range:min':",
            "                self.predicates.append(lambda x, cd=created:",
            "                                       cd <= x.created())",
            "                self.description.append('Created since: %s' % created)",
            "            if created_usage == 'range:max':",
            "                self.predicates.append(lambda x, cd=created:",
            "                                       cd >= x.created())",
            "                self.description.append('Created before: %s' % created)",
            "",
            "        if modified is not self.MARKER:",
            "            if modified_usage == 'range:min':",
            "                self.predicates.append(lambda x, md=modified:",
            "                                       md <= x.modified())",
            "                self.description.append('Modified since: %s' % modified)",
            "            if modified_usage == 'range:max':",
            "                self.predicates.append(lambda x, md=modified:",
            "                                       md >= x.modified())",
            "                self.description.append('Modified before: %s' % modified)",
            "",
            "        if Type:",
            "            if isinstance(Type, str):",
            "                Type = [Type]",
            "            self.predicates.append(lambda x, Type=Type: x.Type() in Type)",
            "            self.description.append('Type: %s' % ', '.join(Type))",
            "",
            "        if portal_type and portal_type is not self.MARKER:",
            "            if isinstance(portal_type, str):",
            "                portal_type = [portal_type]",
            "            self.predicates.append(lambda x, pt=portal_type:",
            "                                   hasattr(aq_base(x), 'getPortalTypeName')",
            "                                   and x.getPortalTypeName() in pt)",
            "            self.description.append('Portal Type: %s' % ', '.join(portal_type))",
            "",
            "    def hasSubject(self, obj):",
            "        \"\"\"",
            "        Converts Subject string into a List for content filter view.",
            "        \"\"\"",
            "        for sub in obj.Subject():",
            "            if sub in self.filterSubject:",
            "                return 1",
            "        return 0",
            "",
            "    def __call__(self, content):",
            "",
            "        for predicate in self.predicates:",
            "",
            "            try:",
            "                if not predicate(content):",
            "                    return 0",
            "            except (AttributeError, KeyError, IndexError, ValueError):",
            "                # predicates are *not* allowed to throw exceptions",
            "                return 0",
            "",
            "        return 1",
            "",
            "    def __str__(self):",
            "        \"\"\"",
            "            Return a stringified description of the filter.",
            "        \"\"\"",
            "        return '; '.join(self.description)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "238": [
                "PortalFolderBase",
                "encodeFolderFilter"
            ],
            "241": [
                "PortalFolderBase",
                "encodeFolderFilter"
            ],
            "242": [
                "PortalFolderBase",
                "encodeFolderFilter"
            ],
            "243": [
                "PortalFolderBase",
                "encodeFolderFilter"
            ],
            "249": [
                "PortalFolderBase",
                "decodeFolderFilter"
            ],
            "250": [
                "PortalFolderBase",
                "decodeFolderFilter"
            ],
            "251": [
                "PortalFolderBase",
                "decodeFolderFilter"
            ],
            "252": [
                "PortalFolderBase",
                "decodeFolderFilter"
            ],
            "253": [
                "PortalFolderBase",
                "decodeFolderFilter"
            ],
            "254": [
                "PortalFolderBase",
                "decodeFolderFilter"
            ]
        },
        "addLocation": []
    },
    "src/Products/CMFCore/tests/test_PortalFolder.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "         verifyClass(IOrderedContainer, self._getTargetClass())"
            },
            "2": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    def test_FolderFilter(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        folder = self._getTargetClass()('test_id')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        # No filter"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        request = {}"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        encoded_filter = folder.encodeFolderFilter(request)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        self.assertEqual(folder.decodeFolderFilter(encoded_filter), {})"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        # Simple filter"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        request = {'filter_by_id': 'foobar'}"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        encoded_filter = folder.encodeFolderFilter(request)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        self.assertEqual(folder.decodeFolderFilter(encoded_filter),"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                         {'id': 'foobar'})"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        # Multiple filters"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        request = {'filter_by_id': 'foobar',"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+                   'filter_by_title': 'baz'}"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        encoded_filter = folder.encodeFolderFilter(request)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        self.assertEqual(folder.decodeFolderFilter(encoded_filter),"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+                         {'id': 'foobar', 'title': 'baz'})"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        # Non-filter request values are ignored"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        request = {'filter_by_id': 'foobar', 'somekey': 'somevalue'}"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        encoded_filter = folder.encodeFolderFilter(request)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        self.assertEqual(folder.decodeFolderFilter(encoded_filter),"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                         {'id': 'foobar'})"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        # Conspicuously large input values to the decode operation"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        # are ignored to prevent a DOS"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        encoded_filter = 'x' * 2000"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        self.assertEqual(folder.decodeFolderFilter(encoded_filter), {})"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 190,
                "PatchRowcode": " class PortalFolderSecurityTests(SecurityTest):"
            },
            "37": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\" Unit tests for PortalFolder module.",
            "\"\"\"",
            "",
            "import unittest",
            "",
            "import transaction",
            "from AccessControl import SecurityManager",
            "from AccessControl import Unauthorized",
            "from AccessControl.SecurityManagement import newSecurityManager",
            "from Acquisition import Implicit",
            "from Acquisition import aq_base",
            "from DateTime import DateTime",
            "from OFS.Image import manage_addFile",
            "from zope.component import getSiteManager",
            "from zope.component.interfaces import IFactory",
            "from zope.interface import implementer",
            "from zope.interface.verify import verifyClass",
            "",
            "from ..exceptions import BadRequest",
            "from ..interfaces import ICatalogTool",
            "from ..interfaces import ITypesTool",
            "from ..interfaces import IWorkflowTool",
            "from ..testing import ConformsToFolder",
            "from ..testing import TraversingEventZCMLLayer",
            "from ..TypesTool import FactoryTypeInformation as FTI",
            "from ..TypesTool import TypesTool",
            "from ..WorkflowTool import WorkflowTool",
            "from .base.dummy import DummyContent",
            "from .base.dummy import DummyFactoryDispatcher",
            "from .base.dummy import DummySite",
            "from .base.dummy import DummyUserFolder",
            "from .base.testcase import SecurityTest",
            "from .base.tidata import FTIDATA_CMF",
            "from .base.tidata import FTIDATA_DUMMY",
            "",
            "",
            "def extra_meta_types():",
            "    return [{'name': 'Dummy', 'action': 'manage_addFolder',",
            "             'permission': 'View'}]",
            "",
            "",
            "@implementer(ICatalogTool)",
            "class DummyCatalogTool:",
            "",
            "    def __init__(self):",
            "        self.paths = []",
            "        self.ids = []",
            "",
            "    def indexObject(self, object):",
            "        self.paths.append('/'.join(object.getPhysicalPath()))",
            "        self.ids.append(object.getId())",
            "",
            "    def unindexObject(self, object):",
            "        self.paths.remove('/'.join(object.getPhysicalPath()))",
            "        self.ids.append(object.getId())",
            "",
            "    def reindexObject(self, object):",
            "        pass",
            "",
            "    def __len__(self):",
            "        return len(self.paths)",
            "",
            "",
            "def has_path(catalog, path):",
            "    if isinstance(path, tuple):",
            "        path = '/'.join(path)",
            "    return path in catalog.paths",
            "",
            "",
            "def has_id(catalog, id):",
            "    return id in catalog.ids",
            "",
            "",
            "class PortalFolderFactoryTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "    _PORTAL_TYPE = 'Test Folder'",
            "",
            "    def _getTargetObject(self):",
            "        from ..PortalFolder import PortalFolderFactory",
            "",
            "        return PortalFolderFactory",
            "",
            "    def setUp(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        SecurityTest.setUp(self)",
            "        self.site = DummySite('site').__of__(self.app)",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "",
            "        self.ttool = ttool = TypesTool()",
            "        ttool._setObject(self._PORTAL_TYPE,",
            "                         FTI(id=self._PORTAL_TYPE,",
            "                             title='Folder or Directory',",
            "                             meta_type=PortalFolder.meta_type,",
            "                             factory='cmf.folder',",
            "                             filter_content_types=0))",
            "        ttool._setObject('Dummy Content', FTI(**FTIDATA_DUMMY[0].copy()))",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ttool, ITypesTool)",
            "        sm.registerUtility(self._getTargetObject(), IFactory, 'cmf.folder')",
            "",
            "        self.f = self.site._setObject('container', PortalFolder('container'))",
            "        self.f._setPortalTypeName(self._PORTAL_TYPE)",
            "",
            "    def test_invokeFactory(self):",
            "        f = self.f",
            "        self.assertFalse('foo' in f.objectIds())",
            "",
            "        f.manage_addProduct = {'FooProduct': DummyFactoryDispatcher(f)}",
            "        f.invokeFactory(type_name='Dummy Content', id='foo')",
            "",
            "        self.assertTrue('foo' in f.objectIds())",
            "        foo = f.foo",
            "        self.assertEqual(foo.getId(), 'foo')",
            "        self.assertEqual(foo.getPortalTypeName(), 'Dummy Content')",
            "        self.assertEqual(foo.Type(), 'Dummy Content Title')",
            "",
            "    def test_invokeFactory_disallowed_type(self):",
            "        f = self.f",
            "        ftype = getattr(self.ttool, self._PORTAL_TYPE)",
            "        ftype.filter_content_types = 1",
            "        self.assertRaises(ValueError,",
            "                          f.invokeFactory, self._PORTAL_TYPE, 'sub')",
            "",
            "        ftype.allowed_content_types = (self._PORTAL_TYPE,)",
            "        f.invokeFactory(self._PORTAL_TYPE, id='sub')",
            "        self.assertTrue('sub' in f.objectIds())",
            "        self.assertRaises(ValueError, f.invokeFactory, 'Dummy Content', 'foo')",
            "",
            "",
            "class PortalFolderTests(ConformsToFolder, unittest.TestCase):",
            "",
            "    def _getTargetClass(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        return PortalFolder",
            "",
            "    def test_interfaces(self):",
            "        from OFS.interfaces import IOrderedContainer",
            "",
            "        verifyClass(IOrderedContainer, self._getTargetClass())",
            "",
            "",
            "class PortalFolderSecurityTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "",
            "    def _getTargetClass(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        return PortalFolder",
            "",
            "    def _makeOne(self, id, *args, **kw):",
            "        return self.site._setObject(id,",
            "                                    self._getTargetClass()(id, *args, **kw))",
            "",
            "    def setUp(self):",
            "        SecurityTest.setUp(self)",
            "        self.site = DummySite('site').__of__(self.app)",
            "",
            "    def test_contents_methods(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "",
            "        ttool = TypesTool()",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        f = self._makeOne('foo')",
            "        self.assertEqual(f.objectValues(), [])",
            "        self.assertEqual(f.contentIds(), [])",
            "        self.assertEqual(f.contentItems(), [])",
            "        self.assertEqual(f.contentValues(), [])",
            "        self.assertEqual(f.listFolderContents(), [])",
            "        self.assertEqual(f.listDAVObjects(), [])",
            "",
            "        f._setObject('sub1', DummyContent('sub1'))",
            "        self.assertEqual(f.objectValues(), [f.sub1])",
            "        self.assertEqual(f.contentIds(), [])",
            "        self.assertEqual(f.contentItems(), [])",
            "        self.assertEqual(f.contentValues(), [])",
            "        self.assertEqual(f.listFolderContents(), [])",
            "        self.assertEqual(f.listDAVObjects(), [f.sub1])",
            "",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        self.assertEqual(f.objectValues(), [f.sub1])",
            "        self.assertEqual(f.contentIds(), ['sub1'])",
            "        self.assertEqual(f.contentItems(), [('sub1', f.sub1)])",
            "        self.assertEqual(f.contentValues(), [f.sub1])",
            "        self.assertEqual(f.listFolderContents(), [f.sub1])",
            "        self.assertEqual(f.listDAVObjects(), [f.sub1])",
            "",
            "        f._setObject('hidden_sub2', DummyContent('hidden_sub2'))",
            "        self.assertEqual(f.objectValues(), [f.sub1, f.hidden_sub2])",
            "        self.assertEqual(f.contentIds(), ['sub1', 'hidden_sub2'])",
            "        self.assertEqual(f.contentItems(), [('sub1', f.sub1),",
            "                                            ('hidden_sub2', f.hidden_sub2)])",
            "        self.assertEqual(f.contentValues(), [f.sub1, f.hidden_sub2])",
            "        self.assertEqual(f.listFolderContents(), [f.sub1])",
            "        self.assertEqual(f.listDAVObjects(), [f.sub1, f.hidden_sub2])",
            "",
            "    def test_deletePropagation(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        foo = DummyContent('foo')",
            "        foo.reset()",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "",
            "        test._setObject('foo', foo)",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "",
            "        foo.reset()",
            "        test._delObject('foo')",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "",
            "        foo.reset()",
            "        test._setObject('foo', foo)",
            "        test._delOb('foo')    # doesn't propagate",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "",
            "    def test_manageDelObjects(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        foo = DummyContent('foo')",
            "",
            "        test._setObject('foo', foo)",
            "        foo.reset()",
            "        test.manage_delObjects(ids=['foo'])",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "",
            "    def test_catalogUnindexAndIndex(self):",
            "        #",
            "        # Test is a new object does get cataloged upon _setObject",
            "        # and uncataloged upon manage_deleteObjects",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        ctool = DummyCatalogTool()",
            "        self.assertEqual(len(ctool), 0)",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        sm.registerUtility(TypesTool(), ITypesTool)",
            "",
            "        test._setObject('foo', DummyContent('foo', catalog=1))",
            "        foo = test.foo",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 1)",
            "",
            "        foo.reset()",
            "        test._delObject('foo')",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "    def test_portalfolder_cataloging(self):",
            "        #",
            "        # Test to ensure a portal folder itself is *not* cataloged upon",
            "        # instantiation (Tracker issue 309)",
            "        #",
            "        ctool = DummyCatalogTool()",
            "        wtool = WorkflowTool()",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        sm.registerUtility(wtool, IWorkflowTool)",
            "",
            "        test = self._makeOne('test')",
            "        wtool.notifyCreated(test)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "    def test_tracker261(self):",
            "        #",
            "        #   Tracker issue #261 says that content in a deleted folder",
            "        #   is not being uncatalogued.  Try creating a subfolder with",
            "        #   content object, and test.",
            "        #",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        ctool = DummyCatalogTool()",
            "        getSiteManager().registerUtility(ctool, ICatalogTool)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "        test._setObject('sub', PortalFolder('sub', ''))",
            "        sub = test.sub",
            "",
            "        sub._setObject('foo', DummyContent('foo', catalog=1))",
            "        foo = sub.foo",
            "",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 1)",
            "",
            "        foo.reset()",
            "        test._delObject('sub')",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "    def test_manageAddFolder(self):",
            "        #",
            "        #   Does MKDIR/MKCOL intercept work?",
            "        #",
            "        from ..PortalFolder import PortalFolder",
            "        from ..PortalFolder import PortalFolderFactory",
            "",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject('Folder',",
            "                         FTI(id='Folder',",
            "                             title='Folder or Directory',",
            "                             meta_type=PortalFolder.meta_type,",
            "                             factory='cmf.folder',",
            "                             filter_content_types=0))",
            "        ttool._setObject('Grabbed',",
            "                         FTI('Grabbed',",
            "                             title='Grabbed Content',",
            "                             meta_type=PortalFolder.meta_type,",
            "                             factory='cmf.folder'))",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ttool, ITypesTool)",
            "        sm.registerUtility(PortalFolderFactory, IFactory, 'cmf.folder')",
            "",
            "        # First, test default behavior",
            "        test.manage_addFolder(id='simple', title='Simple')",
            "        self.assertEqual(test.simple.getPortalTypeName(), 'Folder')",
            "        self.assertEqual(test.simple.Type(), 'Folder or Directory')",
            "        self.assertEqual(test.simple.getId(), 'simple')",
            "        self.assertEqual(test.simple.Title(), 'Simple')",
            "",
            "        # Now, test overridden behavior",
            "        ttool.Folder.setMethodAliases({'mkdir': 'grabbed'})",
            "",
            "        class Grabbed:",
            "",
            "            _grabbed_with = None",
            "",
            "            def __init__(self, context):",
            "                self._context = context",
            "",
            "            def __call__(self, id):",
            "                self._grabbed_with = id",
            "                self._context._setOb(id, PortalFolder(id))",
            "                self._context._getOb(id)._setPortalTypeName('Grabbed')",
            "",
            "        self.app.grabbed = Grabbed(test)",
            "",
            "        test.manage_addFolder(id='indirect', title='Indirect')",
            "        self.assertEqual(test.indirect.getPortalTypeName(), 'Grabbed')",
            "        self.assertEqual(test.indirect.Type(), 'Grabbed Content')",
            "        self.assertEqual(test.indirect.getId(), 'indirect')",
            "        self.assertEqual(test.indirect.Title(), 'Indirect')",
            "",
            "    def test_contentPasteAllowedTypes(self):",
            "        #",
            "        #   _verifyObjectPaste() should honor allowed content types",
            "        #",
            "        ttool = TypesTool()",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        ttool._setObject('Folder', FTI(**fti))",
            "        sub1 = self._makeOne('sub1')",
            "        sub1._setObject('dummy', DummyContent('dummy'))",
            "        sub2 = self._makeOne('sub2')",
            "        sub2.all_meta_types = extra_meta_types()",
            "",
            "        # Allow adding of Dummy Content",
            "        ttool.Folder.manage_changeProperties(filter_content_types=False)",
            "",
            "        # Copy/paste should work fine",
            "        cookie = sub1.manage_copyObjects(ids=['dummy'])",
            "        sub2.manage_pasteObjects(cookie)",
            "",
            "        # Disallow adding of Dummy Content",
            "        ttool.Folder.manage_changeProperties(filter_content_types=True)",
            "",
            "        # Now copy/paste should raise a ValueError",
            "        cookie = sub1.manage_copyObjects(ids=('dummy',))",
            "        self.assertRaises(ValueError, sub2.manage_pasteObjects, cookie)",
            "",
            "    def test_contentPasteFollowsWorkflowGuards(self):",
            "        #",
            "        # Copy/Paste should obey workflow guards",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        ttool = TypesTool()",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        ttool._setObject('Folder', FTI(**fti))",
            "        folder = self._makeOne('folder', 'Folder')",
            "        content = self._makeOne('content')",
            "        folder._setObject('content', content)",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ttool, ITypesTool)",
            "",
            "        # Allow adding of Dummy Content",
            "        ttool.Folder.manage_changeProperties(filter_content_types=False)",
            "",
            "        # Copy/paste verification should work fine",
            "        folder._verifyObjectPaste(content)",
            "",
            "        # Add a workflow with a blocking guard",
            "        # Based on TypesTools tests",
            "        class DummyWorkflow:",
            "",
            "            _allow = False",
            "",
            "            def allowCreate(self, container, type_id):",
            "                return self._allow",
            "",
            "        class DummyWorkflowTool:",
            "",
            "            def __init__(self):",
            "                self._workflows = [DummyWorkflow()]",
            "",
            "            def getWorkflowsFor(self, type_id):",
            "                return self._workflows",
            "",
            "        # Now copy/paste verification should raise a ValueError",
            "        sm.registerUtility(DummyWorkflowTool(), IWorkflowTool)",
            "        self.assertRaises(ValueError, folder._verifyObjectPaste, content)",
            "",
            "    def test_setObjectRaisesBadRequest(self):",
            "        #",
            "        #   _setObject() should raise BadRequest on duplicate id",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setObject('foo', DummyContent('foo'))",
            "        self.assertRaises(BadRequest, test._setObject, 'foo',",
            "                          DummyContent('foo'))",
            "",
            "    def test__checkId_Duplicate(self):",
            "        #",
            "        #   _checkId() should raise BadRequest on duplicate id",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setObject('foo', DummyContent('foo'))",
            "        self.assertRaises(BadRequest, test._checkId, 'foo')",
            "",
            "    def test__checkId_PortalRoot(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        test._checkId('acl_users')",
            "        newSecurityManager(None, acl_users.user_foo)",
            "        self.assertRaises(BadRequest, test._checkId, 'acl_users')",
            "",
            "    def test__checkId_MethodAlias(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setPortalTypeName('Dummy Content 15')",
            "        ttool = TypesTool()",
            "        ttool._setObject('Dummy Content 15', FTI(**FTIDATA_CMF[0]))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        test._checkId('view')",
            "        newSecurityManager(None, acl_users.user_foo)",
            "        self.assertRaises(BadRequest, test._checkId, 'view')",
            "",
            "    def test__checkId_starting_with_dot(self):",
            "        #",
            "        # doted prefixed names at the root of the portal can be overriden",
            "        #",
            "",
            "        # Create a .foo at the root",
            "        self.site._setObject('.foo', DummyContent('.foo'))",
            "",
            "        # Create a sub-folder",
            "        sub = self._makeOne('sub')",
            "",
            "        # It should be possible to create another .foo object in the",
            "        # sub-folder",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.user_foo)",
            "",
            "        self.assertTrue(sub.checkIdAvailable('.foo'))",
            "",
            "    def test__checkId_Five(self):",
            "        test = self._makeOne('test')",
            "        self.assertRaises(BadRequest, test._checkId, '@@view')",
            "",
            "    def test_checkIdAvailableCatchesBadRequest(self):",
            "        #",
            "        #   checkIdAvailable() should catch BadRequest",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setObject('foo', DummyContent('foo'))",
            "        self.assertFalse(test.checkIdAvailable('foo'))",
            "",
            "",
            "class PortalFolderMoveTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "",
            "    def setUp(self):",
            "        SecurityTest.setUp(self)",
            "        self.app._setObject('site', DummySite('site'))",
            "        self.site = self.app.site",
            "",
            "    def _makeOne(self, id, *args, **kw):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        return self.site._setObject(id, PortalFolder(id, *args, **kw))",
            "",
            "    def test_folderMove(self):",
            "        #",
            "        #   Does the catalog stay synched when folders are moved?",
            "        #",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        ctool = DummyCatalogTool()",
            "        sm = getSiteManager()",
            "        sm.registerUtility(TypesTool(), ITypesTool)",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "        folder = self._makeOne('folder')",
            "        folder._setObject('sub', PortalFolder('sub', ''))",
            "        folder.sub._setObject('foo', DummyContent('foo', catalog=1))",
            "        self.assertEqual(len(ctool), 1)",
            "        self.assertTrue(has_id(ctool, 'foo'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/sub/foo'))",
            "",
            "        transaction.savepoint(optimistic=True)",
            "        folder.manage_renameObject(id='sub', new_id='new_sub')",
            "        self.assertEqual(len(ctool), 1)",
            "        self.assertTrue(has_id(ctool, 'foo'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/new_sub/foo'))",
            "",
            "        folder._setObject('bar', DummyContent('bar', catalog=1))",
            "        self.assertEqual(len(ctool), 2)",
            "        self.assertTrue(has_id(ctool, 'bar'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/bar'))",
            "",
            "        folder._setObject('sub2', PortalFolder('sub2', ''))",
            "        sub2 = folder.sub2",
            "        # Waaa! force sub2 to allow paste of Dummy object.",
            "        sub2.all_meta_types = []",
            "        sub2.all_meta_types.extend(sub2.all_meta_types)",
            "        sub2.all_meta_types.extend(extra_meta_types())",
            "",
            "        transaction.savepoint(optimistic=True)",
            "        cookie = folder.manage_cutObjects(ids=['bar'])",
            "        sub2.manage_pasteObjects(cookie)",
            "",
            "        self.assertTrue(has_id(ctool, 'foo'))",
            "        self.assertTrue(has_id(ctool, 'bar'))",
            "        self.assertEqual(len(ctool), 2)",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/sub2/bar'))",
            "",
            "    def test_contentPaste(self):",
            "        #",
            "        #   Does copy / paste work?",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        ctool = DummyCatalogTool()",
            "        ttool = TypesTool()",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        sub1 = self._makeOne('sub1')",
            "        sub2 = self._makeOne('sub2')",
            "        sub3 = self._makeOne('sub3')",
            "        self.assertEqual(len(ctool), 0)",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        sm.registerUtility(ttool, ITypesTool)",
            "",
            "        sub1._setObject('dummy', DummyContent('dummy', catalog=1))",
            "        self.assertTrue('dummy' in sub1.objectIds())",
            "        self.assertTrue('dummy' in sub1.contentIds())",
            "        self.assertFalse('dummy' in sub2.objectIds())",
            "        self.assertFalse('dummy' in sub2.contentIds())",
            "        self.assertFalse('dummy' in sub3.objectIds())",
            "        self.assertFalse('dummy' in sub3.contentIds())",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub2/dummy'))",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))",
            "",
            "        cookie = sub1.manage_copyObjects(ids=('dummy',))",
            "        # Waaa! force sub2 to allow paste of Dummy object.",
            "        sub2.all_meta_types = []",
            "        sub2.all_meta_types.extend(sub2.all_meta_types)",
            "        sub2.all_meta_types.extend(extra_meta_types())",
            "        sub2.manage_pasteObjects(cookie)",
            "        self.assertTrue('dummy' in sub1.objectIds())",
            "        self.assertTrue('dummy' in sub1.contentIds())",
            "        self.assertTrue('dummy' in sub2.objectIds())",
            "        self.assertTrue('dummy' in sub2.contentIds())",
            "        self.assertFalse('dummy' in sub3.objectIds())",
            "        self.assertFalse('dummy' in sub3.contentIds())",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))",
            "",
            "        transaction.savepoint(optimistic=True)",
            "        cookie = sub1.manage_cutObjects(ids=('dummy',))",
            "        # Waaa! force sub2 to allow paste of Dummy object.",
            "        sub3.all_meta_types = []",
            "        sub3.all_meta_types.extend(sub3.all_meta_types)",
            "        sub3.all_meta_types.extend(extra_meta_types())",
            "        sub3.manage_pasteObjects(cookie)",
            "        self.assertFalse('dummy' in sub1.objectIds())",
            "        self.assertFalse('dummy' in sub1.contentIds())",
            "        self.assertTrue('dummy' in sub2.objectIds())",
            "        self.assertTrue('dummy' in sub2.contentIds())",
            "        self.assertTrue('dummy' in sub3.objectIds())",
            "        self.assertTrue('dummy' in sub3.contentIds())",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub1/dummy'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub3/dummy'))",
            "",
            "",
            "class ContentFilterTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.dummy = DummyContent('Dummy')",
            "",
            "    def test_empty(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter()",
            "        dummy = self.dummy",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = [_f for _f in desc.split('; ') if _f]",
            "        self.assertFalse(lines)",
            "",
            "    def test_Type(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Type='foo')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        cfilter = ContentFilter(Type='Dummy Content Title')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Type: Dummy Content Title')",
            "",
            "        cfilter = ContentFilter(Type=('foo', 'bar'))",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        cfilter = ContentFilter(Type=('Dummy Content Title', 'something else'))",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Type: Dummy Content Title, something else')",
            "",
            "    def test_portal_type(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(portal_type='some_pt')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'asdf'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'some_ptyyy'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'xxxsome_ptyyy'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'some_pt'",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Portal Type: some_pt')",
            "",
            "    def test_Title(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Title='foo')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.title = 'asdf'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.title = 'foolish'",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.title = 'ohsofoolish'",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Title: foo')",
            "",
            "    def test_Creator(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Creator='moe')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.creators = ('curly',)",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.creators = ('moe',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.creators = ('moe', 'curly')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Creator: moe')",
            "",
            "    def test_Description(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Description='funny')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.description = 'sad'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.description = 'funny'",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.description = 'it is funny you should mention it...'",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Description: funny')",
            "",
            "    def test_Subject(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Subject=('foo',))",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('bar',)",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('foo',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.subject = ('foo', 'bar')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Subject: foo')",
            "",
            "    def test_Subject2(self):",
            "        # Now test with mutli-valued",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Subject=('foo', 'bar'))",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('baz',)",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('bar',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.subject = ('foo',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.subject = ('foo', 'bar')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Subject: foo, bar')",
            "",
            "    def test_created(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(created=creation_date,",
            "                                created_usage='range:min')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Created since: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_created2(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(created=creation_date,",
            "                                created_usage='range:max')",
            "",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Created before: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_modified(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(modified=DateTime('2001/01/01'),",
            "                                modified_usage='range:min')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2000/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Modified since: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_modified2(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(modified=DateTime('2001/01/01'),",
            "                                modified_usage='range:max')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2000/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Modified before: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_mixed(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(created=DateTime('2001/01/01'),",
            "                                created_usage='range:max', Title='foo')",
            "",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertFalse(cfilter(dummy))",
            "",
            "        dummy.title = 'ohsofoolish'",
            "        del dummy.created_date",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 2)",
            "        self.assertTrue('Created before: 2001/01/01 00:00:00 %s' % tz in lines)",
            "        self.assertTrue('Title: foo' in lines)",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "#   Tests for security-related CopySupport lifted from the Zope 2.7",
            "#   / head OFS.tests.testCopySupport (see Collector #259).",
            "# -----------------------------------------------------------------------------",
            "ADD_IMAGES_AND_FILES = 'Add images and files'",
            "FILE_META_TYPES = ({'name': 'File',",
            "                    'action': 'manage_addFile',",
            "                    'permission': ADD_IMAGES_AND_FILES},)",
            "",
            "",
            "class _SensitiveSecurityPolicy:",
            "",
            "    def __init__(self, validate_lambda, checkPermission_lambda):",
            "        self._lambdas = (validate_lambda, checkPermission_lambda)",
            "",
            "    def validate(self, *args, **kw):",
            "        if self._lambdas[0](*args, **kw):",
            "            return True",
            "        raise Unauthorized",
            "",
            "    def checkPermission(self, *args, **kw):",
            "        return self._lambdas[1](*args, **kw)",
            "",
            "",
            "class _AllowedUser(Implicit):",
            "",
            "    def __init__(self, allowed_lambda):",
            "        self._lambdas = (allowed_lambda,)",
            "",
            "    def getId(self):",
            "        return 'unit_tester'",
            "",
            "    def getUserName(self):",
            "        return 'Unit Tester'",
            "",
            "    def allowed(self, object, object_roles=None):",
            "        return self._lambdas[0](object, object_roles)",
            "",
            "",
            "class PortalFolderCopySupportTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "",
            "    def _initFolders(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        self.app._setObject('folder1', PortalFolder('folder1'))",
            "        self.app._setObject('folder2', PortalFolder('folder2'))",
            "        folder1 = getattr(self.app, 'folder1')",
            "        manage_addFile(folder1, 'file', file='', content_type='text/plain')",
            "",
            "        # Hack, we need a _p_mtime for the file, so we make sure that it",
            "        # has one. We use a subtransaction, which means we can rollback",
            "        # later and pretend we didn't touch the ZODB.",
            "        transaction.savepoint(optimistic=True)",
            "        return self.app._getOb('folder1'), self.app._getOb('folder2')",
            "",
            "    def _assertCopyErrorUnauth(self, callable, *args, **kw):",
            "        import re",
            "",
            "        from OFS.CopySupport import CopyError",
            "",
            "        from ..exceptions import zExceptions_Unauthorized",
            "",
            "        ce_regex = kw.get('ce_regex')",
            "        if ce_regex is not None:",
            "            del kw['ce_regex']",
            "",
            "        try:",
            "            callable(*args, **kw)",
            "        except CopyError as e:",
            "            if ce_regex is not None:",
            "                pattern = re.compile(ce_regex, re.DOTALL)",
            "                if pattern.search(str(e)) is None:",
            "                    self.fail(\"Paste failed; didn't match pattern:\\n%s\" % e)",
            "            else:",
            "                self.fail('Paste failed; no pattern:\\n%s' % e)",
            "",
            "        except zExceptions_Unauthorized:",
            "            pass",
            "        else:",
            "            self.fail('Paste allowed unexpectedly.')",
            "",
            "    def _initPolicyAndUser(self, a_lambda=None, v_lambda=None, c_lambda=None):",
            "        def _promiscuous(*args, **kw):",
            "            return 1",
            "",
            "        if a_lambda is None:",
            "            a_lambda = _promiscuous",
            "",
            "        if v_lambda is None:",
            "            v_lambda = _promiscuous",
            "",
            "        if c_lambda is None:",
            "            c_lambda = _promiscuous",
            "",
            "        scp = _SensitiveSecurityPolicy(v_lambda, c_lambda)",
            "        SecurityManager.setSecurityPolicy(scp)",
            "",
            "        newSecurityManager(None,",
            "                           _AllowedUser(a_lambda).__of__(self.app.acl_users))",
            "",
            "    def test_copy_baseline(self):",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        self.assertTrue('file' in folder1.objectIds())",
            "        self.assertFalse('file' in folder2.objectIds())",
            "",
            "        cookie = folder1.manage_copyObjects(ids=('file',))",
            "        folder2.manage_pasteObjects(cookie)",
            "",
            "        self.assertTrue('file' in folder1.objectIds())",
            "        self.assertTrue('file' in folder2.objectIds())",
            "",
            "    def test_copy_cant_read_source(self):",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        a_file = folder1._getOb('file')",
            "",
            "        def _validate(a, c, n, v, *args, **kw):",
            "            return aq_base(v) is not aq_base(a_file)",
            "",
            "        self._initPolicyAndUser(v_lambda=_validate)",
            "",
            "        cookie = folder1.manage_copyObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects,",
            "                                    cookie,",
            "                                    ce_regex='Insufficient privileges')",
            "",
            "    def test_copy_cant_create_target_metatype_not_supported(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = ()",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        cookie = folder1.manage_copyObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Not Supported')",
            "",
            "    def test_move_baseline(self):",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        self.assertTrue('file' in folder1.objectIds())",
            "        self.assertFalse('file' in folder2.objectIds())",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        folder2.manage_pasteObjects(cookie)",
            "",
            "        self.assertFalse('file' in folder1.objectIds())",
            "        self.assertTrue('file' in folder2.objectIds())",
            "",
            "    def test_move_cant_read_source(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        a_file = folder1._getOb('file')",
            "",
            "        def _validate(a, c, n, v, *args, **kw):",
            "            return aq_base(v) is not aq_base(a_file)",
            "",
            "        self._initPolicyAndUser(v_lambda=_validate)",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Insufficient privileges')",
            "",
            "    def test_move_cant_create_target_metatype_not_supported(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = ()",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Not Supported')",
            "",
            "    def test_move_cant_create_target_metatype_not_allowed(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        def _no_manage_addFile(a, c, n, v, *args, **kw):",
            "            return n != 'manage_addFile'",
            "",
            "        def _no_add_images_and_files(permission, object, context):",
            "            return permission != ADD_IMAGES_AND_FILES",
            "",
            "        self._initPolicyAndUser(v_lambda=_no_manage_addFile,",
            "                                c_lambda=_no_add_images_and_files)",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Insufficient privileges')",
            "",
            "    def test_move_cant_delete_source(self):",
            "        from AccessControl.Permissions import delete_objects as DeleteObjects",
            "",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.manage_permission(DeleteObjects, roles=(), acquire=0)",
            "",
            "        folder1._setObject('sub', PortalFolder('sub'))",
            "        transaction.savepoint(optimistic=True)  # get a _p_jar for 'sub'",
            "",
            "        def _no_delete_objects(permission, object, context):",
            "            return permission != DeleteObjects",
            "",
            "        self._initPolicyAndUser(c_lambda=_no_delete_objects)",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('sub',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Insufficient Privileges'",
            "                                    + '.*%s' % DeleteObjects)",
            "",
            "    def test_paste_with_restricted_item_content_type_not_allowed(self):",
            "        #   Test from CMF Collector #216 (Plone #2186), for the case",
            "        #   in which the item being pasted does not allow adding such",
            "        #   objects to containers which do not explicitly grant access.",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        RESTRICTED_TYPE = 'Restricted Item'",
            "        UNRESTRICTED_TYPE = 'Unrestricted Container'",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.portal_type = UNRESTRICTED_TYPE",
            "        folder2.portal_type = RESTRICTED_TYPE",
            "",
            "        self._initPolicyAndUser()  # ensure that sec. machinery allows paste",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject(RESTRICTED_TYPE,",
            "                         FTI(id=RESTRICTED_TYPE,",
            "                             title=RESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             global_allow=0))",
            "        ttool._setObject(UNRESTRICTED_TYPE,",
            "                         FTI(id=UNRESTRICTED_TYPE,",
            "                             title=UNRESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             filter_content_types=0))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        # copy and pasting the object into the folder should raise",
            "        # an exception",
            "        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])",
            "        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)",
            "",
            "    def test_paste_with_restricted_item_content_type_allowed(self):",
            "        #   Test from CMF Collector #216 (Plone #2186), for the case",
            "        #   in which the item being pasted *does8 allow adding such",
            "        #   objects to containers which *do* explicitly grant access.",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        RESTRICTED_TYPE = 'Restricted Item'",
            "        UNRESTRICTED_TYPE = 'Unrestricted Container'",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.portal_type = UNRESTRICTED_TYPE",
            "        folder2.portal_type = RESTRICTED_TYPE",
            "",
            "        self._initPolicyAndUser()  # ensure that sec. machinery allows paste",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject(RESTRICTED_TYPE,",
            "                         FTI(id=RESTRICTED_TYPE,",
            "                             title=RESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             global_allow=0))",
            "        ttool._setObject(UNRESTRICTED_TYPE,",
            "                         FTI(id=UNRESTRICTED_TYPE,",
            "                             title=UNRESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             filter_content_types=1,",
            "                             allowed_content_types=[RESTRICTED_TYPE]))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        # copy and pasting the object into the folder should *not* raise",
            "        # an exception, because the folder's type allows it.",
            "        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])",
            "        folder1.manage_pasteObjects(copy_cookie)",
            "        self.assertTrue('folder2' in folder1.objectIds())",
            "",
            "    def test_paste_with_restricted_container_content_type(self):",
            "        #   Test from CMF Collector #216 (Plone #2186), for the case",
            "        #   in which the container does not allow adding items of the",
            "        #   type being pasted.",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        RESTRICTED_TYPE = 'Restricted Container'",
            "        UNRESTRICTED_TYPE = 'Unrestricted Item'",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.portal_type = RESTRICTED_TYPE",
            "        folder2.portal_type = UNRESTRICTED_TYPE",
            "",
            "        self._initPolicyAndUser()  # ensure that sec. machinery allows paste",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject(RESTRICTED_TYPE,",
            "                         FTI(id=RESTRICTED_TYPE,",
            "                             title=RESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             filter_content_types=1,",
            "                             allowed_content_types=()))",
            "        ttool._setObject(UNRESTRICTED_TYPE,",
            "                         FTI(id=UNRESTRICTED_TYPE,",
            "                             title=UNRESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             global_allow=1))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        # copy and pasting the object into the folder should raise",
            "        # an exception",
            "        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])",
            "        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)",
            "",
            "",
            "def test_suite():",
            "    loadTestsFromTestCase = unittest.defaultTestLoader.loadTestsFromTestCase",
            "    return unittest.TestSuite((",
            "        loadTestsFromTestCase(PortalFolderFactoryTests),",
            "        loadTestsFromTestCase(PortalFolderTests),",
            "        loadTestsFromTestCase(PortalFolderSecurityTests),",
            "        loadTestsFromTestCase(PortalFolderMoveTests),",
            "        loadTestsFromTestCase(ContentFilterTests),",
            "        loadTestsFromTestCase(PortalFolderCopySupportTests)))"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\" Unit tests for PortalFolder module.",
            "\"\"\"",
            "",
            "import unittest",
            "",
            "import transaction",
            "from AccessControl import SecurityManager",
            "from AccessControl import Unauthorized",
            "from AccessControl.SecurityManagement import newSecurityManager",
            "from Acquisition import Implicit",
            "from Acquisition import aq_base",
            "from DateTime import DateTime",
            "from OFS.Image import manage_addFile",
            "from zope.component import getSiteManager",
            "from zope.component.interfaces import IFactory",
            "from zope.interface import implementer",
            "from zope.interface.verify import verifyClass",
            "",
            "from ..exceptions import BadRequest",
            "from ..interfaces import ICatalogTool",
            "from ..interfaces import ITypesTool",
            "from ..interfaces import IWorkflowTool",
            "from ..testing import ConformsToFolder",
            "from ..testing import TraversingEventZCMLLayer",
            "from ..TypesTool import FactoryTypeInformation as FTI",
            "from ..TypesTool import TypesTool",
            "from ..WorkflowTool import WorkflowTool",
            "from .base.dummy import DummyContent",
            "from .base.dummy import DummyFactoryDispatcher",
            "from .base.dummy import DummySite",
            "from .base.dummy import DummyUserFolder",
            "from .base.testcase import SecurityTest",
            "from .base.tidata import FTIDATA_CMF",
            "from .base.tidata import FTIDATA_DUMMY",
            "",
            "",
            "def extra_meta_types():",
            "    return [{'name': 'Dummy', 'action': 'manage_addFolder',",
            "             'permission': 'View'}]",
            "",
            "",
            "@implementer(ICatalogTool)",
            "class DummyCatalogTool:",
            "",
            "    def __init__(self):",
            "        self.paths = []",
            "        self.ids = []",
            "",
            "    def indexObject(self, object):",
            "        self.paths.append('/'.join(object.getPhysicalPath()))",
            "        self.ids.append(object.getId())",
            "",
            "    def unindexObject(self, object):",
            "        self.paths.remove('/'.join(object.getPhysicalPath()))",
            "        self.ids.append(object.getId())",
            "",
            "    def reindexObject(self, object):",
            "        pass",
            "",
            "    def __len__(self):",
            "        return len(self.paths)",
            "",
            "",
            "def has_path(catalog, path):",
            "    if isinstance(path, tuple):",
            "        path = '/'.join(path)",
            "    return path in catalog.paths",
            "",
            "",
            "def has_id(catalog, id):",
            "    return id in catalog.ids",
            "",
            "",
            "class PortalFolderFactoryTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "    _PORTAL_TYPE = 'Test Folder'",
            "",
            "    def _getTargetObject(self):",
            "        from ..PortalFolder import PortalFolderFactory",
            "",
            "        return PortalFolderFactory",
            "",
            "    def setUp(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        SecurityTest.setUp(self)",
            "        self.site = DummySite('site').__of__(self.app)",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "",
            "        self.ttool = ttool = TypesTool()",
            "        ttool._setObject(self._PORTAL_TYPE,",
            "                         FTI(id=self._PORTAL_TYPE,",
            "                             title='Folder or Directory',",
            "                             meta_type=PortalFolder.meta_type,",
            "                             factory='cmf.folder',",
            "                             filter_content_types=0))",
            "        ttool._setObject('Dummy Content', FTI(**FTIDATA_DUMMY[0].copy()))",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ttool, ITypesTool)",
            "        sm.registerUtility(self._getTargetObject(), IFactory, 'cmf.folder')",
            "",
            "        self.f = self.site._setObject('container', PortalFolder('container'))",
            "        self.f._setPortalTypeName(self._PORTAL_TYPE)",
            "",
            "    def test_invokeFactory(self):",
            "        f = self.f",
            "        self.assertFalse('foo' in f.objectIds())",
            "",
            "        f.manage_addProduct = {'FooProduct': DummyFactoryDispatcher(f)}",
            "        f.invokeFactory(type_name='Dummy Content', id='foo')",
            "",
            "        self.assertTrue('foo' in f.objectIds())",
            "        foo = f.foo",
            "        self.assertEqual(foo.getId(), 'foo')",
            "        self.assertEqual(foo.getPortalTypeName(), 'Dummy Content')",
            "        self.assertEqual(foo.Type(), 'Dummy Content Title')",
            "",
            "    def test_invokeFactory_disallowed_type(self):",
            "        f = self.f",
            "        ftype = getattr(self.ttool, self._PORTAL_TYPE)",
            "        ftype.filter_content_types = 1",
            "        self.assertRaises(ValueError,",
            "                          f.invokeFactory, self._PORTAL_TYPE, 'sub')",
            "",
            "        ftype.allowed_content_types = (self._PORTAL_TYPE,)",
            "        f.invokeFactory(self._PORTAL_TYPE, id='sub')",
            "        self.assertTrue('sub' in f.objectIds())",
            "        self.assertRaises(ValueError, f.invokeFactory, 'Dummy Content', 'foo')",
            "",
            "",
            "class PortalFolderTests(ConformsToFolder, unittest.TestCase):",
            "",
            "    def _getTargetClass(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        return PortalFolder",
            "",
            "    def test_interfaces(self):",
            "        from OFS.interfaces import IOrderedContainer",
            "",
            "        verifyClass(IOrderedContainer, self._getTargetClass())",
            "",
            "    def test_FolderFilter(self):",
            "        folder = self._getTargetClass()('test_id')",
            "",
            "        # No filter",
            "        request = {}",
            "        encoded_filter = folder.encodeFolderFilter(request)",
            "        self.assertEqual(folder.decodeFolderFilter(encoded_filter), {})",
            "",
            "        # Simple filter",
            "        request = {'filter_by_id': 'foobar'}",
            "        encoded_filter = folder.encodeFolderFilter(request)",
            "        self.assertEqual(folder.decodeFolderFilter(encoded_filter),",
            "                         {'id': 'foobar'})",
            "",
            "        # Multiple filters",
            "        request = {'filter_by_id': 'foobar',",
            "                   'filter_by_title': 'baz'}",
            "        encoded_filter = folder.encodeFolderFilter(request)",
            "        self.assertEqual(folder.decodeFolderFilter(encoded_filter),",
            "                         {'id': 'foobar', 'title': 'baz'})",
            "",
            "        # Non-filter request values are ignored",
            "        request = {'filter_by_id': 'foobar', 'somekey': 'somevalue'}",
            "        encoded_filter = folder.encodeFolderFilter(request)",
            "        self.assertEqual(folder.decodeFolderFilter(encoded_filter),",
            "                         {'id': 'foobar'})",
            "",
            "        # Conspicuously large input values to the decode operation",
            "        # are ignored to prevent a DOS",
            "        encoded_filter = 'x' * 2000",
            "        self.assertEqual(folder.decodeFolderFilter(encoded_filter), {})",
            "",
            "",
            "class PortalFolderSecurityTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "",
            "    def _getTargetClass(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        return PortalFolder",
            "",
            "    def _makeOne(self, id, *args, **kw):",
            "        return self.site._setObject(id,",
            "                                    self._getTargetClass()(id, *args, **kw))",
            "",
            "    def setUp(self):",
            "        SecurityTest.setUp(self)",
            "        self.site = DummySite('site').__of__(self.app)",
            "",
            "    def test_contents_methods(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "",
            "        ttool = TypesTool()",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        f = self._makeOne('foo')",
            "        self.assertEqual(f.objectValues(), [])",
            "        self.assertEqual(f.contentIds(), [])",
            "        self.assertEqual(f.contentItems(), [])",
            "        self.assertEqual(f.contentValues(), [])",
            "        self.assertEqual(f.listFolderContents(), [])",
            "        self.assertEqual(f.listDAVObjects(), [])",
            "",
            "        f._setObject('sub1', DummyContent('sub1'))",
            "        self.assertEqual(f.objectValues(), [f.sub1])",
            "        self.assertEqual(f.contentIds(), [])",
            "        self.assertEqual(f.contentItems(), [])",
            "        self.assertEqual(f.contentValues(), [])",
            "        self.assertEqual(f.listFolderContents(), [])",
            "        self.assertEqual(f.listDAVObjects(), [f.sub1])",
            "",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        self.assertEqual(f.objectValues(), [f.sub1])",
            "        self.assertEqual(f.contentIds(), ['sub1'])",
            "        self.assertEqual(f.contentItems(), [('sub1', f.sub1)])",
            "        self.assertEqual(f.contentValues(), [f.sub1])",
            "        self.assertEqual(f.listFolderContents(), [f.sub1])",
            "        self.assertEqual(f.listDAVObjects(), [f.sub1])",
            "",
            "        f._setObject('hidden_sub2', DummyContent('hidden_sub2'))",
            "        self.assertEqual(f.objectValues(), [f.sub1, f.hidden_sub2])",
            "        self.assertEqual(f.contentIds(), ['sub1', 'hidden_sub2'])",
            "        self.assertEqual(f.contentItems(), [('sub1', f.sub1),",
            "                                            ('hidden_sub2', f.hidden_sub2)])",
            "        self.assertEqual(f.contentValues(), [f.sub1, f.hidden_sub2])",
            "        self.assertEqual(f.listFolderContents(), [f.sub1])",
            "        self.assertEqual(f.listDAVObjects(), [f.sub1, f.hidden_sub2])",
            "",
            "    def test_deletePropagation(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        foo = DummyContent('foo')",
            "        foo.reset()",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "",
            "        test._setObject('foo', foo)",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "",
            "        foo.reset()",
            "        test._delObject('foo')",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "",
            "        foo.reset()",
            "        test._setObject('foo', foo)",
            "        test._delOb('foo')    # doesn't propagate",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "",
            "    def test_manageDelObjects(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        foo = DummyContent('foo')",
            "",
            "        test._setObject('foo', foo)",
            "        foo.reset()",
            "        test.manage_delObjects(ids=['foo'])",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "",
            "    def test_catalogUnindexAndIndex(self):",
            "        #",
            "        # Test is a new object does get cataloged upon _setObject",
            "        # and uncataloged upon manage_deleteObjects",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        ctool = DummyCatalogTool()",
            "        self.assertEqual(len(ctool), 0)",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        sm.registerUtility(TypesTool(), ITypesTool)",
            "",
            "        test._setObject('foo', DummyContent('foo', catalog=1))",
            "        foo = test.foo",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 1)",
            "",
            "        foo.reset()",
            "        test._delObject('foo')",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "    def test_portalfolder_cataloging(self):",
            "        #",
            "        # Test to ensure a portal folder itself is *not* cataloged upon",
            "        # instantiation (Tracker issue 309)",
            "        #",
            "        ctool = DummyCatalogTool()",
            "        wtool = WorkflowTool()",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        sm.registerUtility(wtool, IWorkflowTool)",
            "",
            "        test = self._makeOne('test')",
            "        wtool.notifyCreated(test)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "    def test_tracker261(self):",
            "        #",
            "        #   Tracker issue #261 says that content in a deleted folder",
            "        #   is not being uncatalogued.  Try creating a subfolder with",
            "        #   content object, and test.",
            "        #",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        ctool = DummyCatalogTool()",
            "        getSiteManager().registerUtility(ctool, ICatalogTool)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "        test._setObject('sub', PortalFolder('sub', ''))",
            "        sub = test.sub",
            "",
            "        sub._setObject('foo', DummyContent('foo', catalog=1))",
            "        foo = sub.foo",
            "",
            "        self.assertTrue(foo.after_add_called)",
            "        self.assertFalse(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 1)",
            "",
            "        foo.reset()",
            "        test._delObject('sub')",
            "        self.assertFalse(foo.after_add_called)",
            "        self.assertTrue(foo.before_delete_called)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "    def test_manageAddFolder(self):",
            "        #",
            "        #   Does MKDIR/MKCOL intercept work?",
            "        #",
            "        from ..PortalFolder import PortalFolder",
            "        from ..PortalFolder import PortalFolderFactory",
            "",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject('Folder',",
            "                         FTI(id='Folder',",
            "                             title='Folder or Directory',",
            "                             meta_type=PortalFolder.meta_type,",
            "                             factory='cmf.folder',",
            "                             filter_content_types=0))",
            "        ttool._setObject('Grabbed',",
            "                         FTI('Grabbed',",
            "                             title='Grabbed Content',",
            "                             meta_type=PortalFolder.meta_type,",
            "                             factory='cmf.folder'))",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ttool, ITypesTool)",
            "        sm.registerUtility(PortalFolderFactory, IFactory, 'cmf.folder')",
            "",
            "        # First, test default behavior",
            "        test.manage_addFolder(id='simple', title='Simple')",
            "        self.assertEqual(test.simple.getPortalTypeName(), 'Folder')",
            "        self.assertEqual(test.simple.Type(), 'Folder or Directory')",
            "        self.assertEqual(test.simple.getId(), 'simple')",
            "        self.assertEqual(test.simple.Title(), 'Simple')",
            "",
            "        # Now, test overridden behavior",
            "        ttool.Folder.setMethodAliases({'mkdir': 'grabbed'})",
            "",
            "        class Grabbed:",
            "",
            "            _grabbed_with = None",
            "",
            "            def __init__(self, context):",
            "                self._context = context",
            "",
            "            def __call__(self, id):",
            "                self._grabbed_with = id",
            "                self._context._setOb(id, PortalFolder(id))",
            "                self._context._getOb(id)._setPortalTypeName('Grabbed')",
            "",
            "        self.app.grabbed = Grabbed(test)",
            "",
            "        test.manage_addFolder(id='indirect', title='Indirect')",
            "        self.assertEqual(test.indirect.getPortalTypeName(), 'Grabbed')",
            "        self.assertEqual(test.indirect.Type(), 'Grabbed Content')",
            "        self.assertEqual(test.indirect.getId(), 'indirect')",
            "        self.assertEqual(test.indirect.Title(), 'Indirect')",
            "",
            "    def test_contentPasteAllowedTypes(self):",
            "        #",
            "        #   _verifyObjectPaste() should honor allowed content types",
            "        #",
            "        ttool = TypesTool()",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        ttool._setObject('Folder', FTI(**fti))",
            "        sub1 = self._makeOne('sub1')",
            "        sub1._setObject('dummy', DummyContent('dummy'))",
            "        sub2 = self._makeOne('sub2')",
            "        sub2.all_meta_types = extra_meta_types()",
            "",
            "        # Allow adding of Dummy Content",
            "        ttool.Folder.manage_changeProperties(filter_content_types=False)",
            "",
            "        # Copy/paste should work fine",
            "        cookie = sub1.manage_copyObjects(ids=['dummy'])",
            "        sub2.manage_pasteObjects(cookie)",
            "",
            "        # Disallow adding of Dummy Content",
            "        ttool.Folder.manage_changeProperties(filter_content_types=True)",
            "",
            "        # Now copy/paste should raise a ValueError",
            "        cookie = sub1.manage_copyObjects(ids=('dummy',))",
            "        self.assertRaises(ValueError, sub2.manage_pasteObjects, cookie)",
            "",
            "    def test_contentPasteFollowsWorkflowGuards(self):",
            "        #",
            "        # Copy/Paste should obey workflow guards",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        ttool = TypesTool()",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        ttool._setObject('Folder', FTI(**fti))",
            "        folder = self._makeOne('folder', 'Folder')",
            "        content = self._makeOne('content')",
            "        folder._setObject('content', content)",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ttool, ITypesTool)",
            "",
            "        # Allow adding of Dummy Content",
            "        ttool.Folder.manage_changeProperties(filter_content_types=False)",
            "",
            "        # Copy/paste verification should work fine",
            "        folder._verifyObjectPaste(content)",
            "",
            "        # Add a workflow with a blocking guard",
            "        # Based on TypesTools tests",
            "        class DummyWorkflow:",
            "",
            "            _allow = False",
            "",
            "            def allowCreate(self, container, type_id):",
            "                return self._allow",
            "",
            "        class DummyWorkflowTool:",
            "",
            "            def __init__(self):",
            "                self._workflows = [DummyWorkflow()]",
            "",
            "            def getWorkflowsFor(self, type_id):",
            "                return self._workflows",
            "",
            "        # Now copy/paste verification should raise a ValueError",
            "        sm.registerUtility(DummyWorkflowTool(), IWorkflowTool)",
            "        self.assertRaises(ValueError, folder._verifyObjectPaste, content)",
            "",
            "    def test_setObjectRaisesBadRequest(self):",
            "        #",
            "        #   _setObject() should raise BadRequest on duplicate id",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setObject('foo', DummyContent('foo'))",
            "        self.assertRaises(BadRequest, test._setObject, 'foo',",
            "                          DummyContent('foo'))",
            "",
            "    def test__checkId_Duplicate(self):",
            "        #",
            "        #   _checkId() should raise BadRequest on duplicate id",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setObject('foo', DummyContent('foo'))",
            "        self.assertRaises(BadRequest, test._checkId, 'foo')",
            "",
            "    def test__checkId_PortalRoot(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        test._checkId('acl_users')",
            "        newSecurityManager(None, acl_users.user_foo)",
            "        self.assertRaises(BadRequest, test._checkId, 'acl_users')",
            "",
            "    def test__checkId_MethodAlias(self):",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setPortalTypeName('Dummy Content 15')",
            "        ttool = TypesTool()",
            "        ttool._setObject('Dummy Content 15', FTI(**FTIDATA_CMF[0]))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        test._checkId('view')",
            "        newSecurityManager(None, acl_users.user_foo)",
            "        self.assertRaises(BadRequest, test._checkId, 'view')",
            "",
            "    def test__checkId_starting_with_dot(self):",
            "        #",
            "        # doted prefixed names at the root of the portal can be overriden",
            "        #",
            "",
            "        # Create a .foo at the root",
            "        self.site._setObject('.foo', DummyContent('.foo'))",
            "",
            "        # Create a sub-folder",
            "        sub = self._makeOne('sub')",
            "",
            "        # It should be possible to create another .foo object in the",
            "        # sub-folder",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.user_foo)",
            "",
            "        self.assertTrue(sub.checkIdAvailable('.foo'))",
            "",
            "    def test__checkId_Five(self):",
            "        test = self._makeOne('test')",
            "        self.assertRaises(BadRequest, test._checkId, '@@view')",
            "",
            "    def test_checkIdAvailableCatchesBadRequest(self):",
            "        #",
            "        #   checkIdAvailable() should catch BadRequest",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        test = self._makeOne('test')",
            "        test._setObject('foo', DummyContent('foo'))",
            "        self.assertFalse(test.checkIdAvailable('foo'))",
            "",
            "",
            "class PortalFolderMoveTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "",
            "    def setUp(self):",
            "        SecurityTest.setUp(self)",
            "        self.app._setObject('site', DummySite('site'))",
            "        self.site = self.app.site",
            "",
            "    def _makeOne(self, id, *args, **kw):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        return self.site._setObject(id, PortalFolder(id, *args, **kw))",
            "",
            "    def test_folderMove(self):",
            "        #",
            "        #   Does the catalog stay synched when folders are moved?",
            "        #",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        ctool = DummyCatalogTool()",
            "        sm = getSiteManager()",
            "        sm.registerUtility(TypesTool(), ITypesTool)",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        self.assertEqual(len(ctool), 0)",
            "",
            "        folder = self._makeOne('folder')",
            "        folder._setObject('sub', PortalFolder('sub', ''))",
            "        folder.sub._setObject('foo', DummyContent('foo', catalog=1))",
            "        self.assertEqual(len(ctool), 1)",
            "        self.assertTrue(has_id(ctool, 'foo'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/sub/foo'))",
            "",
            "        transaction.savepoint(optimistic=True)",
            "        folder.manage_renameObject(id='sub', new_id='new_sub')",
            "        self.assertEqual(len(ctool), 1)",
            "        self.assertTrue(has_id(ctool, 'foo'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/new_sub/foo'))",
            "",
            "        folder._setObject('bar', DummyContent('bar', catalog=1))",
            "        self.assertEqual(len(ctool), 2)",
            "        self.assertTrue(has_id(ctool, 'bar'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/bar'))",
            "",
            "        folder._setObject('sub2', PortalFolder('sub2', ''))",
            "        sub2 = folder.sub2",
            "        # Waaa! force sub2 to allow paste of Dummy object.",
            "        sub2.all_meta_types = []",
            "        sub2.all_meta_types.extend(sub2.all_meta_types)",
            "        sub2.all_meta_types.extend(extra_meta_types())",
            "",
            "        transaction.savepoint(optimistic=True)",
            "        cookie = folder.manage_cutObjects(ids=['bar'])",
            "        sub2.manage_pasteObjects(cookie)",
            "",
            "        self.assertTrue(has_id(ctool, 'foo'))",
            "        self.assertTrue(has_id(ctool, 'bar'))",
            "        self.assertEqual(len(ctool), 2)",
            "        self.assertTrue(has_path(ctool, '/bar/site/folder/sub2/bar'))",
            "",
            "    def test_contentPaste(self):",
            "        #",
            "        #   Does copy / paste work?",
            "        #",
            "        acl_users = self.site._setObject('acl_users', DummyUserFolder())",
            "        newSecurityManager(None, acl_users.all_powerful_Oz)",
            "        ctool = DummyCatalogTool()",
            "        ttool = TypesTool()",
            "        fti = FTIDATA_DUMMY[0].copy()",
            "        ttool._setObject('Dummy Content', FTI(**fti))",
            "        sub1 = self._makeOne('sub1')",
            "        sub2 = self._makeOne('sub2')",
            "        sub3 = self._makeOne('sub3')",
            "        self.assertEqual(len(ctool), 0)",
            "        sm = getSiteManager()",
            "        sm.registerUtility(ctool, ICatalogTool)",
            "        sm.registerUtility(ttool, ITypesTool)",
            "",
            "        sub1._setObject('dummy', DummyContent('dummy', catalog=1))",
            "        self.assertTrue('dummy' in sub1.objectIds())",
            "        self.assertTrue('dummy' in sub1.contentIds())",
            "        self.assertFalse('dummy' in sub2.objectIds())",
            "        self.assertFalse('dummy' in sub2.contentIds())",
            "        self.assertFalse('dummy' in sub3.objectIds())",
            "        self.assertFalse('dummy' in sub3.contentIds())",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub2/dummy'))",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))",
            "",
            "        cookie = sub1.manage_copyObjects(ids=('dummy',))",
            "        # Waaa! force sub2 to allow paste of Dummy object.",
            "        sub2.all_meta_types = []",
            "        sub2.all_meta_types.extend(sub2.all_meta_types)",
            "        sub2.all_meta_types.extend(extra_meta_types())",
            "        sub2.manage_pasteObjects(cookie)",
            "        self.assertTrue('dummy' in sub1.objectIds())",
            "        self.assertTrue('dummy' in sub1.contentIds())",
            "        self.assertTrue('dummy' in sub2.objectIds())",
            "        self.assertTrue('dummy' in sub2.contentIds())",
            "        self.assertFalse('dummy' in sub3.objectIds())",
            "        self.assertFalse('dummy' in sub3.contentIds())",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub1/dummy'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub3/dummy'))",
            "",
            "        transaction.savepoint(optimistic=True)",
            "        cookie = sub1.manage_cutObjects(ids=('dummy',))",
            "        # Waaa! force sub2 to allow paste of Dummy object.",
            "        sub3.all_meta_types = []",
            "        sub3.all_meta_types.extend(sub3.all_meta_types)",
            "        sub3.all_meta_types.extend(extra_meta_types())",
            "        sub3.manage_pasteObjects(cookie)",
            "        self.assertFalse('dummy' in sub1.objectIds())",
            "        self.assertFalse('dummy' in sub1.contentIds())",
            "        self.assertTrue('dummy' in sub2.objectIds())",
            "        self.assertTrue('dummy' in sub2.contentIds())",
            "        self.assertTrue('dummy' in sub3.objectIds())",
            "        self.assertTrue('dummy' in sub3.contentIds())",
            "        self.assertFalse(has_path(ctool, '/bar/site/sub1/dummy'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub2/dummy'))",
            "        self.assertTrue(has_path(ctool, '/bar/site/sub3/dummy'))",
            "",
            "",
            "class ContentFilterTests(unittest.TestCase):",
            "",
            "    def setUp(self):",
            "        self.dummy = DummyContent('Dummy')",
            "",
            "    def test_empty(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter()",
            "        dummy = self.dummy",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = [_f for _f in desc.split('; ') if _f]",
            "        self.assertFalse(lines)",
            "",
            "    def test_Type(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Type='foo')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        cfilter = ContentFilter(Type='Dummy Content Title')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Type: Dummy Content Title')",
            "",
            "        cfilter = ContentFilter(Type=('foo', 'bar'))",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        cfilter = ContentFilter(Type=('Dummy Content Title', 'something else'))",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Type: Dummy Content Title, something else')",
            "",
            "    def test_portal_type(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(portal_type='some_pt')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'asdf'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'some_ptyyy'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'xxxsome_ptyyy'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.portal_type = 'some_pt'",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Portal Type: some_pt')",
            "",
            "    def test_Title(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Title='foo')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.title = 'asdf'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.title = 'foolish'",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.title = 'ohsofoolish'",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Title: foo')",
            "",
            "    def test_Creator(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Creator='moe')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.creators = ('curly',)",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.creators = ('moe',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.creators = ('moe', 'curly')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Creator: moe')",
            "",
            "    def test_Description(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Description='funny')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.description = 'sad'",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.description = 'funny'",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.description = 'it is funny you should mention it...'",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Description: funny')",
            "",
            "    def test_Subject(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Subject=('foo',))",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('bar',)",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('foo',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.subject = ('foo', 'bar')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Subject: foo')",
            "",
            "    def test_Subject2(self):",
            "        # Now test with mutli-valued",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        cfilter = ContentFilter(Subject=('foo', 'bar'))",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('baz',)",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.subject = ('bar',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.subject = ('foo',)",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.subject = ('foo', 'bar')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0], 'Subject: foo, bar')",
            "",
            "    def test_created(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(created=creation_date,",
            "                                created_usage='range:min')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Created since: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_created2(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(created=creation_date,",
            "                                created_usage='range:max')",
            "",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Created before: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_modified(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(modified=DateTime('2001/01/01'),",
            "                                modified_usage='range:min')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2000/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Modified since: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_modified2(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(modified=DateTime('2001/01/01'),",
            "                                modified_usage='range:max')",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2000/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.modified_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 1)",
            "        self.assertEqual(lines[0],",
            "                         'Modified before: 2001/01/01 00:00:00 %s' % tz)",
            "",
            "    def test_mixed(self):",
            "        from ..PortalFolder import ContentFilter",
            "",
            "        creation_date = DateTime('2001/01/01')",
            "        tz = creation_date.timezone()",
            "        cfilter = ContentFilter(created=DateTime('2001/01/01'),",
            "                                created_usage='range:max', Title='foo')",
            "",
            "        dummy = self.dummy",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertFalse(cfilter(dummy))",
            "",
            "        dummy.title = 'ohsofoolish'",
            "        del dummy.created_date",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2000/12/31')",
            "        self.assertTrue(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/12/31')",
            "        self.assertFalse(cfilter(dummy))",
            "        dummy.created_date = DateTime('2001/01/01')",
            "        self.assertTrue(cfilter(dummy))",
            "",
            "        desc = str(cfilter)",
            "        lines = desc.split('; ')",
            "        self.assertEqual(len(lines), 2)",
            "        self.assertTrue('Created before: 2001/01/01 00:00:00 %s' % tz in lines)",
            "        self.assertTrue('Title: foo' in lines)",
            "",
            "",
            "# -----------------------------------------------------------------------------",
            "#   Tests for security-related CopySupport lifted from the Zope 2.7",
            "#   / head OFS.tests.testCopySupport (see Collector #259).",
            "# -----------------------------------------------------------------------------",
            "ADD_IMAGES_AND_FILES = 'Add images and files'",
            "FILE_META_TYPES = ({'name': 'File',",
            "                    'action': 'manage_addFile',",
            "                    'permission': ADD_IMAGES_AND_FILES},)",
            "",
            "",
            "class _SensitiveSecurityPolicy:",
            "",
            "    def __init__(self, validate_lambda, checkPermission_lambda):",
            "        self._lambdas = (validate_lambda, checkPermission_lambda)",
            "",
            "    def validate(self, *args, **kw):",
            "        if self._lambdas[0](*args, **kw):",
            "            return True",
            "        raise Unauthorized",
            "",
            "    def checkPermission(self, *args, **kw):",
            "        return self._lambdas[1](*args, **kw)",
            "",
            "",
            "class _AllowedUser(Implicit):",
            "",
            "    def __init__(self, allowed_lambda):",
            "        self._lambdas = (allowed_lambda,)",
            "",
            "    def getId(self):",
            "        return 'unit_tester'",
            "",
            "    def getUserName(self):",
            "        return 'Unit Tester'",
            "",
            "    def allowed(self, object, object_roles=None):",
            "        return self._lambdas[0](object, object_roles)",
            "",
            "",
            "class PortalFolderCopySupportTests(SecurityTest):",
            "",
            "    layer = TraversingEventZCMLLayer",
            "",
            "    def _initFolders(self):",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        self.app._setObject('folder1', PortalFolder('folder1'))",
            "        self.app._setObject('folder2', PortalFolder('folder2'))",
            "        folder1 = getattr(self.app, 'folder1')",
            "        manage_addFile(folder1, 'file', file='', content_type='text/plain')",
            "",
            "        # Hack, we need a _p_mtime for the file, so we make sure that it",
            "        # has one. We use a subtransaction, which means we can rollback",
            "        # later and pretend we didn't touch the ZODB.",
            "        transaction.savepoint(optimistic=True)",
            "        return self.app._getOb('folder1'), self.app._getOb('folder2')",
            "",
            "    def _assertCopyErrorUnauth(self, callable, *args, **kw):",
            "        import re",
            "",
            "        from OFS.CopySupport import CopyError",
            "",
            "        from ..exceptions import zExceptions_Unauthorized",
            "",
            "        ce_regex = kw.get('ce_regex')",
            "        if ce_regex is not None:",
            "            del kw['ce_regex']",
            "",
            "        try:",
            "            callable(*args, **kw)",
            "        except CopyError as e:",
            "            if ce_regex is not None:",
            "                pattern = re.compile(ce_regex, re.DOTALL)",
            "                if pattern.search(str(e)) is None:",
            "                    self.fail(\"Paste failed; didn't match pattern:\\n%s\" % e)",
            "            else:",
            "                self.fail('Paste failed; no pattern:\\n%s' % e)",
            "",
            "        except zExceptions_Unauthorized:",
            "            pass",
            "        else:",
            "            self.fail('Paste allowed unexpectedly.')",
            "",
            "    def _initPolicyAndUser(self, a_lambda=None, v_lambda=None, c_lambda=None):",
            "        def _promiscuous(*args, **kw):",
            "            return 1",
            "",
            "        if a_lambda is None:",
            "            a_lambda = _promiscuous",
            "",
            "        if v_lambda is None:",
            "            v_lambda = _promiscuous",
            "",
            "        if c_lambda is None:",
            "            c_lambda = _promiscuous",
            "",
            "        scp = _SensitiveSecurityPolicy(v_lambda, c_lambda)",
            "        SecurityManager.setSecurityPolicy(scp)",
            "",
            "        newSecurityManager(None,",
            "                           _AllowedUser(a_lambda).__of__(self.app.acl_users))",
            "",
            "    def test_copy_baseline(self):",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        self.assertTrue('file' in folder1.objectIds())",
            "        self.assertFalse('file' in folder2.objectIds())",
            "",
            "        cookie = folder1.manage_copyObjects(ids=('file',))",
            "        folder2.manage_pasteObjects(cookie)",
            "",
            "        self.assertTrue('file' in folder1.objectIds())",
            "        self.assertTrue('file' in folder2.objectIds())",
            "",
            "    def test_copy_cant_read_source(self):",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        a_file = folder1._getOb('file')",
            "",
            "        def _validate(a, c, n, v, *args, **kw):",
            "            return aq_base(v) is not aq_base(a_file)",
            "",
            "        self._initPolicyAndUser(v_lambda=_validate)",
            "",
            "        cookie = folder1.manage_copyObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects,",
            "                                    cookie,",
            "                                    ce_regex='Insufficient privileges')",
            "",
            "    def test_copy_cant_create_target_metatype_not_supported(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = ()",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        cookie = folder1.manage_copyObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Not Supported')",
            "",
            "    def test_move_baseline(self):",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        self.assertTrue('file' in folder1.objectIds())",
            "        self.assertFalse('file' in folder2.objectIds())",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        folder2.manage_pasteObjects(cookie)",
            "",
            "        self.assertFalse('file' in folder1.objectIds())",
            "        self.assertTrue('file' in folder2.objectIds())",
            "",
            "    def test_move_cant_read_source(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        a_file = folder1._getOb('file')",
            "",
            "        def _validate(a, c, n, v, *args, **kw):",
            "            return aq_base(v) is not aq_base(a_file)",
            "",
            "        self._initPolicyAndUser(v_lambda=_validate)",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Insufficient privileges')",
            "",
            "    def test_move_cant_create_target_metatype_not_supported(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = ()",
            "",
            "        self._initPolicyAndUser()",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Not Supported')",
            "",
            "    def test_move_cant_create_target_metatype_not_allowed(self):",
            "        folder1, folder2 = self._initFolders()",
            "        folder2.all_meta_types = FILE_META_TYPES",
            "",
            "        def _no_manage_addFile(a, c, n, v, *args, **kw):",
            "            return n != 'manage_addFile'",
            "",
            "        def _no_add_images_and_files(permission, object, context):",
            "            return permission != ADD_IMAGES_AND_FILES",
            "",
            "        self._initPolicyAndUser(v_lambda=_no_manage_addFile,",
            "                                c_lambda=_no_add_images_and_files)",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('file',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Insufficient privileges')",
            "",
            "    def test_move_cant_delete_source(self):",
            "        from AccessControl.Permissions import delete_objects as DeleteObjects",
            "",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.manage_permission(DeleteObjects, roles=(), acquire=0)",
            "",
            "        folder1._setObject('sub', PortalFolder('sub'))",
            "        transaction.savepoint(optimistic=True)  # get a _p_jar for 'sub'",
            "",
            "        def _no_delete_objects(permission, object, context):",
            "            return permission != DeleteObjects",
            "",
            "        self._initPolicyAndUser(c_lambda=_no_delete_objects)",
            "",
            "        cookie = folder1.manage_cutObjects(ids=('sub',))",
            "        self._assertCopyErrorUnauth(folder2.manage_pasteObjects, cookie,",
            "                                    ce_regex='Insufficient Privileges'",
            "                                    + '.*%s' % DeleteObjects)",
            "",
            "    def test_paste_with_restricted_item_content_type_not_allowed(self):",
            "        #   Test from CMF Collector #216 (Plone #2186), for the case",
            "        #   in which the item being pasted does not allow adding such",
            "        #   objects to containers which do not explicitly grant access.",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        RESTRICTED_TYPE = 'Restricted Item'",
            "        UNRESTRICTED_TYPE = 'Unrestricted Container'",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.portal_type = UNRESTRICTED_TYPE",
            "        folder2.portal_type = RESTRICTED_TYPE",
            "",
            "        self._initPolicyAndUser()  # ensure that sec. machinery allows paste",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject(RESTRICTED_TYPE,",
            "                         FTI(id=RESTRICTED_TYPE,",
            "                             title=RESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             global_allow=0))",
            "        ttool._setObject(UNRESTRICTED_TYPE,",
            "                         FTI(id=UNRESTRICTED_TYPE,",
            "                             title=UNRESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             filter_content_types=0))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        # copy and pasting the object into the folder should raise",
            "        # an exception",
            "        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])",
            "        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)",
            "",
            "    def test_paste_with_restricted_item_content_type_allowed(self):",
            "        #   Test from CMF Collector #216 (Plone #2186), for the case",
            "        #   in which the item being pasted *does8 allow adding such",
            "        #   objects to containers which *do* explicitly grant access.",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        RESTRICTED_TYPE = 'Restricted Item'",
            "        UNRESTRICTED_TYPE = 'Unrestricted Container'",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.portal_type = UNRESTRICTED_TYPE",
            "        folder2.portal_type = RESTRICTED_TYPE",
            "",
            "        self._initPolicyAndUser()  # ensure that sec. machinery allows paste",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject(RESTRICTED_TYPE,",
            "                         FTI(id=RESTRICTED_TYPE,",
            "                             title=RESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             global_allow=0))",
            "        ttool._setObject(UNRESTRICTED_TYPE,",
            "                         FTI(id=UNRESTRICTED_TYPE,",
            "                             title=UNRESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             filter_content_types=1,",
            "                             allowed_content_types=[RESTRICTED_TYPE]))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        # copy and pasting the object into the folder should *not* raise",
            "        # an exception, because the folder's type allows it.",
            "        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])",
            "        folder1.manage_pasteObjects(copy_cookie)",
            "        self.assertTrue('folder2' in folder1.objectIds())",
            "",
            "    def test_paste_with_restricted_container_content_type(self):",
            "        #   Test from CMF Collector #216 (Plone #2186), for the case",
            "        #   in which the container does not allow adding items of the",
            "        #   type being pasted.",
            "        from ..PortalFolder import PortalFolder",
            "",
            "        RESTRICTED_TYPE = 'Restricted Container'",
            "        UNRESTRICTED_TYPE = 'Unrestricted Item'",
            "",
            "        folder1, folder2 = self._initFolders()",
            "        folder1.portal_type = RESTRICTED_TYPE",
            "        folder2.portal_type = UNRESTRICTED_TYPE",
            "",
            "        self._initPolicyAndUser()  # ensure that sec. machinery allows paste",
            "",
            "        ttool = TypesTool()",
            "        ttool._setObject(RESTRICTED_TYPE,",
            "                         FTI(id=RESTRICTED_TYPE,",
            "                             title=RESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             filter_content_types=1,",
            "                             allowed_content_types=()))",
            "        ttool._setObject(UNRESTRICTED_TYPE,",
            "                         FTI(id=UNRESTRICTED_TYPE,",
            "                             title=UNRESTRICTED_TYPE,",
            "                             meta_type=PortalFolder.meta_type,",
            "                             product='CMFCore',",
            "                             factory='manage_addPortalFolder',",
            "                             global_allow=1))",
            "        getSiteManager().registerUtility(ttool, ITypesTool)",
            "",
            "        # copy and pasting the object into the folder should raise",
            "        # an exception",
            "        copy_cookie = self.app.manage_copyObjects(ids=['folder2'])",
            "        self.assertRaises(ValueError, folder1.manage_pasteObjects, copy_cookie)",
            "",
            "",
            "def test_suite():",
            "    loadTestsFromTestCase = unittest.defaultTestLoader.loadTestsFromTestCase",
            "    return unittest.TestSuite((",
            "        loadTestsFromTestCase(PortalFolderFactoryTests),",
            "        loadTestsFromTestCase(PortalFolderTests),",
            "        loadTestsFromTestCase(PortalFolderSecurityTests),",
            "        loadTestsFromTestCase(PortalFolderMoveTests),",
            "        loadTestsFromTestCase(ContentFilterTests),",
            "        loadTestsFromTestCase(PortalFolderCopySupportTests)))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.octoprint.filemanager.storage.LocalFileStorage._copy_metadata_entry"
        ]
    }
}