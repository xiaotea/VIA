{
    "homeassistant/components/auth/login_flow.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " from homeassistant.components.http.view import HomeAssistantView"
            },
            "1": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " from homeassistant.core import HomeAssistant"
            },
            "2": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " from homeassistant.helpers.network import is_cloud_connection"
            },
            "3": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from homeassistant.util.network import is_local"
            },
            "4": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " from . import indieauth"
            },
            "6": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         providers = []"
            },
            "9": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         for provider in hass.auth.auth_providers:"
            },
            "10": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            additional_data = {}"
            },
            "11": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "12": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 167,
                "PatchRowcode": "             if provider.type == \"trusted_networks\":"
            },
            "13": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "                 if cloud_connection:"
            },
            "14": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "                     # Skip quickly as trusted networks are not available on cloud"
            },
            "15": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "                 except InvalidAuthError:"
            },
            "16": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "                     # Not a trusted network, so we don't expose that trusted_network authenticator is setup"
            },
            "17": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "                     continue"
            },
            "18": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            elif ("
            },
            "19": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                provider.type == \"homeassistant\""
            },
            "20": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and not cloud_connection"
            },
            "21": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and is_local(remote_address)"
            },
            "22": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                and \"person\" in hass.config.components"
            },
            "23": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ):"
            },
            "24": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # We are local, return user id and username"
            },
            "25": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                users = await provider.store.async_get_users()"
            },
            "26": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                additional_data[\"users\"] = {"
            },
            "27": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    user.id: credentials.data[\"username\"]"
            },
            "28": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    for user in users"
            },
            "29": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    for credentials in user.credentials"
            },
            "30": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if ("
            },
            "31": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        credentials.auth_provider_type == provider.type"
            },
            "32": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        and credentials.auth_provider_id == provider.id"
            },
            "33": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "34": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                }"
            },
            "35": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             providers.append("
            },
            "37": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "                 {"
            },
            "38": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                     \"name\": provider.name,"
            },
            "39": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "                     \"id\": provider.id,"
            },
            "40": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "                     \"type\": provider.type,"
            },
            "41": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    **additional_data,"
            },
            "42": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "                 }"
            },
            "43": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "             )"
            },
            "44": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"HTTP views handle login flow.",
            "",
            "# GET /auth/providers",
            "",
            "Return a list of auth providers. Example:",
            "",
            "[",
            "    {",
            "        \"name\": \"Local\",",
            "        \"id\": null,",
            "        \"type\": \"local_provider\",",
            "    }",
            "]",
            "",
            "",
            "# POST /auth/login_flow",
            "",
            "Create a login flow. Will return the first step of the flow.",
            "",
            "Pass in parameter 'client_id' and 'redirect_url' validate by indieauth.",
            "",
            "Pass in parameter 'handler' to specify the auth provider to use. Auth providers",
            "are identified by type and id.",
            "",
            "And optional parameter 'type' has to set as 'link_user' if login flow used for",
            "link credential to exist user. Default 'type' is 'authorize'.",
            "",
            "{",
            "    \"client_id\": \"https://hassbian.local:8123/\",",
            "    \"handler\": [\"local_provider\", null],",
            "    \"redirect_url\": \"https://hassbian.local:8123/\",",
            "    \"type': \"authorize\"",
            "}",
            "",
            "Return value will be a step in a data entry flow. See the docs for data entry",
            "flow for details.",
            "",
            "{",
            "    \"data_schema\": [",
            "        {\"name\": \"username\", \"type\": \"string\"},",
            "        {\"name\": \"password\", \"type\": \"string\"}",
            "    ],",
            "    \"errors\": {},",
            "    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",",
            "    \"handler\": [\"insecure_example\", null],",
            "    \"step_id\": \"init\",",
            "    \"type\": \"form\"",
            "}",
            "",
            "",
            "# POST /auth/login_flow/{flow_id}",
            "",
            "Progress the flow. Most flows will be 1 page, but could optionally add extra",
            "login challenges, like TFA. Once the flow has finished, the returned step will",
            "have type FlowResultType.CREATE_ENTRY and \"result\" key will contain an authorization code.",
            "The authorization code associated with an authorized user by default, it will",
            "associate with an credential if \"type\" set to \"link_user\" in",
            "\"/auth/login_flow\"",
            "",
            "{",
            "    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",",
            "    \"handler\": [\"insecure_example\", null],",
            "    \"result\": \"411ee2f916e648d691e937ae9344681e\",",
            "    \"title\": \"Example\",",
            "    \"type\": \"create_entry\",",
            "    \"version\": 1",
            "}",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "from collections.abc import Callable",
            "from http import HTTPStatus",
            "from ipaddress import ip_address",
            "from typing import TYPE_CHECKING, Any, cast",
            "",
            "from aiohttp import web",
            "import voluptuous as vol",
            "import voluptuous_serialize",
            "",
            "from homeassistant import data_entry_flow",
            "from homeassistant.auth import AuthManagerFlowManager, InvalidAuthError",
            "from homeassistant.auth.models import Credentials",
            "from homeassistant.components import onboarding",
            "from homeassistant.components.http.auth import async_user_not_allowed_do_auth",
            "from homeassistant.components.http.ban import (",
            "    log_invalid_auth,",
            "    process_success_login,",
            "    process_wrong_login,",
            ")",
            "from homeassistant.components.http.data_validator import RequestDataValidator",
            "from homeassistant.components.http.view import HomeAssistantView",
            "from homeassistant.core import HomeAssistant",
            "from homeassistant.helpers.network import is_cloud_connection",
            "from homeassistant.util.network import is_local",
            "",
            "from . import indieauth",
            "",
            "if TYPE_CHECKING:",
            "    from homeassistant.auth.providers.trusted_networks import (",
            "        TrustedNetworksAuthProvider,",
            "    )",
            "",
            "    from . import StoreResultType",
            "",
            "",
            "async def async_setup(",
            "    hass: HomeAssistant, store_result: Callable[[str, Credentials], str]",
            ") -> None:",
            "    \"\"\"Component to allow users to login.\"\"\"",
            "    hass.http.register_view(WellKnownOAuthInfoView)",
            "    hass.http.register_view(AuthProvidersView)",
            "    hass.http.register_view(LoginFlowIndexView(hass.auth.login_flow, store_result))",
            "    hass.http.register_view(LoginFlowResourceView(hass.auth.login_flow, store_result))",
            "",
            "",
            "class WellKnownOAuthInfoView(HomeAssistantView):",
            "    \"\"\"View to host the OAuth2 information.\"\"\"",
            "",
            "    requires_auth = False",
            "    url = \"/.well-known/oauth-authorization-server\"",
            "    name = \"well-known/oauth-authorization-server\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Return the well known OAuth2 authorization info.\"\"\"",
            "        return self.json(",
            "            {",
            "                \"authorization_endpoint\": \"/auth/authorize\",",
            "                \"token_endpoint\": \"/auth/token\",",
            "                \"revocation_endpoint\": \"/auth/revoke\",",
            "                \"response_types_supported\": [\"code\"],",
            "                \"service_documentation\": (",
            "                    \"https://developers.home-assistant.io/docs/auth_api\"",
            "                ),",
            "            }",
            "        )",
            "",
            "",
            "class AuthProvidersView(HomeAssistantView):",
            "    \"\"\"View to get available auth providers.\"\"\"",
            "",
            "    url = \"/auth/providers\"",
            "    name = \"api:auth:providers\"",
            "    requires_auth = False",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Get available auth providers.\"\"\"",
            "        hass: HomeAssistant = request.app[\"hass\"]",
            "        if not onboarding.async_is_user_onboarded(hass):",
            "            return self.json_message(",
            "                message=\"Onboarding not finished\",",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                message_code=\"onboarding_required\",",
            "            )",
            "",
            "        try:",
            "            remote_address = ip_address(request.remote)  # type: ignore[arg-type]",
            "        except ValueError:",
            "            return self.json_message(",
            "                message=\"Invalid remote IP\",",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                message_code=\"invalid_remote_ip\",",
            "            )",
            "",
            "        cloud_connection = is_cloud_connection(hass)",
            "",
            "        providers = []",
            "        for provider in hass.auth.auth_providers:",
            "            additional_data = {}",
            "",
            "            if provider.type == \"trusted_networks\":",
            "                if cloud_connection:",
            "                    # Skip quickly as trusted networks are not available on cloud",
            "                    continue",
            "",
            "                try:",
            "                    cast(\"TrustedNetworksAuthProvider\", provider).async_validate_access(",
            "                        remote_address",
            "                    )",
            "                except InvalidAuthError:",
            "                    # Not a trusted network, so we don't expose that trusted_network authenticator is setup",
            "                    continue",
            "            elif (",
            "                provider.type == \"homeassistant\"",
            "                and not cloud_connection",
            "                and is_local(remote_address)",
            "                and \"person\" in hass.config.components",
            "            ):",
            "                # We are local, return user id and username",
            "                users = await provider.store.async_get_users()",
            "                additional_data[\"users\"] = {",
            "                    user.id: credentials.data[\"username\"]",
            "                    for user in users",
            "                    for credentials in user.credentials",
            "                    if (",
            "                        credentials.auth_provider_type == provider.type",
            "                        and credentials.auth_provider_id == provider.id",
            "                    )",
            "                }",
            "",
            "            providers.append(",
            "                {",
            "                    \"name\": provider.name,",
            "                    \"id\": provider.id,",
            "                    \"type\": provider.type,",
            "                    **additional_data,",
            "                }",
            "            )",
            "",
            "        return self.json(providers)",
            "",
            "",
            "def _prepare_result_json(",
            "    result: data_entry_flow.FlowResult,",
            ") -> data_entry_flow.FlowResult:",
            "    \"\"\"Convert result to JSON.\"\"\"",
            "    if result[\"type\"] == data_entry_flow.FlowResultType.CREATE_ENTRY:",
            "        data = result.copy()",
            "        data.pop(\"result\")",
            "        data.pop(\"data\")",
            "        return data",
            "",
            "    if result[\"type\"] != data_entry_flow.FlowResultType.FORM:",
            "        return result",
            "",
            "    data = result.copy()",
            "",
            "    if (schema := data[\"data_schema\"]) is None:",
            "        data[\"data_schema\"] = []",
            "    else:",
            "        data[\"data_schema\"] = voluptuous_serialize.convert(schema)",
            "",
            "    return data",
            "",
            "",
            "class LoginFlowBaseView(HomeAssistantView):",
            "    \"\"\"Base class for the login views.\"\"\"",
            "",
            "    requires_auth = False",
            "",
            "    def __init__(",
            "        self,",
            "        flow_mgr: AuthManagerFlowManager,",
            "        store_result: StoreResultType,",
            "    ) -> None:",
            "        \"\"\"Initialize the flow manager index view.\"\"\"",
            "        self._flow_mgr = flow_mgr",
            "        self._store_result = store_result",
            "",
            "    async def _async_flow_result_to_response(",
            "        self,",
            "        request: web.Request,",
            "        client_id: str,",
            "        result: data_entry_flow.FlowResult,",
            "    ) -> web.Response:",
            "        \"\"\"Convert the flow result to a response.\"\"\"",
            "        if result[\"type\"] != data_entry_flow.FlowResultType.CREATE_ENTRY:",
            "            # @log_invalid_auth does not work here since it returns HTTP 200.",
            "            # We need to manually log failed login attempts.",
            "            if (",
            "                result[\"type\"] == data_entry_flow.FlowResultType.FORM",
            "                and (errors := result.get(\"errors\"))",
            "                and errors.get(\"base\")",
            "                in (",
            "                    \"invalid_auth\",",
            "                    \"invalid_code\",",
            "                )",
            "            ):",
            "                await process_wrong_login(request)",
            "            return self.json(_prepare_result_json(result))",
            "",
            "        hass: HomeAssistant = request.app[\"hass\"]",
            "",
            "        if not await indieauth.verify_redirect_uri(",
            "            hass, client_id, result[\"context\"][\"redirect_uri\"]",
            "        ):",
            "            return self.json_message(\"Invalid redirect URI\", HTTPStatus.FORBIDDEN)",
            "",
            "        result.pop(\"data\")",
            "        result.pop(\"context\")",
            "",
            "        result_obj: Credentials = result.pop(\"result\")",
            "",
            "        # Result can be None if credential was never linked to a user before.",
            "        user = await hass.auth.async_get_user_by_credentials(result_obj)",
            "",
            "        if user is not None and (",
            "            user_access_error := async_user_not_allowed_do_auth(hass, user)",
            "        ):",
            "            return self.json_message(",
            "                f\"Login blocked: {user_access_error}\", HTTPStatus.FORBIDDEN",
            "            )",
            "",
            "        process_success_login(request)",
            "        result[\"result\"] = self._store_result(client_id, result_obj)",
            "",
            "        return self.json(result)",
            "",
            "",
            "class LoginFlowIndexView(LoginFlowBaseView):",
            "    \"\"\"View to create a login flow.\"\"\"",
            "",
            "    url = \"/auth/login_flow\"",
            "    name = \"api:auth:login_flow\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Do not allow index of flows in progress.\"\"\"",
            "        return web.Response(status=HTTPStatus.METHOD_NOT_ALLOWED)",
            "",
            "    @RequestDataValidator(",
            "        vol.Schema(",
            "            {",
            "                vol.Required(\"client_id\"): str,",
            "                vol.Required(\"handler\"): vol.Any(str, list),",
            "                vol.Required(\"redirect_uri\"): str,",
            "                vol.Optional(\"type\", default=\"authorize\"): str,",
            "            }",
            "        )",
            "    )",
            "    @log_invalid_auth",
            "    async def post(self, request: web.Request, data: dict[str, Any]) -> web.Response:",
            "        \"\"\"Create a new login flow.\"\"\"",
            "        client_id: str = data[\"client_id\"]",
            "        redirect_uri: str = data[\"redirect_uri\"]",
            "",
            "        if not indieauth.verify_client_id(client_id):",
            "            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)",
            "",
            "        handler: tuple[str, ...] | str",
            "        if isinstance(data[\"handler\"], list):",
            "            handler = tuple(data[\"handler\"])",
            "        else:",
            "            handler = data[\"handler\"]",
            "",
            "        try:",
            "            result = await self._flow_mgr.async_init(",
            "                handler,  # type: ignore[arg-type]",
            "                context={",
            "                    \"ip_address\": ip_address(request.remote),  # type: ignore[arg-type]",
            "                    \"credential_only\": data.get(\"type\") == \"link_user\",",
            "                    \"redirect_uri\": redirect_uri,",
            "                },",
            "            )",
            "        except data_entry_flow.UnknownHandler:",
            "            return self.json_message(\"Invalid handler specified\", HTTPStatus.NOT_FOUND)",
            "        except data_entry_flow.UnknownStep:",
            "            return self.json_message(",
            "                \"Handler does not support init\", HTTPStatus.BAD_REQUEST",
            "            )",
            "",
            "        return await self._async_flow_result_to_response(request, client_id, result)",
            "",
            "",
            "class LoginFlowResourceView(LoginFlowBaseView):",
            "    \"\"\"View to interact with the flow manager.\"\"\"",
            "",
            "    url = \"/auth/login_flow/{flow_id}\"",
            "    name = \"api:auth:login_flow:resource\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Do not allow getting status of a flow in progress.\"\"\"",
            "        return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)",
            "",
            "    @RequestDataValidator(",
            "        vol.Schema(",
            "            {vol.Required(\"client_id\"): str},",
            "            extra=vol.ALLOW_EXTRA,",
            "        )",
            "    )",
            "    @log_invalid_auth",
            "    async def post(",
            "        self, request: web.Request, data: dict[str, Any], flow_id: str",
            "    ) -> web.Response:",
            "        \"\"\"Handle progressing a login flow request.\"\"\"",
            "        client_id: str = data.pop(\"client_id\")",
            "",
            "        if not indieauth.verify_client_id(client_id):",
            "            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)",
            "",
            "        try:",
            "            # do not allow change ip during login flow",
            "            flow = self._flow_mgr.async_get(flow_id)",
            "            if flow[\"context\"][\"ip_address\"] != ip_address(request.remote):  # type: ignore[arg-type]",
            "                return self.json_message(\"IP address changed\", HTTPStatus.BAD_REQUEST)",
            "            result = await self._flow_mgr.async_configure(flow_id, data)",
            "        except data_entry_flow.UnknownFlow:",
            "            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)",
            "        except vol.Invalid:",
            "            return self.json_message(\"User input malformed\", HTTPStatus.BAD_REQUEST)",
            "",
            "        return await self._async_flow_result_to_response(request, client_id, result)",
            "",
            "    async def delete(self, request: web.Request, flow_id: str) -> web.Response:",
            "        \"\"\"Cancel a flow in progress.\"\"\"",
            "        try:",
            "            self._flow_mgr.async_abort(flow_id)",
            "        except data_entry_flow.UnknownFlow:",
            "            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)",
            "",
            "        return self.json_message(\"Flow aborted\")"
        ],
        "afterPatchFile": [
            "\"\"\"HTTP views handle login flow.",
            "",
            "# GET /auth/providers",
            "",
            "Return a list of auth providers. Example:",
            "",
            "[",
            "    {",
            "        \"name\": \"Local\",",
            "        \"id\": null,",
            "        \"type\": \"local_provider\",",
            "    }",
            "]",
            "",
            "",
            "# POST /auth/login_flow",
            "",
            "Create a login flow. Will return the first step of the flow.",
            "",
            "Pass in parameter 'client_id' and 'redirect_url' validate by indieauth.",
            "",
            "Pass in parameter 'handler' to specify the auth provider to use. Auth providers",
            "are identified by type and id.",
            "",
            "And optional parameter 'type' has to set as 'link_user' if login flow used for",
            "link credential to exist user. Default 'type' is 'authorize'.",
            "",
            "{",
            "    \"client_id\": \"https://hassbian.local:8123/\",",
            "    \"handler\": [\"local_provider\", null],",
            "    \"redirect_url\": \"https://hassbian.local:8123/\",",
            "    \"type': \"authorize\"",
            "}",
            "",
            "Return value will be a step in a data entry flow. See the docs for data entry",
            "flow for details.",
            "",
            "{",
            "    \"data_schema\": [",
            "        {\"name\": \"username\", \"type\": \"string\"},",
            "        {\"name\": \"password\", \"type\": \"string\"}",
            "    ],",
            "    \"errors\": {},",
            "    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",",
            "    \"handler\": [\"insecure_example\", null],",
            "    \"step_id\": \"init\",",
            "    \"type\": \"form\"",
            "}",
            "",
            "",
            "# POST /auth/login_flow/{flow_id}",
            "",
            "Progress the flow. Most flows will be 1 page, but could optionally add extra",
            "login challenges, like TFA. Once the flow has finished, the returned step will",
            "have type FlowResultType.CREATE_ENTRY and \"result\" key will contain an authorization code.",
            "The authorization code associated with an authorized user by default, it will",
            "associate with an credential if \"type\" set to \"link_user\" in",
            "\"/auth/login_flow\"",
            "",
            "{",
            "    \"flow_id\": \"8f7e42faab604bcab7ac43c44ca34d58\",",
            "    \"handler\": [\"insecure_example\", null],",
            "    \"result\": \"411ee2f916e648d691e937ae9344681e\",",
            "    \"title\": \"Example\",",
            "    \"type\": \"create_entry\",",
            "    \"version\": 1",
            "}",
            "\"\"\"",
            "from __future__ import annotations",
            "",
            "from collections.abc import Callable",
            "from http import HTTPStatus",
            "from ipaddress import ip_address",
            "from typing import TYPE_CHECKING, Any, cast",
            "",
            "from aiohttp import web",
            "import voluptuous as vol",
            "import voluptuous_serialize",
            "",
            "from homeassistant import data_entry_flow",
            "from homeassistant.auth import AuthManagerFlowManager, InvalidAuthError",
            "from homeassistant.auth.models import Credentials",
            "from homeassistant.components import onboarding",
            "from homeassistant.components.http.auth import async_user_not_allowed_do_auth",
            "from homeassistant.components.http.ban import (",
            "    log_invalid_auth,",
            "    process_success_login,",
            "    process_wrong_login,",
            ")",
            "from homeassistant.components.http.data_validator import RequestDataValidator",
            "from homeassistant.components.http.view import HomeAssistantView",
            "from homeassistant.core import HomeAssistant",
            "from homeassistant.helpers.network import is_cloud_connection",
            "",
            "from . import indieauth",
            "",
            "if TYPE_CHECKING:",
            "    from homeassistant.auth.providers.trusted_networks import (",
            "        TrustedNetworksAuthProvider,",
            "    )",
            "",
            "    from . import StoreResultType",
            "",
            "",
            "async def async_setup(",
            "    hass: HomeAssistant, store_result: Callable[[str, Credentials], str]",
            ") -> None:",
            "    \"\"\"Component to allow users to login.\"\"\"",
            "    hass.http.register_view(WellKnownOAuthInfoView)",
            "    hass.http.register_view(AuthProvidersView)",
            "    hass.http.register_view(LoginFlowIndexView(hass.auth.login_flow, store_result))",
            "    hass.http.register_view(LoginFlowResourceView(hass.auth.login_flow, store_result))",
            "",
            "",
            "class WellKnownOAuthInfoView(HomeAssistantView):",
            "    \"\"\"View to host the OAuth2 information.\"\"\"",
            "",
            "    requires_auth = False",
            "    url = \"/.well-known/oauth-authorization-server\"",
            "    name = \"well-known/oauth-authorization-server\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Return the well known OAuth2 authorization info.\"\"\"",
            "        return self.json(",
            "            {",
            "                \"authorization_endpoint\": \"/auth/authorize\",",
            "                \"token_endpoint\": \"/auth/token\",",
            "                \"revocation_endpoint\": \"/auth/revoke\",",
            "                \"response_types_supported\": [\"code\"],",
            "                \"service_documentation\": (",
            "                    \"https://developers.home-assistant.io/docs/auth_api\"",
            "                ),",
            "            }",
            "        )",
            "",
            "",
            "class AuthProvidersView(HomeAssistantView):",
            "    \"\"\"View to get available auth providers.\"\"\"",
            "",
            "    url = \"/auth/providers\"",
            "    name = \"api:auth:providers\"",
            "    requires_auth = False",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Get available auth providers.\"\"\"",
            "        hass: HomeAssistant = request.app[\"hass\"]",
            "        if not onboarding.async_is_user_onboarded(hass):",
            "            return self.json_message(",
            "                message=\"Onboarding not finished\",",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                message_code=\"onboarding_required\",",
            "            )",
            "",
            "        try:",
            "            remote_address = ip_address(request.remote)  # type: ignore[arg-type]",
            "        except ValueError:",
            "            return self.json_message(",
            "                message=\"Invalid remote IP\",",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                message_code=\"invalid_remote_ip\",",
            "            )",
            "",
            "        cloud_connection = is_cloud_connection(hass)",
            "",
            "        providers = []",
            "        for provider in hass.auth.auth_providers:",
            "            if provider.type == \"trusted_networks\":",
            "                if cloud_connection:",
            "                    # Skip quickly as trusted networks are not available on cloud",
            "                    continue",
            "",
            "                try:",
            "                    cast(\"TrustedNetworksAuthProvider\", provider).async_validate_access(",
            "                        remote_address",
            "                    )",
            "                except InvalidAuthError:",
            "                    # Not a trusted network, so we don't expose that trusted_network authenticator is setup",
            "                    continue",
            "",
            "            providers.append(",
            "                {",
            "                    \"name\": provider.name,",
            "                    \"id\": provider.id,",
            "                    \"type\": provider.type,",
            "                }",
            "            )",
            "",
            "        return self.json(providers)",
            "",
            "",
            "def _prepare_result_json(",
            "    result: data_entry_flow.FlowResult,",
            ") -> data_entry_flow.FlowResult:",
            "    \"\"\"Convert result to JSON.\"\"\"",
            "    if result[\"type\"] == data_entry_flow.FlowResultType.CREATE_ENTRY:",
            "        data = result.copy()",
            "        data.pop(\"result\")",
            "        data.pop(\"data\")",
            "        return data",
            "",
            "    if result[\"type\"] != data_entry_flow.FlowResultType.FORM:",
            "        return result",
            "",
            "    data = result.copy()",
            "",
            "    if (schema := data[\"data_schema\"]) is None:",
            "        data[\"data_schema\"] = []",
            "    else:",
            "        data[\"data_schema\"] = voluptuous_serialize.convert(schema)",
            "",
            "    return data",
            "",
            "",
            "class LoginFlowBaseView(HomeAssistantView):",
            "    \"\"\"Base class for the login views.\"\"\"",
            "",
            "    requires_auth = False",
            "",
            "    def __init__(",
            "        self,",
            "        flow_mgr: AuthManagerFlowManager,",
            "        store_result: StoreResultType,",
            "    ) -> None:",
            "        \"\"\"Initialize the flow manager index view.\"\"\"",
            "        self._flow_mgr = flow_mgr",
            "        self._store_result = store_result",
            "",
            "    async def _async_flow_result_to_response(",
            "        self,",
            "        request: web.Request,",
            "        client_id: str,",
            "        result: data_entry_flow.FlowResult,",
            "    ) -> web.Response:",
            "        \"\"\"Convert the flow result to a response.\"\"\"",
            "        if result[\"type\"] != data_entry_flow.FlowResultType.CREATE_ENTRY:",
            "            # @log_invalid_auth does not work here since it returns HTTP 200.",
            "            # We need to manually log failed login attempts.",
            "            if (",
            "                result[\"type\"] == data_entry_flow.FlowResultType.FORM",
            "                and (errors := result.get(\"errors\"))",
            "                and errors.get(\"base\")",
            "                in (",
            "                    \"invalid_auth\",",
            "                    \"invalid_code\",",
            "                )",
            "            ):",
            "                await process_wrong_login(request)",
            "            return self.json(_prepare_result_json(result))",
            "",
            "        hass: HomeAssistant = request.app[\"hass\"]",
            "",
            "        if not await indieauth.verify_redirect_uri(",
            "            hass, client_id, result[\"context\"][\"redirect_uri\"]",
            "        ):",
            "            return self.json_message(\"Invalid redirect URI\", HTTPStatus.FORBIDDEN)",
            "",
            "        result.pop(\"data\")",
            "        result.pop(\"context\")",
            "",
            "        result_obj: Credentials = result.pop(\"result\")",
            "",
            "        # Result can be None if credential was never linked to a user before.",
            "        user = await hass.auth.async_get_user_by_credentials(result_obj)",
            "",
            "        if user is not None and (",
            "            user_access_error := async_user_not_allowed_do_auth(hass, user)",
            "        ):",
            "            return self.json_message(",
            "                f\"Login blocked: {user_access_error}\", HTTPStatus.FORBIDDEN",
            "            )",
            "",
            "        process_success_login(request)",
            "        result[\"result\"] = self._store_result(client_id, result_obj)",
            "",
            "        return self.json(result)",
            "",
            "",
            "class LoginFlowIndexView(LoginFlowBaseView):",
            "    \"\"\"View to create a login flow.\"\"\"",
            "",
            "    url = \"/auth/login_flow\"",
            "    name = \"api:auth:login_flow\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Do not allow index of flows in progress.\"\"\"",
            "        return web.Response(status=HTTPStatus.METHOD_NOT_ALLOWED)",
            "",
            "    @RequestDataValidator(",
            "        vol.Schema(",
            "            {",
            "                vol.Required(\"client_id\"): str,",
            "                vol.Required(\"handler\"): vol.Any(str, list),",
            "                vol.Required(\"redirect_uri\"): str,",
            "                vol.Optional(\"type\", default=\"authorize\"): str,",
            "            }",
            "        )",
            "    )",
            "    @log_invalid_auth",
            "    async def post(self, request: web.Request, data: dict[str, Any]) -> web.Response:",
            "        \"\"\"Create a new login flow.\"\"\"",
            "        client_id: str = data[\"client_id\"]",
            "        redirect_uri: str = data[\"redirect_uri\"]",
            "",
            "        if not indieauth.verify_client_id(client_id):",
            "            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)",
            "",
            "        handler: tuple[str, ...] | str",
            "        if isinstance(data[\"handler\"], list):",
            "            handler = tuple(data[\"handler\"])",
            "        else:",
            "            handler = data[\"handler\"]",
            "",
            "        try:",
            "            result = await self._flow_mgr.async_init(",
            "                handler,  # type: ignore[arg-type]",
            "                context={",
            "                    \"ip_address\": ip_address(request.remote),  # type: ignore[arg-type]",
            "                    \"credential_only\": data.get(\"type\") == \"link_user\",",
            "                    \"redirect_uri\": redirect_uri,",
            "                },",
            "            )",
            "        except data_entry_flow.UnknownHandler:",
            "            return self.json_message(\"Invalid handler specified\", HTTPStatus.NOT_FOUND)",
            "        except data_entry_flow.UnknownStep:",
            "            return self.json_message(",
            "                \"Handler does not support init\", HTTPStatus.BAD_REQUEST",
            "            )",
            "",
            "        return await self._async_flow_result_to_response(request, client_id, result)",
            "",
            "",
            "class LoginFlowResourceView(LoginFlowBaseView):",
            "    \"\"\"View to interact with the flow manager.\"\"\"",
            "",
            "    url = \"/auth/login_flow/{flow_id}\"",
            "    name = \"api:auth:login_flow:resource\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Do not allow getting status of a flow in progress.\"\"\"",
            "        return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)",
            "",
            "    @RequestDataValidator(",
            "        vol.Schema(",
            "            {vol.Required(\"client_id\"): str},",
            "            extra=vol.ALLOW_EXTRA,",
            "        )",
            "    )",
            "    @log_invalid_auth",
            "    async def post(",
            "        self, request: web.Request, data: dict[str, Any], flow_id: str",
            "    ) -> web.Response:",
            "        \"\"\"Handle progressing a login flow request.\"\"\"",
            "        client_id: str = data.pop(\"client_id\")",
            "",
            "        if not indieauth.verify_client_id(client_id):",
            "            return self.json_message(\"Invalid client id\", HTTPStatus.BAD_REQUEST)",
            "",
            "        try:",
            "            # do not allow change ip during login flow",
            "            flow = self._flow_mgr.async_get(flow_id)",
            "            if flow[\"context\"][\"ip_address\"] != ip_address(request.remote):  # type: ignore[arg-type]",
            "                return self.json_message(\"IP address changed\", HTTPStatus.BAD_REQUEST)",
            "            result = await self._flow_mgr.async_configure(flow_id, data)",
            "        except data_entry_flow.UnknownFlow:",
            "            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)",
            "        except vol.Invalid:",
            "            return self.json_message(\"User input malformed\", HTTPStatus.BAD_REQUEST)",
            "",
            "        return await self._async_flow_result_to_response(request, client_id, result)",
            "",
            "    async def delete(self, request: web.Request, flow_id: str) -> web.Response:",
            "        \"\"\"Cancel a flow in progress.\"\"\"",
            "        try:",
            "            self._flow_mgr.async_abort(flow_id)",
            "        except data_entry_flow.UnknownFlow:",
            "            return self.json_message(\"Invalid flow specified\", HTTPStatus.NOT_FOUND)",
            "",
            "        return self.json_message(\"Flow aborted\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "94": [],
            "168": [
                "AuthProvidersView"
            ],
            "169": [
                "AuthProvidersView"
            ],
            "182": [
                "AuthProvidersView"
            ],
            "183": [
                "AuthProvidersView"
            ],
            "184": [
                "AuthProvidersView"
            ],
            "185": [
                "AuthProvidersView"
            ],
            "186": [
                "AuthProvidersView"
            ],
            "187": [
                "AuthProvidersView"
            ],
            "188": [
                "AuthProvidersView"
            ],
            "189": [
                "AuthProvidersView"
            ],
            "190": [
                "AuthProvidersView"
            ],
            "191": [
                "AuthProvidersView"
            ],
            "192": [
                "AuthProvidersView"
            ],
            "193": [
                "AuthProvidersView"
            ],
            "194": [
                "AuthProvidersView"
            ],
            "195": [
                "AuthProvidersView"
            ],
            "196": [
                "AuthProvidersView"
            ],
            "197": [
                "AuthProvidersView"
            ],
            "198": [
                "AuthProvidersView"
            ],
            "205": [
                "AuthProvidersView"
            ]
        },
        "addLocation": []
    },
    "homeassistant/components/person/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from __future__ import annotations"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from http import HTTPStatus"
            },
            "3": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ipaddress import ip_address"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import logging"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from typing import Any"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " )"
            },
            "8": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " from homeassistant.helpers.entity_component import EntityComponent"
            },
            "9": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " from homeassistant.helpers.event import async_track_state_change_event"
            },
            "10": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from homeassistant.helpers.network import is_cloud_connection"
            },
            "11": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " from homeassistant.helpers.restore_state import RestoreEntity"
            },
            "12": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " from homeassistant.helpers.storage import Store"
            },
            "13": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " from homeassistant.helpers.typing import ConfigType"
            },
            "14": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " from homeassistant.loader import bind_hass"
            },
            "15": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from homeassistant.util.network import is_local"
            },
            "16": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " _LOGGER = logging.getLogger(__name__)"
            },
            "18": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 585,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 586,
                "PatchRowcode": "     async def get(self, request: web.Request) -> web.Response:"
            },
            "21": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": 587,
                "PatchRowcode": "         \"\"\"Return a list of persons if request comes from a local IP.\"\"\""
            },
            "22": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "23": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            remote_address = ip_address(request.remote)  # type: ignore[arg-type]"
            },
            "24": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except ValueError:"
            },
            "25": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.json_message("
            },
            "26": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                message=\"Invalid remote IP\","
            },
            "27": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                status_code=HTTPStatus.BAD_REQUEST,"
            },
            "28": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                message_code=\"invalid_remote_ip\","
            },
            "29": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "30": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "31": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        hass: HomeAssistant = request.app[\"hass\"]"
            },
            "32": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if is_cloud_connection(hass) or not is_local(remote_address):"
            },
            "33": {
                "beforePatchRowNumber": 602,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self.json_message("
            },
            "34": {
                "beforePatchRowNumber": 603,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                message=\"Not local\","
            },
            "35": {
                "beforePatchRowNumber": 604,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                status_code=HTTPStatus.BAD_REQUEST,"
            },
            "36": {
                "beforePatchRowNumber": 605,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                message_code=\"not_local\","
            },
            "37": {
                "beforePatchRowNumber": 606,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "38": {
                "beforePatchRowNumber": 607,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 608,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        yaml, storage, _ = hass.data[DOMAIN]"
            },
            "40": {
                "beforePatchRowNumber": 609,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        persons = [*yaml.async_items(), *storage.async_items()]"
            },
            "41": {
                "beforePatchRowNumber": 610,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "42": {
                "beforePatchRowNumber": 611,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.json("
            },
            "43": {
                "beforePatchRowNumber": 612,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            {"
            },
            "44": {
                "beforePatchRowNumber": 613,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                person[ATTR_USER_ID]: {"
            },
            "45": {
                "beforePatchRowNumber": 614,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    ATTR_NAME: person[ATTR_NAME],"
            },
            "46": {
                "beforePatchRowNumber": 615,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    CONF_PICTURE: person.get(CONF_PICTURE),"
            },
            "47": {
                "beforePatchRowNumber": 616,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                }"
            },
            "48": {
                "beforePatchRowNumber": 617,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                for person in persons"
            },
            "49": {
                "beforePatchRowNumber": 618,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if person.get(ATTR_USER_ID)"
            },
            "50": {
                "beforePatchRowNumber": 619,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            }"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 588,
                "PatchRowcode": "+        return self.json_message("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 589,
                "PatchRowcode": "+            message=\"Not local\","
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 590,
                "PatchRowcode": "+            status_code=HTTPStatus.BAD_REQUEST,"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 591,
                "PatchRowcode": "+            message_code=\"not_local\","
            },
            "55": {
                "beforePatchRowNumber": 620,
                "afterPatchRowNumber": 592,
                "PatchRowcode": "         )"
            }
        },
        "frontPatchFile": [
            "\"\"\"Support for tracking people.\"\"\"",
            "from __future__ import annotations",
            "",
            "from http import HTTPStatus",
            "from ipaddress import ip_address",
            "import logging",
            "from typing import Any",
            "",
            "from aiohttp import web",
            "import voluptuous as vol",
            "",
            "from homeassistant.auth import EVENT_USER_REMOVED",
            "from homeassistant.components import persistent_notification, websocket_api",
            "from homeassistant.components.device_tracker import (",
            "    ATTR_SOURCE_TYPE,",
            "    DOMAIN as DEVICE_TRACKER_DOMAIN,",
            "    SourceType,",
            ")",
            "from homeassistant.components.http.view import HomeAssistantView",
            "from homeassistant.const import (",
            "    ATTR_EDITABLE,",
            "    ATTR_ENTITY_ID,",
            "    ATTR_GPS_ACCURACY,",
            "    ATTR_ID,",
            "    ATTR_LATITUDE,",
            "    ATTR_LONGITUDE,",
            "    ATTR_NAME,",
            "    CONF_ID,",
            "    CONF_NAME,",
            "    CONF_TYPE,",
            "    EVENT_HOMEASSISTANT_START,",
            "    SERVICE_RELOAD,",
            "    STATE_HOME,",
            "    STATE_NOT_HOME,",
            "    STATE_UNAVAILABLE,",
            "    STATE_UNKNOWN,",
            ")",
            "from homeassistant.core import (",
            "    Event,",
            "    HomeAssistant,",
            "    ServiceCall,",
            "    State,",
            "    callback,",
            "    split_entity_id,",
            ")",
            "from homeassistant.helpers import (",
            "    collection,",
            "    config_validation as cv,",
            "    entity_registry as er,",
            "    service,",
            ")",
            "from homeassistant.helpers.entity_component import EntityComponent",
            "from homeassistant.helpers.event import async_track_state_change_event",
            "from homeassistant.helpers.network import is_cloud_connection",
            "from homeassistant.helpers.restore_state import RestoreEntity",
            "from homeassistant.helpers.storage import Store",
            "from homeassistant.helpers.typing import ConfigType",
            "from homeassistant.loader import bind_hass",
            "from homeassistant.util.network import is_local",
            "",
            "_LOGGER = logging.getLogger(__name__)",
            "",
            "ATTR_SOURCE = \"source\"",
            "ATTR_USER_ID = \"user_id\"",
            "ATTR_DEVICE_TRACKERS = \"device_trackers\"",
            "",
            "CONF_DEVICE_TRACKERS = \"device_trackers\"",
            "CONF_USER_ID = \"user_id\"",
            "CONF_PICTURE = \"picture\"",
            "",
            "DOMAIN = \"person\"",
            "",
            "STORAGE_KEY = DOMAIN",
            "STORAGE_VERSION = 2",
            "# Device tracker states to ignore",
            "IGNORE_STATES = (STATE_UNKNOWN, STATE_UNAVAILABLE)",
            "",
            "PERSON_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Required(CONF_ID): cv.string,",
            "        vol.Required(CONF_NAME): cv.string,",
            "        vol.Optional(CONF_USER_ID): cv.string,",
            "        vol.Optional(CONF_DEVICE_TRACKERS, default=[]): vol.All(",
            "            cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)",
            "        ),",
            "        vol.Optional(CONF_PICTURE): cv.string,",
            "    }",
            ")",
            "",
            "CONFIG_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Optional(DOMAIN, default=[]): vol.All(",
            "            cv.ensure_list, cv.remove_falsy, [PERSON_SCHEMA]",
            "        )",
            "    },",
            "    extra=vol.ALLOW_EXTRA,",
            ")",
            "",
            "",
            "@bind_hass",
            "async def async_create_person(hass, name, *, user_id=None, device_trackers=None):",
            "    \"\"\"Create a new person.\"\"\"",
            "    await hass.data[DOMAIN][1].async_create_item(",
            "        {",
            "            ATTR_NAME: name,",
            "            ATTR_USER_ID: user_id,",
            "            CONF_DEVICE_TRACKERS: device_trackers or [],",
            "        }",
            "    )",
            "",
            "",
            "@bind_hass",
            "async def async_add_user_device_tracker(",
            "    hass: HomeAssistant, user_id: str, device_tracker_entity_id: str",
            "):",
            "    \"\"\"Add a device tracker to a person linked to a user.\"\"\"",
            "    coll: PersonStorageCollection = hass.data[DOMAIN][1]",
            "",
            "    for person in coll.async_items():",
            "        if person.get(ATTR_USER_ID) != user_id:",
            "            continue",
            "",
            "        device_trackers = person[CONF_DEVICE_TRACKERS]",
            "",
            "        if device_tracker_entity_id in device_trackers:",
            "            return",
            "",
            "        await coll.async_update_item(",
            "            person[CONF_ID],",
            "            {CONF_DEVICE_TRACKERS: device_trackers + [device_tracker_entity_id]},",
            "        )",
            "        break",
            "",
            "",
            "@callback",
            "def persons_with_entity(hass: HomeAssistant, entity_id: str) -> list[str]:",
            "    \"\"\"Return all persons that reference the entity.\"\"\"",
            "    if (",
            "        DOMAIN not in hass.data",
            "        or split_entity_id(entity_id)[0] != DEVICE_TRACKER_DOMAIN",
            "    ):",
            "        return []",
            "",
            "    component: EntityComponent[Person] = hass.data[DOMAIN][2]",
            "",
            "    return [",
            "        person_entity.entity_id",
            "        for person_entity in component.entities",
            "        if entity_id in person_entity.device_trackers",
            "    ]",
            "",
            "",
            "@callback",
            "def entities_in_person(hass: HomeAssistant, entity_id: str) -> list[str]:",
            "    \"\"\"Return all entities belonging to a person.\"\"\"",
            "    if DOMAIN not in hass.data:",
            "        return []",
            "",
            "    component: EntityComponent[Person] = hass.data[DOMAIN][2]",
            "",
            "    if (person_entity := component.get_entity(entity_id)) is None:",
            "        return []",
            "",
            "    return person_entity.device_trackers",
            "",
            "",
            "CREATE_FIELDS = {",
            "    vol.Required(CONF_NAME): vol.All(str, vol.Length(min=1)),",
            "    vol.Optional(CONF_USER_ID): vol.Any(str, None),",
            "    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(",
            "        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)",
            "    ),",
            "    vol.Optional(CONF_PICTURE): vol.Any(str, None),",
            "}",
            "",
            "",
            "UPDATE_FIELDS = {",
            "    vol.Optional(CONF_NAME): vol.All(str, vol.Length(min=1)),",
            "    vol.Optional(CONF_USER_ID): vol.Any(str, None),",
            "    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(",
            "        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)",
            "    ),",
            "    vol.Optional(CONF_PICTURE): vol.Any(str, None),",
            "}",
            "",
            "",
            "class PersonStore(Store):",
            "    \"\"\"Person storage.\"\"\"",
            "",
            "    async def _async_migrate_func(self, old_major_version, old_minor_version, old_data):",
            "        \"\"\"Migrate to the new version.",
            "",
            "        Migrate storage to use format of collection helper.",
            "        \"\"\"",
            "        return {\"items\": old_data[\"persons\"]}",
            "",
            "",
            "class PersonStorageCollection(collection.DictStorageCollection):",
            "    \"\"\"Person collection stored in storage.\"\"\"",
            "",
            "    CREATE_SCHEMA = vol.Schema(CREATE_FIELDS)",
            "    UPDATE_SCHEMA = vol.Schema(UPDATE_FIELDS)",
            "",
            "    def __init__(",
            "        self,",
            "        store: Store,",
            "        id_manager: collection.IDManager,",
            "        yaml_collection: collection.YamlCollection,",
            "    ) -> None:",
            "        \"\"\"Initialize a person storage collection.\"\"\"",
            "        super().__init__(store, id_manager)",
            "        self.yaml_collection = yaml_collection",
            "",
            "    async def _async_load_data(self) -> collection.SerializedStorageCollection | None:",
            "        \"\"\"Load the data.",
            "",
            "        A past bug caused onboarding to create invalid person objects.",
            "        This patches it up.",
            "        \"\"\"",
            "        data = await super()._async_load_data()",
            "",
            "        if data is None:",
            "            return data",
            "",
            "        for person in data[\"items\"]:",
            "            if person[CONF_DEVICE_TRACKERS] is None:",
            "                person[CONF_DEVICE_TRACKERS] = []",
            "",
            "        return data",
            "",
            "    async def async_load(self) -> None:",
            "        \"\"\"Load the Storage collection.\"\"\"",
            "        await super().async_load()",
            "        self.hass.bus.async_listen(",
            "            er.EVENT_ENTITY_REGISTRY_UPDATED,",
            "            self._entity_registry_updated,",
            "            event_filter=self._entity_registry_filter,",
            "        )",
            "",
            "    @callback",
            "    def _entity_registry_filter(self, event: Event) -> bool:",
            "        \"\"\"Filter entity registry events.\"\"\"",
            "        return (",
            "            event.data[\"action\"] == \"remove\"",
            "            and split_entity_id(event.data[ATTR_ENTITY_ID])[0] == \"device_tracker\"",
            "        )",
            "",
            "    async def _entity_registry_updated(self, event: Event) -> None:",
            "        \"\"\"Handle entity registry updated.\"\"\"",
            "        entity_id = event.data[ATTR_ENTITY_ID]",
            "        for person in list(self.data.values()):",
            "            if entity_id not in person[CONF_DEVICE_TRACKERS]:",
            "                continue",
            "",
            "            await self.async_update_item(",
            "                person[CONF_ID],",
            "                {",
            "                    CONF_DEVICE_TRACKERS: [",
            "                        devt",
            "                        for devt in person[CONF_DEVICE_TRACKERS]",
            "                        if devt != entity_id",
            "                    ]",
            "                },",
            "            )",
            "",
            "    async def _process_create_data(self, data: dict) -> dict:",
            "        \"\"\"Validate the config is valid.\"\"\"",
            "        data = self.CREATE_SCHEMA(data)",
            "",
            "        if (user_id := data.get(CONF_USER_ID)) is not None:",
            "            await self._validate_user_id(user_id)",
            "",
            "        return data",
            "",
            "    @callback",
            "    def _get_suggested_id(self, info: dict) -> str:",
            "        \"\"\"Suggest an ID based on the config.\"\"\"",
            "        return info[CONF_NAME]",
            "",
            "    async def _update_data(self, item: dict, update_data: dict) -> dict:",
            "        \"\"\"Return a new updated data object.\"\"\"",
            "        update_data = self.UPDATE_SCHEMA(update_data)",
            "",
            "        user_id = update_data.get(CONF_USER_ID)",
            "",
            "        if user_id is not None and user_id != item.get(CONF_USER_ID):",
            "            await self._validate_user_id(user_id)",
            "",
            "        return {**item, **update_data}",
            "",
            "    async def _validate_user_id(self, user_id):",
            "        \"\"\"Validate the used user_id.\"\"\"",
            "        if await self.hass.auth.async_get_user(user_id) is None:",
            "            raise ValueError(\"User does not exist\")",
            "",
            "        for persons in (self.data.values(), self.yaml_collection.async_items()):",
            "            if any(person for person in persons if person.get(CONF_USER_ID) == user_id):",
            "                raise ValueError(\"User already taken\")",
            "",
            "",
            "async def filter_yaml_data(hass: HomeAssistant, persons: list[dict]) -> list[dict]:",
            "    \"\"\"Validate YAML data that we can't validate via schema.\"\"\"",
            "    filtered = []",
            "    person_invalid_user = []",
            "",
            "    for person_conf in persons:",
            "        user_id = person_conf.get(CONF_USER_ID)",
            "",
            "        if user_id is not None and await hass.auth.async_get_user(user_id) is None:",
            "            _LOGGER.error(",
            "                \"Invalid user_id detected for person %s\",",
            "                person_conf[CONF_ID],",
            "            )",
            "            person_invalid_user.append(",
            "                f\"- Person {person_conf[CONF_NAME]} (id: {person_conf[CONF_ID]}) points\"",
            "                f\" at invalid user {user_id}\"",
            "            )",
            "            continue",
            "",
            "        filtered.append(person_conf)",
            "",
            "    if person_invalid_user:",
            "        persistent_notification.async_create(",
            "            hass,",
            "            f\"\"\"",
            "The following persons point at invalid users:",
            "",
            "{\"- \".join(person_invalid_user)}",
            "            \"\"\",",
            "            \"Invalid Person Configuration\",",
            "            DOMAIN,",
            "        )",
            "",
            "    return filtered",
            "",
            "",
            "async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:",
            "    \"\"\"Set up the person component.\"\"\"",
            "    entity_component = EntityComponent[Person](_LOGGER, DOMAIN, hass)",
            "    id_manager = collection.IDManager()",
            "    yaml_collection = collection.YamlCollection(",
            "        logging.getLogger(f\"{__name__}.yaml_collection\"), id_manager",
            "    )",
            "    storage_collection = PersonStorageCollection(",
            "        PersonStore(hass, STORAGE_VERSION, STORAGE_KEY),",
            "        id_manager,",
            "        yaml_collection,",
            "    )",
            "",
            "    collection.sync_entity_lifecycle(",
            "        hass, DOMAIN, DOMAIN, entity_component, yaml_collection, Person",
            "    )",
            "    collection.sync_entity_lifecycle(",
            "        hass, DOMAIN, DOMAIN, entity_component, storage_collection, Person",
            "    )",
            "",
            "    await yaml_collection.async_load(",
            "        await filter_yaml_data(hass, config.get(DOMAIN, []))",
            "    )",
            "    await storage_collection.async_load()",
            "",
            "    hass.data[DOMAIN] = (yaml_collection, storage_collection, entity_component)",
            "",
            "    collection.DictStorageCollectionWebsocket(",
            "        storage_collection, DOMAIN, DOMAIN, CREATE_FIELDS, UPDATE_FIELDS",
            "    ).async_setup(hass, create_list=False)",
            "",
            "    websocket_api.async_register_command(hass, ws_list_person)",
            "",
            "    async def _handle_user_removed(event: Event) -> None:",
            "        \"\"\"Handle a user being removed.\"\"\"",
            "        user_id = event.data[ATTR_USER_ID]",
            "        for person in storage_collection.async_items():",
            "            if person[CONF_USER_ID] == user_id:",
            "                await storage_collection.async_update_item(",
            "                    person[CONF_ID], {CONF_USER_ID: None}",
            "                )",
            "",
            "    hass.bus.async_listen(EVENT_USER_REMOVED, _handle_user_removed)",
            "",
            "    async def async_reload_yaml(call: ServiceCall) -> None:",
            "        \"\"\"Reload YAML.\"\"\"",
            "        conf = await entity_component.async_prepare_reload(skip_reset=True)",
            "        if conf is None:",
            "            return",
            "        await yaml_collection.async_load(",
            "            await filter_yaml_data(hass, conf.get(DOMAIN, []))",
            "        )",
            "",
            "    service.async_register_admin_service(",
            "        hass, DOMAIN, SERVICE_RELOAD, async_reload_yaml",
            "    )",
            "",
            "    hass.http.register_view(ListPersonsView)",
            "",
            "    return True",
            "",
            "",
            "class Person(collection.CollectionEntity, RestoreEntity):",
            "    \"\"\"Represent a tracked person.\"\"\"",
            "",
            "    _entity_component_unrecorded_attributes = frozenset({ATTR_DEVICE_TRACKERS})",
            "",
            "    _attr_should_poll = False",
            "    editable: bool",
            "",
            "    def __init__(self, config):",
            "        \"\"\"Set up person.\"\"\"",
            "        self._config = config",
            "        self._latitude = None",
            "        self._longitude = None",
            "        self._gps_accuracy = None",
            "        self._source = None",
            "        self._state = None",
            "        self._unsub_track_device = None",
            "",
            "    @classmethod",
            "    def from_storage(cls, config: ConfigType):",
            "        \"\"\"Return entity instance initialized from storage.\"\"\"",
            "        person = cls(config)",
            "        person.editable = True",
            "        return person",
            "",
            "    @classmethod",
            "    def from_yaml(cls, config: ConfigType):",
            "        \"\"\"Return entity instance initialized from yaml.\"\"\"",
            "        person = cls(config)",
            "        person.editable = False",
            "        return person",
            "",
            "    @property",
            "    def name(self):",
            "        \"\"\"Return the name of the entity.\"\"\"",
            "        return self._config[CONF_NAME]",
            "",
            "    @property",
            "    def entity_picture(self) -> str | None:",
            "        \"\"\"Return entity picture.\"\"\"",
            "        return self._config.get(CONF_PICTURE)",
            "",
            "    @property",
            "    def state(self):",
            "        \"\"\"Return the state of the person.\"\"\"",
            "        return self._state",
            "",
            "    @property",
            "    def extra_state_attributes(self):",
            "        \"\"\"Return the state attributes of the person.\"\"\"",
            "        data = {ATTR_EDITABLE: self.editable, ATTR_ID: self.unique_id}",
            "        if self._latitude is not None:",
            "            data[ATTR_LATITUDE] = self._latitude",
            "        if self._longitude is not None:",
            "            data[ATTR_LONGITUDE] = self._longitude",
            "        if self._gps_accuracy is not None:",
            "            data[ATTR_GPS_ACCURACY] = self._gps_accuracy",
            "        if self._source is not None:",
            "            data[ATTR_SOURCE] = self._source",
            "        if (user_id := self._config.get(CONF_USER_ID)) is not None:",
            "            data[ATTR_USER_ID] = user_id",
            "        data[ATTR_DEVICE_TRACKERS] = self.device_trackers",
            "        return data",
            "",
            "    @property",
            "    def unique_id(self):",
            "        \"\"\"Return a unique ID for the person.\"\"\"",
            "        return self._config[CONF_ID]",
            "",
            "    @property",
            "    def device_trackers(self):",
            "        \"\"\"Return the device trackers for the person.\"\"\"",
            "        return self._config[CONF_DEVICE_TRACKERS]",
            "",
            "    async def async_added_to_hass(self):",
            "        \"\"\"Register device trackers.\"\"\"",
            "        await super().async_added_to_hass()",
            "        if state := await self.async_get_last_state():",
            "            self._parse_source_state(state)",
            "",
            "        if self.hass.is_running:",
            "            # Update person now if hass is already running.",
            "            await self.async_update_config(self._config)",
            "        else:",
            "            # Wait for hass start to not have race between person",
            "            # and device trackers finishing setup.",
            "            async def person_start_hass(now):",
            "                await self.async_update_config(self._config)",
            "",
            "            self.hass.bus.async_listen_once(",
            "                EVENT_HOMEASSISTANT_START, person_start_hass",
            "            )",
            "",
            "    async def async_update_config(self, config: ConfigType):",
            "        \"\"\"Handle when the config is updated.\"\"\"",
            "        self._config = config",
            "",
            "        if self._unsub_track_device is not None:",
            "            self._unsub_track_device()",
            "            self._unsub_track_device = None",
            "",
            "        if trackers := self._config[CONF_DEVICE_TRACKERS]:",
            "            _LOGGER.debug(\"Subscribe to device trackers for %s\", self.entity_id)",
            "",
            "            self._unsub_track_device = async_track_state_change_event(",
            "                self.hass, trackers, self._async_handle_tracker_update",
            "            )",
            "",
            "        self._update_state()",
            "",
            "    @callback",
            "    def _async_handle_tracker_update(self, event):",
            "        \"\"\"Handle the device tracker state changes.\"\"\"",
            "        self._update_state()",
            "",
            "    @callback",
            "    def _update_state(self):",
            "        \"\"\"Update the state.\"\"\"",
            "        latest_non_gps_home = latest_not_home = latest_gps = latest = None",
            "        for entity_id in self._config[CONF_DEVICE_TRACKERS]:",
            "            state = self.hass.states.get(entity_id)",
            "",
            "            if not state or state.state in IGNORE_STATES:",
            "                continue",
            "",
            "            if state.attributes.get(ATTR_SOURCE_TYPE) == SourceType.GPS:",
            "                latest_gps = _get_latest(latest_gps, state)",
            "            elif state.state == STATE_HOME:",
            "                latest_non_gps_home = _get_latest(latest_non_gps_home, state)",
            "            elif state.state == STATE_NOT_HOME:",
            "                latest_not_home = _get_latest(latest_not_home, state)",
            "",
            "        if latest_non_gps_home:",
            "            latest = latest_non_gps_home",
            "        elif latest_gps:",
            "            latest = latest_gps",
            "        else:",
            "            latest = latest_not_home",
            "",
            "        if latest:",
            "            self._parse_source_state(latest)",
            "        else:",
            "            self._state = None",
            "            self._source = None",
            "            self._latitude = None",
            "            self._longitude = None",
            "            self._gps_accuracy = None",
            "",
            "        self.async_write_ha_state()",
            "",
            "    @callback",
            "    def _parse_source_state(self, state):",
            "        \"\"\"Parse source state and set person attributes.",
            "",
            "        This is a device tracker state or the restored person state.",
            "        \"\"\"",
            "        self._state = state.state",
            "        self._source = state.entity_id",
            "        self._latitude = state.attributes.get(ATTR_LATITUDE)",
            "        self._longitude = state.attributes.get(ATTR_LONGITUDE)",
            "        self._gps_accuracy = state.attributes.get(ATTR_GPS_ACCURACY)",
            "",
            "",
            "@websocket_api.websocket_command({vol.Required(CONF_TYPE): \"person/list\"})",
            "def ws_list_person(",
            "    hass: HomeAssistant,",
            "    connection: websocket_api.ActiveConnection,",
            "    msg: dict[str, Any],",
            ") -> None:",
            "    \"\"\"List persons.\"\"\"",
            "    yaml, storage, _ = hass.data[DOMAIN]",
            "    connection.send_result(",
            "        msg[ATTR_ID], {\"storage\": storage.async_items(), \"config\": yaml.async_items()}",
            "    )",
            "",
            "",
            "def _get_latest(prev: State | None, curr: State):",
            "    \"\"\"Get latest state.\"\"\"",
            "    if prev is None or curr.last_updated > prev.last_updated:",
            "        return curr",
            "    return prev",
            "",
            "",
            "class ListPersonsView(HomeAssistantView):",
            "    \"\"\"List all persons if request is made from a local network.\"\"\"",
            "",
            "    requires_auth = False",
            "    url = \"/api/person/list\"",
            "    name = \"api:person:list\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Return a list of persons if request comes from a local IP.\"\"\"",
            "        try:",
            "            remote_address = ip_address(request.remote)  # type: ignore[arg-type]",
            "        except ValueError:",
            "            return self.json_message(",
            "                message=\"Invalid remote IP\",",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                message_code=\"invalid_remote_ip\",",
            "            )",
            "",
            "        hass: HomeAssistant = request.app[\"hass\"]",
            "        if is_cloud_connection(hass) or not is_local(remote_address):",
            "            return self.json_message(",
            "                message=\"Not local\",",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                message_code=\"not_local\",",
            "            )",
            "",
            "        yaml, storage, _ = hass.data[DOMAIN]",
            "        persons = [*yaml.async_items(), *storage.async_items()]",
            "",
            "        return self.json(",
            "            {",
            "                person[ATTR_USER_ID]: {",
            "                    ATTR_NAME: person[ATTR_NAME],",
            "                    CONF_PICTURE: person.get(CONF_PICTURE),",
            "                }",
            "                for person in persons",
            "                if person.get(ATTR_USER_ID)",
            "            }",
            "        )"
        ],
        "afterPatchFile": [
            "\"\"\"Support for tracking people.\"\"\"",
            "from __future__ import annotations",
            "",
            "from http import HTTPStatus",
            "import logging",
            "from typing import Any",
            "",
            "from aiohttp import web",
            "import voluptuous as vol",
            "",
            "from homeassistant.auth import EVENT_USER_REMOVED",
            "from homeassistant.components import persistent_notification, websocket_api",
            "from homeassistant.components.device_tracker import (",
            "    ATTR_SOURCE_TYPE,",
            "    DOMAIN as DEVICE_TRACKER_DOMAIN,",
            "    SourceType,",
            ")",
            "from homeassistant.components.http.view import HomeAssistantView",
            "from homeassistant.const import (",
            "    ATTR_EDITABLE,",
            "    ATTR_ENTITY_ID,",
            "    ATTR_GPS_ACCURACY,",
            "    ATTR_ID,",
            "    ATTR_LATITUDE,",
            "    ATTR_LONGITUDE,",
            "    ATTR_NAME,",
            "    CONF_ID,",
            "    CONF_NAME,",
            "    CONF_TYPE,",
            "    EVENT_HOMEASSISTANT_START,",
            "    SERVICE_RELOAD,",
            "    STATE_HOME,",
            "    STATE_NOT_HOME,",
            "    STATE_UNAVAILABLE,",
            "    STATE_UNKNOWN,",
            ")",
            "from homeassistant.core import (",
            "    Event,",
            "    HomeAssistant,",
            "    ServiceCall,",
            "    State,",
            "    callback,",
            "    split_entity_id,",
            ")",
            "from homeassistant.helpers import (",
            "    collection,",
            "    config_validation as cv,",
            "    entity_registry as er,",
            "    service,",
            ")",
            "from homeassistant.helpers.entity_component import EntityComponent",
            "from homeassistant.helpers.event import async_track_state_change_event",
            "from homeassistant.helpers.restore_state import RestoreEntity",
            "from homeassistant.helpers.storage import Store",
            "from homeassistant.helpers.typing import ConfigType",
            "from homeassistant.loader import bind_hass",
            "",
            "_LOGGER = logging.getLogger(__name__)",
            "",
            "ATTR_SOURCE = \"source\"",
            "ATTR_USER_ID = \"user_id\"",
            "ATTR_DEVICE_TRACKERS = \"device_trackers\"",
            "",
            "CONF_DEVICE_TRACKERS = \"device_trackers\"",
            "CONF_USER_ID = \"user_id\"",
            "CONF_PICTURE = \"picture\"",
            "",
            "DOMAIN = \"person\"",
            "",
            "STORAGE_KEY = DOMAIN",
            "STORAGE_VERSION = 2",
            "# Device tracker states to ignore",
            "IGNORE_STATES = (STATE_UNKNOWN, STATE_UNAVAILABLE)",
            "",
            "PERSON_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Required(CONF_ID): cv.string,",
            "        vol.Required(CONF_NAME): cv.string,",
            "        vol.Optional(CONF_USER_ID): cv.string,",
            "        vol.Optional(CONF_DEVICE_TRACKERS, default=[]): vol.All(",
            "            cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)",
            "        ),",
            "        vol.Optional(CONF_PICTURE): cv.string,",
            "    }",
            ")",
            "",
            "CONFIG_SCHEMA = vol.Schema(",
            "    {",
            "        vol.Optional(DOMAIN, default=[]): vol.All(",
            "            cv.ensure_list, cv.remove_falsy, [PERSON_SCHEMA]",
            "        )",
            "    },",
            "    extra=vol.ALLOW_EXTRA,",
            ")",
            "",
            "",
            "@bind_hass",
            "async def async_create_person(hass, name, *, user_id=None, device_trackers=None):",
            "    \"\"\"Create a new person.\"\"\"",
            "    await hass.data[DOMAIN][1].async_create_item(",
            "        {",
            "            ATTR_NAME: name,",
            "            ATTR_USER_ID: user_id,",
            "            CONF_DEVICE_TRACKERS: device_trackers or [],",
            "        }",
            "    )",
            "",
            "",
            "@bind_hass",
            "async def async_add_user_device_tracker(",
            "    hass: HomeAssistant, user_id: str, device_tracker_entity_id: str",
            "):",
            "    \"\"\"Add a device tracker to a person linked to a user.\"\"\"",
            "    coll: PersonStorageCollection = hass.data[DOMAIN][1]",
            "",
            "    for person in coll.async_items():",
            "        if person.get(ATTR_USER_ID) != user_id:",
            "            continue",
            "",
            "        device_trackers = person[CONF_DEVICE_TRACKERS]",
            "",
            "        if device_tracker_entity_id in device_trackers:",
            "            return",
            "",
            "        await coll.async_update_item(",
            "            person[CONF_ID],",
            "            {CONF_DEVICE_TRACKERS: device_trackers + [device_tracker_entity_id]},",
            "        )",
            "        break",
            "",
            "",
            "@callback",
            "def persons_with_entity(hass: HomeAssistant, entity_id: str) -> list[str]:",
            "    \"\"\"Return all persons that reference the entity.\"\"\"",
            "    if (",
            "        DOMAIN not in hass.data",
            "        or split_entity_id(entity_id)[0] != DEVICE_TRACKER_DOMAIN",
            "    ):",
            "        return []",
            "",
            "    component: EntityComponent[Person] = hass.data[DOMAIN][2]",
            "",
            "    return [",
            "        person_entity.entity_id",
            "        for person_entity in component.entities",
            "        if entity_id in person_entity.device_trackers",
            "    ]",
            "",
            "",
            "@callback",
            "def entities_in_person(hass: HomeAssistant, entity_id: str) -> list[str]:",
            "    \"\"\"Return all entities belonging to a person.\"\"\"",
            "    if DOMAIN not in hass.data:",
            "        return []",
            "",
            "    component: EntityComponent[Person] = hass.data[DOMAIN][2]",
            "",
            "    if (person_entity := component.get_entity(entity_id)) is None:",
            "        return []",
            "",
            "    return person_entity.device_trackers",
            "",
            "",
            "CREATE_FIELDS = {",
            "    vol.Required(CONF_NAME): vol.All(str, vol.Length(min=1)),",
            "    vol.Optional(CONF_USER_ID): vol.Any(str, None),",
            "    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(",
            "        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)",
            "    ),",
            "    vol.Optional(CONF_PICTURE): vol.Any(str, None),",
            "}",
            "",
            "",
            "UPDATE_FIELDS = {",
            "    vol.Optional(CONF_NAME): vol.All(str, vol.Length(min=1)),",
            "    vol.Optional(CONF_USER_ID): vol.Any(str, None),",
            "    vol.Optional(CONF_DEVICE_TRACKERS, default=list): vol.All(",
            "        cv.ensure_list, cv.entities_domain(DEVICE_TRACKER_DOMAIN)",
            "    ),",
            "    vol.Optional(CONF_PICTURE): vol.Any(str, None),",
            "}",
            "",
            "",
            "class PersonStore(Store):",
            "    \"\"\"Person storage.\"\"\"",
            "",
            "    async def _async_migrate_func(self, old_major_version, old_minor_version, old_data):",
            "        \"\"\"Migrate to the new version.",
            "",
            "        Migrate storage to use format of collection helper.",
            "        \"\"\"",
            "        return {\"items\": old_data[\"persons\"]}",
            "",
            "",
            "class PersonStorageCollection(collection.DictStorageCollection):",
            "    \"\"\"Person collection stored in storage.\"\"\"",
            "",
            "    CREATE_SCHEMA = vol.Schema(CREATE_FIELDS)",
            "    UPDATE_SCHEMA = vol.Schema(UPDATE_FIELDS)",
            "",
            "    def __init__(",
            "        self,",
            "        store: Store,",
            "        id_manager: collection.IDManager,",
            "        yaml_collection: collection.YamlCollection,",
            "    ) -> None:",
            "        \"\"\"Initialize a person storage collection.\"\"\"",
            "        super().__init__(store, id_manager)",
            "        self.yaml_collection = yaml_collection",
            "",
            "    async def _async_load_data(self) -> collection.SerializedStorageCollection | None:",
            "        \"\"\"Load the data.",
            "",
            "        A past bug caused onboarding to create invalid person objects.",
            "        This patches it up.",
            "        \"\"\"",
            "        data = await super()._async_load_data()",
            "",
            "        if data is None:",
            "            return data",
            "",
            "        for person in data[\"items\"]:",
            "            if person[CONF_DEVICE_TRACKERS] is None:",
            "                person[CONF_DEVICE_TRACKERS] = []",
            "",
            "        return data",
            "",
            "    async def async_load(self) -> None:",
            "        \"\"\"Load the Storage collection.\"\"\"",
            "        await super().async_load()",
            "        self.hass.bus.async_listen(",
            "            er.EVENT_ENTITY_REGISTRY_UPDATED,",
            "            self._entity_registry_updated,",
            "            event_filter=self._entity_registry_filter,",
            "        )",
            "",
            "    @callback",
            "    def _entity_registry_filter(self, event: Event) -> bool:",
            "        \"\"\"Filter entity registry events.\"\"\"",
            "        return (",
            "            event.data[\"action\"] == \"remove\"",
            "            and split_entity_id(event.data[ATTR_ENTITY_ID])[0] == \"device_tracker\"",
            "        )",
            "",
            "    async def _entity_registry_updated(self, event: Event) -> None:",
            "        \"\"\"Handle entity registry updated.\"\"\"",
            "        entity_id = event.data[ATTR_ENTITY_ID]",
            "        for person in list(self.data.values()):",
            "            if entity_id not in person[CONF_DEVICE_TRACKERS]:",
            "                continue",
            "",
            "            await self.async_update_item(",
            "                person[CONF_ID],",
            "                {",
            "                    CONF_DEVICE_TRACKERS: [",
            "                        devt",
            "                        for devt in person[CONF_DEVICE_TRACKERS]",
            "                        if devt != entity_id",
            "                    ]",
            "                },",
            "            )",
            "",
            "    async def _process_create_data(self, data: dict) -> dict:",
            "        \"\"\"Validate the config is valid.\"\"\"",
            "        data = self.CREATE_SCHEMA(data)",
            "",
            "        if (user_id := data.get(CONF_USER_ID)) is not None:",
            "            await self._validate_user_id(user_id)",
            "",
            "        return data",
            "",
            "    @callback",
            "    def _get_suggested_id(self, info: dict) -> str:",
            "        \"\"\"Suggest an ID based on the config.\"\"\"",
            "        return info[CONF_NAME]",
            "",
            "    async def _update_data(self, item: dict, update_data: dict) -> dict:",
            "        \"\"\"Return a new updated data object.\"\"\"",
            "        update_data = self.UPDATE_SCHEMA(update_data)",
            "",
            "        user_id = update_data.get(CONF_USER_ID)",
            "",
            "        if user_id is not None and user_id != item.get(CONF_USER_ID):",
            "            await self._validate_user_id(user_id)",
            "",
            "        return {**item, **update_data}",
            "",
            "    async def _validate_user_id(self, user_id):",
            "        \"\"\"Validate the used user_id.\"\"\"",
            "        if await self.hass.auth.async_get_user(user_id) is None:",
            "            raise ValueError(\"User does not exist\")",
            "",
            "        for persons in (self.data.values(), self.yaml_collection.async_items()):",
            "            if any(person for person in persons if person.get(CONF_USER_ID) == user_id):",
            "                raise ValueError(\"User already taken\")",
            "",
            "",
            "async def filter_yaml_data(hass: HomeAssistant, persons: list[dict]) -> list[dict]:",
            "    \"\"\"Validate YAML data that we can't validate via schema.\"\"\"",
            "    filtered = []",
            "    person_invalid_user = []",
            "",
            "    for person_conf in persons:",
            "        user_id = person_conf.get(CONF_USER_ID)",
            "",
            "        if user_id is not None and await hass.auth.async_get_user(user_id) is None:",
            "            _LOGGER.error(",
            "                \"Invalid user_id detected for person %s\",",
            "                person_conf[CONF_ID],",
            "            )",
            "            person_invalid_user.append(",
            "                f\"- Person {person_conf[CONF_NAME]} (id: {person_conf[CONF_ID]}) points\"",
            "                f\" at invalid user {user_id}\"",
            "            )",
            "            continue",
            "",
            "        filtered.append(person_conf)",
            "",
            "    if person_invalid_user:",
            "        persistent_notification.async_create(",
            "            hass,",
            "            f\"\"\"",
            "The following persons point at invalid users:",
            "",
            "{\"- \".join(person_invalid_user)}",
            "            \"\"\",",
            "            \"Invalid Person Configuration\",",
            "            DOMAIN,",
            "        )",
            "",
            "    return filtered",
            "",
            "",
            "async def async_setup(hass: HomeAssistant, config: ConfigType) -> bool:",
            "    \"\"\"Set up the person component.\"\"\"",
            "    entity_component = EntityComponent[Person](_LOGGER, DOMAIN, hass)",
            "    id_manager = collection.IDManager()",
            "    yaml_collection = collection.YamlCollection(",
            "        logging.getLogger(f\"{__name__}.yaml_collection\"), id_manager",
            "    )",
            "    storage_collection = PersonStorageCollection(",
            "        PersonStore(hass, STORAGE_VERSION, STORAGE_KEY),",
            "        id_manager,",
            "        yaml_collection,",
            "    )",
            "",
            "    collection.sync_entity_lifecycle(",
            "        hass, DOMAIN, DOMAIN, entity_component, yaml_collection, Person",
            "    )",
            "    collection.sync_entity_lifecycle(",
            "        hass, DOMAIN, DOMAIN, entity_component, storage_collection, Person",
            "    )",
            "",
            "    await yaml_collection.async_load(",
            "        await filter_yaml_data(hass, config.get(DOMAIN, []))",
            "    )",
            "    await storage_collection.async_load()",
            "",
            "    hass.data[DOMAIN] = (yaml_collection, storage_collection, entity_component)",
            "",
            "    collection.DictStorageCollectionWebsocket(",
            "        storage_collection, DOMAIN, DOMAIN, CREATE_FIELDS, UPDATE_FIELDS",
            "    ).async_setup(hass, create_list=False)",
            "",
            "    websocket_api.async_register_command(hass, ws_list_person)",
            "",
            "    async def _handle_user_removed(event: Event) -> None:",
            "        \"\"\"Handle a user being removed.\"\"\"",
            "        user_id = event.data[ATTR_USER_ID]",
            "        for person in storage_collection.async_items():",
            "            if person[CONF_USER_ID] == user_id:",
            "                await storage_collection.async_update_item(",
            "                    person[CONF_ID], {CONF_USER_ID: None}",
            "                )",
            "",
            "    hass.bus.async_listen(EVENT_USER_REMOVED, _handle_user_removed)",
            "",
            "    async def async_reload_yaml(call: ServiceCall) -> None:",
            "        \"\"\"Reload YAML.\"\"\"",
            "        conf = await entity_component.async_prepare_reload(skip_reset=True)",
            "        if conf is None:",
            "            return",
            "        await yaml_collection.async_load(",
            "            await filter_yaml_data(hass, conf.get(DOMAIN, []))",
            "        )",
            "",
            "    service.async_register_admin_service(",
            "        hass, DOMAIN, SERVICE_RELOAD, async_reload_yaml",
            "    )",
            "",
            "    hass.http.register_view(ListPersonsView)",
            "",
            "    return True",
            "",
            "",
            "class Person(collection.CollectionEntity, RestoreEntity):",
            "    \"\"\"Represent a tracked person.\"\"\"",
            "",
            "    _entity_component_unrecorded_attributes = frozenset({ATTR_DEVICE_TRACKERS})",
            "",
            "    _attr_should_poll = False",
            "    editable: bool",
            "",
            "    def __init__(self, config):",
            "        \"\"\"Set up person.\"\"\"",
            "        self._config = config",
            "        self._latitude = None",
            "        self._longitude = None",
            "        self._gps_accuracy = None",
            "        self._source = None",
            "        self._state = None",
            "        self._unsub_track_device = None",
            "",
            "    @classmethod",
            "    def from_storage(cls, config: ConfigType):",
            "        \"\"\"Return entity instance initialized from storage.\"\"\"",
            "        person = cls(config)",
            "        person.editable = True",
            "        return person",
            "",
            "    @classmethod",
            "    def from_yaml(cls, config: ConfigType):",
            "        \"\"\"Return entity instance initialized from yaml.\"\"\"",
            "        person = cls(config)",
            "        person.editable = False",
            "        return person",
            "",
            "    @property",
            "    def name(self):",
            "        \"\"\"Return the name of the entity.\"\"\"",
            "        return self._config[CONF_NAME]",
            "",
            "    @property",
            "    def entity_picture(self) -> str | None:",
            "        \"\"\"Return entity picture.\"\"\"",
            "        return self._config.get(CONF_PICTURE)",
            "",
            "    @property",
            "    def state(self):",
            "        \"\"\"Return the state of the person.\"\"\"",
            "        return self._state",
            "",
            "    @property",
            "    def extra_state_attributes(self):",
            "        \"\"\"Return the state attributes of the person.\"\"\"",
            "        data = {ATTR_EDITABLE: self.editable, ATTR_ID: self.unique_id}",
            "        if self._latitude is not None:",
            "            data[ATTR_LATITUDE] = self._latitude",
            "        if self._longitude is not None:",
            "            data[ATTR_LONGITUDE] = self._longitude",
            "        if self._gps_accuracy is not None:",
            "            data[ATTR_GPS_ACCURACY] = self._gps_accuracy",
            "        if self._source is not None:",
            "            data[ATTR_SOURCE] = self._source",
            "        if (user_id := self._config.get(CONF_USER_ID)) is not None:",
            "            data[ATTR_USER_ID] = user_id",
            "        data[ATTR_DEVICE_TRACKERS] = self.device_trackers",
            "        return data",
            "",
            "    @property",
            "    def unique_id(self):",
            "        \"\"\"Return a unique ID for the person.\"\"\"",
            "        return self._config[CONF_ID]",
            "",
            "    @property",
            "    def device_trackers(self):",
            "        \"\"\"Return the device trackers for the person.\"\"\"",
            "        return self._config[CONF_DEVICE_TRACKERS]",
            "",
            "    async def async_added_to_hass(self):",
            "        \"\"\"Register device trackers.\"\"\"",
            "        await super().async_added_to_hass()",
            "        if state := await self.async_get_last_state():",
            "            self._parse_source_state(state)",
            "",
            "        if self.hass.is_running:",
            "            # Update person now if hass is already running.",
            "            await self.async_update_config(self._config)",
            "        else:",
            "            # Wait for hass start to not have race between person",
            "            # and device trackers finishing setup.",
            "            async def person_start_hass(now):",
            "                await self.async_update_config(self._config)",
            "",
            "            self.hass.bus.async_listen_once(",
            "                EVENT_HOMEASSISTANT_START, person_start_hass",
            "            )",
            "",
            "    async def async_update_config(self, config: ConfigType):",
            "        \"\"\"Handle when the config is updated.\"\"\"",
            "        self._config = config",
            "",
            "        if self._unsub_track_device is not None:",
            "            self._unsub_track_device()",
            "            self._unsub_track_device = None",
            "",
            "        if trackers := self._config[CONF_DEVICE_TRACKERS]:",
            "            _LOGGER.debug(\"Subscribe to device trackers for %s\", self.entity_id)",
            "",
            "            self._unsub_track_device = async_track_state_change_event(",
            "                self.hass, trackers, self._async_handle_tracker_update",
            "            )",
            "",
            "        self._update_state()",
            "",
            "    @callback",
            "    def _async_handle_tracker_update(self, event):",
            "        \"\"\"Handle the device tracker state changes.\"\"\"",
            "        self._update_state()",
            "",
            "    @callback",
            "    def _update_state(self):",
            "        \"\"\"Update the state.\"\"\"",
            "        latest_non_gps_home = latest_not_home = latest_gps = latest = None",
            "        for entity_id in self._config[CONF_DEVICE_TRACKERS]:",
            "            state = self.hass.states.get(entity_id)",
            "",
            "            if not state or state.state in IGNORE_STATES:",
            "                continue",
            "",
            "            if state.attributes.get(ATTR_SOURCE_TYPE) == SourceType.GPS:",
            "                latest_gps = _get_latest(latest_gps, state)",
            "            elif state.state == STATE_HOME:",
            "                latest_non_gps_home = _get_latest(latest_non_gps_home, state)",
            "            elif state.state == STATE_NOT_HOME:",
            "                latest_not_home = _get_latest(latest_not_home, state)",
            "",
            "        if latest_non_gps_home:",
            "            latest = latest_non_gps_home",
            "        elif latest_gps:",
            "            latest = latest_gps",
            "        else:",
            "            latest = latest_not_home",
            "",
            "        if latest:",
            "            self._parse_source_state(latest)",
            "        else:",
            "            self._state = None",
            "            self._source = None",
            "            self._latitude = None",
            "            self._longitude = None",
            "            self._gps_accuracy = None",
            "",
            "        self.async_write_ha_state()",
            "",
            "    @callback",
            "    def _parse_source_state(self, state):",
            "        \"\"\"Parse source state and set person attributes.",
            "",
            "        This is a device tracker state or the restored person state.",
            "        \"\"\"",
            "        self._state = state.state",
            "        self._source = state.entity_id",
            "        self._latitude = state.attributes.get(ATTR_LATITUDE)",
            "        self._longitude = state.attributes.get(ATTR_LONGITUDE)",
            "        self._gps_accuracy = state.attributes.get(ATTR_GPS_ACCURACY)",
            "",
            "",
            "@websocket_api.websocket_command({vol.Required(CONF_TYPE): \"person/list\"})",
            "def ws_list_person(",
            "    hass: HomeAssistant,",
            "    connection: websocket_api.ActiveConnection,",
            "    msg: dict[str, Any],",
            ") -> None:",
            "    \"\"\"List persons.\"\"\"",
            "    yaml, storage, _ = hass.data[DOMAIN]",
            "    connection.send_result(",
            "        msg[ATTR_ID], {\"storage\": storage.async_items(), \"config\": yaml.async_items()}",
            "    )",
            "",
            "",
            "def _get_latest(prev: State | None, curr: State):",
            "    \"\"\"Get latest state.\"\"\"",
            "    if prev is None or curr.last_updated > prev.last_updated:",
            "        return curr",
            "    return prev",
            "",
            "",
            "class ListPersonsView(HomeAssistantView):",
            "    \"\"\"List all persons if request is made from a local network.\"\"\"",
            "",
            "    requires_auth = False",
            "    url = \"/api/person/list\"",
            "    name = \"api:person:list\"",
            "",
            "    async def get(self, request: web.Request) -> web.Response:",
            "        \"\"\"Return a list of persons if request comes from a local IP.\"\"\"",
            "        return self.json_message(",
            "            message=\"Not local\",",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            message_code=\"not_local\",",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "5": [],
            "54": [],
            "59": [],
            "591": [
                "ListPersonsView"
            ],
            "592": [
                "ListPersonsView"
            ],
            "593": [
                "ListPersonsView"
            ],
            "594": [
                "ListPersonsView"
            ],
            "595": [
                "ListPersonsView"
            ],
            "596": [
                "ListPersonsView"
            ],
            "597": [
                "ListPersonsView"
            ],
            "598": [
                "ListPersonsView"
            ],
            "599": [
                "ListPersonsView"
            ],
            "600": [
                "ListPersonsView"
            ],
            "601": [
                "ListPersonsView"
            ],
            "602": [
                "ListPersonsView"
            ],
            "603": [
                "ListPersonsView"
            ],
            "604": [
                "ListPersonsView"
            ],
            "605": [
                "ListPersonsView"
            ],
            "606": [
                "ListPersonsView"
            ],
            "607": [
                "ListPersonsView"
            ],
            "608": [
                "ListPersonsView"
            ],
            "609": [
                "ListPersonsView"
            ],
            "610": [
                "ListPersonsView"
            ],
            "611": [
                "ListPersonsView"
            ],
            "612": [
                "ListPersonsView"
            ],
            "613": [
                "ListPersonsView"
            ],
            "614": [
                "ListPersonsView"
            ],
            "615": [
                "ListPersonsView"
            ],
            "616": [
                "ListPersonsView"
            ],
            "617": [
                "ListPersonsView"
            ],
            "618": [
                "ListPersonsView"
            ],
            "619": [
                "ListPersonsView"
            ]
        },
        "addLocation": []
    }
}