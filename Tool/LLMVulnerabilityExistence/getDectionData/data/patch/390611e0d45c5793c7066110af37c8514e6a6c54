{
    "tensorflow/python/ops/sparse_ops_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from absl.testing import parameterized"
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import numpy as np"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from tensorflow.python.eager import context"
            },
            "4": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from tensorflow.python.framework import constant_op"
            },
            "5": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from tensorflow.python.framework import dtypes"
            },
            "6": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from tensorflow.python.framework import errors"
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " # Need array_grad to register gradient for Identity."
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from tensorflow.python.ops import array_grad  # pylint: disable=unused-import"
            },
            "9": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from tensorflow.python.ops import array_ops"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+from tensorflow.python.ops import gen_sparse_ops"
            },
            "11": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from tensorflow.python.ops import gradient_checker_v2 as gradient_checker"
            },
            "12": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " from tensorflow.python.ops import math_ops"
            },
            "13": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " # Need sparse_grad to register gradient for SparseToDense."
            },
            "14": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "     self.assertAllEqual([5], result.dense_shape)"
            },
            "15": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+@test_util.run_all_in_graph_and_eager_modes"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+class RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+  def testSparseFillEmptyRowsGrad(self):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    reverse_index_map = [2, 1]"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    grad_values = [0, 1, 2, 3]"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+    d_values, d_default_value = self.evaluate("
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        gen_sparse_ops.SparseFillEmptyRowsGrad("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+            reverse_index_map=reverse_index_map, grad_values=grad_values))"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+    self.assertAllEqual([2, 1], d_values)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+    self.assertEqual(3, d_default_value)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+  def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+    reverse_index_map = [2, -1]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+    grad_values = [0, 1, 2, 3]"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        errors.InvalidArgumentError,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+        r'Elements in reverse index must be in \\[0, 4\\)'):"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+      self.evaluate("
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+          gen_sparse_ops.SparseFillEmptyRowsGrad("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+              reverse_index_map=reverse_index_map, grad_values=grad_values))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+  def testSparseFillEmptyRowsGradLargeIndexMapValue(self):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    reverse_index_map = [2, 10]"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    grad_values = [0, 1, 2, 3]"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    with self.assertRaisesRegex("
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        errors.InvalidArgumentError,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        r'Elements in reverse index must be in \\[0, 4\\)'):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+      self.evaluate("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+          gen_sparse_ops.SparseFillEmptyRowsGrad("
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+              reverse_index_map=reverse_index_map, grad_values=grad_values))"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+  def testSparseFillEmptyRowsGradMatrix(self):"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+    reverse_index_map = [0, 1]"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    grad_values = [[0, 1], [2, 3]]"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+    # Note: Eager mode and graph mode throw different errors here. Graph mode"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    # will fail with a ValueError from the shape checking logic, while Eager"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+    # will fail with an InvalidArgumentError from the kernel itself."
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    if context.executing_eagerly():"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+      with self.assertRaisesRegex(errors.InvalidArgumentError,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+                                  r'grad_values must be a vector'):"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        self.evaluate("
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+            gen_sparse_ops.SparseFillEmptyRowsGrad("
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+                reverse_index_map=reverse_index_map, grad_values=grad_values))"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+    else:"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+      with self.assertRaisesRegex(ValueError,"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+                                  r'Shape must be rank 1 but is rank 2'):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        self.evaluate("
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            gen_sparse_ops.SparseFillEmptyRowsGrad("
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+                reverse_index_map=reverse_index_map, grad_values=grad_values))"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " if __name__ == '__main__':"
            },
            "70": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "   googletest.main()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for sparse ops.\"\"\"",
            "",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import print_function",
            "",
            "from absl.testing import parameterized",
            "import numpy as np",
            "",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.framework import test_util",
            "# Need array_grad to register gradient for Identity.",
            "from tensorflow.python.ops import array_grad  # pylint: disable=unused-import",
            "from tensorflow.python.ops import array_ops",
            "from tensorflow.python.ops import gradient_checker_v2 as gradient_checker",
            "from tensorflow.python.ops import math_ops",
            "# Need sparse_grad to register gradient for SparseToDense.",
            "from tensorflow.python.ops import sparse_grad  # pylint: disable=unused-import",
            "from tensorflow.python.ops import sparse_ops",
            "from tensorflow.python.platform import googletest",
            "",
            "",
            "@test_util.run_all_in_graph_and_eager_modes",
            "class SparseOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
            "",
            "  def testSparseEye(self):",
            "    def test_one(n, m, as_tensors):",
            "      expected = np.eye(n, m)",
            "      if as_tensors:",
            "        m = constant_op.constant(m)",
            "        n = constant_op.constant(n)",
            "      s = sparse_ops.sparse_eye(n, m)",
            "      d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)",
            "      self.assertAllEqual(self.evaluate(d), expected)",
            "",
            "    for n in range(2, 10, 2):",
            "      for m in range(2, 10, 2):",
            "        # Test with n and m as both constants and tensors.",
            "        test_one(n, m, True)",
            "        test_one(n, m, False)",
            "",
            "  def testDenseFromConstantToSparse(self):",
            "    expected_constant = np.reshape(np.arange(24, dtype=np.int64), (3, 4, 2))",
            "    tensor = constant_op.constant(expected_constant)",
            "    sparse = sparse_ops.from_dense(tensor)",
            "    dense = sparse_ops.sparse_to_dense(sparse.indices, sparse.dense_shape,",
            "                                       sparse.values)",
            "    constant = self.evaluate(dense)",
            "    self.assertAllEqual(expected_constant, constant)",
            "",
            "  def testTransposePreservesShape(self):",
            "    with ops.Graph().as_default():",
            "      t = sparse_tensor.SparseTensor(indices=[[0, 0]],",
            "                                     values=[0.],",
            "                                     dense_shape=[3, 4])",
            "      self.assertTrue(t.shape.is_fully_defined)",
            "      transposed = sparse_ops.sparse_transpose(t)",
            "      self.assertAllEqual(transposed.shape, [4, 3])",
            "",
            "  def testSparseExpandDims(self):",
            "    for rank in range(1, 4):",
            "      # Create a dummy input. When rank=3, shape=[2, 4, 6].",
            "      shape = np.arange(1, rank + 1) * 2",
            "      before = np.arange(np.prod(shape)).reshape(shape)",
            "",
            "      # Make entries sparse.",
            "      before *= np.random.binomial(1, .2, before.shape)",
            "      dense_shape = before.shape",
            "      indices = np.array(np.where(before)).T",
            "      values = before[before != 0]",
            "",
            "      # Try every possible valid value of axis.",
            "      for axis in range(-rank - 1, rank):",
            "        expected_after = np.expand_dims(before, axis)",
            "",
            "        for axis_as_tensor in [False, True]:",
            "          dense_shape_t = constant_op.constant(dense_shape, dtype=dtypes.int64)",
            "          indices_t = constant_op.constant(indices)",
            "          values_t = constant_op.constant(values)",
            "          before_t = sparse_tensor.SparseTensor(",
            "              indices=indices_t, values=values_t, dense_shape=dense_shape_t)",
            "",
            "          if axis_as_tensor:",
            "            axis = constant_op.constant(axis)",
            "",
            "          s = sparse_ops.sparse_expand_dims(before_t, axis)",
            "          d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)",
            "          self.assertAllEqual(self.evaluate(d), expected_after)",
            "",
            "  @parameterized.parameters([",
            "      (math_ops.abs, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 3.0, 4.0]),",
            "      (math_ops.negative, [1.0, -1.0, 3.0, -4.0], [-1.0, 1.0, -3.0, 4.0]),",
            "      (math_ops.sign, [3.0, -2.0, 0.0, -4.0], [1.0, -1.0, 0.0, -1.0]),",
            "      (math_ops.square, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 9.0, 16.0]),",
            "  ])",
            "  def testUnarySparseDispatch(self, op, values, expected):",
            "    st = sparse_tensor.SparseTensor(",
            "        indices=[[0, 0], [0, 1], [2, 0], [2, 4]],",
            "        values=values,",
            "        dense_shape=[3, 6])",
            "    result = op(st)",
            "    result_value = self.evaluate(result)",
            "    self.assertAllEqual(result_value.indices, st.indices)",
            "    self.assertAllEqual(result_value.values, expected)",
            "    self.assertAllEqual(result_value.dense_shape, st.dense_shape)",
            "",
            "  def testSparseToDenseGradient(self):",
            "",
            "    def f(sparse_values, default_value):",
            "      st = sparse_tensor.SparseTensor(",
            "          indices=[[0, 3, 6], [1, 4, 7], [2, 5, 8]],",
            "          values=sparse_values,",
            "          dense_shape=[3, 6, 9])",
            "      return sparse_ops.sparse_tensor_to_dense(st, default_value)",
            "",
            "    grads = gradient_checker.compute_gradient(",
            "        f, [constant_op.constant([1.0, 2.0, 3.0]),",
            "            constant_op.constant(0.0)])",
            "    epsilon = 1e-4",
            "    self.assertLess(gradient_checker.max_error(*grads), epsilon)",
            "",
            "  def testSparseTensorToDenseString(self):",
            "    sp = sparse_tensor.SparseTensor(",
            "        indices=[[0, 0], [1, 2]], values=['a', 'b'], dense_shape=[2, 3])",
            "    dense = sparse_ops.sparse_tensor_to_dense(sp)",
            "    expected_dense = [[b'a', b'', b''], [b'', b'', b'b']]",
            "    result_dense = self.evaluate(dense)",
            "    self.assertAllEqual(expected_dense, result_dense)",
            "",
            "  def testDenseSparseTensorMatMul(self):",
            "",
            "    np.random.seed(42)",
            "    dense_numpy_array = np.random.rand(3, 3)",
            "    independent_dense_tf = constant_op.constant(",
            "        dense_numpy_array, dtype='float32')",
            "",
            "    sp = sparse_tensor.SparseTensor(",
            "        indices=[[0, 0], [1, 2]], values=[4., 8.], dense_shape=[3, 3])",
            "    dense_of_sparse = sparse_ops.sparse_to_dense(sp.indices, sp.shape,",
            "                                                 sp.values)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=False, adjoint_b=False)",
            "    expected = math_ops.matmul(independent_dense_tf, dense_of_sparse)",
            "    self.assertAllEqual(expected, result)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=False, adjoint_b=True)",
            "    expected = math_ops.matmul(independent_dense_tf,",
            "                               array_ops.transpose(dense_of_sparse))",
            "    self.assertAllEqual(expected, result)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=True, adjoint_b=False)",
            "    expected = math_ops.matmul(",
            "        array_ops.transpose(independent_dense_tf), dense_of_sparse)",
            "    self.assertAllEqual(expected, result)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=True, adjoint_b=True)",
            "    expected = math_ops.matmul(",
            "        array_ops.transpose(independent_dense_tf),",
            "        array_ops.transpose(dense_of_sparse))",
            "    self.assertAllEqual(expected, result)",
            "",
            "  def testMapValues(self):",
            "    # supplying no sparse tensor should result in ValueError",
            "    with self.assertRaises(ValueError):",
            "      sparse_ops.map_values(math_ops.abs, 0.0)",
            "",
            "    sp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 1.0, 0.0]])",
            "",
            "    # helper function to check equality of sparse tensor",
            "    def assert_sparse_equal(expected, result):",
            "      self.assertAllEqual(expected.values, result.values, msg='Values differ')",
            "      self.assertAllEqual(",
            "          expected.indices, result.indices, msg='Indices differ')",
            "      self.assertAllEqual(",
            "          expected.dense_shape, result.dense_shape, msg='Shapes differ')",
            "",
            "    # check for a single sparse argument",
            "    expected = sparse_ops.from_dense([[0.0, 1.0, 0.0], [2.0, 1.0, 0.0]])",
            "    result = sparse_ops.map_values(math_ops.abs, sp)",
            "    assert_sparse_equal(expected, result)",
            "",
            "    # check correct passing of keyword argument, and handling of two sparse",
            "    # arguments at the same time",
            "    def mapping(arg1, arg2, kwarg):",
            "      self.assertEqual(kwarg, 'kwarg')",
            "      return arg1 + arg2",
            "",
            "    result = sparse_ops.map_values(mapping, sp, sp, kwarg='kwarg')",
            "    expected = sparse_ops.from_dense([[0.0, 2.0, 0.0], [-4.0, 2.0, 0.0]])",
            "    assert_sparse_equal(expected, result)",
            "",
            "    # check that index mismatches are correctly detected even if the `value`s",
            "    # have compatible shape",
            "    sp_incomp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 0.0, 1.0]])",
            "    with self.assertRaises((errors.InvalidArgumentError, ValueError)):",
            "      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')",
            "      self.evaluate(result)",
            "",
            "    # check that shape mismatches are correctly detected",
            "    sp_incomp = sparse_tensor.SparseTensor(sp.indices, sp.values, (25, 25))",
            "    with self.assertRaises((errors.InvalidArgumentError, ValueError)):",
            "      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')",
            "      self.evaluate(result)",
            "",
            "  def testConstantStringToSparse(self):",
            "    # Test case for GitHub issue 40633.",
            "    tensor = constant_op.constant(list('ababa'))",
            "    sparse = sparse_ops.from_dense(tensor)",
            "    result = self.evaluate(sparse)",
            "    self.assertAllEqual([[0], [1], [2], [3], [4]], result.indices)",
            "    self.assertAllEqual([b'a', b'b', b'a', b'b', b'a'], result.values)",
            "    self.assertAllEqual([5], result.dense_shape)",
            "",
            "",
            "if __name__ == '__main__':",
            "  googletest.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2018 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for sparse ops.\"\"\"",
            "",
            "from __future__ import absolute_import",
            "from __future__ import division",
            "from __future__ import print_function",
            "",
            "from absl.testing import parameterized",
            "import numpy as np",
            "",
            "from tensorflow.python.eager import context",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import ops",
            "from tensorflow.python.framework import sparse_tensor",
            "from tensorflow.python.framework import test_util",
            "# Need array_grad to register gradient for Identity.",
            "from tensorflow.python.ops import array_grad  # pylint: disable=unused-import",
            "from tensorflow.python.ops import array_ops",
            "from tensorflow.python.ops import gen_sparse_ops",
            "from tensorflow.python.ops import gradient_checker_v2 as gradient_checker",
            "from tensorflow.python.ops import math_ops",
            "# Need sparse_grad to register gradient for SparseToDense.",
            "from tensorflow.python.ops import sparse_grad  # pylint: disable=unused-import",
            "from tensorflow.python.ops import sparse_ops",
            "from tensorflow.python.platform import googletest",
            "",
            "",
            "@test_util.run_all_in_graph_and_eager_modes",
            "class SparseOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
            "",
            "  def testSparseEye(self):",
            "    def test_one(n, m, as_tensors):",
            "      expected = np.eye(n, m)",
            "      if as_tensors:",
            "        m = constant_op.constant(m)",
            "        n = constant_op.constant(n)",
            "      s = sparse_ops.sparse_eye(n, m)",
            "      d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)",
            "      self.assertAllEqual(self.evaluate(d), expected)",
            "",
            "    for n in range(2, 10, 2):",
            "      for m in range(2, 10, 2):",
            "        # Test with n and m as both constants and tensors.",
            "        test_one(n, m, True)",
            "        test_one(n, m, False)",
            "",
            "  def testDenseFromConstantToSparse(self):",
            "    expected_constant = np.reshape(np.arange(24, dtype=np.int64), (3, 4, 2))",
            "    tensor = constant_op.constant(expected_constant)",
            "    sparse = sparse_ops.from_dense(tensor)",
            "    dense = sparse_ops.sparse_to_dense(sparse.indices, sparse.dense_shape,",
            "                                       sparse.values)",
            "    constant = self.evaluate(dense)",
            "    self.assertAllEqual(expected_constant, constant)",
            "",
            "  def testTransposePreservesShape(self):",
            "    with ops.Graph().as_default():",
            "      t = sparse_tensor.SparseTensor(indices=[[0, 0]],",
            "                                     values=[0.],",
            "                                     dense_shape=[3, 4])",
            "      self.assertTrue(t.shape.is_fully_defined)",
            "      transposed = sparse_ops.sparse_transpose(t)",
            "      self.assertAllEqual(transposed.shape, [4, 3])",
            "",
            "  def testSparseExpandDims(self):",
            "    for rank in range(1, 4):",
            "      # Create a dummy input. When rank=3, shape=[2, 4, 6].",
            "      shape = np.arange(1, rank + 1) * 2",
            "      before = np.arange(np.prod(shape)).reshape(shape)",
            "",
            "      # Make entries sparse.",
            "      before *= np.random.binomial(1, .2, before.shape)",
            "      dense_shape = before.shape",
            "      indices = np.array(np.where(before)).T",
            "      values = before[before != 0]",
            "",
            "      # Try every possible valid value of axis.",
            "      for axis in range(-rank - 1, rank):",
            "        expected_after = np.expand_dims(before, axis)",
            "",
            "        for axis_as_tensor in [False, True]:",
            "          dense_shape_t = constant_op.constant(dense_shape, dtype=dtypes.int64)",
            "          indices_t = constant_op.constant(indices)",
            "          values_t = constant_op.constant(values)",
            "          before_t = sparse_tensor.SparseTensor(",
            "              indices=indices_t, values=values_t, dense_shape=dense_shape_t)",
            "",
            "          if axis_as_tensor:",
            "            axis = constant_op.constant(axis)",
            "",
            "          s = sparse_ops.sparse_expand_dims(before_t, axis)",
            "          d = sparse_ops.sparse_to_dense(s.indices, s.dense_shape, s.values)",
            "          self.assertAllEqual(self.evaluate(d), expected_after)",
            "",
            "  @parameterized.parameters([",
            "      (math_ops.abs, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 3.0, 4.0]),",
            "      (math_ops.negative, [1.0, -1.0, 3.0, -4.0], [-1.0, 1.0, -3.0, 4.0]),",
            "      (math_ops.sign, [3.0, -2.0, 0.0, -4.0], [1.0, -1.0, 0.0, -1.0]),",
            "      (math_ops.square, [1.0, -1.0, 3.0, -4.0], [1.0, 1.0, 9.0, 16.0]),",
            "  ])",
            "  def testUnarySparseDispatch(self, op, values, expected):",
            "    st = sparse_tensor.SparseTensor(",
            "        indices=[[0, 0], [0, 1], [2, 0], [2, 4]],",
            "        values=values,",
            "        dense_shape=[3, 6])",
            "    result = op(st)",
            "    result_value = self.evaluate(result)",
            "    self.assertAllEqual(result_value.indices, st.indices)",
            "    self.assertAllEqual(result_value.values, expected)",
            "    self.assertAllEqual(result_value.dense_shape, st.dense_shape)",
            "",
            "  def testSparseToDenseGradient(self):",
            "",
            "    def f(sparse_values, default_value):",
            "      st = sparse_tensor.SparseTensor(",
            "          indices=[[0, 3, 6], [1, 4, 7], [2, 5, 8]],",
            "          values=sparse_values,",
            "          dense_shape=[3, 6, 9])",
            "      return sparse_ops.sparse_tensor_to_dense(st, default_value)",
            "",
            "    grads = gradient_checker.compute_gradient(",
            "        f, [constant_op.constant([1.0, 2.0, 3.0]),",
            "            constant_op.constant(0.0)])",
            "    epsilon = 1e-4",
            "    self.assertLess(gradient_checker.max_error(*grads), epsilon)",
            "",
            "  def testSparseTensorToDenseString(self):",
            "    sp = sparse_tensor.SparseTensor(",
            "        indices=[[0, 0], [1, 2]], values=['a', 'b'], dense_shape=[2, 3])",
            "    dense = sparse_ops.sparse_tensor_to_dense(sp)",
            "    expected_dense = [[b'a', b'', b''], [b'', b'', b'b']]",
            "    result_dense = self.evaluate(dense)",
            "    self.assertAllEqual(expected_dense, result_dense)",
            "",
            "  def testDenseSparseTensorMatMul(self):",
            "",
            "    np.random.seed(42)",
            "    dense_numpy_array = np.random.rand(3, 3)",
            "    independent_dense_tf = constant_op.constant(",
            "        dense_numpy_array, dtype='float32')",
            "",
            "    sp = sparse_tensor.SparseTensor(",
            "        indices=[[0, 0], [1, 2]], values=[4., 8.], dense_shape=[3, 3])",
            "    dense_of_sparse = sparse_ops.sparse_to_dense(sp.indices, sp.shape,",
            "                                                 sp.values)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=False, adjoint_b=False)",
            "    expected = math_ops.matmul(independent_dense_tf, dense_of_sparse)",
            "    self.assertAllEqual(expected, result)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=False, adjoint_b=True)",
            "    expected = math_ops.matmul(independent_dense_tf,",
            "                               array_ops.transpose(dense_of_sparse))",
            "    self.assertAllEqual(expected, result)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=True, adjoint_b=False)",
            "    expected = math_ops.matmul(",
            "        array_ops.transpose(independent_dense_tf), dense_of_sparse)",
            "    self.assertAllEqual(expected, result)",
            "",
            "    result = sparse_ops.sparse_tensor_dense_matmul(",
            "        independent_dense_tf, sp, adjoint_a=True, adjoint_b=True)",
            "    expected = math_ops.matmul(",
            "        array_ops.transpose(independent_dense_tf),",
            "        array_ops.transpose(dense_of_sparse))",
            "    self.assertAllEqual(expected, result)",
            "",
            "  def testMapValues(self):",
            "    # supplying no sparse tensor should result in ValueError",
            "    with self.assertRaises(ValueError):",
            "      sparse_ops.map_values(math_ops.abs, 0.0)",
            "",
            "    sp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 1.0, 0.0]])",
            "",
            "    # helper function to check equality of sparse tensor",
            "    def assert_sparse_equal(expected, result):",
            "      self.assertAllEqual(expected.values, result.values, msg='Values differ')",
            "      self.assertAllEqual(",
            "          expected.indices, result.indices, msg='Indices differ')",
            "      self.assertAllEqual(",
            "          expected.dense_shape, result.dense_shape, msg='Shapes differ')",
            "",
            "    # check for a single sparse argument",
            "    expected = sparse_ops.from_dense([[0.0, 1.0, 0.0], [2.0, 1.0, 0.0]])",
            "    result = sparse_ops.map_values(math_ops.abs, sp)",
            "    assert_sparse_equal(expected, result)",
            "",
            "    # check correct passing of keyword argument, and handling of two sparse",
            "    # arguments at the same time",
            "    def mapping(arg1, arg2, kwarg):",
            "      self.assertEqual(kwarg, 'kwarg')",
            "      return arg1 + arg2",
            "",
            "    result = sparse_ops.map_values(mapping, sp, sp, kwarg='kwarg')",
            "    expected = sparse_ops.from_dense([[0.0, 2.0, 0.0], [-4.0, 2.0, 0.0]])",
            "    assert_sparse_equal(expected, result)",
            "",
            "    # check that index mismatches are correctly detected even if the `value`s",
            "    # have compatible shape",
            "    sp_incomp = sparse_ops.from_dense([[0.0, 1.0, 0.0], [-2.0, 0.0, 1.0]])",
            "    with self.assertRaises((errors.InvalidArgumentError, ValueError)):",
            "      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')",
            "      self.evaluate(result)",
            "",
            "    # check that shape mismatches are correctly detected",
            "    sp_incomp = sparse_tensor.SparseTensor(sp.indices, sp.values, (25, 25))",
            "    with self.assertRaises((errors.InvalidArgumentError, ValueError)):",
            "      result = sparse_ops.map_values(mapping, sp, sp_incomp, kwarg='kwarg')",
            "      self.evaluate(result)",
            "",
            "  def testConstantStringToSparse(self):",
            "    # Test case for GitHub issue 40633.",
            "    tensor = constant_op.constant(list('ababa'))",
            "    sparse = sparse_ops.from_dense(tensor)",
            "    result = self.evaluate(sparse)",
            "    self.assertAllEqual([[0], [1], [2], [3], [4]], result.indices)",
            "    self.assertAllEqual([b'a', b'b', b'a', b'b', b'a'], result.values)",
            "    self.assertAllEqual([5], result.dense_shape)",
            "",
            "",
            "@test_util.run_all_in_graph_and_eager_modes",
            "class RawOpsTest(test_util.TensorFlowTestCase, parameterized.TestCase):",
            "",
            "  def testSparseFillEmptyRowsGrad(self):",
            "    reverse_index_map = [2, 1]",
            "    grad_values = [0, 1, 2, 3]",
            "    d_values, d_default_value = self.evaluate(",
            "        gen_sparse_ops.SparseFillEmptyRowsGrad(",
            "            reverse_index_map=reverse_index_map, grad_values=grad_values))",
            "    self.assertAllEqual([2, 1], d_values)",
            "    self.assertEqual(3, d_default_value)",
            "",
            "  def testSparseFillEmptyRowsGradNegativeIndexMapValue(self):",
            "    reverse_index_map = [2, -1]",
            "    grad_values = [0, 1, 2, 3]",
            "    with self.assertRaisesRegex(",
            "        errors.InvalidArgumentError,",
            "        r'Elements in reverse index must be in \\[0, 4\\)'):",
            "      self.evaluate(",
            "          gen_sparse_ops.SparseFillEmptyRowsGrad(",
            "              reverse_index_map=reverse_index_map, grad_values=grad_values))",
            "",
            "  def testSparseFillEmptyRowsGradLargeIndexMapValue(self):",
            "    reverse_index_map = [2, 10]",
            "    grad_values = [0, 1, 2, 3]",
            "    with self.assertRaisesRegex(",
            "        errors.InvalidArgumentError,",
            "        r'Elements in reverse index must be in \\[0, 4\\)'):",
            "      self.evaluate(",
            "          gen_sparse_ops.SparseFillEmptyRowsGrad(",
            "              reverse_index_map=reverse_index_map, grad_values=grad_values))",
            "",
            "  def testSparseFillEmptyRowsGradMatrix(self):",
            "    reverse_index_map = [0, 1]",
            "    grad_values = [[0, 1], [2, 3]]",
            "    # Note: Eager mode and graph mode throw different errors here. Graph mode",
            "    # will fail with a ValueError from the shape checking logic, while Eager",
            "    # will fail with an InvalidArgumentError from the kernel itself.",
            "    if context.executing_eagerly():",
            "      with self.assertRaisesRegex(errors.InvalidArgumentError,",
            "                                  r'grad_values must be a vector'):",
            "        self.evaluate(",
            "            gen_sparse_ops.SparseFillEmptyRowsGrad(",
            "                reverse_index_map=reverse_index_map, grad_values=grad_values))",
            "    else:",
            "      with self.assertRaisesRegex(ValueError,",
            "                                  r'Shape must be rank 1 but is rank 2'):",
            "        self.evaluate(",
            "            gen_sparse_ops.SparseFillEmptyRowsGrad(",
            "                reverse_index_map=reverse_index_map, grad_values=grad_values))",
            "",
            "",
            "if __name__ == '__main__':",
            "  googletest.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.pgadmin.tools.import_export.create_import_export_job"
        ]
    }
}