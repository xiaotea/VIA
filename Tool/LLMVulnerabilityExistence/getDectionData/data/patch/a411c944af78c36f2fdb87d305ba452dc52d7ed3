{
    "keystone/token/backends/memcache.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         return token_ref"
            },
            "1": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     def create_token(self, token_id, data):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        def update_index(user_id, token_data):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            user_key = self._prefix_user_id(user_id)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            if not self.client.append(user_key, ',%s' % token_data):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                if not self.client.add(user_key, token_data):"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+                    if not self.client.append(user_key, ',%s' % token_data):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+                        msg = _('Unable to add token user list.')"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                        raise exception.UnexpectedError(msg)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         data_copy = copy.deepcopy(data)"
            },
            "13": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "         ptk = self._prefix_token_id(token.unique_id(token_id))"
            },
            "14": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         if not data_copy.get('expires'):"
            },
            "15": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "             expires_ts = utils.unixtime(data_copy['expires'])"
            },
            "16": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "             kwargs['time'] = expires_ts"
            },
            "17": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         self.client.set(ptk, data_copy, **kwargs)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        token_data = jsonutils.dumps(token_id)"
            },
            "19": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         if 'id' in data['user']:"
            },
            "20": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            token_data = jsonutils.dumps(token_id)"
            },
            "21": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             user_id = data['user']['id']"
            },
            "22": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_key = self._prefix_user_id(user_id)"
            },
            "23": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not self.client.append(user_key, ',%s' % token_data):"
            },
            "24": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if not self.client.add(user_key, token_data):"
            },
            "25": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if not self.client.append(user_key, ',%s' % token_data):"
            },
            "26": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        msg = _('Unable to add token user list.')"
            },
            "27": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        raise exception.UnexpectedError(msg)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            update_index(user_id, token_data)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        if CONF.trust.enabled and data.get('trust_id'):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            if 'access' in data_copy:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+                trustee_user_id = data_copy['access']['trust']["
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                    'trustee_user_id']"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+            else:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                trustee_user_id = data_copy['OS-TRUST:trust']["
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                    'trustee_user_id']"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            update_index(trustee_user_id, token_data)"
            },
            "38": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         return copy.deepcopy(data_copy)"
            },
            "39": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 99,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     def _add_to_revocation_list(self, token_id, token_data):"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from __future__ import absolute_import",
            "import copy",
            "",
            "import memcache",
            "",
            "from keystone.common import utils",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import jsonutils",
            "from keystone import token",
            "",
            "",
            "CONF = config.CONF",
            "config.register_str('servers', group='memcache', default='localhost:11211')",
            "",
            "",
            "class Token(token.Driver):",
            "    revocation_key = 'revocation-list'",
            "",
            "    def __init__(self, client=None):",
            "        self._memcache_client = client",
            "",
            "    @property",
            "    def client(self):",
            "        return self._memcache_client or self._get_memcache_client()",
            "",
            "    def _get_memcache_client(self):",
            "        memcache_servers = CONF.memcache.servers.split(',')",
            "        self._memcache_client = memcache.Client(memcache_servers, debug=0)",
            "        return self._memcache_client",
            "",
            "    def _prefix_token_id(self, token_id):",
            "        return 'token-%s' % token_id.encode('utf-8')",
            "",
            "    def _prefix_user_id(self, user_id):",
            "        return 'usertokens-%s' % user_id.encode('utf-8')",
            "",
            "    def get_token(self, token_id):",
            "        if token_id is None:",
            "            raise exception.TokenNotFound(token_id='')",
            "        ptk = self._prefix_token_id(token.unique_id(token_id))",
            "        token_ref = self.client.get(ptk)",
            "        if token_ref is None:",
            "            raise exception.TokenNotFound(token_id=token_id)",
            "",
            "        return token_ref",
            "",
            "    def create_token(self, token_id, data):",
            "        data_copy = copy.deepcopy(data)",
            "        ptk = self._prefix_token_id(token.unique_id(token_id))",
            "        if not data_copy.get('expires'):",
            "            data_copy['expires'] = token.default_expire_time()",
            "        if not data_copy.get('user_id'):",
            "            data_copy['user_id'] = data_copy['user']['id']",
            "        kwargs = {}",
            "        if data_copy['expires'] is not None:",
            "            expires_ts = utils.unixtime(data_copy['expires'])",
            "            kwargs['time'] = expires_ts",
            "        self.client.set(ptk, data_copy, **kwargs)",
            "        if 'id' in data['user']:",
            "            token_data = jsonutils.dumps(token_id)",
            "            user_id = data['user']['id']",
            "            user_key = self._prefix_user_id(user_id)",
            "            if not self.client.append(user_key, ',%s' % token_data):",
            "                if not self.client.add(user_key, token_data):",
            "                    if not self.client.append(user_key, ',%s' % token_data):",
            "                        msg = _('Unable to add token user list.')",
            "                        raise exception.UnexpectedError(msg)",
            "        return copy.deepcopy(data_copy)",
            "",
            "    def _add_to_revocation_list(self, token_id, token_data):",
            "        data_json = jsonutils.dumps({'id': token_id,",
            "                                     'expires': token_data['expires']})",
            "        if not self.client.append(self.revocation_key, ',%s' % data_json):",
            "            if not self.client.add(self.revocation_key, data_json):",
            "                if not self.client.append(self.revocation_key,",
            "                                          ',%s' % data_json):",
            "                    msg = _('Unable to add token to revocation list.')",
            "                    raise exception.UnexpectedError(msg)",
            "",
            "    def delete_token(self, token_id):",
            "        # Test for existence",
            "        token_id = token.unique_id(token_id)",
            "        data = self.get_token(token_id)",
            "        ptk = self._prefix_token_id(token_id)",
            "        result = self.client.delete(ptk)",
            "        self._add_to_revocation_list(token_id, data)",
            "        return result",
            "",
            "    def list_tokens(self, user_id, tenant_id=None, trust_id=None):",
            "        tokens = []",
            "        user_key = self._prefix_user_id(user_id)",
            "        user_record = self.client.get(user_key) or \"\"",
            "        token_list = jsonutils.loads('[%s]' % user_record)",
            "        for token_id in token_list:",
            "            ptk = self._prefix_token_id(token.unique_id(token_id))",
            "            token_ref = self.client.get(ptk)",
            "            if token_ref:",
            "                if tenant_id is not None:",
            "                    tenant = token_ref.get('tenant')",
            "                    if not tenant:",
            "                        continue",
            "                    if tenant.get('id') != tenant_id:",
            "                        continue",
            "                if trust_id is not None:",
            "                    trust = token_ref.get('trust_id')",
            "                    if not trust:",
            "                        continue",
            "                    if trust != trust_id:",
            "                        continue",
            "",
            "                tokens.append(token_id)",
            "        return tokens",
            "",
            "    def list_revoked_tokens(self):",
            "        list_json = self.client.get(self.revocation_key)",
            "        if list_json:",
            "            return jsonutils.loads('[%s]' % list_json)",
            "        return []"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2012 OpenStack LLC",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from __future__ import absolute_import",
            "import copy",
            "",
            "import memcache",
            "",
            "from keystone.common import utils",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.openstack.common import jsonutils",
            "from keystone import token",
            "",
            "",
            "CONF = config.CONF",
            "config.register_str('servers', group='memcache', default='localhost:11211')",
            "",
            "",
            "class Token(token.Driver):",
            "    revocation_key = 'revocation-list'",
            "",
            "    def __init__(self, client=None):",
            "        self._memcache_client = client",
            "",
            "    @property",
            "    def client(self):",
            "        return self._memcache_client or self._get_memcache_client()",
            "",
            "    def _get_memcache_client(self):",
            "        memcache_servers = CONF.memcache.servers.split(',')",
            "        self._memcache_client = memcache.Client(memcache_servers, debug=0)",
            "        return self._memcache_client",
            "",
            "    def _prefix_token_id(self, token_id):",
            "        return 'token-%s' % token_id.encode('utf-8')",
            "",
            "    def _prefix_user_id(self, user_id):",
            "        return 'usertokens-%s' % user_id.encode('utf-8')",
            "",
            "    def get_token(self, token_id):",
            "        if token_id is None:",
            "            raise exception.TokenNotFound(token_id='')",
            "        ptk = self._prefix_token_id(token.unique_id(token_id))",
            "        token_ref = self.client.get(ptk)",
            "        if token_ref is None:",
            "            raise exception.TokenNotFound(token_id=token_id)",
            "",
            "        return token_ref",
            "",
            "    def create_token(self, token_id, data):",
            "",
            "        def update_index(user_id, token_data):",
            "            user_key = self._prefix_user_id(user_id)",
            "            if not self.client.append(user_key, ',%s' % token_data):",
            "                if not self.client.add(user_key, token_data):",
            "                    if not self.client.append(user_key, ',%s' % token_data):",
            "                        msg = _('Unable to add token user list.')",
            "                        raise exception.UnexpectedError(msg)",
            "",
            "        data_copy = copy.deepcopy(data)",
            "        ptk = self._prefix_token_id(token.unique_id(token_id))",
            "        if not data_copy.get('expires'):",
            "            data_copy['expires'] = token.default_expire_time()",
            "        if not data_copy.get('user_id'):",
            "            data_copy['user_id'] = data_copy['user']['id']",
            "        kwargs = {}",
            "        if data_copy['expires'] is not None:",
            "            expires_ts = utils.unixtime(data_copy['expires'])",
            "            kwargs['time'] = expires_ts",
            "        self.client.set(ptk, data_copy, **kwargs)",
            "        token_data = jsonutils.dumps(token_id)",
            "        if 'id' in data['user']:",
            "            user_id = data['user']['id']",
            "            update_index(user_id, token_data)",
            "",
            "        if CONF.trust.enabled and data.get('trust_id'):",
            "            if 'access' in data_copy:",
            "                trustee_user_id = data_copy['access']['trust'][",
            "                    'trustee_user_id']",
            "            else:",
            "                trustee_user_id = data_copy['OS-TRUST:trust'][",
            "                    'trustee_user_id']",
            "            update_index(trustee_user_id, token_data)",
            "        return copy.deepcopy(data_copy)",
            "",
            "    def _add_to_revocation_list(self, token_id, token_data):",
            "        data_json = jsonutils.dumps({'id': token_id,",
            "                                     'expires': token_data['expires']})",
            "        if not self.client.append(self.revocation_key, ',%s' % data_json):",
            "            if not self.client.add(self.revocation_key, data_json):",
            "                if not self.client.append(self.revocation_key,",
            "                                          ',%s' % data_json):",
            "                    msg = _('Unable to add token to revocation list.')",
            "                    raise exception.UnexpectedError(msg)",
            "",
            "    def delete_token(self, token_id):",
            "        # Test for existence",
            "        token_id = token.unique_id(token_id)",
            "        data = self.get_token(token_id)",
            "        ptk = self._prefix_token_id(token_id)",
            "        result = self.client.delete(ptk)",
            "        self._add_to_revocation_list(token_id, data)",
            "        return result",
            "",
            "    def list_tokens(self, user_id, tenant_id=None, trust_id=None):",
            "        tokens = []",
            "        user_key = self._prefix_user_id(user_id)",
            "        user_record = self.client.get(user_key) or \"\"",
            "        token_list = jsonutils.loads('[%s]' % user_record)",
            "        for token_id in token_list:",
            "            ptk = self._prefix_token_id(token.unique_id(token_id))",
            "            token_ref = self.client.get(ptk)",
            "            if token_ref:",
            "                if tenant_id is not None:",
            "                    tenant = token_ref.get('tenant')",
            "                    if not tenant:",
            "                        continue",
            "                    if tenant.get('id') != tenant_id:",
            "                        continue",
            "                if trust_id is not None:",
            "                    trust = token_ref.get('trust_id')",
            "                    if not trust:",
            "                        continue",
            "                    if trust != trust_id:",
            "                        continue",
            "",
            "                tokens.append(token_id)",
            "        return tokens",
            "",
            "    def list_revoked_tokens(self):",
            "        list_json = self.client.get(self.revocation_key)",
            "        if list_json:",
            "            return jsonutils.loads('[%s]' % list_json)",
            "        return []"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "77": [
                "Token",
                "create_token"
            ],
            "79": [
                "Token",
                "create_token"
            ],
            "80": [
                "Token",
                "create_token"
            ],
            "81": [
                "Token",
                "create_token"
            ],
            "82": [
                "Token",
                "create_token"
            ],
            "83": [
                "Token",
                "create_token"
            ],
            "84": [
                "Token",
                "create_token"
            ]
        },
        "addLocation": [
            "keystone.token.backends.memcache.Token.create_token.kwargs",
            "keystone.token.backends.memcache.Token.create_token"
        ]
    }
}