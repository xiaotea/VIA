{
    "django/contrib/gis/db/models/aggregates.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from django.contrib.gis.db.models.fields import ("
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": "     ExtentField, GeometryCollectionField, GeometryField, LineStringField,"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+from django.db.models import Value"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from django.db.models.aggregates import Aggregate"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.utils.functional import cached_property"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         )"
            },
            "8": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     def as_oracle(self, compiler, connection, **extra_context):"
            },
            "10": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        tolerance = self.extra.get('tolerance') or getattr(self, 'tolerance', 0.05)"
            },
            "11": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        template = None if self.is_extent else '%(function)s(SDOAGGRTYPE(%(expressions)s,%(tolerance)s))'"
            },
            "12": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.as_sql(compiler, connection, template=template, tolerance=tolerance, **extra_context)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        if not self.is_extent:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+            tolerance = self.extra.get('tolerance') or getattr(self, 'tolerance', 0.05)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+            clone = self.copy()"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+            clone.set_source_expressions(["
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+                *self.get_source_expressions(),"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+                Value(tolerance),"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+            ])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            template = '%(function)s(SDOAGGRTYPE(%(expressions)s))'"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            return clone.as_sql(compiler, connection, template=template, **extra_context)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        return self.as_sql(compiler, connection, **extra_context)"
            },
            "23": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):"
            },
            "25": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)"
            }
        },
        "frontPatchFile": [
            "from django.contrib.gis.db.models.fields import (",
            "    ExtentField, GeometryCollectionField, GeometryField, LineStringField,",
            ")",
            "from django.db.models.aggregates import Aggregate",
            "from django.utils.functional import cached_property",
            "",
            "__all__ = ['Collect', 'Extent', 'Extent3D', 'MakeLine', 'Union']",
            "",
            "",
            "class GeoAggregate(Aggregate):",
            "    function = None",
            "    is_extent = False",
            "",
            "    @cached_property",
            "    def output_field(self):",
            "        return self.output_field_class(self.source_expressions[0].output_field.srid)",
            "",
            "    def as_sql(self, compiler, connection, function=None, **extra_context):",
            "        # this will be called again in parent, but it's needed now - before",
            "        # we get the spatial_aggregate_name",
            "        connection.ops.check_expression_support(self)",
            "        return super().as_sql(",
            "            compiler,",
            "            connection,",
            "            function=function or connection.ops.spatial_aggregate_name(self.name),",
            "            **extra_context",
            "        )",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        tolerance = self.extra.get('tolerance') or getattr(self, 'tolerance', 0.05)",
            "        template = None if self.is_extent else '%(function)s(SDOAGGRTYPE(%(expressions)s,%(tolerance)s))'",
            "        return self.as_sql(compiler, connection, template=template, tolerance=tolerance, **extra_context)",
            "",
            "    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):",
            "        c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)",
            "        for expr in c.get_source_expressions():",
            "            if not hasattr(expr.field, 'geom_type'):",
            "                raise ValueError('Geospatial aggregates only allowed on geometry fields.')",
            "        return c",
            "",
            "",
            "class Collect(GeoAggregate):",
            "    name = 'Collect'",
            "    output_field_class = GeometryCollectionField",
            "",
            "",
            "class Extent(GeoAggregate):",
            "    name = 'Extent'",
            "    is_extent = '2D'",
            "",
            "    def __init__(self, expression, **extra):",
            "        super().__init__(expression, output_field=ExtentField(), **extra)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        return connection.ops.convert_extent(value)",
            "",
            "",
            "class Extent3D(GeoAggregate):",
            "    name = 'Extent3D'",
            "    is_extent = '3D'",
            "",
            "    def __init__(self, expression, **extra):",
            "        super().__init__(expression, output_field=ExtentField(), **extra)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        return connection.ops.convert_extent3d(value)",
            "",
            "",
            "class MakeLine(GeoAggregate):",
            "    name = 'MakeLine'",
            "    output_field_class = LineStringField",
            "",
            "",
            "class Union(GeoAggregate):",
            "    name = 'Union'",
            "    output_field_class = GeometryField"
        ],
        "afterPatchFile": [
            "from django.contrib.gis.db.models.fields import (",
            "    ExtentField, GeometryCollectionField, GeometryField, LineStringField,",
            ")",
            "from django.db.models import Value",
            "from django.db.models.aggregates import Aggregate",
            "from django.utils.functional import cached_property",
            "",
            "__all__ = ['Collect', 'Extent', 'Extent3D', 'MakeLine', 'Union']",
            "",
            "",
            "class GeoAggregate(Aggregate):",
            "    function = None",
            "    is_extent = False",
            "",
            "    @cached_property",
            "    def output_field(self):",
            "        return self.output_field_class(self.source_expressions[0].output_field.srid)",
            "",
            "    def as_sql(self, compiler, connection, function=None, **extra_context):",
            "        # this will be called again in parent, but it's needed now - before",
            "        # we get the spatial_aggregate_name",
            "        connection.ops.check_expression_support(self)",
            "        return super().as_sql(",
            "            compiler,",
            "            connection,",
            "            function=function or connection.ops.spatial_aggregate_name(self.name),",
            "            **extra_context",
            "        )",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        if not self.is_extent:",
            "            tolerance = self.extra.get('tolerance') or getattr(self, 'tolerance', 0.05)",
            "            clone = self.copy()",
            "            clone.set_source_expressions([",
            "                *self.get_source_expressions(),",
            "                Value(tolerance),",
            "            ])",
            "            template = '%(function)s(SDOAGGRTYPE(%(expressions)s))'",
            "            return clone.as_sql(compiler, connection, template=template, **extra_context)",
            "        return self.as_sql(compiler, connection, **extra_context)",
            "",
            "    def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):",
            "        c = super().resolve_expression(query, allow_joins, reuse, summarize, for_save)",
            "        for expr in c.get_source_expressions():",
            "            if not hasattr(expr.field, 'geom_type'):",
            "                raise ValueError('Geospatial aggregates only allowed on geometry fields.')",
            "        return c",
            "",
            "",
            "class Collect(GeoAggregate):",
            "    name = 'Collect'",
            "    output_field_class = GeometryCollectionField",
            "",
            "",
            "class Extent(GeoAggregate):",
            "    name = 'Extent'",
            "    is_extent = '2D'",
            "",
            "    def __init__(self, expression, **extra):",
            "        super().__init__(expression, output_field=ExtentField(), **extra)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        return connection.ops.convert_extent(value)",
            "",
            "",
            "class Extent3D(GeoAggregate):",
            "    name = 'Extent3D'",
            "    is_extent = '3D'",
            "",
            "    def __init__(self, expression, **extra):",
            "        super().__init__(expression, output_field=ExtentField(), **extra)",
            "",
            "    def convert_value(self, value, expression, connection):",
            "        return connection.ops.convert_extent3d(value)",
            "",
            "",
            "class MakeLine(GeoAggregate):",
            "    name = 'MakeLine'",
            "    output_field_class = LineStringField",
            "",
            "",
            "class Union(GeoAggregate):",
            "    name = 'Union'",
            "    output_field_class = GeometryField"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "30": [
                "GeoAggregate",
                "as_oracle"
            ],
            "31": [
                "GeoAggregate",
                "as_oracle"
            ],
            "32": [
                "GeoAggregate",
                "as_oracle"
            ]
        },
        "addLocation": []
    },
    "django/contrib/gis/db/models/functions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "     tolerance = 0.05"
            },
            "1": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "     def as_oracle(self, compiler, connection, **extra_context):"
            },
            "3": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        tol = self.extra.get('tolerance', self.tolerance)"
            },
            "4": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self.as_sql("
            },
            "5": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            compiler, connection,"
            },
            "6": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            template=\"%%(function)s(%%(expressions)s, %s)\" % tol,"
            },
            "7": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            **extra_context"
            },
            "8": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        tolerance = Value(self._handle_param("
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            self.extra.get('tolerance', self.tolerance),"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            'tolerance',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            NUMERIC_TYPES,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        ))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        clone = self.copy()"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        clone.set_source_expressions([*self.get_source_expressions(), tolerance])"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        return clone.as_sql(compiler, connection, **extra_context)"
            },
            "17": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 125,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 126,
                "PatchRowcode": " class Area(OracleToleranceMixin, GeoFunc):"
            }
        },
        "frontPatchFile": [
            "import warnings",
            "from decimal import Decimal",
            "",
            "from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField",
            "from django.contrib.gis.db.models.sql import AreaField, DistanceField",
            "from django.contrib.gis.geos import GEOSGeometry",
            "from django.core.exceptions import FieldError",
            "from django.db.models import (",
            "    BooleanField, FloatField, IntegerField, TextField, Transform,",
            ")",
            "from django.db.models.expressions import Func, Value",
            "from django.db.models.functions import Cast",
            "from django.db.utils import NotSupportedError",
            "from django.utils.deprecation import RemovedInDjango30Warning",
            "from django.utils.functional import cached_property",
            "",
            "NUMERIC_TYPES = (int, float, Decimal)",
            "",
            "",
            "class GeoFuncMixin:",
            "    function = None",
            "    geom_param_pos = (0,)",
            "",
            "    def __init__(self, *expressions, **extra):",
            "        super().__init__(*expressions, **extra)",
            "",
            "        # Ensure that value expressions are geometric.",
            "        for pos in self.geom_param_pos:",
            "            expr = self.source_expressions[pos]",
            "            if not isinstance(expr, Value):",
            "                continue",
            "            try:",
            "                output_field = expr.output_field",
            "            except FieldError:",
            "                output_field = None",
            "            geom = expr.value",
            "            if not isinstance(geom, GEOSGeometry) or output_field and not isinstance(output_field, GeometryField):",
            "                raise TypeError(\"%s function requires a geometric argument in position %d.\" % (self.name, pos + 1))",
            "            if not geom.srid and not output_field:",
            "                raise ValueError(\"SRID is required for all geometries.\")",
            "            if not output_field:",
            "                self.source_expressions[pos] = Value(geom, output_field=GeometryField(srid=geom.srid))",
            "",
            "    @property",
            "    def name(self):",
            "        return self.__class__.__name__",
            "",
            "    @cached_property",
            "    def geo_field(self):",
            "        return self.source_expressions[self.geom_param_pos[0]].field",
            "",
            "    def as_sql(self, compiler, connection, function=None, **extra_context):",
            "        if not self.function and not function:",
            "            function = connection.ops.spatial_function_name(self.name)",
            "        return super().as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def resolve_expression(self, *args, **kwargs):",
            "        res = super().resolve_expression(*args, **kwargs)",
            "",
            "        # Ensure that expressions are geometric.",
            "        source_fields = res.get_source_fields()",
            "        for pos in self.geom_param_pos:",
            "            field = source_fields[pos]",
            "            if not isinstance(field, GeometryField):",
            "                raise TypeError(",
            "                    \"%s function requires a GeometryField in position %s, got %s.\" % (",
            "                        self.name, pos + 1, type(field).__name__,",
            "                    )",
            "                )",
            "",
            "        base_srid = res.geo_field.srid",
            "        for pos in self.geom_param_pos[1:]:",
            "            expr = res.source_expressions[pos]",
            "            expr_srid = expr.output_field.srid",
            "            if expr_srid != base_srid:",
            "                # Automatic SRID conversion so objects are comparable.",
            "                res.source_expressions[pos] = Transform(expr, base_srid).resolve_expression(*args, **kwargs)",
            "        return res",
            "",
            "    def _handle_param(self, value, param_name='', check_types=None):",
            "        if not hasattr(value, 'resolve_expression'):",
            "            if check_types and not isinstance(value, check_types):",
            "                raise TypeError(",
            "                    \"The %s parameter has the wrong type: should be %s.\" % (",
            "                        param_name, check_types)",
            "                )",
            "        return value",
            "",
            "",
            "class GeoFunc(GeoFuncMixin, Func):",
            "    pass",
            "",
            "",
            "class GeomOutputGeoFunc(GeoFunc):",
            "    @cached_property",
            "    def output_field(self):",
            "        return GeometryField(srid=self.geo_field.srid)",
            "",
            "",
            "class SQLiteDecimalToFloatMixin:",
            "    \"\"\"",
            "    By default, Decimal values are converted to str by the SQLite backend, which",
            "    is not acceptable by the GIS functions expecting numeric values.",
            "    \"\"\"",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        for expr in self.get_source_expressions():",
            "            if hasattr(expr, 'value') and isinstance(expr.value, Decimal):",
            "                expr.value = float(expr.value)",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class OracleToleranceMixin:",
            "    tolerance = 0.05",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        tol = self.extra.get('tolerance', self.tolerance)",
            "        return self.as_sql(",
            "            compiler, connection,",
            "            template=\"%%(function)s(%%(expressions)s, %s)\" % tol,",
            "            **extra_context",
            "        )",
            "",
            "",
            "class Area(OracleToleranceMixin, GeoFunc):",
            "    arity = 1",
            "",
            "    @cached_property",
            "    def output_field(self):",
            "        return AreaField(self.geo_field)",
            "",
            "    def as_sql(self, compiler, connection, **extra_context):",
            "        if not connection.features.supports_area_geodetic and self.geo_field.geodetic(connection):",
            "            raise NotSupportedError('Area on geodetic coordinate systems not supported.')",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection):",
            "            extra_context['template'] = '%(function)s(%(expressions)s, %(spheroid)d)'",
            "            extra_context['spheroid'] = True",
            "        return self.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Azimuth(GeoFunc):",
            "    output_field = FloatField()",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class AsGeoJSON(GeoFunc):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, bbox=False, crs=False, precision=8, **extra):",
            "        expressions = [expression]",
            "        if precision is not None:",
            "            expressions.append(self._handle_param(precision, 'precision', int))",
            "        options = 0",
            "        if crs and bbox:",
            "            options = 3",
            "        elif bbox:",
            "            options = 1",
            "        elif crs:",
            "            options = 2",
            "        if options:",
            "            expressions.append(options)",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class AsGML(GeoFunc):",
            "    geom_param_pos = (1,)",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, version=2, precision=8, **extra):",
            "        expressions = [version, expression]",
            "        if precision is not None:",
            "            expressions.append(self._handle_param(precision, 'precision', int))",
            "        super().__init__(*expressions, **extra)",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        source_expressions = self.get_source_expressions()",
            "        version = source_expressions[0]",
            "        clone = self.copy()",
            "        clone.set_source_expressions([source_expressions[1]])",
            "        extra_context['function'] = 'SDO_UTIL.TO_GML311GEOMETRY' if version.value == 3 else 'SDO_UTIL.TO_GMLGEOMETRY'",
            "        return super(AsGML, clone).as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class AsKML(AsGML):",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        # No version parameter",
            "        clone = self.copy()",
            "        clone.set_source_expressions(self.get_source_expressions()[1:])",
            "        return clone.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class AsSVG(GeoFunc):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, relative=False, precision=8, **extra):",
            "        relative = relative if hasattr(relative, 'resolve_expression') else int(relative)",
            "        expressions = [",
            "            expression,",
            "            relative,",
            "            self._handle_param(precision, 'precision', int),",
            "        ]",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class BoundingCircle(OracleToleranceMixin, GeoFunc):",
            "    def __init__(self, expression, num_seg=48, **extra):",
            "        super().__init__(expression, num_seg, **extra)",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        clone.set_source_expressions([self.get_source_expressions()[0]])",
            "        return super(BoundingCircle, clone).as_oracle(compiler, connection, **extra_context)",
            "",
            "",
            "class Centroid(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class Difference(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class DistanceResultMixin:",
            "    @cached_property",
            "    def output_field(self):",
            "        return DistanceField(self.geo_field)",
            "",
            "    def source_is_geography(self):",
            "        return self.geo_field.geography and self.geo_field.srid == 4326",
            "",
            "",
            "class Distance(DistanceResultMixin, OracleToleranceMixin, GeoFunc):",
            "    geom_param_pos = (0, 1)",
            "    spheroid = None",
            "",
            "    def __init__(self, expr1, expr2, spheroid=None, **extra):",
            "        expressions = [expr1, expr2]",
            "        if spheroid is not None:",
            "            self.spheroid = self._handle_param(spheroid, 'spheroid', bool)",
            "        super().__init__(*expressions, **extra)",
            "",
            "    def as_postgresql(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        function = None",
            "        expr2 = clone.source_expressions[1]",
            "        geography = self.source_is_geography()",
            "        if expr2.output_field.geography != geography:",
            "            if isinstance(expr2, Value):",
            "                expr2.output_field.geography = geography",
            "            else:",
            "                clone.source_expressions[1] = Cast(",
            "                    expr2,",
            "                    GeometryField(srid=expr2.output_field.srid, geography=geography),",
            "                )",
            "",
            "        if not geography and self.geo_field.geodetic(connection):",
            "            # Geometry fields with geodetic (lon/lat) coordinates need special distance functions",
            "            if self.spheroid:",
            "                # DistanceSpheroid is more accurate and resource intensive than DistanceSphere",
            "                function = connection.ops.spatial_function_name('DistanceSpheroid')",
            "                # Replace boolean param by the real spheroid of the base field",
            "                clone.source_expressions.append(Value(self.geo_field.spheroid(connection)))",
            "            else:",
            "                function = connection.ops.spatial_function_name('DistanceSphere')",
            "        return super(Distance, clone).as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection):",
            "            # SpatiaLite returns NULL instead of zero on geodetic coordinates",
            "            extra_context['template'] = 'COALESCE(%(function)s(%(expressions)s, %(spheroid)s), 0)'",
            "            extra_context['spheroid'] = int(bool(self.spheroid))",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Envelope(GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class ForcePolygonCW(GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class ForceRHR(GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        warnings.warn(",
            "            'ForceRHR is deprecated in favor of ForcePolygonCW.',",
            "            RemovedInDjango30Warning, stacklevel=2,",
            "        )",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class GeoHash(GeoFunc):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, precision=None, **extra):",
            "        expressions = [expression]",
            "        if precision is not None:",
            "            expressions.append(self._handle_param(precision, 'precision', int))",
            "        super().__init__(*expressions, **extra)",
            "",
            "    def as_mysql(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        # If no precision is provided, set it to the maximum.",
            "        if len(clone.source_expressions) < 2:",
            "            clone.source_expressions.append(Value(100))",
            "        return clone.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Intersection(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "@BaseSpatialField.register_lookup",
            "class IsValid(OracleToleranceMixin, GeoFuncMixin, Transform):",
            "    lookup_name = 'isvalid'",
            "    output_field = BooleanField()",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        sql, params = super().as_oracle(compiler, connection, **extra_context)",
            "        return \"CASE %s WHEN 'TRUE' THEN 1 ELSE 0 END\" % sql, params",
            "",
            "",
            "class Length(DistanceResultMixin, OracleToleranceMixin, GeoFunc):",
            "    def __init__(self, expr1, spheroid=True, **extra):",
            "        self.spheroid = spheroid",
            "        super().__init__(expr1, **extra)",
            "",
            "    def as_sql(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection) and not connection.features.supports_length_geodetic:",
            "            raise NotSupportedError(\"This backend doesn't support Length on geodetic fields\")",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "    def as_postgresql(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        function = None",
            "        if self.source_is_geography():",
            "            clone.source_expressions.append(Value(self.spheroid))",
            "        elif self.geo_field.geodetic(connection):",
            "            # Geometry fields with geodetic (lon/lat) coordinates need length_spheroid",
            "            function = connection.ops.spatial_function_name('LengthSpheroid')",
            "            clone.source_expressions.append(Value(self.geo_field.spheroid(connection)))",
            "        else:",
            "            dim = min(f.dim for f in self.get_source_fields() if f)",
            "            if dim > 2:",
            "                function = connection.ops.length3d",
            "        return super(Length, clone).as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        function = None",
            "        if self.geo_field.geodetic(connection):",
            "            function = 'GeodesicLength' if self.spheroid else 'GreatCircleLength'",
            "        return super().as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "",
            "class LineLocatePoint(GeoFunc):",
            "    output_field = FloatField()",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class MakeValid(GeoFunc):",
            "    pass",
            "",
            "",
            "class MemSize(GeoFunc):",
            "    output_field = IntegerField()",
            "    arity = 1",
            "",
            "",
            "class NumGeometries(GeoFunc):",
            "    output_field = IntegerField()",
            "    arity = 1",
            "",
            "",
            "class NumPoints(GeoFunc):",
            "    output_field = IntegerField()",
            "    arity = 1",
            "",
            "",
            "class Perimeter(DistanceResultMixin, OracleToleranceMixin, GeoFunc):",
            "    arity = 1",
            "",
            "    def as_postgresql(self, compiler, connection, **extra_context):",
            "        function = None",
            "        if self.geo_field.geodetic(connection) and not self.source_is_geography():",
            "            raise NotSupportedError(\"ST_Perimeter cannot use a non-projected non-geography field.\")",
            "        dim = min(f.dim for f in self.get_source_fields())",
            "        if dim > 2:",
            "            function = connection.ops.perimeter3d",
            "        return super().as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection):",
            "            raise NotSupportedError(\"Perimeter cannot use a non-projected field.\")",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class PointOnSurface(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class Reverse(GeoFunc):",
            "    arity = 1",
            "",
            "",
            "class Scale(SQLiteDecimalToFloatMixin, GeomOutputGeoFunc):",
            "    def __init__(self, expression, x, y, z=0.0, **extra):",
            "        expressions = [",
            "            expression,",
            "            self._handle_param(x, 'x', NUMERIC_TYPES),",
            "            self._handle_param(y, 'y', NUMERIC_TYPES),",
            "        ]",
            "        if z != 0.0:",
            "            expressions.append(self._handle_param(z, 'z', NUMERIC_TYPES))",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class SnapToGrid(SQLiteDecimalToFloatMixin, GeomOutputGeoFunc):",
            "    def __init__(self, expression, *args, **extra):",
            "        nargs = len(args)",
            "        expressions = [expression]",
            "        if nargs in (1, 2):",
            "            expressions.extend(",
            "                [self._handle_param(arg, '', NUMERIC_TYPES) for arg in args]",
            "            )",
            "        elif nargs == 4:",
            "            # Reverse origin and size param ordering",
            "            expressions += [",
            "                *(self._handle_param(arg, '', NUMERIC_TYPES) for arg in args[2:]),",
            "                *(self._handle_param(arg, '', NUMERIC_TYPES) for arg in args[0:2]),",
            "            ]",
            "        else:",
            "            raise ValueError('Must provide 1, 2, or 4 arguments to `SnapToGrid`.')",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class SymDifference(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class Transform(GeomOutputGeoFunc):",
            "    def __init__(self, expression, srid, **extra):",
            "        expressions = [",
            "            expression,",
            "            self._handle_param(srid, 'srid', int),",
            "        ]",
            "        if 'output_field' not in extra:",
            "            extra['output_field'] = GeometryField(srid=srid)",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class Translate(Scale):",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        if len(self.source_expressions) < 4:",
            "            # Always provide the z parameter for ST_Translate",
            "            clone.source_expressions.append(Value(0))",
            "        return super(Translate, clone).as_sqlite(compiler, connection, **extra_context)",
            "",
            "",
            "class Union(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)"
        ],
        "afterPatchFile": [
            "import warnings",
            "from decimal import Decimal",
            "",
            "from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField",
            "from django.contrib.gis.db.models.sql import AreaField, DistanceField",
            "from django.contrib.gis.geos import GEOSGeometry",
            "from django.core.exceptions import FieldError",
            "from django.db.models import (",
            "    BooleanField, FloatField, IntegerField, TextField, Transform,",
            ")",
            "from django.db.models.expressions import Func, Value",
            "from django.db.models.functions import Cast",
            "from django.db.utils import NotSupportedError",
            "from django.utils.deprecation import RemovedInDjango30Warning",
            "from django.utils.functional import cached_property",
            "",
            "NUMERIC_TYPES = (int, float, Decimal)",
            "",
            "",
            "class GeoFuncMixin:",
            "    function = None",
            "    geom_param_pos = (0,)",
            "",
            "    def __init__(self, *expressions, **extra):",
            "        super().__init__(*expressions, **extra)",
            "",
            "        # Ensure that value expressions are geometric.",
            "        for pos in self.geom_param_pos:",
            "            expr = self.source_expressions[pos]",
            "            if not isinstance(expr, Value):",
            "                continue",
            "            try:",
            "                output_field = expr.output_field",
            "            except FieldError:",
            "                output_field = None",
            "            geom = expr.value",
            "            if not isinstance(geom, GEOSGeometry) or output_field and not isinstance(output_field, GeometryField):",
            "                raise TypeError(\"%s function requires a geometric argument in position %d.\" % (self.name, pos + 1))",
            "            if not geom.srid and not output_field:",
            "                raise ValueError(\"SRID is required for all geometries.\")",
            "            if not output_field:",
            "                self.source_expressions[pos] = Value(geom, output_field=GeometryField(srid=geom.srid))",
            "",
            "    @property",
            "    def name(self):",
            "        return self.__class__.__name__",
            "",
            "    @cached_property",
            "    def geo_field(self):",
            "        return self.source_expressions[self.geom_param_pos[0]].field",
            "",
            "    def as_sql(self, compiler, connection, function=None, **extra_context):",
            "        if not self.function and not function:",
            "            function = connection.ops.spatial_function_name(self.name)",
            "        return super().as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def resolve_expression(self, *args, **kwargs):",
            "        res = super().resolve_expression(*args, **kwargs)",
            "",
            "        # Ensure that expressions are geometric.",
            "        source_fields = res.get_source_fields()",
            "        for pos in self.geom_param_pos:",
            "            field = source_fields[pos]",
            "            if not isinstance(field, GeometryField):",
            "                raise TypeError(",
            "                    \"%s function requires a GeometryField in position %s, got %s.\" % (",
            "                        self.name, pos + 1, type(field).__name__,",
            "                    )",
            "                )",
            "",
            "        base_srid = res.geo_field.srid",
            "        for pos in self.geom_param_pos[1:]:",
            "            expr = res.source_expressions[pos]",
            "            expr_srid = expr.output_field.srid",
            "            if expr_srid != base_srid:",
            "                # Automatic SRID conversion so objects are comparable.",
            "                res.source_expressions[pos] = Transform(expr, base_srid).resolve_expression(*args, **kwargs)",
            "        return res",
            "",
            "    def _handle_param(self, value, param_name='', check_types=None):",
            "        if not hasattr(value, 'resolve_expression'):",
            "            if check_types and not isinstance(value, check_types):",
            "                raise TypeError(",
            "                    \"The %s parameter has the wrong type: should be %s.\" % (",
            "                        param_name, check_types)",
            "                )",
            "        return value",
            "",
            "",
            "class GeoFunc(GeoFuncMixin, Func):",
            "    pass",
            "",
            "",
            "class GeomOutputGeoFunc(GeoFunc):",
            "    @cached_property",
            "    def output_field(self):",
            "        return GeometryField(srid=self.geo_field.srid)",
            "",
            "",
            "class SQLiteDecimalToFloatMixin:",
            "    \"\"\"",
            "    By default, Decimal values are converted to str by the SQLite backend, which",
            "    is not acceptable by the GIS functions expecting numeric values.",
            "    \"\"\"",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        for expr in self.get_source_expressions():",
            "            if hasattr(expr, 'value') and isinstance(expr.value, Decimal):",
            "                expr.value = float(expr.value)",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class OracleToleranceMixin:",
            "    tolerance = 0.05",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        tolerance = Value(self._handle_param(",
            "            self.extra.get('tolerance', self.tolerance),",
            "            'tolerance',",
            "            NUMERIC_TYPES,",
            "        ))",
            "        clone = self.copy()",
            "        clone.set_source_expressions([*self.get_source_expressions(), tolerance])",
            "        return clone.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Area(OracleToleranceMixin, GeoFunc):",
            "    arity = 1",
            "",
            "    @cached_property",
            "    def output_field(self):",
            "        return AreaField(self.geo_field)",
            "",
            "    def as_sql(self, compiler, connection, **extra_context):",
            "        if not connection.features.supports_area_geodetic and self.geo_field.geodetic(connection):",
            "            raise NotSupportedError('Area on geodetic coordinate systems not supported.')",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection):",
            "            extra_context['template'] = '%(function)s(%(expressions)s, %(spheroid)d)'",
            "            extra_context['spheroid'] = True",
            "        return self.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Azimuth(GeoFunc):",
            "    output_field = FloatField()",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class AsGeoJSON(GeoFunc):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, bbox=False, crs=False, precision=8, **extra):",
            "        expressions = [expression]",
            "        if precision is not None:",
            "            expressions.append(self._handle_param(precision, 'precision', int))",
            "        options = 0",
            "        if crs and bbox:",
            "            options = 3",
            "        elif bbox:",
            "            options = 1",
            "        elif crs:",
            "            options = 2",
            "        if options:",
            "            expressions.append(options)",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class AsGML(GeoFunc):",
            "    geom_param_pos = (1,)",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, version=2, precision=8, **extra):",
            "        expressions = [version, expression]",
            "        if precision is not None:",
            "            expressions.append(self._handle_param(precision, 'precision', int))",
            "        super().__init__(*expressions, **extra)",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        source_expressions = self.get_source_expressions()",
            "        version = source_expressions[0]",
            "        clone = self.copy()",
            "        clone.set_source_expressions([source_expressions[1]])",
            "        extra_context['function'] = 'SDO_UTIL.TO_GML311GEOMETRY' if version.value == 3 else 'SDO_UTIL.TO_GMLGEOMETRY'",
            "        return super(AsGML, clone).as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class AsKML(AsGML):",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        # No version parameter",
            "        clone = self.copy()",
            "        clone.set_source_expressions(self.get_source_expressions()[1:])",
            "        return clone.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class AsSVG(GeoFunc):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, relative=False, precision=8, **extra):",
            "        relative = relative if hasattr(relative, 'resolve_expression') else int(relative)",
            "        expressions = [",
            "            expression,",
            "            relative,",
            "            self._handle_param(precision, 'precision', int),",
            "        ]",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class BoundingCircle(OracleToleranceMixin, GeoFunc):",
            "    def __init__(self, expression, num_seg=48, **extra):",
            "        super().__init__(expression, num_seg, **extra)",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        clone.set_source_expressions([self.get_source_expressions()[0]])",
            "        return super(BoundingCircle, clone).as_oracle(compiler, connection, **extra_context)",
            "",
            "",
            "class Centroid(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class Difference(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class DistanceResultMixin:",
            "    @cached_property",
            "    def output_field(self):",
            "        return DistanceField(self.geo_field)",
            "",
            "    def source_is_geography(self):",
            "        return self.geo_field.geography and self.geo_field.srid == 4326",
            "",
            "",
            "class Distance(DistanceResultMixin, OracleToleranceMixin, GeoFunc):",
            "    geom_param_pos = (0, 1)",
            "    spheroid = None",
            "",
            "    def __init__(self, expr1, expr2, spheroid=None, **extra):",
            "        expressions = [expr1, expr2]",
            "        if spheroid is not None:",
            "            self.spheroid = self._handle_param(spheroid, 'spheroid', bool)",
            "        super().__init__(*expressions, **extra)",
            "",
            "    def as_postgresql(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        function = None",
            "        expr2 = clone.source_expressions[1]",
            "        geography = self.source_is_geography()",
            "        if expr2.output_field.geography != geography:",
            "            if isinstance(expr2, Value):",
            "                expr2.output_field.geography = geography",
            "            else:",
            "                clone.source_expressions[1] = Cast(",
            "                    expr2,",
            "                    GeometryField(srid=expr2.output_field.srid, geography=geography),",
            "                )",
            "",
            "        if not geography and self.geo_field.geodetic(connection):",
            "            # Geometry fields with geodetic (lon/lat) coordinates need special distance functions",
            "            if self.spheroid:",
            "                # DistanceSpheroid is more accurate and resource intensive than DistanceSphere",
            "                function = connection.ops.spatial_function_name('DistanceSpheroid')",
            "                # Replace boolean param by the real spheroid of the base field",
            "                clone.source_expressions.append(Value(self.geo_field.spheroid(connection)))",
            "            else:",
            "                function = connection.ops.spatial_function_name('DistanceSphere')",
            "        return super(Distance, clone).as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection):",
            "            # SpatiaLite returns NULL instead of zero on geodetic coordinates",
            "            extra_context['template'] = 'COALESCE(%(function)s(%(expressions)s, %(spheroid)s), 0)'",
            "            extra_context['spheroid'] = int(bool(self.spheroid))",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Envelope(GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class ForcePolygonCW(GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class ForceRHR(GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        warnings.warn(",
            "            'ForceRHR is deprecated in favor of ForcePolygonCW.',",
            "            RemovedInDjango30Warning, stacklevel=2,",
            "        )",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class GeoHash(GeoFunc):",
            "    output_field = TextField()",
            "",
            "    def __init__(self, expression, precision=None, **extra):",
            "        expressions = [expression]",
            "        if precision is not None:",
            "            expressions.append(self._handle_param(precision, 'precision', int))",
            "        super().__init__(*expressions, **extra)",
            "",
            "    def as_mysql(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        # If no precision is provided, set it to the maximum.",
            "        if len(clone.source_expressions) < 2:",
            "            clone.source_expressions.append(Value(100))",
            "        return clone.as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class Intersection(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "@BaseSpatialField.register_lookup",
            "class IsValid(OracleToleranceMixin, GeoFuncMixin, Transform):",
            "    lookup_name = 'isvalid'",
            "    output_field = BooleanField()",
            "",
            "    def as_oracle(self, compiler, connection, **extra_context):",
            "        sql, params = super().as_oracle(compiler, connection, **extra_context)",
            "        return \"CASE %s WHEN 'TRUE' THEN 1 ELSE 0 END\" % sql, params",
            "",
            "",
            "class Length(DistanceResultMixin, OracleToleranceMixin, GeoFunc):",
            "    def __init__(self, expr1, spheroid=True, **extra):",
            "        self.spheroid = spheroid",
            "        super().__init__(expr1, **extra)",
            "",
            "    def as_sql(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection) and not connection.features.supports_length_geodetic:",
            "            raise NotSupportedError(\"This backend doesn't support Length on geodetic fields\")",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "    def as_postgresql(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        function = None",
            "        if self.source_is_geography():",
            "            clone.source_expressions.append(Value(self.spheroid))",
            "        elif self.geo_field.geodetic(connection):",
            "            # Geometry fields with geodetic (lon/lat) coordinates need length_spheroid",
            "            function = connection.ops.spatial_function_name('LengthSpheroid')",
            "            clone.source_expressions.append(Value(self.geo_field.spheroid(connection)))",
            "        else:",
            "            dim = min(f.dim for f in self.get_source_fields() if f)",
            "            if dim > 2:",
            "                function = connection.ops.length3d",
            "        return super(Length, clone).as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        function = None",
            "        if self.geo_field.geodetic(connection):",
            "            function = 'GeodesicLength' if self.spheroid else 'GreatCircleLength'",
            "        return super().as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "",
            "class LineLocatePoint(GeoFunc):",
            "    output_field = FloatField()",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class MakeValid(GeoFunc):",
            "    pass",
            "",
            "",
            "class MemSize(GeoFunc):",
            "    output_field = IntegerField()",
            "    arity = 1",
            "",
            "",
            "class NumGeometries(GeoFunc):",
            "    output_field = IntegerField()",
            "    arity = 1",
            "",
            "",
            "class NumPoints(GeoFunc):",
            "    output_field = IntegerField()",
            "    arity = 1",
            "",
            "",
            "class Perimeter(DistanceResultMixin, OracleToleranceMixin, GeoFunc):",
            "    arity = 1",
            "",
            "    def as_postgresql(self, compiler, connection, **extra_context):",
            "        function = None",
            "        if self.geo_field.geodetic(connection) and not self.source_is_geography():",
            "            raise NotSupportedError(\"ST_Perimeter cannot use a non-projected non-geography field.\")",
            "        dim = min(f.dim for f in self.get_source_fields())",
            "        if dim > 2:",
            "            function = connection.ops.perimeter3d",
            "        return super().as_sql(compiler, connection, function=function, **extra_context)",
            "",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        if self.geo_field.geodetic(connection):",
            "            raise NotSupportedError(\"Perimeter cannot use a non-projected field.\")",
            "        return super().as_sql(compiler, connection, **extra_context)",
            "",
            "",
            "class PointOnSurface(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 1",
            "",
            "",
            "class Reverse(GeoFunc):",
            "    arity = 1",
            "",
            "",
            "class Scale(SQLiteDecimalToFloatMixin, GeomOutputGeoFunc):",
            "    def __init__(self, expression, x, y, z=0.0, **extra):",
            "        expressions = [",
            "            expression,",
            "            self._handle_param(x, 'x', NUMERIC_TYPES),",
            "            self._handle_param(y, 'y', NUMERIC_TYPES),",
            "        ]",
            "        if z != 0.0:",
            "            expressions.append(self._handle_param(z, 'z', NUMERIC_TYPES))",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class SnapToGrid(SQLiteDecimalToFloatMixin, GeomOutputGeoFunc):",
            "    def __init__(self, expression, *args, **extra):",
            "        nargs = len(args)",
            "        expressions = [expression]",
            "        if nargs in (1, 2):",
            "            expressions.extend(",
            "                [self._handle_param(arg, '', NUMERIC_TYPES) for arg in args]",
            "            )",
            "        elif nargs == 4:",
            "            # Reverse origin and size param ordering",
            "            expressions += [",
            "                *(self._handle_param(arg, '', NUMERIC_TYPES) for arg in args[2:]),",
            "                *(self._handle_param(arg, '', NUMERIC_TYPES) for arg in args[0:2]),",
            "            ]",
            "        else:",
            "            raise ValueError('Must provide 1, 2, or 4 arguments to `SnapToGrid`.')",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class SymDifference(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)",
            "",
            "",
            "class Transform(GeomOutputGeoFunc):",
            "    def __init__(self, expression, srid, **extra):",
            "        expressions = [",
            "            expression,",
            "            self._handle_param(srid, 'srid', int),",
            "        ]",
            "        if 'output_field' not in extra:",
            "            extra['output_field'] = GeometryField(srid=srid)",
            "        super().__init__(*expressions, **extra)",
            "",
            "",
            "class Translate(Scale):",
            "    def as_sqlite(self, compiler, connection, **extra_context):",
            "        clone = self.copy()",
            "        if len(self.source_expressions) < 4:",
            "            # Always provide the z parameter for ST_Translate",
            "            clone.source_expressions.append(Value(0))",
            "        return super(Translate, clone).as_sqlite(compiler, connection, **extra_context)",
            "",
            "",
            "class Union(OracleToleranceMixin, GeomOutputGeoFunc):",
            "    arity = 2",
            "    geom_param_pos = (0, 1)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "116": [
                "OracleToleranceMixin",
                "as_oracle"
            ],
            "117": [
                "OracleToleranceMixin",
                "as_oracle"
            ],
            "118": [
                "OracleToleranceMixin",
                "as_oracle"
            ],
            "119": [
                "OracleToleranceMixin",
                "as_oracle"
            ],
            "120": [
                "OracleToleranceMixin",
                "as_oracle"
            ],
            "121": [
                "OracleToleranceMixin",
                "as_oracle"
            ]
        },
        "addLocation": []
    }
}