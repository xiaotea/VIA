{
    "synapse/config/_base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         with open(file_path) as file_stream:"
            },
            "1": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "             return file_stream.read()"
            },
            "2": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 205,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+    def read_template(self, filename: str) -> jinja2.Template:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+        \"\"\"Load a template file from disk."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        This function will attempt to load the given template from the default Synapse"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        template directory."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        Files read are treated as Jinja templates. The templates is not rendered yet"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        and has autoescape enabled."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        Args:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            filename: A template filename to read."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        Raises:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            ConfigError: if the file's path is incorrect or otherwise cannot be read."
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        Returns:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+            A jinja2 template."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        \"\"\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        return self.read_templates([filename])[0]"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "     def read_templates("
            },
            "24": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self,"
            },
            "25": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filenames: List[str],"
            },
            "26": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        custom_template_directory: Optional[str] = None,"
            },
            "27": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        autoescape: bool = False,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        self, filenames: List[str], custom_template_directory: Optional[str] = None,"
            },
            "29": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "     ) -> List[jinja2.Template]:"
            },
            "30": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         \"\"\"Load a list of template files from disk using the given variables."
            },
            "31": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         This function will attempt to load the given templates from the default Synapse"
            },
            "33": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "         template directory. If `custom_template_directory` is supplied, that directory"
            },
            "34": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         is tried first."
            },
            "35": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 234,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Files read are treated as Jinja templates. These templates are not rendered yet."
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+        Files read are treated as Jinja templates. The templates are not rendered yet"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        and have autoescape enabled."
            },
            "39": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 237,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "         Args:"
            },
            "41": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "             filenames: A list of template filenames to read."
            },
            "42": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "             custom_template_directory: A directory to try to look for the templates"
            },
            "44": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                 before using the default Synapse template directory instead."
            },
            "45": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 243,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            autoescape: Whether to autoescape variables before inserting them into the"
            },
            "47": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                template."
            },
            "48": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "49": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         Raises:"
            },
            "50": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             ConfigError: if the file's path is incorrect or otherwise cannot be read."
            },
            "51": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 246,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "         Returns:"
            },
            "53": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "             A list of jinja2 templates."
            },
            "54": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         \"\"\""
            },
            "55": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        templates = []"
            },
            "56": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         search_directories = [self.default_template_dir]"
            },
            "57": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "58": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         # The loader will first look in the custom template directory (if specified) for the"
            },
            "59": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "             search_directories.insert(0, custom_template_directory)"
            },
            "60": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 264,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "         loader = jinja2.FileSystemLoader(search_directories)"
            },
            "62": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        env = jinja2.Environment(loader=loader, autoescape=autoescape)"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+        env = jinja2.Environment(loader=loader, autoescape=jinja2.select_autoescape(),)"
            },
            "64": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 267,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "         # Update the environment with our custom filters"
            },
            "66": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         env.filters.update("
            },
            "67": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "             }"
            },
            "68": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "         )"
            },
            "69": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 275,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for filename in filenames:"
            },
            "71": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # Load the template"
            },
            "72": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            template = env.get_template(filename)"
            },
            "73": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            templates.append(template)"
            },
            "74": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "75": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return templates"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+        # Load the templates"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+        return [env.get_template(filename) for filename in filenames]"
            },
            "78": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 279,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 280,
                "PatchRowcode": " def _format_ts_filter(value: int, format: str):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2017-2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import argparse",
            "import errno",
            "import os",
            "import time",
            "import urllib.parse",
            "from collections import OrderedDict",
            "from hashlib import sha256",
            "from textwrap import dedent",
            "from typing import Any, Callable, Iterable, List, MutableMapping, Optional",
            "",
            "import attr",
            "import jinja2",
            "import pkg_resources",
            "import yaml",
            "",
            "",
            "class ConfigError(Exception):",
            "    \"\"\"Represents a problem parsing the configuration",
            "",
            "    Args:",
            "        msg:  A textual description of the error.",
            "        path: Where appropriate, an indication of where in the configuration",
            "           the problem lies.",
            "    \"\"\"",
            "",
            "    def __init__(self, msg: str, path: Optional[Iterable[str]] = None):",
            "        self.msg = msg",
            "        self.path = path",
            "",
            "",
            "# We split these messages out to allow packages to override with package",
            "# specific instructions.",
            "MISSING_REPORT_STATS_CONFIG_INSTRUCTIONS = \"\"\"\\",
            "Please opt in or out of reporting anonymized homeserver usage statistics, by",
            "setting the `report_stats` key in your config file to either True or False.",
            "\"\"\"",
            "",
            "MISSING_REPORT_STATS_SPIEL = \"\"\"\\",
            "We would really appreciate it if you could help our project out by reporting",
            "anonymized usage statistics from your homeserver. Only very basic aggregate",
            "data (e.g. number of users) will be reported, but it helps us to track the",
            "growth of the Matrix community, and helps us to make Matrix a success, as well",
            "as to convince other networks that they should peer with us.",
            "",
            "Thank you.",
            "\"\"\"",
            "",
            "MISSING_SERVER_NAME = \"\"\"\\",
            "Missing mandatory `server_name` config option.",
            "\"\"\"",
            "",
            "",
            "CONFIG_FILE_HEADER = \"\"\"\\",
            "# Configuration file for Synapse.",
            "#",
            "# This is a YAML file: see [1] for a quick introduction. Note in particular",
            "# that *indentation is important*: all the elements of a list or dictionary",
            "# should have the same indentation.",
            "#",
            "# [1] https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html",
            "",
            "\"\"\"",
            "",
            "",
            "def path_exists(file_path):",
            "    \"\"\"Check if a file exists",
            "",
            "    Unlike os.path.exists, this throws an exception if there is an error",
            "    checking if the file exists (for example, if there is a perms error on",
            "    the parent dir).",
            "",
            "    Returns:",
            "        bool: True if the file exists; False if not.",
            "    \"\"\"",
            "    try:",
            "        os.stat(file_path)",
            "        return True",
            "    except OSError as e:",
            "        if e.errno != errno.ENOENT:",
            "            raise e",
            "        return False",
            "",
            "",
            "class Config:",
            "    \"\"\"",
            "    A configuration section, containing configuration keys and values.",
            "",
            "    Attributes:",
            "        section (str): The section title of this config object, such as",
            "            \"tls\" or \"logger\". This is used to refer to it on the root",
            "            logger (for example, `config.tls.some_option`). Must be",
            "            defined in subclasses.",
            "    \"\"\"",
            "",
            "    section = None",
            "",
            "    def __init__(self, root_config=None):",
            "        self.root = root_config",
            "",
            "        # Get the path to the default Synapse template directory",
            "        self.default_template_dir = pkg_resources.resource_filename(",
            "            \"synapse\", \"res/templates\"",
            "        )",
            "",
            "    def __getattr__(self, item: str) -> Any:",
            "        \"\"\"",
            "        Try and fetch a configuration option that does not exist on this class.",
            "",
            "        This is so that existing configs that rely on `self.value`, where value",
            "        is actually from a different config section, continue to work.",
            "        \"\"\"",
            "        if item in [\"generate_config_section\", \"read_config\"]:",
            "            raise AttributeError(item)",
            "",
            "        if self.root is None:",
            "            raise AttributeError(item)",
            "        else:",
            "            return self.root._get_unclassed_config(self.section, item)",
            "",
            "    @staticmethod",
            "    def parse_size(value):",
            "        if isinstance(value, int):",
            "            return value",
            "        sizes = {\"K\": 1024, \"M\": 1024 * 1024}",
            "        size = 1",
            "        suffix = value[-1]",
            "        if suffix in sizes:",
            "            value = value[:-1]",
            "            size = sizes[suffix]",
            "        return int(value) * size",
            "",
            "    @staticmethod",
            "    def parse_duration(value):",
            "        if isinstance(value, int):",
            "            return value",
            "        second = 1000",
            "        minute = 60 * second",
            "        hour = 60 * minute",
            "        day = 24 * hour",
            "        week = 7 * day",
            "        year = 365 * day",
            "        sizes = {\"s\": second, \"m\": minute, \"h\": hour, \"d\": day, \"w\": week, \"y\": year}",
            "        size = 1",
            "        suffix = value[-1]",
            "        if suffix in sizes:",
            "            value = value[:-1]",
            "            size = sizes[suffix]",
            "        return int(value) * size",
            "",
            "    @staticmethod",
            "    def abspath(file_path):",
            "        return os.path.abspath(file_path) if file_path else file_path",
            "",
            "    @classmethod",
            "    def path_exists(cls, file_path):",
            "        return path_exists(file_path)",
            "",
            "    @classmethod",
            "    def check_file(cls, file_path, config_name):",
            "        if file_path is None:",
            "            raise ConfigError(\"Missing config for %s.\" % (config_name,))",
            "        try:",
            "            os.stat(file_path)",
            "        except OSError as e:",
            "            raise ConfigError(",
            "                \"Error accessing file '%s' (config for %s): %s\"",
            "                % (file_path, config_name, e.strerror)",
            "            )",
            "        return cls.abspath(file_path)",
            "",
            "    @classmethod",
            "    def ensure_directory(cls, dir_path):",
            "        dir_path = cls.abspath(dir_path)",
            "        try:",
            "            os.makedirs(dir_path)",
            "        except OSError as e:",
            "            if e.errno != errno.EEXIST:",
            "                raise",
            "        if not os.path.isdir(dir_path):",
            "            raise ConfigError(\"%s is not a directory\" % (dir_path,))",
            "        return dir_path",
            "",
            "    @classmethod",
            "    def read_file(cls, file_path, config_name):",
            "        cls.check_file(file_path, config_name)",
            "        with open(file_path) as file_stream:",
            "            return file_stream.read()",
            "",
            "    def read_templates(",
            "        self,",
            "        filenames: List[str],",
            "        custom_template_directory: Optional[str] = None,",
            "        autoescape: bool = False,",
            "    ) -> List[jinja2.Template]:",
            "        \"\"\"Load a list of template files from disk using the given variables.",
            "",
            "        This function will attempt to load the given templates from the default Synapse",
            "        template directory. If `custom_template_directory` is supplied, that directory",
            "        is tried first.",
            "",
            "        Files read are treated as Jinja templates. These templates are not rendered yet.",
            "",
            "        Args:",
            "            filenames: A list of template filenames to read.",
            "",
            "            custom_template_directory: A directory to try to look for the templates",
            "                before using the default Synapse template directory instead.",
            "",
            "            autoescape: Whether to autoescape variables before inserting them into the",
            "                template.",
            "",
            "        Raises:",
            "            ConfigError: if the file's path is incorrect or otherwise cannot be read.",
            "",
            "        Returns:",
            "            A list of jinja2 templates.",
            "        \"\"\"",
            "        templates = []",
            "        search_directories = [self.default_template_dir]",
            "",
            "        # The loader will first look in the custom template directory (if specified) for the",
            "        # given filename. If it doesn't find it, it will use the default template dir instead",
            "        if custom_template_directory:",
            "            # Check that the given template directory exists",
            "            if not self.path_exists(custom_template_directory):",
            "                raise ConfigError(",
            "                    \"Configured template directory does not exist: %s\"",
            "                    % (custom_template_directory,)",
            "                )",
            "",
            "            # Search the custom template directory as well",
            "            search_directories.insert(0, custom_template_directory)",
            "",
            "        loader = jinja2.FileSystemLoader(search_directories)",
            "        env = jinja2.Environment(loader=loader, autoescape=autoescape)",
            "",
            "        # Update the environment with our custom filters",
            "        env.filters.update(",
            "            {",
            "                \"format_ts\": _format_ts_filter,",
            "                \"mxc_to_http\": _create_mxc_to_http_filter(self.public_baseurl),",
            "            }",
            "        )",
            "",
            "        for filename in filenames:",
            "            # Load the template",
            "            template = env.get_template(filename)",
            "            templates.append(template)",
            "",
            "        return templates",
            "",
            "",
            "def _format_ts_filter(value: int, format: str):",
            "    return time.strftime(format, time.localtime(value / 1000))",
            "",
            "",
            "def _create_mxc_to_http_filter(public_baseurl: str) -> Callable:",
            "    \"\"\"Create and return a jinja2 filter that converts MXC urls to HTTP",
            "",
            "    Args:",
            "        public_baseurl: The public, accessible base URL of the homeserver",
            "    \"\"\"",
            "",
            "    def mxc_to_http_filter(value, width, height, resize_method=\"crop\"):",
            "        if value[0:6] != \"mxc://\":",
            "            return \"\"",
            "",
            "        server_and_media_id = value[6:]",
            "        fragment = None",
            "        if \"#\" in server_and_media_id:",
            "            server_and_media_id, fragment = server_and_media_id.split(\"#\", 1)",
            "            fragment = \"#\" + fragment",
            "",
            "        params = {\"width\": width, \"height\": height, \"method\": resize_method}",
            "        return \"%s_matrix/media/v1/thumbnail/%s?%s%s\" % (",
            "            public_baseurl,",
            "            server_and_media_id,",
            "            urllib.parse.urlencode(params),",
            "            fragment or \"\",",
            "        )",
            "",
            "    return mxc_to_http_filter",
            "",
            "",
            "class RootConfig:",
            "    \"\"\"",
            "    Holder of an application's configuration.",
            "",
            "    What configuration this object holds is defined by `config_classes`, a list",
            "    of Config classes that will be instantiated and given the contents of a",
            "    configuration file to read. They can then be accessed on this class by their",
            "    section name, defined in the Config or dynamically set to be the name of the",
            "    class, lower-cased and with \"Config\" removed.",
            "    \"\"\"",
            "",
            "    config_classes = []",
            "",
            "    def __init__(self):",
            "        self._configs = OrderedDict()",
            "",
            "        for config_class in self.config_classes:",
            "            if config_class.section is None:",
            "                raise ValueError(\"%r requires a section name\" % (config_class,))",
            "",
            "            try:",
            "                conf = config_class(self)",
            "            except Exception as e:",
            "                raise Exception(\"Failed making %s: %r\" % (config_class.section, e))",
            "            self._configs[config_class.section] = conf",
            "",
            "    def __getattr__(self, item: str) -> Any:",
            "        \"\"\"",
            "        Redirect lookups on this object either to config objects, or values on",
            "        config objects, so that `config.tls.blah` works, as well as legacy uses",
            "        of things like `config.server_name`. It will first look up the config",
            "        section name, and then values on those config classes.",
            "        \"\"\"",
            "        if item in self._configs.keys():",
            "            return self._configs[item]",
            "",
            "        return self._get_unclassed_config(None, item)",
            "",
            "    def _get_unclassed_config(self, asking_section: Optional[str], item: str):",
            "        \"\"\"",
            "        Fetch a config value from one of the instantiated config classes that",
            "        has not been fetched directly.",
            "",
            "        Args:",
            "            asking_section: If this check is coming from a Config child, which",
            "                one? This section will not be asked if it has the value.",
            "            item: The configuration value key.",
            "",
            "        Raises:",
            "            AttributeError if no config classes have the config key. The body",
            "                will contain what sections were checked.",
            "        \"\"\"",
            "        for key, val in self._configs.items():",
            "            if key == asking_section:",
            "                continue",
            "",
            "            if item in dir(val):",
            "                return getattr(val, item)",
            "",
            "        raise AttributeError(item, \"not found in %s\" % (list(self._configs.keys()),))",
            "",
            "    def invoke_all(self, func_name: str, *args, **kwargs) -> MutableMapping[str, Any]:",
            "        \"\"\"",
            "        Invoke a function on all instantiated config objects this RootConfig is",
            "        configured to use.",
            "",
            "        Args:",
            "            func_name: Name of function to invoke",
            "            *args",
            "            **kwargs",
            "        Returns:",
            "            ordered dictionary of config section name and the result of the",
            "            function from it.",
            "        \"\"\"",
            "        res = OrderedDict()",
            "",
            "        for name, config in self._configs.items():",
            "            if hasattr(config, func_name):",
            "                res[name] = getattr(config, func_name)(*args, **kwargs)",
            "",
            "        return res",
            "",
            "    @classmethod",
            "    def invoke_all_static(cls, func_name: str, *args, **kwargs):",
            "        \"\"\"",
            "        Invoke a static function on config objects this RootConfig is",
            "        configured to use.",
            "",
            "        Args:",
            "            func_name: Name of function to invoke",
            "            *args",
            "            **kwargs",
            "        Returns:",
            "            ordered dictionary of config section name and the result of the",
            "            function from it.",
            "        \"\"\"",
            "        for config in cls.config_classes:",
            "            if hasattr(config, func_name):",
            "                getattr(config, func_name)(*args, **kwargs)",
            "",
            "    def generate_config(",
            "        self,",
            "        config_dir_path,",
            "        data_dir_path,",
            "        server_name,",
            "        generate_secrets=False,",
            "        report_stats=None,",
            "        open_private_ports=False,",
            "        listeners=None,",
            "        tls_certificate_path=None,",
            "        tls_private_key_path=None,",
            "        acme_domain=None,",
            "    ):",
            "        \"\"\"",
            "        Build a default configuration file",
            "",
            "        This is used when the user explicitly asks us to generate a config file",
            "        (eg with --generate_config).",
            "",
            "        Args:",
            "            config_dir_path (str): The path where the config files are kept. Used to",
            "                create filenames for things like the log config and the signing key.",
            "",
            "            data_dir_path (str): The path where the data files are kept. Used to create",
            "                filenames for things like the database and media store.",
            "",
            "            server_name (str): The server name. Used to initialise the server_name",
            "                config param, but also used in the names of some of the config files.",
            "",
            "            generate_secrets (bool): True if we should generate new secrets for things",
            "                like the macaroon_secret_key. If False, these parameters will be left",
            "                unset.",
            "",
            "            report_stats (bool|None): Initial setting for the report_stats setting.",
            "                If None, report_stats will be left unset.",
            "",
            "            open_private_ports (bool): True to leave private ports (such as the non-TLS",
            "                HTTP listener) open to the internet.",
            "",
            "            listeners (list(dict)|None): A list of descriptions of the listeners",
            "                synapse should start with each of which specifies a port (str), a list of",
            "                resources (list(str)), tls (bool) and type (str). For example:",
            "                [{",
            "                    \"port\": 8448,",
            "                    \"resources\": [{\"names\": [\"federation\"]}],",
            "                    \"tls\": True,",
            "                    \"type\": \"http\",",
            "                },",
            "                {",
            "                    \"port\": 443,",
            "                    \"resources\": [{\"names\": [\"client\"]}],",
            "                    \"tls\": False,",
            "                    \"type\": \"http\",",
            "                }],",
            "",
            "",
            "            database (str|None): The database type to configure, either `psycog2`",
            "                or `sqlite3`.",
            "",
            "            tls_certificate_path (str|None): The path to the tls certificate.",
            "",
            "            tls_private_key_path (str|None): The path to the tls private key.",
            "",
            "            acme_domain (str|None): The domain acme will try to validate. If",
            "                specified acme will be enabled.",
            "",
            "        Returns:",
            "            str: the yaml config file",
            "        \"\"\"",
            "",
            "        return CONFIG_FILE_HEADER + \"\\n\\n\".join(",
            "            dedent(conf)",
            "            for conf in self.invoke_all(",
            "                \"generate_config_section\",",
            "                config_dir_path=config_dir_path,",
            "                data_dir_path=data_dir_path,",
            "                server_name=server_name,",
            "                generate_secrets=generate_secrets,",
            "                report_stats=report_stats,",
            "                open_private_ports=open_private_ports,",
            "                listeners=listeners,",
            "                tls_certificate_path=tls_certificate_path,",
            "                tls_private_key_path=tls_private_key_path,",
            "                acme_domain=acme_domain,",
            "            ).values()",
            "        )",
            "",
            "    @classmethod",
            "    def load_config(cls, description, argv):",
            "        \"\"\"Parse the commandline and config files",
            "",
            "        Doesn't support config-file-generation: used by the worker apps.",
            "",
            "        Returns: Config object.",
            "        \"\"\"",
            "        config_parser = argparse.ArgumentParser(description=description)",
            "        cls.add_arguments_to_parser(config_parser)",
            "        obj, _ = cls.load_config_with_parser(config_parser, argv)",
            "",
            "        return obj",
            "",
            "    @classmethod",
            "    def add_arguments_to_parser(cls, config_parser):",
            "        \"\"\"Adds all the config flags to an ArgumentParser.",
            "",
            "        Doesn't support config-file-generation: used by the worker apps.",
            "",
            "        Used for workers where we want to add extra flags/subcommands.",
            "",
            "        Args:",
            "            config_parser (ArgumentParser): App description",
            "        \"\"\"",
            "",
            "        config_parser.add_argument(",
            "            \"-c\",",
            "            \"--config-path\",",
            "            action=\"append\",",
            "            metavar=\"CONFIG_FILE\",",
            "            help=\"Specify config file. Can be given multiple times and\"",
            "            \" may specify directories containing *.yaml files.\",",
            "        )",
            "",
            "        config_parser.add_argument(",
            "            \"--keys-directory\",",
            "            metavar=\"DIRECTORY\",",
            "            help=\"Where files such as certs and signing keys are stored when\"",
            "            \" their location is not given explicitly in the config.\"",
            "            \" Defaults to the directory containing the last config file\",",
            "        )",
            "",
            "        cls.invoke_all_static(\"add_arguments\", config_parser)",
            "",
            "    @classmethod",
            "    def load_config_with_parser(cls, parser, argv):",
            "        \"\"\"Parse the commandline and config files with the given parser",
            "",
            "        Doesn't support config-file-generation: used by the worker apps.",
            "",
            "        Used for workers where we want to add extra flags/subcommands.",
            "",
            "        Args:",
            "            parser (ArgumentParser)",
            "            argv (list[str])",
            "",
            "        Returns:",
            "            tuple[HomeServerConfig, argparse.Namespace]: Returns the parsed",
            "            config object and the parsed argparse.Namespace object from",
            "            `parser.parse_args(..)`",
            "        \"\"\"",
            "",
            "        obj = cls()",
            "",
            "        config_args = parser.parse_args(argv)",
            "",
            "        config_files = find_config_files(search_paths=config_args.config_path)",
            "",
            "        if not config_files:",
            "            parser.error(\"Must supply a config file.\")",
            "",
            "        if config_args.keys_directory:",
            "            config_dir_path = config_args.keys_directory",
            "        else:",
            "            config_dir_path = os.path.dirname(config_files[-1])",
            "        config_dir_path = os.path.abspath(config_dir_path)",
            "        data_dir_path = os.getcwd()",
            "",
            "        config_dict = read_config_files(config_files)",
            "        obj.parse_config_dict(",
            "            config_dict, config_dir_path=config_dir_path, data_dir_path=data_dir_path",
            "        )",
            "",
            "        obj.invoke_all(\"read_arguments\", config_args)",
            "",
            "        return obj, config_args",
            "",
            "    @classmethod",
            "    def load_or_generate_config(cls, description, argv):",
            "        \"\"\"Parse the commandline and config files",
            "",
            "        Supports generation of config files, so is used for the main homeserver app.",
            "",
            "        Returns: Config object, or None if --generate-config or --generate-keys was set",
            "        \"\"\"",
            "        parser = argparse.ArgumentParser(description=description)",
            "        parser.add_argument(",
            "            \"-c\",",
            "            \"--config-path\",",
            "            action=\"append\",",
            "            metavar=\"CONFIG_FILE\",",
            "            help=\"Specify config file. Can be given multiple times and\"",
            "            \" may specify directories containing *.yaml files.\",",
            "        )",
            "",
            "        generate_group = parser.add_argument_group(\"Config generation\")",
            "        generate_group.add_argument(",
            "            \"--generate-config\",",
            "            action=\"store_true\",",
            "            help=\"Generate a config file, then exit.\",",
            "        )",
            "        generate_group.add_argument(",
            "            \"--generate-missing-configs\",",
            "            \"--generate-keys\",",
            "            action=\"store_true\",",
            "            help=\"Generate any missing additional config files, then exit.\",",
            "        )",
            "        generate_group.add_argument(",
            "            \"-H\", \"--server-name\", help=\"The server name to generate a config file for.\"",
            "        )",
            "        generate_group.add_argument(",
            "            \"--report-stats\",",
            "            action=\"store\",",
            "            help=\"Whether the generated config reports anonymized usage statistics.\",",
            "            choices=[\"yes\", \"no\"],",
            "        )",
            "        generate_group.add_argument(",
            "            \"--config-directory\",",
            "            \"--keys-directory\",",
            "            metavar=\"DIRECTORY\",",
            "            help=(",
            "                \"Specify where additional config files such as signing keys and log\"",
            "                \" config should be stored. Defaults to the same directory as the last\"",
            "                \" config file.\"",
            "            ),",
            "        )",
            "        generate_group.add_argument(",
            "            \"--data-directory\",",
            "            metavar=\"DIRECTORY\",",
            "            help=(",
            "                \"Specify where data such as the media store and database file should be\"",
            "                \" stored. Defaults to the current working directory.\"",
            "            ),",
            "        )",
            "        generate_group.add_argument(",
            "            \"--open-private-ports\",",
            "            action=\"store_true\",",
            "            help=(",
            "                \"Leave private ports (such as the non-TLS HTTP listener) open to the\"",
            "                \" internet. Do not use this unless you know what you are doing.\"",
            "            ),",
            "        )",
            "",
            "        cls.invoke_all_static(\"add_arguments\", parser)",
            "        config_args = parser.parse_args(argv)",
            "",
            "        config_files = find_config_files(search_paths=config_args.config_path)",
            "",
            "        if not config_files:",
            "            parser.error(",
            "                \"Must supply a config file.\\nA config file can be automatically\"",
            "                ' generated using \"--generate-config -H SERVER_NAME'",
            "                ' -c CONFIG-FILE\"'",
            "            )",
            "",
            "        if config_args.config_directory:",
            "            config_dir_path = config_args.config_directory",
            "        else:",
            "            config_dir_path = os.path.dirname(config_files[-1])",
            "        config_dir_path = os.path.abspath(config_dir_path)",
            "        data_dir_path = os.getcwd()",
            "",
            "        generate_missing_configs = config_args.generate_missing_configs",
            "",
            "        obj = cls()",
            "",
            "        if config_args.generate_config:",
            "            if config_args.report_stats is None:",
            "                parser.error(",
            "                    \"Please specify either --report-stats=yes or --report-stats=no\\n\\n\"",
            "                    + MISSING_REPORT_STATS_SPIEL",
            "                )",
            "",
            "            (config_path,) = config_files",
            "            if not path_exists(config_path):",
            "                print(\"Generating config file %s\" % (config_path,))",
            "",
            "                if config_args.data_directory:",
            "                    data_dir_path = config_args.data_directory",
            "                else:",
            "                    data_dir_path = os.getcwd()",
            "                data_dir_path = os.path.abspath(data_dir_path)",
            "",
            "                server_name = config_args.server_name",
            "                if not server_name:",
            "                    raise ConfigError(",
            "                        \"Must specify a server_name to a generate config for.\"",
            "                        \" Pass -H server.name.\"",
            "                    )",
            "",
            "                config_str = obj.generate_config(",
            "                    config_dir_path=config_dir_path,",
            "                    data_dir_path=data_dir_path,",
            "                    server_name=server_name,",
            "                    report_stats=(config_args.report_stats == \"yes\"),",
            "                    generate_secrets=True,",
            "                    open_private_ports=config_args.open_private_ports,",
            "                )",
            "",
            "                if not path_exists(config_dir_path):",
            "                    os.makedirs(config_dir_path)",
            "                with open(config_path, \"w\") as config_file:",
            "                    config_file.write(config_str)",
            "                    config_file.write(\"\\n\\n# vim:ft=yaml\")",
            "",
            "                config_dict = yaml.safe_load(config_str)",
            "                obj.generate_missing_files(config_dict, config_dir_path)",
            "",
            "                print(",
            "                    (",
            "                        \"A config file has been generated in %r for server name\"",
            "                        \" %r. Please review this file and customise it\"",
            "                        \" to your needs.\"",
            "                    )",
            "                    % (config_path, server_name)",
            "                )",
            "                return",
            "            else:",
            "                print(",
            "                    (",
            "                        \"Config file %r already exists. Generating any missing config\"",
            "                        \" files.\"",
            "                    )",
            "                    % (config_path,)",
            "                )",
            "                generate_missing_configs = True",
            "",
            "        config_dict = read_config_files(config_files)",
            "        if generate_missing_configs:",
            "            obj.generate_missing_files(config_dict, config_dir_path)",
            "            return None",
            "",
            "        obj.parse_config_dict(",
            "            config_dict, config_dir_path=config_dir_path, data_dir_path=data_dir_path",
            "        )",
            "        obj.invoke_all(\"read_arguments\", config_args)",
            "",
            "        return obj",
            "",
            "    def parse_config_dict(self, config_dict, config_dir_path=None, data_dir_path=None):",
            "        \"\"\"Read the information from the config dict into this Config object.",
            "",
            "        Args:",
            "            config_dict (dict): Configuration data, as read from the yaml",
            "",
            "            config_dir_path (str): The path where the config files are kept. Used to",
            "                create filenames for things like the log config and the signing key.",
            "",
            "            data_dir_path (str): The path where the data files are kept. Used to create",
            "                filenames for things like the database and media store.",
            "        \"\"\"",
            "        self.invoke_all(",
            "            \"read_config\",",
            "            config_dict,",
            "            config_dir_path=config_dir_path,",
            "            data_dir_path=data_dir_path,",
            "        )",
            "",
            "    def generate_missing_files(self, config_dict, config_dir_path):",
            "        self.invoke_all(\"generate_files\", config_dict, config_dir_path)",
            "",
            "",
            "def read_config_files(config_files):",
            "    \"\"\"Read the config files into a dict",
            "",
            "    Args:",
            "        config_files (iterable[str]): A list of the config files to read",
            "",
            "    Returns: dict",
            "    \"\"\"",
            "    specified_config = {}",
            "    for config_file in config_files:",
            "        with open(config_file) as file_stream:",
            "            yaml_config = yaml.safe_load(file_stream)",
            "",
            "        if not isinstance(yaml_config, dict):",
            "            err = \"File %r is empty or doesn't parse into a key-value map. IGNORING.\"",
            "            print(err % (config_file,))",
            "            continue",
            "",
            "        specified_config.update(yaml_config)",
            "",
            "    if \"server_name\" not in specified_config:",
            "        raise ConfigError(MISSING_SERVER_NAME)",
            "",
            "    if \"report_stats\" not in specified_config:",
            "        raise ConfigError(",
            "            MISSING_REPORT_STATS_CONFIG_INSTRUCTIONS + \"\\n\" + MISSING_REPORT_STATS_SPIEL",
            "        )",
            "    return specified_config",
            "",
            "",
            "def find_config_files(search_paths):",
            "    \"\"\"Finds config files using a list of search paths. If a path is a file",
            "    then that file path is added to the list. If a search path is a directory",
            "    then all the \"*.yaml\" files in that directory are added to the list in",
            "    sorted order.",
            "",
            "    Args:",
            "        search_paths(list(str)): A list of paths to search.",
            "",
            "    Returns:",
            "        list(str): A list of file paths.",
            "    \"\"\"",
            "",
            "    config_files = []",
            "    if search_paths:",
            "        for config_path in search_paths:",
            "            if os.path.isdir(config_path):",
            "                # We accept specifying directories as config paths, we search",
            "                # inside that directory for all files matching *.yaml, and then",
            "                # we apply them in *sorted* order.",
            "                files = []",
            "                for entry in os.listdir(config_path):",
            "                    entry_path = os.path.join(config_path, entry)",
            "                    if not os.path.isfile(entry_path):",
            "                        err = \"Found subdirectory in config directory: %r. IGNORING.\"",
            "                        print(err % (entry_path,))",
            "                        continue",
            "",
            "                    if not entry.endswith(\".yaml\"):",
            "                        err = (",
            "                            \"Found file in config directory that does not end in \"",
            "                            \"'.yaml': %r. IGNORING.\"",
            "                        )",
            "                        print(err % (entry_path,))",
            "                        continue",
            "",
            "                    files.append(entry_path)",
            "",
            "                config_files.extend(sorted(files))",
            "            else:",
            "                config_files.append(config_path)",
            "    return config_files",
            "",
            "",
            "@attr.s",
            "class ShardedWorkerHandlingConfig:",
            "    \"\"\"Algorithm for choosing which instance is responsible for handling some",
            "    sharded work.",
            "",
            "    For example, the federation senders use this to determine which instances",
            "    handles sending stuff to a given destination (which is used as the `key`",
            "    below).",
            "    \"\"\"",
            "",
            "    instances = attr.ib(type=List[str])",
            "",
            "    def should_handle(self, instance_name: str, key: str) -> bool:",
            "        \"\"\"Whether this instance is responsible for handling the given key.",
            "        \"\"\"",
            "        # If multiple instances are not defined we always return true",
            "        if not self.instances or len(self.instances) == 1:",
            "            return True",
            "",
            "        return self.get_instance(key) == instance_name",
            "",
            "    def get_instance(self, key: str) -> str:",
            "        \"\"\"Get the instance responsible for handling the given key.",
            "",
            "        Note: For things like federation sending the config for which instance",
            "        is sending is known only to the sender instance if there is only one.",
            "        Therefore `should_handle` should be used where possible.",
            "        \"\"\"",
            "",
            "        if not self.instances:",
            "            return \"master\"",
            "",
            "        if len(self.instances) == 1:",
            "            return self.instances[0]",
            "",
            "        # We shard by taking the hash, modulo it by the number of instances and",
            "        # then checking whether this instance matches the instance at that",
            "        # index.",
            "        #",
            "        # (Technically this introduces some bias and is not entirely uniform,",
            "        # but since the hash is so large the bias is ridiculously small).",
            "        dest_hash = sha256(key.encode(\"utf8\")).digest()",
            "        dest_int = int.from_bytes(dest_hash, byteorder=\"little\")",
            "        remainder = dest_int % (len(self.instances))",
            "        return self.instances[remainder]",
            "",
            "",
            "__all__ = [\"Config\", \"RootConfig\", \"ShardedWorkerHandlingConfig\"]"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2014-2016 OpenMarket Ltd",
            "# Copyright 2017-2018 New Vector Ltd",
            "# Copyright 2019 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import argparse",
            "import errno",
            "import os",
            "import time",
            "import urllib.parse",
            "from collections import OrderedDict",
            "from hashlib import sha256",
            "from textwrap import dedent",
            "from typing import Any, Callable, Iterable, List, MutableMapping, Optional",
            "",
            "import attr",
            "import jinja2",
            "import pkg_resources",
            "import yaml",
            "",
            "",
            "class ConfigError(Exception):",
            "    \"\"\"Represents a problem parsing the configuration",
            "",
            "    Args:",
            "        msg:  A textual description of the error.",
            "        path: Where appropriate, an indication of where in the configuration",
            "           the problem lies.",
            "    \"\"\"",
            "",
            "    def __init__(self, msg: str, path: Optional[Iterable[str]] = None):",
            "        self.msg = msg",
            "        self.path = path",
            "",
            "",
            "# We split these messages out to allow packages to override with package",
            "# specific instructions.",
            "MISSING_REPORT_STATS_CONFIG_INSTRUCTIONS = \"\"\"\\",
            "Please opt in or out of reporting anonymized homeserver usage statistics, by",
            "setting the `report_stats` key in your config file to either True or False.",
            "\"\"\"",
            "",
            "MISSING_REPORT_STATS_SPIEL = \"\"\"\\",
            "We would really appreciate it if you could help our project out by reporting",
            "anonymized usage statistics from your homeserver. Only very basic aggregate",
            "data (e.g. number of users) will be reported, but it helps us to track the",
            "growth of the Matrix community, and helps us to make Matrix a success, as well",
            "as to convince other networks that they should peer with us.",
            "",
            "Thank you.",
            "\"\"\"",
            "",
            "MISSING_SERVER_NAME = \"\"\"\\",
            "Missing mandatory `server_name` config option.",
            "\"\"\"",
            "",
            "",
            "CONFIG_FILE_HEADER = \"\"\"\\",
            "# Configuration file for Synapse.",
            "#",
            "# This is a YAML file: see [1] for a quick introduction. Note in particular",
            "# that *indentation is important*: all the elements of a list or dictionary",
            "# should have the same indentation.",
            "#",
            "# [1] https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html",
            "",
            "\"\"\"",
            "",
            "",
            "def path_exists(file_path):",
            "    \"\"\"Check if a file exists",
            "",
            "    Unlike os.path.exists, this throws an exception if there is an error",
            "    checking if the file exists (for example, if there is a perms error on",
            "    the parent dir).",
            "",
            "    Returns:",
            "        bool: True if the file exists; False if not.",
            "    \"\"\"",
            "    try:",
            "        os.stat(file_path)",
            "        return True",
            "    except OSError as e:",
            "        if e.errno != errno.ENOENT:",
            "            raise e",
            "        return False",
            "",
            "",
            "class Config:",
            "    \"\"\"",
            "    A configuration section, containing configuration keys and values.",
            "",
            "    Attributes:",
            "        section (str): The section title of this config object, such as",
            "            \"tls\" or \"logger\". This is used to refer to it on the root",
            "            logger (for example, `config.tls.some_option`). Must be",
            "            defined in subclasses.",
            "    \"\"\"",
            "",
            "    section = None",
            "",
            "    def __init__(self, root_config=None):",
            "        self.root = root_config",
            "",
            "        # Get the path to the default Synapse template directory",
            "        self.default_template_dir = pkg_resources.resource_filename(",
            "            \"synapse\", \"res/templates\"",
            "        )",
            "",
            "    def __getattr__(self, item: str) -> Any:",
            "        \"\"\"",
            "        Try and fetch a configuration option that does not exist on this class.",
            "",
            "        This is so that existing configs that rely on `self.value`, where value",
            "        is actually from a different config section, continue to work.",
            "        \"\"\"",
            "        if item in [\"generate_config_section\", \"read_config\"]:",
            "            raise AttributeError(item)",
            "",
            "        if self.root is None:",
            "            raise AttributeError(item)",
            "        else:",
            "            return self.root._get_unclassed_config(self.section, item)",
            "",
            "    @staticmethod",
            "    def parse_size(value):",
            "        if isinstance(value, int):",
            "            return value",
            "        sizes = {\"K\": 1024, \"M\": 1024 * 1024}",
            "        size = 1",
            "        suffix = value[-1]",
            "        if suffix in sizes:",
            "            value = value[:-1]",
            "            size = sizes[suffix]",
            "        return int(value) * size",
            "",
            "    @staticmethod",
            "    def parse_duration(value):",
            "        if isinstance(value, int):",
            "            return value",
            "        second = 1000",
            "        minute = 60 * second",
            "        hour = 60 * minute",
            "        day = 24 * hour",
            "        week = 7 * day",
            "        year = 365 * day",
            "        sizes = {\"s\": second, \"m\": minute, \"h\": hour, \"d\": day, \"w\": week, \"y\": year}",
            "        size = 1",
            "        suffix = value[-1]",
            "        if suffix in sizes:",
            "            value = value[:-1]",
            "            size = sizes[suffix]",
            "        return int(value) * size",
            "",
            "    @staticmethod",
            "    def abspath(file_path):",
            "        return os.path.abspath(file_path) if file_path else file_path",
            "",
            "    @classmethod",
            "    def path_exists(cls, file_path):",
            "        return path_exists(file_path)",
            "",
            "    @classmethod",
            "    def check_file(cls, file_path, config_name):",
            "        if file_path is None:",
            "            raise ConfigError(\"Missing config for %s.\" % (config_name,))",
            "        try:",
            "            os.stat(file_path)",
            "        except OSError as e:",
            "            raise ConfigError(",
            "                \"Error accessing file '%s' (config for %s): %s\"",
            "                % (file_path, config_name, e.strerror)",
            "            )",
            "        return cls.abspath(file_path)",
            "",
            "    @classmethod",
            "    def ensure_directory(cls, dir_path):",
            "        dir_path = cls.abspath(dir_path)",
            "        try:",
            "            os.makedirs(dir_path)",
            "        except OSError as e:",
            "            if e.errno != errno.EEXIST:",
            "                raise",
            "        if not os.path.isdir(dir_path):",
            "            raise ConfigError(\"%s is not a directory\" % (dir_path,))",
            "        return dir_path",
            "",
            "    @classmethod",
            "    def read_file(cls, file_path, config_name):",
            "        cls.check_file(file_path, config_name)",
            "        with open(file_path) as file_stream:",
            "            return file_stream.read()",
            "",
            "    def read_template(self, filename: str) -> jinja2.Template:",
            "        \"\"\"Load a template file from disk.",
            "",
            "        This function will attempt to load the given template from the default Synapse",
            "        template directory.",
            "",
            "        Files read are treated as Jinja templates. The templates is not rendered yet",
            "        and has autoescape enabled.",
            "",
            "        Args:",
            "            filename: A template filename to read.",
            "",
            "        Raises:",
            "            ConfigError: if the file's path is incorrect or otherwise cannot be read.",
            "",
            "        Returns:",
            "            A jinja2 template.",
            "        \"\"\"",
            "        return self.read_templates([filename])[0]",
            "",
            "    def read_templates(",
            "        self, filenames: List[str], custom_template_directory: Optional[str] = None,",
            "    ) -> List[jinja2.Template]:",
            "        \"\"\"Load a list of template files from disk using the given variables.",
            "",
            "        This function will attempt to load the given templates from the default Synapse",
            "        template directory. If `custom_template_directory` is supplied, that directory",
            "        is tried first.",
            "",
            "        Files read are treated as Jinja templates. The templates are not rendered yet",
            "        and have autoescape enabled.",
            "",
            "        Args:",
            "            filenames: A list of template filenames to read.",
            "",
            "            custom_template_directory: A directory to try to look for the templates",
            "                before using the default Synapse template directory instead.",
            "",
            "        Raises:",
            "            ConfigError: if the file's path is incorrect or otherwise cannot be read.",
            "",
            "        Returns:",
            "            A list of jinja2 templates.",
            "        \"\"\"",
            "        search_directories = [self.default_template_dir]",
            "",
            "        # The loader will first look in the custom template directory (if specified) for the",
            "        # given filename. If it doesn't find it, it will use the default template dir instead",
            "        if custom_template_directory:",
            "            # Check that the given template directory exists",
            "            if not self.path_exists(custom_template_directory):",
            "                raise ConfigError(",
            "                    \"Configured template directory does not exist: %s\"",
            "                    % (custom_template_directory,)",
            "                )",
            "",
            "            # Search the custom template directory as well",
            "            search_directories.insert(0, custom_template_directory)",
            "",
            "        loader = jinja2.FileSystemLoader(search_directories)",
            "        env = jinja2.Environment(loader=loader, autoescape=jinja2.select_autoescape(),)",
            "",
            "        # Update the environment with our custom filters",
            "        env.filters.update(",
            "            {",
            "                \"format_ts\": _format_ts_filter,",
            "                \"mxc_to_http\": _create_mxc_to_http_filter(self.public_baseurl),",
            "            }",
            "        )",
            "",
            "        # Load the templates",
            "        return [env.get_template(filename) for filename in filenames]",
            "",
            "",
            "def _format_ts_filter(value: int, format: str):",
            "    return time.strftime(format, time.localtime(value / 1000))",
            "",
            "",
            "def _create_mxc_to_http_filter(public_baseurl: str) -> Callable:",
            "    \"\"\"Create and return a jinja2 filter that converts MXC urls to HTTP",
            "",
            "    Args:",
            "        public_baseurl: The public, accessible base URL of the homeserver",
            "    \"\"\"",
            "",
            "    def mxc_to_http_filter(value, width, height, resize_method=\"crop\"):",
            "        if value[0:6] != \"mxc://\":",
            "            return \"\"",
            "",
            "        server_and_media_id = value[6:]",
            "        fragment = None",
            "        if \"#\" in server_and_media_id:",
            "            server_and_media_id, fragment = server_and_media_id.split(\"#\", 1)",
            "            fragment = \"#\" + fragment",
            "",
            "        params = {\"width\": width, \"height\": height, \"method\": resize_method}",
            "        return \"%s_matrix/media/v1/thumbnail/%s?%s%s\" % (",
            "            public_baseurl,",
            "            server_and_media_id,",
            "            urllib.parse.urlencode(params),",
            "            fragment or \"\",",
            "        )",
            "",
            "    return mxc_to_http_filter",
            "",
            "",
            "class RootConfig:",
            "    \"\"\"",
            "    Holder of an application's configuration.",
            "",
            "    What configuration this object holds is defined by `config_classes`, a list",
            "    of Config classes that will be instantiated and given the contents of a",
            "    configuration file to read. They can then be accessed on this class by their",
            "    section name, defined in the Config or dynamically set to be the name of the",
            "    class, lower-cased and with \"Config\" removed.",
            "    \"\"\"",
            "",
            "    config_classes = []",
            "",
            "    def __init__(self):",
            "        self._configs = OrderedDict()",
            "",
            "        for config_class in self.config_classes:",
            "            if config_class.section is None:",
            "                raise ValueError(\"%r requires a section name\" % (config_class,))",
            "",
            "            try:",
            "                conf = config_class(self)",
            "            except Exception as e:",
            "                raise Exception(\"Failed making %s: %r\" % (config_class.section, e))",
            "            self._configs[config_class.section] = conf",
            "",
            "    def __getattr__(self, item: str) -> Any:",
            "        \"\"\"",
            "        Redirect lookups on this object either to config objects, or values on",
            "        config objects, so that `config.tls.blah` works, as well as legacy uses",
            "        of things like `config.server_name`. It will first look up the config",
            "        section name, and then values on those config classes.",
            "        \"\"\"",
            "        if item in self._configs.keys():",
            "            return self._configs[item]",
            "",
            "        return self._get_unclassed_config(None, item)",
            "",
            "    def _get_unclassed_config(self, asking_section: Optional[str], item: str):",
            "        \"\"\"",
            "        Fetch a config value from one of the instantiated config classes that",
            "        has not been fetched directly.",
            "",
            "        Args:",
            "            asking_section: If this check is coming from a Config child, which",
            "                one? This section will not be asked if it has the value.",
            "            item: The configuration value key.",
            "",
            "        Raises:",
            "            AttributeError if no config classes have the config key. The body",
            "                will contain what sections were checked.",
            "        \"\"\"",
            "        for key, val in self._configs.items():",
            "            if key == asking_section:",
            "                continue",
            "",
            "            if item in dir(val):",
            "                return getattr(val, item)",
            "",
            "        raise AttributeError(item, \"not found in %s\" % (list(self._configs.keys()),))",
            "",
            "    def invoke_all(self, func_name: str, *args, **kwargs) -> MutableMapping[str, Any]:",
            "        \"\"\"",
            "        Invoke a function on all instantiated config objects this RootConfig is",
            "        configured to use.",
            "",
            "        Args:",
            "            func_name: Name of function to invoke",
            "            *args",
            "            **kwargs",
            "        Returns:",
            "            ordered dictionary of config section name and the result of the",
            "            function from it.",
            "        \"\"\"",
            "        res = OrderedDict()",
            "",
            "        for name, config in self._configs.items():",
            "            if hasattr(config, func_name):",
            "                res[name] = getattr(config, func_name)(*args, **kwargs)",
            "",
            "        return res",
            "",
            "    @classmethod",
            "    def invoke_all_static(cls, func_name: str, *args, **kwargs):",
            "        \"\"\"",
            "        Invoke a static function on config objects this RootConfig is",
            "        configured to use.",
            "",
            "        Args:",
            "            func_name: Name of function to invoke",
            "            *args",
            "            **kwargs",
            "        Returns:",
            "            ordered dictionary of config section name and the result of the",
            "            function from it.",
            "        \"\"\"",
            "        for config in cls.config_classes:",
            "            if hasattr(config, func_name):",
            "                getattr(config, func_name)(*args, **kwargs)",
            "",
            "    def generate_config(",
            "        self,",
            "        config_dir_path,",
            "        data_dir_path,",
            "        server_name,",
            "        generate_secrets=False,",
            "        report_stats=None,",
            "        open_private_ports=False,",
            "        listeners=None,",
            "        tls_certificate_path=None,",
            "        tls_private_key_path=None,",
            "        acme_domain=None,",
            "    ):",
            "        \"\"\"",
            "        Build a default configuration file",
            "",
            "        This is used when the user explicitly asks us to generate a config file",
            "        (eg with --generate_config).",
            "",
            "        Args:",
            "            config_dir_path (str): The path where the config files are kept. Used to",
            "                create filenames for things like the log config and the signing key.",
            "",
            "            data_dir_path (str): The path where the data files are kept. Used to create",
            "                filenames for things like the database and media store.",
            "",
            "            server_name (str): The server name. Used to initialise the server_name",
            "                config param, but also used in the names of some of the config files.",
            "",
            "            generate_secrets (bool): True if we should generate new secrets for things",
            "                like the macaroon_secret_key. If False, these parameters will be left",
            "                unset.",
            "",
            "            report_stats (bool|None): Initial setting for the report_stats setting.",
            "                If None, report_stats will be left unset.",
            "",
            "            open_private_ports (bool): True to leave private ports (such as the non-TLS",
            "                HTTP listener) open to the internet.",
            "",
            "            listeners (list(dict)|None): A list of descriptions of the listeners",
            "                synapse should start with each of which specifies a port (str), a list of",
            "                resources (list(str)), tls (bool) and type (str). For example:",
            "                [{",
            "                    \"port\": 8448,",
            "                    \"resources\": [{\"names\": [\"federation\"]}],",
            "                    \"tls\": True,",
            "                    \"type\": \"http\",",
            "                },",
            "                {",
            "                    \"port\": 443,",
            "                    \"resources\": [{\"names\": [\"client\"]}],",
            "                    \"tls\": False,",
            "                    \"type\": \"http\",",
            "                }],",
            "",
            "",
            "            database (str|None): The database type to configure, either `psycog2`",
            "                or `sqlite3`.",
            "",
            "            tls_certificate_path (str|None): The path to the tls certificate.",
            "",
            "            tls_private_key_path (str|None): The path to the tls private key.",
            "",
            "            acme_domain (str|None): The domain acme will try to validate. If",
            "                specified acme will be enabled.",
            "",
            "        Returns:",
            "            str: the yaml config file",
            "        \"\"\"",
            "",
            "        return CONFIG_FILE_HEADER + \"\\n\\n\".join(",
            "            dedent(conf)",
            "            for conf in self.invoke_all(",
            "                \"generate_config_section\",",
            "                config_dir_path=config_dir_path,",
            "                data_dir_path=data_dir_path,",
            "                server_name=server_name,",
            "                generate_secrets=generate_secrets,",
            "                report_stats=report_stats,",
            "                open_private_ports=open_private_ports,",
            "                listeners=listeners,",
            "                tls_certificate_path=tls_certificate_path,",
            "                tls_private_key_path=tls_private_key_path,",
            "                acme_domain=acme_domain,",
            "            ).values()",
            "        )",
            "",
            "    @classmethod",
            "    def load_config(cls, description, argv):",
            "        \"\"\"Parse the commandline and config files",
            "",
            "        Doesn't support config-file-generation: used by the worker apps.",
            "",
            "        Returns: Config object.",
            "        \"\"\"",
            "        config_parser = argparse.ArgumentParser(description=description)",
            "        cls.add_arguments_to_parser(config_parser)",
            "        obj, _ = cls.load_config_with_parser(config_parser, argv)",
            "",
            "        return obj",
            "",
            "    @classmethod",
            "    def add_arguments_to_parser(cls, config_parser):",
            "        \"\"\"Adds all the config flags to an ArgumentParser.",
            "",
            "        Doesn't support config-file-generation: used by the worker apps.",
            "",
            "        Used for workers where we want to add extra flags/subcommands.",
            "",
            "        Args:",
            "            config_parser (ArgumentParser): App description",
            "        \"\"\"",
            "",
            "        config_parser.add_argument(",
            "            \"-c\",",
            "            \"--config-path\",",
            "            action=\"append\",",
            "            metavar=\"CONFIG_FILE\",",
            "            help=\"Specify config file. Can be given multiple times and\"",
            "            \" may specify directories containing *.yaml files.\",",
            "        )",
            "",
            "        config_parser.add_argument(",
            "            \"--keys-directory\",",
            "            metavar=\"DIRECTORY\",",
            "            help=\"Where files such as certs and signing keys are stored when\"",
            "            \" their location is not given explicitly in the config.\"",
            "            \" Defaults to the directory containing the last config file\",",
            "        )",
            "",
            "        cls.invoke_all_static(\"add_arguments\", config_parser)",
            "",
            "    @classmethod",
            "    def load_config_with_parser(cls, parser, argv):",
            "        \"\"\"Parse the commandline and config files with the given parser",
            "",
            "        Doesn't support config-file-generation: used by the worker apps.",
            "",
            "        Used for workers where we want to add extra flags/subcommands.",
            "",
            "        Args:",
            "            parser (ArgumentParser)",
            "            argv (list[str])",
            "",
            "        Returns:",
            "            tuple[HomeServerConfig, argparse.Namespace]: Returns the parsed",
            "            config object and the parsed argparse.Namespace object from",
            "            `parser.parse_args(..)`",
            "        \"\"\"",
            "",
            "        obj = cls()",
            "",
            "        config_args = parser.parse_args(argv)",
            "",
            "        config_files = find_config_files(search_paths=config_args.config_path)",
            "",
            "        if not config_files:",
            "            parser.error(\"Must supply a config file.\")",
            "",
            "        if config_args.keys_directory:",
            "            config_dir_path = config_args.keys_directory",
            "        else:",
            "            config_dir_path = os.path.dirname(config_files[-1])",
            "        config_dir_path = os.path.abspath(config_dir_path)",
            "        data_dir_path = os.getcwd()",
            "",
            "        config_dict = read_config_files(config_files)",
            "        obj.parse_config_dict(",
            "            config_dict, config_dir_path=config_dir_path, data_dir_path=data_dir_path",
            "        )",
            "",
            "        obj.invoke_all(\"read_arguments\", config_args)",
            "",
            "        return obj, config_args",
            "",
            "    @classmethod",
            "    def load_or_generate_config(cls, description, argv):",
            "        \"\"\"Parse the commandline and config files",
            "",
            "        Supports generation of config files, so is used for the main homeserver app.",
            "",
            "        Returns: Config object, or None if --generate-config or --generate-keys was set",
            "        \"\"\"",
            "        parser = argparse.ArgumentParser(description=description)",
            "        parser.add_argument(",
            "            \"-c\",",
            "            \"--config-path\",",
            "            action=\"append\",",
            "            metavar=\"CONFIG_FILE\",",
            "            help=\"Specify config file. Can be given multiple times and\"",
            "            \" may specify directories containing *.yaml files.\",",
            "        )",
            "",
            "        generate_group = parser.add_argument_group(\"Config generation\")",
            "        generate_group.add_argument(",
            "            \"--generate-config\",",
            "            action=\"store_true\",",
            "            help=\"Generate a config file, then exit.\",",
            "        )",
            "        generate_group.add_argument(",
            "            \"--generate-missing-configs\",",
            "            \"--generate-keys\",",
            "            action=\"store_true\",",
            "            help=\"Generate any missing additional config files, then exit.\",",
            "        )",
            "        generate_group.add_argument(",
            "            \"-H\", \"--server-name\", help=\"The server name to generate a config file for.\"",
            "        )",
            "        generate_group.add_argument(",
            "            \"--report-stats\",",
            "            action=\"store\",",
            "            help=\"Whether the generated config reports anonymized usage statistics.\",",
            "            choices=[\"yes\", \"no\"],",
            "        )",
            "        generate_group.add_argument(",
            "            \"--config-directory\",",
            "            \"--keys-directory\",",
            "            metavar=\"DIRECTORY\",",
            "            help=(",
            "                \"Specify where additional config files such as signing keys and log\"",
            "                \" config should be stored. Defaults to the same directory as the last\"",
            "                \" config file.\"",
            "            ),",
            "        )",
            "        generate_group.add_argument(",
            "            \"--data-directory\",",
            "            metavar=\"DIRECTORY\",",
            "            help=(",
            "                \"Specify where data such as the media store and database file should be\"",
            "                \" stored. Defaults to the current working directory.\"",
            "            ),",
            "        )",
            "        generate_group.add_argument(",
            "            \"--open-private-ports\",",
            "            action=\"store_true\",",
            "            help=(",
            "                \"Leave private ports (such as the non-TLS HTTP listener) open to the\"",
            "                \" internet. Do not use this unless you know what you are doing.\"",
            "            ),",
            "        )",
            "",
            "        cls.invoke_all_static(\"add_arguments\", parser)",
            "        config_args = parser.parse_args(argv)",
            "",
            "        config_files = find_config_files(search_paths=config_args.config_path)",
            "",
            "        if not config_files:",
            "            parser.error(",
            "                \"Must supply a config file.\\nA config file can be automatically\"",
            "                ' generated using \"--generate-config -H SERVER_NAME'",
            "                ' -c CONFIG-FILE\"'",
            "            )",
            "",
            "        if config_args.config_directory:",
            "            config_dir_path = config_args.config_directory",
            "        else:",
            "            config_dir_path = os.path.dirname(config_files[-1])",
            "        config_dir_path = os.path.abspath(config_dir_path)",
            "        data_dir_path = os.getcwd()",
            "",
            "        generate_missing_configs = config_args.generate_missing_configs",
            "",
            "        obj = cls()",
            "",
            "        if config_args.generate_config:",
            "            if config_args.report_stats is None:",
            "                parser.error(",
            "                    \"Please specify either --report-stats=yes or --report-stats=no\\n\\n\"",
            "                    + MISSING_REPORT_STATS_SPIEL",
            "                )",
            "",
            "            (config_path,) = config_files",
            "            if not path_exists(config_path):",
            "                print(\"Generating config file %s\" % (config_path,))",
            "",
            "                if config_args.data_directory:",
            "                    data_dir_path = config_args.data_directory",
            "                else:",
            "                    data_dir_path = os.getcwd()",
            "                data_dir_path = os.path.abspath(data_dir_path)",
            "",
            "                server_name = config_args.server_name",
            "                if not server_name:",
            "                    raise ConfigError(",
            "                        \"Must specify a server_name to a generate config for.\"",
            "                        \" Pass -H server.name.\"",
            "                    )",
            "",
            "                config_str = obj.generate_config(",
            "                    config_dir_path=config_dir_path,",
            "                    data_dir_path=data_dir_path,",
            "                    server_name=server_name,",
            "                    report_stats=(config_args.report_stats == \"yes\"),",
            "                    generate_secrets=True,",
            "                    open_private_ports=config_args.open_private_ports,",
            "                )",
            "",
            "                if not path_exists(config_dir_path):",
            "                    os.makedirs(config_dir_path)",
            "                with open(config_path, \"w\") as config_file:",
            "                    config_file.write(config_str)",
            "                    config_file.write(\"\\n\\n# vim:ft=yaml\")",
            "",
            "                config_dict = yaml.safe_load(config_str)",
            "                obj.generate_missing_files(config_dict, config_dir_path)",
            "",
            "                print(",
            "                    (",
            "                        \"A config file has been generated in %r for server name\"",
            "                        \" %r. Please review this file and customise it\"",
            "                        \" to your needs.\"",
            "                    )",
            "                    % (config_path, server_name)",
            "                )",
            "                return",
            "            else:",
            "                print(",
            "                    (",
            "                        \"Config file %r already exists. Generating any missing config\"",
            "                        \" files.\"",
            "                    )",
            "                    % (config_path,)",
            "                )",
            "                generate_missing_configs = True",
            "",
            "        config_dict = read_config_files(config_files)",
            "        if generate_missing_configs:",
            "            obj.generate_missing_files(config_dict, config_dir_path)",
            "            return None",
            "",
            "        obj.parse_config_dict(",
            "            config_dict, config_dir_path=config_dir_path, data_dir_path=data_dir_path",
            "        )",
            "        obj.invoke_all(\"read_arguments\", config_args)",
            "",
            "        return obj",
            "",
            "    def parse_config_dict(self, config_dict, config_dir_path=None, data_dir_path=None):",
            "        \"\"\"Read the information from the config dict into this Config object.",
            "",
            "        Args:",
            "            config_dict (dict): Configuration data, as read from the yaml",
            "",
            "            config_dir_path (str): The path where the config files are kept. Used to",
            "                create filenames for things like the log config and the signing key.",
            "",
            "            data_dir_path (str): The path where the data files are kept. Used to create",
            "                filenames for things like the database and media store.",
            "        \"\"\"",
            "        self.invoke_all(",
            "            \"read_config\",",
            "            config_dict,",
            "            config_dir_path=config_dir_path,",
            "            data_dir_path=data_dir_path,",
            "        )",
            "",
            "    def generate_missing_files(self, config_dict, config_dir_path):",
            "        self.invoke_all(\"generate_files\", config_dict, config_dir_path)",
            "",
            "",
            "def read_config_files(config_files):",
            "    \"\"\"Read the config files into a dict",
            "",
            "    Args:",
            "        config_files (iterable[str]): A list of the config files to read",
            "",
            "    Returns: dict",
            "    \"\"\"",
            "    specified_config = {}",
            "    for config_file in config_files:",
            "        with open(config_file) as file_stream:",
            "            yaml_config = yaml.safe_load(file_stream)",
            "",
            "        if not isinstance(yaml_config, dict):",
            "            err = \"File %r is empty or doesn't parse into a key-value map. IGNORING.\"",
            "            print(err % (config_file,))",
            "            continue",
            "",
            "        specified_config.update(yaml_config)",
            "",
            "    if \"server_name\" not in specified_config:",
            "        raise ConfigError(MISSING_SERVER_NAME)",
            "",
            "    if \"report_stats\" not in specified_config:",
            "        raise ConfigError(",
            "            MISSING_REPORT_STATS_CONFIG_INSTRUCTIONS + \"\\n\" + MISSING_REPORT_STATS_SPIEL",
            "        )",
            "    return specified_config",
            "",
            "",
            "def find_config_files(search_paths):",
            "    \"\"\"Finds config files using a list of search paths. If a path is a file",
            "    then that file path is added to the list. If a search path is a directory",
            "    then all the \"*.yaml\" files in that directory are added to the list in",
            "    sorted order.",
            "",
            "    Args:",
            "        search_paths(list(str)): A list of paths to search.",
            "",
            "    Returns:",
            "        list(str): A list of file paths.",
            "    \"\"\"",
            "",
            "    config_files = []",
            "    if search_paths:",
            "        for config_path in search_paths:",
            "            if os.path.isdir(config_path):",
            "                # We accept specifying directories as config paths, we search",
            "                # inside that directory for all files matching *.yaml, and then",
            "                # we apply them in *sorted* order.",
            "                files = []",
            "                for entry in os.listdir(config_path):",
            "                    entry_path = os.path.join(config_path, entry)",
            "                    if not os.path.isfile(entry_path):",
            "                        err = \"Found subdirectory in config directory: %r. IGNORING.\"",
            "                        print(err % (entry_path,))",
            "                        continue",
            "",
            "                    if not entry.endswith(\".yaml\"):",
            "                        err = (",
            "                            \"Found file in config directory that does not end in \"",
            "                            \"'.yaml': %r. IGNORING.\"",
            "                        )",
            "                        print(err % (entry_path,))",
            "                        continue",
            "",
            "                    files.append(entry_path)",
            "",
            "                config_files.extend(sorted(files))",
            "            else:",
            "                config_files.append(config_path)",
            "    return config_files",
            "",
            "",
            "@attr.s",
            "class ShardedWorkerHandlingConfig:",
            "    \"\"\"Algorithm for choosing which instance is responsible for handling some",
            "    sharded work.",
            "",
            "    For example, the federation senders use this to determine which instances",
            "    handles sending stuff to a given destination (which is used as the `key`",
            "    below).",
            "    \"\"\"",
            "",
            "    instances = attr.ib(type=List[str])",
            "",
            "    def should_handle(self, instance_name: str, key: str) -> bool:",
            "        \"\"\"Whether this instance is responsible for handling the given key.",
            "        \"\"\"",
            "        # If multiple instances are not defined we always return true",
            "        if not self.instances or len(self.instances) == 1:",
            "            return True",
            "",
            "        return self.get_instance(key) == instance_name",
            "",
            "    def get_instance(self, key: str) -> str:",
            "        \"\"\"Get the instance responsible for handling the given key.",
            "",
            "        Note: For things like federation sending the config for which instance",
            "        is sending is known only to the sender instance if there is only one.",
            "        Therefore `should_handle` should be used where possible.",
            "        \"\"\"",
            "",
            "        if not self.instances:",
            "            return \"master\"",
            "",
            "        if len(self.instances) == 1:",
            "            return self.instances[0]",
            "",
            "        # We shard by taking the hash, modulo it by the number of instances and",
            "        # then checking whether this instance matches the instance at that",
            "        # index.",
            "        #",
            "        # (Technically this introduces some bias and is not entirely uniform,",
            "        # but since the hash is so large the bias is ridiculously small).",
            "        dest_hash = sha256(key.encode(\"utf8\")).digest()",
            "        dest_int = int.from_bytes(dest_hash, byteorder=\"little\")",
            "        remainder = dest_int % (len(self.instances))",
            "        return self.instances[remainder]",
            "",
            "",
            "__all__ = [\"Config\", \"RootConfig\", \"ShardedWorkerHandlingConfig\"]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "207": [
                "Config",
                "read_templates"
            ],
            "208": [
                "Config",
                "read_templates"
            ],
            "209": [
                "Config",
                "read_templates"
            ],
            "210": [
                "Config",
                "read_templates"
            ],
            "218": [
                "Config",
                "read_templates"
            ],
            "226": [
                "Config",
                "read_templates"
            ],
            "227": [
                "Config",
                "read_templates"
            ],
            "228": [
                "Config",
                "read_templates"
            ],
            "235": [
                "Config",
                "read_templates"
            ],
            "252": [
                "Config",
                "read_templates"
            ],
            "262": [
                "Config",
                "read_templates"
            ],
            "263": [
                "Config",
                "read_templates"
            ],
            "264": [
                "Config",
                "read_templates"
            ],
            "265": [
                "Config",
                "read_templates"
            ],
            "266": [
                "Config",
                "read_templates"
            ],
            "267": [
                "Config",
                "read_templates"
            ]
        },
        "addLocation": [
            "rdiffweb.controller.page_pref_sshkeys.ApiSshKeys.post",
            "synapse.config._base.Config.read_templates.filenames",
            "synapse.config._base.Config.self"
        ]
    },
    "synapse/config/captcha.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "             \"recaptcha_siteverify_api\","
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             \"https://www.recaptcha.net/recaptcha/api/siteverify\","
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         )"
            },
            "3": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.recaptcha_template = self.read_templates("
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            [\"recaptcha.html\"], autoescape=True"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )[0]"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        self.recaptcha_template = self.read_template(\"recaptcha.html\")"
            },
            "7": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     def generate_config_section(self, **kwargs):"
            },
            "9": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         return \"\"\"\\"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014-2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from ._base import Config",
            "",
            "",
            "class CaptchaConfig(Config):",
            "    section = \"captcha\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        self.recaptcha_private_key = config.get(\"recaptcha_private_key\")",
            "        self.recaptcha_public_key = config.get(\"recaptcha_public_key\")",
            "        self.enable_registration_captcha = config.get(",
            "            \"enable_registration_captcha\", False",
            "        )",
            "        self.recaptcha_siteverify_api = config.get(",
            "            \"recaptcha_siteverify_api\",",
            "            \"https://www.recaptcha.net/recaptcha/api/siteverify\",",
            "        )",
            "        self.recaptcha_template = self.read_templates(",
            "            [\"recaptcha.html\"], autoescape=True",
            "        )[0]",
            "",
            "    def generate_config_section(self, **kwargs):",
            "        return \"\"\"\\",
            "        ## Captcha ##",
            "        # See docs/CAPTCHA_SETUP.md for full details of configuring this.",
            "",
            "        # This homeserver's ReCAPTCHA public key. Must be specified if",
            "        # enable_registration_captcha is enabled.",
            "        #",
            "        #recaptcha_public_key: \"YOUR_PUBLIC_KEY\"",
            "",
            "        # This homeserver's ReCAPTCHA private key. Must be specified if",
            "        # enable_registration_captcha is enabled.",
            "        #",
            "        #recaptcha_private_key: \"YOUR_PRIVATE_KEY\"",
            "",
            "        # Uncomment to enable ReCaptcha checks when registering, preventing signup",
            "        # unless a captcha is answered. Requires a valid ReCaptcha",
            "        # public/private key. Defaults to 'false'.",
            "        #",
            "        #enable_registration_captcha: true",
            "",
            "        # The API endpoint to use for verifying m.login.recaptcha responses.",
            "        # Defaults to \"https://www.recaptcha.net/recaptcha/api/siteverify\".",
            "        #",
            "        #recaptcha_siteverify_api: \"https://my.recaptcha.site\"",
            "        \"\"\""
        ],
        "afterPatchFile": [
            "# Copyright 2014-2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from ._base import Config",
            "",
            "",
            "class CaptchaConfig(Config):",
            "    section = \"captcha\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        self.recaptcha_private_key = config.get(\"recaptcha_private_key\")",
            "        self.recaptcha_public_key = config.get(\"recaptcha_public_key\")",
            "        self.enable_registration_captcha = config.get(",
            "            \"enable_registration_captcha\", False",
            "        )",
            "        self.recaptcha_siteverify_api = config.get(",
            "            \"recaptcha_siteverify_api\",",
            "            \"https://www.recaptcha.net/recaptcha/api/siteverify\",",
            "        )",
            "        self.recaptcha_template = self.read_template(\"recaptcha.html\")",
            "",
            "    def generate_config_section(self, **kwargs):",
            "        return \"\"\"\\",
            "        ## Captcha ##",
            "        # See docs/CAPTCHA_SETUP.md for full details of configuring this.",
            "",
            "        # This homeserver's ReCAPTCHA public key. Must be specified if",
            "        # enable_registration_captcha is enabled.",
            "        #",
            "        #recaptcha_public_key: \"YOUR_PUBLIC_KEY\"",
            "",
            "        # This homeserver's ReCAPTCHA private key. Must be specified if",
            "        # enable_registration_captcha is enabled.",
            "        #",
            "        #recaptcha_private_key: \"YOUR_PRIVATE_KEY\"",
            "",
            "        # Uncomment to enable ReCaptcha checks when registering, preventing signup",
            "        # unless a captcha is answered. Requires a valid ReCaptcha",
            "        # public/private key. Defaults to 'false'.",
            "        #",
            "        #enable_registration_captcha: true",
            "",
            "        # The API endpoint to use for verifying m.login.recaptcha responses.",
            "        # Defaults to \"https://www.recaptcha.net/recaptcha/api/siteverify\".",
            "        #",
            "        #recaptcha_siteverify_api: \"https://my.recaptcha.site\"",
            "        \"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [
                "CaptchaConfig",
                "read_config"
            ],
            "32": [
                "CaptchaConfig",
                "read_config"
            ],
            "33": [
                "CaptchaConfig",
                "read_config"
            ]
        },
        "addLocation": []
    },
    "synapse/config/consent_config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     def read_config(self, config, **kwargs):"
            },
            "2": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         consent_config = config.get(\"user_consent\")"
            },
            "3": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.terms_template = self.read_templates([\"terms.html\"], autoescape=True)[0]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        self.terms_template = self.read_template(\"terms.html\")"
            },
            "5": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         if consent_config is None:"
            },
            "7": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "             return"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from os import path",
            "",
            "from synapse.config import ConfigError",
            "",
            "from ._base import Config",
            "",
            "DEFAULT_CONFIG = \"\"\"\\",
            "# User Consent configuration",
            "#",
            "# for detailed instructions, see",
            "# https://github.com/matrix-org/synapse/blob/master/docs/consent_tracking.md",
            "#",
            "# Parts of this section are required if enabling the 'consent' resource under",
            "# 'listeners', in particular 'template_dir' and 'version'.",
            "#",
            "# 'template_dir' gives the location of the templates for the HTML forms.",
            "# This directory should contain one subdirectory per language (eg, 'en', 'fr'),",
            "# and each language directory should contain the policy document (named as",
            "# '<version>.html') and a success page (success.html).",
            "#",
            "# 'version' specifies the 'current' version of the policy document. It defines",
            "# the version to be served by the consent resource if there is no 'v'",
            "# parameter.",
            "#",
            "# 'server_notice_content', if enabled, will send a user a \"Server Notice\"",
            "# asking them to consent to the privacy policy. The 'server_notices' section",
            "# must also be configured for this to work. Notices will *not* be sent to",
            "# guest users unless 'send_server_notice_to_guests' is set to true.",
            "#",
            "# 'block_events_error', if set, will block any attempts to send events",
            "# until the user consents to the privacy policy. The value of the setting is",
            "# used as the text of the error.",
            "#",
            "# 'require_at_registration', if enabled, will add a step to the registration",
            "# process, similar to how captcha works. Users will be required to accept the",
            "# policy before their account is created.",
            "#",
            "# 'policy_name' is the display name of the policy users will see when registering",
            "# for an account. Has no effect unless `require_at_registration` is enabled.",
            "# Defaults to \"Privacy Policy\".",
            "#",
            "#user_consent:",
            "#  template_dir: res/templates/privacy",
            "#  version: 1.0",
            "#  server_notice_content:",
            "#    msgtype: m.text",
            "#    body: >-",
            "#      To continue using this homeserver you must review and agree to the",
            "#      terms and conditions at %(consent_uri)s",
            "#  send_server_notice_to_guests: true",
            "#  block_events_error: >-",
            "#    To continue using this homeserver you must review and agree to the",
            "#    terms and conditions at %(consent_uri)s",
            "#  require_at_registration: false",
            "#  policy_name: Privacy Policy",
            "#",
            "\"\"\"",
            "",
            "",
            "class ConsentConfig(Config):",
            "",
            "    section = \"consent\"",
            "",
            "    def __init__(self, *args):",
            "        super().__init__(*args)",
            "",
            "        self.user_consent_version = None",
            "        self.user_consent_template_dir = None",
            "        self.user_consent_server_notice_content = None",
            "        self.user_consent_server_notice_to_guests = False",
            "        self.block_events_without_consent_error = None",
            "        self.user_consent_at_registration = False",
            "        self.user_consent_policy_name = \"Privacy Policy\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        consent_config = config.get(\"user_consent\")",
            "        self.terms_template = self.read_templates([\"terms.html\"], autoescape=True)[0]",
            "",
            "        if consent_config is None:",
            "            return",
            "        self.user_consent_version = str(consent_config[\"version\"])",
            "        self.user_consent_template_dir = self.abspath(consent_config[\"template_dir\"])",
            "        if not path.isdir(self.user_consent_template_dir):",
            "            raise ConfigError(",
            "                \"Could not find template directory '%s'\"",
            "                % (self.user_consent_template_dir,)",
            "            )",
            "        self.user_consent_server_notice_content = consent_config.get(",
            "            \"server_notice_content\"",
            "        )",
            "        self.block_events_without_consent_error = consent_config.get(",
            "            \"block_events_error\"",
            "        )",
            "        self.user_consent_server_notice_to_guests = bool(",
            "            consent_config.get(\"send_server_notice_to_guests\", False)",
            "        )",
            "        self.user_consent_at_registration = bool(",
            "            consent_config.get(\"require_at_registration\", False)",
            "        )",
            "        self.user_consent_policy_name = consent_config.get(",
            "            \"policy_name\", \"Privacy Policy\"",
            "        )",
            "",
            "    def generate_config_section(self, **kwargs):",
            "        return DEFAULT_CONFIG"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2018 New Vector Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "from os import path",
            "",
            "from synapse.config import ConfigError",
            "",
            "from ._base import Config",
            "",
            "DEFAULT_CONFIG = \"\"\"\\",
            "# User Consent configuration",
            "#",
            "# for detailed instructions, see",
            "# https://github.com/matrix-org/synapse/blob/master/docs/consent_tracking.md",
            "#",
            "# Parts of this section are required if enabling the 'consent' resource under",
            "# 'listeners', in particular 'template_dir' and 'version'.",
            "#",
            "# 'template_dir' gives the location of the templates for the HTML forms.",
            "# This directory should contain one subdirectory per language (eg, 'en', 'fr'),",
            "# and each language directory should contain the policy document (named as",
            "# '<version>.html') and a success page (success.html).",
            "#",
            "# 'version' specifies the 'current' version of the policy document. It defines",
            "# the version to be served by the consent resource if there is no 'v'",
            "# parameter.",
            "#",
            "# 'server_notice_content', if enabled, will send a user a \"Server Notice\"",
            "# asking them to consent to the privacy policy. The 'server_notices' section",
            "# must also be configured for this to work. Notices will *not* be sent to",
            "# guest users unless 'send_server_notice_to_guests' is set to true.",
            "#",
            "# 'block_events_error', if set, will block any attempts to send events",
            "# until the user consents to the privacy policy. The value of the setting is",
            "# used as the text of the error.",
            "#",
            "# 'require_at_registration', if enabled, will add a step to the registration",
            "# process, similar to how captcha works. Users will be required to accept the",
            "# policy before their account is created.",
            "#",
            "# 'policy_name' is the display name of the policy users will see when registering",
            "# for an account. Has no effect unless `require_at_registration` is enabled.",
            "# Defaults to \"Privacy Policy\".",
            "#",
            "#user_consent:",
            "#  template_dir: res/templates/privacy",
            "#  version: 1.0",
            "#  server_notice_content:",
            "#    msgtype: m.text",
            "#    body: >-",
            "#      To continue using this homeserver you must review and agree to the",
            "#      terms and conditions at %(consent_uri)s",
            "#  send_server_notice_to_guests: true",
            "#  block_events_error: >-",
            "#    To continue using this homeserver you must review and agree to the",
            "#    terms and conditions at %(consent_uri)s",
            "#  require_at_registration: false",
            "#  policy_name: Privacy Policy",
            "#",
            "\"\"\"",
            "",
            "",
            "class ConsentConfig(Config):",
            "",
            "    section = \"consent\"",
            "",
            "    def __init__(self, *args):",
            "        super().__init__(*args)",
            "",
            "        self.user_consent_version = None",
            "        self.user_consent_template_dir = None",
            "        self.user_consent_server_notice_content = None",
            "        self.user_consent_server_notice_to_guests = False",
            "        self.block_events_without_consent_error = None",
            "        self.user_consent_at_registration = False",
            "        self.user_consent_policy_name = \"Privacy Policy\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        consent_config = config.get(\"user_consent\")",
            "        self.terms_template = self.read_template(\"terms.html\")",
            "",
            "        if consent_config is None:",
            "            return",
            "        self.user_consent_version = str(consent_config[\"version\"])",
            "        self.user_consent_template_dir = self.abspath(consent_config[\"template_dir\"])",
            "        if not path.isdir(self.user_consent_template_dir):",
            "            raise ConfigError(",
            "                \"Could not find template directory '%s'\"",
            "                % (self.user_consent_template_dir,)",
            "            )",
            "        self.user_consent_server_notice_content = consent_config.get(",
            "            \"server_notice_content\"",
            "        )",
            "        self.block_events_without_consent_error = consent_config.get(",
            "            \"block_events_error\"",
            "        )",
            "        self.user_consent_server_notice_to_guests = bool(",
            "            consent_config.get(\"send_server_notice_to_guests\", False)",
            "        )",
            "        self.user_consent_at_registration = bool(",
            "            consent_config.get(\"require_at_registration\", False)",
            "        )",
            "        self.user_consent_policy_name = consent_config.get(",
            "            \"policy_name\", \"Privacy Policy\"",
            "        )",
            "",
            "    def generate_config_section(self, **kwargs):",
            "        return DEFAULT_CONFIG"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "92": [
                "ConsentConfig",
                "read_config"
            ]
        },
        "addLocation": []
    },
    "synapse/config/registration.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         self.session_lifetime = session_lifetime"
            },
            "1": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         # The success template used during fallback auth."
            },
            "3": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.fallback_success_template = self.read_templates("
            },
            "4": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            [\"auth_success.html\"], autoescape=True"
            },
            "5": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )[0]"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        self.fallback_success_template = self.read_template(\"auth_success.html\")"
            },
            "7": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "     def generate_config_section(self, generate_secrets=False, **kwargs):"
            },
            "9": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         if generate_secrets:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import os",
            "",
            "import pkg_resources",
            "",
            "from synapse.api.constants import RoomCreationPreset",
            "from synapse.config._base import Config, ConfigError",
            "from synapse.types import RoomAlias, UserID",
            "from synapse.util.stringutils import random_string_with_symbols, strtobool",
            "",
            "",
            "class AccountValidityConfig(Config):",
            "    section = \"accountvalidity\"",
            "",
            "    def __init__(self, config, synapse_config):",
            "        if config is None:",
            "            return",
            "        super().__init__()",
            "        self.enabled = config.get(\"enabled\", False)",
            "        self.renew_by_email_enabled = \"renew_at\" in config",
            "",
            "        if self.enabled:",
            "            if \"period\" in config:",
            "                self.period = self.parse_duration(config[\"period\"])",
            "            else:",
            "                raise ConfigError(\"'period' is required when using account validity\")",
            "",
            "            if \"renew_at\" in config:",
            "                self.renew_at = self.parse_duration(config[\"renew_at\"])",
            "",
            "            if \"renew_email_subject\" in config:",
            "                self.renew_email_subject = config[\"renew_email_subject\"]",
            "            else:",
            "                self.renew_email_subject = \"Renew your %(app)s account\"",
            "",
            "            self.startup_job_max_delta = self.period * 10.0 / 100.0",
            "",
            "        template_dir = config.get(\"template_dir\")",
            "",
            "        if not template_dir:",
            "            template_dir = pkg_resources.resource_filename(\"synapse\", \"res/templates\")",
            "",
            "        if \"account_renewed_html_path\" in config:",
            "            file_path = os.path.join(template_dir, config[\"account_renewed_html_path\"])",
            "",
            "            self.account_renewed_html_content = self.read_file(",
            "                file_path, \"account_validity.account_renewed_html_path\"",
            "            )",
            "        else:",
            "            self.account_renewed_html_content = (",
            "                \"<html><body>Your account has been successfully renewed.</body><html>\"",
            "            )",
            "",
            "        if \"invalid_token_html_path\" in config:",
            "            file_path = os.path.join(template_dir, config[\"invalid_token_html_path\"])",
            "",
            "            self.invalid_token_html_content = self.read_file(",
            "                file_path, \"account_validity.invalid_token_html_path\"",
            "            )",
            "        else:",
            "            self.invalid_token_html_content = (",
            "                \"<html><body>Invalid renewal token.</body><html>\"",
            "            )",
            "",
            "",
            "class RegistrationConfig(Config):",
            "    section = \"registration\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        self.enable_registration = strtobool(",
            "            str(config.get(\"enable_registration\", False))",
            "        )",
            "        if \"disable_registration\" in config:",
            "            self.enable_registration = not strtobool(",
            "                str(config[\"disable_registration\"])",
            "            )",
            "",
            "        self.account_validity = AccountValidityConfig(",
            "            config.get(\"account_validity\") or {}, config",
            "        )",
            "",
            "        self.registrations_require_3pid = config.get(\"registrations_require_3pid\", [])",
            "        self.allowed_local_3pids = config.get(\"allowed_local_3pids\", [])",
            "        self.enable_3pid_lookup = config.get(\"enable_3pid_lookup\", True)",
            "        self.registration_shared_secret = config.get(\"registration_shared_secret\")",
            "",
            "        self.bcrypt_rounds = config.get(\"bcrypt_rounds\", 12)",
            "        self.trusted_third_party_id_servers = config.get(",
            "            \"trusted_third_party_id_servers\", [\"matrix.org\", \"vector.im\"]",
            "        )",
            "        account_threepid_delegates = config.get(\"account_threepid_delegates\") or {}",
            "        self.account_threepid_delegate_email = account_threepid_delegates.get(\"email\")",
            "        self.account_threepid_delegate_msisdn = account_threepid_delegates.get(\"msisdn\")",
            "",
            "        self.default_identity_server = config.get(\"default_identity_server\")",
            "        self.allow_guest_access = config.get(\"allow_guest_access\", False)",
            "",
            "        if config.get(\"invite_3pid_guest\", False):",
            "            raise ConfigError(\"invite_3pid_guest is no longer supported\")",
            "",
            "        self.auto_join_rooms = config.get(\"auto_join_rooms\", [])",
            "        for room_alias in self.auto_join_rooms:",
            "            if not RoomAlias.is_valid(room_alias):",
            "                raise ConfigError(\"Invalid auto_join_rooms entry %s\" % (room_alias,))",
            "",
            "        # Options for creating auto-join rooms if they do not exist yet.",
            "        self.autocreate_auto_join_rooms = config.get(\"autocreate_auto_join_rooms\", True)",
            "        self.autocreate_auto_join_rooms_federated = config.get(",
            "            \"autocreate_auto_join_rooms_federated\", True",
            "        )",
            "        self.autocreate_auto_join_room_preset = (",
            "            config.get(\"autocreate_auto_join_room_preset\")",
            "            or RoomCreationPreset.PUBLIC_CHAT",
            "        )",
            "        self.auto_join_room_requires_invite = self.autocreate_auto_join_room_preset in {",
            "            RoomCreationPreset.PRIVATE_CHAT,",
            "            RoomCreationPreset.TRUSTED_PRIVATE_CHAT,",
            "        }",
            "",
            "        # Pull the creator/inviter from the configuration, this gets used to",
            "        # send invites for invite-only rooms.",
            "        mxid_localpart = config.get(\"auto_join_mxid_localpart\")",
            "        self.auto_join_user_id = None",
            "        if mxid_localpart:",
            "            # Convert the localpart to a full mxid.",
            "            self.auto_join_user_id = UserID(",
            "                mxid_localpart, self.server_name",
            "            ).to_string()",
            "",
            "        if self.autocreate_auto_join_rooms:",
            "            # Ensure the preset is a known value.",
            "            if self.autocreate_auto_join_room_preset not in {",
            "                RoomCreationPreset.PUBLIC_CHAT,",
            "                RoomCreationPreset.PRIVATE_CHAT,",
            "                RoomCreationPreset.TRUSTED_PRIVATE_CHAT,",
            "            }:",
            "                raise ConfigError(\"Invalid value for autocreate_auto_join_room_preset\")",
            "            # If the preset requires invitations to be sent, ensure there's a",
            "            # configured user to send them from.",
            "            if self.auto_join_room_requires_invite:",
            "                if not mxid_localpart:",
            "                    raise ConfigError(",
            "                        \"The configuration option `auto_join_mxid_localpart` is required if \"",
            "                        \"`autocreate_auto_join_room_preset` is set to private_chat or trusted_private_chat, such that \"",
            "                        \"Synapse knows who to send invitations from. Please \"",
            "                        \"configure `auto_join_mxid_localpart`.\"",
            "                    )",
            "",
            "        self.auto_join_rooms_for_guests = config.get(\"auto_join_rooms_for_guests\", True)",
            "",
            "        self.enable_set_displayname = config.get(\"enable_set_displayname\", True)",
            "        self.enable_set_avatar_url = config.get(\"enable_set_avatar_url\", True)",
            "        self.enable_3pid_changes = config.get(\"enable_3pid_changes\", True)",
            "",
            "        self.disable_msisdn_registration = config.get(",
            "            \"disable_msisdn_registration\", False",
            "        )",
            "",
            "        session_lifetime = config.get(\"session_lifetime\")",
            "        if session_lifetime is not None:",
            "            session_lifetime = self.parse_duration(session_lifetime)",
            "        self.session_lifetime = session_lifetime",
            "",
            "        # The success template used during fallback auth.",
            "        self.fallback_success_template = self.read_templates(",
            "            [\"auth_success.html\"], autoescape=True",
            "        )[0]",
            "",
            "    def generate_config_section(self, generate_secrets=False, **kwargs):",
            "        if generate_secrets:",
            "            registration_shared_secret = 'registration_shared_secret: \"%s\"' % (",
            "                random_string_with_symbols(50),",
            "            )",
            "        else:",
            "            registration_shared_secret = \"#registration_shared_secret: <PRIVATE STRING>\"",
            "",
            "        return (",
            "            \"\"\"\\",
            "        ## Registration ##",
            "        #",
            "        # Registration can be rate-limited using the parameters in the \"Ratelimiting\"",
            "        # section of this file.",
            "",
            "        # Enable registration for new users.",
            "        #",
            "        #enable_registration: false",
            "",
            "        # Optional account validity configuration. This allows for accounts to be denied",
            "        # any request after a given period.",
            "        #",
            "        # Once this feature is enabled, Synapse will look for registered users without an",
            "        # expiration date at startup and will add one to every account it found using the",
            "        # current settings at that time.",
            "        # This means that, if a validity period is set, and Synapse is restarted (it will",
            "        # then derive an expiration date from the current validity period), and some time",
            "        # after that the validity period changes and Synapse is restarted, the users'",
            "        # expiration dates won't be updated unless their account is manually renewed. This",
            "        # date will be randomly selected within a range [now + period - d ; now + period],",
            "        # where d is equal to 10%% of the validity period.",
            "        #",
            "        account_validity:",
            "          # The account validity feature is disabled by default. Uncomment the",
            "          # following line to enable it.",
            "          #",
            "          #enabled: true",
            "",
            "          # The period after which an account is valid after its registration. When",
            "          # renewing the account, its validity period will be extended by this amount",
            "          # of time. This parameter is required when using the account validity",
            "          # feature.",
            "          #",
            "          #period: 6w",
            "",
            "          # The amount of time before an account's expiry date at which Synapse will",
            "          # send an email to the account's email address with a renewal link. By",
            "          # default, no such emails are sent.",
            "          #",
            "          # If you enable this setting, you will also need to fill out the 'email'",
            "          # configuration section. You should also check that 'public_baseurl' is set",
            "          # correctly.",
            "          #",
            "          #renew_at: 1w",
            "",
            "          # The subject of the email sent out with the renewal link. '%%(app)s' can be",
            "          # used as a placeholder for the 'app_name' parameter from the 'email'",
            "          # section.",
            "          #",
            "          # Note that the placeholder must be written '%%(app)s', including the",
            "          # trailing 's'.",
            "          #",
            "          # If this is not set, a default value is used.",
            "          #",
            "          #renew_email_subject: \"Renew your %%(app)s account\"",
            "",
            "          # Directory in which Synapse will try to find templates for the HTML files to",
            "          # serve to the user when trying to renew an account. If not set, default",
            "          # templates from within the Synapse package will be used.",
            "          #",
            "          #template_dir: \"res/templates\"",
            "",
            "          # File within 'template_dir' giving the HTML to be displayed to the user after",
            "          # they successfully renewed their account. If not set, default text is used.",
            "          #",
            "          #account_renewed_html_path: \"account_renewed.html\"",
            "",
            "          # File within 'template_dir' giving the HTML to be displayed when the user",
            "          # tries to renew an account with an invalid renewal token. If not set,",
            "          # default text is used.",
            "          #",
            "          #invalid_token_html_path: \"invalid_token.html\"",
            "",
            "        # Time that a user's session remains valid for, after they log in.",
            "        #",
            "        # Note that this is not currently compatible with guest logins.",
            "        #",
            "        # Note also that this is calculated at login time: changes are not applied",
            "        # retrospectively to users who have already logged in.",
            "        #",
            "        # By default, this is infinite.",
            "        #",
            "        #session_lifetime: 24h",
            "",
            "        # The user must provide all of the below types of 3PID when registering.",
            "        #",
            "        #registrations_require_3pid:",
            "        #  - email",
            "        #  - msisdn",
            "",
            "        # Explicitly disable asking for MSISDNs from the registration",
            "        # flow (overrides registrations_require_3pid if MSISDNs are set as required)",
            "        #",
            "        #disable_msisdn_registration: true",
            "",
            "        # Mandate that users are only allowed to associate certain formats of",
            "        # 3PIDs with accounts on this server.",
            "        #",
            "        #allowed_local_3pids:",
            "        #  - medium: email",
            "        #    pattern: '.*@matrix\\\\.org'",
            "        #  - medium: email",
            "        #    pattern: '.*@vector\\\\.im'",
            "        #  - medium: msisdn",
            "        #    pattern: '\\\\+44'",
            "",
            "        # Enable 3PIDs lookup requests to identity servers from this server.",
            "        #",
            "        #enable_3pid_lookup: true",
            "",
            "        # If set, allows registration of standard or admin accounts by anyone who",
            "        # has the shared secret, even if registration is otherwise disabled.",
            "        #",
            "        %(registration_shared_secret)s",
            "",
            "        # Set the number of bcrypt rounds used to generate password hash.",
            "        # Larger numbers increase the work factor needed to generate the hash.",
            "        # The default number is 12 (which equates to 2^12 rounds).",
            "        # N.B. that increasing this will exponentially increase the time required",
            "        # to register or login - e.g. 24 => 2^24 rounds which will take >20 mins.",
            "        #",
            "        #bcrypt_rounds: 12",
            "",
            "        # Allows users to register as guests without a password/email/etc, and",
            "        # participate in rooms hosted on this server which have been made",
            "        # accessible to anonymous users.",
            "        #",
            "        #allow_guest_access: false",
            "",
            "        # The identity server which we suggest that clients should use when users log",
            "        # in on this server.",
            "        #",
            "        # (By default, no suggestion is made, so it is left up to the client.)",
            "        #",
            "        #default_identity_server: https://matrix.org",
            "",
            "        # Handle threepid (email/phone etc) registration and password resets through a set of",
            "        # *trusted* identity servers. Note that this allows the configured identity server to",
            "        # reset passwords for accounts!",
            "        #",
            "        # Be aware that if `email` is not set, and SMTP options have not been",
            "        # configured in the email config block, registration and user password resets via",
            "        # email will be globally disabled.",
            "        #",
            "        # Additionally, if `msisdn` is not set, registration and password resets via msisdn",
            "        # will be disabled regardless, and users will not be able to associate an msisdn",
            "        # identifier to their account. This is due to Synapse currently not supporting",
            "        # any method of sending SMS messages on its own.",
            "        #",
            "        # To enable using an identity server for operations regarding a particular third-party",
            "        # identifier type, set the value to the URL of that identity server as shown in the",
            "        # examples below.",
            "        #",
            "        # Servers handling the these requests must answer the `/requestToken` endpoints defined",
            "        # by the Matrix Identity Service API specification:",
            "        # https://matrix.org/docs/spec/identity_service/latest",
            "        #",
            "        account_threepid_delegates:",
            "            #email: https://example.com     # Delegate email sending to example.com",
            "            #msisdn: http://localhost:8090  # Delegate SMS sending to this local process",
            "",
            "        # Whether users are allowed to change their displayname after it has",
            "        # been initially set. Useful when provisioning users based on the",
            "        # contents of a third-party directory.",
            "        #",
            "        # Does not apply to server administrators. Defaults to 'true'",
            "        #",
            "        #enable_set_displayname: false",
            "",
            "        # Whether users are allowed to change their avatar after it has been",
            "        # initially set. Useful when provisioning users based on the contents",
            "        # of a third-party directory.",
            "        #",
            "        # Does not apply to server administrators. Defaults to 'true'",
            "        #",
            "        #enable_set_avatar_url: false",
            "",
            "        # Whether users can change the 3PIDs associated with their accounts",
            "        # (email address and msisdn).",
            "        #",
            "        # Defaults to 'true'",
            "        #",
            "        #enable_3pid_changes: false",
            "",
            "        # Users who register on this homeserver will automatically be joined",
            "        # to these rooms.",
            "        #",
            "        # By default, any room aliases included in this list will be created",
            "        # as a publicly joinable room when the first user registers for the",
            "        # homeserver. This behaviour can be customised with the settings below.",
            "        #",
            "        #auto_join_rooms:",
            "        #  - \"#example:example.com\"",
            "",
            "        # Where auto_join_rooms are specified, setting this flag ensures that the",
            "        # the rooms exist by creating them when the first user on the",
            "        # homeserver registers.",
            "        #",
            "        # By default the auto-created rooms are publicly joinable from any federated",
            "        # server. Use the autocreate_auto_join_rooms_federated and",
            "        # autocreate_auto_join_room_preset settings below to customise this behaviour.",
            "        #",
            "        # Setting to false means that if the rooms are not manually created,",
            "        # users cannot be auto-joined since they do not exist.",
            "        #",
            "        # Defaults to true. Uncomment the following line to disable automatically",
            "        # creating auto-join rooms.",
            "        #",
            "        #autocreate_auto_join_rooms: false",
            "",
            "        # Whether the auto_join_rooms that are auto-created are available via",
            "        # federation. Only has an effect if autocreate_auto_join_rooms is true.",
            "        #",
            "        # Note that whether a room is federated cannot be modified after",
            "        # creation.",
            "        #",
            "        # Defaults to true: the room will be joinable from other servers.",
            "        # Uncomment the following to prevent users from other homeservers from",
            "        # joining these rooms.",
            "        #",
            "        #autocreate_auto_join_rooms_federated: false",
            "",
            "        # The room preset to use when auto-creating one of auto_join_rooms. Only has an",
            "        # effect if autocreate_auto_join_rooms is true.",
            "        #",
            "        # This can be one of \"public_chat\", \"private_chat\", or \"trusted_private_chat\".",
            "        # If a value of \"private_chat\" or \"trusted_private_chat\" is used then",
            "        # auto_join_mxid_localpart must also be configured.",
            "        #",
            "        # Defaults to \"public_chat\", meaning that the room is joinable by anyone, including",
            "        # federated servers if autocreate_auto_join_rooms_federated is true (the default).",
            "        # Uncomment the following to require an invitation to join these rooms.",
            "        #",
            "        #autocreate_auto_join_room_preset: private_chat",
            "",
            "        # The local part of the user id which is used to create auto_join_rooms if",
            "        # autocreate_auto_join_rooms is true. If this is not provided then the",
            "        # initial user account that registers will be used to create the rooms.",
            "        #",
            "        # The user id is also used to invite new users to any auto-join rooms which",
            "        # are set to invite-only.",
            "        #",
            "        # It *must* be configured if autocreate_auto_join_room_preset is set to",
            "        # \"private_chat\" or \"trusted_private_chat\".",
            "        #",
            "        # Note that this must be specified in order for new users to be correctly",
            "        # invited to any auto-join rooms which have been set to invite-only (either",
            "        # at the time of creation or subsequently).",
            "        #",
            "        # Note that, if the room already exists, this user must be joined and",
            "        # have the appropriate permissions to invite new members.",
            "        #",
            "        #auto_join_mxid_localpart: system",
            "",
            "        # When auto_join_rooms is specified, setting this flag to false prevents",
            "        # guest accounts from being automatically joined to the rooms.",
            "        #",
            "        # Defaults to true.",
            "        #",
            "        #auto_join_rooms_for_guests: false",
            "        \"\"\"",
            "            % locals()",
            "        )",
            "",
            "    @staticmethod",
            "    def add_arguments(parser):",
            "        reg_group = parser.add_argument_group(\"registration\")",
            "        reg_group.add_argument(",
            "            \"--enable-registration\",",
            "            action=\"store_true\",",
            "            default=None,",
            "            help=\"Enable registration for new users.\",",
            "        )",
            "",
            "    def read_arguments(self, args):",
            "        if args.enable_registration is not None:",
            "            self.enable_registration = bool(strtobool(str(args.enable_registration)))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import os",
            "",
            "import pkg_resources",
            "",
            "from synapse.api.constants import RoomCreationPreset",
            "from synapse.config._base import Config, ConfigError",
            "from synapse.types import RoomAlias, UserID",
            "from synapse.util.stringutils import random_string_with_symbols, strtobool",
            "",
            "",
            "class AccountValidityConfig(Config):",
            "    section = \"accountvalidity\"",
            "",
            "    def __init__(self, config, synapse_config):",
            "        if config is None:",
            "            return",
            "        super().__init__()",
            "        self.enabled = config.get(\"enabled\", False)",
            "        self.renew_by_email_enabled = \"renew_at\" in config",
            "",
            "        if self.enabled:",
            "            if \"period\" in config:",
            "                self.period = self.parse_duration(config[\"period\"])",
            "            else:",
            "                raise ConfigError(\"'period' is required when using account validity\")",
            "",
            "            if \"renew_at\" in config:",
            "                self.renew_at = self.parse_duration(config[\"renew_at\"])",
            "",
            "            if \"renew_email_subject\" in config:",
            "                self.renew_email_subject = config[\"renew_email_subject\"]",
            "            else:",
            "                self.renew_email_subject = \"Renew your %(app)s account\"",
            "",
            "            self.startup_job_max_delta = self.period * 10.0 / 100.0",
            "",
            "        template_dir = config.get(\"template_dir\")",
            "",
            "        if not template_dir:",
            "            template_dir = pkg_resources.resource_filename(\"synapse\", \"res/templates\")",
            "",
            "        if \"account_renewed_html_path\" in config:",
            "            file_path = os.path.join(template_dir, config[\"account_renewed_html_path\"])",
            "",
            "            self.account_renewed_html_content = self.read_file(",
            "                file_path, \"account_validity.account_renewed_html_path\"",
            "            )",
            "        else:",
            "            self.account_renewed_html_content = (",
            "                \"<html><body>Your account has been successfully renewed.</body><html>\"",
            "            )",
            "",
            "        if \"invalid_token_html_path\" in config:",
            "            file_path = os.path.join(template_dir, config[\"invalid_token_html_path\"])",
            "",
            "            self.invalid_token_html_content = self.read_file(",
            "                file_path, \"account_validity.invalid_token_html_path\"",
            "            )",
            "        else:",
            "            self.invalid_token_html_content = (",
            "                \"<html><body>Invalid renewal token.</body><html>\"",
            "            )",
            "",
            "",
            "class RegistrationConfig(Config):",
            "    section = \"registration\"",
            "",
            "    def read_config(self, config, **kwargs):",
            "        self.enable_registration = strtobool(",
            "            str(config.get(\"enable_registration\", False))",
            "        )",
            "        if \"disable_registration\" in config:",
            "            self.enable_registration = not strtobool(",
            "                str(config[\"disable_registration\"])",
            "            )",
            "",
            "        self.account_validity = AccountValidityConfig(",
            "            config.get(\"account_validity\") or {}, config",
            "        )",
            "",
            "        self.registrations_require_3pid = config.get(\"registrations_require_3pid\", [])",
            "        self.allowed_local_3pids = config.get(\"allowed_local_3pids\", [])",
            "        self.enable_3pid_lookup = config.get(\"enable_3pid_lookup\", True)",
            "        self.registration_shared_secret = config.get(\"registration_shared_secret\")",
            "",
            "        self.bcrypt_rounds = config.get(\"bcrypt_rounds\", 12)",
            "        self.trusted_third_party_id_servers = config.get(",
            "            \"trusted_third_party_id_servers\", [\"matrix.org\", \"vector.im\"]",
            "        )",
            "        account_threepid_delegates = config.get(\"account_threepid_delegates\") or {}",
            "        self.account_threepid_delegate_email = account_threepid_delegates.get(\"email\")",
            "        self.account_threepid_delegate_msisdn = account_threepid_delegates.get(\"msisdn\")",
            "",
            "        self.default_identity_server = config.get(\"default_identity_server\")",
            "        self.allow_guest_access = config.get(\"allow_guest_access\", False)",
            "",
            "        if config.get(\"invite_3pid_guest\", False):",
            "            raise ConfigError(\"invite_3pid_guest is no longer supported\")",
            "",
            "        self.auto_join_rooms = config.get(\"auto_join_rooms\", [])",
            "        for room_alias in self.auto_join_rooms:",
            "            if not RoomAlias.is_valid(room_alias):",
            "                raise ConfigError(\"Invalid auto_join_rooms entry %s\" % (room_alias,))",
            "",
            "        # Options for creating auto-join rooms if they do not exist yet.",
            "        self.autocreate_auto_join_rooms = config.get(\"autocreate_auto_join_rooms\", True)",
            "        self.autocreate_auto_join_rooms_federated = config.get(",
            "            \"autocreate_auto_join_rooms_federated\", True",
            "        )",
            "        self.autocreate_auto_join_room_preset = (",
            "            config.get(\"autocreate_auto_join_room_preset\")",
            "            or RoomCreationPreset.PUBLIC_CHAT",
            "        )",
            "        self.auto_join_room_requires_invite = self.autocreate_auto_join_room_preset in {",
            "            RoomCreationPreset.PRIVATE_CHAT,",
            "            RoomCreationPreset.TRUSTED_PRIVATE_CHAT,",
            "        }",
            "",
            "        # Pull the creator/inviter from the configuration, this gets used to",
            "        # send invites for invite-only rooms.",
            "        mxid_localpart = config.get(\"auto_join_mxid_localpart\")",
            "        self.auto_join_user_id = None",
            "        if mxid_localpart:",
            "            # Convert the localpart to a full mxid.",
            "            self.auto_join_user_id = UserID(",
            "                mxid_localpart, self.server_name",
            "            ).to_string()",
            "",
            "        if self.autocreate_auto_join_rooms:",
            "            # Ensure the preset is a known value.",
            "            if self.autocreate_auto_join_room_preset not in {",
            "                RoomCreationPreset.PUBLIC_CHAT,",
            "                RoomCreationPreset.PRIVATE_CHAT,",
            "                RoomCreationPreset.TRUSTED_PRIVATE_CHAT,",
            "            }:",
            "                raise ConfigError(\"Invalid value for autocreate_auto_join_room_preset\")",
            "            # If the preset requires invitations to be sent, ensure there's a",
            "            # configured user to send them from.",
            "            if self.auto_join_room_requires_invite:",
            "                if not mxid_localpart:",
            "                    raise ConfigError(",
            "                        \"The configuration option `auto_join_mxid_localpart` is required if \"",
            "                        \"`autocreate_auto_join_room_preset` is set to private_chat or trusted_private_chat, such that \"",
            "                        \"Synapse knows who to send invitations from. Please \"",
            "                        \"configure `auto_join_mxid_localpart`.\"",
            "                    )",
            "",
            "        self.auto_join_rooms_for_guests = config.get(\"auto_join_rooms_for_guests\", True)",
            "",
            "        self.enable_set_displayname = config.get(\"enable_set_displayname\", True)",
            "        self.enable_set_avatar_url = config.get(\"enable_set_avatar_url\", True)",
            "        self.enable_3pid_changes = config.get(\"enable_3pid_changes\", True)",
            "",
            "        self.disable_msisdn_registration = config.get(",
            "            \"disable_msisdn_registration\", False",
            "        )",
            "",
            "        session_lifetime = config.get(\"session_lifetime\")",
            "        if session_lifetime is not None:",
            "            session_lifetime = self.parse_duration(session_lifetime)",
            "        self.session_lifetime = session_lifetime",
            "",
            "        # The success template used during fallback auth.",
            "        self.fallback_success_template = self.read_template(\"auth_success.html\")",
            "",
            "    def generate_config_section(self, generate_secrets=False, **kwargs):",
            "        if generate_secrets:",
            "            registration_shared_secret = 'registration_shared_secret: \"%s\"' % (",
            "                random_string_with_symbols(50),",
            "            )",
            "        else:",
            "            registration_shared_secret = \"#registration_shared_secret: <PRIVATE STRING>\"",
            "",
            "        return (",
            "            \"\"\"\\",
            "        ## Registration ##",
            "        #",
            "        # Registration can be rate-limited using the parameters in the \"Ratelimiting\"",
            "        # section of this file.",
            "",
            "        # Enable registration for new users.",
            "        #",
            "        #enable_registration: false",
            "",
            "        # Optional account validity configuration. This allows for accounts to be denied",
            "        # any request after a given period.",
            "        #",
            "        # Once this feature is enabled, Synapse will look for registered users without an",
            "        # expiration date at startup and will add one to every account it found using the",
            "        # current settings at that time.",
            "        # This means that, if a validity period is set, and Synapse is restarted (it will",
            "        # then derive an expiration date from the current validity period), and some time",
            "        # after that the validity period changes and Synapse is restarted, the users'",
            "        # expiration dates won't be updated unless their account is manually renewed. This",
            "        # date will be randomly selected within a range [now + period - d ; now + period],",
            "        # where d is equal to 10%% of the validity period.",
            "        #",
            "        account_validity:",
            "          # The account validity feature is disabled by default. Uncomment the",
            "          # following line to enable it.",
            "          #",
            "          #enabled: true",
            "",
            "          # The period after which an account is valid after its registration. When",
            "          # renewing the account, its validity period will be extended by this amount",
            "          # of time. This parameter is required when using the account validity",
            "          # feature.",
            "          #",
            "          #period: 6w",
            "",
            "          # The amount of time before an account's expiry date at which Synapse will",
            "          # send an email to the account's email address with a renewal link. By",
            "          # default, no such emails are sent.",
            "          #",
            "          # If you enable this setting, you will also need to fill out the 'email'",
            "          # configuration section. You should also check that 'public_baseurl' is set",
            "          # correctly.",
            "          #",
            "          #renew_at: 1w",
            "",
            "          # The subject of the email sent out with the renewal link. '%%(app)s' can be",
            "          # used as a placeholder for the 'app_name' parameter from the 'email'",
            "          # section.",
            "          #",
            "          # Note that the placeholder must be written '%%(app)s', including the",
            "          # trailing 's'.",
            "          #",
            "          # If this is not set, a default value is used.",
            "          #",
            "          #renew_email_subject: \"Renew your %%(app)s account\"",
            "",
            "          # Directory in which Synapse will try to find templates for the HTML files to",
            "          # serve to the user when trying to renew an account. If not set, default",
            "          # templates from within the Synapse package will be used.",
            "          #",
            "          #template_dir: \"res/templates\"",
            "",
            "          # File within 'template_dir' giving the HTML to be displayed to the user after",
            "          # they successfully renewed their account. If not set, default text is used.",
            "          #",
            "          #account_renewed_html_path: \"account_renewed.html\"",
            "",
            "          # File within 'template_dir' giving the HTML to be displayed when the user",
            "          # tries to renew an account with an invalid renewal token. If not set,",
            "          # default text is used.",
            "          #",
            "          #invalid_token_html_path: \"invalid_token.html\"",
            "",
            "        # Time that a user's session remains valid for, after they log in.",
            "        #",
            "        # Note that this is not currently compatible with guest logins.",
            "        #",
            "        # Note also that this is calculated at login time: changes are not applied",
            "        # retrospectively to users who have already logged in.",
            "        #",
            "        # By default, this is infinite.",
            "        #",
            "        #session_lifetime: 24h",
            "",
            "        # The user must provide all of the below types of 3PID when registering.",
            "        #",
            "        #registrations_require_3pid:",
            "        #  - email",
            "        #  - msisdn",
            "",
            "        # Explicitly disable asking for MSISDNs from the registration",
            "        # flow (overrides registrations_require_3pid if MSISDNs are set as required)",
            "        #",
            "        #disable_msisdn_registration: true",
            "",
            "        # Mandate that users are only allowed to associate certain formats of",
            "        # 3PIDs with accounts on this server.",
            "        #",
            "        #allowed_local_3pids:",
            "        #  - medium: email",
            "        #    pattern: '.*@matrix\\\\.org'",
            "        #  - medium: email",
            "        #    pattern: '.*@vector\\\\.im'",
            "        #  - medium: msisdn",
            "        #    pattern: '\\\\+44'",
            "",
            "        # Enable 3PIDs lookup requests to identity servers from this server.",
            "        #",
            "        #enable_3pid_lookup: true",
            "",
            "        # If set, allows registration of standard or admin accounts by anyone who",
            "        # has the shared secret, even if registration is otherwise disabled.",
            "        #",
            "        %(registration_shared_secret)s",
            "",
            "        # Set the number of bcrypt rounds used to generate password hash.",
            "        # Larger numbers increase the work factor needed to generate the hash.",
            "        # The default number is 12 (which equates to 2^12 rounds).",
            "        # N.B. that increasing this will exponentially increase the time required",
            "        # to register or login - e.g. 24 => 2^24 rounds which will take >20 mins.",
            "        #",
            "        #bcrypt_rounds: 12",
            "",
            "        # Allows users to register as guests without a password/email/etc, and",
            "        # participate in rooms hosted on this server which have been made",
            "        # accessible to anonymous users.",
            "        #",
            "        #allow_guest_access: false",
            "",
            "        # The identity server which we suggest that clients should use when users log",
            "        # in on this server.",
            "        #",
            "        # (By default, no suggestion is made, so it is left up to the client.)",
            "        #",
            "        #default_identity_server: https://matrix.org",
            "",
            "        # Handle threepid (email/phone etc) registration and password resets through a set of",
            "        # *trusted* identity servers. Note that this allows the configured identity server to",
            "        # reset passwords for accounts!",
            "        #",
            "        # Be aware that if `email` is not set, and SMTP options have not been",
            "        # configured in the email config block, registration and user password resets via",
            "        # email will be globally disabled.",
            "        #",
            "        # Additionally, if `msisdn` is not set, registration and password resets via msisdn",
            "        # will be disabled regardless, and users will not be able to associate an msisdn",
            "        # identifier to their account. This is due to Synapse currently not supporting",
            "        # any method of sending SMS messages on its own.",
            "        #",
            "        # To enable using an identity server for operations regarding a particular third-party",
            "        # identifier type, set the value to the URL of that identity server as shown in the",
            "        # examples below.",
            "        #",
            "        # Servers handling the these requests must answer the `/requestToken` endpoints defined",
            "        # by the Matrix Identity Service API specification:",
            "        # https://matrix.org/docs/spec/identity_service/latest",
            "        #",
            "        account_threepid_delegates:",
            "            #email: https://example.com     # Delegate email sending to example.com",
            "            #msisdn: http://localhost:8090  # Delegate SMS sending to this local process",
            "",
            "        # Whether users are allowed to change their displayname after it has",
            "        # been initially set. Useful when provisioning users based on the",
            "        # contents of a third-party directory.",
            "        #",
            "        # Does not apply to server administrators. Defaults to 'true'",
            "        #",
            "        #enable_set_displayname: false",
            "",
            "        # Whether users are allowed to change their avatar after it has been",
            "        # initially set. Useful when provisioning users based on the contents",
            "        # of a third-party directory.",
            "        #",
            "        # Does not apply to server administrators. Defaults to 'true'",
            "        #",
            "        #enable_set_avatar_url: false",
            "",
            "        # Whether users can change the 3PIDs associated with their accounts",
            "        # (email address and msisdn).",
            "        #",
            "        # Defaults to 'true'",
            "        #",
            "        #enable_3pid_changes: false",
            "",
            "        # Users who register on this homeserver will automatically be joined",
            "        # to these rooms.",
            "        #",
            "        # By default, any room aliases included in this list will be created",
            "        # as a publicly joinable room when the first user registers for the",
            "        # homeserver. This behaviour can be customised with the settings below.",
            "        #",
            "        #auto_join_rooms:",
            "        #  - \"#example:example.com\"",
            "",
            "        # Where auto_join_rooms are specified, setting this flag ensures that the",
            "        # the rooms exist by creating them when the first user on the",
            "        # homeserver registers.",
            "        #",
            "        # By default the auto-created rooms are publicly joinable from any federated",
            "        # server. Use the autocreate_auto_join_rooms_federated and",
            "        # autocreate_auto_join_room_preset settings below to customise this behaviour.",
            "        #",
            "        # Setting to false means that if the rooms are not manually created,",
            "        # users cannot be auto-joined since they do not exist.",
            "        #",
            "        # Defaults to true. Uncomment the following line to disable automatically",
            "        # creating auto-join rooms.",
            "        #",
            "        #autocreate_auto_join_rooms: false",
            "",
            "        # Whether the auto_join_rooms that are auto-created are available via",
            "        # federation. Only has an effect if autocreate_auto_join_rooms is true.",
            "        #",
            "        # Note that whether a room is federated cannot be modified after",
            "        # creation.",
            "        #",
            "        # Defaults to true: the room will be joinable from other servers.",
            "        # Uncomment the following to prevent users from other homeservers from",
            "        # joining these rooms.",
            "        #",
            "        #autocreate_auto_join_rooms_federated: false",
            "",
            "        # The room preset to use when auto-creating one of auto_join_rooms. Only has an",
            "        # effect if autocreate_auto_join_rooms is true.",
            "        #",
            "        # This can be one of \"public_chat\", \"private_chat\", or \"trusted_private_chat\".",
            "        # If a value of \"private_chat\" or \"trusted_private_chat\" is used then",
            "        # auto_join_mxid_localpart must also be configured.",
            "        #",
            "        # Defaults to \"public_chat\", meaning that the room is joinable by anyone, including",
            "        # federated servers if autocreate_auto_join_rooms_federated is true (the default).",
            "        # Uncomment the following to require an invitation to join these rooms.",
            "        #",
            "        #autocreate_auto_join_room_preset: private_chat",
            "",
            "        # The local part of the user id which is used to create auto_join_rooms if",
            "        # autocreate_auto_join_rooms is true. If this is not provided then the",
            "        # initial user account that registers will be used to create the rooms.",
            "        #",
            "        # The user id is also used to invite new users to any auto-join rooms which",
            "        # are set to invite-only.",
            "        #",
            "        # It *must* be configured if autocreate_auto_join_room_preset is set to",
            "        # \"private_chat\" or \"trusted_private_chat\".",
            "        #",
            "        # Note that this must be specified in order for new users to be correctly",
            "        # invited to any auto-join rooms which have been set to invite-only (either",
            "        # at the time of creation or subsequently).",
            "        #",
            "        # Note that, if the room already exists, this user must be joined and",
            "        # have the appropriate permissions to invite new members.",
            "        #",
            "        #auto_join_mxid_localpart: system",
            "",
            "        # When auto_join_rooms is specified, setting this flag to false prevents",
            "        # guest accounts from being automatically joined to the rooms.",
            "        #",
            "        # Defaults to true.",
            "        #",
            "        #auto_join_rooms_for_guests: false",
            "        \"\"\"",
            "            % locals()",
            "        )",
            "",
            "    @staticmethod",
            "    def add_arguments(parser):",
            "        reg_group = parser.add_argument_group(\"registration\")",
            "        reg_group.add_argument(",
            "            \"--enable-registration\",",
            "            action=\"store_true\",",
            "            default=None,",
            "            help=\"Enable registration for new users.\",",
            "        )",
            "",
            "    def read_arguments(self, args):",
            "        if args.enable_registration is not None:",
            "            self.enable_registration = bool(strtobool(str(args.enable_registration)))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "179": [
                "RegistrationConfig",
                "read_config"
            ],
            "180": [
                "RegistrationConfig",
                "read_config"
            ],
            "181": [
                "RegistrationConfig",
                "read_config"
            ]
        },
        "addLocation": []
    },
    "synapse/push/mailer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 668,
                "afterPatchRowNumber": 668,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 669,
                "afterPatchRowNumber": 669,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 670,
                "afterPatchRowNumber": 670,
                "PatchRowcode": " def safe_markup(raw_html: str) -> jinja2.Markup:"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 671,
                "PatchRowcode": "+    \"\"\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 672,
                "PatchRowcode": "+    Sanitise a raw HTML string to a set of allowed tags and attributes, and linkify any bare URLs."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 673,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 674,
                "PatchRowcode": "+    Args"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 675,
                "PatchRowcode": "+        raw_html: Unsafe HTML."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 676,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+    Returns:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 678,
                "PatchRowcode": "+        A Markup object ready to safely use in a Jinja template."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 679,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 671,
                "afterPatchRowNumber": 680,
                "PatchRowcode": "     return jinja2.Markup("
            },
            "13": {
                "beforePatchRowNumber": 672,
                "afterPatchRowNumber": 681,
                "PatchRowcode": "         bleach.linkify("
            },
            "14": {
                "beforePatchRowNumber": 673,
                "afterPatchRowNumber": 682,
                "PatchRowcode": "             bleach.clean("
            },
            "15": {
                "beforePatchRowNumber": 684,
                "afterPatchRowNumber": 693,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 685,
                "afterPatchRowNumber": 694,
                "PatchRowcode": " def safe_text(raw_text: str) -> jinja2.Markup:"
            },
            "17": {
                "beforePatchRowNumber": 686,
                "afterPatchRowNumber": 695,
                "PatchRowcode": "     \"\"\""
            },
            "18": {
                "beforePatchRowNumber": 687,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Process text: treat it as HTML but escape any tags (ie. just escape the"
            },
            "19": {
                "beforePatchRowNumber": 688,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    HTML) then linkify it."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 696,
                "PatchRowcode": "+    Sanitise text (escape any HTML tags), and then linkify any bare URLs."
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 697,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 698,
                "PatchRowcode": "+    Args"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 699,
                "PatchRowcode": "+        raw_text: Unsafe text which might include HTML markup."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 700,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 701,
                "PatchRowcode": "+    Returns:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 702,
                "PatchRowcode": "+        A Markup object ready to safely use in a Jinja template."
            },
            "27": {
                "beforePatchRowNumber": 689,
                "afterPatchRowNumber": 703,
                "PatchRowcode": "     \"\"\""
            },
            "28": {
                "beforePatchRowNumber": 690,
                "afterPatchRowNumber": 704,
                "PatchRowcode": "     return jinja2.Markup("
            },
            "29": {
                "beforePatchRowNumber": 691,
                "afterPatchRowNumber": 705,
                "PatchRowcode": "         bleach.linkify(bleach.clean(raw_text, tags=[], attributes={}, strip=False))"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import email.mime.multipart",
            "import email.utils",
            "import logging",
            "import urllib.parse",
            "from email.mime.multipart import MIMEMultipart",
            "from email.mime.text import MIMEText",
            "from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, TypeVar",
            "",
            "import bleach",
            "import jinja2",
            "",
            "from synapse.api.constants import EventTypes, Membership",
            "from synapse.api.errors import StoreError",
            "from synapse.config.emailconfig import EmailSubjectConfig",
            "from synapse.events import EventBase",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.push.presentable_names import (",
            "    calculate_room_name,",
            "    descriptor_from_member_events,",
            "    name_from_member_event,",
            ")",
            "from synapse.types import StateMap, UserID",
            "from synapse.util.async_helpers import concurrently_execute",
            "from synapse.visibility import filter_events_for_client",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.app.homeserver import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "T = TypeVar(\"T\")",
            "",
            "",
            "CONTEXT_BEFORE = 1",
            "CONTEXT_AFTER = 1",
            "",
            "# From https://github.com/matrix-org/matrix-react-sdk/blob/master/src/HtmlUtils.js",
            "ALLOWED_TAGS = [",
            "    \"font\",  # custom to matrix for IRC-style font coloring",
            "    \"del\",  # for markdown",
            "    # deliberately no h1/h2 to stop people shouting.",
            "    \"h3\",",
            "    \"h4\",",
            "    \"h5\",",
            "    \"h6\",",
            "    \"blockquote\",",
            "    \"p\",",
            "    \"a\",",
            "    \"ul\",",
            "    \"ol\",",
            "    \"nl\",",
            "    \"li\",",
            "    \"b\",",
            "    \"i\",",
            "    \"u\",",
            "    \"strong\",",
            "    \"em\",",
            "    \"strike\",",
            "    \"code\",",
            "    \"hr\",",
            "    \"br\",",
            "    \"div\",",
            "    \"table\",",
            "    \"thead\",",
            "    \"caption\",",
            "    \"tbody\",",
            "    \"tr\",",
            "    \"th\",",
            "    \"td\",",
            "    \"pre\",",
            "]",
            "ALLOWED_ATTRS = {",
            "    # custom ones first:",
            "    \"font\": [\"color\"],  # custom to matrix",
            "    \"a\": [\"href\", \"name\", \"target\"],  # remote target: custom to matrix",
            "    # We don't currently allow img itself by default, but this",
            "    # would make sense if we did",
            "    \"img\": [\"src\"],",
            "}",
            "# When bleach release a version with this option, we can specify schemes",
            "# ALLOWED_SCHEMES = [\"http\", \"https\", \"ftp\", \"mailto\"]",
            "",
            "",
            "class Mailer:",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        app_name: str,",
            "        template_html: jinja2.Template,",
            "        template_text: jinja2.Template,",
            "    ):",
            "        self.hs = hs",
            "        self.template_html = template_html",
            "        self.template_text = template_text",
            "",
            "        self.sendmail = self.hs.get_sendmail()",
            "        self.store = self.hs.get_datastore()",
            "        self.macaroon_gen = self.hs.get_macaroon_generator()",
            "        self.state_handler = self.hs.get_state_handler()",
            "        self.storage = hs.get_storage()",
            "        self.app_name = app_name",
            "        self.email_subjects = hs.config.email_subjects  # type: EmailSubjectConfig",
            "",
            "        logger.info(\"Created Mailer for app_name %s\" % app_name)",
            "",
            "    async def send_password_reset_mail(",
            "        self, email_address: str, token: str, client_secret: str, sid: str",
            "    ) -> None:",
            "        \"\"\"Send an email with a password reset link to a user",
            "",
            "        Args:",
            "            email_address: Email address we're sending the password",
            "                reset to",
            "            token: Unique token generated by the server to verify",
            "                the email was received",
            "            client_secret: Unique token generated by the client to",
            "                group together multiple email sending attempts",
            "            sid: The generated session ID",
            "        \"\"\"",
            "        params = {\"token\": token, \"client_secret\": client_secret, \"sid\": sid}",
            "        link = (",
            "            self.hs.config.public_baseurl",
            "            + \"_synapse/client/password_reset/email/submit_token?%s\"",
            "            % urllib.parse.urlencode(params)",
            "        )",
            "",
            "        template_vars = {\"link\": link}",
            "",
            "        await self.send_email(",
            "            email_address,",
            "            self.email_subjects.password_reset",
            "            % {\"server_name\": self.hs.config.server_name},",
            "            template_vars,",
            "        )",
            "",
            "    async def send_registration_mail(",
            "        self, email_address: str, token: str, client_secret: str, sid: str",
            "    ) -> None:",
            "        \"\"\"Send an email with a registration confirmation link to a user",
            "",
            "        Args:",
            "            email_address: Email address we're sending the registration",
            "                link to",
            "            token: Unique token generated by the server to verify",
            "                the email was received",
            "            client_secret: Unique token generated by the client to",
            "                group together multiple email sending attempts",
            "            sid: The generated session ID",
            "        \"\"\"",
            "        params = {\"token\": token, \"client_secret\": client_secret, \"sid\": sid}",
            "        link = (",
            "            self.hs.config.public_baseurl",
            "            + \"_matrix/client/unstable/registration/email/submit_token?%s\"",
            "            % urllib.parse.urlencode(params)",
            "        )",
            "",
            "        template_vars = {\"link\": link}",
            "",
            "        await self.send_email(",
            "            email_address,",
            "            self.email_subjects.email_validation",
            "            % {\"server_name\": self.hs.config.server_name},",
            "            template_vars,",
            "        )",
            "",
            "    async def send_add_threepid_mail(",
            "        self, email_address: str, token: str, client_secret: str, sid: str",
            "    ) -> None:",
            "        \"\"\"Send an email with a validation link to a user for adding a 3pid to their account",
            "",
            "        Args:",
            "            email_address: Email address we're sending the validation link to",
            "",
            "            token: Unique token generated by the server to verify the email was received",
            "",
            "            client_secret: Unique token generated by the client to group together",
            "                multiple email sending attempts",
            "",
            "            sid: The generated session ID",
            "        \"\"\"",
            "        params = {\"token\": token, \"client_secret\": client_secret, \"sid\": sid}",
            "        link = (",
            "            self.hs.config.public_baseurl",
            "            + \"_matrix/client/unstable/add_threepid/email/submit_token?%s\"",
            "            % urllib.parse.urlencode(params)",
            "        )",
            "",
            "        template_vars = {\"link\": link}",
            "",
            "        await self.send_email(",
            "            email_address,",
            "            self.email_subjects.email_validation",
            "            % {\"server_name\": self.hs.config.server_name},",
            "            template_vars,",
            "        )",
            "",
            "    async def send_notification_mail(",
            "        self,",
            "        app_id: str,",
            "        user_id: str,",
            "        email_address: str,",
            "        push_actions: Iterable[Dict[str, Any]],",
            "        reason: Dict[str, Any],",
            "    ) -> None:",
            "        \"\"\"Send email regarding a user's room notifications\"\"\"",
            "        rooms_in_order = deduped_ordered_list([pa[\"room_id\"] for pa in push_actions])",
            "",
            "        notif_events = await self.store.get_events(",
            "            [pa[\"event_id\"] for pa in push_actions]",
            "        )",
            "",
            "        notifs_by_room = {}  # type: Dict[str, List[Dict[str, Any]]]",
            "        for pa in push_actions:",
            "            notifs_by_room.setdefault(pa[\"room_id\"], []).append(pa)",
            "",
            "        # collect the current state for all the rooms in which we have",
            "        # notifications",
            "        state_by_room = {}",
            "",
            "        try:",
            "            user_display_name = await self.store.get_profile_displayname(",
            "                UserID.from_string(user_id).localpart",
            "            )",
            "            if user_display_name is None:",
            "                user_display_name = user_id",
            "        except StoreError:",
            "            user_display_name = user_id",
            "",
            "        async def _fetch_room_state(room_id):",
            "            room_state = await self.store.get_current_state_ids(room_id)",
            "            state_by_room[room_id] = room_state",
            "",
            "        # Run at most 3 of these at once: sync does 10 at a time but email",
            "        # notifs are much less realtime than sync so we can afford to wait a bit.",
            "        await concurrently_execute(_fetch_room_state, rooms_in_order, 3)",
            "",
            "        # actually sort our so-called rooms_in_order list, most recent room first",
            "        rooms_in_order.sort(key=lambda r: -(notifs_by_room[r][-1][\"received_ts\"] or 0))",
            "",
            "        rooms = []",
            "",
            "        for r in rooms_in_order:",
            "            roomvars = await self.get_room_vars(",
            "                r, user_id, notifs_by_room[r], notif_events, state_by_room[r]",
            "            )",
            "            rooms.append(roomvars)",
            "",
            "        reason[\"room_name\"] = await calculate_room_name(",
            "            self.store,",
            "            state_by_room[reason[\"room_id\"]],",
            "            user_id,",
            "            fallback_to_members=True,",
            "        )",
            "",
            "        summary_text = await self.make_summary_text(",
            "            notifs_by_room, state_by_room, notif_events, user_id, reason",
            "        )",
            "",
            "        template_vars = {",
            "            \"user_display_name\": user_display_name,",
            "            \"unsubscribe_link\": self.make_unsubscribe_link(",
            "                user_id, app_id, email_address",
            "            ),",
            "            \"summary_text\": summary_text,",
            "            \"rooms\": rooms,",
            "            \"reason\": reason,",
            "        }",
            "",
            "        await self.send_email(email_address, summary_text, template_vars)",
            "",
            "    async def send_email(",
            "        self, email_address: str, subject: str, extra_template_vars: Dict[str, Any]",
            "    ) -> None:",
            "        \"\"\"Send an email with the given information and template text\"\"\"",
            "        try:",
            "            from_string = self.hs.config.email_notif_from % {\"app\": self.app_name}",
            "        except TypeError:",
            "            from_string = self.hs.config.email_notif_from",
            "",
            "        raw_from = email.utils.parseaddr(from_string)[1]",
            "        raw_to = email.utils.parseaddr(email_address)[1]",
            "",
            "        if raw_to == \"\":",
            "            raise RuntimeError(\"Invalid 'to' address\")",
            "",
            "        template_vars = {",
            "            \"app_name\": self.app_name,",
            "            \"server_name\": self.hs.config.server.server_name,",
            "        }",
            "",
            "        template_vars.update(extra_template_vars)",
            "",
            "        html_text = self.template_html.render(**template_vars)",
            "        html_part = MIMEText(html_text, \"html\", \"utf8\")",
            "",
            "        plain_text = self.template_text.render(**template_vars)",
            "        text_part = MIMEText(plain_text, \"plain\", \"utf8\")",
            "",
            "        multipart_msg = MIMEMultipart(\"alternative\")",
            "        multipart_msg[\"Subject\"] = subject",
            "        multipart_msg[\"From\"] = from_string",
            "        multipart_msg[\"To\"] = email_address",
            "        multipart_msg[\"Date\"] = email.utils.formatdate()",
            "        multipart_msg[\"Message-ID\"] = email.utils.make_msgid()",
            "        multipart_msg.attach(text_part)",
            "        multipart_msg.attach(html_part)",
            "",
            "        logger.info(\"Sending email to %s\" % email_address)",
            "",
            "        await make_deferred_yieldable(",
            "            self.sendmail(",
            "                self.hs.config.email_smtp_host,",
            "                raw_from,",
            "                raw_to,",
            "                multipart_msg.as_string().encode(\"utf8\"),",
            "                reactor=self.hs.get_reactor(),",
            "                port=self.hs.config.email_smtp_port,",
            "                requireAuthentication=self.hs.config.email_smtp_user is not None,",
            "                username=self.hs.config.email_smtp_user,",
            "                password=self.hs.config.email_smtp_pass,",
            "                requireTransportSecurity=self.hs.config.require_transport_security,",
            "            )",
            "        )",
            "",
            "    async def get_room_vars(",
            "        self,",
            "        room_id: str,",
            "        user_id: str,",
            "        notifs: Iterable[Dict[str, Any]],",
            "        notif_events: Dict[str, EventBase],",
            "        room_state_ids: StateMap[str],",
            "    ) -> Dict[str, Any]:",
            "        # Check if one of the notifs is an invite event for the user.",
            "        is_invite = False",
            "        for n in notifs:",
            "            ev = notif_events[n[\"event_id\"]]",
            "            if ev.type == EventTypes.Member and ev.state_key == user_id:",
            "                if ev.content.get(\"membership\") == Membership.INVITE:",
            "                    is_invite = True",
            "                    break",
            "",
            "        room_name = await calculate_room_name(self.store, room_state_ids, user_id)",
            "",
            "        room_vars = {",
            "            \"title\": room_name,",
            "            \"hash\": string_ordinal_total(room_id),  # See sender avatar hash",
            "            \"notifs\": [],",
            "            \"invite\": is_invite,",
            "            \"link\": self.make_room_link(room_id),",
            "        }  # type: Dict[str, Any]",
            "",
            "        if not is_invite:",
            "            for n in notifs:",
            "                notifvars = await self.get_notif_vars(",
            "                    n, user_id, notif_events[n[\"event_id\"]], room_state_ids",
            "                )",
            "",
            "                # merge overlapping notifs together.",
            "                # relies on the notifs being in chronological order.",
            "                merge = False",
            "                if room_vars[\"notifs\"] and \"messages\" in room_vars[\"notifs\"][-1]:",
            "                    prev_messages = room_vars[\"notifs\"][-1][\"messages\"]",
            "                    for message in notifvars[\"messages\"]:",
            "                        pm = list(",
            "                            filter(lambda pm: pm[\"id\"] == message[\"id\"], prev_messages)",
            "                        )",
            "                        if pm:",
            "                            if not message[\"is_historical\"]:",
            "                                pm[0][\"is_historical\"] = False",
            "                            merge = True",
            "                        elif merge:",
            "                            # we're merging, so append any remaining messages",
            "                            # in this notif to the previous one",
            "                            prev_messages.append(message)",
            "",
            "                if not merge:",
            "                    room_vars[\"notifs\"].append(notifvars)",
            "",
            "        return room_vars",
            "",
            "    async def get_notif_vars(",
            "        self,",
            "        notif: Dict[str, Any],",
            "        user_id: str,",
            "        notif_event: EventBase,",
            "        room_state_ids: StateMap[str],",
            "    ) -> Dict[str, Any]:",
            "        results = await self.store.get_events_around(",
            "            notif[\"room_id\"],",
            "            notif[\"event_id\"],",
            "            before_limit=CONTEXT_BEFORE,",
            "            after_limit=CONTEXT_AFTER,",
            "        )",
            "",
            "        ret = {",
            "            \"link\": self.make_notif_link(notif),",
            "            \"ts\": notif[\"received_ts\"],",
            "            \"messages\": [],",
            "        }",
            "",
            "        the_events = await filter_events_for_client(",
            "            self.storage, user_id, results[\"events_before\"]",
            "        )",
            "        the_events.append(notif_event)",
            "",
            "        for event in the_events:",
            "            messagevars = await self.get_message_vars(notif, event, room_state_ids)",
            "            if messagevars is not None:",
            "                ret[\"messages\"].append(messagevars)",
            "",
            "        return ret",
            "",
            "    async def get_message_vars(",
            "        self, notif: Dict[str, Any], event: EventBase, room_state_ids: StateMap[str]",
            "    ) -> Optional[Dict[str, Any]]:",
            "        if event.type != EventTypes.Message and event.type != EventTypes.Encrypted:",
            "            return None",
            "",
            "        sender_state_event_id = room_state_ids[(\"m.room.member\", event.sender)]",
            "        sender_state_event = await self.store.get_event(sender_state_event_id)",
            "        sender_name = name_from_member_event(sender_state_event)",
            "        sender_avatar_url = sender_state_event.content.get(\"avatar_url\")",
            "",
            "        # 'hash' for deterministically picking default images: use",
            "        # sender_hash % the number of default images to choose from",
            "        sender_hash = string_ordinal_total(event.sender)",
            "",
            "        ret = {",
            "            \"event_type\": event.type,",
            "            \"is_historical\": event.event_id != notif[\"event_id\"],",
            "            \"id\": event.event_id,",
            "            \"ts\": event.origin_server_ts,",
            "            \"sender_name\": sender_name,",
            "            \"sender_avatar_url\": sender_avatar_url,",
            "            \"sender_hash\": sender_hash,",
            "        }",
            "",
            "        # Encrypted messages don't have any additional useful information.",
            "        if event.type == EventTypes.Encrypted:",
            "            return ret",
            "",
            "        msgtype = event.content.get(\"msgtype\")",
            "",
            "        ret[\"msgtype\"] = msgtype",
            "",
            "        if msgtype == \"m.text\":",
            "            self.add_text_message_vars(ret, event)",
            "        elif msgtype == \"m.image\":",
            "            self.add_image_message_vars(ret, event)",
            "",
            "        if \"body\" in event.content:",
            "            ret[\"body_text_plain\"] = event.content[\"body\"]",
            "",
            "        return ret",
            "",
            "    def add_text_message_vars(",
            "        self, messagevars: Dict[str, Any], event: EventBase",
            "    ) -> None:",
            "        msgformat = event.content.get(\"format\")",
            "",
            "        messagevars[\"format\"] = msgformat",
            "",
            "        formatted_body = event.content.get(\"formatted_body\")",
            "        body = event.content.get(\"body\")",
            "",
            "        if msgformat == \"org.matrix.custom.html\" and formatted_body:",
            "            messagevars[\"body_text_html\"] = safe_markup(formatted_body)",
            "        elif body:",
            "            messagevars[\"body_text_html\"] = safe_text(body)",
            "",
            "    def add_image_message_vars(",
            "        self, messagevars: Dict[str, Any], event: EventBase",
            "    ) -> None:",
            "        \"\"\"",
            "        Potentially add an image URL to the message variables.",
            "        \"\"\"",
            "        if \"url\" in event.content:",
            "            messagevars[\"image_url\"] = event.content[\"url\"]",
            "",
            "    async def make_summary_text(",
            "        self,",
            "        notifs_by_room: Dict[str, List[Dict[str, Any]]],",
            "        room_state_ids: Dict[str, StateMap[str]],",
            "        notif_events: Dict[str, EventBase],",
            "        user_id: str,",
            "        reason: Dict[str, Any],",
            "    ):",
            "        if len(notifs_by_room) == 1:",
            "            # Only one room has new stuff",
            "            room_id = list(notifs_by_room.keys())[0]",
            "",
            "            # If the room has some kind of name, use it, but we don't",
            "            # want the generated-from-names one here otherwise we'll",
            "            # end up with, \"new message from Bob in the Bob room\"",
            "            room_name = await calculate_room_name(",
            "                self.store, room_state_ids[room_id], user_id, fallback_to_members=False",
            "            )",
            "",
            "            # See if one of the notifs is an invite event for the user",
            "            invite_event = None",
            "            for n in notifs_by_room[room_id]:",
            "                ev = notif_events[n[\"event_id\"]]",
            "                if ev.type == EventTypes.Member and ev.state_key == user_id:",
            "                    if ev.content.get(\"membership\") == Membership.INVITE:",
            "                        invite_event = ev",
            "                        break",
            "",
            "            if invite_event:",
            "                inviter_member_event_id = room_state_ids[room_id].get(",
            "                    (\"m.room.member\", invite_event.sender)",
            "                )",
            "                inviter_name = invite_event.sender",
            "                if inviter_member_event_id:",
            "                    inviter_member_event = await self.store.get_event(",
            "                        inviter_member_event_id, allow_none=True",
            "                    )",
            "                    if inviter_member_event:",
            "                        inviter_name = name_from_member_event(inviter_member_event)",
            "",
            "                if room_name is None:",
            "                    return self.email_subjects.invite_from_person % {",
            "                        \"person\": inviter_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "                else:",
            "                    return self.email_subjects.invite_from_person_to_room % {",
            "                        \"person\": inviter_name,",
            "                        \"room\": room_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "",
            "            sender_name = None",
            "            if len(notifs_by_room[room_id]) == 1:",
            "                # There is just the one notification, so give some detail",
            "                event = notif_events[notifs_by_room[room_id][0][\"event_id\"]]",
            "                if (\"m.room.member\", event.sender) in room_state_ids[room_id]:",
            "                    state_event_id = room_state_ids[room_id][",
            "                        (\"m.room.member\", event.sender)",
            "                    ]",
            "                    state_event = await self.store.get_event(state_event_id)",
            "                    sender_name = name_from_member_event(state_event)",
            "",
            "                if sender_name is not None and room_name is not None:",
            "                    return self.email_subjects.message_from_person_in_room % {",
            "                        \"person\": sender_name,",
            "                        \"room\": room_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "                elif sender_name is not None:",
            "                    return self.email_subjects.message_from_person % {",
            "                        \"person\": sender_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "            else:",
            "                # There's more than one notification for this room, so just",
            "                # say there are several",
            "                if room_name is not None:",
            "                    return self.email_subjects.messages_in_room % {",
            "                        \"room\": room_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "                else:",
            "                    # If the room doesn't have a name, say who the messages",
            "                    # are from explicitly to avoid, \"messages in the Bob room\"",
            "                    sender_ids = list(",
            "                        {",
            "                            notif_events[n[\"event_id\"]].sender",
            "                            for n in notifs_by_room[room_id]",
            "                        }",
            "                    )",
            "",
            "                    member_events = await self.store.get_events(",
            "                        [",
            "                            room_state_ids[room_id][(\"m.room.member\", s)]",
            "                            for s in sender_ids",
            "                        ]",
            "                    )",
            "",
            "                    return self.email_subjects.messages_from_person % {",
            "                        \"person\": descriptor_from_member_events(member_events.values()),",
            "                        \"app\": self.app_name,",
            "                    }",
            "        else:",
            "            # Stuff's happened in multiple different rooms",
            "",
            "            # ...but we still refer to the 'reason' room which triggered the mail",
            "            if reason[\"room_name\"] is not None:",
            "                return self.email_subjects.messages_in_room_and_others % {",
            "                    \"room\": reason[\"room_name\"],",
            "                    \"app\": self.app_name,",
            "                }",
            "            else:",
            "                # If the reason room doesn't have a name, say who the messages",
            "                # are from explicitly to avoid, \"messages in the Bob room\"",
            "                room_id = reason[\"room_id\"]",
            "",
            "                sender_ids = list(",
            "                    {",
            "                        notif_events[n[\"event_id\"]].sender",
            "                        for n in notifs_by_room[room_id]",
            "                    }",
            "                )",
            "",
            "                member_events = await self.store.get_events(",
            "                    [room_state_ids[room_id][(\"m.room.member\", s)] for s in sender_ids]",
            "                )",
            "",
            "                return self.email_subjects.messages_from_person_and_others % {",
            "                    \"person\": descriptor_from_member_events(member_events.values()),",
            "                    \"app\": self.app_name,",
            "                }",
            "",
            "    def make_room_link(self, room_id: str) -> str:",
            "        if self.hs.config.email_riot_base_url:",
            "            base_url = \"%s/#/room\" % (self.hs.config.email_riot_base_url)",
            "        elif self.app_name == \"Vector\":",
            "            # need /beta for Universal Links to work on iOS",
            "            base_url = \"https://vector.im/beta/#/room\"",
            "        else:",
            "            base_url = \"https://matrix.to/#\"",
            "        return \"%s/%s\" % (base_url, room_id)",
            "",
            "    def make_notif_link(self, notif: Dict[str, str]) -> str:",
            "        if self.hs.config.email_riot_base_url:",
            "            return \"%s/#/room/%s/%s\" % (",
            "                self.hs.config.email_riot_base_url,",
            "                notif[\"room_id\"],",
            "                notif[\"event_id\"],",
            "            )",
            "        elif self.app_name == \"Vector\":",
            "            # need /beta for Universal Links to work on iOS",
            "            return \"https://vector.im/beta/#/room/%s/%s\" % (",
            "                notif[\"room_id\"],",
            "                notif[\"event_id\"],",
            "            )",
            "        else:",
            "            return \"https://matrix.to/#/%s/%s\" % (notif[\"room_id\"], notif[\"event_id\"])",
            "",
            "    def make_unsubscribe_link(",
            "        self, user_id: str, app_id: str, email_address: str",
            "    ) -> str:",
            "        params = {",
            "            \"access_token\": self.macaroon_gen.generate_delete_pusher_token(user_id),",
            "            \"app_id\": app_id,",
            "            \"pushkey\": email_address,",
            "        }",
            "",
            "        # XXX: make r0 once API is stable",
            "        return \"%s_matrix/client/unstable/pushers/remove?%s\" % (",
            "            self.hs.config.public_baseurl,",
            "            urllib.parse.urlencode(params),",
            "        )",
            "",
            "",
            "def safe_markup(raw_html: str) -> jinja2.Markup:",
            "    return jinja2.Markup(",
            "        bleach.linkify(",
            "            bleach.clean(",
            "                raw_html,",
            "                tags=ALLOWED_TAGS,",
            "                attributes=ALLOWED_ATTRS,",
            "                # bleach master has this, but it isn't released yet",
            "                # protocols=ALLOWED_SCHEMES,",
            "                strip=True,",
            "            )",
            "        )",
            "    )",
            "",
            "",
            "def safe_text(raw_text: str) -> jinja2.Markup:",
            "    \"\"\"",
            "    Process text: treat it as HTML but escape any tags (ie. just escape the",
            "    HTML) then linkify it.",
            "    \"\"\"",
            "    return jinja2.Markup(",
            "        bleach.linkify(bleach.clean(raw_text, tags=[], attributes={}, strip=False))",
            "    )",
            "",
            "",
            "def deduped_ordered_list(it: Iterable[T]) -> List[T]:",
            "    seen = set()",
            "    ret = []",
            "    for item in it:",
            "        if item not in seen:",
            "            seen.add(item)",
            "            ret.append(item)",
            "    return ret",
            "",
            "",
            "def string_ordinal_total(s: str) -> int:",
            "    tot = 0",
            "    for c in s:",
            "        tot += ord(c)",
            "    return tot"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2016 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import email.mime.multipart",
            "import email.utils",
            "import logging",
            "import urllib.parse",
            "from email.mime.multipart import MIMEMultipart",
            "from email.mime.text import MIMEText",
            "from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Optional, TypeVar",
            "",
            "import bleach",
            "import jinja2",
            "",
            "from synapse.api.constants import EventTypes, Membership",
            "from synapse.api.errors import StoreError",
            "from synapse.config.emailconfig import EmailSubjectConfig",
            "from synapse.events import EventBase",
            "from synapse.logging.context import make_deferred_yieldable",
            "from synapse.push.presentable_names import (",
            "    calculate_room_name,",
            "    descriptor_from_member_events,",
            "    name_from_member_event,",
            ")",
            "from synapse.types import StateMap, UserID",
            "from synapse.util.async_helpers import concurrently_execute",
            "from synapse.visibility import filter_events_for_client",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.app.homeserver import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "T = TypeVar(\"T\")",
            "",
            "",
            "CONTEXT_BEFORE = 1",
            "CONTEXT_AFTER = 1",
            "",
            "# From https://github.com/matrix-org/matrix-react-sdk/blob/master/src/HtmlUtils.js",
            "ALLOWED_TAGS = [",
            "    \"font\",  # custom to matrix for IRC-style font coloring",
            "    \"del\",  # for markdown",
            "    # deliberately no h1/h2 to stop people shouting.",
            "    \"h3\",",
            "    \"h4\",",
            "    \"h5\",",
            "    \"h6\",",
            "    \"blockquote\",",
            "    \"p\",",
            "    \"a\",",
            "    \"ul\",",
            "    \"ol\",",
            "    \"nl\",",
            "    \"li\",",
            "    \"b\",",
            "    \"i\",",
            "    \"u\",",
            "    \"strong\",",
            "    \"em\",",
            "    \"strike\",",
            "    \"code\",",
            "    \"hr\",",
            "    \"br\",",
            "    \"div\",",
            "    \"table\",",
            "    \"thead\",",
            "    \"caption\",",
            "    \"tbody\",",
            "    \"tr\",",
            "    \"th\",",
            "    \"td\",",
            "    \"pre\",",
            "]",
            "ALLOWED_ATTRS = {",
            "    # custom ones first:",
            "    \"font\": [\"color\"],  # custom to matrix",
            "    \"a\": [\"href\", \"name\", \"target\"],  # remote target: custom to matrix",
            "    # We don't currently allow img itself by default, but this",
            "    # would make sense if we did",
            "    \"img\": [\"src\"],",
            "}",
            "# When bleach release a version with this option, we can specify schemes",
            "# ALLOWED_SCHEMES = [\"http\", \"https\", \"ftp\", \"mailto\"]",
            "",
            "",
            "class Mailer:",
            "    def __init__(",
            "        self,",
            "        hs: \"HomeServer\",",
            "        app_name: str,",
            "        template_html: jinja2.Template,",
            "        template_text: jinja2.Template,",
            "    ):",
            "        self.hs = hs",
            "        self.template_html = template_html",
            "        self.template_text = template_text",
            "",
            "        self.sendmail = self.hs.get_sendmail()",
            "        self.store = self.hs.get_datastore()",
            "        self.macaroon_gen = self.hs.get_macaroon_generator()",
            "        self.state_handler = self.hs.get_state_handler()",
            "        self.storage = hs.get_storage()",
            "        self.app_name = app_name",
            "        self.email_subjects = hs.config.email_subjects  # type: EmailSubjectConfig",
            "",
            "        logger.info(\"Created Mailer for app_name %s\" % app_name)",
            "",
            "    async def send_password_reset_mail(",
            "        self, email_address: str, token: str, client_secret: str, sid: str",
            "    ) -> None:",
            "        \"\"\"Send an email with a password reset link to a user",
            "",
            "        Args:",
            "            email_address: Email address we're sending the password",
            "                reset to",
            "            token: Unique token generated by the server to verify",
            "                the email was received",
            "            client_secret: Unique token generated by the client to",
            "                group together multiple email sending attempts",
            "            sid: The generated session ID",
            "        \"\"\"",
            "        params = {\"token\": token, \"client_secret\": client_secret, \"sid\": sid}",
            "        link = (",
            "            self.hs.config.public_baseurl",
            "            + \"_synapse/client/password_reset/email/submit_token?%s\"",
            "            % urllib.parse.urlencode(params)",
            "        )",
            "",
            "        template_vars = {\"link\": link}",
            "",
            "        await self.send_email(",
            "            email_address,",
            "            self.email_subjects.password_reset",
            "            % {\"server_name\": self.hs.config.server_name},",
            "            template_vars,",
            "        )",
            "",
            "    async def send_registration_mail(",
            "        self, email_address: str, token: str, client_secret: str, sid: str",
            "    ) -> None:",
            "        \"\"\"Send an email with a registration confirmation link to a user",
            "",
            "        Args:",
            "            email_address: Email address we're sending the registration",
            "                link to",
            "            token: Unique token generated by the server to verify",
            "                the email was received",
            "            client_secret: Unique token generated by the client to",
            "                group together multiple email sending attempts",
            "            sid: The generated session ID",
            "        \"\"\"",
            "        params = {\"token\": token, \"client_secret\": client_secret, \"sid\": sid}",
            "        link = (",
            "            self.hs.config.public_baseurl",
            "            + \"_matrix/client/unstable/registration/email/submit_token?%s\"",
            "            % urllib.parse.urlencode(params)",
            "        )",
            "",
            "        template_vars = {\"link\": link}",
            "",
            "        await self.send_email(",
            "            email_address,",
            "            self.email_subjects.email_validation",
            "            % {\"server_name\": self.hs.config.server_name},",
            "            template_vars,",
            "        )",
            "",
            "    async def send_add_threepid_mail(",
            "        self, email_address: str, token: str, client_secret: str, sid: str",
            "    ) -> None:",
            "        \"\"\"Send an email with a validation link to a user for adding a 3pid to their account",
            "",
            "        Args:",
            "            email_address: Email address we're sending the validation link to",
            "",
            "            token: Unique token generated by the server to verify the email was received",
            "",
            "            client_secret: Unique token generated by the client to group together",
            "                multiple email sending attempts",
            "",
            "            sid: The generated session ID",
            "        \"\"\"",
            "        params = {\"token\": token, \"client_secret\": client_secret, \"sid\": sid}",
            "        link = (",
            "            self.hs.config.public_baseurl",
            "            + \"_matrix/client/unstable/add_threepid/email/submit_token?%s\"",
            "            % urllib.parse.urlencode(params)",
            "        )",
            "",
            "        template_vars = {\"link\": link}",
            "",
            "        await self.send_email(",
            "            email_address,",
            "            self.email_subjects.email_validation",
            "            % {\"server_name\": self.hs.config.server_name},",
            "            template_vars,",
            "        )",
            "",
            "    async def send_notification_mail(",
            "        self,",
            "        app_id: str,",
            "        user_id: str,",
            "        email_address: str,",
            "        push_actions: Iterable[Dict[str, Any]],",
            "        reason: Dict[str, Any],",
            "    ) -> None:",
            "        \"\"\"Send email regarding a user's room notifications\"\"\"",
            "        rooms_in_order = deduped_ordered_list([pa[\"room_id\"] for pa in push_actions])",
            "",
            "        notif_events = await self.store.get_events(",
            "            [pa[\"event_id\"] for pa in push_actions]",
            "        )",
            "",
            "        notifs_by_room = {}  # type: Dict[str, List[Dict[str, Any]]]",
            "        for pa in push_actions:",
            "            notifs_by_room.setdefault(pa[\"room_id\"], []).append(pa)",
            "",
            "        # collect the current state for all the rooms in which we have",
            "        # notifications",
            "        state_by_room = {}",
            "",
            "        try:",
            "            user_display_name = await self.store.get_profile_displayname(",
            "                UserID.from_string(user_id).localpart",
            "            )",
            "            if user_display_name is None:",
            "                user_display_name = user_id",
            "        except StoreError:",
            "            user_display_name = user_id",
            "",
            "        async def _fetch_room_state(room_id):",
            "            room_state = await self.store.get_current_state_ids(room_id)",
            "            state_by_room[room_id] = room_state",
            "",
            "        # Run at most 3 of these at once: sync does 10 at a time but email",
            "        # notifs are much less realtime than sync so we can afford to wait a bit.",
            "        await concurrently_execute(_fetch_room_state, rooms_in_order, 3)",
            "",
            "        # actually sort our so-called rooms_in_order list, most recent room first",
            "        rooms_in_order.sort(key=lambda r: -(notifs_by_room[r][-1][\"received_ts\"] or 0))",
            "",
            "        rooms = []",
            "",
            "        for r in rooms_in_order:",
            "            roomvars = await self.get_room_vars(",
            "                r, user_id, notifs_by_room[r], notif_events, state_by_room[r]",
            "            )",
            "            rooms.append(roomvars)",
            "",
            "        reason[\"room_name\"] = await calculate_room_name(",
            "            self.store,",
            "            state_by_room[reason[\"room_id\"]],",
            "            user_id,",
            "            fallback_to_members=True,",
            "        )",
            "",
            "        summary_text = await self.make_summary_text(",
            "            notifs_by_room, state_by_room, notif_events, user_id, reason",
            "        )",
            "",
            "        template_vars = {",
            "            \"user_display_name\": user_display_name,",
            "            \"unsubscribe_link\": self.make_unsubscribe_link(",
            "                user_id, app_id, email_address",
            "            ),",
            "            \"summary_text\": summary_text,",
            "            \"rooms\": rooms,",
            "            \"reason\": reason,",
            "        }",
            "",
            "        await self.send_email(email_address, summary_text, template_vars)",
            "",
            "    async def send_email(",
            "        self, email_address: str, subject: str, extra_template_vars: Dict[str, Any]",
            "    ) -> None:",
            "        \"\"\"Send an email with the given information and template text\"\"\"",
            "        try:",
            "            from_string = self.hs.config.email_notif_from % {\"app\": self.app_name}",
            "        except TypeError:",
            "            from_string = self.hs.config.email_notif_from",
            "",
            "        raw_from = email.utils.parseaddr(from_string)[1]",
            "        raw_to = email.utils.parseaddr(email_address)[1]",
            "",
            "        if raw_to == \"\":",
            "            raise RuntimeError(\"Invalid 'to' address\")",
            "",
            "        template_vars = {",
            "            \"app_name\": self.app_name,",
            "            \"server_name\": self.hs.config.server.server_name,",
            "        }",
            "",
            "        template_vars.update(extra_template_vars)",
            "",
            "        html_text = self.template_html.render(**template_vars)",
            "        html_part = MIMEText(html_text, \"html\", \"utf8\")",
            "",
            "        plain_text = self.template_text.render(**template_vars)",
            "        text_part = MIMEText(plain_text, \"plain\", \"utf8\")",
            "",
            "        multipart_msg = MIMEMultipart(\"alternative\")",
            "        multipart_msg[\"Subject\"] = subject",
            "        multipart_msg[\"From\"] = from_string",
            "        multipart_msg[\"To\"] = email_address",
            "        multipart_msg[\"Date\"] = email.utils.formatdate()",
            "        multipart_msg[\"Message-ID\"] = email.utils.make_msgid()",
            "        multipart_msg.attach(text_part)",
            "        multipart_msg.attach(html_part)",
            "",
            "        logger.info(\"Sending email to %s\" % email_address)",
            "",
            "        await make_deferred_yieldable(",
            "            self.sendmail(",
            "                self.hs.config.email_smtp_host,",
            "                raw_from,",
            "                raw_to,",
            "                multipart_msg.as_string().encode(\"utf8\"),",
            "                reactor=self.hs.get_reactor(),",
            "                port=self.hs.config.email_smtp_port,",
            "                requireAuthentication=self.hs.config.email_smtp_user is not None,",
            "                username=self.hs.config.email_smtp_user,",
            "                password=self.hs.config.email_smtp_pass,",
            "                requireTransportSecurity=self.hs.config.require_transport_security,",
            "            )",
            "        )",
            "",
            "    async def get_room_vars(",
            "        self,",
            "        room_id: str,",
            "        user_id: str,",
            "        notifs: Iterable[Dict[str, Any]],",
            "        notif_events: Dict[str, EventBase],",
            "        room_state_ids: StateMap[str],",
            "    ) -> Dict[str, Any]:",
            "        # Check if one of the notifs is an invite event for the user.",
            "        is_invite = False",
            "        for n in notifs:",
            "            ev = notif_events[n[\"event_id\"]]",
            "            if ev.type == EventTypes.Member and ev.state_key == user_id:",
            "                if ev.content.get(\"membership\") == Membership.INVITE:",
            "                    is_invite = True",
            "                    break",
            "",
            "        room_name = await calculate_room_name(self.store, room_state_ids, user_id)",
            "",
            "        room_vars = {",
            "            \"title\": room_name,",
            "            \"hash\": string_ordinal_total(room_id),  # See sender avatar hash",
            "            \"notifs\": [],",
            "            \"invite\": is_invite,",
            "            \"link\": self.make_room_link(room_id),",
            "        }  # type: Dict[str, Any]",
            "",
            "        if not is_invite:",
            "            for n in notifs:",
            "                notifvars = await self.get_notif_vars(",
            "                    n, user_id, notif_events[n[\"event_id\"]], room_state_ids",
            "                )",
            "",
            "                # merge overlapping notifs together.",
            "                # relies on the notifs being in chronological order.",
            "                merge = False",
            "                if room_vars[\"notifs\"] and \"messages\" in room_vars[\"notifs\"][-1]:",
            "                    prev_messages = room_vars[\"notifs\"][-1][\"messages\"]",
            "                    for message in notifvars[\"messages\"]:",
            "                        pm = list(",
            "                            filter(lambda pm: pm[\"id\"] == message[\"id\"], prev_messages)",
            "                        )",
            "                        if pm:",
            "                            if not message[\"is_historical\"]:",
            "                                pm[0][\"is_historical\"] = False",
            "                            merge = True",
            "                        elif merge:",
            "                            # we're merging, so append any remaining messages",
            "                            # in this notif to the previous one",
            "                            prev_messages.append(message)",
            "",
            "                if not merge:",
            "                    room_vars[\"notifs\"].append(notifvars)",
            "",
            "        return room_vars",
            "",
            "    async def get_notif_vars(",
            "        self,",
            "        notif: Dict[str, Any],",
            "        user_id: str,",
            "        notif_event: EventBase,",
            "        room_state_ids: StateMap[str],",
            "    ) -> Dict[str, Any]:",
            "        results = await self.store.get_events_around(",
            "            notif[\"room_id\"],",
            "            notif[\"event_id\"],",
            "            before_limit=CONTEXT_BEFORE,",
            "            after_limit=CONTEXT_AFTER,",
            "        )",
            "",
            "        ret = {",
            "            \"link\": self.make_notif_link(notif),",
            "            \"ts\": notif[\"received_ts\"],",
            "            \"messages\": [],",
            "        }",
            "",
            "        the_events = await filter_events_for_client(",
            "            self.storage, user_id, results[\"events_before\"]",
            "        )",
            "        the_events.append(notif_event)",
            "",
            "        for event in the_events:",
            "            messagevars = await self.get_message_vars(notif, event, room_state_ids)",
            "            if messagevars is not None:",
            "                ret[\"messages\"].append(messagevars)",
            "",
            "        return ret",
            "",
            "    async def get_message_vars(",
            "        self, notif: Dict[str, Any], event: EventBase, room_state_ids: StateMap[str]",
            "    ) -> Optional[Dict[str, Any]]:",
            "        if event.type != EventTypes.Message and event.type != EventTypes.Encrypted:",
            "            return None",
            "",
            "        sender_state_event_id = room_state_ids[(\"m.room.member\", event.sender)]",
            "        sender_state_event = await self.store.get_event(sender_state_event_id)",
            "        sender_name = name_from_member_event(sender_state_event)",
            "        sender_avatar_url = sender_state_event.content.get(\"avatar_url\")",
            "",
            "        # 'hash' for deterministically picking default images: use",
            "        # sender_hash % the number of default images to choose from",
            "        sender_hash = string_ordinal_total(event.sender)",
            "",
            "        ret = {",
            "            \"event_type\": event.type,",
            "            \"is_historical\": event.event_id != notif[\"event_id\"],",
            "            \"id\": event.event_id,",
            "            \"ts\": event.origin_server_ts,",
            "            \"sender_name\": sender_name,",
            "            \"sender_avatar_url\": sender_avatar_url,",
            "            \"sender_hash\": sender_hash,",
            "        }",
            "",
            "        # Encrypted messages don't have any additional useful information.",
            "        if event.type == EventTypes.Encrypted:",
            "            return ret",
            "",
            "        msgtype = event.content.get(\"msgtype\")",
            "",
            "        ret[\"msgtype\"] = msgtype",
            "",
            "        if msgtype == \"m.text\":",
            "            self.add_text_message_vars(ret, event)",
            "        elif msgtype == \"m.image\":",
            "            self.add_image_message_vars(ret, event)",
            "",
            "        if \"body\" in event.content:",
            "            ret[\"body_text_plain\"] = event.content[\"body\"]",
            "",
            "        return ret",
            "",
            "    def add_text_message_vars(",
            "        self, messagevars: Dict[str, Any], event: EventBase",
            "    ) -> None:",
            "        msgformat = event.content.get(\"format\")",
            "",
            "        messagevars[\"format\"] = msgformat",
            "",
            "        formatted_body = event.content.get(\"formatted_body\")",
            "        body = event.content.get(\"body\")",
            "",
            "        if msgformat == \"org.matrix.custom.html\" and formatted_body:",
            "            messagevars[\"body_text_html\"] = safe_markup(formatted_body)",
            "        elif body:",
            "            messagevars[\"body_text_html\"] = safe_text(body)",
            "",
            "    def add_image_message_vars(",
            "        self, messagevars: Dict[str, Any], event: EventBase",
            "    ) -> None:",
            "        \"\"\"",
            "        Potentially add an image URL to the message variables.",
            "        \"\"\"",
            "        if \"url\" in event.content:",
            "            messagevars[\"image_url\"] = event.content[\"url\"]",
            "",
            "    async def make_summary_text(",
            "        self,",
            "        notifs_by_room: Dict[str, List[Dict[str, Any]]],",
            "        room_state_ids: Dict[str, StateMap[str]],",
            "        notif_events: Dict[str, EventBase],",
            "        user_id: str,",
            "        reason: Dict[str, Any],",
            "    ):",
            "        if len(notifs_by_room) == 1:",
            "            # Only one room has new stuff",
            "            room_id = list(notifs_by_room.keys())[0]",
            "",
            "            # If the room has some kind of name, use it, but we don't",
            "            # want the generated-from-names one here otherwise we'll",
            "            # end up with, \"new message from Bob in the Bob room\"",
            "            room_name = await calculate_room_name(",
            "                self.store, room_state_ids[room_id], user_id, fallback_to_members=False",
            "            )",
            "",
            "            # See if one of the notifs is an invite event for the user",
            "            invite_event = None",
            "            for n in notifs_by_room[room_id]:",
            "                ev = notif_events[n[\"event_id\"]]",
            "                if ev.type == EventTypes.Member and ev.state_key == user_id:",
            "                    if ev.content.get(\"membership\") == Membership.INVITE:",
            "                        invite_event = ev",
            "                        break",
            "",
            "            if invite_event:",
            "                inviter_member_event_id = room_state_ids[room_id].get(",
            "                    (\"m.room.member\", invite_event.sender)",
            "                )",
            "                inviter_name = invite_event.sender",
            "                if inviter_member_event_id:",
            "                    inviter_member_event = await self.store.get_event(",
            "                        inviter_member_event_id, allow_none=True",
            "                    )",
            "                    if inviter_member_event:",
            "                        inviter_name = name_from_member_event(inviter_member_event)",
            "",
            "                if room_name is None:",
            "                    return self.email_subjects.invite_from_person % {",
            "                        \"person\": inviter_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "                else:",
            "                    return self.email_subjects.invite_from_person_to_room % {",
            "                        \"person\": inviter_name,",
            "                        \"room\": room_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "",
            "            sender_name = None",
            "            if len(notifs_by_room[room_id]) == 1:",
            "                # There is just the one notification, so give some detail",
            "                event = notif_events[notifs_by_room[room_id][0][\"event_id\"]]",
            "                if (\"m.room.member\", event.sender) in room_state_ids[room_id]:",
            "                    state_event_id = room_state_ids[room_id][",
            "                        (\"m.room.member\", event.sender)",
            "                    ]",
            "                    state_event = await self.store.get_event(state_event_id)",
            "                    sender_name = name_from_member_event(state_event)",
            "",
            "                if sender_name is not None and room_name is not None:",
            "                    return self.email_subjects.message_from_person_in_room % {",
            "                        \"person\": sender_name,",
            "                        \"room\": room_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "                elif sender_name is not None:",
            "                    return self.email_subjects.message_from_person % {",
            "                        \"person\": sender_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "            else:",
            "                # There's more than one notification for this room, so just",
            "                # say there are several",
            "                if room_name is not None:",
            "                    return self.email_subjects.messages_in_room % {",
            "                        \"room\": room_name,",
            "                        \"app\": self.app_name,",
            "                    }",
            "                else:",
            "                    # If the room doesn't have a name, say who the messages",
            "                    # are from explicitly to avoid, \"messages in the Bob room\"",
            "                    sender_ids = list(",
            "                        {",
            "                            notif_events[n[\"event_id\"]].sender",
            "                            for n in notifs_by_room[room_id]",
            "                        }",
            "                    )",
            "",
            "                    member_events = await self.store.get_events(",
            "                        [",
            "                            room_state_ids[room_id][(\"m.room.member\", s)]",
            "                            for s in sender_ids",
            "                        ]",
            "                    )",
            "",
            "                    return self.email_subjects.messages_from_person % {",
            "                        \"person\": descriptor_from_member_events(member_events.values()),",
            "                        \"app\": self.app_name,",
            "                    }",
            "        else:",
            "            # Stuff's happened in multiple different rooms",
            "",
            "            # ...but we still refer to the 'reason' room which triggered the mail",
            "            if reason[\"room_name\"] is not None:",
            "                return self.email_subjects.messages_in_room_and_others % {",
            "                    \"room\": reason[\"room_name\"],",
            "                    \"app\": self.app_name,",
            "                }",
            "            else:",
            "                # If the reason room doesn't have a name, say who the messages",
            "                # are from explicitly to avoid, \"messages in the Bob room\"",
            "                room_id = reason[\"room_id\"]",
            "",
            "                sender_ids = list(",
            "                    {",
            "                        notif_events[n[\"event_id\"]].sender",
            "                        for n in notifs_by_room[room_id]",
            "                    }",
            "                )",
            "",
            "                member_events = await self.store.get_events(",
            "                    [room_state_ids[room_id][(\"m.room.member\", s)] for s in sender_ids]",
            "                )",
            "",
            "                return self.email_subjects.messages_from_person_and_others % {",
            "                    \"person\": descriptor_from_member_events(member_events.values()),",
            "                    \"app\": self.app_name,",
            "                }",
            "",
            "    def make_room_link(self, room_id: str) -> str:",
            "        if self.hs.config.email_riot_base_url:",
            "            base_url = \"%s/#/room\" % (self.hs.config.email_riot_base_url)",
            "        elif self.app_name == \"Vector\":",
            "            # need /beta for Universal Links to work on iOS",
            "            base_url = \"https://vector.im/beta/#/room\"",
            "        else:",
            "            base_url = \"https://matrix.to/#\"",
            "        return \"%s/%s\" % (base_url, room_id)",
            "",
            "    def make_notif_link(self, notif: Dict[str, str]) -> str:",
            "        if self.hs.config.email_riot_base_url:",
            "            return \"%s/#/room/%s/%s\" % (",
            "                self.hs.config.email_riot_base_url,",
            "                notif[\"room_id\"],",
            "                notif[\"event_id\"],",
            "            )",
            "        elif self.app_name == \"Vector\":",
            "            # need /beta for Universal Links to work on iOS",
            "            return \"https://vector.im/beta/#/room/%s/%s\" % (",
            "                notif[\"room_id\"],",
            "                notif[\"event_id\"],",
            "            )",
            "        else:",
            "            return \"https://matrix.to/#/%s/%s\" % (notif[\"room_id\"], notif[\"event_id\"])",
            "",
            "    def make_unsubscribe_link(",
            "        self, user_id: str, app_id: str, email_address: str",
            "    ) -> str:",
            "        params = {",
            "            \"access_token\": self.macaroon_gen.generate_delete_pusher_token(user_id),",
            "            \"app_id\": app_id,",
            "            \"pushkey\": email_address,",
            "        }",
            "",
            "        # XXX: make r0 once API is stable",
            "        return \"%s_matrix/client/unstable/pushers/remove?%s\" % (",
            "            self.hs.config.public_baseurl,",
            "            urllib.parse.urlencode(params),",
            "        )",
            "",
            "",
            "def safe_markup(raw_html: str) -> jinja2.Markup:",
            "    \"\"\"",
            "    Sanitise a raw HTML string to a set of allowed tags and attributes, and linkify any bare URLs.",
            "",
            "    Args",
            "        raw_html: Unsafe HTML.",
            "",
            "    Returns:",
            "        A Markup object ready to safely use in a Jinja template.",
            "    \"\"\"",
            "    return jinja2.Markup(",
            "        bleach.linkify(",
            "            bleach.clean(",
            "                raw_html,",
            "                tags=ALLOWED_TAGS,",
            "                attributes=ALLOWED_ATTRS,",
            "                # bleach master has this, but it isn't released yet",
            "                # protocols=ALLOWED_SCHEMES,",
            "                strip=True,",
            "            )",
            "        )",
            "    )",
            "",
            "",
            "def safe_text(raw_text: str) -> jinja2.Markup:",
            "    \"\"\"",
            "    Sanitise text (escape any HTML tags), and then linkify any bare URLs.",
            "",
            "    Args",
            "        raw_text: Unsafe text which might include HTML markup.",
            "",
            "    Returns:",
            "        A Markup object ready to safely use in a Jinja template.",
            "    \"\"\"",
            "    return jinja2.Markup(",
            "        bleach.linkify(bleach.clean(raw_text, tags=[], attributes={}, strip=False))",
            "    )",
            "",
            "",
            "def deduped_ordered_list(it: Iterable[T]) -> List[T]:",
            "    seen = set()",
            "    ret = []",
            "    for item in it:",
            "        if item not in seen:",
            "            seen.add(item)",
            "            ret.append(item)",
            "    return ret",
            "",
            "",
            "def string_ordinal_total(s: str) -> int:",
            "    tot = 0",
            "    for c in s:",
            "        tot += ord(c)",
            "    return tot"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "687": [
                "safe_text"
            ],
            "688": [
                "safe_text"
            ]
        },
        "addLocation": [
            "synapse.push.mailer.Mailer.add_text_message_vars",
            "rdiffweb.controller.page_pref_sshkeys.ApiSshKeys.post"
        ]
    }
}