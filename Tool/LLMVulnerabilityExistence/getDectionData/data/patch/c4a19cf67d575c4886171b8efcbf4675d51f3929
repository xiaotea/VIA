{
    "rdiffweb/core/model/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import cherrypy"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sqlalchemy import event"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from sqlalchemy import event, func"
            },
            "5": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from sqlalchemy.exc import IntegrityError"
            },
            "6": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from ._repo import RepoObject  # noqa"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from ._session import DbSession, SessionObject  # noqa"
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ._sshkey import SshKey  # noqa"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+from ._sshkey import SshKey, sshkey_fingerprint_index  # noqa"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from ._token import Token  # noqa"
            },
            "12": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from ._user import DuplicateSSHKeyError, UserObject, user_username_index  # noqa"
            },
            "13": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "             logger.error(msg)"
            },
            "15": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             print(msg, file=sys.stderr)"
            },
            "16": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "             raise SystemExit(12)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    # Fix SSH Key uniqueness - since 2.5.4"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    if not _index_exists(connection, 'sshkey_fingerprint_index'):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        duplicate_sshkeys = ("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            SshKey.query.with_entities(SshKey.fingerprint)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            .group_by(SshKey.fingerprint)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            .having(func.count(SshKey.fingerprint) > 1)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        ).all()"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        try:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            sshkey_fingerprint_index.create()"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        except IntegrityError:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            msg = ("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                'Failure to upgrade your database to make SSH Keys unique. '"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                'You must downgrade and deleted duplicate SSH Keys. '"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                '%s' % '\\n'.join([str(k) for k in duplicate_sshkeys]),"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            )"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            logger.error(msg)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+            print(msg, file=sys.stderr)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            raise SystemExit(12)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "import sys",
            "",
            "import cherrypy",
            "from sqlalchemy import event",
            "from sqlalchemy.exc import IntegrityError",
            "",
            "from ._repo import RepoObject  # noqa",
            "from ._session import DbSession, SessionObject  # noqa",
            "from ._sshkey import SshKey  # noqa",
            "from ._token import Token  # noqa",
            "from ._user import DuplicateSSHKeyError, UserObject, user_username_index  # noqa",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _column_add(connection, column):",
            "    if _column_exists(connection, column):",
            "        return",
            "    table_name = column.table.fullname",
            "    column_name = column.name",
            "    column_type = column.type.compile(connection.engine.dialect)",
            "    connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))",
            "",
            "",
            "def _column_exists(connection, column):",
            "    table_name = column.table.fullname",
            "    column_name = column.name",
            "    if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "        sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % (",
            "            table_name,",
            "            column_name,",
            "        )",
            "    else:",
            "        sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % (",
            "            table_name,",
            "            column_name,",
            "        )",
            "    data = connection.engine.execute(sql).first()",
            "    return data[0] >= 1",
            "",
            "",
            "def _index_exists(connection, index_name):",
            "    if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "        sql = \"SELECT name FROM sqlite_master WHERE type = 'index' AND name = '%s';\" % (index_name)",
            "    else:",
            "        sql = \"SELECT * FROM pg_indexes WHERE indexname = '%s'\" % (index_name)",
            "    return connection.engine.execute(sql).first() is not None",
            "",
            "",
            "@event.listens_for(Base.metadata, 'after_create')",
            "def db_after_create(target, connection, **kw):",
            "    \"\"\"",
            "    Called on database creation to update database schema.",
            "    \"\"\"",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Add repo's Encoding",
            "    _column_add(connection, RepoObject.__table__.c.Encoding)",
            "    _column_add(connection, RepoObject.__table__.c.keepdays)",
            "",
            "    # Create column for roles using \"isadmin\" column. Keep the",
            "    # original column in case we need to revert to previous version.",
            "    if not _column_exists(connection, UserObject.__table__.c.role):",
            "        _column_add(connection, UserObject.__table__.c.role)",
            "        UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})",
            "",
            "    # Add user's fullname column",
            "    _column_add(connection, UserObject.__table__.c.fullname)",
            "",
            "    # Add user's mfa column",
            "    _column_add(connection, UserObject.__table__.c.mfa)",
            "",
            "    # Re-create session table if Number column is missing",
            "    if not _column_exists(connection, SessionObject.__table__.c.Number):",
            "        SessionObject.__table__.drop()",
            "        SessionObject.__table__.create()",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Remove preceding and leading slash (/) generated by previous",
            "    # versions. Also rename '.' to ''",
            "    result = RepoObject.query.all()",
            "    for row in result:",
            "        if row.repopath.startswith('/') or row.repopath.endswith('/'):",
            "            row.repopath = row.repopath.strip('/')",
            "            row.commit()",
            "        if row.repopath == '.':",
            "            row.repopath = ''",
            "            row.commit()",
            "    # Remove duplicates and nested repositories.",
            "    result = RepoObject.query.order_by(RepoObject.userid, RepoObject.repopath).all()",
            "    prev_repo = (None, None)",
            "    for row in result:",
            "        if prev_repo[0] == row.userid and (prev_repo[1] == row.repopath or row.repopath.startswith(prev_repo[1] + '/')):",
            "            row.delete()",
            "        else:",
            "            prev_repo = (row.userid, row.repopath)",
            "",
            "    # Fix username case insensitive unique",
            "    if not _index_exists(connection, 'user_username_index'):",
            "        duplicate_users = (",
            "            UserObject.query.with_entities(func.lower(UserObject.username))",
            "            .group_by(func.lower(UserObject.username))",
            "            .having(func.count(UserObject.username) > 1)",
            "        ).all()",
            "        try:",
            "            user_username_index.create()",
            "        except IntegrityError:",
            "            msg = (",
            "                'Failure to upgrade your database to make Username case insensitive. '",
            "                'You must downgrade and deleted duplicate Username. '",
            "                '%s' % '\\n'.join([str(k) for k in duplicate_users]),",
            "            )",
            "            logger.error(msg)",
            "            print(msg, file=sys.stderr)",
            "            raise SystemExit(12)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import logging",
            "import sys",
            "",
            "import cherrypy",
            "from sqlalchemy import event, func",
            "from sqlalchemy.exc import IntegrityError",
            "",
            "from ._repo import RepoObject  # noqa",
            "from ._session import DbSession, SessionObject  # noqa",
            "from ._sshkey import SshKey, sshkey_fingerprint_index  # noqa",
            "from ._token import Token  # noqa",
            "from ._user import DuplicateSSHKeyError, UserObject, user_username_index  # noqa",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _column_add(connection, column):",
            "    if _column_exists(connection, column):",
            "        return",
            "    table_name = column.table.fullname",
            "    column_name = column.name",
            "    column_type = column.type.compile(connection.engine.dialect)",
            "    connection.engine.execute('ALTER TABLE %s ADD COLUMN %s %s' % (table_name, column_name, column_type))",
            "",
            "",
            "def _column_exists(connection, column):",
            "    table_name = column.table.fullname",
            "    column_name = column.name",
            "    if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "        sql = \"SELECT COUNT(*) FROM pragma_table_info('%s') WHERE LOWER(name)=LOWER('%s')\" % (",
            "            table_name,",
            "            column_name,",
            "        )",
            "    else:",
            "        sql = \"SELECT COUNT(*) FROM information_schema.columns WHERE table_name='%s' and column_name='%s'\" % (",
            "            table_name,",
            "            column_name,",
            "        )",
            "    data = connection.engine.execute(sql).first()",
            "    return data[0] >= 1",
            "",
            "",
            "def _index_exists(connection, index_name):",
            "    if 'SQLite' in connection.engine.dialect.__class__.__name__:",
            "        sql = \"SELECT name FROM sqlite_master WHERE type = 'index' AND name = '%s';\" % (index_name)",
            "    else:",
            "        sql = \"SELECT * FROM pg_indexes WHERE indexname = '%s'\" % (index_name)",
            "    return connection.engine.execute(sql).first() is not None",
            "",
            "",
            "@event.listens_for(Base.metadata, 'after_create')",
            "def db_after_create(target, connection, **kw):",
            "    \"\"\"",
            "    Called on database creation to update database schema.",
            "    \"\"\"",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Add repo's Encoding",
            "    _column_add(connection, RepoObject.__table__.c.Encoding)",
            "    _column_add(connection, RepoObject.__table__.c.keepdays)",
            "",
            "    # Create column for roles using \"isadmin\" column. Keep the",
            "    # original column in case we need to revert to previous version.",
            "    if not _column_exists(connection, UserObject.__table__.c.role):",
            "        _column_add(connection, UserObject.__table__.c.role)",
            "        UserObject.query.filter(UserObject._is_admin == 1).update({UserObject.role: UserObject.ADMIN_ROLE})",
            "",
            "    # Add user's fullname column",
            "    _column_add(connection, UserObject.__table__.c.fullname)",
            "",
            "    # Add user's mfa column",
            "    _column_add(connection, UserObject.__table__.c.mfa)",
            "",
            "    # Re-create session table if Number column is missing",
            "    if not _column_exists(connection, SessionObject.__table__.c.Number):",
            "        SessionObject.__table__.drop()",
            "        SessionObject.__table__.create()",
            "",
            "    if getattr(connection, '_transaction', None):",
            "        connection._transaction.commit()",
            "",
            "    # Remove preceding and leading slash (/) generated by previous",
            "    # versions. Also rename '.' to ''",
            "    result = RepoObject.query.all()",
            "    for row in result:",
            "        if row.repopath.startswith('/') or row.repopath.endswith('/'):",
            "            row.repopath = row.repopath.strip('/')",
            "            row.commit()",
            "        if row.repopath == '.':",
            "            row.repopath = ''",
            "            row.commit()",
            "    # Remove duplicates and nested repositories.",
            "    result = RepoObject.query.order_by(RepoObject.userid, RepoObject.repopath).all()",
            "    prev_repo = (None, None)",
            "    for row in result:",
            "        if prev_repo[0] == row.userid and (prev_repo[1] == row.repopath or row.repopath.startswith(prev_repo[1] + '/')):",
            "            row.delete()",
            "        else:",
            "            prev_repo = (row.userid, row.repopath)",
            "",
            "    # Fix username case insensitive unique",
            "    if not _index_exists(connection, 'user_username_index'):",
            "        duplicate_users = (",
            "            UserObject.query.with_entities(func.lower(UserObject.username))",
            "            .group_by(func.lower(UserObject.username))",
            "            .having(func.count(UserObject.username) > 1)",
            "        ).all()",
            "        try:",
            "            user_username_index.create()",
            "        except IntegrityError:",
            "            msg = (",
            "                'Failure to upgrade your database to make Username case insensitive. '",
            "                'You must downgrade and deleted duplicate Username. '",
            "                '%s' % '\\n'.join([str(k) for k in duplicate_users]),",
            "            )",
            "            logger.error(msg)",
            "            print(msg, file=sys.stderr)",
            "            raise SystemExit(12)",
            "",
            "    # Fix SSH Key uniqueness - since 2.5.4",
            "    if not _index_exists(connection, 'sshkey_fingerprint_index'):",
            "        duplicate_sshkeys = (",
            "            SshKey.query.with_entities(SshKey.fingerprint)",
            "            .group_by(SshKey.fingerprint)",
            "            .having(func.count(SshKey.fingerprint) > 1)",
            "        ).all()",
            "        try:",
            "            sshkey_fingerprint_index.create()",
            "        except IntegrityError:",
            "            msg = (",
            "                'Failure to upgrade your database to make SSH Keys unique. '",
            "                'You must downgrade and deleted duplicate SSH Keys. '",
            "                '%s' % '\\n'.join([str(k) for k in duplicate_sshkeys]),",
            "            )",
            "            logger.error(msg)",
            "            print(msg, file=sys.stderr)",
            "            raise SystemExit(12)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "22": [],
            "27": []
        },
        "addLocation": []
    },
    "rdiffweb/core/model/_sshkey.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " # along with this program.  If not, see <http://www.gnu.org/licenses/>."
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import cherrypy"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sqlalchemy import Column, Integer, Text"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from sqlalchemy import Column, Index, Integer, Text"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " Base = cherrypy.tools.db.get_base()"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     fingerprint = Column('Fingerprint', Text)"
            },
            "9": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     key = Column('Key', Text, unique=True, primary_key=True)"
            },
            "10": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     userid = Column('UserID', Integer, nullable=False)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+# Make finger print unique"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+sshkey_fingerprint_index = Index('sshkey_fingerprint_index', SshKey.fingerprint, unique=True)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Integer, Text",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "",
            "class SshKey(Base):",
            "    __tablename__ = 'sshkeys'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "    fingerprint = Column('Fingerprint', Text)",
            "    key = Column('Key', Text, unique=True, primary_key=True)",
            "    userid = Column('UserID', Integer, nullable=False)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Index, Integer, Text",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "",
            "class SshKey(Base):",
            "    __tablename__ = 'sshkeys'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "    fingerprint = Column('Fingerprint', Text)",
            "    key = Column('Key', Text, unique=True, primary_key=True)",
            "    userid = Column('UserID', Integer, nullable=False)",
            "",
            "",
            "# Make finger print unique",
            "sshkey_fingerprint_index = Index('sshkey_fingerprint_index', SshKey.fingerprint, unique=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "19": []
        },
        "addLocation": []
    },
    "rdiffweb/core/model/_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         assert key"
            },
            "1": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         key = authorizedkeys.check_publickey(key)"
            },
            "2": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 161,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Remove option, replace comments."
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        # Remove option & Remove comment for SQL storage"
            },
            "5": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         key = authorizedkeys.AuthorizedKey("
            },
            "6": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "             options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment"
            },
            "7": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         )"
            },
            "8": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "             # Also look in database."
            },
            "9": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "             logger.info(\"add key [%s] to [%s] database\", key, self.username)"
            },
            "10": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "             try:"
            },
            "11": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+                sshkey = SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue())"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+                sshkey.add().flush()"
            },
            "14": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             except IntegrityError:"
            },
            "15": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "                 raise DuplicateSSHKeyError("
            },
            "16": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "                     _(\"Duplicate key. This key already exists or is associated to another user.\")"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import logging",
            "import os",
            "import secrets",
            "import string",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Index, Integer, SmallInteger, String, and_, event, func, inspect, or_",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "from sqlalchemy.orm import deferred, relationship, validates",
            "from zxcvbn import zxcvbn",
            "",
            "import rdiffweb.tools.db  # noqa",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "from ._repo import RepoObject",
            "from ._session import SessionObject",
            "from ._sshkey import SshKey",
            "from ._token import Token",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "SEP = b'/'",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(Base):",
            "    __tablename__ = 'users'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    # Value for role.",
            "    ADMIN_ROLE = 0",
            "    MAINTAINER_ROLE = 5",
            "    USER_ROLE = 10",
            "    ROLES = {",
            "        'admin': ADMIN_ROLE,",
            "        'maintainer': MAINTAINER_ROLE,",
            "        'user': USER_ROLE,",
            "    }",
            "    # Value for mfa field",
            "    DISABLED_MFA = 0",
            "    ENABLED_MFA = 1",
            "",
            "    # Regex pattern to be used for validation.",
            "    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"",
            "    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"",
            "    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"",
            "",
            "    userid = Column('UserID', Integer, primary_key=True)",
            "    username = Column('Username', String, nullable=False)",
            "    hash_password = Column('Password', String, nullable=False, default=\"\")",
            "    user_root = Column('UserRoot', String, nullable=False, default=\"\")",
            "    _is_admin = deferred(",
            "        Column(",
            "            'IsAdmin',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"0\",",
            "            doc=\"DEPRECATED This column is replaced by 'role'\",",
            "        )",
            "    )",
            "    email = Column('UserEmail', String, nullable=False, default=\"\")",
            "    restore_format = deferred(",
            "        Column(",
            "            'RestoreFormat',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"1\",",
            "            doc=\"DEPRECATED This column is not used anymore\",",
            "        )",
            "    )",
            "    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)",
            "    fullname = Column('fullname', String, nullable=False, default=\"\")",
            "    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)",
            "    repo_objs = relationship(",
            "        'RepoObject',",
            "        foreign_keys='UserObject.userid',",
            "        primaryjoin='UserObject.userid == RepoObject.userid',",
            "        uselist=True,",
            "        lazy=True,",
            "        order_by=lambda: RepoObject.repopath,",
            "    )",
            "",
            "    @classmethod",
            "    def get_user(cls, user):",
            "        \"\"\"Return a user object with username case-insensitive\"\"\"",
            "        return UserObject.query.filter(func.lower(UserObject.username) == user.lower()).first()",
            "",
            "    @classmethod",
            "    def create_admin_user(cls, default_username, default_password):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = UserObject.get_user(default_username)",
            "        if not userobj:",
            "            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')",
            "            userobj.hash_password = hash_password('admin123')",
            "        # Also make sure to update the password with latest value from config file.",
            "        if default_password:",
            "            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):",
            "                userobj.hash_password = default_password",
            "            else:",
            "                userobj.hash_password = hash_password(default_password)",
            "        userobj.add()",
            "        return userobj",
            "",
            "    @classmethod",
            "    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if UserObject.get_user(username):",
            "            raise ValueError(_(\"User %s already exists.\" % (username,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", username)",
            "        userobj = UserObject(",
            "            username=username,",
            "            hash_password=hash_password(password) if password else '',",
            "            role=role,",
            "            **attrs,",
            "        ).add()",
            "        # Return user object",
            "        return userobj",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue()).add().flush()",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)",
            "",
            "    def add_access_token(self, name, expiration_time=None, length=16):",
            "        \"\"\"",
            "        Create a new access token. Return the un-encrypted value of the token.",
            "        \"\"\"",
            "        assert name",
            "        assert length >= 8",
            "        # Generate a random token",
            "        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))",
            "        # Store hash token",
            "        try:",
            "            Token(",
            "                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time",
            "            ).add().flush()",
            "        except IntegrityError:",
            "            raise ValueError(_(\"Duplicate token name: %s\") % name)",
            "        cherrypy.engine.publish('access_token_added', self, name)",
            "        return token",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self, *args, **kwargs):",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "        if self.username == cfg.admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "        # FIXME This should be deleted by cascade",
            "        SshKey.query.filter(SshKey.userid == self.userid).delete()",
            "        RepoObject.query.filter(RepoObject.userid == self.userid).delete()",
            "        Token.query.filter(Token.userid == self.userid).delete()",
            "        # Delete ourself",
            "        return Base.delete(self)",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def delete_access_token(self, name):",
            "        assert name",
            "        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():",
            "            raise ValueError(_(\"token name doesn't exists: %s\") % name)",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        cherrypy.engine.publish('set_disk_quota', self, value)",
            "",
            "    @property",
            "    def authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        for record in SshKey.query.filter(SshKey.userid == self.userid).all():",
            "            yield authorizedkeys.check_publickey(record.key)",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "        # Update the repositories by walking in the directory tree.",
            "        def _onerror(unused):",
            "            logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "        # Get application config",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        dirty = False",
            "        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()",
            "        user_root = os.fsencode(self.user_root)",
            "        for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "            for name in dirs.copy():",
            "                if name.startswith(b'.'):",
            "                    dirs.remove(name)",
            "            if b'rdiff-backup-data' in dirs:",
            "                repopath = os.path.relpath(root, start=user_root)",
            "                del dirs[:]",
            "                # Handle special scenario when the repo is the",
            "                # user_root",
            "                repopath = b'' if repopath == b'.' else repopath",
            "",
            "                # Check if repo path exists.",
            "                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)",
            "                if not record_match:",
            "                    # Add repository to database.",
            "                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()",
            "                    dirty = True",
            "                else:",
            "                    records.remove(record_match)",
            "            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:",
            "                del dirs[:]",
            "        # If enabled, remove entried from database",
            "        if delete:",
            "            for record in records:",
            "                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()",
            "        return dirty",
            "",
            "    @hybrid_property",
            "    def is_admin(self):",
            "        return self.role is not None and self.role <= self.ADMIN_ROLE",
            "",
            "    @hybrid_property",
            "    def is_ldap(self):",
            "        return self.hash_password is None or self.hash_password == ''",
            "",
            "    @is_ldap.expression",
            "    def is_ldap(cls):",
            "        return or_(cls.hash_password.is_(None), cls.hash_password == '')",
            "",
            "    @hybrid_property",
            "    def is_maintainer(self):",
            "        return self.role is not None and self.role <= self.MAINTAINER_ROLE",
            "",
            "    def set_password(self, password):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == cfg.admin_user and cfg.admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check password length",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        # Store password",
            "        logger.info(\"updating user password [%s] and revoke sessions\", self.username)",
            "        self.hash_password = hash_password(password)",
            "",
            "        # Revoke other session to force re-login",
            "        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None",
            "        SessionObject.query.filter(",
            "            SessionObject.username == self.username,",
            "            SessionObject.id != session_id,",
            "        ).delete()",
            "",
            "    def __eq__(self, other):",
            "        return type(self) == type(other) and inspect(self).key == inspect(other).key",
            "",
            "    @validates('username')",
            "    def validates_username(self, key, value):",
            "        if self.username:",
            "            raise ValueError('Username cannot be modified.')",
            "        return value",
            "",
            "    def validate_access_token(self, token):",
            "        \"\"\"",
            "        Check if the given token matches.",
            "        \"\"\"",
            "        for access_token in Token.query.all():",
            "            if access_token.is_expired:",
            "                continue",
            "            if check_password(token, access_token.hash_token):",
            "                # When it matches, return the record.",
            "                return access_token",
            "        return False",
            "",
            "    def validate_password(self, password):",
            "        return check_password(password, self.hash_password)",
            "",
            "",
            "# Username should be case insensitive",
            "user_username_index = Index('user_username_index', func.lower(UserObject.username), unique=True)",
            "",
            "",
            "@event.listens_for(UserObject.hash_password, \"set\")",
            "def hash_password_set(target, value, oldvalue, initiator):",
            "    if value and value != oldvalue:",
            "        cherrypy.engine.publish('user_password_changed', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'before_insert')",
            "def user_before_insert(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is added",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_added', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_delete')",
            "def user_after_delete(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is deleted.",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_deleted', target.username)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_update')",
            "def user_attr_changed(mapper, connection, target):",
            "    changes = {}",
            "    state = inspect(target)",
            "    for attr in state.attrs:",
            "        if attr.key in ['user_root', 'email', 'role', 'mfa']:",
            "            hist = attr.load_history()",
            "            if hist.has_changes():",
            "                changes[attr.key] = (",
            "                    hist.deleted[0] if len(hist.deleted) >= 1 else None,",
            "                    hist.added[0] if len(hist.added) >= 1 else None,",
            "                )",
            "    if changes:",
            "        cherrypy.engine.publish('user_attr_changed', target, changes)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "import logging",
            "import os",
            "import secrets",
            "import string",
            "",
            "import cherrypy",
            "from sqlalchemy import Column, Index, Integer, SmallInteger, String, and_, event, func, inspect, or_",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.ext.hybrid import hybrid_property",
            "from sqlalchemy.orm import deferred, relationship, validates",
            "from zxcvbn import zxcvbn",
            "",
            "import rdiffweb.tools.db  # noqa",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "from ._repo import RepoObject",
            "from ._session import SessionObject",
            "from ._sshkey import SshKey",
            "from ._token import Token",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "Base = cherrypy.tools.db.get_base()",
            "",
            "SEP = b'/'",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(Base):",
            "    __tablename__ = 'users'",
            "    __table_args__ = {'sqlite_autoincrement': True}",
            "",
            "    # Value for role.",
            "    ADMIN_ROLE = 0",
            "    MAINTAINER_ROLE = 5",
            "    USER_ROLE = 10",
            "    ROLES = {",
            "        'admin': ADMIN_ROLE,",
            "        'maintainer': MAINTAINER_ROLE,",
            "        'user': USER_ROLE,",
            "    }",
            "    # Value for mfa field",
            "    DISABLED_MFA = 0",
            "    ENABLED_MFA = 1",
            "",
            "    # Regex pattern to be used for validation.",
            "    PATTERN_EMAIL = r\"[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$\"",
            "    PATTERN_FULLNAME = r\"\"\"[^!\"#$%&()*+,./:;<=>?@[\\]_{|}~]+$\"\"\"",
            "    PATTERN_USERNAME = r\"[a-zA-Z0-9_.\\-]+$\"",
            "",
            "    userid = Column('UserID', Integer, primary_key=True)",
            "    username = Column('Username', String, nullable=False)",
            "    hash_password = Column('Password', String, nullable=False, default=\"\")",
            "    user_root = Column('UserRoot', String, nullable=False, default=\"\")",
            "    _is_admin = deferred(",
            "        Column(",
            "            'IsAdmin',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"0\",",
            "            doc=\"DEPRECATED This column is replaced by 'role'\",",
            "        )",
            "    )",
            "    email = Column('UserEmail', String, nullable=False, default=\"\")",
            "    restore_format = deferred(",
            "        Column(",
            "            'RestoreFormat',",
            "            SmallInteger,",
            "            nullable=False,",
            "            server_default=\"1\",",
            "            doc=\"DEPRECATED This column is not used anymore\",",
            "        )",
            "    )",
            "    role = Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE), default=USER_ROLE)",
            "    fullname = Column('fullname', String, nullable=False, default=\"\")",
            "    mfa = Column('mfa', SmallInteger, nullable=False, default=DISABLED_MFA)",
            "    repo_objs = relationship(",
            "        'RepoObject',",
            "        foreign_keys='UserObject.userid',",
            "        primaryjoin='UserObject.userid == RepoObject.userid',",
            "        uselist=True,",
            "        lazy=True,",
            "        order_by=lambda: RepoObject.repopath,",
            "    )",
            "",
            "    @classmethod",
            "    def get_user(cls, user):",
            "        \"\"\"Return a user object with username case-insensitive\"\"\"",
            "        return UserObject.query.filter(func.lower(UserObject.username) == user.lower()).first()",
            "",
            "    @classmethod",
            "    def create_admin_user(cls, default_username, default_password):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = UserObject.get_user(default_username)",
            "        if not userobj:",
            "            userobj = cls.add_user(default_username, role=UserObject.ADMIN_ROLE, user_root='/backups')",
            "            userobj.hash_password = hash_password('admin123')",
            "        # Also make sure to update the password with latest value from config file.",
            "        if default_password:",
            "            if default_password.startswith('{SSHA}') or default_password.startswith('$argon2'):",
            "                userobj.hash_password = default_password",
            "            else:",
            "                userobj.hash_password = hash_password(default_password)",
            "        userobj.add()",
            "        return userobj",
            "",
            "    @classmethod",
            "    def add_user(cls, username, password=None, role=USER_ROLE, **attrs):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if UserObject.get_user(username):",
            "            raise ValueError(_(\"User %s already exists.\" % (username,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", username)",
            "        userobj = UserObject(",
            "            username=username,",
            "            hash_password=hash_password(password) if password else '',",
            "            role=role,",
            "            **attrs,",
            "        ).add()",
            "        # Return user object",
            "        return userobj",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option & Remove comment for SQL storage",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                sshkey = SshKey(userid=self.userid, fingerprint=key.fingerprint, key=key.getvalue())",
            "                sshkey.add().flush()",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "        cherrypy.engine.publish('authorizedkey_added', self, fingerprint=key.fingerprint, comment=comment)",
            "",
            "    def add_access_token(self, name, expiration_time=None, length=16):",
            "        \"\"\"",
            "        Create a new access token. Return the un-encrypted value of the token.",
            "        \"\"\"",
            "        assert name",
            "        assert length >= 8",
            "        # Generate a random token",
            "        token = ''.join(secrets.choice(string.ascii_lowercase) for i in range(length))",
            "        # Store hash token",
            "        try:",
            "            Token(",
            "                userid=self.userid, name=name, hash_token=hash_password(token), expiration_time=expiration_time",
            "            ).add().flush()",
            "        except IntegrityError:",
            "            raise ValueError(_(\"Duplicate token name: %s\") % name)",
            "        cherrypy.engine.publish('access_token_added', self, name)",
            "        return token",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self, *args, **kwargs):",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "        if self.username == cfg.admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "        # FIXME This should be deleted by cascade",
            "        SshKey.query.filter(SshKey.userid == self.userid).delete()",
            "        RepoObject.query.filter(RepoObject.userid == self.userid).delete()",
            "        Token.query.filter(Token.userid == self.userid).delete()",
            "        # Delete ourself",
            "        return Base.delete(self)",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            SshKey.query.filter(and_(SshKey.userid == self.userid, SshKey.fingerprint == fingerprint)).delete()",
            "        cherrypy.engine.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def delete_access_token(self, name):",
            "        assert name",
            "        if not Token.query.filter(Token.userid == self.userid, Token.name == name).delete():",
            "            raise ValueError(_(\"token name doesn't exists: %s\") % name)",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = cherrypy.engine.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        cherrypy.engine.publish('set_disk_quota', self, value)",
            "",
            "    @property",
            "    def authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        for record in SshKey.query.filter(SshKey.userid == self.userid).all():",
            "            yield authorizedkeys.check_publickey(record.key)",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "        # Update the repositories by walking in the directory tree.",
            "        def _onerror(unused):",
            "            logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "        # Get application config",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        dirty = False",
            "        records = RepoObject.query.filter(RepoObject.userid == self.userid).order_by(RepoObject.repopath).all()",
            "        user_root = os.fsencode(self.user_root)",
            "        for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "            for name in dirs.copy():",
            "                if name.startswith(b'.'):",
            "                    dirs.remove(name)",
            "            if b'rdiff-backup-data' in dirs:",
            "                repopath = os.path.relpath(root, start=user_root)",
            "                del dirs[:]",
            "                # Handle special scenario when the repo is the",
            "                # user_root",
            "                repopath = b'' if repopath == b'.' else repopath",
            "",
            "                # Check if repo path exists.",
            "                record_match = next((record for record in records if record.repopath == os.fsdecode(repopath)), None)",
            "                if not record_match:",
            "                    # Add repository to database.",
            "                    RepoObject(user=self, repopath=os.fsdecode(repopath)).add()",
            "                    dirty = True",
            "                else:",
            "                    records.remove(record_match)",
            "            if root.count(SEP) - user_root.count(SEP) >= cfg.max_depth:",
            "                del dirs[:]",
            "        # If enabled, remove entried from database",
            "        if delete:",
            "            for record in records:",
            "                RepoObject.query.filter(RepoObject.repoid == record.repoid).delete()",
            "        return dirty",
            "",
            "    @hybrid_property",
            "    def is_admin(self):",
            "        return self.role is not None and self.role <= self.ADMIN_ROLE",
            "",
            "    @hybrid_property",
            "    def is_ldap(self):",
            "        return self.hash_password is None or self.hash_password == ''",
            "",
            "    @is_ldap.expression",
            "    def is_ldap(cls):",
            "        return or_(cls.hash_password.is_(None), cls.hash_password == '')",
            "",
            "    @hybrid_property",
            "    def is_maintainer(self):",
            "        return self.role is not None and self.role <= self.MAINTAINER_ROLE",
            "",
            "    def set_password(self, password):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = cherrypy.tree.apps[''].cfg",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == cfg.admin_user and cfg.admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check password length",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        # Store password",
            "        logger.info(\"updating user password [%s] and revoke sessions\", self.username)",
            "        self.hash_password = hash_password(password)",
            "",
            "        # Revoke other session to force re-login",
            "        session_id = cherrypy.serving.session.id if hasattr(cherrypy.serving, 'session') else None",
            "        SessionObject.query.filter(",
            "            SessionObject.username == self.username,",
            "            SessionObject.id != session_id,",
            "        ).delete()",
            "",
            "    def __eq__(self, other):",
            "        return type(self) == type(other) and inspect(self).key == inspect(other).key",
            "",
            "    @validates('username')",
            "    def validates_username(self, key, value):",
            "        if self.username:",
            "            raise ValueError('Username cannot be modified.')",
            "        return value",
            "",
            "    def validate_access_token(self, token):",
            "        \"\"\"",
            "        Check if the given token matches.",
            "        \"\"\"",
            "        for access_token in Token.query.all():",
            "            if access_token.is_expired:",
            "                continue",
            "            if check_password(token, access_token.hash_token):",
            "                # When it matches, return the record.",
            "                return access_token",
            "        return False",
            "",
            "    def validate_password(self, password):",
            "        return check_password(password, self.hash_password)",
            "",
            "",
            "# Username should be case insensitive",
            "user_username_index = Index('user_username_index', func.lower(UserObject.username), unique=True)",
            "",
            "",
            "@event.listens_for(UserObject.hash_password, \"set\")",
            "def hash_password_set(target, value, oldvalue, initiator):",
            "    if value and value != oldvalue:",
            "        cherrypy.engine.publish('user_password_changed', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'before_insert')",
            "def user_before_insert(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is added",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_added', target)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_delete')",
            "def user_after_delete(mapper, connection, target):",
            "    \"\"\"",
            "    Publish event when user is deleted.",
            "    \"\"\"",
            "    cherrypy.engine.publish('user_deleted', target.username)",
            "",
            "",
            "@event.listens_for(UserObject, 'after_update')",
            "def user_attr_changed(mapper, connection, target):",
            "    changes = {}",
            "    state = inspect(target)",
            "    for attr in state.attrs:",
            "        if attr.key in ['user_root', 'email', 'role', 'mfa']:",
            "            hist = attr.load_history()",
            "            if hist.has_changes():",
            "                changes[attr.key] = (",
            "                    hist.deleted[0] if len(hist.deleted) >= 1 else None,",
            "                    hist.added[0] if len(hist.added) >= 1 else None,",
            "                )",
            "    if changes:",
            "        cherrypy.engine.publish('user_attr_changed', target, changes)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "162": [
                "UserObject",
                "add_authorizedkey"
            ],
            "179": [
                "UserObject",
                "add_authorizedkey"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/core/model/tests/test_user.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "     def test_add_authorizedkey_duplicate(self):"
            },
            "1": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 326,
                "PatchRowcode": "         # Read the pub key"
            },
            "2": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "         key = self._read_ssh_key()"
            },
            "3": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Add the key to the user"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+        # Given a user with a SSH Key"
            },
            "5": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "         userobj = UserObject.get_user(self.USERNAME)"
            },
            "6": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         userobj.add_authorizedkey(key)"
            },
            "7": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         userobj.commit()"
            },
            "8": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Add the same key"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        # When adding the same identical key."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+        # Then an error is raised"
            },
            "12": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         with self.assertRaises(DuplicateSSHKeyError):"
            },
            "13": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "             userobj.add_authorizedkey(key)"
            },
            "14": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "             userobj.commit()"
            },
            "15": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 338,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 339,
                "PatchRowcode": "+    def test_add_authorizedkey_duplicate_new_comment(self):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 340,
                "PatchRowcode": "+        # Read the pub key"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 341,
                "PatchRowcode": "+        key = self._read_ssh_key()"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 342,
                "PatchRowcode": "+        # Given a user with a SSH Key"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 343,
                "PatchRowcode": "+        userobj = UserObject.get_user(self.USERNAME)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 344,
                "PatchRowcode": "+        userobj.add_authorizedkey(key)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 345,
                "PatchRowcode": "+        userobj.commit()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 346,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 347,
                "PatchRowcode": "+        # When adding the same key with a different comment"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 348,
                "PatchRowcode": "+        # Then an error is raised"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 349,
                "PatchRowcode": "+        with self.assertRaises(DuplicateSSHKeyError):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 350,
                "PatchRowcode": "+            userobj.add_authorizedkey(key, comment=\"new comment\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+            userobj.commit()"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 352,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 353,
                "PatchRowcode": "+    def test_add_authorizedkey_duplicate_new_user(self):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+        # Read the pub key"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        key = self._read_ssh_key()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+        # Given a user with a SSH Key"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+        userobj = UserObject.get_user(self.USERNAME)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        userobj.add_authorizedkey(key)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+        userobj.commit()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+        # When adding the same key to a different user"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        # Then an error is raised"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        newuser = UserObject.add_user(\"newuser\")"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        newuser.commit()"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+        with self.assertRaises(DuplicateSSHKeyError):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+            newuser.add_authorizedkey(key, comment=\"new comment\")"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+            newuser.commit()"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "     def test_add_authorizedkey_with_file(self):"
            },
            "47": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "         \"\"\""
            },
            "48": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         Add an ssh key for a user with an authorizedkey file."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on June 30, 2022",
            "",
            "Module to test `user` model.",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "import os",
            "from io import StringIO, open",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "import pkg_resources",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, UserObject",
            "from rdiffweb.core.passwd import check_password",
            "",
            "",
            "class UserObjectTest(rdiffweb.test.WebCase):",
            "    def _read_ssh_key(self):",
            "        \"\"\"Readthe pub key from test packages\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_publickey_ssh_rsa.pub')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.readline()",
            "",
            "    def _read_authorized_keys(self):",
            "        \"\"\"Read the content of test_authorized_keys\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_authorized_keys')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.read()",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('access_token_added', self.listener.access_token_added, priority=50)",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_mail, priority=50)",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_login', self.listener.user_login, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('access_token_added', self.listener.access_token_added)",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_mail)",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_login', self.listener.user_login)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def test_add_user(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_updated_by_listener(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        # Given a listener with side effet",
            "        def change_user_obj(userobj):",
            "            userobj.user_root = '/new/value'",
            "",
            "        self.listener.user_added.side_effect = change_user_obj",
            "        # When adding user",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Then lister get called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "        # Then object was updated by listener",
            "        self.assertEqual('/new/value', userobj.user_root)",
            "",
            "    def test_add_user_with_duplicate(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('denise')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_duplicate_caseinsensitive(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('dEnIse')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_password(self):",
            "        \"\"\"Add user to database with password.\"\"\"",
            "        userobj = UserObject.add_user('jo', 'password')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('jo'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_delete_admin_user(self):",
            "        # Trying to delete admin user should raise an error.",
            "        userobj = UserObject.get_user('admin')",
            "        with self.assertRaises(ValueError):",
            "            userobj.delete()",
            "",
            "    def test_users(self):",
            "        # Check admin exists",
            "        self.assertEqual(1, UserObject.query.count())",
            "        # Create user.",
            "        user = UserObject.add_user('annik')",
            "        user.commit()",
            "        users = UserObject.query.all()",
            "        self.assertEqual(2, len(users))",
            "        self.assertEqual('annik', users[1].username)",
            "        # Then 2 user exists",
            "        self.assertEqual(2, UserObject.query.count())",
            "",
            "    def test_get_user(self):",
            "        # Create new user",
            "        user = UserObject.add_user('bernie', 'my-password')",
            "        user.user_root = self.testcases",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.email = 'bernie@gmail.com'",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        user.repo_objs[0].maxage = -1",
            "        user.repo_objs[1].maxage = 3",
            "        user.commit()",
            "",
            "        # Get user record.",
            "        obj = UserObject.get_user('bernie')",
            "        self.assertIsNotNone(obj)",
            "        self.assertEqual('bernie', obj.username)",
            "        self.assertEqual('bernie@gmail.com', obj.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in obj.repo_objs]))",
            "        self.assertEqual(self.testcases, obj.user_root)",
            "        self.assertEqual(True, obj.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, obj.role)",
            "",
            "        # Get repo object",
            "        self.assertEqual('broker-repo', obj.repo_objs[0].name)",
            "        self.assertEqual(-1, obj.repo_objs[0].maxage)",
            "        self.assertEqual('testcases', obj.repo_objs[1].name)",
            "        self.assertEqual(3, obj.repo_objs[1].maxage)",
            "",
            "    def test_get_user_case_insensitive(self):",
            "        userobj1 = UserObject.get_user(self.USERNAME)",
            "        userobj2 = UserObject.get_user(self.USERNAME.lower())",
            "        userobj3 = UserObject.get_user(self.USERNAME.upper())",
            "        self.assertEqual(userobj1, userobj2)",
            "        self.assertEqual(userobj2, userobj3)",
            "",
            "    def test_get_user_with_invalid_user(self):",
            "        self.assertIsNone(UserObject.get_user('invalid'))",
            "",
            "    def test_get_set(self):",
            "        user = UserObject.add_user('larry', 'password')",
            "        user.add().commit()",
            "",
            "        self.assertEqual('', user.email)",
            "        self.assertEqual([], user.repo_objs)",
            "        self.assertEqual('', user.user_root)",
            "        self.assertEqual(False, user.is_admin)",
            "        self.assertEqual(UserObject.USER_ROLE, user.role)",
            "",
            "        user.user_root = self.testcases",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'user_root': ('', self.testcases)})",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(",
            "            user, {'role': (UserObject.USER_ROLE, UserObject.ADMIN_ROLE)}",
            "        )",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.email = 'larry@gmail.com'",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'email': ('', 'larry@gmail.com')})",
            "        self.listener.user_attr_changed.reset_mock()",
            "",
            "        self.assertEqual('larry@gmail.com', user.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        self.assertEqual(self.testcases, user.user_root)",
            "        self.assertEqual(True, user.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, user.role)",
            "",
            "    def test_set_role_null(self):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        user.add().commit()",
            "        # When trying to set the role to null",
            "        user.role = None",
            "        # Then an exception is raised",
            "        with self.assertRaises(Exception):",
            "            user.add().commit()",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, False),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_admin(self, role, expected_is_admin):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_admin, user.is_admin)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, True),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_maintainer(self, role, expected_is_maintainer):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_maintainer, user.is_maintainer)",
            "",
            "    def test_set_password_update(self):",
            "        # Given a user in database with a password",
            "        userobj = UserObject.add_user('annik', 'password')",
            "        userobj.commit()",
            "        self.listener.user_password_changed.reset_mock()",
            "        # When updating the user's password",
            "        userobj.set_password('new_password')",
            "        userobj.commit()",
            "        # Then password is SSHA",
            "        self.assertTrue(check_password('new_password', userobj.hash_password))",
            "        # Check if listener called",
            "        self.listener.user_password_changed.assert_called_once_with(userobj)",
            "",
            "    def test_delete_user(self):",
            "        # Given an existing user in database",
            "        userobj = UserObject.add_user('vicky')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('vicky'))",
            "        # When deleting that user",
            "        userobj.delete()",
            "        userobj.commit()",
            "        # Then user it no longer in database",
            "        self.assertIsNone(UserObject.get_user('vicky'))",
            "        # Then listner was called",
            "        self.listener.user_deleted.assert_called_once_with('vicky')",
            "",
            "    def test_set_password_empty(self):",
            "        \"\"\"Expect error when trying to update password of invalid user.\"\"\"",
            "        userobj = UserObject.add_user('john')",
            "        userobj.commit()",
            "        with self.assertRaises(ValueError):",
            "            self.assertFalse(userobj.set_password(''))",
            "",
            "    def test_disk_quota(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.disk_quota",
            "",
            "    def test_disk_usage(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        disk_usage = userobj.disk_usage",
            "        self.assertIsInstance(disk_usage, int)",
            "",
            "    def test_add_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user without an authorizedkey file.",
            "        \"\"\"",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys), \"expecting one key\")",
            "        self.assertEqual(\"3c:99:ed:a7:82:a8:71:09:2c:15:3d:78:4a:8c:11:99\", keys[0].fingerprint)",
            "",
            "    def test_add_authorizedkey_duplicate(self):",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "        # Add the same key",
            "        with self.assertRaises(DuplicateSSHKeyError):",
            "            userobj.add_authorizedkey(key)",
            "            userobj.commit()",
            "",
            "    def test_add_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user with an authorizedkey file.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "",
            "        # Create empty authorized_keys file",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        open(filename, 'a').close()",
            "",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        with open(filename, 'r') as fh:",
            "            self.assertEqual(key, fh.read())",
            "",
            "    def test_delete_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user without authorizedkey file.",
            "        \"\"\"",
            "        # Update user with ssh keys.",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for k in authorizedkeys.read(StringIO(data)):",
            "            try:",
            "                userobj.add_authorizedkey(k.getvalue())",
            "            except ValueError:",
            "                # Some ssh key in the testing file are not valid.",
            "                pass",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(2, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys))",
            "",
            "    def test_delete_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user with authorizedkey file.",
            "        \"\"\"",
            "        # Create authorized_keys file",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        with open(filename, 'w') as f:",
            "            f.write(data)",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(5, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(4, len(keys))",
            "",
            "    def test_repo_objs(self):",
            "        # Given a user with a list of repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        repos = sorted(userobj.repo_objs, key=lambda r: r.name)",
            "        self.assertEqual(['broker-repo', 'testcases'], [r.name for r in repos])",
            "        # When deleting a repository empty list",
            "        repos[1].delete()",
            "        repos[1].commit()",
            "        # Then the repository is removed from the list.",
            "        self.assertEqual(['broker-repo'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_without_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos()",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_single_repo(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.user_root = os.path.join(self.testcases, 'testcases')",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual([''], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_empty_userroot(self):",
            "        # Given a user with valid repositories relative to root",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for repo in userobj.repo_objs:",
            "            repo.repopath = self.testcases[1:] + '/' + repo.repopath",
            "            repo.add().commit()",
            "        userobj.user_root = '/'",
            "        userobj.add().commit()",
            "        self.assertEqual(['interrupted', 'ok'], sorted([r.status[0] for r in userobj.repo_objs]))",
            "        # When updating it's userroot directory to an empty value",
            "        userobj.user_root = ''",
            "        userobj.add().commit()",
            "        UserObject.session.expire_all()",
            "        # Then close session",
            "        cherrypy.tools.db.on_end_resource()",
            "        # Then repo status is \"broken\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertFalse(userobj.valid_user_root())",
            "        self.assertEqual(['failed', 'failed'], [r.status[0] for r in userobj.repo_objs])",
            "",
            "",
            "# password: test",
            "@parameterized_class(",
            "    [",
            "        {",
            "            'default_config': {",
            "                'admin-password': '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e',",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': '$argon2id$v=19$m=65536,t=3,p=4$N2FmDyCNjY/MTreAOWluLw$BbKVcHt99Jf5yeTbFcJhwJpcEtSSNCB1ru4D+Vvm+JM'",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': 'test',",
            "            }",
            "        },",
            "    ]",
            ")",
            "class UserObjectWithAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def test_create_admin_user(self):",
            "        # Given admin-password is configure",
            "        # When database get created",
            "        # Then admin user get created with 'test' password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertIsNotNone(userobj)",
            "        self.assertTrue(check_password('test', userobj.hash_password))",
            "",
            "        # Given admin-password is configure",
            "        # When trying to update admin password",
            "        # Then an exception is raised",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        with self.assertRaises(ValueError):",
            "            userobj.set_password('newpassword')",
            "",
            "",
            "class UserObjectWithoutAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def tearDown(self):",
            "        # Do nothing - We need to makre sure the database is not drop.",
            "        pass",
            "",
            "    def test_create_admin_user_without_password(self):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again",
            "        user = UserObject.create_admin_user(self.USERNAME, None)",
            "        user.commit()",
            "        # Then user password must not be replaced",
            "        self.assertTrue(check_password('test', user.hash_password))",
            "",
            "    @parameterized.expand(",
            "        [",
            "            'puy3qjRWjpCn',",
            "            '$argon2id$v=19$m=65536,t=3,p=4$L91u8sX4ecyrbUSqvmb/FA$GOGR5uPmQmla6H62e5yKKNCRa7sY6d2Hxmly/eAXe6Q',",
            "            '{SSHA}3RkZu26wF8xSHInMcK8P/9wqqU1aCzie',",
            "        ]",
            "    )",
            "    def test_create_admin_user_with_password(self, new_password):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again with a password",
            "        user = UserObject.create_admin_user(self.USERNAME, new_password)",
            "        user.commit()",
            "        # Then user password get replaced",
            "        self.assertTrue(check_password('puy3qjRWjpCn', user.hash_password))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on June 30, 2022",
            "",
            "Module to test `user` model.",
            "",
            "@author: Patrik Dufresne <patrik@ikus-soft.com>",
            "\"\"\"",
            "import os",
            "from io import StringIO, open",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "import pkg_resources",
            "from parameterized import parameterized, parameterized_class",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core import authorizedkeys",
            "from rdiffweb.core.model import DuplicateSSHKeyError, RepoObject, UserObject",
            "from rdiffweb.core.passwd import check_password",
            "",
            "",
            "class UserObjectTest(rdiffweb.test.WebCase):",
            "    def _read_ssh_key(self):",
            "        \"\"\"Readthe pub key from test packages\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_publickey_ssh_rsa.pub')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.readline()",
            "",
            "    def _read_authorized_keys(self):",
            "        \"\"\"Read the content of test_authorized_keys\"\"\"",
            "        filename = pkg_resources.resource_filename('rdiffweb.core.tests', 'test_authorized_keys')",
            "        with open(filename, 'r', encoding='utf8') as f:",
            "            return f.read()",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('access_token_added', self.listener.access_token_added, priority=50)",
            "        cherrypy.engine.subscribe('queue_mail', self.listener.queue_mail, priority=50)",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_login', self.listener.user_login, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('access_token_added', self.listener.access_token_added)",
            "        cherrypy.engine.unsubscribe('queue_mail', self.listener.queue_mail)",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_login', self.listener.user_login)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def test_add_user(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_updated_by_listener(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        # Given a listener with side effet",
            "        def change_user_obj(userobj):",
            "            userobj.user_root = '/new/value'",
            "",
            "        self.listener.user_added.side_effect = change_user_obj",
            "        # When adding user",
            "        userobj = UserObject.add_user('joe')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('joe'))",
            "        # Then lister get called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "        # Then object was updated by listener",
            "        self.assertEqual('/new/value', userobj.user_root)",
            "",
            "    def test_add_user_with_duplicate(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('denise')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_duplicate_caseinsensitive(self):",
            "        \"\"\"Add user to database.\"\"\"",
            "        user = UserObject.add_user('denise')",
            "        user.commit()",
            "        self.listener.user_added.reset_mock()",
            "        with self.assertRaises(ValueError):",
            "            UserObject.add_user('dEnIse')",
            "        # Check if listener called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_user_with_password(self):",
            "        \"\"\"Add user to database with password.\"\"\"",
            "        userobj = UserObject.add_user('jo', 'password')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('jo'))",
            "        # Check if listener called",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_delete_admin_user(self):",
            "        # Trying to delete admin user should raise an error.",
            "        userobj = UserObject.get_user('admin')",
            "        with self.assertRaises(ValueError):",
            "            userobj.delete()",
            "",
            "    def test_users(self):",
            "        # Check admin exists",
            "        self.assertEqual(1, UserObject.query.count())",
            "        # Create user.",
            "        user = UserObject.add_user('annik')",
            "        user.commit()",
            "        users = UserObject.query.all()",
            "        self.assertEqual(2, len(users))",
            "        self.assertEqual('annik', users[1].username)",
            "        # Then 2 user exists",
            "        self.assertEqual(2, UserObject.query.count())",
            "",
            "    def test_get_user(self):",
            "        # Create new user",
            "        user = UserObject.add_user('bernie', 'my-password')",
            "        user.user_root = self.testcases",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.email = 'bernie@gmail.com'",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        user.repo_objs[0].maxage = -1",
            "        user.repo_objs[1].maxage = 3",
            "        user.commit()",
            "",
            "        # Get user record.",
            "        obj = UserObject.get_user('bernie')",
            "        self.assertIsNotNone(obj)",
            "        self.assertEqual('bernie', obj.username)",
            "        self.assertEqual('bernie@gmail.com', obj.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in obj.repo_objs]))",
            "        self.assertEqual(self.testcases, obj.user_root)",
            "        self.assertEqual(True, obj.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, obj.role)",
            "",
            "        # Get repo object",
            "        self.assertEqual('broker-repo', obj.repo_objs[0].name)",
            "        self.assertEqual(-1, obj.repo_objs[0].maxage)",
            "        self.assertEqual('testcases', obj.repo_objs[1].name)",
            "        self.assertEqual(3, obj.repo_objs[1].maxage)",
            "",
            "    def test_get_user_case_insensitive(self):",
            "        userobj1 = UserObject.get_user(self.USERNAME)",
            "        userobj2 = UserObject.get_user(self.USERNAME.lower())",
            "        userobj3 = UserObject.get_user(self.USERNAME.upper())",
            "        self.assertEqual(userobj1, userobj2)",
            "        self.assertEqual(userobj2, userobj3)",
            "",
            "    def test_get_user_with_invalid_user(self):",
            "        self.assertIsNone(UserObject.get_user('invalid'))",
            "",
            "    def test_get_set(self):",
            "        user = UserObject.add_user('larry', 'password')",
            "        user.add().commit()",
            "",
            "        self.assertEqual('', user.email)",
            "        self.assertEqual([], user.repo_objs)",
            "        self.assertEqual('', user.user_root)",
            "        self.assertEqual(False, user.is_admin)",
            "        self.assertEqual(UserObject.USER_ROLE, user.role)",
            "",
            "        user.user_root = self.testcases",
            "        user.refresh_repos()",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'user_root': ('', self.testcases)})",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.role = UserObject.ADMIN_ROLE",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(",
            "            user, {'role': (UserObject.USER_ROLE, UserObject.ADMIN_ROLE)}",
            "        )",
            "        self.listener.user_attr_changed.reset_mock()",
            "        user = UserObject.get_user('larry')",
            "        user.email = 'larry@gmail.com'",
            "        user.commit()",
            "        self.listener.user_attr_changed.assert_called_with(user, {'email': ('', 'larry@gmail.com')})",
            "        self.listener.user_attr_changed.reset_mock()",
            "",
            "        self.assertEqual('larry@gmail.com', user.email)",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in user.repo_objs]))",
            "        self.assertEqual(self.testcases, user.user_root)",
            "        self.assertEqual(True, user.is_admin)",
            "        self.assertEqual(UserObject.ADMIN_ROLE, user.role)",
            "",
            "    def test_set_role_null(self):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        user.add().commit()",
            "        # When trying to set the role to null",
            "        user.role = None",
            "        # Then an exception is raised",
            "        with self.assertRaises(Exception):",
            "            user.add().commit()",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, False),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_admin(self, role, expected_is_admin):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_admin, user.is_admin)",
            "",
            "    @parameterized.expand(",
            "        [",
            "            (-1, True),",
            "            (0, True),",
            "            (5, True),",
            "            (10, False),",
            "            (15, False),",
            "        ]",
            "    )",
            "    def test_is_maintainer(self, role, expected_is_maintainer):",
            "        # Given a user",
            "        user = UserObject.add_user('annik', 'password')",
            "        # When setting the role value",
            "        user.role = role",
            "        user.commit()",
            "        # Then the is_admin value get updated too",
            "        self.assertEqual(expected_is_maintainer, user.is_maintainer)",
            "",
            "    def test_set_password_update(self):",
            "        # Given a user in database with a password",
            "        userobj = UserObject.add_user('annik', 'password')",
            "        userobj.commit()",
            "        self.listener.user_password_changed.reset_mock()",
            "        # When updating the user's password",
            "        userobj.set_password('new_password')",
            "        userobj.commit()",
            "        # Then password is SSHA",
            "        self.assertTrue(check_password('new_password', userobj.hash_password))",
            "        # Check if listener called",
            "        self.listener.user_password_changed.assert_called_once_with(userobj)",
            "",
            "    def test_delete_user(self):",
            "        # Given an existing user in database",
            "        userobj = UserObject.add_user('vicky')",
            "        userobj.commit()",
            "        self.assertIsNotNone(UserObject.get_user('vicky'))",
            "        # When deleting that user",
            "        userobj.delete()",
            "        userobj.commit()",
            "        # Then user it no longer in database",
            "        self.assertIsNone(UserObject.get_user('vicky'))",
            "        # Then listner was called",
            "        self.listener.user_deleted.assert_called_once_with('vicky')",
            "",
            "    def test_set_password_empty(self):",
            "        \"\"\"Expect error when trying to update password of invalid user.\"\"\"",
            "        userobj = UserObject.add_user('john')",
            "        userobj.commit()",
            "        with self.assertRaises(ValueError):",
            "            self.assertFalse(userobj.set_password(''))",
            "",
            "    def test_disk_quota(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.disk_quota",
            "",
            "    def test_disk_usage(self):",
            "        \"\"\"",
            "        Just make a call to the function.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        disk_usage = userobj.disk_usage",
            "        self.assertIsInstance(disk_usage, int)",
            "",
            "    def test_add_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user without an authorizedkey file.",
            "        \"\"\"",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Add the key to the user",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys), \"expecting one key\")",
            "        self.assertEqual(\"3c:99:ed:a7:82:a8:71:09:2c:15:3d:78:4a:8c:11:99\", keys[0].fingerprint)",
            "",
            "    def test_add_authorizedkey_duplicate(self):",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Given a user with a SSH Key",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # When adding the same identical key.",
            "        # Then an error is raised",
            "        with self.assertRaises(DuplicateSSHKeyError):",
            "            userobj.add_authorizedkey(key)",
            "            userobj.commit()",
            "",
            "    def test_add_authorizedkey_duplicate_new_comment(self):",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Given a user with a SSH Key",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # When adding the same key with a different comment",
            "        # Then an error is raised",
            "        with self.assertRaises(DuplicateSSHKeyError):",
            "            userobj.add_authorizedkey(key, comment=\"new comment\")",
            "            userobj.commit()",
            "",
            "    def test_add_authorizedkey_duplicate_new_user(self):",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        # Given a user with a SSH Key",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # When adding the same key to a different user",
            "        # Then an error is raised",
            "        newuser = UserObject.add_user(\"newuser\")",
            "        newuser.commit()",
            "        with self.assertRaises(DuplicateSSHKeyError):",
            "            newuser.add_authorizedkey(key, comment=\"new comment\")",
            "            newuser.commit()",
            "",
            "    def test_add_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Add an ssh key for a user with an authorizedkey file.",
            "        \"\"\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "",
            "        # Create empty authorized_keys file",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        open(filename, 'a').close()",
            "",
            "        # Read the pub key",
            "        key = self._read_ssh_key()",
            "        userobj.add_authorizedkey(key)",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        with open(filename, 'r') as fh:",
            "            self.assertEqual(key, fh.read())",
            "",
            "    def test_delete_authorizedkey_without_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user without authorizedkey file.",
            "        \"\"\"",
            "        # Update user with ssh keys.",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for k in authorizedkeys.read(StringIO(data)):",
            "            try:",
            "                userobj.add_authorizedkey(k.getvalue())",
            "            except ValueError:",
            "                # Some ssh key in the testing file are not valid.",
            "                pass",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(2, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "        userobj.commit()",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(1, len(keys))",
            "",
            "    def test_delete_authorizedkey_with_file(self):",
            "        \"\"\"",
            "        Remove an ssh key for a user with authorizedkey file.",
            "        \"\"\"",
            "        # Create authorized_keys file",
            "        data = self._read_authorized_keys()",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        os.mkdir(os.path.join(userobj.user_root, '.ssh'))",
            "        filename = os.path.join(userobj.user_root, '.ssh', 'authorized_keys')",
            "        with open(filename, 'w') as f:",
            "            f.write(data)",
            "",
            "        # Get the keys",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(5, len(keys))",
            "",
            "        # Remove a key",
            "        userobj.delete_authorizedkey(\"9a:f1:69:3c:bc:5a:cd:02:5e:33:bc:cd:c0:01:eb:4c\")",
            "",
            "        # Validate",
            "        keys = list(userobj.authorizedkeys)",
            "        self.assertEqual(4, len(keys))",
            "",
            "    def test_repo_objs(self):",
            "        # Given a user with a list of repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        repos = sorted(userobj.repo_objs, key=lambda r: r.name)",
            "        self.assertEqual(['broker-repo', 'testcases'], [r.name for r in repos])",
            "        # When deleting a repository empty list",
            "        repos[1].delete()",
            "        repos[1].commit()",
            "        # Then the repository is removed from the list.",
            "        self.assertEqual(['broker-repo'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_without_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos()",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_delete(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        RepoObject.query.delete()",
            "        RepoObject(userid=userobj.userid, repopath='invalid').add().commit()",
            "        self.assertEqual(['invalid'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_single_repo(self):",
            "        # Given a user with invalid repositories",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.user_root = os.path.join(self.testcases, 'testcases')",
            "        # When updating the repository list without deletion",
            "        userobj.refresh_repos(delete=True)",
            "        userobj.commit()",
            "        # Then the list invlaid the invalid repo and new repos",
            "        userobj.expire()",
            "        self.assertEqual([''], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_refresh_repos_with_empty_userroot(self):",
            "        # Given a user with valid repositories relative to root",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        for repo in userobj.repo_objs:",
            "            repo.repopath = self.testcases[1:] + '/' + repo.repopath",
            "            repo.add().commit()",
            "        userobj.user_root = '/'",
            "        userobj.add().commit()",
            "        self.assertEqual(['interrupted', 'ok'], sorted([r.status[0] for r in userobj.repo_objs]))",
            "        # When updating it's userroot directory to an empty value",
            "        userobj.user_root = ''",
            "        userobj.add().commit()",
            "        UserObject.session.expire_all()",
            "        # Then close session",
            "        cherrypy.tools.db.on_end_resource()",
            "        # Then repo status is \"broken\"",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertFalse(userobj.valid_user_root())",
            "        self.assertEqual(['failed', 'failed'], [r.status[0] for r in userobj.repo_objs])",
            "",
            "",
            "# password: test",
            "@parameterized_class(",
            "    [",
            "        {",
            "            'default_config': {",
            "                'admin-password': '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e',",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': '$argon2id$v=19$m=65536,t=3,p=4$N2FmDyCNjY/MTreAOWluLw$BbKVcHt99Jf5yeTbFcJhwJpcEtSSNCB1ru4D+Vvm+JM'",
            "            },",
            "        },",
            "        {",
            "            'default_config': {",
            "                'admin-password': 'test',",
            "            }",
            "        },",
            "    ]",
            ")",
            "class UserObjectWithAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def test_create_admin_user(self):",
            "        # Given admin-password is configure",
            "        # When database get created",
            "        # Then admin user get created with 'test' password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        self.assertIsNotNone(userobj)",
            "        self.assertTrue(check_password('test', userobj.hash_password))",
            "",
            "        # Given admin-password is configure",
            "        # When trying to update admin password",
            "        # Then an exception is raised",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        with self.assertRaises(ValueError):",
            "            userobj.set_password('newpassword')",
            "",
            "",
            "class UserObjectWithoutAdminPassword(rdiffweb.test.WebCase):",
            "    def setUp(self):",
            "        # Do nothing - We need to skip the default setup to avoid deleting the records.",
            "        pass",
            "",
            "    def tearDown(self):",
            "        # Do nothing - We need to makre sure the database is not drop.",
            "        pass",
            "",
            "    def test_create_admin_user_without_password(self):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again",
            "        user = UserObject.create_admin_user(self.USERNAME, None)",
            "        user.commit()",
            "        # Then user password must not be replaced",
            "        self.assertTrue(check_password('test', user.hash_password))",
            "",
            "    @parameterized.expand(",
            "        [",
            "            'puy3qjRWjpCn',",
            "            '$argon2id$v=19$m=65536,t=3,p=4$L91u8sX4ecyrbUSqvmb/FA$GOGR5uPmQmla6H62e5yKKNCRa7sY6d2Hxmly/eAXe6Q',",
            "            '{SSHA}3RkZu26wF8xSHInMcK8P/9wqqU1aCzie',",
            "        ]",
            "    )",
            "    def test_create_admin_user_with_password(self, new_password):",
            "        # Given an existing admin user with a password",
            "        userobj = UserObject.get_user(self.USERNAME)",
            "        userobj.hash_password = '{SSHA}wbSK4hlEX7mtGJplFi2oN6ABm6Y3Bo1e'  # test",
            "        # When application restart, create_admin_user is called again with a password",
            "        user = UserObject.create_admin_user(self.USERNAME, new_password)",
            "        user.commit()",
            "        # Then user password get replaced",
            "        self.assertTrue(check_password('puy3qjRWjpCn', user.hash_password))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "328": [
                "UserObjectTest",
                "test_add_authorizedkey_duplicate"
            ],
            "332": [
                "UserObjectTest",
                "test_add_authorizedkey_duplicate"
            ]
        },
        "addLocation": []
    }
}