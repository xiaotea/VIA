{
    "ckan/logic/action/create.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1038,
                "afterPatchRowNumber": 1038,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 1039,
                "afterPatchRowNumber": 1039,
                "PatchRowcode": "     _check_access('user_create', context, data_dict)"
            },
            "2": {
                "beforePatchRowNumber": 1040,
                "afterPatchRowNumber": 1040,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1041,
                "PatchRowcode": "+    author_obj = model.User.get(context.get('user'))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1042,
                "PatchRowcode": "+    if data_dict.get(\"id\"):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1043,
                "PatchRowcode": "+        is_sysadmin = (author_obj and author_obj.sysadmin)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1044,
                "PatchRowcode": "+        if not is_sysadmin or model.User.get(data_dict[\"id\"]):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1045,
                "PatchRowcode": "+            data_dict.pop(\"id\", None)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1046,
                "PatchRowcode": "+    context.pop(\"user_obj\", None)"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1047,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 1041,
                "afterPatchRowNumber": 1048,
                "PatchRowcode": "     upload = uploader.get_uploader('user')"
            },
            "11": {
                "beforePatchRowNumber": 1042,
                "afterPatchRowNumber": 1049,
                "PatchRowcode": "     upload.update_data_dict(data_dict, 'image_url',"
            },
            "12": {
                "beforePatchRowNumber": 1043,
                "afterPatchRowNumber": 1050,
                "PatchRowcode": "                             'image_upload', 'clear_upload')"
            },
            "13": {
                "beforePatchRowNumber": 1085,
                "afterPatchRowNumber": 1092,
                "PatchRowcode": "     user_dictize_context['keep_apikey'] = True"
            },
            "14": {
                "beforePatchRowNumber": 1086,
                "afterPatchRowNumber": 1093,
                "PatchRowcode": "     user_dictize_context['keep_email'] = True"
            },
            "15": {
                "beforePatchRowNumber": 1087,
                "afterPatchRowNumber": 1094,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 1088,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    author_obj = model.User.get(context.get('user'))"
            },
            "17": {
                "beforePatchRowNumber": 1089,
                "afterPatchRowNumber": 1095,
                "PatchRowcode": "     include_plugin_extras = False"
            },
            "18": {
                "beforePatchRowNumber": 1090,
                "afterPatchRowNumber": 1096,
                "PatchRowcode": "     if author_obj:"
            },
            "19": {
                "beforePatchRowNumber": 1091,
                "afterPatchRowNumber": 1097,
                "PatchRowcode": "         include_plugin_extras = author_obj.sysadmin and 'plugin_extras' in data"
            }
        },
        "frontPatchFile": [
            "# encoding: utf-8",
            "",
            "'''API functions for adding data to CKAN.'''",
            "",
            "import logging",
            "import random",
            "import re",
            "from socket import error as socket_error",
            "import datetime",
            "",
            "import six",
            "",
            "import ckan.common",
            "from sqlalchemy import func",
            "",
            "import ckan.lib.plugins as lib_plugins",
            "import ckan.logic as logic",
            "import ckan.plugins as plugins",
            "import ckan.lib.dictization",
            "import ckan.logic.action",
            "import ckan.logic.schema",
            "import ckan.lib.dictization.model_dictize as model_dictize",
            "import ckan.lib.dictization.model_save as model_save",
            "import ckan.lib.navl.dictization_functions",
            "import ckan.lib.uploader as uploader",
            "import ckan.lib.mailer as mailer",
            "import ckan.lib.datapreview",
            "import ckan.lib.api_token as api_token",
            "import ckan.authz as authz",
            "",
            "from ckan.common import _, config",
            "",
            "# FIXME this looks nasty and should be shared better",
            "from ckan.logic.action.update import _update_package_relationship",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "# Define some shortcuts",
            "# Ensure they are module-private so that they don't get loaded as available",
            "# actions in the action API.",
            "_validate = ckan.lib.navl.dictization_functions.validate",
            "_check_access = logic.check_access",
            "_get_action = logic.get_action",
            "ValidationError = logic.ValidationError",
            "NotFound = logic.NotFound",
            "NotAuthorized = logic.NotAuthorized",
            "_get_or_bust = logic.get_or_bust",
            "",
            "",
            "def package_create(context, data_dict):",
            "    '''Create a new dataset (package).",
            "",
            "    You must be authorized to create new datasets. If you specify any groups",
            "    for the new dataset, you must also be authorized to edit these groups.",
            "",
            "    Plugins may change the parameters of this function depending on the value",
            "    of the ``type`` parameter, see the",
            "    :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugin interface.",
            "",
            "    :param name: the name of the new dataset, must be between 2 and 100",
            "        characters long and contain only lowercase alphanumeric characters,",
            "        ``-`` and ``_``, e.g. ``'warandpeace'``",
            "    :type name: string",
            "    :param title: the title of the dataset (optional, default: same as",
            "        ``name``)",
            "    :type title: string",
            "    :param private: If ``True`` creates a private dataset",
            "    :type private: bool",
            "    :param author: the name of the dataset's author (optional)",
            "    :type author: string",
            "    :param author_email: the email address of the dataset's author (optional)",
            "    :type author_email: string",
            "    :param maintainer: the name of the dataset's maintainer (optional)",
            "    :type maintainer: string",
            "    :param maintainer_email: the email address of the dataset's maintainer",
            "        (optional)",
            "    :type maintainer_email: string",
            "    :param license_id: the id of the dataset's license, see",
            "        :py:func:`~ckan.logic.action.get.license_list` for available values",
            "        (optional)",
            "    :type license_id: license id string",
            "    :param notes: a description of the dataset (optional)",
            "    :type notes: string",
            "    :param url: a URL for the dataset's source (optional)",
            "    :type url: string",
            "    :param version: (optional)",
            "    :type version: string, no longer than 100 characters",
            "    :param state: the current state of the dataset, e.g. ``'active'`` or",
            "        ``'deleted'``, only active datasets show up in search results and",
            "        other lists of datasets, this parameter will be ignored if you are not",
            "        authorized to change the state of the dataset (optional, default:",
            "        ``'active'``)",
            "    :type state: string",
            "    :param type: the type of the dataset (optional),",
            "        :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugins",
            "        associate themselves with different dataset types and provide custom",
            "        dataset handling behaviour for these types",
            "    :type type: string",
            "    :param resources: the dataset's resources, see",
            "        :py:func:`resource_create` for the format of resource dictionaries",
            "        (optional)",
            "    :type resources: list of resource dictionaries",
            "    :param tags: the dataset's tags, see :py:func:`tag_create` for the format",
            "        of tag dictionaries (optional)",
            "    :type tags: list of tag dictionaries",
            "    :param extras: the dataset's extras (optional), extras are arbitrary",
            "        (key: value) metadata items that can be added to datasets, each extra",
            "        dictionary should have keys ``'key'`` (a string), ``'value'`` (a",
            "        string)",
            "    :type extras: list of dataset extra dictionaries",
            "    :param relationships_as_object: see :py:func:`package_relationship_create`",
            "        for the format of relationship dictionaries (optional)",
            "    :type relationships_as_object: list of relationship dictionaries",
            "    :param relationships_as_subject: see :py:func:`package_relationship_create`",
            "        for the format of relationship dictionaries (optional)",
            "    :type relationships_as_subject: list of relationship dictionaries",
            "    :param groups: the groups to which the dataset belongs (optional), each",
            "        group dictionary should have one or more of the following keys which",
            "        identify an existing group:",
            "        ``'id'`` (the id of the group, string), or ``'name'`` (the name of the",
            "        group, string),  to see which groups exist",
            "        call :py:func:`~ckan.logic.action.get.group_list`",
            "    :type groups: list of dictionaries",
            "    :param owner_org: the id of the dataset's owning organization, see",
            "        :py:func:`~ckan.logic.action.get.organization_list` or",
            "        :py:func:`~ckan.logic.action.get.organization_list_for_user` for",
            "        available values. This parameter can be made optional if the config",
            "        option :ref:`ckan.auth.create_unowned_dataset` is set to ``True``.",
            "    :type owner_org: string",
            "",
            "    :returns: the newly created dataset (unless 'return_id_only' is set to True",
            "              in the context, in which case just the dataset id will",
            "              be returned)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    session = context['session']",
            "    user = context['user']",
            "",
            "    if 'type' not in data_dict:",
            "        package_plugin = lib_plugins.lookup_package_plugin()",
            "        try:",
            "            # use first type as default if user didn't provide type",
            "            package_type = package_plugin.package_types()[0]",
            "        except (AttributeError, IndexError):",
            "            package_type = 'dataset'",
            "            # in case a 'dataset' plugin was registered w/o fallback",
            "            package_plugin = lib_plugins.lookup_package_plugin(package_type)",
            "        data_dict['type'] = package_type",
            "    else:",
            "        package_plugin = lib_plugins.lookup_package_plugin(data_dict['type'])",
            "",
            "    if 'schema' in context:",
            "        schema = context['schema']",
            "    else:",
            "        schema = package_plugin.create_package_schema()",
            "",
            "    _check_access('package_create', context, data_dict)",
            "",
            "    if 'api_version' not in context:",
            "        # check_data_dict() is deprecated. If the package_plugin has a",
            "        # check_data_dict() we'll call it, if it doesn't have the method we'll",
            "        # do nothing.",
            "        check_data_dict = getattr(package_plugin, 'check_data_dict', None)",
            "        if check_data_dict:",
            "            try:",
            "                check_data_dict(data_dict, schema)",
            "            except TypeError:",
            "                # Old plugins do not support passing the schema so we need",
            "                # to ensure they still work",
            "                package_plugin.check_data_dict(data_dict)",
            "",
            "    data, errors = lib_plugins.plugin_validate(",
            "        package_plugin, context, data_dict, schema, 'package_create')",
            "    log.debug('package_create validate_errs=%r user=%s package=%s data=%r',",
            "              errors, context.get('user'),",
            "              data.get('name'), data_dict)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    if user:",
            "",
            "        user_obj = model.User.by_name(six.ensure_text(user))",
            "        if user_obj:",
            "            data['creator_user_id'] = user_obj.id",
            "",
            "    pkg = model_save.package_dict_save(data, context)",
            "",
            "    # Needed to let extensions know the package and resources ids",
            "    model.Session.flush()",
            "    data['id'] = pkg.id",
            "    if data.get('resources'):",
            "        for index, resource in enumerate(data['resources']):",
            "            resource['id'] = pkg.resources[index].id",
            "",
            "    context_org_update = context.copy()",
            "    context_org_update['ignore_auth'] = True",
            "    context_org_update['defer_commit'] = True",
            "    _get_action('package_owner_org_update')(context_org_update,",
            "                                            {'id': pkg.id,",
            "                                             'organization_id': pkg.owner_org})",
            "",
            "    for item in plugins.PluginImplementations(plugins.IPackageController):",
            "        item.create(pkg)",
            "",
            "        item.after_create(context, data)",
            "",
            "    # Make sure that a user provided schema is not used in create_views",
            "    # and on package_show",
            "    context.pop('schema', None)",
            "",
            "    # Create default views for resources if necessary",
            "    if data.get('resources'):",
            "        logic.get_action('package_create_default_resource_views')(",
            "            {'model': context['model'], 'user': context['user'],",
            "             'ignore_auth': True},",
            "            {'package': data})",
            "",
            "    # Create activity",
            "    if not pkg.private:",
            "        user_obj = model.User.by_name(user)",
            "        if user_obj:",
            "            user_id = user_obj.id",
            "        else:",
            "            user_id = 'not logged in'",
            "",
            "        activity = pkg.activity_stream_item('new', user_id)",
            "        session.add(activity)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    return_id_only = context.get('return_id_only', False)",
            "",
            "    if return_id_only:",
            "        return pkg.id",
            "",
            "    return _get_action('package_show')(",
            "        context.copy(), {'id': pkg.id}",
            "    )",
            "",
            "",
            "def resource_create(context, data_dict):",
            "    '''Appends a new resource to a datasets list of resources.",
            "",
            "    :param package_id: id of package that the resource should be added to.",
            "",
            "    :type package_id: string",
            "    :param url: url of resource",
            "    :type url: string",
            "    :param description: (optional)",
            "    :type description: string",
            "    :param format: (optional)",
            "    :type format: string",
            "    :param hash: (optional)",
            "    :type hash: string",
            "    :param name: (optional)",
            "    :type name: string",
            "    :param resource_type: (optional)",
            "    :type resource_type: string",
            "    :param mimetype: (optional)",
            "    :type mimetype: string",
            "    :param mimetype_inner: (optional)",
            "    :type mimetype_inner: string",
            "    :param cache_url: (optional)",
            "    :type cache_url: string",
            "    :param size: (optional)",
            "    :type size: int",
            "    :param created: (optional)",
            "    :type created: iso date string",
            "    :param last_modified: (optional)",
            "    :type last_modified: iso date string",
            "    :param cache_last_updated: (optional)",
            "    :type cache_last_updated: iso date string",
            "    :param upload: (optional)",
            "    :type upload: FieldStorage (optional) needs multipart/form-data",
            "",
            "    :returns: the newly created resource",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context['user']",
            "",
            "    package_id = _get_or_bust(data_dict, 'package_id')",
            "    if not data_dict.get('url'):",
            "        data_dict['url'] = ''",
            "",
            "    package_show_context = dict(context, for_update=True, return_type='dict')",
            "    pkg_dict = _get_action('package_show')(",
            "        package_show_context,",
            "        {'id': package_id})",
            "",
            "    _check_access('resource_create', context, data_dict)",
            "",
            "    for plugin in plugins.PluginImplementations(plugins.IResourceController):",
            "        plugin.before_create(context, data_dict)",
            "",
            "    if 'resources' not in pkg_dict:",
            "        pkg_dict['resources'] = []",
            "",
            "    upload = uploader.get_resource_uploader(data_dict)",
            "",
            "    if 'mimetype' not in data_dict:",
            "        if hasattr(upload, 'mimetype'):",
            "            data_dict['mimetype'] = upload.mimetype",
            "",
            "    if 'size' not in data_dict:",
            "        if hasattr(upload, 'filesize'):",
            "            data_dict['size'] = upload.filesize",
            "",
            "    pkg_dict['resources'].append(data_dict)",
            "",
            "    try:",
            "        context['defer_commit'] = True",
            "        context['use_cache'] = False",
            "        _get_action('package_update')(context, pkg_dict)",
            "        context.pop('defer_commit')",
            "    except ValidationError as e:",
            "        try:",
            "            raise ValidationError(e.error_dict['resources'][-1])",
            "        except (KeyError, IndexError):",
            "            raise ValidationError(e.error_dict)",
            "",
            "    # Get out resource_id resource from model as it will not appear in",
            "    # package_show until after commit",
            "    upload.upload(context['package'].resources[-1].id,",
            "                  uploader.get_max_resource_size())",
            "",
            "    model.repo.commit()",
            "",
            "    #  Run package show again to get out actual last_resource",
            "    updated_pkg_dict = _get_action('package_show')(context, {'id': package_id})",
            "    resource = updated_pkg_dict['resources'][-1]",
            "",
            "    #  Add the default views to the new resource",
            "    logic.get_action('resource_create_default_resource_views')(",
            "        {'model': context['model'],",
            "         'user': context['user'],",
            "         'ignore_auth': True",
            "         },",
            "        {'resource': resource,",
            "         'package': updated_pkg_dict",
            "         })",
            "",
            "    for plugin in plugins.PluginImplementations(plugins.IResourceController):",
            "        plugin.after_create(context, resource)",
            "",
            "    return resource",
            "",
            "",
            "def resource_view_create(context, data_dict):",
            "    '''Creates a new resource view.",
            "",
            "    :param resource_id: id of the resource",
            "    :type resource_id: string",
            "    :param title: the title of the view",
            "    :type title: string",
            "    :param description: a description of the view (optional)",
            "    :type description: string",
            "    :param view_type: type of view",
            "    :type view_type: string",
            "    :param config: options necessary to recreate a view state (optional)",
            "    :type config: JSON string",
            "",
            "    :returns: the newly created resource view",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "",
            "    resource_id = _get_or_bust(data_dict, 'resource_id')",
            "    view_type = _get_or_bust(data_dict, 'view_type')",
            "    view_plugin = ckan.lib.datapreview.get_view_plugin(view_type)",
            "",
            "    if not view_plugin:",
            "        raise ValidationError(",
            "            {\"view_type\": \"No plugin found for view_type {view_type}\".format(",
            "                view_type=view_type",
            "            )}",
            "        )",
            "",
            "    default = logic.schema.default_create_resource_view_schema(view_plugin)",
            "    schema = context.get('schema', default)",
            "    plugin_schema = view_plugin.info().get('schema', {})",
            "    schema.update(plugin_schema)",
            "",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    _check_access('resource_view_create', context, data_dict)",
            "",
            "    if context.get('preview'):",
            "        return data",
            "",
            "    max_order = model.Session.query(",
            "        func.max(model.ResourceView.order)",
            "    ).filter_by(resource_id=resource_id).first()",
            "",
            "    order = 0",
            "    if max_order[0] is not None:",
            "        order = max_order[0] + 1",
            "    data['order'] = order",
            "",
            "    resource_view = model_save.resource_view_dict_save(data, context)",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "    return model_dictize.resource_view_dictize(resource_view, context)",
            "",
            "",
            "def resource_create_default_resource_views(context, data_dict):",
            "    '''",
            "    Creates the default views (if necessary) on the provided resource",
            "",
            "    The function will get the plugins for the default views defined in",
            "    the configuration, and if some were found the `can_view` method of",
            "    each one of them will be called to determine if a resource view should",
            "    be created. Resource views extensions get the resource dict and the",
            "    parent dataset dict.",
            "",
            "    If the latter is not provided, `package_show` is called to get it.",
            "",
            "    By default only view plugins that don't require the resource data to be in",
            "    the DataStore are called. See",
            "    :py:func:`ckan.logic.action.create.package_create_default_resource_views.``",
            "    for details on the ``create_datastore_views`` parameter.",
            "",
            "    :param resource: full resource dict",
            "    :type resource: dict",
            "    :param package: full dataset dict (optional, if not provided",
            "        :py:func:`~ckan.logic.action.get.package_show` will be called).",
            "    :type package: dict",
            "    :param create_datastore_views: whether to create views that rely on data",
            "        being on the DataStore (optional, defaults to False)",
            "    :type create_datastore_views: bool",
            "",
            "    :returns: a list of resource views created (empty if none were created)",
            "    :rtype: list of dictionaries",
            "    '''",
            "",
            "    resource_dict = _get_or_bust(data_dict, 'resource')",
            "",
            "    _check_access('resource_create_default_resource_views', context, data_dict)",
            "",
            "    dataset_dict = data_dict.get('package')",
            "",
            "    create_datastore_views = ckan.common.asbool(",
            "        data_dict.get('create_datastore_views', False))",
            "",
            "    return ckan.lib.datapreview.add_views_to_resource(",
            "        context,",
            "        resource_dict,",
            "        dataset_dict,",
            "        view_types=[],",
            "        create_datastore_views=create_datastore_views)",
            "",
            "",
            "def package_create_default_resource_views(context, data_dict):",
            "    '''",
            "    Creates the default views on all resources of the provided dataset",
            "",
            "    By default only view plugins that don't require the resource data to be in",
            "    the DataStore are called. Passing `create_datastore_views` as True will",
            "    only create views that require data to be in the DataStore. The first case",
            "    happens when the function is called from `package_create` or",
            "    `package_update`, the second when it's called from the DataPusher when",
            "    data was uploaded to the DataStore.",
            "",
            "    :param package: full dataset dict (ie the one obtained",
            "        calling :py:func:`~ckan.logic.action.get.package_show`).",
            "    :type package: dict",
            "    :param create_datastore_views: whether to create views that rely on data",
            "        being on the DataStore (optional, defaults to False)",
            "    :type create_datastore_views: bool",
            "",
            "    :returns: a list of resource views created (empty if none were created)",
            "    :rtype: list of dictionaries",
            "    '''",
            "",
            "    dataset_dict = _get_or_bust(data_dict, 'package')",
            "",
            "    _check_access('package_create_default_resource_views', context, data_dict)",
            "",
            "    create_datastore_views = ckan.common.asbool(",
            "        data_dict.get('create_datastore_views', False))",
            "",
            "    return ckan.lib.datapreview.add_views_to_dataset_resources(",
            "        context,",
            "        dataset_dict,",
            "        view_types=[],",
            "        create_datastore_views=create_datastore_views)",
            "",
            "",
            "def package_relationship_create(context, data_dict):",
            "    '''Create a relationship between two datasets (packages).",
            "",
            "    You must be authorized to edit both the subject and the object datasets.",
            "",
            "    :param subject: the id or name of the dataset that is the subject of the",
            "        relationship",
            "    :type subject: string",
            "    :param object: the id or name of the dataset that is the object of the",
            "        relationship",
            "    :param type: the type of the relationship, one of ``'depends_on'``,",
            "        ``'dependency_of'``, ``'derives_from'``, ``'has_derivation'``,",
            "        ``'links_to'``, ``'linked_from'``, ``'child_of'`` or ``'parent_of'``",
            "    :type type: string",
            "    :param comment: a comment about the relationship (optional)",
            "    :type comment: string",
            "",
            "    :returns: the newly created package relationship",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context['user']",
            "    schema = context.get('schema') \\",
            "        or ckan.logic.schema.default_create_relationship_schema()",
            "    api = context.get('api_version')",
            "    ref_package_by = 'id' if api == 2 else 'name'",
            "",
            "    id, id2, rel_type = _get_or_bust(data_dict, ['subject', 'object', 'type'])",
            "    comment = data_dict.get('comment', u'')",
            "",
            "    pkg1 = model.Package.get(id)",
            "    pkg2 = model.Package.get(id2)",
            "    if not pkg1:",
            "        raise NotFound('Subject package %r was not found.' % id)",
            "    if not pkg2:",
            "        return NotFound('Object package %r was not found.' % id2)",
            "",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    _check_access('package_relationship_create', context, data_dict)",
            "",
            "    # Create a Package Relationship.",
            "    existing_rels = pkg1.get_relationships_with(pkg2, rel_type)",
            "    if existing_rels:",
            "        return _update_package_relationship(existing_rels[0],",
            "                                            comment, context)",
            "    rel = pkg1.add_relationship(rel_type, pkg2, comment=comment)",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit_and_remove()",
            "    context['relationship'] = rel",
            "",
            "    relationship_dicts = rel.as_dict(ref_package_by=ref_package_by)",
            "    return relationship_dicts",
            "",
            "",
            "def member_create(context, data_dict=None):",
            "    '''Make an object (e.g. a user, dataset or group) a member of a group.",
            "",
            "    If the object is already a member of the group then the capacity of the",
            "    membership will be updated.",
            "",
            "    You must be authorized to edit the group.",
            "",
            "    :param id: the id or name of the group to add the object to",
            "    :type id: string",
            "    :param object: the id or name of the object to add",
            "    :type object: string",
            "    :param object_type: the type of the object being added, e.g. ``'package'``",
            "        or ``'user'``",
            "    :type object_type: string",
            "    :param capacity: the capacity of the membership",
            "    :type capacity: string",
            "",
            "    :returns: the newly created (or updated) membership",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context['user']",
            "",
            "    group_id, obj_id, obj_type, capacity = \\",
            "        _get_or_bust(data_dict, ['id', 'object', 'object_type', 'capacity'])",
            "",
            "    group = model.Group.get(group_id)",
            "    if not group:",
            "        raise NotFound('Group was not found.')",
            "",
            "    obj_class = ckan.logic.model_name_to_class(model, obj_type)",
            "    obj = obj_class.get(obj_id)",
            "    if not obj:",
            "        raise NotFound('%s was not found.' % obj_type.title())",
            "",
            "    _check_access('member_create', context, data_dict)",
            "",
            "    # Look up existing, in case it exists",
            "    member = model.Session.query(model.Member).\\",
            "        filter(model.Member.table_name == obj_type).\\",
            "        filter(model.Member.table_id == obj.id).\\",
            "        filter(model.Member.group_id == group.id).\\",
            "        filter(model.Member.state == 'active').first()",
            "    if member:",
            "        user_obj = model.User.get(user)",
            "        if member.table_name == u'user' and \\",
            "                member.table_id == user_obj.id and \\",
            "                member.capacity == u'admin' and \\",
            "                capacity != u'admin':",
            "            raise NotAuthorized(\"Administrators cannot revoke their \"",
            "                                \"own admin status\")",
            "    else:",
            "        member = model.Member(table_name=obj_type,",
            "                              table_id=obj.id,",
            "                              group_id=group.id,",
            "                              state='active')",
            "        member.group = group",
            "    member.capacity = capacity",
            "",
            "    model.Session.add(member)",
            "    model.repo.commit()",
            "",
            "    return model_dictize.member_dictize(member, context)",
            "",
            "",
            "def package_collaborator_create(context, data_dict):",
            "    '''Make a user a collaborator in a dataset.",
            "",
            "    If the user is already a collaborator in the dataset then their",
            "    capacity will be updated.",
            "",
            "    Currently you must be an Admin on the dataset owner organization to",
            "    manage collaborators.",
            "",
            "    Note: This action requires the collaborators feature to be enabled with",
            "    the :ref:`ckan.auth.allow_dataset_collaborators` configuration option.",
            "",
            "    :param id: the id or name of the dataset",
            "    :type id: string",
            "    :param user_id: the id or name of the user to add or edit",
            "    :type user_id: string",
            "    :param capacity: the capacity or role of the membership. Must be one of",
            "        \"editor\" or \"member\". Additionally",
            "        if :ref:`ckan.auth.allow_admin_collaborators` is set to True, \"admin\"",
            "        is also allowed.",
            "    :type capacity: string",
            "",
            "    :returns: the newly created (or updated) collaborator",
            "    :rtype: dictionary",
            "    '''",
            "",
            "    model = context['model']",
            "",
            "    package_id, user_id, capacity = _get_or_bust(",
            "        data_dict,",
            "        ['id', 'user_id', 'capacity']",
            "    )",
            "",
            "    allowed_capacities = authz.get_collaborator_capacities()",
            "    if capacity not in allowed_capacities:",
            "        raise ValidationError(",
            "            _('Role must be one of \"{}\"').format(', '.join(",
            "                allowed_capacities)))",
            "",
            "    _check_access('package_collaborator_create', context, data_dict)",
            "",
            "    package = model.Package.get(package_id)",
            "    if not package:",
            "        raise NotFound(_('Dataset not found'))",
            "",
            "    user = model.User.get(user_id)",
            "    if not user:",
            "        raise NotFound(_('User not found'))",
            "",
            "    if not authz.check_config_permission('allow_dataset_collaborators'):",
            "        raise ValidationError(_('Dataset collaborators not enabled'))",
            "",
            "    # Check if collaborator already exists",
            "    collaborator = model.Session.query(model.PackageMember). \\",
            "        filter(model.PackageMember.package_id == package.id). \\",
            "        filter(model.PackageMember.user_id == user.id).one_or_none()",
            "    if not collaborator:",
            "        collaborator = model.PackageMember(",
            "            package_id=package.id,",
            "            user_id=user.id)",
            "    collaborator.capacity = capacity",
            "    collaborator.modified = datetime.datetime.utcnow()",
            "    model.Session.add(collaborator)",
            "    model.repo.commit()",
            "",
            "    log.info('User {} added as collaborator in package {} ({})'.format(",
            "        user.name, package.id, capacity))",
            "",
            "    return model_dictize.member_dictize(collaborator, context)",
            "",
            "",
            "def _group_or_org_create(context, data_dict, is_org=False):",
            "    model = context['model']",
            "    user = context['user']",
            "    session = context['session']",
            "    data_dict['is_organization'] = is_org",
            "",
            "    upload = uploader.get_uploader('group')",
            "    upload.update_data_dict(data_dict, 'image_url',",
            "                            'image_upload', 'clear_upload')",
            "    # get the schema",
            "    group_type = data_dict.get('type', 'organization' if is_org else 'group')",
            "    group_plugin = lib_plugins.lookup_group_plugin(group_type)",
            "    try:",
            "        schema = group_plugin.form_to_db_schema_options({",
            "            'type': 'create', 'api': 'api_version' in context,",
            "            'context': context})",
            "    except AttributeError:",
            "        schema = group_plugin.form_to_db_schema()",
            "",
            "    if 'api_version' not in context:",
            "        # old plugins do not support passing the schema so we need",
            "        # to ensure they still work",
            "        try:",
            "            group_plugin.check_data_dict(data_dict, schema)",
            "        except TypeError:",
            "            group_plugin.check_data_dict(data_dict)",
            "",
            "    data, errors = lib_plugins.plugin_validate(",
            "        group_plugin, context, data_dict, schema,",
            "        'organization_create' if is_org else 'group_create')",
            "    log.debug('group_create validate_errs=%r user=%s group=%s data_dict=%r',",
            "              errors, context.get('user'), data_dict.get('name'), data_dict)",
            "",
            "    if errors:",
            "        session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    group = model_save.group_dict_save(data, context)",
            "",
            "    # Needed to let extensions know the group id",
            "    session.flush()",
            "",
            "    if is_org:",
            "        plugin_type = plugins.IOrganizationController",
            "    else:",
            "        plugin_type = plugins.IGroupController",
            "",
            "    for item in plugins.PluginImplementations(plugin_type):",
            "        item.create(group)",
            "",
            "    if is_org:",
            "        activity_type = 'new organization'",
            "    else:",
            "        activity_type = 'new group'",
            "",
            "    user_id = model.User.by_name(six.ensure_text(user)).id",
            "",
            "    activity_dict = {",
            "        'user_id': user_id,",
            "        'object_id': group.id,",
            "        'activity_type': activity_type,",
            "    }",
            "    activity_dict['data'] = {",
            "        'group': ckan.lib.dictization.table_dictize(group, context)",
            "    }",
            "    activity_create_context = {",
            "        'model': model,",
            "        'user': user,",
            "        'defer_commit': True,",
            "        'ignore_auth': True,",
            "        'session': session",
            "    }",
            "    logic.get_action('activity_create')(activity_create_context, activity_dict)",
            "",
            "    upload.upload(uploader.get_max_image_size())",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "    context[\"group\"] = group",
            "    context[\"id\"] = group.id",
            "",
            "    # creator of group/org becomes an admin",
            "    # this needs to be after the repo.commit or else revisions break",
            "    member_dict = {",
            "        'id': group.id,",
            "        'object': user_id,",
            "        'object_type': 'user',",
            "        'capacity': 'admin',",
            "    }",
            "    member_create_context = {",
            "        'model': model,",
            "        'user': user,",
            "        'ignore_auth': True,  # we are not a member of the group at this point",
            "        'session': session",
            "    }",
            "    logic.get_action('member_create')(member_create_context, member_dict)",
            "",
            "    log.debug('Created object %s' % group.name)",
            "",
            "    return_id_only = context.get('return_id_only', False)",
            "    action = 'organization_show' if is_org else 'group_show'",
            "",
            "    output = context['id'] if return_id_only \\",
            "        else _get_action(action)(context, {'id': group.id})",
            "",
            "    return output",
            "",
            "",
            "def group_create(context, data_dict):",
            "    '''Create a new group.",
            "",
            "    You must be authorized to create groups.",
            "",
            "    Plugins may change the parameters of this function depending on the value",
            "    of the ``type`` parameter, see the",
            "    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.",
            "",
            "    :param name: the name of the group, a string between 2 and 100 characters",
            "        long, containing only lowercase alphanumeric characters, ``-`` and",
            "        ``_``",
            "    :type name: string",
            "    :param id: the id of the group (optional)",
            "    :type id: string",
            "    :param title: the title of the group (optional)",
            "    :type title: string",
            "    :param description: the description of the group (optional)",
            "    :type description: string",
            "    :param image_url: the URL to an image to be displayed on the group's page",
            "        (optional)",
            "    :type image_url: string",
            "    :param type: the type of the group (optional, default: ``'group'``),",
            "        :py:class:`~ckan.plugins.interfaces.IGroupForm` plugins",
            "        associate themselves with different group types and provide custom",
            "        group handling behaviour for these types",
            "        Cannot be 'organization'",
            "    :type type: string",
            "    :param state: the current state of the group, e.g. ``'active'`` or",
            "        ``'deleted'``, only active groups show up in search results and",
            "        other lists of groups, this parameter will be ignored if you are not",
            "        authorized to change the state of the group (optional, default:",
            "        ``'active'``)",
            "    :type state: string",
            "    :param approval_status: (optional)",
            "    :type approval_status: string",
            "    :param extras: the group's extras (optional), extras are arbitrary",
            "        (key: value) metadata items that can be added to groups, each extra",
            "        dictionary should have keys ``'key'`` (a string), ``'value'`` (a",
            "        string), and optionally ``'deleted'``",
            "    :type extras: list of dataset extra dictionaries",
            "    :param packages: the datasets (packages) that belong to the group, a list",
            "        of dictionaries each with keys ``'name'`` (string, the id or name of",
            "        the dataset) and optionally ``'title'`` (string, the title of the",
            "        dataset)",
            "    :type packages: list of dictionaries",
            "    :param groups: the groups that belong to the group, a list of dictionaries",
            "        each with key ``'name'`` (string, the id or name of the group) and",
            "        optionally ``'capacity'`` (string, the capacity in which the group is",
            "        a member of the group)",
            "    :type groups: list of dictionaries",
            "    :param users: the users that belong to the group, a list of dictionaries",
            "        each with key ``'name'`` (string, the id or name of the user) and",
            "        optionally ``'capacity'`` (string, the capacity in which the user is",
            "        a member of the group)",
            "    :type users: list of dictionaries",
            "",
            "    :returns: the newly created group (unless 'return_id_only' is set to True",
            "              in the context, in which case just the group id will",
            "              be returned)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    # wrapper for creating groups",
            "    if data_dict.get('type') == 'organization':",
            "        # FIXME better exception?",
            "        raise Exception(_('Trying to create an organization as a group'))",
            "    _check_access('group_create', context, data_dict)",
            "    return _group_or_org_create(context, data_dict)",
            "",
            "",
            "def organization_create(context, data_dict):",
            "    '''Create a new organization.",
            "",
            "    You must be authorized to create organizations.",
            "",
            "    Plugins may change the parameters of this function depending on the value",
            "    of the ``type`` parameter, see the",
            "    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.",
            "",
            "    :param name: the name of the organization, a string between 2 and",
            "        100 characters long, containing only lowercase alphanumeric",
            "        characters, ``-`` and ``_``",
            "    :type name: string",
            "    :param id: the id of the organization (optional)",
            "    :type id: string",
            "    :param title: the title of the organization (optional)",
            "    :type title: string",
            "    :param description: the description of the organization (optional)",
            "    :type description: string",
            "    :param image_url: the URL to an image to be displayed on the",
            "        organization's page (optional)",
            "    :type image_url: string",
            "    :param state: the current state of the organization, e.g. ``'active'`` or",
            "        ``'deleted'``, only active organizations show up in search results and",
            "        other lists of organizations, this parameter will be ignored if you",
            "        are not authorized to change the state of the organization",
            "        (optional, default: ``'active'``)",
            "    :type state: string",
            "    :param approval_status: (optional)",
            "    :type approval_status: string",
            "    :param extras: the organization's extras (optional), extras are arbitrary",
            "        (key: value) metadata items that can be added to organizations,",
            "        each extra",
            "        dictionary should have keys ``'key'`` (a string), ``'value'`` (a",
            "        string), and optionally ``'deleted'``",
            "    :type extras: list of dataset extra dictionaries",
            "    :param packages: the datasets (packages) that belong to the organization,",
            "        a list of dictionaries each with keys ``'name'`` (string, the id",
            "        or name of the dataset) and optionally ``'title'`` (string, the",
            "        title of the dataset)",
            "    :type packages: list of dictionaries",
            "    :param users: the users that belong to the organization, a list",
            "        of dictionaries each with key ``'name'`` (string, the id or name",
            "        of the user) and optionally ``'capacity'`` (string, the capacity",
            "        in which the user is a member of the organization)",
            "    :type users: list of dictionaries",
            "",
            "    :returns: the newly created organization (unless 'return_id_only' is set",
            "              to True in the context, in which case just the organization id",
            "              will be returned)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    # wrapper for creating organizations",
            "    data_dict.setdefault('type', 'organization')",
            "    _check_access('organization_create', context, data_dict)",
            "    return _group_or_org_create(context, data_dict, is_org=True)",
            "",
            "",
            "@logic.auth_audit_exempt",
            "def rating_create(context, data_dict):",
            "    '''Rate a dataset (package).",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param package: the name or id of the dataset to rate",
            "    :type package: string",
            "    :param rating: the rating to give to the dataset, an integer between 1 and",
            "        5",
            "    :type rating: int",
            "",
            "    :returns: a dictionary with two keys: ``'rating average'`` (the average",
            "        rating of the dataset you rated) and ``'rating count'`` (the number of",
            "        times the dataset has been rated)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context.get(\"user\")",
            "",
            "    package_ref = data_dict.get('package')",
            "    rating = data_dict.get('rating')",
            "    opts_err = None",
            "    if not package_ref:",
            "        opts_err = _('You must supply a package id or name '",
            "                     '(parameter \"package\").')",
            "    elif not rating:",
            "        opts_err = _('You must supply a rating (parameter \"rating\").')",
            "    else:",
            "        try:",
            "            rating_int = int(rating)",
            "        except ValueError:",
            "            opts_err = _('Rating must be an integer value.')",
            "        else:",
            "            package = model.Package.get(package_ref)",
            "            if rating < model.MIN_RATING or rating > model.MAX_RATING:",
            "                opts_err = _('Rating must be between %i and %i.') \\",
            "                    % (model.MIN_RATING, model.MAX_RATING)",
            "            elif not package:",
            "                opts_err = _('Not found') + ': %r' % package_ref",
            "    if opts_err:",
            "        raise ValidationError(opts_err)",
            "",
            "    user = model.User.by_name(user)",
            "    package.set_rating(user, rating_int)",
            "    model.repo.commit()",
            "",
            "    package = model.Package.get(package_ref)",
            "    ret_dict = {'rating average': package.get_average_rating(),",
            "                'rating count': len(package.ratings)}",
            "    return ret_dict",
            "",
            "",
            "def user_create(context, data_dict):",
            "    '''Create a new user.",
            "",
            "    You must be authorized to create users.",
            "",
            "    :param name: the name of the new user, a string between 2 and 100",
            "        characters in length, containing only lowercase alphanumeric",
            "        characters, ``-`` and ``_``",
            "    :type name: string",
            "    :param email: the email address for the new user",
            "    :type email: string",
            "    :param password: the password of the new user, a string of at least 4",
            "        characters",
            "    :type password: string",
            "    :param id: the id of the new user (optional)",
            "    :type id: string",
            "    :param fullname: the full name of the new user (optional)",
            "    :type fullname: string",
            "    :param about: a description of the new user (optional)",
            "    :type about: string",
            "    :param image_url: the URL to an image to be displayed on the group's page",
            "        (optional)",
            "    :type image_url: string",
            "    :param plugin_extras: private extra user data belonging to plugins.",
            "        Only sysadmin users may set this value. It should be a dict that can",
            "        be dumped into JSON, and plugins should namespace their extras with",
            "        the plugin name to avoid collisions with other plugins, eg::",
            "",
            "            {",
            "                \"name\": \"test_user\",",
            "                \"email\": \"test@example.com\",",
            "                \"plugin_extras\": {",
            "                    \"my_plugin\": {",
            "                        \"private_extra\": 1",
            "                    },",
            "                    \"another_plugin\": {",
            "                        \"another_extra\": True",
            "                    }",
            "                }",
            "            }",
            "    :type plugin_extras: dict",
            "",
            "",
            "    :returns: the newly created user",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    schema = context.get('schema') or ckan.logic.schema.default_user_schema()",
            "    session = context['session']",
            "",
            "    _check_access('user_create', context, data_dict)",
            "",
            "    upload = uploader.get_uploader('user')",
            "    upload.update_data_dict(data_dict, 'image_url',",
            "                            'image_upload', 'clear_upload')",
            "    data, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # user schema prevents non-sysadmins from providing password_hash",
            "    if 'password_hash' in data:",
            "        data['_password'] = data.pop('password_hash')",
            "",
            "    user = model_save.user_dict_save(data, context)",
            "",
            "    # Flush the session to cause user.id to be initialised, because",
            "    # activity_create() (below) needs it.",
            "    session.flush()",
            "",
            "    activity_create_context = {",
            "        'model': model,",
            "        'user': context['user'],",
            "        'defer_commit': True,",
            "        'ignore_auth': True,",
            "        'session': session",
            "    }",
            "    activity_dict = {",
            "        'user_id': user.id,",
            "        'object_id': user.id,",
            "        'activity_type': 'new user',",
            "    }",
            "    logic.get_action('activity_create')(activity_create_context, activity_dict)",
            "",
            "    upload.upload(uploader.get_max_image_size())",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    # A new context is required for dictizing the newly constructed user in",
            "    # order that all the new user's data is returned, in particular, the",
            "    # api_key.",
            "    #",
            "    # The context is copied so as not to clobber the caller's context dict.",
            "    user_dictize_context = context.copy()",
            "    user_dictize_context['keep_apikey'] = True",
            "    user_dictize_context['keep_email'] = True",
            "",
            "    author_obj = model.User.get(context.get('user'))",
            "    include_plugin_extras = False",
            "    if author_obj:",
            "        include_plugin_extras = author_obj.sysadmin and 'plugin_extras' in data",
            "    user_dict = model_dictize.user_dictize(",
            "        user, user_dictize_context,",
            "        include_plugin_extras=include_plugin_extras",
            "    )",
            "",
            "    context['user_obj'] = user",
            "    context['id'] = user.id",
            "",
            "    model.Dashboard.get(user.id)  # Create dashboard for user.",
            "",
            "    log.debug('Created user {name}'.format(name=user.name))",
            "    return user_dict",
            "",
            "",
            "def user_invite(context, data_dict):",
            "    '''Invite a new user.",
            "",
            "    You must be authorized to create group members.",
            "",
            "    :param email: the email of the user to be invited to the group",
            "    :type email: string",
            "    :param group_id: the id or name of the group",
            "    :type group_id: string",
            "    :param role: role of the user in the group. One of ``member``, ``editor``,",
            "        or ``admin``",
            "    :type role: string",
            "",
            "    :returns: the newly created user",
            "    :rtype: dictionary",
            "    '''",
            "    import string",
            "    _check_access('user_invite', context, data_dict)",
            "",
            "    schema = context.get('schema',",
            "                         ckan.logic.schema.default_user_invite_schema())",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    model = context['model']",
            "    group = model.Group.get(data['group_id'])",
            "    if not group:",
            "        raise NotFound()",
            "",
            "    name = _get_random_username_from_email(data['email'])",
            "    # Choose a password. However it will not be used - the invitee will not be",
            "    # told it - they will need to reset it",
            "    while True:",
            "        password = ''.join(random.SystemRandom().choice(",
            "            string.ascii_lowercase + string.ascii_uppercase + string.digits)",
            "            for _ in range(12))",
            "        # Occasionally it won't meet the constraints, so check",
            "        errors = {}",
            "        logic.validators.user_password_validator(",
            "            'password', {'password': password}, errors, None)",
            "        if not errors:",
            "            break",
            "",
            "    data['name'] = name",
            "    data['password'] = password",
            "    data['state'] = ckan.model.State.PENDING",
            "    user_dict = _get_action('user_create')(context, data)",
            "    user = ckan.model.User.get(user_dict['id'])",
            "    member_dict = {",
            "        'username': user.id,",
            "        'id': data['group_id'],",
            "        'role': data['role']",
            "    }",
            "",
            "    if group.is_organization:",
            "        _get_action('organization_member_create')(context, member_dict)",
            "        group_dict = _get_action('organization_show')(context,",
            "                                                      {'id': data['group_id']})",
            "    else:",
            "        _get_action('group_member_create')(context, member_dict)",
            "        group_dict = _get_action('group_show')(context,",
            "                                               {'id': data['group_id']})",
            "    try:",
            "        mailer.send_invite(user, group_dict, data['role'])",
            "    except (socket_error, mailer.MailerException) as error:",
            "        # Email could not be sent, delete the pending user",
            "",
            "        _get_action('user_delete')(context, {'id': user.id})",
            "",
            "        error_dict = {",
            "            \"message\": _('Error sending the invite email, \\",
            "                the user was not created: {0}').format(error)",
            "        }",
            "        raise ValidationError(error_dict, error_summary=error_dict)",
            "",
            "    return model_dictize.user_dictize(user, context)",
            "",
            "",
            "def _get_random_username_from_email(email):",
            "    localpart = email.split('@')[0]",
            "    cleaned_localpart = re.sub(r'[^\\w]', '-', localpart).lower()",
            "",
            "    # if we can't create a unique user name within this many attempts",
            "    # then something else is probably wrong and we should give up",
            "    max_name_creation_attempts = 100",
            "",
            "    for i in range(max_name_creation_attempts):",
            "        random_number = random.SystemRandom().random() * 10000",
            "        name = '%s-%d' % (cleaned_localpart, random_number)",
            "        if not ckan.model.User.get(name):",
            "            return name",
            "",
            "    return cleaned_localpart",
            "",
            "",
            "def vocabulary_create(context, data_dict):",
            "    '''Create a new tag vocabulary.",
            "",
            "    You must be a sysadmin to create vocabularies.",
            "",
            "    :param name: the name of the new vocabulary, e.g. ``'Genre'``",
            "    :type name: string",
            "    :param tags: the new tags to add to the new vocabulary, for the format of",
            "        tag dictionaries see :py:func:`tag_create`",
            "    :type tags: list of tag dictionaries",
            "",
            "    :returns: the newly-created vocabulary",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    schema = context.get('schema') or \\",
            "        ckan.logic.schema.default_create_vocabulary_schema()",
            "",
            "    _check_access('vocabulary_create', context, data_dict)",
            "",
            "    data, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    vocabulary = model_save.vocabulary_dict_save(data, context)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug('Created Vocabulary %s' % vocabulary.name)",
            "",
            "    return model_dictize.vocabulary_dictize(vocabulary, context)",
            "",
            "",
            "def activity_create(context, activity_dict, **kw):",
            "    '''Create a new activity stream activity.",
            "",
            "    You must be a sysadmin to create new activities.",
            "",
            "    :param user_id: the name or id of the user who carried out the activity,",
            "        e.g. ``'seanh'``",
            "    :type user_id: string",
            "    :param object_id: the name or id of the object of the activity, e.g.",
            "        ``'my_dataset'``",
            "    :param activity_type: the type of the activity, this must be an activity",
            "        type that CKAN knows how to render, e.g. ``'new package'``,",
            "        ``'changed user'``, ``'deleted group'`` etc.",
            "    :type activity_type: string",
            "    :param data: any additional data about the activity",
            "    :type data: dictionary",
            "",
            "    :returns: the newly created activity",
            "    :rtype: dictionary",
            "",
            "    '''",
            "",
            "    _check_access('activity_create', context, activity_dict)",
            "",
            "    # this action had a ignore_auth param which has been removed",
            "    # removed in 2.2",
            "    if 'ignore_auth' in kw:",
            "        raise Exception('Activity Stream calling parameters have changed '",
            "                        'ignore_auth must be passed in the context not as '",
            "                        'a param')",
            "",
            "    if not ckan.common.asbool(",
            "            config.get('ckan.activity_streams_enabled', 'true')):",
            "        return",
            "",
            "    model = context['model']",
            "",
            "    # Any revision_id that the caller attempts to pass in the activity_dict is",
            "    # ignored and removed here.",
            "    if 'revision_id' in activity_dict:",
            "        del activity_dict['revision_id']",
            "",
            "    schema = context.get('schema') or \\",
            "        ckan.logic.schema.default_create_activity_schema()",
            "",
            "    data, errors = _validate(activity_dict, schema, context)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    activity = model_save.activity_dict_save(data, context)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(\"Created '%s' activity\" % activity.activity_type)",
            "    return model_dictize.activity_dictize(activity, context)",
            "",
            "",
            "def tag_create(context, data_dict):",
            "    '''Create a new vocabulary tag.",
            "",
            "    You must be a sysadmin to create vocabulary tags.",
            "",
            "    You can only use this function to create tags that belong to a vocabulary,",
            "    not to create free tags. (To create a new free tag simply add the tag to",
            "    a package, e.g. using the",
            "    :py:func:`~ckan.logic.action.update.package_update` function.)",
            "",
            "    :param name: the name for the new tag, a string between 2 and 100",
            "        characters long containing only alphanumeric characters and ``-``,",
            "        ``_`` and ``.``, e.g. ``'Jazz'``",
            "    :type name: string",
            "    :param vocabulary_id: the id of the vocabulary that the new tag",
            "        should be added to, e.g. the id of vocabulary ``'Genre'``",
            "    :type vocabulary_id: string",
            "",
            "    :returns: the newly-created tag",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "",
            "    _check_access('tag_create', context, data_dict)",
            "",
            "    schema = context.get('schema') or \\",
            "        ckan.logic.schema.default_create_tag_schema()",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    tag = model_save.tag_dict_save(data_dict, context)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(\"Created tag '%s' \" % tag)",
            "    return model_dictize.tag_dictize(tag, context)",
            "",
            "",
            "def follow_user(context, data_dict):",
            "    '''Start following another user.",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param id: the id or name of the user to follow, e.g. ``'joeuser'``",
            "    :type id: string",
            "",
            "    :returns: a representation of the 'follower' relationship between yourself",
            "        and the other user",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    if 'user' not in context:",
            "        raise NotAuthorized(_(\"You must be logged in to follow users\"))",
            "",
            "    model = context['model']",
            "    session = context['session']",
            "",
            "    userobj = model.User.get(context['user'])",
            "    if not userobj:",
            "        raise NotAuthorized(_(\"You must be logged in to follow users\"))",
            "",
            "    schema = (context.get('schema')",
            "              or ckan.logic.schema.default_follow_user_schema())",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # Don't let a user follow herself.",
            "    if userobj.id == validated_data_dict['id']:",
            "        message = _('You cannot follow yourself')",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    # Don't let a user follow someone she is already following.",
            "    if model.UserFollowingUser.is_following(userobj.id,",
            "                                            validated_data_dict['id']):",
            "        followeduserobj = model.User.get(validated_data_dict['id'])",
            "        name = followeduserobj.display_name",
            "        message = _('You are already following {0}').format(name)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    follower = model_save.follower_dict_save(",
            "        validated_data_dict, context, model.UserFollowingUser)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(u'User {follower} started following user {object}'.format(",
            "        follower=follower.follower_id, object=follower.object_id))",
            "",
            "    return model_dictize.user_following_user_dictize(follower, context)",
            "",
            "",
            "def follow_dataset(context, data_dict):",
            "    '''Start following a dataset.",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param id: the id or name of the dataset to follow, e.g. ``'warandpeace'``",
            "    :type id: string",
            "",
            "    :returns: a representation of the 'follower' relationship between yourself",
            "        and the dataset",
            "    :rtype: dictionary",
            "",
            "    '''",
            "",
            "    if 'user' not in context:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a dataset.\"))",
            "",
            "    model = context['model']",
            "    session = context['session']",
            "",
            "    userobj = model.User.get(context['user'])",
            "    if not userobj:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a dataset.\"))",
            "",
            "    schema = (context.get('schema')",
            "              or ckan.logic.schema.default_follow_dataset_schema())",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # Don't let a user follow a dataset she is already following.",
            "    if model.UserFollowingDataset.is_following(userobj.id,",
            "                                               validated_data_dict['id']):",
            "        # FIXME really package model should have this logic and provide",
            "        # 'display_name' like users and groups",
            "        pkgobj = model.Package.get(validated_data_dict['id'])",
            "        name = pkgobj.title or pkgobj.name or pkgobj.id",
            "        message = _(",
            "            'You are already following {0}').format(name)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    follower = model_save.follower_dict_save(validated_data_dict, context,",
            "                                             model.UserFollowingDataset)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(u'User {follower} started following dataset {object}'.format(",
            "        follower=follower.follower_id, object=follower.object_id))",
            "",
            "    return model_dictize.user_following_dataset_dictize(follower, context)",
            "",
            "",
            "def _group_or_org_member_create(context, data_dict, is_org=False):",
            "    # creator of group/org becomes an admin",
            "    # this needs to be after the repo.commit or else revisions break",
            "    model = context['model']",
            "    user = context['user']",
            "    session = context['session']",
            "",
            "    schema = ckan.logic.schema.member_schema()",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    username = _get_or_bust(data_dict, 'username')",
            "    role = data_dict.get('role')",
            "    group_id = data_dict.get('id')",
            "    group = model.Group.get(group_id)",
            "    if not group:",
            "        msg = _('Organization not found') if is_org else _('Group not found')",
            "        raise NotFound(msg)",
            "    result = model.User.get(username)",
            "    if result:",
            "        user_id = result.id",
            "    else:",
            "        message = _(u'User {username} does not exist.').format(",
            "            username=username)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "    member_dict = {",
            "        'id': group.id,",
            "        'object': user_id,",
            "        'object_type': 'user',",
            "        'capacity': role,",
            "    }",
            "    member_create_context = {",
            "        'model': model,",
            "        'user': user,",
            "        'session': session,",
            "        'ignore_auth': context.get('ignore_auth'),",
            "    }",
            "    return logic.get_action('member_create')(member_create_context,",
            "                                             member_dict)",
            "",
            "",
            "def group_member_create(context, data_dict):",
            "    '''Make a user a member of a group.",
            "",
            "    You must be authorized to edit the group.",
            "",
            "    :param id: the id or name of the group",
            "    :type id: string",
            "    :param username: name or id of the user to be made member of the group",
            "    :type username: string",
            "    :param role: role of the user in the group. One of ``member``, ``editor``,",
            "        or ``admin``",
            "    :type role: string",
            "",
            "    :returns: the newly created (or updated) membership",
            "    :rtype: dictionary",
            "    '''",
            "    _check_access('group_member_create', context, data_dict)",
            "    return _group_or_org_member_create(context, data_dict)",
            "",
            "",
            "def organization_member_create(context, data_dict):",
            "    '''Make a user a member of an organization.",
            "",
            "    You must be authorized to edit the organization.",
            "",
            "    :param id: the id or name of the organization",
            "    :type id: string",
            "    :param username: name or id of the user to be made member of the",
            "        organization",
            "    :type username: string",
            "    :param role: role of the user in the organization. One of ``member``,",
            "        ``editor``, or ``admin``",
            "    :type role: string",
            "",
            "    :returns: the newly created (or updated) membership",
            "    :rtype: dictionary",
            "    '''",
            "    _check_access('organization_member_create', context, data_dict)",
            "    return _group_or_org_member_create(context, data_dict, is_org=True)",
            "",
            "",
            "def follow_group(context, data_dict):",
            "    '''Start following a group.",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param id: the id or name of the group to follow, e.g. ``'roger'``",
            "    :type id: string",
            "",
            "    :returns: a representation of the 'follower' relationship between yourself",
            "        and the group",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    if 'user' not in context:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a group.\"))",
            "",
            "    model = context['model']",
            "    session = context['session']",
            "",
            "    userobj = model.User.get(context['user'])",
            "    if not userobj:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a group.\"))",
            "",
            "    schema = context.get('schema',",
            "                         ckan.logic.schema.default_follow_group_schema())",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # Don't let a user follow a group she is already following.",
            "    if model.UserFollowingGroup.is_following(userobj.id,",
            "                                             validated_data_dict['id']):",
            "        groupobj = model.Group.get(validated_data_dict['id'])",
            "        name = groupobj.display_name",
            "        message = _(",
            "            'You are already following {0}').format(name)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    follower = model_save.follower_dict_save(validated_data_dict, context,",
            "                                             model.UserFollowingGroup)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(u'User {follower} started following group {object}'.format(",
            "        follower=follower.follower_id, object=follower.object_id))",
            "",
            "    return model_dictize.user_following_group_dictize(follower, context)",
            "",
            "",
            "def api_token_create(context, data_dict):",
            "    \"\"\"Create new API Token for current user.",
            "",
            "    Apart from the `user` and `name` field that are required by",
            "    default implementation, there may be additional fields registered",
            "    by extensions.",
            "",
            "    :param user: name or id of the user who owns new API Token",
            "    :type user: string",
            "    :param name: distinctive name for API Token",
            "    :type name: string",
            "",
            "    :returns: Returns a dict with the key \"token\" containing the",
            "              encoded token value. Extensions can privide additional",
            "              fields via `add_extra` method of",
            "              :py:class:`~ckan.plugins.interfaces.IApiToken`",
            "    :rtype: dictionary",
            "",
            "    \"\"\"",
            "    model = context[u'model']",
            "    user, name = _get_or_bust(data_dict, [u'user', u'name'])",
            "",
            "    if model.User.get(user) is None:",
            "        raise NotFound(\"User not found\")",
            "",
            "    _check_access(u'api_token_create', context, data_dict)",
            "",
            "    schema = context.get(u'schema')",
            "    if not schema:",
            "        schema = api_token.get_schema()",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    token_obj = model_save.api_token_save(",
            "        {u'user': user, u'name': name}, context",
            "    )",
            "    model.Session.commit()",
            "    data = {",
            "        u'jti': token_obj.id,",
            "        u'iat': api_token.into_seconds(token_obj.created_at)",
            "    }",
            "",
            "    data = api_token.postprocess(data, token_obj.id, validated_data_dict)",
            "    token = api_token.encode(data)",
            "",
            "    result = api_token.add_extra({u'token': token})",
            "    return result"
        ],
        "afterPatchFile": [
            "# encoding: utf-8",
            "",
            "'''API functions for adding data to CKAN.'''",
            "",
            "import logging",
            "import random",
            "import re",
            "from socket import error as socket_error",
            "import datetime",
            "",
            "import six",
            "",
            "import ckan.common",
            "from sqlalchemy import func",
            "",
            "import ckan.lib.plugins as lib_plugins",
            "import ckan.logic as logic",
            "import ckan.plugins as plugins",
            "import ckan.lib.dictization",
            "import ckan.logic.action",
            "import ckan.logic.schema",
            "import ckan.lib.dictization.model_dictize as model_dictize",
            "import ckan.lib.dictization.model_save as model_save",
            "import ckan.lib.navl.dictization_functions",
            "import ckan.lib.uploader as uploader",
            "import ckan.lib.mailer as mailer",
            "import ckan.lib.datapreview",
            "import ckan.lib.api_token as api_token",
            "import ckan.authz as authz",
            "",
            "from ckan.common import _, config",
            "",
            "# FIXME this looks nasty and should be shared better",
            "from ckan.logic.action.update import _update_package_relationship",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "# Define some shortcuts",
            "# Ensure they are module-private so that they don't get loaded as available",
            "# actions in the action API.",
            "_validate = ckan.lib.navl.dictization_functions.validate",
            "_check_access = logic.check_access",
            "_get_action = logic.get_action",
            "ValidationError = logic.ValidationError",
            "NotFound = logic.NotFound",
            "NotAuthorized = logic.NotAuthorized",
            "_get_or_bust = logic.get_or_bust",
            "",
            "",
            "def package_create(context, data_dict):",
            "    '''Create a new dataset (package).",
            "",
            "    You must be authorized to create new datasets. If you specify any groups",
            "    for the new dataset, you must also be authorized to edit these groups.",
            "",
            "    Plugins may change the parameters of this function depending on the value",
            "    of the ``type`` parameter, see the",
            "    :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugin interface.",
            "",
            "    :param name: the name of the new dataset, must be between 2 and 100",
            "        characters long and contain only lowercase alphanumeric characters,",
            "        ``-`` and ``_``, e.g. ``'warandpeace'``",
            "    :type name: string",
            "    :param title: the title of the dataset (optional, default: same as",
            "        ``name``)",
            "    :type title: string",
            "    :param private: If ``True`` creates a private dataset",
            "    :type private: bool",
            "    :param author: the name of the dataset's author (optional)",
            "    :type author: string",
            "    :param author_email: the email address of the dataset's author (optional)",
            "    :type author_email: string",
            "    :param maintainer: the name of the dataset's maintainer (optional)",
            "    :type maintainer: string",
            "    :param maintainer_email: the email address of the dataset's maintainer",
            "        (optional)",
            "    :type maintainer_email: string",
            "    :param license_id: the id of the dataset's license, see",
            "        :py:func:`~ckan.logic.action.get.license_list` for available values",
            "        (optional)",
            "    :type license_id: license id string",
            "    :param notes: a description of the dataset (optional)",
            "    :type notes: string",
            "    :param url: a URL for the dataset's source (optional)",
            "    :type url: string",
            "    :param version: (optional)",
            "    :type version: string, no longer than 100 characters",
            "    :param state: the current state of the dataset, e.g. ``'active'`` or",
            "        ``'deleted'``, only active datasets show up in search results and",
            "        other lists of datasets, this parameter will be ignored if you are not",
            "        authorized to change the state of the dataset (optional, default:",
            "        ``'active'``)",
            "    :type state: string",
            "    :param type: the type of the dataset (optional),",
            "        :py:class:`~ckan.plugins.interfaces.IDatasetForm` plugins",
            "        associate themselves with different dataset types and provide custom",
            "        dataset handling behaviour for these types",
            "    :type type: string",
            "    :param resources: the dataset's resources, see",
            "        :py:func:`resource_create` for the format of resource dictionaries",
            "        (optional)",
            "    :type resources: list of resource dictionaries",
            "    :param tags: the dataset's tags, see :py:func:`tag_create` for the format",
            "        of tag dictionaries (optional)",
            "    :type tags: list of tag dictionaries",
            "    :param extras: the dataset's extras (optional), extras are arbitrary",
            "        (key: value) metadata items that can be added to datasets, each extra",
            "        dictionary should have keys ``'key'`` (a string), ``'value'`` (a",
            "        string)",
            "    :type extras: list of dataset extra dictionaries",
            "    :param relationships_as_object: see :py:func:`package_relationship_create`",
            "        for the format of relationship dictionaries (optional)",
            "    :type relationships_as_object: list of relationship dictionaries",
            "    :param relationships_as_subject: see :py:func:`package_relationship_create`",
            "        for the format of relationship dictionaries (optional)",
            "    :type relationships_as_subject: list of relationship dictionaries",
            "    :param groups: the groups to which the dataset belongs (optional), each",
            "        group dictionary should have one or more of the following keys which",
            "        identify an existing group:",
            "        ``'id'`` (the id of the group, string), or ``'name'`` (the name of the",
            "        group, string),  to see which groups exist",
            "        call :py:func:`~ckan.logic.action.get.group_list`",
            "    :type groups: list of dictionaries",
            "    :param owner_org: the id of the dataset's owning organization, see",
            "        :py:func:`~ckan.logic.action.get.organization_list` or",
            "        :py:func:`~ckan.logic.action.get.organization_list_for_user` for",
            "        available values. This parameter can be made optional if the config",
            "        option :ref:`ckan.auth.create_unowned_dataset` is set to ``True``.",
            "    :type owner_org: string",
            "",
            "    :returns: the newly created dataset (unless 'return_id_only' is set to True",
            "              in the context, in which case just the dataset id will",
            "              be returned)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    session = context['session']",
            "    user = context['user']",
            "",
            "    if 'type' not in data_dict:",
            "        package_plugin = lib_plugins.lookup_package_plugin()",
            "        try:",
            "            # use first type as default if user didn't provide type",
            "            package_type = package_plugin.package_types()[0]",
            "        except (AttributeError, IndexError):",
            "            package_type = 'dataset'",
            "            # in case a 'dataset' plugin was registered w/o fallback",
            "            package_plugin = lib_plugins.lookup_package_plugin(package_type)",
            "        data_dict['type'] = package_type",
            "    else:",
            "        package_plugin = lib_plugins.lookup_package_plugin(data_dict['type'])",
            "",
            "    if 'schema' in context:",
            "        schema = context['schema']",
            "    else:",
            "        schema = package_plugin.create_package_schema()",
            "",
            "    _check_access('package_create', context, data_dict)",
            "",
            "    if 'api_version' not in context:",
            "        # check_data_dict() is deprecated. If the package_plugin has a",
            "        # check_data_dict() we'll call it, if it doesn't have the method we'll",
            "        # do nothing.",
            "        check_data_dict = getattr(package_plugin, 'check_data_dict', None)",
            "        if check_data_dict:",
            "            try:",
            "                check_data_dict(data_dict, schema)",
            "            except TypeError:",
            "                # Old plugins do not support passing the schema so we need",
            "                # to ensure they still work",
            "                package_plugin.check_data_dict(data_dict)",
            "",
            "    data, errors = lib_plugins.plugin_validate(",
            "        package_plugin, context, data_dict, schema, 'package_create')",
            "    log.debug('package_create validate_errs=%r user=%s package=%s data=%r',",
            "              errors, context.get('user'),",
            "              data.get('name'), data_dict)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    if user:",
            "",
            "        user_obj = model.User.by_name(six.ensure_text(user))",
            "        if user_obj:",
            "            data['creator_user_id'] = user_obj.id",
            "",
            "    pkg = model_save.package_dict_save(data, context)",
            "",
            "    # Needed to let extensions know the package and resources ids",
            "    model.Session.flush()",
            "    data['id'] = pkg.id",
            "    if data.get('resources'):",
            "        for index, resource in enumerate(data['resources']):",
            "            resource['id'] = pkg.resources[index].id",
            "",
            "    context_org_update = context.copy()",
            "    context_org_update['ignore_auth'] = True",
            "    context_org_update['defer_commit'] = True",
            "    _get_action('package_owner_org_update')(context_org_update,",
            "                                            {'id': pkg.id,",
            "                                             'organization_id': pkg.owner_org})",
            "",
            "    for item in plugins.PluginImplementations(plugins.IPackageController):",
            "        item.create(pkg)",
            "",
            "        item.after_create(context, data)",
            "",
            "    # Make sure that a user provided schema is not used in create_views",
            "    # and on package_show",
            "    context.pop('schema', None)",
            "",
            "    # Create default views for resources if necessary",
            "    if data.get('resources'):",
            "        logic.get_action('package_create_default_resource_views')(",
            "            {'model': context['model'], 'user': context['user'],",
            "             'ignore_auth': True},",
            "            {'package': data})",
            "",
            "    # Create activity",
            "    if not pkg.private:",
            "        user_obj = model.User.by_name(user)",
            "        if user_obj:",
            "            user_id = user_obj.id",
            "        else:",
            "            user_id = 'not logged in'",
            "",
            "        activity = pkg.activity_stream_item('new', user_id)",
            "        session.add(activity)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    return_id_only = context.get('return_id_only', False)",
            "",
            "    if return_id_only:",
            "        return pkg.id",
            "",
            "    return _get_action('package_show')(",
            "        context.copy(), {'id': pkg.id}",
            "    )",
            "",
            "",
            "def resource_create(context, data_dict):",
            "    '''Appends a new resource to a datasets list of resources.",
            "",
            "    :param package_id: id of package that the resource should be added to.",
            "",
            "    :type package_id: string",
            "    :param url: url of resource",
            "    :type url: string",
            "    :param description: (optional)",
            "    :type description: string",
            "    :param format: (optional)",
            "    :type format: string",
            "    :param hash: (optional)",
            "    :type hash: string",
            "    :param name: (optional)",
            "    :type name: string",
            "    :param resource_type: (optional)",
            "    :type resource_type: string",
            "    :param mimetype: (optional)",
            "    :type mimetype: string",
            "    :param mimetype_inner: (optional)",
            "    :type mimetype_inner: string",
            "    :param cache_url: (optional)",
            "    :type cache_url: string",
            "    :param size: (optional)",
            "    :type size: int",
            "    :param created: (optional)",
            "    :type created: iso date string",
            "    :param last_modified: (optional)",
            "    :type last_modified: iso date string",
            "    :param cache_last_updated: (optional)",
            "    :type cache_last_updated: iso date string",
            "    :param upload: (optional)",
            "    :type upload: FieldStorage (optional) needs multipart/form-data",
            "",
            "    :returns: the newly created resource",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context['user']",
            "",
            "    package_id = _get_or_bust(data_dict, 'package_id')",
            "    if not data_dict.get('url'):",
            "        data_dict['url'] = ''",
            "",
            "    package_show_context = dict(context, for_update=True, return_type='dict')",
            "    pkg_dict = _get_action('package_show')(",
            "        package_show_context,",
            "        {'id': package_id})",
            "",
            "    _check_access('resource_create', context, data_dict)",
            "",
            "    for plugin in plugins.PluginImplementations(plugins.IResourceController):",
            "        plugin.before_create(context, data_dict)",
            "",
            "    if 'resources' not in pkg_dict:",
            "        pkg_dict['resources'] = []",
            "",
            "    upload = uploader.get_resource_uploader(data_dict)",
            "",
            "    if 'mimetype' not in data_dict:",
            "        if hasattr(upload, 'mimetype'):",
            "            data_dict['mimetype'] = upload.mimetype",
            "",
            "    if 'size' not in data_dict:",
            "        if hasattr(upload, 'filesize'):",
            "            data_dict['size'] = upload.filesize",
            "",
            "    pkg_dict['resources'].append(data_dict)",
            "",
            "    try:",
            "        context['defer_commit'] = True",
            "        context['use_cache'] = False",
            "        _get_action('package_update')(context, pkg_dict)",
            "        context.pop('defer_commit')",
            "    except ValidationError as e:",
            "        try:",
            "            raise ValidationError(e.error_dict['resources'][-1])",
            "        except (KeyError, IndexError):",
            "            raise ValidationError(e.error_dict)",
            "",
            "    # Get out resource_id resource from model as it will not appear in",
            "    # package_show until after commit",
            "    upload.upload(context['package'].resources[-1].id,",
            "                  uploader.get_max_resource_size())",
            "",
            "    model.repo.commit()",
            "",
            "    #  Run package show again to get out actual last_resource",
            "    updated_pkg_dict = _get_action('package_show')(context, {'id': package_id})",
            "    resource = updated_pkg_dict['resources'][-1]",
            "",
            "    #  Add the default views to the new resource",
            "    logic.get_action('resource_create_default_resource_views')(",
            "        {'model': context['model'],",
            "         'user': context['user'],",
            "         'ignore_auth': True",
            "         },",
            "        {'resource': resource,",
            "         'package': updated_pkg_dict",
            "         })",
            "",
            "    for plugin in plugins.PluginImplementations(plugins.IResourceController):",
            "        plugin.after_create(context, resource)",
            "",
            "    return resource",
            "",
            "",
            "def resource_view_create(context, data_dict):",
            "    '''Creates a new resource view.",
            "",
            "    :param resource_id: id of the resource",
            "    :type resource_id: string",
            "    :param title: the title of the view",
            "    :type title: string",
            "    :param description: a description of the view (optional)",
            "    :type description: string",
            "    :param view_type: type of view",
            "    :type view_type: string",
            "    :param config: options necessary to recreate a view state (optional)",
            "    :type config: JSON string",
            "",
            "    :returns: the newly created resource view",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "",
            "    resource_id = _get_or_bust(data_dict, 'resource_id')",
            "    view_type = _get_or_bust(data_dict, 'view_type')",
            "    view_plugin = ckan.lib.datapreview.get_view_plugin(view_type)",
            "",
            "    if not view_plugin:",
            "        raise ValidationError(",
            "            {\"view_type\": \"No plugin found for view_type {view_type}\".format(",
            "                view_type=view_type",
            "            )}",
            "        )",
            "",
            "    default = logic.schema.default_create_resource_view_schema(view_plugin)",
            "    schema = context.get('schema', default)",
            "    plugin_schema = view_plugin.info().get('schema', {})",
            "    schema.update(plugin_schema)",
            "",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    _check_access('resource_view_create', context, data_dict)",
            "",
            "    if context.get('preview'):",
            "        return data",
            "",
            "    max_order = model.Session.query(",
            "        func.max(model.ResourceView.order)",
            "    ).filter_by(resource_id=resource_id).first()",
            "",
            "    order = 0",
            "    if max_order[0] is not None:",
            "        order = max_order[0] + 1",
            "    data['order'] = order",
            "",
            "    resource_view = model_save.resource_view_dict_save(data, context)",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "    return model_dictize.resource_view_dictize(resource_view, context)",
            "",
            "",
            "def resource_create_default_resource_views(context, data_dict):",
            "    '''",
            "    Creates the default views (if necessary) on the provided resource",
            "",
            "    The function will get the plugins for the default views defined in",
            "    the configuration, and if some were found the `can_view` method of",
            "    each one of them will be called to determine if a resource view should",
            "    be created. Resource views extensions get the resource dict and the",
            "    parent dataset dict.",
            "",
            "    If the latter is not provided, `package_show` is called to get it.",
            "",
            "    By default only view plugins that don't require the resource data to be in",
            "    the DataStore are called. See",
            "    :py:func:`ckan.logic.action.create.package_create_default_resource_views.``",
            "    for details on the ``create_datastore_views`` parameter.",
            "",
            "    :param resource: full resource dict",
            "    :type resource: dict",
            "    :param package: full dataset dict (optional, if not provided",
            "        :py:func:`~ckan.logic.action.get.package_show` will be called).",
            "    :type package: dict",
            "    :param create_datastore_views: whether to create views that rely on data",
            "        being on the DataStore (optional, defaults to False)",
            "    :type create_datastore_views: bool",
            "",
            "    :returns: a list of resource views created (empty if none were created)",
            "    :rtype: list of dictionaries",
            "    '''",
            "",
            "    resource_dict = _get_or_bust(data_dict, 'resource')",
            "",
            "    _check_access('resource_create_default_resource_views', context, data_dict)",
            "",
            "    dataset_dict = data_dict.get('package')",
            "",
            "    create_datastore_views = ckan.common.asbool(",
            "        data_dict.get('create_datastore_views', False))",
            "",
            "    return ckan.lib.datapreview.add_views_to_resource(",
            "        context,",
            "        resource_dict,",
            "        dataset_dict,",
            "        view_types=[],",
            "        create_datastore_views=create_datastore_views)",
            "",
            "",
            "def package_create_default_resource_views(context, data_dict):",
            "    '''",
            "    Creates the default views on all resources of the provided dataset",
            "",
            "    By default only view plugins that don't require the resource data to be in",
            "    the DataStore are called. Passing `create_datastore_views` as True will",
            "    only create views that require data to be in the DataStore. The first case",
            "    happens when the function is called from `package_create` or",
            "    `package_update`, the second when it's called from the DataPusher when",
            "    data was uploaded to the DataStore.",
            "",
            "    :param package: full dataset dict (ie the one obtained",
            "        calling :py:func:`~ckan.logic.action.get.package_show`).",
            "    :type package: dict",
            "    :param create_datastore_views: whether to create views that rely on data",
            "        being on the DataStore (optional, defaults to False)",
            "    :type create_datastore_views: bool",
            "",
            "    :returns: a list of resource views created (empty if none were created)",
            "    :rtype: list of dictionaries",
            "    '''",
            "",
            "    dataset_dict = _get_or_bust(data_dict, 'package')",
            "",
            "    _check_access('package_create_default_resource_views', context, data_dict)",
            "",
            "    create_datastore_views = ckan.common.asbool(",
            "        data_dict.get('create_datastore_views', False))",
            "",
            "    return ckan.lib.datapreview.add_views_to_dataset_resources(",
            "        context,",
            "        dataset_dict,",
            "        view_types=[],",
            "        create_datastore_views=create_datastore_views)",
            "",
            "",
            "def package_relationship_create(context, data_dict):",
            "    '''Create a relationship between two datasets (packages).",
            "",
            "    You must be authorized to edit both the subject and the object datasets.",
            "",
            "    :param subject: the id or name of the dataset that is the subject of the",
            "        relationship",
            "    :type subject: string",
            "    :param object: the id or name of the dataset that is the object of the",
            "        relationship",
            "    :param type: the type of the relationship, one of ``'depends_on'``,",
            "        ``'dependency_of'``, ``'derives_from'``, ``'has_derivation'``,",
            "        ``'links_to'``, ``'linked_from'``, ``'child_of'`` or ``'parent_of'``",
            "    :type type: string",
            "    :param comment: a comment about the relationship (optional)",
            "    :type comment: string",
            "",
            "    :returns: the newly created package relationship",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context['user']",
            "    schema = context.get('schema') \\",
            "        or ckan.logic.schema.default_create_relationship_schema()",
            "    api = context.get('api_version')",
            "    ref_package_by = 'id' if api == 2 else 'name'",
            "",
            "    id, id2, rel_type = _get_or_bust(data_dict, ['subject', 'object', 'type'])",
            "    comment = data_dict.get('comment', u'')",
            "",
            "    pkg1 = model.Package.get(id)",
            "    pkg2 = model.Package.get(id2)",
            "    if not pkg1:",
            "        raise NotFound('Subject package %r was not found.' % id)",
            "    if not pkg2:",
            "        return NotFound('Object package %r was not found.' % id2)",
            "",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    _check_access('package_relationship_create', context, data_dict)",
            "",
            "    # Create a Package Relationship.",
            "    existing_rels = pkg1.get_relationships_with(pkg2, rel_type)",
            "    if existing_rels:",
            "        return _update_package_relationship(existing_rels[0],",
            "                                            comment, context)",
            "    rel = pkg1.add_relationship(rel_type, pkg2, comment=comment)",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit_and_remove()",
            "    context['relationship'] = rel",
            "",
            "    relationship_dicts = rel.as_dict(ref_package_by=ref_package_by)",
            "    return relationship_dicts",
            "",
            "",
            "def member_create(context, data_dict=None):",
            "    '''Make an object (e.g. a user, dataset or group) a member of a group.",
            "",
            "    If the object is already a member of the group then the capacity of the",
            "    membership will be updated.",
            "",
            "    You must be authorized to edit the group.",
            "",
            "    :param id: the id or name of the group to add the object to",
            "    :type id: string",
            "    :param object: the id or name of the object to add",
            "    :type object: string",
            "    :param object_type: the type of the object being added, e.g. ``'package'``",
            "        or ``'user'``",
            "    :type object_type: string",
            "    :param capacity: the capacity of the membership",
            "    :type capacity: string",
            "",
            "    :returns: the newly created (or updated) membership",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context['user']",
            "",
            "    group_id, obj_id, obj_type, capacity = \\",
            "        _get_or_bust(data_dict, ['id', 'object', 'object_type', 'capacity'])",
            "",
            "    group = model.Group.get(group_id)",
            "    if not group:",
            "        raise NotFound('Group was not found.')",
            "",
            "    obj_class = ckan.logic.model_name_to_class(model, obj_type)",
            "    obj = obj_class.get(obj_id)",
            "    if not obj:",
            "        raise NotFound('%s was not found.' % obj_type.title())",
            "",
            "    _check_access('member_create', context, data_dict)",
            "",
            "    # Look up existing, in case it exists",
            "    member = model.Session.query(model.Member).\\",
            "        filter(model.Member.table_name == obj_type).\\",
            "        filter(model.Member.table_id == obj.id).\\",
            "        filter(model.Member.group_id == group.id).\\",
            "        filter(model.Member.state == 'active').first()",
            "    if member:",
            "        user_obj = model.User.get(user)",
            "        if member.table_name == u'user' and \\",
            "                member.table_id == user_obj.id and \\",
            "                member.capacity == u'admin' and \\",
            "                capacity != u'admin':",
            "            raise NotAuthorized(\"Administrators cannot revoke their \"",
            "                                \"own admin status\")",
            "    else:",
            "        member = model.Member(table_name=obj_type,",
            "                              table_id=obj.id,",
            "                              group_id=group.id,",
            "                              state='active')",
            "        member.group = group",
            "    member.capacity = capacity",
            "",
            "    model.Session.add(member)",
            "    model.repo.commit()",
            "",
            "    return model_dictize.member_dictize(member, context)",
            "",
            "",
            "def package_collaborator_create(context, data_dict):",
            "    '''Make a user a collaborator in a dataset.",
            "",
            "    If the user is already a collaborator in the dataset then their",
            "    capacity will be updated.",
            "",
            "    Currently you must be an Admin on the dataset owner organization to",
            "    manage collaborators.",
            "",
            "    Note: This action requires the collaborators feature to be enabled with",
            "    the :ref:`ckan.auth.allow_dataset_collaborators` configuration option.",
            "",
            "    :param id: the id or name of the dataset",
            "    :type id: string",
            "    :param user_id: the id or name of the user to add or edit",
            "    :type user_id: string",
            "    :param capacity: the capacity or role of the membership. Must be one of",
            "        \"editor\" or \"member\". Additionally",
            "        if :ref:`ckan.auth.allow_admin_collaborators` is set to True, \"admin\"",
            "        is also allowed.",
            "    :type capacity: string",
            "",
            "    :returns: the newly created (or updated) collaborator",
            "    :rtype: dictionary",
            "    '''",
            "",
            "    model = context['model']",
            "",
            "    package_id, user_id, capacity = _get_or_bust(",
            "        data_dict,",
            "        ['id', 'user_id', 'capacity']",
            "    )",
            "",
            "    allowed_capacities = authz.get_collaborator_capacities()",
            "    if capacity not in allowed_capacities:",
            "        raise ValidationError(",
            "            _('Role must be one of \"{}\"').format(', '.join(",
            "                allowed_capacities)))",
            "",
            "    _check_access('package_collaborator_create', context, data_dict)",
            "",
            "    package = model.Package.get(package_id)",
            "    if not package:",
            "        raise NotFound(_('Dataset not found'))",
            "",
            "    user = model.User.get(user_id)",
            "    if not user:",
            "        raise NotFound(_('User not found'))",
            "",
            "    if not authz.check_config_permission('allow_dataset_collaborators'):",
            "        raise ValidationError(_('Dataset collaborators not enabled'))",
            "",
            "    # Check if collaborator already exists",
            "    collaborator = model.Session.query(model.PackageMember). \\",
            "        filter(model.PackageMember.package_id == package.id). \\",
            "        filter(model.PackageMember.user_id == user.id).one_or_none()",
            "    if not collaborator:",
            "        collaborator = model.PackageMember(",
            "            package_id=package.id,",
            "            user_id=user.id)",
            "    collaborator.capacity = capacity",
            "    collaborator.modified = datetime.datetime.utcnow()",
            "    model.Session.add(collaborator)",
            "    model.repo.commit()",
            "",
            "    log.info('User {} added as collaborator in package {} ({})'.format(",
            "        user.name, package.id, capacity))",
            "",
            "    return model_dictize.member_dictize(collaborator, context)",
            "",
            "",
            "def _group_or_org_create(context, data_dict, is_org=False):",
            "    model = context['model']",
            "    user = context['user']",
            "    session = context['session']",
            "    data_dict['is_organization'] = is_org",
            "",
            "    upload = uploader.get_uploader('group')",
            "    upload.update_data_dict(data_dict, 'image_url',",
            "                            'image_upload', 'clear_upload')",
            "    # get the schema",
            "    group_type = data_dict.get('type', 'organization' if is_org else 'group')",
            "    group_plugin = lib_plugins.lookup_group_plugin(group_type)",
            "    try:",
            "        schema = group_plugin.form_to_db_schema_options({",
            "            'type': 'create', 'api': 'api_version' in context,",
            "            'context': context})",
            "    except AttributeError:",
            "        schema = group_plugin.form_to_db_schema()",
            "",
            "    if 'api_version' not in context:",
            "        # old plugins do not support passing the schema so we need",
            "        # to ensure they still work",
            "        try:",
            "            group_plugin.check_data_dict(data_dict, schema)",
            "        except TypeError:",
            "            group_plugin.check_data_dict(data_dict)",
            "",
            "    data, errors = lib_plugins.plugin_validate(",
            "        group_plugin, context, data_dict, schema,",
            "        'organization_create' if is_org else 'group_create')",
            "    log.debug('group_create validate_errs=%r user=%s group=%s data_dict=%r',",
            "              errors, context.get('user'), data_dict.get('name'), data_dict)",
            "",
            "    if errors:",
            "        session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    group = model_save.group_dict_save(data, context)",
            "",
            "    # Needed to let extensions know the group id",
            "    session.flush()",
            "",
            "    if is_org:",
            "        plugin_type = plugins.IOrganizationController",
            "    else:",
            "        plugin_type = plugins.IGroupController",
            "",
            "    for item in plugins.PluginImplementations(plugin_type):",
            "        item.create(group)",
            "",
            "    if is_org:",
            "        activity_type = 'new organization'",
            "    else:",
            "        activity_type = 'new group'",
            "",
            "    user_id = model.User.by_name(six.ensure_text(user)).id",
            "",
            "    activity_dict = {",
            "        'user_id': user_id,",
            "        'object_id': group.id,",
            "        'activity_type': activity_type,",
            "    }",
            "    activity_dict['data'] = {",
            "        'group': ckan.lib.dictization.table_dictize(group, context)",
            "    }",
            "    activity_create_context = {",
            "        'model': model,",
            "        'user': user,",
            "        'defer_commit': True,",
            "        'ignore_auth': True,",
            "        'session': session",
            "    }",
            "    logic.get_action('activity_create')(activity_create_context, activity_dict)",
            "",
            "    upload.upload(uploader.get_max_image_size())",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "    context[\"group\"] = group",
            "    context[\"id\"] = group.id",
            "",
            "    # creator of group/org becomes an admin",
            "    # this needs to be after the repo.commit or else revisions break",
            "    member_dict = {",
            "        'id': group.id,",
            "        'object': user_id,",
            "        'object_type': 'user',",
            "        'capacity': 'admin',",
            "    }",
            "    member_create_context = {",
            "        'model': model,",
            "        'user': user,",
            "        'ignore_auth': True,  # we are not a member of the group at this point",
            "        'session': session",
            "    }",
            "    logic.get_action('member_create')(member_create_context, member_dict)",
            "",
            "    log.debug('Created object %s' % group.name)",
            "",
            "    return_id_only = context.get('return_id_only', False)",
            "    action = 'organization_show' if is_org else 'group_show'",
            "",
            "    output = context['id'] if return_id_only \\",
            "        else _get_action(action)(context, {'id': group.id})",
            "",
            "    return output",
            "",
            "",
            "def group_create(context, data_dict):",
            "    '''Create a new group.",
            "",
            "    You must be authorized to create groups.",
            "",
            "    Plugins may change the parameters of this function depending on the value",
            "    of the ``type`` parameter, see the",
            "    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.",
            "",
            "    :param name: the name of the group, a string between 2 and 100 characters",
            "        long, containing only lowercase alphanumeric characters, ``-`` and",
            "        ``_``",
            "    :type name: string",
            "    :param id: the id of the group (optional)",
            "    :type id: string",
            "    :param title: the title of the group (optional)",
            "    :type title: string",
            "    :param description: the description of the group (optional)",
            "    :type description: string",
            "    :param image_url: the URL to an image to be displayed on the group's page",
            "        (optional)",
            "    :type image_url: string",
            "    :param type: the type of the group (optional, default: ``'group'``),",
            "        :py:class:`~ckan.plugins.interfaces.IGroupForm` plugins",
            "        associate themselves with different group types and provide custom",
            "        group handling behaviour for these types",
            "        Cannot be 'organization'",
            "    :type type: string",
            "    :param state: the current state of the group, e.g. ``'active'`` or",
            "        ``'deleted'``, only active groups show up in search results and",
            "        other lists of groups, this parameter will be ignored if you are not",
            "        authorized to change the state of the group (optional, default:",
            "        ``'active'``)",
            "    :type state: string",
            "    :param approval_status: (optional)",
            "    :type approval_status: string",
            "    :param extras: the group's extras (optional), extras are arbitrary",
            "        (key: value) metadata items that can be added to groups, each extra",
            "        dictionary should have keys ``'key'`` (a string), ``'value'`` (a",
            "        string), and optionally ``'deleted'``",
            "    :type extras: list of dataset extra dictionaries",
            "    :param packages: the datasets (packages) that belong to the group, a list",
            "        of dictionaries each with keys ``'name'`` (string, the id or name of",
            "        the dataset) and optionally ``'title'`` (string, the title of the",
            "        dataset)",
            "    :type packages: list of dictionaries",
            "    :param groups: the groups that belong to the group, a list of dictionaries",
            "        each with key ``'name'`` (string, the id or name of the group) and",
            "        optionally ``'capacity'`` (string, the capacity in which the group is",
            "        a member of the group)",
            "    :type groups: list of dictionaries",
            "    :param users: the users that belong to the group, a list of dictionaries",
            "        each with key ``'name'`` (string, the id or name of the user) and",
            "        optionally ``'capacity'`` (string, the capacity in which the user is",
            "        a member of the group)",
            "    :type users: list of dictionaries",
            "",
            "    :returns: the newly created group (unless 'return_id_only' is set to True",
            "              in the context, in which case just the group id will",
            "              be returned)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    # wrapper for creating groups",
            "    if data_dict.get('type') == 'organization':",
            "        # FIXME better exception?",
            "        raise Exception(_('Trying to create an organization as a group'))",
            "    _check_access('group_create', context, data_dict)",
            "    return _group_or_org_create(context, data_dict)",
            "",
            "",
            "def organization_create(context, data_dict):",
            "    '''Create a new organization.",
            "",
            "    You must be authorized to create organizations.",
            "",
            "    Plugins may change the parameters of this function depending on the value",
            "    of the ``type`` parameter, see the",
            "    :py:class:`~ckan.plugins.interfaces.IGroupForm` plugin interface.",
            "",
            "    :param name: the name of the organization, a string between 2 and",
            "        100 characters long, containing only lowercase alphanumeric",
            "        characters, ``-`` and ``_``",
            "    :type name: string",
            "    :param id: the id of the organization (optional)",
            "    :type id: string",
            "    :param title: the title of the organization (optional)",
            "    :type title: string",
            "    :param description: the description of the organization (optional)",
            "    :type description: string",
            "    :param image_url: the URL to an image to be displayed on the",
            "        organization's page (optional)",
            "    :type image_url: string",
            "    :param state: the current state of the organization, e.g. ``'active'`` or",
            "        ``'deleted'``, only active organizations show up in search results and",
            "        other lists of organizations, this parameter will be ignored if you",
            "        are not authorized to change the state of the organization",
            "        (optional, default: ``'active'``)",
            "    :type state: string",
            "    :param approval_status: (optional)",
            "    :type approval_status: string",
            "    :param extras: the organization's extras (optional), extras are arbitrary",
            "        (key: value) metadata items that can be added to organizations,",
            "        each extra",
            "        dictionary should have keys ``'key'`` (a string), ``'value'`` (a",
            "        string), and optionally ``'deleted'``",
            "    :type extras: list of dataset extra dictionaries",
            "    :param packages: the datasets (packages) that belong to the organization,",
            "        a list of dictionaries each with keys ``'name'`` (string, the id",
            "        or name of the dataset) and optionally ``'title'`` (string, the",
            "        title of the dataset)",
            "    :type packages: list of dictionaries",
            "    :param users: the users that belong to the organization, a list",
            "        of dictionaries each with key ``'name'`` (string, the id or name",
            "        of the user) and optionally ``'capacity'`` (string, the capacity",
            "        in which the user is a member of the organization)",
            "    :type users: list of dictionaries",
            "",
            "    :returns: the newly created organization (unless 'return_id_only' is set",
            "              to True in the context, in which case just the organization id",
            "              will be returned)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    # wrapper for creating organizations",
            "    data_dict.setdefault('type', 'organization')",
            "    _check_access('organization_create', context, data_dict)",
            "    return _group_or_org_create(context, data_dict, is_org=True)",
            "",
            "",
            "@logic.auth_audit_exempt",
            "def rating_create(context, data_dict):",
            "    '''Rate a dataset (package).",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param package: the name or id of the dataset to rate",
            "    :type package: string",
            "    :param rating: the rating to give to the dataset, an integer between 1 and",
            "        5",
            "    :type rating: int",
            "",
            "    :returns: a dictionary with two keys: ``'rating average'`` (the average",
            "        rating of the dataset you rated) and ``'rating count'`` (the number of",
            "        times the dataset has been rated)",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    user = context.get(\"user\")",
            "",
            "    package_ref = data_dict.get('package')",
            "    rating = data_dict.get('rating')",
            "    opts_err = None",
            "    if not package_ref:",
            "        opts_err = _('You must supply a package id or name '",
            "                     '(parameter \"package\").')",
            "    elif not rating:",
            "        opts_err = _('You must supply a rating (parameter \"rating\").')",
            "    else:",
            "        try:",
            "            rating_int = int(rating)",
            "        except ValueError:",
            "            opts_err = _('Rating must be an integer value.')",
            "        else:",
            "            package = model.Package.get(package_ref)",
            "            if rating < model.MIN_RATING or rating > model.MAX_RATING:",
            "                opts_err = _('Rating must be between %i and %i.') \\",
            "                    % (model.MIN_RATING, model.MAX_RATING)",
            "            elif not package:",
            "                opts_err = _('Not found') + ': %r' % package_ref",
            "    if opts_err:",
            "        raise ValidationError(opts_err)",
            "",
            "    user = model.User.by_name(user)",
            "    package.set_rating(user, rating_int)",
            "    model.repo.commit()",
            "",
            "    package = model.Package.get(package_ref)",
            "    ret_dict = {'rating average': package.get_average_rating(),",
            "                'rating count': len(package.ratings)}",
            "    return ret_dict",
            "",
            "",
            "def user_create(context, data_dict):",
            "    '''Create a new user.",
            "",
            "    You must be authorized to create users.",
            "",
            "    :param name: the name of the new user, a string between 2 and 100",
            "        characters in length, containing only lowercase alphanumeric",
            "        characters, ``-`` and ``_``",
            "    :type name: string",
            "    :param email: the email address for the new user",
            "    :type email: string",
            "    :param password: the password of the new user, a string of at least 4",
            "        characters",
            "    :type password: string",
            "    :param id: the id of the new user (optional)",
            "    :type id: string",
            "    :param fullname: the full name of the new user (optional)",
            "    :type fullname: string",
            "    :param about: a description of the new user (optional)",
            "    :type about: string",
            "    :param image_url: the URL to an image to be displayed on the group's page",
            "        (optional)",
            "    :type image_url: string",
            "    :param plugin_extras: private extra user data belonging to plugins.",
            "        Only sysadmin users may set this value. It should be a dict that can",
            "        be dumped into JSON, and plugins should namespace their extras with",
            "        the plugin name to avoid collisions with other plugins, eg::",
            "",
            "            {",
            "                \"name\": \"test_user\",",
            "                \"email\": \"test@example.com\",",
            "                \"plugin_extras\": {",
            "                    \"my_plugin\": {",
            "                        \"private_extra\": 1",
            "                    },",
            "                    \"another_plugin\": {",
            "                        \"another_extra\": True",
            "                    }",
            "                }",
            "            }",
            "    :type plugin_extras: dict",
            "",
            "",
            "    :returns: the newly created user",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    schema = context.get('schema') or ckan.logic.schema.default_user_schema()",
            "    session = context['session']",
            "",
            "    _check_access('user_create', context, data_dict)",
            "",
            "    author_obj = model.User.get(context.get('user'))",
            "    if data_dict.get(\"id\"):",
            "        is_sysadmin = (author_obj and author_obj.sysadmin)",
            "        if not is_sysadmin or model.User.get(data_dict[\"id\"]):",
            "            data_dict.pop(\"id\", None)",
            "    context.pop(\"user_obj\", None)",
            "",
            "    upload = uploader.get_uploader('user')",
            "    upload.update_data_dict(data_dict, 'image_url',",
            "                            'image_upload', 'clear_upload')",
            "    data, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # user schema prevents non-sysadmins from providing password_hash",
            "    if 'password_hash' in data:",
            "        data['_password'] = data.pop('password_hash')",
            "",
            "    user = model_save.user_dict_save(data, context)",
            "",
            "    # Flush the session to cause user.id to be initialised, because",
            "    # activity_create() (below) needs it.",
            "    session.flush()",
            "",
            "    activity_create_context = {",
            "        'model': model,",
            "        'user': context['user'],",
            "        'defer_commit': True,",
            "        'ignore_auth': True,",
            "        'session': session",
            "    }",
            "    activity_dict = {",
            "        'user_id': user.id,",
            "        'object_id': user.id,",
            "        'activity_type': 'new user',",
            "    }",
            "    logic.get_action('activity_create')(activity_create_context, activity_dict)",
            "",
            "    upload.upload(uploader.get_max_image_size())",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    # A new context is required for dictizing the newly constructed user in",
            "    # order that all the new user's data is returned, in particular, the",
            "    # api_key.",
            "    #",
            "    # The context is copied so as not to clobber the caller's context dict.",
            "    user_dictize_context = context.copy()",
            "    user_dictize_context['keep_apikey'] = True",
            "    user_dictize_context['keep_email'] = True",
            "",
            "    include_plugin_extras = False",
            "    if author_obj:",
            "        include_plugin_extras = author_obj.sysadmin and 'plugin_extras' in data",
            "    user_dict = model_dictize.user_dictize(",
            "        user, user_dictize_context,",
            "        include_plugin_extras=include_plugin_extras",
            "    )",
            "",
            "    context['user_obj'] = user",
            "    context['id'] = user.id",
            "",
            "    model.Dashboard.get(user.id)  # Create dashboard for user.",
            "",
            "    log.debug('Created user {name}'.format(name=user.name))",
            "    return user_dict",
            "",
            "",
            "def user_invite(context, data_dict):",
            "    '''Invite a new user.",
            "",
            "    You must be authorized to create group members.",
            "",
            "    :param email: the email of the user to be invited to the group",
            "    :type email: string",
            "    :param group_id: the id or name of the group",
            "    :type group_id: string",
            "    :param role: role of the user in the group. One of ``member``, ``editor``,",
            "        or ``admin``",
            "    :type role: string",
            "",
            "    :returns: the newly created user",
            "    :rtype: dictionary",
            "    '''",
            "    import string",
            "    _check_access('user_invite', context, data_dict)",
            "",
            "    schema = context.get('schema',",
            "                         ckan.logic.schema.default_user_invite_schema())",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    model = context['model']",
            "    group = model.Group.get(data['group_id'])",
            "    if not group:",
            "        raise NotFound()",
            "",
            "    name = _get_random_username_from_email(data['email'])",
            "    # Choose a password. However it will not be used - the invitee will not be",
            "    # told it - they will need to reset it",
            "    while True:",
            "        password = ''.join(random.SystemRandom().choice(",
            "            string.ascii_lowercase + string.ascii_uppercase + string.digits)",
            "            for _ in range(12))",
            "        # Occasionally it won't meet the constraints, so check",
            "        errors = {}",
            "        logic.validators.user_password_validator(",
            "            'password', {'password': password}, errors, None)",
            "        if not errors:",
            "            break",
            "",
            "    data['name'] = name",
            "    data['password'] = password",
            "    data['state'] = ckan.model.State.PENDING",
            "    user_dict = _get_action('user_create')(context, data)",
            "    user = ckan.model.User.get(user_dict['id'])",
            "    member_dict = {",
            "        'username': user.id,",
            "        'id': data['group_id'],",
            "        'role': data['role']",
            "    }",
            "",
            "    if group.is_organization:",
            "        _get_action('organization_member_create')(context, member_dict)",
            "        group_dict = _get_action('organization_show')(context,",
            "                                                      {'id': data['group_id']})",
            "    else:",
            "        _get_action('group_member_create')(context, member_dict)",
            "        group_dict = _get_action('group_show')(context,",
            "                                               {'id': data['group_id']})",
            "    try:",
            "        mailer.send_invite(user, group_dict, data['role'])",
            "    except (socket_error, mailer.MailerException) as error:",
            "        # Email could not be sent, delete the pending user",
            "",
            "        _get_action('user_delete')(context, {'id': user.id})",
            "",
            "        error_dict = {",
            "            \"message\": _('Error sending the invite email, \\",
            "                the user was not created: {0}').format(error)",
            "        }",
            "        raise ValidationError(error_dict, error_summary=error_dict)",
            "",
            "    return model_dictize.user_dictize(user, context)",
            "",
            "",
            "def _get_random_username_from_email(email):",
            "    localpart = email.split('@')[0]",
            "    cleaned_localpart = re.sub(r'[^\\w]', '-', localpart).lower()",
            "",
            "    # if we can't create a unique user name within this many attempts",
            "    # then something else is probably wrong and we should give up",
            "    max_name_creation_attempts = 100",
            "",
            "    for i in range(max_name_creation_attempts):",
            "        random_number = random.SystemRandom().random() * 10000",
            "        name = '%s-%d' % (cleaned_localpart, random_number)",
            "        if not ckan.model.User.get(name):",
            "            return name",
            "",
            "    return cleaned_localpart",
            "",
            "",
            "def vocabulary_create(context, data_dict):",
            "    '''Create a new tag vocabulary.",
            "",
            "    You must be a sysadmin to create vocabularies.",
            "",
            "    :param name: the name of the new vocabulary, e.g. ``'Genre'``",
            "    :type name: string",
            "    :param tags: the new tags to add to the new vocabulary, for the format of",
            "        tag dictionaries see :py:func:`tag_create`",
            "    :type tags: list of tag dictionaries",
            "",
            "    :returns: the newly-created vocabulary",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "    schema = context.get('schema') or \\",
            "        ckan.logic.schema.default_create_vocabulary_schema()",
            "",
            "    _check_access('vocabulary_create', context, data_dict)",
            "",
            "    data, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    vocabulary = model_save.vocabulary_dict_save(data, context)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug('Created Vocabulary %s' % vocabulary.name)",
            "",
            "    return model_dictize.vocabulary_dictize(vocabulary, context)",
            "",
            "",
            "def activity_create(context, activity_dict, **kw):",
            "    '''Create a new activity stream activity.",
            "",
            "    You must be a sysadmin to create new activities.",
            "",
            "    :param user_id: the name or id of the user who carried out the activity,",
            "        e.g. ``'seanh'``",
            "    :type user_id: string",
            "    :param object_id: the name or id of the object of the activity, e.g.",
            "        ``'my_dataset'``",
            "    :param activity_type: the type of the activity, this must be an activity",
            "        type that CKAN knows how to render, e.g. ``'new package'``,",
            "        ``'changed user'``, ``'deleted group'`` etc.",
            "    :type activity_type: string",
            "    :param data: any additional data about the activity",
            "    :type data: dictionary",
            "",
            "    :returns: the newly created activity",
            "    :rtype: dictionary",
            "",
            "    '''",
            "",
            "    _check_access('activity_create', context, activity_dict)",
            "",
            "    # this action had a ignore_auth param which has been removed",
            "    # removed in 2.2",
            "    if 'ignore_auth' in kw:",
            "        raise Exception('Activity Stream calling parameters have changed '",
            "                        'ignore_auth must be passed in the context not as '",
            "                        'a param')",
            "",
            "    if not ckan.common.asbool(",
            "            config.get('ckan.activity_streams_enabled', 'true')):",
            "        return",
            "",
            "    model = context['model']",
            "",
            "    # Any revision_id that the caller attempts to pass in the activity_dict is",
            "    # ignored and removed here.",
            "    if 'revision_id' in activity_dict:",
            "        del activity_dict['revision_id']",
            "",
            "    schema = context.get('schema') or \\",
            "        ckan.logic.schema.default_create_activity_schema()",
            "",
            "    data, errors = _validate(activity_dict, schema, context)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    activity = model_save.activity_dict_save(data, context)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(\"Created '%s' activity\" % activity.activity_type)",
            "    return model_dictize.activity_dictize(activity, context)",
            "",
            "",
            "def tag_create(context, data_dict):",
            "    '''Create a new vocabulary tag.",
            "",
            "    You must be a sysadmin to create vocabulary tags.",
            "",
            "    You can only use this function to create tags that belong to a vocabulary,",
            "    not to create free tags. (To create a new free tag simply add the tag to",
            "    a package, e.g. using the",
            "    :py:func:`~ckan.logic.action.update.package_update` function.)",
            "",
            "    :param name: the name for the new tag, a string between 2 and 100",
            "        characters long containing only alphanumeric characters and ``-``,",
            "        ``_`` and ``.``, e.g. ``'Jazz'``",
            "    :type name: string",
            "    :param vocabulary_id: the id of the vocabulary that the new tag",
            "        should be added to, e.g. the id of vocabulary ``'Genre'``",
            "    :type vocabulary_id: string",
            "",
            "    :returns: the newly-created tag",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    model = context['model']",
            "",
            "    _check_access('tag_create', context, data_dict)",
            "",
            "    schema = context.get('schema') or \\",
            "        ckan.logic.schema.default_create_tag_schema()",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    tag = model_save.tag_dict_save(data_dict, context)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(\"Created tag '%s' \" % tag)",
            "    return model_dictize.tag_dictize(tag, context)",
            "",
            "",
            "def follow_user(context, data_dict):",
            "    '''Start following another user.",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param id: the id or name of the user to follow, e.g. ``'joeuser'``",
            "    :type id: string",
            "",
            "    :returns: a representation of the 'follower' relationship between yourself",
            "        and the other user",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    if 'user' not in context:",
            "        raise NotAuthorized(_(\"You must be logged in to follow users\"))",
            "",
            "    model = context['model']",
            "    session = context['session']",
            "",
            "    userobj = model.User.get(context['user'])",
            "    if not userobj:",
            "        raise NotAuthorized(_(\"You must be logged in to follow users\"))",
            "",
            "    schema = (context.get('schema')",
            "              or ckan.logic.schema.default_follow_user_schema())",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # Don't let a user follow herself.",
            "    if userobj.id == validated_data_dict['id']:",
            "        message = _('You cannot follow yourself')",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    # Don't let a user follow someone she is already following.",
            "    if model.UserFollowingUser.is_following(userobj.id,",
            "                                            validated_data_dict['id']):",
            "        followeduserobj = model.User.get(validated_data_dict['id'])",
            "        name = followeduserobj.display_name",
            "        message = _('You are already following {0}').format(name)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    follower = model_save.follower_dict_save(",
            "        validated_data_dict, context, model.UserFollowingUser)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(u'User {follower} started following user {object}'.format(",
            "        follower=follower.follower_id, object=follower.object_id))",
            "",
            "    return model_dictize.user_following_user_dictize(follower, context)",
            "",
            "",
            "def follow_dataset(context, data_dict):",
            "    '''Start following a dataset.",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param id: the id or name of the dataset to follow, e.g. ``'warandpeace'``",
            "    :type id: string",
            "",
            "    :returns: a representation of the 'follower' relationship between yourself",
            "        and the dataset",
            "    :rtype: dictionary",
            "",
            "    '''",
            "",
            "    if 'user' not in context:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a dataset.\"))",
            "",
            "    model = context['model']",
            "    session = context['session']",
            "",
            "    userobj = model.User.get(context['user'])",
            "    if not userobj:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a dataset.\"))",
            "",
            "    schema = (context.get('schema')",
            "              or ckan.logic.schema.default_follow_dataset_schema())",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # Don't let a user follow a dataset she is already following.",
            "    if model.UserFollowingDataset.is_following(userobj.id,",
            "                                               validated_data_dict['id']):",
            "        # FIXME really package model should have this logic and provide",
            "        # 'display_name' like users and groups",
            "        pkgobj = model.Package.get(validated_data_dict['id'])",
            "        name = pkgobj.title or pkgobj.name or pkgobj.id",
            "        message = _(",
            "            'You are already following {0}').format(name)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    follower = model_save.follower_dict_save(validated_data_dict, context,",
            "                                             model.UserFollowingDataset)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(u'User {follower} started following dataset {object}'.format(",
            "        follower=follower.follower_id, object=follower.object_id))",
            "",
            "    return model_dictize.user_following_dataset_dictize(follower, context)",
            "",
            "",
            "def _group_or_org_member_create(context, data_dict, is_org=False):",
            "    # creator of group/org becomes an admin",
            "    # this needs to be after the repo.commit or else revisions break",
            "    model = context['model']",
            "    user = context['user']",
            "    session = context['session']",
            "",
            "    schema = ckan.logic.schema.member_schema()",
            "    data, errors = _validate(data_dict, schema, context)",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    username = _get_or_bust(data_dict, 'username')",
            "    role = data_dict.get('role')",
            "    group_id = data_dict.get('id')",
            "    group = model.Group.get(group_id)",
            "    if not group:",
            "        msg = _('Organization not found') if is_org else _('Group not found')",
            "        raise NotFound(msg)",
            "    result = model.User.get(username)",
            "    if result:",
            "        user_id = result.id",
            "    else:",
            "        message = _(u'User {username} does not exist.').format(",
            "            username=username)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "    member_dict = {",
            "        'id': group.id,",
            "        'object': user_id,",
            "        'object_type': 'user',",
            "        'capacity': role,",
            "    }",
            "    member_create_context = {",
            "        'model': model,",
            "        'user': user,",
            "        'session': session,",
            "        'ignore_auth': context.get('ignore_auth'),",
            "    }",
            "    return logic.get_action('member_create')(member_create_context,",
            "                                             member_dict)",
            "",
            "",
            "def group_member_create(context, data_dict):",
            "    '''Make a user a member of a group.",
            "",
            "    You must be authorized to edit the group.",
            "",
            "    :param id: the id or name of the group",
            "    :type id: string",
            "    :param username: name or id of the user to be made member of the group",
            "    :type username: string",
            "    :param role: role of the user in the group. One of ``member``, ``editor``,",
            "        or ``admin``",
            "    :type role: string",
            "",
            "    :returns: the newly created (or updated) membership",
            "    :rtype: dictionary",
            "    '''",
            "    _check_access('group_member_create', context, data_dict)",
            "    return _group_or_org_member_create(context, data_dict)",
            "",
            "",
            "def organization_member_create(context, data_dict):",
            "    '''Make a user a member of an organization.",
            "",
            "    You must be authorized to edit the organization.",
            "",
            "    :param id: the id or name of the organization",
            "    :type id: string",
            "    :param username: name or id of the user to be made member of the",
            "        organization",
            "    :type username: string",
            "    :param role: role of the user in the organization. One of ``member``,",
            "        ``editor``, or ``admin``",
            "    :type role: string",
            "",
            "    :returns: the newly created (or updated) membership",
            "    :rtype: dictionary",
            "    '''",
            "    _check_access('organization_member_create', context, data_dict)",
            "    return _group_or_org_member_create(context, data_dict, is_org=True)",
            "",
            "",
            "def follow_group(context, data_dict):",
            "    '''Start following a group.",
            "",
            "    You must provide your API key in the Authorization header.",
            "",
            "    :param id: the id or name of the group to follow, e.g. ``'roger'``",
            "    :type id: string",
            "",
            "    :returns: a representation of the 'follower' relationship between yourself",
            "        and the group",
            "    :rtype: dictionary",
            "",
            "    '''",
            "    if 'user' not in context:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a group.\"))",
            "",
            "    model = context['model']",
            "    session = context['session']",
            "",
            "    userobj = model.User.get(context['user'])",
            "    if not userobj:",
            "        raise NotAuthorized(",
            "            _(\"You must be logged in to follow a group.\"))",
            "",
            "    schema = context.get('schema',",
            "                         ckan.logic.schema.default_follow_group_schema())",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        model.Session.rollback()",
            "        raise ValidationError(errors)",
            "",
            "    # Don't let a user follow a group she is already following.",
            "    if model.UserFollowingGroup.is_following(userobj.id,",
            "                                             validated_data_dict['id']):",
            "        groupobj = model.Group.get(validated_data_dict['id'])",
            "        name = groupobj.display_name",
            "        message = _(",
            "            'You are already following {0}').format(name)",
            "        raise ValidationError({'message': message}, error_summary=message)",
            "",
            "    follower = model_save.follower_dict_save(validated_data_dict, context,",
            "                                             model.UserFollowingGroup)",
            "",
            "    if not context.get('defer_commit'):",
            "        model.repo.commit()",
            "",
            "    log.debug(u'User {follower} started following group {object}'.format(",
            "        follower=follower.follower_id, object=follower.object_id))",
            "",
            "    return model_dictize.user_following_group_dictize(follower, context)",
            "",
            "",
            "def api_token_create(context, data_dict):",
            "    \"\"\"Create new API Token for current user.",
            "",
            "    Apart from the `user` and `name` field that are required by",
            "    default implementation, there may be additional fields registered",
            "    by extensions.",
            "",
            "    :param user: name or id of the user who owns new API Token",
            "    :type user: string",
            "    :param name: distinctive name for API Token",
            "    :type name: string",
            "",
            "    :returns: Returns a dict with the key \"token\" containing the",
            "              encoded token value. Extensions can privide additional",
            "              fields via `add_extra` method of",
            "              :py:class:`~ckan.plugins.interfaces.IApiToken`",
            "    :rtype: dictionary",
            "",
            "    \"\"\"",
            "    model = context[u'model']",
            "    user, name = _get_or_bust(data_dict, [u'user', u'name'])",
            "",
            "    if model.User.get(user) is None:",
            "        raise NotFound(\"User not found\")",
            "",
            "    _check_access(u'api_token_create', context, data_dict)",
            "",
            "    schema = context.get(u'schema')",
            "    if not schema:",
            "        schema = api_token.get_schema()",
            "",
            "    validated_data_dict, errors = _validate(data_dict, schema, context)",
            "",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    token_obj = model_save.api_token_save(",
            "        {u'user': user, u'name': name}, context",
            "    )",
            "    model.Session.commit()",
            "    data = {",
            "        u'jti': token_obj.id,",
            "        u'iat': api_token.into_seconds(token_obj.created_at)",
            "    }",
            "",
            "    data = api_token.postprocess(data, token_obj.id, validated_data_dict)",
            "    token = api_token.encode(data)",
            "",
            "    result = api_token.add_extra({u'token': token})",
            "    return result"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1088": [
                "user_create"
            ]
        },
        "addLocation": [
            "ckan.logic.action.create.user_create.activity_dict",
            "wagtail.search.utils",
            "ckan.logic.action.create.user_create.activity_create_context"
        ]
    },
    "ckan/tests/logic/action/test_create.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1100,
                "afterPatchRowNumber": 1100,
                "PatchRowcode": "         user_obj = model.User.get(user[\"id\"])"
            },
            "1": {
                "beforePatchRowNumber": 1101,
                "afterPatchRowNumber": 1101,
                "PatchRowcode": "         assert user_obj.password != \"pretend-this-is-a-valid-hash\""
            },
            "2": {
                "beforePatchRowNumber": 1102,
                "afterPatchRowNumber": 1102,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1103,
                "PatchRowcode": "+    def test_anon_user_create_does_not_update(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1104,
                "PatchRowcode": "+        user1 = factories.User(about=\"This is user 1\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1105,
                "PatchRowcode": "+        user_dict = {"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1106,
                "PatchRowcode": "+            \"id\": user1[\"id\"],"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1107,
                "PatchRowcode": "+            \"name\": \"some_name\","
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1108,
                "PatchRowcode": "+            \"email\": \"some_email@example.com\","
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1109,
                "PatchRowcode": "+            \"password\": \"test1234\","
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1110,
                "PatchRowcode": "+        }"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1111,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1112,
                "PatchRowcode": "+        context = {"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1113,
                "PatchRowcode": "+            \"user\": None,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1114,
                "PatchRowcode": "+            \"ignore_auth\": False,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1115,
                "PatchRowcode": "+        }"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1116,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1117,
                "PatchRowcode": "+        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1118,
                "PatchRowcode": "+        assert user2[\"id\"] != user1[\"id\"]"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1119,
                "PatchRowcode": "+        assert user2[\"about\"] != \"This is user 1\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1120,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1121,
                "PatchRowcode": "+    def test_normal_user_create_does_not_update(self):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1122,
                "PatchRowcode": "+        user1 = factories.User(about=\"This is user 1\")"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1123,
                "PatchRowcode": "+        user_dict = {"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1124,
                "PatchRowcode": "+            \"id\": user1[\"id\"],"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1125,
                "PatchRowcode": "+            \"name\": \"some_name\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1126,
                "PatchRowcode": "+            \"email\": \"some_email@example.com\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1127,
                "PatchRowcode": "+            \"password\": \"test1234\","
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1128,
                "PatchRowcode": "+        }"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1129,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1130,
                "PatchRowcode": "+        context = {"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1131,
                "PatchRowcode": "+            \"user\": factories.User()[\"name\"],"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1132,
                "PatchRowcode": "+            \"ignore_auth\": False,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1133,
                "PatchRowcode": "+        }"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1134,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1135,
                "PatchRowcode": "+        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1136,
                "PatchRowcode": "+        assert user2[\"id\"] != user1[\"id\"]"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1137,
                "PatchRowcode": "+        assert user2[\"about\"] != \"This is user 1\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1138,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1139,
                "PatchRowcode": "+    def test_sysadmin_user_create_does_not_update(self):"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1140,
                "PatchRowcode": "+        user1 = factories.User(about=\"This is user 1\")"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1141,
                "PatchRowcode": "+        user_dict = {"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1142,
                "PatchRowcode": "+            \"id\": user1[\"id\"],"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1143,
                "PatchRowcode": "+            \"name\": \"some_name\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1144,
                "PatchRowcode": "+            \"email\": \"some_email@example.com\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1145,
                "PatchRowcode": "+            \"password\": \"test1234\","
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1146,
                "PatchRowcode": "+        }"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1147,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1148,
                "PatchRowcode": "+        context = {"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1149,
                "PatchRowcode": "+            \"user\": factories.Sysadmin()[\"name\"],"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1150,
                "PatchRowcode": "+            \"ignore_auth\": False,"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1151,
                "PatchRowcode": "+        }"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1152,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1153,
                "PatchRowcode": "+        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1154,
                "PatchRowcode": "+        assert user2[\"id\"] != user1[\"id\"]"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1155,
                "PatchRowcode": "+        assert user2[\"about\"] != \"This is user 1\""
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1156,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1157,
                "PatchRowcode": "+    def test_anon_users_can_not_provide_custom_id(self):"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1158,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1159,
                "PatchRowcode": "+        user_dict = {"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1160,
                "PatchRowcode": "+            \"id\": \"custom_id\","
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1161,
                "PatchRowcode": "+            \"name\": \"some_name\","
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1162,
                "PatchRowcode": "+            \"email\": \"some_email@example.com\","
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1163,
                "PatchRowcode": "+            \"password\": \"test1234\","
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1164,
                "PatchRowcode": "+        }"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1165,
                "PatchRowcode": "+"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1166,
                "PatchRowcode": "+        context = {"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1167,
                "PatchRowcode": "+            \"user\": None,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1168,
                "PatchRowcode": "+            \"ignore_auth\": False,"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1169,
                "PatchRowcode": "+        }"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1170,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1171,
                "PatchRowcode": "+        user = helpers.call_action(\"user_create\", context=context, **user_dict)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1172,
                "PatchRowcode": "+        assert user[\"id\"] != \"custom_id\""
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1173,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1174,
                "PatchRowcode": "+    def test_normal_users_can_not_provide_custom_id(self):"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1175,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1176,
                "PatchRowcode": "+        user_dict = {"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1177,
                "PatchRowcode": "+            \"id\": \"custom_id\","
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1178,
                "PatchRowcode": "+            \"name\": \"some_name\","
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1179,
                "PatchRowcode": "+            \"email\": \"some_email@example.com\","
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1180,
                "PatchRowcode": "+            \"password\": \"test1234\","
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1181,
                "PatchRowcode": "+        }"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1182,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1183,
                "PatchRowcode": "+        context = {"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1184,
                "PatchRowcode": "+            \"user\": factories.User()[\"name\"],"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1185,
                "PatchRowcode": "+            \"ignore_auth\": False,"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1186,
                "PatchRowcode": "+        }"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1187,
                "PatchRowcode": "+"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1188,
                "PatchRowcode": "+        user = helpers.call_action(\"user_create\", context=context, **user_dict)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1189,
                "PatchRowcode": "+        assert user[\"id\"] != \"custom_id\""
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1190,
                "PatchRowcode": "+"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1191,
                "PatchRowcode": "+    def test_sysadmin_can_provide_custom_id(self):"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1192,
                "PatchRowcode": "+"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1193,
                "PatchRowcode": "+        user_dict = {"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1194,
                "PatchRowcode": "+            \"id\": \"custom_id\","
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1195,
                "PatchRowcode": "+            \"name\": \"some_name\","
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1196,
                "PatchRowcode": "+            \"email\": \"some_email@example.com\","
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1197,
                "PatchRowcode": "+            \"password\": \"test1234\","
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1198,
                "PatchRowcode": "+        }"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1199,
                "PatchRowcode": "+        context = {"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1200,
                "PatchRowcode": "+            \"user\": factories.Sysadmin()[\"name\"],"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1201,
                "PatchRowcode": "+            \"ignore_auth\": False,"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1202,
                "PatchRowcode": "+        }"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1203,
                "PatchRowcode": "+"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1204,
                "PatchRowcode": "+        user = helpers.call_action(\"user_create\", context=context, **user_dict)"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1205,
                "PatchRowcode": "+        assert user[\"id\"] == \"custom_id\""
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1206,
                "PatchRowcode": "+"
            },
            "107": {
                "beforePatchRowNumber": 1103,
                "afterPatchRowNumber": 1207,
                "PatchRowcode": " "
            },
            "108": {
                "beforePatchRowNumber": 1104,
                "afterPatchRowNumber": 1208,
                "PatchRowcode": " def _clear_activities():"
            },
            "109": {
                "beforePatchRowNumber": 1105,
                "afterPatchRowNumber": 1209,
                "PatchRowcode": "     from ckan import model"
            }
        },
        "frontPatchFile": [
            "# encoding: utf-8",
            "\"\"\"Unit tests for ckan/logic/action/create.py.",
            "",
            "\"\"\"",
            "import datetime",
            "import mock",
            "import pytest",
            "",
            "import ckan",
            "import ckan.logic as logic",
            "import ckan.model as model",
            "import ckan.tests.factories as factories",
            "import ckan.tests.helpers as helpers",
            "from ckan.common import config",
            "",
            "from six import string_types",
            "",
            "from freezegun import freeze_time",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestUserInvite(object):",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_invited_user_is_created_as_pending(self, _):",
            "        invited_user = self._invite_user_to_group()",
            "",
            "        assert invited_user is not None",
            "        assert invited_user.is_pending()",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_creates_user_with_valid_username(self, _):",
            "        email = \"user$%+abc@email.com\"",
            "        invited_user = self._invite_user_to_group(email)",
            "",
            "        assert invited_user.name.startswith(\"user---abc\"), invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_assigns_user_to_group_in_expected_role(self, _):",
            "        role = \"admin\"",
            "        invited_user = self._invite_user_to_group(role=role)",
            "",
            "        group_ids = invited_user.get_group_ids(capacity=role)",
            "        assert len(group_ids) == 1, group_ids",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_sends_invite(self, send_invite):",
            "        invited_user = self._invite_user_to_group()",
            "",
            "        assert send_invite.called",
            "        assert send_invite.call_args[0][0].id == invited_user.id",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    @mock.patch(\"random.SystemRandom\")",
            "    def test_works_even_if_username_already_exists(self, rand, _):",
            "        # usernames",
            "        rand.return_value.random.side_effect = [1000, 1000, 2000, 3000]",
            "        # passwords (need to set something, otherwise choice will break)",
            "        rand.return_value.choice.side_effect = \"TestPassword1\" * 3",
            "",
            "        for _ in range(3):",
            "            invited_user = self._invite_user_to_group(",
            "                email=\"same{}@email.com\".format(_))",
            "            assert invited_user is not None, invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_email(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_existed_email(self, _):",
            "        factories.User(email=\"email@example.com\")",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=\"email@example.com\")",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_role(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(role=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_raises_not_found(self, _):",
            "        user = factories.User()",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {",
            "            \"email\": \"a@example.com\",",
            "            \"group_id\": \"group_not_found\",",
            "            \"role\": \"admin\",",
            "        }",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_group_id(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(group={\"id\": None})",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_user_name_lowercase_when_email_is_uppercase(self, _):",
            "        invited_user = self._invite_user_to_group(email=\"Maria@example.com\")",
            "",
            "        assert invited_user.name.split(\"-\")[0] == \"maria\"",
            "",
            "    @pytest.mark.ckan_config(\"smtp.server\", \"email.example.com\")",
            "    @pytest.mark.usefixtures(\"with_request_context\")",
            "    def test_smtp_error_returns_error_message(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "        group = factories.Group()",
            "",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "        params = {",
            "            \"email\": \"example-invited-user@example.com\",",
            "            \"group_id\": group[\"id\"],",
            "            \"role\": \"editor\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        # Check that the pending user was deleted",
            "        user = (",
            "            model.Session.query(model.User)",
            "            .filter(model.User.name.like(\"example-invited-user%\"))",
            "            .all()",
            "        )",
            "",
            "        assert user[0].state == \"deleted\"",
            "",
            "    def _invite_user_to_group(",
            "        self, email=\"user@email.com\", group=None, role=\"member\"",
            "    ):",
            "        user = factories.User()",
            "        group = group or factories.Group(user=user)",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {\"email\": email, \"group_id\": group[\"id\"], \"role\": role}",
            "",
            "        result = helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        return model.User.get(result[\"id\"])",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_plugins\")",
            "class TestResourceViewCreate(object):",
            "    def test_resource_view_create(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    def test_requires_resource_id(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"resource_id\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_requires_title(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"title\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview.get_view_plugin\")",
            "    def test_requires_view_type(self, get_view_plugin):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"view_type\")",
            "",
            "        get_view_plugin.return_value = \"mock_view_plugin\"",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_resource(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(resource_id=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_view_extension(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(view_type=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_dont_require_any_extra_fields(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_into_filters_dict(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"weather\", \"country\"],",
            "            \"filter_values\": [\"Brazil\", \"warm\", \"Argentina\"],",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        expected_filters = {",
            "            \"country\": [\"Brazil\", \"Argentina\"],",
            "            \"weather\": [\"warm\"],",
            "        }",
            "        assert result[\"filters\"] == expected_filters",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_to_list(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        assert result[\"filter_fields\"] == [\"country\"]",
            "        assert result[\"filter_values\"] == [\"Brazil\"]",
            "        assert result[\"filters\"] == {\"country\": [\"Brazil\"]}",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_require_filter_fields_and_values_to_have_same_length(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"country\"],",
            "            \"filter_values\": \"Brazil\",",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_non_filterable_views_dont_accept_filter_fields_and_values(self):",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def _default_resource_view_attributes(self, **kwargs):",
            "        default_attributes = {",
            "            \"resource_id\": factories.Resource()[\"id\"],",
            "            \"view_type\": \"image_view\",",
            "            \"title\": \"View\",",
            "            \"description\": \"A nice view\",",
            "        }",
            "",
            "        default_attributes.update(kwargs)",
            "",
            "        return default_attributes",
            "",
            "    def _configure_datapreview_to_return_filterable_view(",
            "        self, datapreview_mock",
            "    ):",
            "        filterable_view = mock.MagicMock()",
            "        filterable_view.info.return_value = {\"filterable\": True}",
            "        datapreview_mock.get_view_plugin.return_value = filterable_view",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.views.default_views\", \"\")",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_plugins\")",
            "class TestCreateDefaultResourceViews(object):",
            "    def test_add_default_views_to_dataset_resources(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset(",
            "            resources=[",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 1\",",
            "                },",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 2\",",
            "                },",
            "            ]",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = \"image_view\"",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"package_create_default_resource_views\",",
            "            context,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 2",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "        assert created_views[1][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = \"image_view\"",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource_no_dataset_passed(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = \"image_view\"",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestResourceCreate:",
            "    def test_resource_create(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        id = result.pop(\"id\")",
            "",
            "        assert id",
            "",
            "        params.pop(\"package_id\")",
            "        for key in params.keys():",
            "            assert params[key] == result[key]",
            "",
            "    def test_it_requires_package_id(self):",
            "",
            "        data_dict = {\"url\": \"http://data\"}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_doesnt_require_url(self):",
            "        dataset = factories.Dataset()",
            "        data_dict = {\"package_id\": dataset[\"id\"]}",
            "        new_resouce = helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "        data_dict = {\"id\": new_resouce[\"id\"]}",
            "        stored_resource = helpers.call_action(\"resource_show\", **data_dict)",
            "",
            "        assert not stored_resource[\"url\"]",
            "",
            "    def test_mimetype_by_url(self, monkeypatch, tmpdir):",
            "        \"\"\"The mimetype is guessed from the url",
            "",
            "        Real world usage would be externally linking the resource and",
            "        the mimetype would be guessed, based on the url",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        monkeypatch.setattr(ckan.lib.uploader, \"_storage_path\", str(tmpdir))",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/csv\"",
            "",
            "    def test_mimetype_by_url_without_path(self):",
            "        \"\"\"",
            "        The mimetype should not be guessed from url if url contains only domain",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://example.com\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype is None",
            "",
            "    def test_mimetype_by_user(self):",
            "        \"\"\"",
            "        The mimetype is supplied by the user",
            "",
            "        Real world usage would be using the FileStore API or web UI form to create a resource",
            "        and the user wanted to specify the mimetype themselves",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "            \"mimetype\": \"application/csv\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype == \"application/csv\"",
            "",
            "    def test_mimetype_by_upload_by_filename(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file with a filename",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, with a filename plus extension If",
            "        there's no url or the mimetype can't be guessed by the url,",
            "        mimetype will be guessed by the extension in the filename",
            "",
            "        \"\"\"",
            "        content = \"\"\"",
            "        \"info\": {",
            "            \"title\": \"BC Data Catalogue API\",",
            "            \"description\": \"This API provides information about datasets in the BC Data Catalogue.\",",
            "            \"termsOfService\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/API_Terms_of_Use.pdf\",",
            "            \"contact\": {",
            "                \"name\": \"Data BC\",",
            "                \"url\": \"http://data.gov.bc.ca/\",",
            "                \"email\": \"\"",
            "            },",
            "            \"license\": {",
            "                \"name\": \"Open Government License - British Columbia\",",
            "                \"url\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/OGL-vbc2.0.pdf\"",
            "            },",
            "            \"version\": \"3.0.0\"",
            "        }",
            "        \"\"\"",
            "",
            "        result = create_with_upload(",
            "            content, 'test.json', url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"]",
            "        )",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"application/json\"",
            "",
            "    @pytest.mark.ckan_config(\"ckan.mimetype_guess\", \"file_contents\")",
            "    def test_mimetype_by_upload_by_file(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file by the contents inside",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, that has no extension If the mimetype",
            "        can't be guessed by the url or filename, mimetype will be",
            "        guessed by the contents inside the file",
            "",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content, 'test.csv', url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"]",
            "        )",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/plain\"",
            "",
            "    def test_size_of_resource_by_upload(self, create_with_upload):",
            "        \"\"\"",
            "        The size of the resource determined by the uploaded file",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content, 'test.csv', url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"]",
            "        )",
            "",
            "        size = result.pop(\"size\")",
            "",
            "        assert size",
            "        assert size > 0",
            "",
            "    def test_size_of_resource_by_user(self):",
            "        \"\"\"",
            "        The size of the resource is provided by the users",
            "",
            "        Real world usage would be using the FileStore API and the user provides a size for the resource",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "            \"size\": 500,",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        size = int(result.pop(\"size\"))",
            "        assert size == 500",
            "",
            "    @pytest.mark.usefixtures(\"with_request_context\")",
            "    def test_extras(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset(user=user)",
            "",
            "        resource = helpers.call_action(",
            "            \"resource_create\",",
            "            package_id=dataset[\"id\"],",
            "            somekey=\"somevalue\",  # this is how to do resource extras",
            "            extras={u\"someotherkey\": u\"alt234\"},  # this isnt",
            "            subobject={u'hello': u'there'},  # JSON objects supported",
            "            sublist=[1, 2, 3],  # JSON lists suppoted",
            "            format=u\"plain text\",",
            "            url=u\"http://datahub.io/download/\",",
            "        )",
            "",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "        resource = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ][0]",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "",
            "    @freeze_time('2020-02-25 12:00:00')",
            "    def test_metadata_modified_is_set_to_utcnow_when_created(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        assert (result['metadata_modified'] ==",
            "                datetime.datetime.utcnow().isoformat())",
            "",
            "    @pytest.mark.ckan_config('ckan.auth.allow_dataset_collaborators', True)",
            "    @pytest.mark.ckan_config('ckan.auth.allow_admin_collaborators', True)",
            "    @pytest.mark.parametrize('role', ['admin', 'editor'])",
            "    def test_collaborators_can_create_resources(self, role):",
            "",
            "        org1 = factories.Organization()",
            "        dataset = factories.Dataset(owner_org=org1['id'])",
            "",
            "        user = factories.User()",
            "",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=role)",
            "",
            "        context = {",
            "            'user': user['name'],",
            "            'ignore_auth': False,",
            "",
            "        }",
            "",
            "        created_resource = helpers.call_action(",
            "            'resource_create',",
            "            context=context,",
            "            package_id=dataset['id'],",
            "            name='created by collaborator',",
            "            url='https://example.com')",
            "",
            "        assert created_resource['name'] == 'created by collaborator'",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestMemberCreate(object):",
            "    def test_group_member_creation(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"group_member_create\",",
            "            id=group[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == group[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_organization_member_creation(self):",
            "        user = factories.User()",
            "        organization = factories.Organization()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"organization_member_create\",",
            "            id=organization[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == organization[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_group_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", username=\"someuser\", role=\"member\"",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", id=\"someid\", role=\"member\"",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_role_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", id=\"someid\", username=\"someuser\"",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                username=\"someuser\",",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\", id=\"someid\", role=\"member\"",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_role_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\", id=\"someid\", username=\"someuser\"",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestDatasetCreate(object):",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                context=context,",
            "                id=\"1234\",",
            "                name=\"test-dataset\",",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        dataset = helpers.call_action(",
            "            \"package_create\", context=context, id=\"1234\", name=\"test-dataset\"",
            "        )",
            "        assert dataset[\"id\"] == \"1234\"",
            "",
            "    def test_context_is_not_polluted(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(",
            "            \"package_create\", context=context, id=\"1234\", name=\"test-dataset\"",
            "        )",
            "        assert \"id\" not in context",
            "        assert \"package\" not in context",
            "",
            "    def test_id_cant_already_exist(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.Sysadmin()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\", id=dataset[\"id\"], name=\"test-dataset\"",
            "            )",
            "",
            "    def test_name_not_changed_during_deletion(self):",
            "        dataset = factories.Dataset()",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert deleted_dataset[\"name\"] == dataset[\"name\"]",
            "",
            "    def test_name_not_changed_after_restoring(self):",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": factories.Sysadmin()[\"name\"]}",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        restored_dataset = helpers.call_action(",
            "            \"package_patch\", context=context, id=dataset[\"id\"], state=\"active\"",
            "        )",
            "        assert deleted_dataset[\"name\"] == restored_dataset[\"name\"]",
            "        assert deleted_dataset[\"id\"] == restored_dataset[\"id\"]",
            "",
            "    def test_creation_of_dataset_with_name_same_as_of_previously_removed(self):",
            "        dataset = factories.Dataset()",
            "        initial_name = dataset[\"name\"]",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        new_dataset = helpers.call_action(\"package_create\", name=initial_name)",
            "        assert new_dataset[\"name\"] == initial_name",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "",
            "        assert new_dataset[\"id\"] != deleted_dataset[\"id\"]",
            "        assert deleted_dataset[\"name\"] == deleted_dataset[\"id\"]",
            "",
            "    def test_missing_id(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"package_create\")",
            "",
            "    def test_name(self):",
            "        dataset = helpers.call_action(\"package_create\", name=\"some-name\")",
            "",
            "        assert dataset[\"name\"] == \"some-name\"",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"name\"]",
            "            == \"some-name\"",
            "        )",
            "",
            "    def test_title(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\", name=\"test_title\", title=\"New Title\"",
            "        )",
            "",
            "        assert dataset[\"title\"] == \"New Title\"",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"title\"]",
            "            == \"New Title\"",
            "        )",
            "",
            "    def test_extras(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-extras\",",
            "            title=\"Test Extras\",",
            "            extras=[{\"key\": u\"original media\", \"value\": u'\"book\"'}],",
            "        )",
            "",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "",
            "    def test_license(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-license\",",
            "            title=\"Test License\",",
            "            license_id=\"other-open\",",
            "        )",
            "",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "",
            "    def test_notes(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-notes\",",
            "            title=\"Test Notes\",",
            "            notes=\"some notes\",",
            "        )",
            "",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "",
            "    def test_resources(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-resources\",",
            "            title=\"Test Resources\",",
            "            resources=[",
            "                {",
            "                    \"alt_url\": u\"alt123\",",
            "                    \"description\": u\"Full text.\",",
            "                    \"somekey\": \"somevalue\",  # this is how to do resource extras",
            "                    \"extras\": {u\"someotherkey\": u\"alt234\"},  # this isnt",
            "                    \"format\": u\"plain text\",",
            "                    \"hash\": u\"abc123\",",
            "                    \"position\": 0,",
            "                    \"url\": u\"http://datahub.io/download/\",",
            "                },",
            "                {",
            "                    \"description\": u\"Index of the novel\",",
            "                    \"format\": u\"JSON\",",
            "                    \"position\": 1,",
            "                    \"url\": u\"http://datahub.io/index.json\",",
            "                },",
            "            ],",
            "        )",
            "",
            "        resources = dataset[\"resources\"]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "        resources = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "",
            "    def test_tags(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-tags\",",
            "            title=\"Test Tags\",",
            "            tags=[{\"name\": u\"russian\"}, {\"name\": u\"tolstoy\"}],",
            "        )",
            "",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == [\"russian\", \"tolstoy\"]",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == [\"russian\", \"tolstoy\"]",
            "",
            "    def test_return_id_only(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\", name=\"test-id\", context={\"return_id_only\": True}",
            "        )",
            "",
            "        assert isinstance(dataset, string_types)",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestGroupCreate(object):",
            "    def test_create_group(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=\"test-group\"",
            "        )",
            "",
            "        assert len(group[\"users\"]) == 1",
            "        assert group[\"display_name\"] == u\"test-group\"",
            "        assert group[\"package_count\"] == 0",
            "        assert not group[\"is_organization\"]",
            "        assert group[\"type\"] == \"group\"",
            "",
            "    def test_create_group_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            group = helpers.call_action(",
            "                \"group_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_group_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=\"test-group\"",
            "        )",
            "",
            "        assert isinstance(group, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", group)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=\"test-organization\"",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestOrganizationCreate(object):",
            "    def test_create_organization(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == u\"test-organization\"",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == \"organization\"",
            "",
            "    def test_create_organization_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            org = helpers.call_action(",
            "                \"organization_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_organization_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        assert isinstance(org, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", org)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=\"test-organization\"",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "    def test_create_organization_custom_type(self):",
            "        custom_org_type = \"some-custom-type\"",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=\"test-organization\",",
            "            type=custom_org_type,",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == u\"test-organization\"",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == custom_org_type",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestUserCreate(object):",
            "    def test_user_create_with_password_hash(self):",
            "        sysadmin = factories.Sysadmin()",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=\"test@example.com\",",
            "            name=\"test\",",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password == \"pretend-this-is-a-valid-hash\"",
            "",
            "    def test_user_create_password_hash_not_for_normal_users(self):",
            "        normal_user = factories.User()",
            "        context = {\"user\": normal_user[\"name\"], \"ignore_auth\": False}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=\"test@example.com\",",
            "            name=\"test\",",
            "            password=\"required\",",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password != \"pretend-this-is-a-valid-hash\"",
            "",
            "",
            "def _clear_activities():",
            "    from ckan import model",
            "",
            "    model.Session.query(model.ActivityDetail).delete()",
            "    model.Session.query(model.Activity).delete()",
            "    model.Session.flush()",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowDataset(object):",
            "    def test_no_activity(self, app):",
            "",
            "        user = factories.User()",
            "        dataset = factories.Dataset(user=user)",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_dataset\", context={\"user\": user[\"name\"]}, **dataset",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowGroup(object):",
            "    def test_no_activity(self, app):",
            "        user = factories.User()",
            "        group = factories.Group(user=user)",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_group\", context={\"user\": user[\"name\"]}, **group",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowOrganization(object):",
            "    def test_no_activity(self, app):",
            "        user = factories.User()",
            "        org = factories.Organization(user=user)",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_group\", context={\"user\": user[\"name\"]}, **org",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowUser(object):",
            "    def test_no_activity(self, app):",
            "",
            "        user = factories.User()",
            "        user2 = factories.User()",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_user\", context={\"user\": user[\"name\"]}, **user2",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(u\"clean_db\")",
            "class TestApiToken(object):",
            "",
            "    def test_token_created(self):",
            "        from ckan.lib.api_token import decode",
            "        user = factories.User()",
            "        data = helpers.call_action(u\"api_token_create\", context={",
            "            u\"model\": model,",
            "            u\"user\": user[u\"name\"]",
            "        }, user=user[u\"name\"], name=u\"token-name\")",
            "        token = data[u'token']",
            "        jti = decode(token)[u'jti']",
            "        res = model.ApiToken.get(jti)",
            "        assert res.user_id == user[u\"id\"]",
            "        assert res.last_access is None",
            "        assert res.id == jti",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "@pytest.mark.ckan_config(u\"ckan.auth.allow_dataset_collaborators\", False)",
            "def test_create_package_collaborator_when_config_disabled():",
            "",
            "    dataset = factories.Dataset()",
            "    user = factories.User()",
            "    capacity = 'editor'",
            "",
            "    with pytest.raises(logic.ValidationError):",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "@pytest.mark.ckan_config(u\"ckan.auth.allow_dataset_collaborators\", True)",
            "class TestPackageMemberCreate(object):",
            "",
            "    def test_create(self):",
            "",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = 'editor'",
            "",
            "        member = helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "        assert member['package_id'] == dataset['id']",
            "        assert member['user_id'] == user['id']",
            "        assert member['capacity'] == capacity",
            "",
            "        assert model.Session.query(model.PackageMember).count() == 1",
            "",
            "    def test_update(self):",
            "",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = 'editor'",
            "",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity='member')",
            "",
            "        assert model.Session.query(model.PackageMember).count() == 1",
            "",
            "        assert model.Session.query(model.PackageMember).one().capacity == 'member'",
            "",
            "    def test_create_wrong_capacity(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = 'unknown'",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                'package_collaborator_create',",
            "                id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "    def test_create_dataset_not_found(self):",
            "        dataset = {'id': 'xxx'}",
            "        user = factories.User()",
            "        capacity = 'editor'",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                'package_collaborator_create',",
            "                id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "    def test_create_user_not_found(self):",
            "        dataset = factories.Dataset()",
            "        user = {'id': 'yyy'}",
            "        capacity = 'editor'",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                'package_collaborator_create',",
            "                id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestUserPluginExtras(object):",
            "",
            "    def test_stored_on_create_if_sysadmin(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "",
            "        user_dict = {",
            "            'name': 'test-user',",
            "            'email': 'test@example.com',",
            "            'password': '12345678',",
            "            'plugin_extras': {",
            "                'plugin1': {",
            "                    'key1': 'value1'",
            "                }",
            "            }",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {'user': sysadmin['name'], 'ignore_auth': False}",
            "",
            "        created_user = helpers.call_action(",
            "            'user_create', context=context, **user_dict)",
            "",
            "        assert created_user['plugin_extras'] == {",
            "            'plugin1': {",
            "                'key1': 'value1',",
            "            }",
            "        }",
            "",
            "        user_dict = helpers.call_action(",
            "            'user_show', context=context, id=created_user['id'], include_plugin_extras=True)",
            "",
            "        assert user_dict['plugin_extras'] == {",
            "            'plugin1': {",
            "                'key1': 'value1',",
            "            }",
            "        }",
            "",
            "        plugin_extras_from_db = model.Session.execute(",
            "            'SELECT plugin_extras FROM \"user\" WHERE id=:id',",
            "            {'id': created_user['id']}",
            "        ).first().values()[0]",
            "",
            "        assert plugin_extras_from_db == {",
            "            'plugin1': {",
            "                'key1': 'value1',",
            "            }",
            "        }",
            "",
            "    def test_ignored_on_create_if_non_sysadmin(self):",
            "",
            "        author = factories.User()",
            "        sysadmin = factories.Sysadmin()",
            "",
            "        user_dict = {",
            "            'name': 'test-user',",
            "            'email': 'test@example.com',",
            "            'password': '12345678',",
            "            'plugin_extras': {",
            "                'plugin1': {",
            "                    'key1': 'value1'",
            "                }",
            "            }",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {'user': author['name'], 'ignore_auth': False}",
            "",
            "        created_user = helpers.call_action(",
            "            'user_create', context=context, **user_dict)",
            "",
            "        assert 'plugin_extras' not in created_user",
            "",
            "        context = {'user': sysadmin['name'], 'ignore_auth': False}",
            "        user = helpers.call_action(",
            "            'user_show', context=context, id=created_user['id'], include_plugin_extras=True)",
            "",
            "        assert user['plugin_extras'] is None",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestUserImageUrl(object):",
            "    def test_external_picture(self):",
            "",
            "        params = {",
            "            'name': 'test_user',",
            "            'email': 'test@example.com',",
            "            'password': '12345678',",
            "            'image_url': 'https://example.com/mypic.png',",
            "        }",
            "",
            "        user_dict = helpers.call_action(\"user_create\", {}, **params)",
            "",
            "        assert user_dict[\"image_url\"] == \"https://example.com/mypic.png\"",
            "        assert (",
            "            user_dict[\"image_display_url\"] == \"https://example.com/mypic.png\"",
            "        )",
            "",
            "    def test_upload_non_picture_works_without_extra_config(",
            "            self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(\"hello world\", \"file.txt\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_non_picture(self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.txt\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_non_picture_with_png_extension(",
            "            self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_picture(self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "",
            "        some_png = \"\"\"",
            "        89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52",
            "        00 00 00 01 00 00 00 01 08 02 00 00 00 90 77 53",
            "        DE 00 00 00 0C 49 44 41 54 08 D7 63 F8 CF C0 00",
            "        00 03 01 01 00 18 DD 8D B0 00 00 00 00 49 45 4E",
            "        44 AE 42 60 82\"\"\"",
            "        some_png = some_png.replace(' ', '').replace('\\n', '')",
            "        some_png_bytes = bytes(bytearray.fromhex(some_png))",
            "        assert create_with_upload(some_png_bytes, \"file.png\", **params)"
        ],
        "afterPatchFile": [
            "# encoding: utf-8",
            "\"\"\"Unit tests for ckan/logic/action/create.py.",
            "",
            "\"\"\"",
            "import datetime",
            "import mock",
            "import pytest",
            "",
            "import ckan",
            "import ckan.logic as logic",
            "import ckan.model as model",
            "import ckan.tests.factories as factories",
            "import ckan.tests.helpers as helpers",
            "from ckan.common import config",
            "",
            "from six import string_types",
            "",
            "from freezegun import freeze_time",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestUserInvite(object):",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_invited_user_is_created_as_pending(self, _):",
            "        invited_user = self._invite_user_to_group()",
            "",
            "        assert invited_user is not None",
            "        assert invited_user.is_pending()",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_creates_user_with_valid_username(self, _):",
            "        email = \"user$%+abc@email.com\"",
            "        invited_user = self._invite_user_to_group(email)",
            "",
            "        assert invited_user.name.startswith(\"user---abc\"), invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_assigns_user_to_group_in_expected_role(self, _):",
            "        role = \"admin\"",
            "        invited_user = self._invite_user_to_group(role=role)",
            "",
            "        group_ids = invited_user.get_group_ids(capacity=role)",
            "        assert len(group_ids) == 1, group_ids",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_sends_invite(self, send_invite):",
            "        invited_user = self._invite_user_to_group()",
            "",
            "        assert send_invite.called",
            "        assert send_invite.call_args[0][0].id == invited_user.id",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    @mock.patch(\"random.SystemRandom\")",
            "    def test_works_even_if_username_already_exists(self, rand, _):",
            "        # usernames",
            "        rand.return_value.random.side_effect = [1000, 1000, 2000, 3000]",
            "        # passwords (need to set something, otherwise choice will break)",
            "        rand.return_value.choice.side_effect = \"TestPassword1\" * 3",
            "",
            "        for _ in range(3):",
            "            invited_user = self._invite_user_to_group(",
            "                email=\"same{}@email.com\".format(_))",
            "            assert invited_user is not None, invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_email(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_existed_email(self, _):",
            "        factories.User(email=\"email@example.com\")",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=\"email@example.com\")",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_role(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(role=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_raises_not_found(self, _):",
            "        user = factories.User()",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {",
            "            \"email\": \"a@example.com\",",
            "            \"group_id\": \"group_not_found\",",
            "            \"role\": \"admin\",",
            "        }",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_group_id(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(group={\"id\": None})",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_user_name_lowercase_when_email_is_uppercase(self, _):",
            "        invited_user = self._invite_user_to_group(email=\"Maria@example.com\")",
            "",
            "        assert invited_user.name.split(\"-\")[0] == \"maria\"",
            "",
            "    @pytest.mark.ckan_config(\"smtp.server\", \"email.example.com\")",
            "    @pytest.mark.usefixtures(\"with_request_context\")",
            "    def test_smtp_error_returns_error_message(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "        group = factories.Group()",
            "",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "        params = {",
            "            \"email\": \"example-invited-user@example.com\",",
            "            \"group_id\": group[\"id\"],",
            "            \"role\": \"editor\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        # Check that the pending user was deleted",
            "        user = (",
            "            model.Session.query(model.User)",
            "            .filter(model.User.name.like(\"example-invited-user%\"))",
            "            .all()",
            "        )",
            "",
            "        assert user[0].state == \"deleted\"",
            "",
            "    def _invite_user_to_group(",
            "        self, email=\"user@email.com\", group=None, role=\"member\"",
            "    ):",
            "        user = factories.User()",
            "        group = group or factories.Group(user=user)",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {\"email\": email, \"group_id\": group[\"id\"], \"role\": role}",
            "",
            "        result = helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        return model.User.get(result[\"id\"])",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_plugins\")",
            "class TestResourceViewCreate(object):",
            "    def test_resource_view_create(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    def test_requires_resource_id(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"resource_id\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_requires_title(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"title\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview.get_view_plugin\")",
            "    def test_requires_view_type(self, get_view_plugin):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"view_type\")",
            "",
            "        get_view_plugin.return_value = \"mock_view_plugin\"",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_resource(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(resource_id=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_view_extension(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(view_type=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_dont_require_any_extra_fields(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_into_filters_dict(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"weather\", \"country\"],",
            "            \"filter_values\": [\"Brazil\", \"warm\", \"Argentina\"],",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        expected_filters = {",
            "            \"country\": [\"Brazil\", \"Argentina\"],",
            "            \"weather\": [\"warm\"],",
            "        }",
            "        assert result[\"filters\"] == expected_filters",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_to_list(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        assert result[\"filter_fields\"] == [\"country\"]",
            "        assert result[\"filter_values\"] == [\"Brazil\"]",
            "        assert result[\"filters\"] == {\"country\": [\"Brazil\"]}",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_require_filter_fields_and_values_to_have_same_length(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"country\"],",
            "            \"filter_values\": \"Brazil\",",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_non_filterable_views_dont_accept_filter_fields_and_values(self):",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def _default_resource_view_attributes(self, **kwargs):",
            "        default_attributes = {",
            "            \"resource_id\": factories.Resource()[\"id\"],",
            "            \"view_type\": \"image_view\",",
            "            \"title\": \"View\",",
            "            \"description\": \"A nice view\",",
            "        }",
            "",
            "        default_attributes.update(kwargs)",
            "",
            "        return default_attributes",
            "",
            "    def _configure_datapreview_to_return_filterable_view(",
            "        self, datapreview_mock",
            "    ):",
            "        filterable_view = mock.MagicMock()",
            "        filterable_view.info.return_value = {\"filterable\": True}",
            "        datapreview_mock.get_view_plugin.return_value = filterable_view",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.views.default_views\", \"\")",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_plugins\")",
            "class TestCreateDefaultResourceViews(object):",
            "    def test_add_default_views_to_dataset_resources(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset(",
            "            resources=[",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 1\",",
            "                },",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 2\",",
            "                },",
            "            ]",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = \"image_view\"",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"package_create_default_resource_views\",",
            "            context,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 2",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "        assert created_views[1][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = \"image_view\"",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource_no_dataset_passed(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = \"image_view\"",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestResourceCreate:",
            "    def test_resource_create(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        id = result.pop(\"id\")",
            "",
            "        assert id",
            "",
            "        params.pop(\"package_id\")",
            "        for key in params.keys():",
            "            assert params[key] == result[key]",
            "",
            "    def test_it_requires_package_id(self):",
            "",
            "        data_dict = {\"url\": \"http://data\"}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_doesnt_require_url(self):",
            "        dataset = factories.Dataset()",
            "        data_dict = {\"package_id\": dataset[\"id\"]}",
            "        new_resouce = helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "        data_dict = {\"id\": new_resouce[\"id\"]}",
            "        stored_resource = helpers.call_action(\"resource_show\", **data_dict)",
            "",
            "        assert not stored_resource[\"url\"]",
            "",
            "    def test_mimetype_by_url(self, monkeypatch, tmpdir):",
            "        \"\"\"The mimetype is guessed from the url",
            "",
            "        Real world usage would be externally linking the resource and",
            "        the mimetype would be guessed, based on the url",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        monkeypatch.setattr(ckan.lib.uploader, \"_storage_path\", str(tmpdir))",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/csv\"",
            "",
            "    def test_mimetype_by_url_without_path(self):",
            "        \"\"\"",
            "        The mimetype should not be guessed from url if url contains only domain",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://example.com\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype is None",
            "",
            "    def test_mimetype_by_user(self):",
            "        \"\"\"",
            "        The mimetype is supplied by the user",
            "",
            "        Real world usage would be using the FileStore API or web UI form to create a resource",
            "        and the user wanted to specify the mimetype themselves",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "            \"mimetype\": \"application/csv\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype == \"application/csv\"",
            "",
            "    def test_mimetype_by_upload_by_filename(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file with a filename",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, with a filename plus extension If",
            "        there's no url or the mimetype can't be guessed by the url,",
            "        mimetype will be guessed by the extension in the filename",
            "",
            "        \"\"\"",
            "        content = \"\"\"",
            "        \"info\": {",
            "            \"title\": \"BC Data Catalogue API\",",
            "            \"description\": \"This API provides information about datasets in the BC Data Catalogue.\",",
            "            \"termsOfService\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/API_Terms_of_Use.pdf\",",
            "            \"contact\": {",
            "                \"name\": \"Data BC\",",
            "                \"url\": \"http://data.gov.bc.ca/\",",
            "                \"email\": \"\"",
            "            },",
            "            \"license\": {",
            "                \"name\": \"Open Government License - British Columbia\",",
            "                \"url\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/OGL-vbc2.0.pdf\"",
            "            },",
            "            \"version\": \"3.0.0\"",
            "        }",
            "        \"\"\"",
            "",
            "        result = create_with_upload(",
            "            content, 'test.json', url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"]",
            "        )",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"application/json\"",
            "",
            "    @pytest.mark.ckan_config(\"ckan.mimetype_guess\", \"file_contents\")",
            "    def test_mimetype_by_upload_by_file(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file by the contents inside",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, that has no extension If the mimetype",
            "        can't be guessed by the url or filename, mimetype will be",
            "        guessed by the contents inside the file",
            "",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content, 'test.csv', url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"]",
            "        )",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/plain\"",
            "",
            "    def test_size_of_resource_by_upload(self, create_with_upload):",
            "        \"\"\"",
            "        The size of the resource determined by the uploaded file",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content, 'test.csv', url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"]",
            "        )",
            "",
            "        size = result.pop(\"size\")",
            "",
            "        assert size",
            "        assert size > 0",
            "",
            "    def test_size_of_resource_by_user(self):",
            "        \"\"\"",
            "        The size of the resource is provided by the users",
            "",
            "        Real world usage would be using the FileStore API and the user provides a size for the resource",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "            \"size\": 500,",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        size = int(result.pop(\"size\"))",
            "        assert size == 500",
            "",
            "    @pytest.mark.usefixtures(\"with_request_context\")",
            "    def test_extras(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset(user=user)",
            "",
            "        resource = helpers.call_action(",
            "            \"resource_create\",",
            "            package_id=dataset[\"id\"],",
            "            somekey=\"somevalue\",  # this is how to do resource extras",
            "            extras={u\"someotherkey\": u\"alt234\"},  # this isnt",
            "            subobject={u'hello': u'there'},  # JSON objects supported",
            "            sublist=[1, 2, 3],  # JSON lists suppoted",
            "            format=u\"plain text\",",
            "            url=u\"http://datahub.io/download/\",",
            "        )",
            "",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "        resource = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ][0]",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "",
            "    @freeze_time('2020-02-25 12:00:00')",
            "    def test_metadata_modified_is_set_to_utcnow_when_created(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        assert (result['metadata_modified'] ==",
            "                datetime.datetime.utcnow().isoformat())",
            "",
            "    @pytest.mark.ckan_config('ckan.auth.allow_dataset_collaborators', True)",
            "    @pytest.mark.ckan_config('ckan.auth.allow_admin_collaborators', True)",
            "    @pytest.mark.parametrize('role', ['admin', 'editor'])",
            "    def test_collaborators_can_create_resources(self, role):",
            "",
            "        org1 = factories.Organization()",
            "        dataset = factories.Dataset(owner_org=org1['id'])",
            "",
            "        user = factories.User()",
            "",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=role)",
            "",
            "        context = {",
            "            'user': user['name'],",
            "            'ignore_auth': False,",
            "",
            "        }",
            "",
            "        created_resource = helpers.call_action(",
            "            'resource_create',",
            "            context=context,",
            "            package_id=dataset['id'],",
            "            name='created by collaborator',",
            "            url='https://example.com')",
            "",
            "        assert created_resource['name'] == 'created by collaborator'",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestMemberCreate(object):",
            "    def test_group_member_creation(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"group_member_create\",",
            "            id=group[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == group[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_organization_member_creation(self):",
            "        user = factories.User()",
            "        organization = factories.Organization()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"organization_member_create\",",
            "            id=organization[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == organization[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_group_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", username=\"someuser\", role=\"member\"",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", id=\"someid\", role=\"member\"",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_role_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", id=\"someid\", username=\"someuser\"",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                username=\"someuser\",",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\", id=\"someid\", role=\"member\"",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_role_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\", id=\"someid\", username=\"someuser\"",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestDatasetCreate(object):",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                context=context,",
            "                id=\"1234\",",
            "                name=\"test-dataset\",",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        dataset = helpers.call_action(",
            "            \"package_create\", context=context, id=\"1234\", name=\"test-dataset\"",
            "        )",
            "        assert dataset[\"id\"] == \"1234\"",
            "",
            "    def test_context_is_not_polluted(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(",
            "            \"package_create\", context=context, id=\"1234\", name=\"test-dataset\"",
            "        )",
            "        assert \"id\" not in context",
            "        assert \"package\" not in context",
            "",
            "    def test_id_cant_already_exist(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.Sysadmin()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\", id=dataset[\"id\"], name=\"test-dataset\"",
            "            )",
            "",
            "    def test_name_not_changed_during_deletion(self):",
            "        dataset = factories.Dataset()",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert deleted_dataset[\"name\"] == dataset[\"name\"]",
            "",
            "    def test_name_not_changed_after_restoring(self):",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": factories.Sysadmin()[\"name\"]}",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        restored_dataset = helpers.call_action(",
            "            \"package_patch\", context=context, id=dataset[\"id\"], state=\"active\"",
            "        )",
            "        assert deleted_dataset[\"name\"] == restored_dataset[\"name\"]",
            "        assert deleted_dataset[\"id\"] == restored_dataset[\"id\"]",
            "",
            "    def test_creation_of_dataset_with_name_same_as_of_previously_removed(self):",
            "        dataset = factories.Dataset()",
            "        initial_name = dataset[\"name\"]",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        new_dataset = helpers.call_action(\"package_create\", name=initial_name)",
            "        assert new_dataset[\"name\"] == initial_name",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "",
            "        assert new_dataset[\"id\"] != deleted_dataset[\"id\"]",
            "        assert deleted_dataset[\"name\"] == deleted_dataset[\"id\"]",
            "",
            "    def test_missing_id(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"package_create\")",
            "",
            "    def test_name(self):",
            "        dataset = helpers.call_action(\"package_create\", name=\"some-name\")",
            "",
            "        assert dataset[\"name\"] == \"some-name\"",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"name\"]",
            "            == \"some-name\"",
            "        )",
            "",
            "    def test_title(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\", name=\"test_title\", title=\"New Title\"",
            "        )",
            "",
            "        assert dataset[\"title\"] == \"New Title\"",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"title\"]",
            "            == \"New Title\"",
            "        )",
            "",
            "    def test_extras(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-extras\",",
            "            title=\"Test Extras\",",
            "            extras=[{\"key\": u\"original media\", \"value\": u'\"book\"'}],",
            "        )",
            "",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "",
            "    def test_license(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-license\",",
            "            title=\"Test License\",",
            "            license_id=\"other-open\",",
            "        )",
            "",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "",
            "    def test_notes(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-notes\",",
            "            title=\"Test Notes\",",
            "            notes=\"some notes\",",
            "        )",
            "",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "",
            "    def test_resources(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-resources\",",
            "            title=\"Test Resources\",",
            "            resources=[",
            "                {",
            "                    \"alt_url\": u\"alt123\",",
            "                    \"description\": u\"Full text.\",",
            "                    \"somekey\": \"somevalue\",  # this is how to do resource extras",
            "                    \"extras\": {u\"someotherkey\": u\"alt234\"},  # this isnt",
            "                    \"format\": u\"plain text\",",
            "                    \"hash\": u\"abc123\",",
            "                    \"position\": 0,",
            "                    \"url\": u\"http://datahub.io/download/\",",
            "                },",
            "                {",
            "                    \"description\": u\"Index of the novel\",",
            "                    \"format\": u\"JSON\",",
            "                    \"position\": 1,",
            "                    \"url\": u\"http://datahub.io/index.json\",",
            "                },",
            "            ],",
            "        )",
            "",
            "        resources = dataset[\"resources\"]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "        resources = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "",
            "    def test_tags(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=\"test-tags\",",
            "            title=\"Test Tags\",",
            "            tags=[{\"name\": u\"russian\"}, {\"name\": u\"tolstoy\"}],",
            "        )",
            "",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == [\"russian\", \"tolstoy\"]",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == [\"russian\", \"tolstoy\"]",
            "",
            "    def test_return_id_only(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\", name=\"test-id\", context={\"return_id_only\": True}",
            "        )",
            "",
            "        assert isinstance(dataset, string_types)",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestGroupCreate(object):",
            "    def test_create_group(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=\"test-group\"",
            "        )",
            "",
            "        assert len(group[\"users\"]) == 1",
            "        assert group[\"display_name\"] == u\"test-group\"",
            "        assert group[\"package_count\"] == 0",
            "        assert not group[\"is_organization\"]",
            "        assert group[\"type\"] == \"group\"",
            "",
            "    def test_create_group_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            group = helpers.call_action(",
            "                \"group_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_group_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=\"test-group\"",
            "        )",
            "",
            "        assert isinstance(group, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", group)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=\"test-organization\"",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestOrganizationCreate(object):",
            "    def test_create_organization(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == u\"test-organization\"",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == \"organization\"",
            "",
            "    def test_create_organization_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            org = helpers.call_action(",
            "                \"organization_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_organization_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        assert isinstance(org, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", org)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\", context=context, name=\"test-organization\"",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=\"test-organization\"",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "    def test_create_organization_custom_type(self):",
            "        custom_org_type = \"some-custom-type\"",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=\"test-organization\",",
            "            type=custom_org_type,",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == u\"test-organization\"",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == custom_org_type",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestUserCreate(object):",
            "    def test_user_create_with_password_hash(self):",
            "        sysadmin = factories.Sysadmin()",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=\"test@example.com\",",
            "            name=\"test\",",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password == \"pretend-this-is-a-valid-hash\"",
            "",
            "    def test_user_create_password_hash_not_for_normal_users(self):",
            "        normal_user = factories.User()",
            "        context = {\"user\": normal_user[\"name\"], \"ignore_auth\": False}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=\"test@example.com\",",
            "            name=\"test\",",
            "            password=\"required\",",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password != \"pretend-this-is-a-valid-hash\"",
            "",
            "    def test_anon_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": None,",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_normal_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.User()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_sysadmin_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.Sysadmin()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_anon_users_can_not_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": None,",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] != \"custom_id\"",
            "",
            "    def test_normal_users_can_not_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.User()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] != \"custom_id\"",
            "",
            "    def test_sysadmin_can_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "        context = {",
            "            \"user\": factories.Sysadmin()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] == \"custom_id\"",
            "",
            "",
            "def _clear_activities():",
            "    from ckan import model",
            "",
            "    model.Session.query(model.ActivityDetail).delete()",
            "    model.Session.query(model.Activity).delete()",
            "    model.Session.flush()",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowDataset(object):",
            "    def test_no_activity(self, app):",
            "",
            "        user = factories.User()",
            "        dataset = factories.Dataset(user=user)",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_dataset\", context={\"user\": user[\"name\"]}, **dataset",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowGroup(object):",
            "    def test_no_activity(self, app):",
            "        user = factories.User()",
            "        group = factories.Group(user=user)",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_group\", context={\"user\": user[\"name\"]}, **group",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowOrganization(object):",
            "    def test_no_activity(self, app):",
            "        user = factories.User()",
            "        org = factories.Organization(user=user)",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_group\", context={\"user\": user[\"name\"]}, **org",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\", \"with_request_context\")",
            "class TestFollowUser(object):",
            "    def test_no_activity(self, app):",
            "",
            "        user = factories.User()",
            "        user2 = factories.User()",
            "        _clear_activities()",
            "        helpers.call_action(",
            "            \"follow_user\", context={\"user\": user[\"name\"]}, **user2",
            "        )",
            "",
            "        activities = helpers.call_action(\"user_activity_list\", id=user[\"id\"])",
            "        assert [activity[\"activity_type\"] for activity in activities] == []",
            "        # A follow creates no Activity, since:",
            "        # https://github.com/ckan/ckan/pull/317",
            "",
            "",
            "@pytest.mark.usefixtures(u\"clean_db\")",
            "class TestApiToken(object):",
            "",
            "    def test_token_created(self):",
            "        from ckan.lib.api_token import decode",
            "        user = factories.User()",
            "        data = helpers.call_action(u\"api_token_create\", context={",
            "            u\"model\": model,",
            "            u\"user\": user[u\"name\"]",
            "        }, user=user[u\"name\"], name=u\"token-name\")",
            "        token = data[u'token']",
            "        jti = decode(token)[u'jti']",
            "        res = model.ApiToken.get(jti)",
            "        assert res.user_id == user[u\"id\"]",
            "        assert res.last_access is None",
            "        assert res.id == jti",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "@pytest.mark.ckan_config(u\"ckan.auth.allow_dataset_collaborators\", False)",
            "def test_create_package_collaborator_when_config_disabled():",
            "",
            "    dataset = factories.Dataset()",
            "    user = factories.User()",
            "    capacity = 'editor'",
            "",
            "    with pytest.raises(logic.ValidationError):",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "@pytest.mark.ckan_config(u\"ckan.auth.allow_dataset_collaborators\", True)",
            "class TestPackageMemberCreate(object):",
            "",
            "    def test_create(self):",
            "",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = 'editor'",
            "",
            "        member = helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "        assert member['package_id'] == dataset['id']",
            "        assert member['user_id'] == user['id']",
            "        assert member['capacity'] == capacity",
            "",
            "        assert model.Session.query(model.PackageMember).count() == 1",
            "",
            "    def test_update(self):",
            "",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = 'editor'",
            "",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "        helpers.call_action(",
            "            'package_collaborator_create',",
            "            id=dataset['id'], user_id=user['id'], capacity='member')",
            "",
            "        assert model.Session.query(model.PackageMember).count() == 1",
            "",
            "        assert model.Session.query(model.PackageMember).one().capacity == 'member'",
            "",
            "    def test_create_wrong_capacity(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = 'unknown'",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                'package_collaborator_create',",
            "                id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "    def test_create_dataset_not_found(self):",
            "        dataset = {'id': 'xxx'}",
            "        user = factories.User()",
            "        capacity = 'editor'",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                'package_collaborator_create',",
            "                id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "    def test_create_user_not_found(self):",
            "        dataset = factories.Dataset()",
            "        user = {'id': 'yyy'}",
            "        capacity = 'editor'",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                'package_collaborator_create',",
            "                id=dataset['id'], user_id=user['id'], capacity=capacity)",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestUserPluginExtras(object):",
            "",
            "    def test_stored_on_create_if_sysadmin(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "",
            "        user_dict = {",
            "            'name': 'test-user',",
            "            'email': 'test@example.com',",
            "            'password': '12345678',",
            "            'plugin_extras': {",
            "                'plugin1': {",
            "                    'key1': 'value1'",
            "                }",
            "            }",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {'user': sysadmin['name'], 'ignore_auth': False}",
            "",
            "        created_user = helpers.call_action(",
            "            'user_create', context=context, **user_dict)",
            "",
            "        assert created_user['plugin_extras'] == {",
            "            'plugin1': {",
            "                'key1': 'value1',",
            "            }",
            "        }",
            "",
            "        user_dict = helpers.call_action(",
            "            'user_show', context=context, id=created_user['id'], include_plugin_extras=True)",
            "",
            "        assert user_dict['plugin_extras'] == {",
            "            'plugin1': {",
            "                'key1': 'value1',",
            "            }",
            "        }",
            "",
            "        plugin_extras_from_db = model.Session.execute(",
            "            'SELECT plugin_extras FROM \"user\" WHERE id=:id',",
            "            {'id': created_user['id']}",
            "        ).first().values()[0]",
            "",
            "        assert plugin_extras_from_db == {",
            "            'plugin1': {",
            "                'key1': 'value1',",
            "            }",
            "        }",
            "",
            "    def test_ignored_on_create_if_non_sysadmin(self):",
            "",
            "        author = factories.User()",
            "        sysadmin = factories.Sysadmin()",
            "",
            "        user_dict = {",
            "            'name': 'test-user',",
            "            'email': 'test@example.com',",
            "            'password': '12345678',",
            "            'plugin_extras': {",
            "                'plugin1': {",
            "                    'key1': 'value1'",
            "                }",
            "            }",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {'user': author['name'], 'ignore_auth': False}",
            "",
            "        created_user = helpers.call_action(",
            "            'user_create', context=context, **user_dict)",
            "",
            "        assert 'plugin_extras' not in created_user",
            "",
            "        context = {'user': sysadmin['name'], 'ignore_auth': False}",
            "        user = helpers.call_action(",
            "            'user_show', context=context, id=created_user['id'], include_plugin_extras=True)",
            "",
            "        assert user['plugin_extras'] is None",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestUserImageUrl(object):",
            "    def test_external_picture(self):",
            "",
            "        params = {",
            "            'name': 'test_user',",
            "            'email': 'test@example.com',",
            "            'password': '12345678',",
            "            'image_url': 'https://example.com/mypic.png',",
            "        }",
            "",
            "        user_dict = helpers.call_action(\"user_create\", {}, **params)",
            "",
            "        assert user_dict[\"image_url\"] == \"https://example.com/mypic.png\"",
            "        assert (",
            "            user_dict[\"image_display_url\"] == \"https://example.com/mypic.png\"",
            "        )",
            "",
            "    def test_upload_non_picture_works_without_extra_config(",
            "            self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(\"hello world\", \"file.txt\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_non_picture(self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.txt\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_non_picture_with_png_extension(",
            "            self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_picture(self, create_with_upload):",
            "        params = {",
            "            \"name\": \"test_user_1\",",
            "            \"email\": \"test1@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "",
            "        some_png = \"\"\"",
            "        89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52",
            "        00 00 00 01 00 00 00 01 08 02 00 00 00 90 77 53",
            "        DE 00 00 00 0C 49 44 41 54 08 D7 63 F8 CF C0 00",
            "        00 03 01 01 00 18 DD 8D B0 00 00 00 00 49 45 4E",
            "        44 AE 42 60 82\"\"\"",
            "        some_png = some_png.replace(' ', '').replace('\\n', '')",
            "        some_png_bytes = bytes(bytearray.fromhex(some_png))",
            "        assert create_with_upload(some_png_bytes, \"file.png\", **params)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "ckan.tests.logic.action.test_create.TestUserCreate.self",
            "wagtail.search.utils"
        ]
    }
}