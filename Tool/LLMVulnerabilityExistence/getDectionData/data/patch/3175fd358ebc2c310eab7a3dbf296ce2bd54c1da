{
    "sydent/http/servlets/emailservlet.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from twisted.web.resource import Resource"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from sydent.util.stringutils import is_valid_client_secret"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from sydent.util.stringutils import is_valid_client_secret, MAX_EMAIL_ADDRESS_LENGTH"
            },
            "5": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from sydent.util.emailutils import EmailAddressException, EmailSendException"
            },
            "6": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from sydent.validators import ("
            },
            "7": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     IncorrectClientSecretException,"
            },
            "8": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "                 'error': 'Invalid client_secret provided'"
            },
            "9": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             }"
            },
            "10": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        if not (0 < len(email) <= MAX_EMAIL_ADDRESS_LENGTH):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            request.setResponseCode(400)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            return {"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+                'errcode': 'M_INVALID_PARAM',"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+                'error': 'Invalid email provided'"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            }"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         ipaddress = self.sydent.ip_from_request(request)"
            },
            "19": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         brand = self.sydent.brand_from_request(request)"
            },
            "20": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.resource import Resource",
            "",
            "from sydent.util.stringutils import is_valid_client_secret",
            "from sydent.util.emailutils import EmailAddressException, EmailSendException",
            "from sydent.validators import (",
            "    IncorrectClientSecretException,",
            "    InvalidSessionIdException,",
            "    IncorrectSessionTokenException,",
            "    SessionExpiredException,",
            ")",
            "",
            "",
            "from sydent.http.servlets import get_args, jsonwrap, send_cors",
            "from sydent.http.auth import authV2",
            "",
            "",
            "class EmailRequestCodeServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.require_auth = require_auth",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        if self.require_auth:",
            "            authV2(self.sydent, request)",
            "",
            "        args = get_args(request, ('email', 'client_secret', 'send_attempt'))",
            "",
            "        email = args['email']",
            "        sendAttempt = args['send_attempt']",
            "        clientSecret = args['client_secret']",
            "",
            "        if not is_valid_client_secret(clientSecret):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'Invalid client_secret provided'",
            "            }",
            "",
            "        ipaddress = self.sydent.ip_from_request(request)",
            "        brand = self.sydent.brand_from_request(request)",
            "",
            "        nextLink = None",
            "        if 'next_link' in args and not args['next_link'].startswith(\"file:///\"):",
            "            nextLink = args['next_link']",
            "",
            "        try:",
            "            sid = self.sydent.validators.email.requestToken(",
            "                email, clientSecret, sendAttempt, nextLink, ipaddress=ipaddress, brand=brand,",
            "            )",
            "            resp = {'sid': str(sid)}",
            "        except EmailAddressException:",
            "            request.setResponseCode(400)",
            "            resp = {'errcode': 'M_INVALID_EMAIL', 'error': 'Invalid email address'}",
            "        except EmailSendException:",
            "            request.setResponseCode(500)",
            "            resp = {'errcode': 'M_EMAIL_SEND_ERROR', 'error': 'Failed to send email'}",
            "",
            "        return resp",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''",
            "",
            "",
            "class EmailValidateCodeServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.require_auth = require_auth",
            "",
            "    def render_GET(self, request):",
            "        args = get_args(request, ('nextLink',), required=False)",
            "",
            "        resp = None",
            "        try:",
            "            resp = self.do_validate_request(request)",
            "        except:",
            "            pass",
            "        if resp and 'success' in resp and resp['success']:",
            "            msg = \"Verification successful! Please return to your Matrix client to continue.\"",
            "            if 'nextLink' in args:",
            "                next_link = args['nextLink']",
            "                if not next_link.startswith(\"file:///\"):",
            "                    request.setResponseCode(302)",
            "                    request.setHeader(\"Location\", next_link)",
            "        else:",
            "            msg = \"Verification failed: you may need to request another verification email\"",
            "",
            "        brand = self.sydent.brand_from_request(request)",
            "        templateFile = self.sydent.get_branded_template(",
            "            brand,",
            "            \"verify_response_template.html\",",
            "            ('http', 'verify_response_template'),",
            "        )",
            "",
            "        request.setHeader(\"Content-Type\", \"text/html\")",
            "        res = open(templateFile).read() % {'message': msg}",
            "        return res.encode(\"UTF-8\")",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        if self.require_auth:",
            "            authV2(self.sydent, request)",
            "",
            "        return self.do_validate_request(request)",
            "",
            "    def do_validate_request(self, request):",
            "        \"\"\"",
            "        Extracts information about a validation session from the request and",
            "        attempts to validate that session.",
            "",
            "        :param request: The request to extract information about the session from.",
            "        :type request: twisted.web.server.Request",
            "",
            "        :return: A dict with a \"success\" key which value indicates whether the",
            "            validation succeeded. If the validation failed, this dict also includes",
            "            a \"errcode\" and a \"error\" keys which include information about the failure.",
            "        :rtype: dict[str, bool or str]",
            "        \"\"\"",
            "        args = get_args(request, ('token', 'sid', 'client_secret'))",
            "",
            "        sid = args['sid']",
            "        tokenString = args['token']",
            "        clientSecret = args['client_secret']",
            "",
            "        if not is_valid_client_secret(clientSecret):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'Invalid client_secret provided'",
            "            }",
            "",
            "        try:",
            "            return self.sydent.validators.email.validateSessionWithToken(sid, clientSecret, tokenString)",
            "        except IncorrectClientSecretException:",
            "            return {'success': False, 'errcode': 'M_INVALID_PARAM',",
            "                    'error': \"Client secret does not match the one given when requesting the token\"}",
            "        except SessionExpiredException:",
            "            return {'success': False, 'errcode': 'M_SESSION_EXPIRED',",
            "                    'error': \"This validation session has expired: call requestToken again\"}",
            "        except InvalidSessionIdException:",
            "            return {'success': False, 'errcode': 'M_INVALID_PARAM',",
            "                    'error': \"The token doesn't match\"}",
            "        except IncorrectSessionTokenException:",
            "            return {'success': False, 'errcode': 'M_NO_VALID_SESSION',",
            "                    'error': \"No session could be found with this sid\"}",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2014 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "from twisted.web.resource import Resource",
            "",
            "from sydent.util.stringutils import is_valid_client_secret, MAX_EMAIL_ADDRESS_LENGTH",
            "from sydent.util.emailutils import EmailAddressException, EmailSendException",
            "from sydent.validators import (",
            "    IncorrectClientSecretException,",
            "    InvalidSessionIdException,",
            "    IncorrectSessionTokenException,",
            "    SessionExpiredException,",
            ")",
            "",
            "",
            "from sydent.http.servlets import get_args, jsonwrap, send_cors",
            "from sydent.http.auth import authV2",
            "",
            "",
            "class EmailRequestCodeServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.require_auth = require_auth",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        if self.require_auth:",
            "            authV2(self.sydent, request)",
            "",
            "        args = get_args(request, ('email', 'client_secret', 'send_attempt'))",
            "",
            "        email = args['email']",
            "        sendAttempt = args['send_attempt']",
            "        clientSecret = args['client_secret']",
            "",
            "        if not is_valid_client_secret(clientSecret):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'Invalid client_secret provided'",
            "            }",
            "",
            "        if not (0 < len(email) <= MAX_EMAIL_ADDRESS_LENGTH):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'Invalid email provided'",
            "            }",
            "",
            "        ipaddress = self.sydent.ip_from_request(request)",
            "        brand = self.sydent.brand_from_request(request)",
            "",
            "        nextLink = None",
            "        if 'next_link' in args and not args['next_link'].startswith(\"file:///\"):",
            "            nextLink = args['next_link']",
            "",
            "        try:",
            "            sid = self.sydent.validators.email.requestToken(",
            "                email, clientSecret, sendAttempt, nextLink, ipaddress=ipaddress, brand=brand,",
            "            )",
            "            resp = {'sid': str(sid)}",
            "        except EmailAddressException:",
            "            request.setResponseCode(400)",
            "            resp = {'errcode': 'M_INVALID_EMAIL', 'error': 'Invalid email address'}",
            "        except EmailSendException:",
            "            request.setResponseCode(500)",
            "            resp = {'errcode': 'M_EMAIL_SEND_ERROR', 'error': 'Failed to send email'}",
            "",
            "        return resp",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''",
            "",
            "",
            "class EmailValidateCodeServlet(Resource):",
            "    isLeaf = True",
            "",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.require_auth = require_auth",
            "",
            "    def render_GET(self, request):",
            "        args = get_args(request, ('nextLink',), required=False)",
            "",
            "        resp = None",
            "        try:",
            "            resp = self.do_validate_request(request)",
            "        except:",
            "            pass",
            "        if resp and 'success' in resp and resp['success']:",
            "            msg = \"Verification successful! Please return to your Matrix client to continue.\"",
            "            if 'nextLink' in args:",
            "                next_link = args['nextLink']",
            "                if not next_link.startswith(\"file:///\"):",
            "                    request.setResponseCode(302)",
            "                    request.setHeader(\"Location\", next_link)",
            "        else:",
            "            msg = \"Verification failed: you may need to request another verification email\"",
            "",
            "        brand = self.sydent.brand_from_request(request)",
            "        templateFile = self.sydent.get_branded_template(",
            "            brand,",
            "            \"verify_response_template.html\",",
            "            ('http', 'verify_response_template'),",
            "        )",
            "",
            "        request.setHeader(\"Content-Type\", \"text/html\")",
            "        res = open(templateFile).read() % {'message': msg}",
            "        return res.encode(\"UTF-8\")",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        if self.require_auth:",
            "            authV2(self.sydent, request)",
            "",
            "        return self.do_validate_request(request)",
            "",
            "    def do_validate_request(self, request):",
            "        \"\"\"",
            "        Extracts information about a validation session from the request and",
            "        attempts to validate that session.",
            "",
            "        :param request: The request to extract information about the session from.",
            "        :type request: twisted.web.server.Request",
            "",
            "        :return: A dict with a \"success\" key which value indicates whether the",
            "            validation succeeded. If the validation failed, this dict also includes",
            "            a \"errcode\" and a \"error\" keys which include information about the failure.",
            "        :rtype: dict[str, bool or str]",
            "        \"\"\"",
            "        args = get_args(request, ('token', 'sid', 'client_secret'))",
            "",
            "        sid = args['sid']",
            "        tokenString = args['token']",
            "        clientSecret = args['client_secret']",
            "",
            "        if not is_valid_client_secret(clientSecret):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'Invalid client_secret provided'",
            "            }",
            "",
            "        try:",
            "            return self.sydent.validators.email.validateSessionWithToken(sid, clientSecret, tokenString)",
            "        except IncorrectClientSecretException:",
            "            return {'success': False, 'errcode': 'M_INVALID_PARAM',",
            "                    'error': \"Client secret does not match the one given when requesting the token\"}",
            "        except SessionExpiredException:",
            "            return {'success': False, 'errcode': 'M_SESSION_EXPIRED',",
            "                    'error': \"This validation session has expired: call requestToken again\"}",
            "        except InvalidSessionIdException:",
            "            return {'success': False, 'errcode': 'M_INVALID_PARAM',",
            "                    'error': \"The token doesn't match\"}",
            "        except IncorrectSessionTokenException:",
            "            return {'success': False, 'errcode': 'M_NO_VALID_SESSION',",
            "                    'error': \"No session could be found with this sid\"}",
            "",
            "    def render_OPTIONS(self, request):",
            "        send_cors(request)",
            "        return b''"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "20": []
        },
        "addLocation": []
    },
    "sydent/http/servlets/store_invite_servlet.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError"
            },
            "1": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " from sydent.http.auth import authV2"
            },
            "2": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " from sydent.util.emailutils import sendEmail"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+from sydent.util.stringutils import MAX_EMAIL_ADDRESS_LENGTH"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " class StoreInviteServlet(Resource):"
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     def __init__(self, syd, require_auth=False):"
            },
            "8": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "                 \"error\": \"Didn't understand medium '%s'\" % (medium,),"
            },
            "9": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "             }"
            },
            "10": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        if not (0 < len(address) <= MAX_EMAIL_ADDRESS_LENGTH):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            request.setResponseCode(400)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+            return {"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                'errcode': 'M_INVALID_PARAM',"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                'error': 'Invalid email provided'"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            }"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         token = self._randomString(128)"
            },
            "19": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         tokenStore = JoinTokenStore(self.sydent)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import nacl.signing",
            "import random",
            "import string",
            "from email.header import Header",
            "",
            "from six import string_types",
            "from twisted.web.resource import Resource",
            "from unpaddedbase64 import encode_base64",
            "",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "from sydent.db.threepid_associations import GlobalAssociationStore",
            "",
            "from sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError",
            "from sydent.http.auth import authV2",
            "from sydent.util.emailutils import sendEmail",
            "",
            "class StoreInviteServlet(Resource):",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.random = random.SystemRandom()",
            "        self.require_auth = require_auth",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))",
            "        medium = args[\"medium\"]",
            "        address = args[\"address\"]",
            "        roomId = args[\"room_id\"]",
            "        sender = args[\"sender\"]",
            "",
            "        verified_sender = None",
            "        if self.require_auth:",
            "            account = authV2(self.sydent, request)",
            "            verified_sender = sender",
            "            if account.userId != sender:",
            "                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")",
            "",
            "        globalAssocStore = GlobalAssociationStore(self.sydent)",
            "        mxid = globalAssocStore.getMxid(medium, address)",
            "        if mxid:",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_THREEPID_IN_USE\",",
            "                \"error\": \"Binding already known\",",
            "                \"mxid\": mxid,",
            "            }",
            "",
            "        if medium != \"email\":",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_UNRECOGNIZED\",",
            "                \"error\": \"Didn't understand medium '%s'\" % (medium,),",
            "            }",
            "",
            "        token = self._randomString(128)",
            "",
            "        tokenStore = JoinTokenStore(self.sydent)",
            "",
            "        ephemeralPrivateKey = nacl.signing.SigningKey.generate()",
            "        ephemeralPublicKey = ephemeralPrivateKey.verify_key",
            "",
            "        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)",
            "        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)",
            "",
            "        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)",
            "        tokenStore.storeToken(medium, address, roomId, sender, token)",
            "",
            "        # Variables to substitute in the template.",
            "        substitutions = {}",
            "        # Include all arguments sent via the request.",
            "        for k, v in args.items():",
            "            if isinstance(v, string_types):",
            "                substitutions[k] = v",
            "        substitutions[\"token\"] = token",
            "",
            "        # Substitutions that the template requires, but are optional to provide",
            "        # to the API.",
            "        extra_substitutions = [",
            "            'sender_display_name',",
            "            'token',",
            "            'room_name',",
            "            'bracketed_room_name',",
            "            'room_avatar_url',",
            "            'sender_avatar_url',",
            "            'guest_user_id',",
            "            'guest_access_token',",
            "        ]",
            "        for k in extra_substitutions:",
            "            substitutions.setdefault(k, '')",
            "",
            "        substitutions[\"bracketed_verified_sender\"] = \"\"",
            "        if verified_sender:",
            "            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)",
            "",
            "        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64",
            "        if substitutions[\"room_name\"] != '':",
            "            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]",
            "",
            "        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location",
            "        if 'org.matrix.web_client_location' in substitutions:",
            "            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")",
            "",
            "        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')",
            "        substitutions[\"subject_header_value\"] = subject_header.encode()",
            "",
            "        brand = self.sydent.brand_from_request(request)",
            "        templateFile = self.sydent.get_branded_template(",
            "            brand,",
            "            \"invite_template.eml\",",
            "            ('email', 'email.invite_template'),",
            "        )",
            "",
            "        sendEmail(self.sydent, templateFile, address, substitutions)",
            "",
            "        pubKey = self.sydent.keyring.ed25519.verify_key",
            "        pubKeyBase64 = encode_base64(pubKey.encode())",
            "",
            "        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)",
            "",
            "        keysToReturn = []",
            "        keysToReturn.append({",
            "            \"public_key\": pubKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",",
            "        })",
            "        keysToReturn.append({",
            "            \"public_key\": ephemeralPublicKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",",
            "        })",
            "",
            "        resp = {",
            "            \"token\": token,",
            "            \"public_key\": pubKeyBase64,",
            "            \"public_keys\": keysToReturn,",
            "            \"display_name\": self.redact_email_address(address),",
            "        }",
            "",
            "        return resp",
            "",
            "    def redact_email_address(self, address):",
            "        \"\"\"",
            "        Redacts the content of a 3PID address. Redacts both the email's username and",
            "        domain independently.",
            "",
            "        :param address: The address to redact.",
            "        :type address: unicode",
            "",
            "        :return: The redacted address.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # Extract strings from the address",
            "        username, domain = address.split(u\"@\", 1)",
            "",
            "        # Obfuscate strings",
            "        redacted_username = self._redact(username, self.sydent.username_obfuscate_characters)",
            "        redacted_domain = self._redact(domain, self.sydent.domain_obfuscate_characters)",
            "",
            "        return redacted_username + u\"@\" + redacted_domain",
            "",
            "    def _redact(self, s, characters_to_reveal):",
            "        \"\"\"",
            "        Redacts the content of a string, using a given amount of characters to reveal.",
            "        If the string is shorter than the given threshold, redact it based on length.",
            "",
            "        :param s: The string to redact.",
            "        :type s: unicode",
            "",
            "        :param characters_to_reveal: How many characters of the string to leave before",
            "            the '...'",
            "        :type characters_to_reveal: int",
            "",
            "        :return: The redacted string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # If the string is shorter than the defined threshold, redact based on length",
            "        if len(s) <= characters_to_reveal:",
            "            if len(s) > 5:",
            "                return s[:3] + u\"...\"",
            "            if len(s) > 1:",
            "                return s[0] + u\"...\"",
            "            return u\"...\"",
            "",
            "        # Otherwise truncate it and add an ellipses",
            "        return s[:characters_to_reveal] + u\"...\"",
            "",
            "    def _randomString(self, length):",
            "        \"\"\"",
            "        Generate a random string of the given length.",
            "",
            "        :param length: The length of the string to generate.",
            "        :type length: int",
            "",
            "        :return: The generated string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        return u''.join(self.random.choice(string.ascii_letters) for _ in range(length))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "# Copyright 2015 OpenMarket Ltd",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from __future__ import absolute_import",
            "",
            "import nacl.signing",
            "import random",
            "import string",
            "from email.header import Header",
            "",
            "from six import string_types",
            "from twisted.web.resource import Resource",
            "from unpaddedbase64 import encode_base64",
            "",
            "from sydent.db.invite_tokens import JoinTokenStore",
            "from sydent.db.threepid_associations import GlobalAssociationStore",
            "",
            "from sydent.http.servlets import get_args, send_cors, jsonwrap, MatrixRestError",
            "from sydent.http.auth import authV2",
            "from sydent.util.emailutils import sendEmail",
            "from sydent.util.stringutils import MAX_EMAIL_ADDRESS_LENGTH",
            "",
            "",
            "class StoreInviteServlet(Resource):",
            "    def __init__(self, syd, require_auth=False):",
            "        self.sydent = syd",
            "        self.random = random.SystemRandom()",
            "        self.require_auth = require_auth",
            "",
            "    @jsonwrap",
            "    def render_POST(self, request):",
            "        send_cors(request)",
            "",
            "        args = get_args(request, (\"medium\", \"address\", \"room_id\", \"sender\",))",
            "        medium = args[\"medium\"]",
            "        address = args[\"address\"]",
            "        roomId = args[\"room_id\"]",
            "        sender = args[\"sender\"]",
            "",
            "        verified_sender = None",
            "        if self.require_auth:",
            "            account = authV2(self.sydent, request)",
            "            verified_sender = sender",
            "            if account.userId != sender:",
            "                raise MatrixRestError(403, \"M_UNAUTHORIZED\", \"'sender' doesn't match\")",
            "",
            "        globalAssocStore = GlobalAssociationStore(self.sydent)",
            "        mxid = globalAssocStore.getMxid(medium, address)",
            "        if mxid:",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_THREEPID_IN_USE\",",
            "                \"error\": \"Binding already known\",",
            "                \"mxid\": mxid,",
            "            }",
            "",
            "        if medium != \"email\":",
            "            request.setResponseCode(400)",
            "            return {",
            "                \"errcode\": \"M_UNRECOGNIZED\",",
            "                \"error\": \"Didn't understand medium '%s'\" % (medium,),",
            "            }",
            "",
            "        if not (0 < len(address) <= MAX_EMAIL_ADDRESS_LENGTH):",
            "            request.setResponseCode(400)",
            "            return {",
            "                'errcode': 'M_INVALID_PARAM',",
            "                'error': 'Invalid email provided'",
            "            }",
            "",
            "        token = self._randomString(128)",
            "",
            "        tokenStore = JoinTokenStore(self.sydent)",
            "",
            "        ephemeralPrivateKey = nacl.signing.SigningKey.generate()",
            "        ephemeralPublicKey = ephemeralPrivateKey.verify_key",
            "",
            "        ephemeralPrivateKeyBase64 = encode_base64(ephemeralPrivateKey.encode(), True)",
            "        ephemeralPublicKeyBase64 = encode_base64(ephemeralPublicKey.encode(), True)",
            "",
            "        tokenStore.storeEphemeralPublicKey(ephemeralPublicKeyBase64)",
            "        tokenStore.storeToken(medium, address, roomId, sender, token)",
            "",
            "        # Variables to substitute in the template.",
            "        substitutions = {}",
            "        # Include all arguments sent via the request.",
            "        for k, v in args.items():",
            "            if isinstance(v, string_types):",
            "                substitutions[k] = v",
            "        substitutions[\"token\"] = token",
            "",
            "        # Substitutions that the template requires, but are optional to provide",
            "        # to the API.",
            "        extra_substitutions = [",
            "            'sender_display_name',",
            "            'token',",
            "            'room_name',",
            "            'bracketed_room_name',",
            "            'room_avatar_url',",
            "            'sender_avatar_url',",
            "            'guest_user_id',",
            "            'guest_access_token',",
            "        ]",
            "        for k in extra_substitutions:",
            "            substitutions.setdefault(k, '')",
            "",
            "        substitutions[\"bracketed_verified_sender\"] = \"\"",
            "        if verified_sender:",
            "            substitutions[\"bracketed_verified_sender\"] = \"(%s) \" % (verified_sender,)",
            "",
            "        substitutions[\"ephemeral_private_key\"] = ephemeralPrivateKeyBase64",
            "        if substitutions[\"room_name\"] != '':",
            "            substitutions[\"bracketed_room_name\"] = \"(%s) \" % substitutions[\"room_name\"]",
            "",
            "        substitutions[\"web_client_location\"] = self.sydent.default_web_client_location",
            "        if 'org.matrix.web_client_location' in substitutions:",
            "            substitutions[\"web_client_location\"] = substitutions.pop(\"org.matrix.web_client_location\")",
            "",
            "        subject_header = Header(self.sydent.cfg.get('email', 'email.invite.subject', raw=True) % substitutions, 'utf8')",
            "        substitutions[\"subject_header_value\"] = subject_header.encode()",
            "",
            "        brand = self.sydent.brand_from_request(request)",
            "        templateFile = self.sydent.get_branded_template(",
            "            brand,",
            "            \"invite_template.eml\",",
            "            ('email', 'email.invite_template'),",
            "        )",
            "",
            "        sendEmail(self.sydent, templateFile, address, substitutions)",
            "",
            "        pubKey = self.sydent.keyring.ed25519.verify_key",
            "        pubKeyBase64 = encode_base64(pubKey.encode())",
            "",
            "        baseUrl = \"%s/_matrix/identity/api/v1\" % (self.sydent.cfg.get('http', 'client_http_base'),)",
            "",
            "        keysToReturn = []",
            "        keysToReturn.append({",
            "            \"public_key\": pubKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/isvalid\",",
            "        })",
            "        keysToReturn.append({",
            "            \"public_key\": ephemeralPublicKeyBase64,",
            "            \"key_validity_url\": baseUrl + \"/pubkey/ephemeral/isvalid\",",
            "        })",
            "",
            "        resp = {",
            "            \"token\": token,",
            "            \"public_key\": pubKeyBase64,",
            "            \"public_keys\": keysToReturn,",
            "            \"display_name\": self.redact_email_address(address),",
            "        }",
            "",
            "        return resp",
            "",
            "    def redact_email_address(self, address):",
            "        \"\"\"",
            "        Redacts the content of a 3PID address. Redacts both the email's username and",
            "        domain independently.",
            "",
            "        :param address: The address to redact.",
            "        :type address: unicode",
            "",
            "        :return: The redacted address.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # Extract strings from the address",
            "        username, domain = address.split(u\"@\", 1)",
            "",
            "        # Obfuscate strings",
            "        redacted_username = self._redact(username, self.sydent.username_obfuscate_characters)",
            "        redacted_domain = self._redact(domain, self.sydent.domain_obfuscate_characters)",
            "",
            "        return redacted_username + u\"@\" + redacted_domain",
            "",
            "    def _redact(self, s, characters_to_reveal):",
            "        \"\"\"",
            "        Redacts the content of a string, using a given amount of characters to reveal.",
            "        If the string is shorter than the given threshold, redact it based on length.",
            "",
            "        :param s: The string to redact.",
            "        :type s: unicode",
            "",
            "        :param characters_to_reveal: How many characters of the string to leave before",
            "            the '...'",
            "        :type characters_to_reveal: int",
            "",
            "        :return: The redacted string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        # If the string is shorter than the defined threshold, redact based on length",
            "        if len(s) <= characters_to_reveal:",
            "            if len(s) > 5:",
            "                return s[:3] + u\"...\"",
            "            if len(s) > 1:",
            "                return s[0] + u\"...\"",
            "            return u\"...\"",
            "",
            "        # Otherwise truncate it and add an ellipses",
            "        return s[:characters_to_reveal] + u\"...\"",
            "",
            "    def _randomString(self, length):",
            "        \"\"\"",
            "        Generate a random string of the given length.",
            "",
            "        :param length: The length of the string to generate.",
            "        :type length: int",
            "",
            "        :return: The generated string.",
            "        :rtype: unicode",
            "        \"\"\"",
            "        return u''.join(self.random.choice(string.ascii_letters) for _ in range(length))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "sydent.http.servlets.store_invite_servlet.StoreInviteServlet.render_POST.resp",
            "sydent.http.servlets.store_invite_servlet.StoreInviteServlet.render_POST.keysToReturn",
            "sydent.http.servlets.store_invite_servlet.StoreInviteServlet.render_POST.extra_substitutions",
            "django.db.models.sql.query.Query"
        ]
    },
    "sydent/util/stringutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from twisted.internet.abstract import isIPAddress, isIPv6Address"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " # https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-client_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+CLIENT_SECRET_REGEX = re.compile(r\"^[0-9a-zA-Z\\.=_\\-]+$\")"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " # hostname/domain name"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " # https://regex101.com/r/OyN1lg/2"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " hostname_regex = re.compile("
            },
            "9": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\","
            },
            "10": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     flags=re.IGNORECASE)"
            },
            "11": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+# it's unclear what the maximum length of an email address is. RFC3696 (as corrected"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+# by errata) says:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+#    the upper limit on address lengths should normally be considered to be 254."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+#"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+# In practice, mail servers appear to be more tolerant and allow 400 characters"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+# or so. Let's allow 500, which should be plenty for everyone."
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+#"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+MAX_EMAIL_ADDRESS_LENGTH = 500"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " def is_valid_client_secret(client_secret):"
            },
            "23": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     \"\"\"Validate that a given string matches the client_secret regex defined by the spec"
            },
            "24": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     :return: Whether the client_secret is valid"
            },
            "25": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     :rtype: bool"
            },
            "26": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     \"\"\""
            },
            "27": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return client_secret_regex.match(client_secret) is not None"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    return ("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        0 < len(client_secret) <= 255"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        and CLIENT_SECRET_REGEX.match(client_secret) is not None"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    )"
            },
            "32": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " def is_valid_hostname(string: str) -> bool:"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2020 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import re",
            "from typing import Optional, Tuple",
            "",
            "from twisted.internet.abstract import isIPAddress, isIPv6Address",
            "",
            "# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken",
            "client_secret_regex = re.compile(r\"^[0-9a-zA-Z\\.\\=\\_\\-]+$\")",
            "",
            "# hostname/domain name",
            "# https://regex101.com/r/OyN1lg/2",
            "hostname_regex = re.compile(",
            "    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",",
            "    flags=re.IGNORECASE)",
            "",
            "",
            "def is_valid_client_secret(client_secret):",
            "    \"\"\"Validate that a given string matches the client_secret regex defined by the spec",
            "",
            "    :param client_secret: The client_secret to validate",
            "    :type client_secret: str",
            "",
            "    :return: Whether the client_secret is valid",
            "    :rtype: bool",
            "    \"\"\"",
            "    return client_secret_regex.match(client_secret) is not None",
            "",
            "",
            "def is_valid_hostname(string: str) -> bool:",
            "    \"\"\"Validate that a given string is a valid hostname or domain name.",
            "",
            "    For domain names, this only validates that the form is right (for",
            "    instance, it doesn't check that the TLD is valid).",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid hostname",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    return hostname_regex.match(string) is not None",
            "",
            "",
            "def parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:",
            "    \"\"\"Split a server name into host/port parts.",
            "",
            "    No validation is done on the host part. The port part is validated to be",
            "    a valid port number.",
            "",
            "    Args:",
            "        server_name: server name to parse",
            "",
            "    Returns:",
            "        host/port parts.",
            "",
            "    Raises:",
            "        ValueError if the server name could not be parsed.",
            "    \"\"\"",
            "    try:",
            "        if server_name[-1] == \"]\":",
            "            # ipv6 literal, hopefully",
            "            return server_name, None",
            "",
            "        host_port = server_name.rsplit(\":\", 1)",
            "        host = host_port[0]",
            "        port = host_port[1] if host_port[1:] else None",
            "",
            "        if port:",
            "            port_num = int(port)",
            "",
            "            # exclude things like '08090' or ' 8090'",
            "            if port != str(port_num) or not (1 <= port_num < 65536):",
            "                raise ValueError(\"Invalid port\")",
            "",
            "        return host, port",
            "    except Exception:",
            "        raise ValueError(\"Invalid server name '%s'\" % server_name)",
            "",
            "",
            "def is_valid_matrix_server_name(string: str) -> bool:",
            "    \"\"\"Validate that the given string is a valid Matrix server name.",
            "",
            "    A string is a valid Matrix server name if it is one of the following, plus",
            "    an optional port:",
            "",
            "    a. IPv4 address",
            "    b. IPv6 literal (`[IPV6_ADDRESS]`)",
            "    c. A valid hostname",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid Matrix server name",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    try:",
            "        host, port = parse_server_name(string)",
            "    except ValueError:",
            "        return False",
            "",
            "    valid_ipv4_addr = isIPAddress(host)",
            "    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])",
            "",
            "    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2020 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import re",
            "from typing import Optional, Tuple",
            "",
            "from twisted.internet.abstract import isIPAddress, isIPv6Address",
            "",
            "# https://matrix.org/docs/spec/client_server/r0.6.0#post-matrix-client-r0-register-email-requesttoken",
            "CLIENT_SECRET_REGEX = re.compile(r\"^[0-9a-zA-Z\\.=_\\-]+$\")",
            "",
            "# hostname/domain name",
            "# https://regex101.com/r/OyN1lg/2",
            "hostname_regex = re.compile(",
            "    r\"^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$\",",
            "    flags=re.IGNORECASE)",
            "",
            "# it's unclear what the maximum length of an email address is. RFC3696 (as corrected",
            "# by errata) says:",
            "#    the upper limit on address lengths should normally be considered to be 254.",
            "#",
            "# In practice, mail servers appear to be more tolerant and allow 400 characters",
            "# or so. Let's allow 500, which should be plenty for everyone.",
            "#",
            "MAX_EMAIL_ADDRESS_LENGTH = 500",
            "",
            "",
            "def is_valid_client_secret(client_secret):",
            "    \"\"\"Validate that a given string matches the client_secret regex defined by the spec",
            "",
            "    :param client_secret: The client_secret to validate",
            "    :type client_secret: str",
            "",
            "    :return: Whether the client_secret is valid",
            "    :rtype: bool",
            "    \"\"\"",
            "    return (",
            "        0 < len(client_secret) <= 255",
            "        and CLIENT_SECRET_REGEX.match(client_secret) is not None",
            "    )",
            "",
            "",
            "def is_valid_hostname(string: str) -> bool:",
            "    \"\"\"Validate that a given string is a valid hostname or domain name.",
            "",
            "    For domain names, this only validates that the form is right (for",
            "    instance, it doesn't check that the TLD is valid).",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid hostname",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    return hostname_regex.match(string) is not None",
            "",
            "",
            "def parse_server_name(server_name: str) -> Tuple[str, Optional[int]]:",
            "    \"\"\"Split a server name into host/port parts.",
            "",
            "    No validation is done on the host part. The port part is validated to be",
            "    a valid port number.",
            "",
            "    Args:",
            "        server_name: server name to parse",
            "",
            "    Returns:",
            "        host/port parts.",
            "",
            "    Raises:",
            "        ValueError if the server name could not be parsed.",
            "    \"\"\"",
            "    try:",
            "        if server_name[-1] == \"]\":",
            "            # ipv6 literal, hopefully",
            "            return server_name, None",
            "",
            "        host_port = server_name.rsplit(\":\", 1)",
            "        host = host_port[0]",
            "        port = host_port[1] if host_port[1:] else None",
            "",
            "        if port:",
            "            port_num = int(port)",
            "",
            "            # exclude things like '08090' or ' 8090'",
            "            if port != str(port_num) or not (1 <= port_num < 65536):",
            "                raise ValueError(\"Invalid port\")",
            "",
            "        return host, port",
            "    except Exception:",
            "        raise ValueError(\"Invalid server name '%s'\" % server_name)",
            "",
            "",
            "def is_valid_matrix_server_name(string: str) -> bool:",
            "    \"\"\"Validate that the given string is a valid Matrix server name.",
            "",
            "    A string is a valid Matrix server name if it is one of the following, plus",
            "    an optional port:",
            "",
            "    a. IPv4 address",
            "    b. IPv6 literal (`[IPV6_ADDRESS]`)",
            "    c. A valid hostname",
            "",
            "    :param string: The string to validate",
            "    :type string: str",
            "",
            "    :return: Whether the input is a valid Matrix server name",
            "    :rtype: bool",
            "    \"\"\"",
            "",
            "    try:",
            "        host, port = parse_server_name(string)",
            "    except ValueError:",
            "        return False",
            "",
            "    valid_ipv4_addr = isIPAddress(host)",
            "    valid_ipv6_literal = host[0] == \"[\" and host[-1] == \"]\" and isIPv6Address(host[1:-1])",
            "",
            "    return valid_ipv4_addr or valid_ipv6_literal or is_valid_hostname(host)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [
                "client_secret_regex"
            ],
            "39": [
                "is_valid_client_secret"
            ]
        },
        "addLocation": []
    }
}