{
    "asyncua/client/ua_client.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " Low level binary client"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import asyncio"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+import copy"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import logging"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Awaitable, Callable, Dict, List, Optional, Union"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from asyncua import ua"
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from ..ua.ua_binary import struct_from_binary, uatcp_to_binary, struct_to_binary, nodeid_from_binary, header_from_binary"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from ..ua.uaerrors import BadTimeout, BadNoSubscription, BadSessionClosed, BadUserAccessDenied, UaStructParsingError"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ..common.connection import SecureConnection"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from ..common.connection import SecureConnection, TransportLimits"
            },
            "12": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " class UASocketProtocol(asyncio.Protocol):"
            },
            "15": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     OPEN = 'open'"
            },
            "16": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     CLOSED = 'closed'"
            },
            "17": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, timeout: float = 1, security_policy: ua.SecurityPolicy = ua.SecurityPolicy()):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    def __init__(self, timeout: float = 1, security_policy: ua.SecurityPolicy = ua.SecurityPolicy(), limits: TransportLimits = None):"
            },
            "20": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         \"\"\""
            },
            "21": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         :param timeout: Timeout in seconds"
            },
            "22": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         :param security_policy: Security policy (optional)"
            },
            "23": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         self._request_id = 0"
            },
            "24": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         self._request_handle = 0"
            },
            "25": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         self._callbackmap: Dict[int, asyncio.Future] = {}"
            },
            "26": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._connection = SecureConnection(security_policy)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        if limits is None:"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            limits = TransportLimits(65535, 65535, 0, 0)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        else:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+            limits = copy.deep_copy(limits)  # Make a copy because the limits can change in the session"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        self._connection = SecureConnection(security_policy, limits)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         self.state = self.INITIALIZED"
            },
            "34": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         self.closed: bool = False"
            },
            "35": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         # needed to pass params from asynchronous request to synchronous data receive callback, as well as"
            },
            "36": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             self._call_callback(0, msg)"
            },
            "37": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "         elif isinstance(msg, ua.ErrorMessage):"
            },
            "38": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             self.logger.fatal(\"Received an error: %r\", msg)"
            },
            "39": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._call_callback(0, ua.UaStatusCodeError(msg.Error.value))"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            self.disconnect_socket()"
            },
            "41": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         else:"
            },
            "42": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             raise ua.UaError(f\"Unsupported message type: {msg}\")"
            },
            "43": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 115,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Low level binary client",
            "\"\"\"",
            "import asyncio",
            "import logging",
            "from typing import Awaitable, Callable, Dict, List, Optional, Union",
            "",
            "from asyncua import ua",
            "from ..ua.ua_binary import struct_from_binary, uatcp_to_binary, struct_to_binary, nodeid_from_binary, header_from_binary",
            "from ..ua.uaerrors import BadTimeout, BadNoSubscription, BadSessionClosed, BadUserAccessDenied, UaStructParsingError",
            "from ..common.connection import SecureConnection",
            "",
            "",
            "class UASocketProtocol(asyncio.Protocol):",
            "    \"\"\"",
            "    Handle socket connection and send ua messages.",
            "    Timeout is the timeout used while waiting for an ua answer from server.",
            "    \"\"\"",
            "    INITIALIZED = 'initialized'",
            "    OPEN = 'open'",
            "    CLOSED = 'closed'",
            "",
            "    def __init__(self, timeout: float = 1, security_policy: ua.SecurityPolicy = ua.SecurityPolicy()):",
            "        \"\"\"",
            "        :param timeout: Timeout in seconds",
            "        :param security_policy: Security policy (optional)",
            "        \"\"\"",
            "        self.logger = logging.getLogger(f\"{__name__}.UASocketProtocol\")",
            "        self.transport: Optional[asyncio.Transport] = None",
            "        self.receive_buffer: Optional[bytes] = None",
            "        self.is_receiving = False",
            "        self.timeout = timeout",
            "        self.authentication_token = ua.NodeId()",
            "        self._request_id = 0",
            "        self._request_handle = 0",
            "        self._callbackmap: Dict[int, asyncio.Future] = {}",
            "        self._connection = SecureConnection(security_policy)",
            "        self.state = self.INITIALIZED",
            "        self.closed: bool = False",
            "        # needed to pass params from asynchronous request to synchronous data receive callback, as well as",
            "        # passing back the processed response to the request so that it can return it.",
            "        self._open_secure_channel_exchange: Union[ua.OpenSecureChannelResponse, ua.OpenSecureChannelParameters, None] = None",
            "        # Hook for upperlayer tasks before a request is send (optional)",
            "        self.pre_request_hook: Optional[Callable[[], Awaitable[None]]] = None",
            "",
            "    def connection_made(self, transport: asyncio.Transport):  # type: ignore",
            "        self.state = self.OPEN",
            "        self.transport = transport",
            "",
            "    def connection_lost(self, exc: Optional[Exception]):",
            "        self.logger.info(\"Socket has closed connection\")",
            "        self.state = self.CLOSED",
            "        self.transport = None",
            "",
            "    def data_received(self, data: bytes):",
            "        if self.receive_buffer:",
            "            data = self.receive_buffer + data",
            "            self.receive_buffer = None",
            "        self._process_received_data(data)",
            "",
            "    def _process_received_data(self, data: bytes):",
            "        \"\"\"",
            "        Try to parse received data as asyncua message. Data may be chunked but will be in correct order.",
            "        See: https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received",
            "        Reassembly is done by filling up a buffer until it verifies as a valid message (or a MessageChunk).",
            "        \"\"\"",
            "        buf = ua.utils.Buffer(data)",
            "        while True:",
            "            try:",
            "                try:",
            "                    header = header_from_binary(buf)",
            "                except ua.utils.NotEnoughData:",
            "                    self.logger.debug('Not enough data while parsing header from server, waiting for more')",
            "                    self.receive_buffer = data",
            "                    return",
            "                if len(buf) < header.body_size:",
            "                    self.logger.debug('We did not receive enough data from server. Need %s got %s', header.body_size, len(buf))",
            "                    self.receive_buffer = data",
            "                    return",
            "                msg = self._connection.receive_from_header_and_body(header, buf)",
            "                self._process_received_message(msg)",
            "                if header.MessageType == ua.MessageType.SecureOpen:",
            "                    params: ua.OpenSecureChannelParameters = self._open_secure_channel_exchange",
            "                    response: ua.OpenSecureChannelResponse = struct_from_binary(ua.OpenSecureChannelResponse, msg.body())",
            "                    response.ResponseHeader.ServiceResult.check()",
            "                    self._open_secure_channel_exchange = response",
            "                    self._connection.set_channel(response.Parameters, params.RequestType, params.ClientNonce)",
            "                if not buf:",
            "                    return",
            "                # Buffer still has bytes left, try to process again",
            "                data = bytes(buf)",
            "            except Exception:",
            "                self.logger.exception('Exception raised while parsing message from server')",
            "                self.disconnect_socket()",
            "                return",
            "",
            "    def _process_received_message(self, msg: Union[ua.Message, ua.Acknowledge, ua.ErrorMessage]):",
            "        if msg is None:",
            "            pass",
            "        elif isinstance(msg, ua.Message):",
            "            self._call_callback(msg.request_id(), msg.body())",
            "        elif isinstance(msg, ua.Acknowledge):",
            "            self._call_callback(0, msg)",
            "        elif isinstance(msg, ua.ErrorMessage):",
            "            self.logger.fatal(\"Received an error: %r\", msg)",
            "            self._call_callback(0, ua.UaStatusCodeError(msg.Error.value))",
            "        else:",
            "            raise ua.UaError(f\"Unsupported message type: {msg}\")",
            "",
            "    def _send_request(self, request, timeout: float = 1, message_type=ua.MessageType.SecureMessage) -> asyncio.Future:",
            "        \"\"\"",
            "        Send request to server, lower-level method.",
            "        Timeout is the timeout written in ua header.",
            "        :param request: Request",
            "        :param timeout: Timeout in seconds",
            "        :param message_type: UA Message Type (optional)",
            "        :return: Future that resolves with the Response",
            "        \"\"\"",
            "        self._setup_request_header(request.RequestHeader, timeout)",
            "        self.logger.debug('Sending: %s', request)",
            "        try:",
            "            binreq = struct_to_binary(request)",
            "        except Exception:",
            "            # reset request handle if any error",
            "            # see self._setup_request_header",
            "            self._request_handle -= 1",
            "            raise",
            "        self._request_id += 1",
            "        future = asyncio.get_running_loop().create_future()",
            "        self._callbackmap[self._request_id] = future",
            "",
            "        # Change to the new security token if the connection has been renewed.",
            "        if self._connection.next_security_token.TokenId != 0:",
            "            self._connection.revolve_tokens()",
            "",
            "        msg = self._connection.message_to_binary(binreq, message_type=message_type, request_id=self._request_id)",
            "        if self.transport is not None:",
            "            self.transport.write(msg)",
            "        return future",
            "",
            "    async def send_request(self, request, timeout: Optional[float] = None, message_type=ua.MessageType.SecureMessage):",
            "        \"\"\"",
            "        Send a request to the server.",
            "        Timeout is the timeout written in ua header.",
            "        Returns response object if no callback is provided.",
            "        \"\"\"",
            "        timeout = self.timeout if timeout is None else timeout",
            "        if self.pre_request_hook:",
            "            # This will propagade exceptions from background tasks to the libary user before calling a request which will",
            "            # timeout then.",
            "            await self.pre_request_hook()",
            "        try:",
            "            data = await asyncio.wait_for(self._send_request(request, timeout, message_type), timeout if timeout else None)",
            "        except Exception:",
            "            if self.state != self.OPEN:",
            "                raise ConnectionError(\"Connection is closed\") from None",
            "            raise",
            "        self.check_answer(data, f\" in response to {request.__class__.__name__}\")",
            "        return data",
            "",
            "    def check_answer(self, data, context):",
            "        data = data.copy()",
            "        typeid = nodeid_from_binary(data)",
            "        if typeid == ua.FourByteNodeId(ua.ObjectIds.ServiceFault_Encoding_DefaultBinary):",
            "            hdr = struct_from_binary(ua.ResponseHeader, data)",
            "            self.logger.warning(\"ServiceFault (%s, diagnostics: %s) from server received %s\", hdr.ServiceResult.name, hdr.ServiceDiagnostics, context)",
            "            hdr.ServiceResult.check()",
            "            return False",
            "        return True",
            "",
            "    def _call_callback(self, request_id, body):",
            "        try:",
            "            self._callbackmap[request_id].set_result(body)",
            "        except KeyError as ex:",
            "            raise ua.UaError(f\"No request found for request id: {request_id}, pending are {self._callbackmap.keys()}, body was {body}\") from ex",
            "        except asyncio.InvalidStateError:",
            "            if not self.closed:",
            "                self.logger.warning(\"Future for request id %s is already done\", request_id)",
            "                return",
            "            self.logger.debug(\"Future for request id %s not handled due to disconnect\", request_id)",
            "        del self._callbackmap[request_id]",
            "",
            "    def _setup_request_header(self, hdr: ua.RequestHeader, timeout=1) -> None:",
            "        \"\"\"",
            "        :param hdr: Request header",
            "        :param timeout: Timeout in seconds",
            "        \"\"\"",
            "        hdr.AuthenticationToken = self.authentication_token",
            "        self._request_handle += 1",
            "        hdr.RequestHandle = self._request_handle",
            "        hdr.TimeoutHint = int(timeout * 1000)",
            "",
            "    def disconnect_socket(self):",
            "        self.logger.info(\"Request to close socket received\")",
            "        if self.transport:",
            "            self.transport.close()",
            "        else:",
            "            self.logger.warning(\"disconnect_socket was called but transport is None\")",
            "",
            "    async def send_hello(self, url, max_messagesize: int = 0, max_chunkcount: int = 0):",
            "        hello = ua.Hello()",
            "        hello.EndpointUrl = url",
            "        hello.MaxMessageSize = max_messagesize",
            "        hello.MaxChunkCount = max_chunkcount",
            "        ack = asyncio.Future()",
            "        self._callbackmap[0] = ack",
            "        if self.transport is not None:",
            "            self.transport.write(uatcp_to_binary(ua.MessageType.Hello, hello))",
            "        return await asyncio.wait_for(ack, self.timeout)",
            "",
            "    async def open_secure_channel(self, params):",
            "        self.logger.info(\"open_secure_channel\")",
            "        request = ua.OpenSecureChannelRequest()",
            "        request.Parameters = params",
            "        if self._open_secure_channel_exchange is not None:",
            "            raise RuntimeError('Two Open Secure Channel requests can not happen too close to each other. ' 'The response must be processed and returned before the next request can be sent.')",
            "        self._open_secure_channel_exchange = params",
            "        await asyncio.wait_for(self._send_request(request, message_type=ua.MessageType.SecureOpen), self.timeout)",
            "        _return = self._open_secure_channel_exchange.Parameters",
            "        self._open_secure_channel_exchange = None",
            "        return _return",
            "",
            "    async def close_secure_channel(self):",
            "        \"\"\"",
            "        Close secure channel.",
            "        It seems to trigger a shutdown of socket in most servers, so be prepare to reconnect.",
            "        OPC UA specs Part 6, 7.1.4 say that Server does not send a CloseSecureChannel response",
            "        and should just close socket.",
            "        \"\"\"",
            "        self.logger.info(\"close_secure_channel\")",
            "        request = ua.CloseSecureChannelRequest()",
            "        future = self._send_request(request, message_type=ua.MessageType.SecureClose)",
            "        # don't expect any more answers",
            "        future.cancel()",
            "        self._callbackmap.clear()",
            "        # some servers send a response here, most do not ... so we ignore",
            "",
            "",
            "class UaClient:",
            "    \"\"\"",
            "    low level OPC-UA client.",
            "",
            "    It implements (almost) all methods defined in asyncua spec",
            "    taking in argument the structures defined in asyncua spec.",
            "",
            "    In this Python implementation  most of the structures are defined in",
            "    uaprotocol_auto.py and uaprotocol_hand.py available under asyncua.ua",
            "    \"\"\"",
            "    def __init__(self, timeout: float = 1.0):",
            "        \"\"\"",
            "        :param timeout: Timout in seconds",
            "        \"\"\"",
            "        self.logger = logging.getLogger(f'{__name__}.UaClient')",
            "        self._subscription_callbacks = {}",
            "        self._timeout = timeout",
            "        self.security_policy = ua.SecurityPolicy()",
            "        self.protocol: UASocketProtocol = None",
            "        self._publish_task = None",
            "        self._pre_request_hook: Optional[Callable[[], Awaitable[None]]] = None",
            "",
            "    def set_security(self, policy: ua.SecurityPolicy):",
            "        self.security_policy = policy",
            "",
            "    def _make_protocol(self):",
            "        self.protocol = UASocketProtocol(self._timeout, security_policy=self.security_policy)",
            "        self.protocol.pre_request_hook = self._pre_request_hook",
            "        return self.protocol",
            "",
            "    @property",
            "    def pre_request_hook(self) -> Callable[[], Awaitable[None]]:",
            "        return self._pre_request_hook",
            "",
            "    @pre_request_hook.setter",
            "    def pre_request_hook(self, hook: Optional[Callable[[], Awaitable[None]]]):",
            "        self._pre_request_hook = hook",
            "        if self.protocol:",
            "            self.protocol.pre_request_hook = self._pre_request_hook",
            "",
            "    async def connect_socket(self, host: str, port: int):",
            "        \"\"\"Connect to server socket.\"\"\"",
            "        self.logger.info(\"opening connection\")",
            "        # Timeout the connection when the server isn't available",
            "        await asyncio.wait_for(asyncio.get_running_loop().create_connection(self._make_protocol, host, port), self._timeout)",
            "",
            "    def disconnect_socket(self):",
            "        if not self.protocol:",
            "            return",
            "        if self.protocol and self.protocol.state == UASocketProtocol.CLOSED:",
            "            self.logger.warning(\"disconnect_socket was called but connection is closed\")",
            "            return None",
            "        self.protocol.disconnect_socket()",
            "        self.protocol = None",
            "",
            "    async def send_hello(self, url, max_messagesize: int = 0, max_chunkcount: int = 0):",
            "        await self.protocol.send_hello(url, max_messagesize, max_chunkcount)",
            "",
            "    async def open_secure_channel(self, params):",
            "        return await self.protocol.open_secure_channel(params)",
            "",
            "    async def close_secure_channel(self):",
            "        \"\"\"",
            "        close secure channel. It seems to trigger a shutdown of socket",
            "        in most servers, so be prepare to reconnect",
            "        \"\"\"",
            "        if not self.protocol or self.protocol.state == UASocketProtocol.CLOSED:",
            "            self.logger.warning(\"close_secure_channel was called but connection is closed\")",
            "            return",
            "        return await self.protocol.close_secure_channel()",
            "",
            "    async def create_session(self, parameters):",
            "        self.logger.info(\"create_session\")",
            "        self.protocol.closed = False",
            "        request = ua.CreateSessionRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CreateSessionResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self.protocol.authentication_token = response.Parameters.AuthenticationToken",
            "        return response.Parameters",
            "",
            "    async def activate_session(self, parameters):",
            "        self.logger.info(\"activate_session\")",
            "        request = ua.ActivateSessionRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ActivateSessionResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters",
            "",
            "    async def close_session(self, delete_subscriptions):",
            "        self.logger.info(\"close_session\")",
            "        if not self.protocol:",
            "            self.logger.warning(\"close_session but connection wasn't established\")",
            "            return",
            "        self.protocol.closed = True",
            "        if self._publish_task and not self._publish_task.done():",
            "            self._publish_task.cancel()",
            "        if self.protocol and self.protocol.state == UASocketProtocol.CLOSED:",
            "            self.logger.warning(\"close_session was called but connection is closed\")",
            "            return",
            "        request = ua.CloseSessionRequest()",
            "        request.DeleteSubscriptions = delete_subscriptions",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CloseSessionResponse, data)",
            "        try:",
            "            response.ResponseHeader.ServiceResult.check()",
            "        except BadSessionClosed:",
            "            # Problem: closing the session with open publish requests leads to BadSessionClosed responses",
            "            #          we can just ignore it therefore.",
            "            #          Alternatively we could make sure that there are no publish requests in flight when",
            "            #          closing the session.",
            "            pass",
            "        except BadUserAccessDenied:",
            "            # Problem: older versions of asyncua didn't allow closing non-activated sessions. just ignore it.",
            "            pass",
            "",
            "    async def browse(self, parameters):",
            "        self.logger.info(\"browse\")",
            "        request = ua.BrowseRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.BrowseResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def browse_next(self, parameters):",
            "        self.logger.debug(\"browse next\")",
            "        request = ua.BrowseNextRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.BrowseNextResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results",
            "",
            "    async def read(self, parameters):",
            "        self.logger.debug(\"read\")",
            "        request = ua.ReadRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ReadResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def write(self, params):",
            "        self.logger.debug(\"write\")",
            "        request = ua.WriteRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.WriteResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def get_endpoints(self, params):",
            "        self.logger.debug(\"get_endpoint\")",
            "        request = ua.GetEndpointsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.GetEndpointsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Endpoints",
            "",
            "    async def find_servers(self, params):",
            "        self.logger.debug(\"find_servers\")",
            "        request = ua.FindServersRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.FindServersResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Servers",
            "",
            "    async def find_servers_on_network(self, params):",
            "        self.logger.debug(\"find_servers_on_network\")",
            "        request = ua.FindServersOnNetworkRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.FindServersOnNetworkResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters",
            "",
            "    async def register_server(self, registered_server):",
            "        self.logger.debug(\"register_server\")",
            "        request = ua.RegisterServerRequest()",
            "        request.Server = registered_server",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.RegisterServerResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        # nothing to return for this service",
            "",
            "    async def register_server2(self, params):",
            "        self.logger.debug(\"register_server2\")",
            "        request = ua.RegisterServer2Request()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.RegisterServer2Response, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.ConfigurationResults",
            "",
            "    async def translate_browsepaths_to_nodeids(self, browse_paths):",
            "        self.logger.debug(\"translate_browsepath_to_nodeid\")",
            "        request = ua.TranslateBrowsePathsToNodeIdsRequest()",
            "        request.Parameters.BrowsePaths = browse_paths",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.TranslateBrowsePathsToNodeIdsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def create_subscription(",
            "        self, params, callback",
            "    ) -> ua.CreateSubscriptionResult:",
            "        self.logger.debug(\"create_subscription\")",
            "        request = ua.CreateSubscriptionRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CreateSubscriptionResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self._subscription_callbacks[response.Parameters.SubscriptionId] = callback",
            "        self.logger.info(",
            "            \"create_subscription success SubscriptionId %s\",",
            "            response.Parameters.SubscriptionId",
            "        )",
            "        if not self._publish_task or self._publish_task.done() :",
            "            # Start the publish loop if it is not yet running",
            "            # The current strategy is to have only one open publish request per UaClient. This might not be enough",
            "            # in high latency networks or in case many subscriptions are created. A Set of Tasks of `_publish_loop`",
            "            # could be used if necessary.",
            "            self._publish_task = asyncio.create_task(self._publish_loop())",
            "        return response.Parameters",
            "",
            "    async def update_subscription(",
            "        self, params: ua.ModifySubscriptionParameters",
            "    ) -> ua.ModifySubscriptionResult:",
            "        request = ua.ModifySubscriptionRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ModifySubscriptionResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self.logger.info(",
            "            \"update_subscription success SubscriptionId %s\",",
            "            params.SubscriptionId",
            "        )",
            "        return response.Parameters",
            "",
            "    async def delete_subscriptions(self, subscription_ids):",
            "        self.logger.debug(\"delete_subscriptions %r\", subscription_ids)",
            "        request = ua.DeleteSubscriptionsRequest()",
            "        request.Parameters.SubscriptionIds = subscription_ids",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteSubscriptionsResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self.logger.info(\"remove subscription callbacks for %r\", subscription_ids)",
            "        for sid in subscription_ids:",
            "            self._subscription_callbacks.pop(sid)",
            "        return response.Results",
            "",
            "    async def publish(self, acks: List[ua.SubscriptionAcknowledgement]) -> ua.PublishResponse:",
            "        \"\"\"",
            "        Send a PublishRequest to the server.",
            "        \"\"\"",
            "        self.logger.debug('publish %r', acks)",
            "        request = ua.PublishRequest()",
            "        request.Parameters.SubscriptionAcknowledgements = acks if acks else []",
            "        data = await self.protocol.send_request(request, timeout=0)",
            "        self.protocol.check_answer(data, \"while waiting for publish response\")",
            "        try:",
            "            response = struct_from_binary(ua.PublishResponse, data)",
            "        except Exception as ex:",
            "            self.logger.exception(\"Error parsing notification from server\")",
            "            raise UaStructParsingError from ex",
            "        return response",
            "",
            "    async def _publish_loop(self):",
            "        \"\"\"",
            "        Start a loop that sends a publish requests and waits for the publish responses.",
            "        Forward the `PublishResult` to the matching `Subscription` by callback.",
            "        \"\"\"",
            "        ack = None",
            "        while True:",
            "            try:",
            "                response = await self.publish([ack] if ack else [])",
            "            except BadTimeout:  # See Spec. Part 4, 7.28",
            "                # Repeat without acknowledgement",
            "                ack = None",
            "                continue",
            "            except BadNoSubscription:  # See Spec. Part 5, 13.8.1",
            "                # BadNoSubscription is expected to be received after deleting the last subscription.",
            "                # We use this as a signal to exit this task and stop sending PublishRequests. This is easier then",
            "                # checking if there are no more subscriptions registered in this client (). A Publish response",
            "                # could still arrive before the DeleteSubscription response.",
            "                #",
            "                # We could remove the callback already when sending the DeleteSubscription request,",
            "                # but there are some legitimate reasons to keep them around, such as when the server",
            "                # responds with \"BadTimeout\" and we should try again later instead of just removing",
            "                # the subscription client-side.",
            "                #",
            "                # There are a variety of ways to act correctly, but the most practical solution seems",
            "                # to be to just silently ignore any BadNoSubscription responses.",
            "                self.logger.info(\"BadNoSubscription received, ignoring because it's probably valid.\")",
            "                # End task",
            "                return",
            "            except UaStructParsingError:",
            "                ack = None",
            "                continue",
            "            subscription_id = response.Parameters.SubscriptionId",
            "            if not subscription_id:",
            "                # The value 0 is used to indicate that there were no Subscriptions defined for which a",
            "                # response could be sent. See Spec. Part 4 - Section 5.13.5 \"Publish\"",
            "                # End task",
            "                return",
            "            try:",
            "                callback = self._subscription_callbacks[subscription_id]",
            "            except KeyError:",
            "                self.logger.warning(\"Received data for unknown subscription %s active are %s\", subscription_id, self._subscription_callbacks.keys())",
            "            else:",
            "                try:",
            "                    if asyncio.iscoroutinefunction(callback):",
            "                        await callback(response.Parameters)",
            "                    else:",
            "                        callback(response.Parameters)",
            "                except Exception:  # we call user code, catch everything!",
            "                    self.logger.exception(\"Exception while calling user callback: %s\")",
            "            # Repeat with acknowledgement",
            "            if response.Parameters.NotificationMessage.NotificationData:",
            "                ack = ua.SubscriptionAcknowledgement()",
            "                ack.SubscriptionId = subscription_id",
            "                ack.SequenceNumber = response.Parameters.NotificationMessage.SequenceNumber",
            "            else:",
            "                ack = None",
            "",
            "    async def create_monitored_items(self, params):",
            "        self.logger.info(\"create_monitored_items\")",
            "        request = ua.CreateMonitoredItemsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CreateMonitoredItemsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def delete_monitored_items(self, params):",
            "        self.logger.info(\"delete_monitored_items\")",
            "        request = ua.DeleteMonitoredItemsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteMonitoredItemsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def add_nodes(self, nodestoadd):",
            "        self.logger.info(\"add_nodes\")",
            "        request = ua.AddNodesRequest()",
            "        request.Parameters.NodesToAdd = nodestoadd",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.AddNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def add_references(self, refs):",
            "        self.logger.info(\"add_references\")",
            "        request = ua.AddReferencesRequest()",
            "        request.Parameters.ReferencesToAdd = refs",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.AddReferencesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def delete_references(self, refs):",
            "        self.logger.info(\"delete\")",
            "        request = ua.DeleteReferencesRequest()",
            "        request.Parameters.ReferencesToDelete = refs",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteReferencesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results",
            "",
            "    async def delete_nodes(self, params):",
            "        self.logger.info(\"delete_nodes\")",
            "        request = ua.DeleteNodesRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def call(self, methodstocall):",
            "        request = ua.CallRequest()",
            "        request.Parameters.MethodsToCall = methodstocall",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CallResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def history_read(self, params):",
            "        self.logger.info(\"history_read\")",
            "        request = ua.HistoryReadRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.HistoryReadResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def modify_monitored_items(self, params):",
            "        self.logger.info(\"modify_monitored_items\")",
            "        request = ua.ModifyMonitoredItemsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ModifyMonitoredItemsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def register_nodes(self, nodes):",
            "        self.logger.info(\"register_nodes\")",
            "        request = ua.RegisterNodesRequest()",
            "        request.Parameters.NodesToRegister = nodes",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.RegisterNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.RegisteredNodeIds",
            "",
            "    async def unregister_nodes(self, nodes):",
            "        self.logger.info(\"unregister_nodes\")",
            "        request = ua.UnregisterNodesRequest()",
            "        request.Parameters.NodesToUnregister = nodes",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.UnregisterNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        # nothing to return for this service",
            "",
            "    async def read_attributes(self, nodeids, attr):",
            "        self.logger.info(\"read_attributes of several nodes\")",
            "        request = ua.ReadRequest()",
            "        for nodeid in nodeids:",
            "            rv = ua.ReadValueId()",
            "            rv.NodeId = nodeid",
            "            rv.AttributeId = attr",
            "            request.Parameters.NodesToRead.append(rv)",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ReadResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def write_attributes(self, nodeids, datavalues, attributeid=ua.AttributeIds.Value):",
            "        \"\"\"",
            "        Set an attribute of multiple nodes",
            "        datavalue is a ua.DataValue object",
            "        \"\"\"",
            "        self.logger.info(\"write_attributes of several nodes\")",
            "        request = ua.WriteRequest()",
            "        for idx, nodeid in enumerate(nodeids):",
            "            attr = ua.WriteValue()",
            "            attr.NodeId = nodeid",
            "            attr.AttributeId = attributeid",
            "            attr.Value = datavalues[idx]",
            "            request.Parameters.NodesToWrite.append(attr)",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.WriteResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def set_monitoring_mode(self, params) -> ua.uatypes.StatusCode:",
            "        \"\"\"",
            "        Update the subscription monitoring mode",
            "        \"\"\"",
            "        self.logger.info(\"set_monitoring_mode\")",
            "        request = ua.SetMonitoringModeRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.SetMonitoringModeResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results",
            "",
            "    async def set_publishing_mode(self, params) -> ua.uatypes.StatusCode:",
            "        \"\"\"",
            "        Update the subscription publishing mode",
            "        \"\"\"",
            "        self.logger.info(\"set_publishing_mode\")",
            "        request = ua.SetPublishingModeRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.SetPublishingModeResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Low level binary client",
            "\"\"\"",
            "import asyncio",
            "import copy",
            "import logging",
            "from typing import Awaitable, Callable, Dict, List, Optional, Union",
            "",
            "from asyncua import ua",
            "from ..ua.ua_binary import struct_from_binary, uatcp_to_binary, struct_to_binary, nodeid_from_binary, header_from_binary",
            "from ..ua.uaerrors import BadTimeout, BadNoSubscription, BadSessionClosed, BadUserAccessDenied, UaStructParsingError",
            "from ..common.connection import SecureConnection, TransportLimits",
            "",
            "",
            "class UASocketProtocol(asyncio.Protocol):",
            "    \"\"\"",
            "    Handle socket connection and send ua messages.",
            "    Timeout is the timeout used while waiting for an ua answer from server.",
            "    \"\"\"",
            "    INITIALIZED = 'initialized'",
            "    OPEN = 'open'",
            "    CLOSED = 'closed'",
            "",
            "    def __init__(self, timeout: float = 1, security_policy: ua.SecurityPolicy = ua.SecurityPolicy(), limits: TransportLimits = None):",
            "        \"\"\"",
            "        :param timeout: Timeout in seconds",
            "        :param security_policy: Security policy (optional)",
            "        \"\"\"",
            "        self.logger = logging.getLogger(f\"{__name__}.UASocketProtocol\")",
            "        self.transport: Optional[asyncio.Transport] = None",
            "        self.receive_buffer: Optional[bytes] = None",
            "        self.is_receiving = False",
            "        self.timeout = timeout",
            "        self.authentication_token = ua.NodeId()",
            "        self._request_id = 0",
            "        self._request_handle = 0",
            "        self._callbackmap: Dict[int, asyncio.Future] = {}",
            "        if limits is None:",
            "            limits = TransportLimits(65535, 65535, 0, 0)",
            "        else:",
            "            limits = copy.deep_copy(limits)  # Make a copy because the limits can change in the session",
            "        self._connection = SecureConnection(security_policy, limits)",
            "",
            "        self.state = self.INITIALIZED",
            "        self.closed: bool = False",
            "        # needed to pass params from asynchronous request to synchronous data receive callback, as well as",
            "        # passing back the processed response to the request so that it can return it.",
            "        self._open_secure_channel_exchange: Union[ua.OpenSecureChannelResponse, ua.OpenSecureChannelParameters, None] = None",
            "        # Hook for upperlayer tasks before a request is send (optional)",
            "        self.pre_request_hook: Optional[Callable[[], Awaitable[None]]] = None",
            "",
            "    def connection_made(self, transport: asyncio.Transport):  # type: ignore",
            "        self.state = self.OPEN",
            "        self.transport = transport",
            "",
            "    def connection_lost(self, exc: Optional[Exception]):",
            "        self.logger.info(\"Socket has closed connection\")",
            "        self.state = self.CLOSED",
            "        self.transport = None",
            "",
            "    def data_received(self, data: bytes):",
            "        if self.receive_buffer:",
            "            data = self.receive_buffer + data",
            "            self.receive_buffer = None",
            "        self._process_received_data(data)",
            "",
            "    def _process_received_data(self, data: bytes):",
            "        \"\"\"",
            "        Try to parse received data as asyncua message. Data may be chunked but will be in correct order.",
            "        See: https://docs.python.org/3/library/asyncio-protocol.html#asyncio.Protocol.data_received",
            "        Reassembly is done by filling up a buffer until it verifies as a valid message (or a MessageChunk).",
            "        \"\"\"",
            "        buf = ua.utils.Buffer(data)",
            "        while True:",
            "            try:",
            "                try:",
            "                    header = header_from_binary(buf)",
            "                except ua.utils.NotEnoughData:",
            "                    self.logger.debug('Not enough data while parsing header from server, waiting for more')",
            "                    self.receive_buffer = data",
            "                    return",
            "                if len(buf) < header.body_size:",
            "                    self.logger.debug('We did not receive enough data from server. Need %s got %s', header.body_size, len(buf))",
            "                    self.receive_buffer = data",
            "                    return",
            "                msg = self._connection.receive_from_header_and_body(header, buf)",
            "                self._process_received_message(msg)",
            "                if header.MessageType == ua.MessageType.SecureOpen:",
            "                    params: ua.OpenSecureChannelParameters = self._open_secure_channel_exchange",
            "                    response: ua.OpenSecureChannelResponse = struct_from_binary(ua.OpenSecureChannelResponse, msg.body())",
            "                    response.ResponseHeader.ServiceResult.check()",
            "                    self._open_secure_channel_exchange = response",
            "                    self._connection.set_channel(response.Parameters, params.RequestType, params.ClientNonce)",
            "                if not buf:",
            "                    return",
            "                # Buffer still has bytes left, try to process again",
            "                data = bytes(buf)",
            "            except Exception:",
            "                self.logger.exception('Exception raised while parsing message from server')",
            "                self.disconnect_socket()",
            "                return",
            "",
            "    def _process_received_message(self, msg: Union[ua.Message, ua.Acknowledge, ua.ErrorMessage]):",
            "        if msg is None:",
            "            pass",
            "        elif isinstance(msg, ua.Message):",
            "            self._call_callback(msg.request_id(), msg.body())",
            "        elif isinstance(msg, ua.Acknowledge):",
            "            self._call_callback(0, msg)",
            "        elif isinstance(msg, ua.ErrorMessage):",
            "            self.logger.fatal(\"Received an error: %r\", msg)",
            "            self.disconnect_socket()",
            "        else:",
            "            raise ua.UaError(f\"Unsupported message type: {msg}\")",
            "",
            "    def _send_request(self, request, timeout: float = 1, message_type=ua.MessageType.SecureMessage) -> asyncio.Future:",
            "        \"\"\"",
            "        Send request to server, lower-level method.",
            "        Timeout is the timeout written in ua header.",
            "        :param request: Request",
            "        :param timeout: Timeout in seconds",
            "        :param message_type: UA Message Type (optional)",
            "        :return: Future that resolves with the Response",
            "        \"\"\"",
            "        self._setup_request_header(request.RequestHeader, timeout)",
            "        self.logger.debug('Sending: %s', request)",
            "        try:",
            "            binreq = struct_to_binary(request)",
            "        except Exception:",
            "            # reset request handle if any error",
            "            # see self._setup_request_header",
            "            self._request_handle -= 1",
            "            raise",
            "        self._request_id += 1",
            "        future = asyncio.get_running_loop().create_future()",
            "        self._callbackmap[self._request_id] = future",
            "",
            "        # Change to the new security token if the connection has been renewed.",
            "        if self._connection.next_security_token.TokenId != 0:",
            "            self._connection.revolve_tokens()",
            "",
            "        msg = self._connection.message_to_binary(binreq, message_type=message_type, request_id=self._request_id)",
            "        if self.transport is not None:",
            "            self.transport.write(msg)",
            "        return future",
            "",
            "    async def send_request(self, request, timeout: Optional[float] = None, message_type=ua.MessageType.SecureMessage):",
            "        \"\"\"",
            "        Send a request to the server.",
            "        Timeout is the timeout written in ua header.",
            "        Returns response object if no callback is provided.",
            "        \"\"\"",
            "        timeout = self.timeout if timeout is None else timeout",
            "        if self.pre_request_hook:",
            "            # This will propagade exceptions from background tasks to the libary user before calling a request which will",
            "            # timeout then.",
            "            await self.pre_request_hook()",
            "        try:",
            "            data = await asyncio.wait_for(self._send_request(request, timeout, message_type), timeout if timeout else None)",
            "        except Exception:",
            "            if self.state != self.OPEN:",
            "                raise ConnectionError(\"Connection is closed\") from None",
            "            raise",
            "        self.check_answer(data, f\" in response to {request.__class__.__name__}\")",
            "        return data",
            "",
            "    def check_answer(self, data, context):",
            "        data = data.copy()",
            "        typeid = nodeid_from_binary(data)",
            "        if typeid == ua.FourByteNodeId(ua.ObjectIds.ServiceFault_Encoding_DefaultBinary):",
            "            hdr = struct_from_binary(ua.ResponseHeader, data)",
            "            self.logger.warning(\"ServiceFault (%s, diagnostics: %s) from server received %s\", hdr.ServiceResult.name, hdr.ServiceDiagnostics, context)",
            "            hdr.ServiceResult.check()",
            "            return False",
            "        return True",
            "",
            "    def _call_callback(self, request_id, body):",
            "        try:",
            "            self._callbackmap[request_id].set_result(body)",
            "        except KeyError as ex:",
            "            raise ua.UaError(f\"No request found for request id: {request_id}, pending are {self._callbackmap.keys()}, body was {body}\") from ex",
            "        except asyncio.InvalidStateError:",
            "            if not self.closed:",
            "                self.logger.warning(\"Future for request id %s is already done\", request_id)",
            "                return",
            "            self.logger.debug(\"Future for request id %s not handled due to disconnect\", request_id)",
            "        del self._callbackmap[request_id]",
            "",
            "    def _setup_request_header(self, hdr: ua.RequestHeader, timeout=1) -> None:",
            "        \"\"\"",
            "        :param hdr: Request header",
            "        :param timeout: Timeout in seconds",
            "        \"\"\"",
            "        hdr.AuthenticationToken = self.authentication_token",
            "        self._request_handle += 1",
            "        hdr.RequestHandle = self._request_handle",
            "        hdr.TimeoutHint = int(timeout * 1000)",
            "",
            "    def disconnect_socket(self):",
            "        self.logger.info(\"Request to close socket received\")",
            "        if self.transport:",
            "            self.transport.close()",
            "        else:",
            "            self.logger.warning(\"disconnect_socket was called but transport is None\")",
            "",
            "    async def send_hello(self, url, max_messagesize: int = 0, max_chunkcount: int = 0):",
            "        hello = ua.Hello()",
            "        hello.EndpointUrl = url",
            "        hello.MaxMessageSize = max_messagesize",
            "        hello.MaxChunkCount = max_chunkcount",
            "        ack = asyncio.Future()",
            "        self._callbackmap[0] = ack",
            "        if self.transport is not None:",
            "            self.transport.write(uatcp_to_binary(ua.MessageType.Hello, hello))",
            "        return await asyncio.wait_for(ack, self.timeout)",
            "",
            "    async def open_secure_channel(self, params):",
            "        self.logger.info(\"open_secure_channel\")",
            "        request = ua.OpenSecureChannelRequest()",
            "        request.Parameters = params",
            "        if self._open_secure_channel_exchange is not None:",
            "            raise RuntimeError('Two Open Secure Channel requests can not happen too close to each other. ' 'The response must be processed and returned before the next request can be sent.')",
            "        self._open_secure_channel_exchange = params",
            "        await asyncio.wait_for(self._send_request(request, message_type=ua.MessageType.SecureOpen), self.timeout)",
            "        _return = self._open_secure_channel_exchange.Parameters",
            "        self._open_secure_channel_exchange = None",
            "        return _return",
            "",
            "    async def close_secure_channel(self):",
            "        \"\"\"",
            "        Close secure channel.",
            "        It seems to trigger a shutdown of socket in most servers, so be prepare to reconnect.",
            "        OPC UA specs Part 6, 7.1.4 say that Server does not send a CloseSecureChannel response",
            "        and should just close socket.",
            "        \"\"\"",
            "        self.logger.info(\"close_secure_channel\")",
            "        request = ua.CloseSecureChannelRequest()",
            "        future = self._send_request(request, message_type=ua.MessageType.SecureClose)",
            "        # don't expect any more answers",
            "        future.cancel()",
            "        self._callbackmap.clear()",
            "        # some servers send a response here, most do not ... so we ignore",
            "",
            "",
            "class UaClient:",
            "    \"\"\"",
            "    low level OPC-UA client.",
            "",
            "    It implements (almost) all methods defined in asyncua spec",
            "    taking in argument the structures defined in asyncua spec.",
            "",
            "    In this Python implementation  most of the structures are defined in",
            "    uaprotocol_auto.py and uaprotocol_hand.py available under asyncua.ua",
            "    \"\"\"",
            "    def __init__(self, timeout: float = 1.0):",
            "        \"\"\"",
            "        :param timeout: Timout in seconds",
            "        \"\"\"",
            "        self.logger = logging.getLogger(f'{__name__}.UaClient')",
            "        self._subscription_callbacks = {}",
            "        self._timeout = timeout",
            "        self.security_policy = ua.SecurityPolicy()",
            "        self.protocol: UASocketProtocol = None",
            "        self._publish_task = None",
            "        self._pre_request_hook: Optional[Callable[[], Awaitable[None]]] = None",
            "",
            "    def set_security(self, policy: ua.SecurityPolicy):",
            "        self.security_policy = policy",
            "",
            "    def _make_protocol(self):",
            "        self.protocol = UASocketProtocol(self._timeout, security_policy=self.security_policy)",
            "        self.protocol.pre_request_hook = self._pre_request_hook",
            "        return self.protocol",
            "",
            "    @property",
            "    def pre_request_hook(self) -> Callable[[], Awaitable[None]]:",
            "        return self._pre_request_hook",
            "",
            "    @pre_request_hook.setter",
            "    def pre_request_hook(self, hook: Optional[Callable[[], Awaitable[None]]]):",
            "        self._pre_request_hook = hook",
            "        if self.protocol:",
            "            self.protocol.pre_request_hook = self._pre_request_hook",
            "",
            "    async def connect_socket(self, host: str, port: int):",
            "        \"\"\"Connect to server socket.\"\"\"",
            "        self.logger.info(\"opening connection\")",
            "        # Timeout the connection when the server isn't available",
            "        await asyncio.wait_for(asyncio.get_running_loop().create_connection(self._make_protocol, host, port), self._timeout)",
            "",
            "    def disconnect_socket(self):",
            "        if not self.protocol:",
            "            return",
            "        if self.protocol and self.protocol.state == UASocketProtocol.CLOSED:",
            "            self.logger.warning(\"disconnect_socket was called but connection is closed\")",
            "            return None",
            "        self.protocol.disconnect_socket()",
            "        self.protocol = None",
            "",
            "    async def send_hello(self, url, max_messagesize: int = 0, max_chunkcount: int = 0):",
            "        await self.protocol.send_hello(url, max_messagesize, max_chunkcount)",
            "",
            "    async def open_secure_channel(self, params):",
            "        return await self.protocol.open_secure_channel(params)",
            "",
            "    async def close_secure_channel(self):",
            "        \"\"\"",
            "        close secure channel. It seems to trigger a shutdown of socket",
            "        in most servers, so be prepare to reconnect",
            "        \"\"\"",
            "        if not self.protocol or self.protocol.state == UASocketProtocol.CLOSED:",
            "            self.logger.warning(\"close_secure_channel was called but connection is closed\")",
            "            return",
            "        return await self.protocol.close_secure_channel()",
            "",
            "    async def create_session(self, parameters):",
            "        self.logger.info(\"create_session\")",
            "        self.protocol.closed = False",
            "        request = ua.CreateSessionRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CreateSessionResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self.protocol.authentication_token = response.Parameters.AuthenticationToken",
            "        return response.Parameters",
            "",
            "    async def activate_session(self, parameters):",
            "        self.logger.info(\"activate_session\")",
            "        request = ua.ActivateSessionRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ActivateSessionResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters",
            "",
            "    async def close_session(self, delete_subscriptions):",
            "        self.logger.info(\"close_session\")",
            "        if not self.protocol:",
            "            self.logger.warning(\"close_session but connection wasn't established\")",
            "            return",
            "        self.protocol.closed = True",
            "        if self._publish_task and not self._publish_task.done():",
            "            self._publish_task.cancel()",
            "        if self.protocol and self.protocol.state == UASocketProtocol.CLOSED:",
            "            self.logger.warning(\"close_session was called but connection is closed\")",
            "            return",
            "        request = ua.CloseSessionRequest()",
            "        request.DeleteSubscriptions = delete_subscriptions",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CloseSessionResponse, data)",
            "        try:",
            "            response.ResponseHeader.ServiceResult.check()",
            "        except BadSessionClosed:",
            "            # Problem: closing the session with open publish requests leads to BadSessionClosed responses",
            "            #          we can just ignore it therefore.",
            "            #          Alternatively we could make sure that there are no publish requests in flight when",
            "            #          closing the session.",
            "            pass",
            "        except BadUserAccessDenied:",
            "            # Problem: older versions of asyncua didn't allow closing non-activated sessions. just ignore it.",
            "            pass",
            "",
            "    async def browse(self, parameters):",
            "        self.logger.info(\"browse\")",
            "        request = ua.BrowseRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.BrowseResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def browse_next(self, parameters):",
            "        self.logger.debug(\"browse next\")",
            "        request = ua.BrowseNextRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.BrowseNextResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results",
            "",
            "    async def read(self, parameters):",
            "        self.logger.debug(\"read\")",
            "        request = ua.ReadRequest()",
            "        request.Parameters = parameters",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ReadResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def write(self, params):",
            "        self.logger.debug(\"write\")",
            "        request = ua.WriteRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.WriteResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def get_endpoints(self, params):",
            "        self.logger.debug(\"get_endpoint\")",
            "        request = ua.GetEndpointsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.GetEndpointsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Endpoints",
            "",
            "    async def find_servers(self, params):",
            "        self.logger.debug(\"find_servers\")",
            "        request = ua.FindServersRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.FindServersResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Servers",
            "",
            "    async def find_servers_on_network(self, params):",
            "        self.logger.debug(\"find_servers_on_network\")",
            "        request = ua.FindServersOnNetworkRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.FindServersOnNetworkResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters",
            "",
            "    async def register_server(self, registered_server):",
            "        self.logger.debug(\"register_server\")",
            "        request = ua.RegisterServerRequest()",
            "        request.Server = registered_server",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.RegisterServerResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        # nothing to return for this service",
            "",
            "    async def register_server2(self, params):",
            "        self.logger.debug(\"register_server2\")",
            "        request = ua.RegisterServer2Request()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.RegisterServer2Response, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.ConfigurationResults",
            "",
            "    async def translate_browsepaths_to_nodeids(self, browse_paths):",
            "        self.logger.debug(\"translate_browsepath_to_nodeid\")",
            "        request = ua.TranslateBrowsePathsToNodeIdsRequest()",
            "        request.Parameters.BrowsePaths = browse_paths",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.TranslateBrowsePathsToNodeIdsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def create_subscription(",
            "        self, params, callback",
            "    ) -> ua.CreateSubscriptionResult:",
            "        self.logger.debug(\"create_subscription\")",
            "        request = ua.CreateSubscriptionRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CreateSubscriptionResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self._subscription_callbacks[response.Parameters.SubscriptionId] = callback",
            "        self.logger.info(",
            "            \"create_subscription success SubscriptionId %s\",",
            "            response.Parameters.SubscriptionId",
            "        )",
            "        if not self._publish_task or self._publish_task.done() :",
            "            # Start the publish loop if it is not yet running",
            "            # The current strategy is to have only one open publish request per UaClient. This might not be enough",
            "            # in high latency networks or in case many subscriptions are created. A Set of Tasks of `_publish_loop`",
            "            # could be used if necessary.",
            "            self._publish_task = asyncio.create_task(self._publish_loop())",
            "        return response.Parameters",
            "",
            "    async def update_subscription(",
            "        self, params: ua.ModifySubscriptionParameters",
            "    ) -> ua.ModifySubscriptionResult:",
            "        request = ua.ModifySubscriptionRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ModifySubscriptionResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self.logger.info(",
            "            \"update_subscription success SubscriptionId %s\",",
            "            params.SubscriptionId",
            "        )",
            "        return response.Parameters",
            "",
            "    async def delete_subscriptions(self, subscription_ids):",
            "        self.logger.debug(\"delete_subscriptions %r\", subscription_ids)",
            "        request = ua.DeleteSubscriptionsRequest()",
            "        request.Parameters.SubscriptionIds = subscription_ids",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteSubscriptionsResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        self.logger.info(\"remove subscription callbacks for %r\", subscription_ids)",
            "        for sid in subscription_ids:",
            "            self._subscription_callbacks.pop(sid)",
            "        return response.Results",
            "",
            "    async def publish(self, acks: List[ua.SubscriptionAcknowledgement]) -> ua.PublishResponse:",
            "        \"\"\"",
            "        Send a PublishRequest to the server.",
            "        \"\"\"",
            "        self.logger.debug('publish %r', acks)",
            "        request = ua.PublishRequest()",
            "        request.Parameters.SubscriptionAcknowledgements = acks if acks else []",
            "        data = await self.protocol.send_request(request, timeout=0)",
            "        self.protocol.check_answer(data, \"while waiting for publish response\")",
            "        try:",
            "            response = struct_from_binary(ua.PublishResponse, data)",
            "        except Exception as ex:",
            "            self.logger.exception(\"Error parsing notification from server\")",
            "            raise UaStructParsingError from ex",
            "        return response",
            "",
            "    async def _publish_loop(self):",
            "        \"\"\"",
            "        Start a loop that sends a publish requests and waits for the publish responses.",
            "        Forward the `PublishResult` to the matching `Subscription` by callback.",
            "        \"\"\"",
            "        ack = None",
            "        while True:",
            "            try:",
            "                response = await self.publish([ack] if ack else [])",
            "            except BadTimeout:  # See Spec. Part 4, 7.28",
            "                # Repeat without acknowledgement",
            "                ack = None",
            "                continue",
            "            except BadNoSubscription:  # See Spec. Part 5, 13.8.1",
            "                # BadNoSubscription is expected to be received after deleting the last subscription.",
            "                # We use this as a signal to exit this task and stop sending PublishRequests. This is easier then",
            "                # checking if there are no more subscriptions registered in this client (). A Publish response",
            "                # could still arrive before the DeleteSubscription response.",
            "                #",
            "                # We could remove the callback already when sending the DeleteSubscription request,",
            "                # but there are some legitimate reasons to keep them around, such as when the server",
            "                # responds with \"BadTimeout\" and we should try again later instead of just removing",
            "                # the subscription client-side.",
            "                #",
            "                # There are a variety of ways to act correctly, but the most practical solution seems",
            "                # to be to just silently ignore any BadNoSubscription responses.",
            "                self.logger.info(\"BadNoSubscription received, ignoring because it's probably valid.\")",
            "                # End task",
            "                return",
            "            except UaStructParsingError:",
            "                ack = None",
            "                continue",
            "            subscription_id = response.Parameters.SubscriptionId",
            "            if not subscription_id:",
            "                # The value 0 is used to indicate that there were no Subscriptions defined for which a",
            "                # response could be sent. See Spec. Part 4 - Section 5.13.5 \"Publish\"",
            "                # End task",
            "                return",
            "            try:",
            "                callback = self._subscription_callbacks[subscription_id]",
            "            except KeyError:",
            "                self.logger.warning(\"Received data for unknown subscription %s active are %s\", subscription_id, self._subscription_callbacks.keys())",
            "            else:",
            "                try:",
            "                    if asyncio.iscoroutinefunction(callback):",
            "                        await callback(response.Parameters)",
            "                    else:",
            "                        callback(response.Parameters)",
            "                except Exception:  # we call user code, catch everything!",
            "                    self.logger.exception(\"Exception while calling user callback: %s\")",
            "            # Repeat with acknowledgement",
            "            if response.Parameters.NotificationMessage.NotificationData:",
            "                ack = ua.SubscriptionAcknowledgement()",
            "                ack.SubscriptionId = subscription_id",
            "                ack.SequenceNumber = response.Parameters.NotificationMessage.SequenceNumber",
            "            else:",
            "                ack = None",
            "",
            "    async def create_monitored_items(self, params):",
            "        self.logger.info(\"create_monitored_items\")",
            "        request = ua.CreateMonitoredItemsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CreateMonitoredItemsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def delete_monitored_items(self, params):",
            "        self.logger.info(\"delete_monitored_items\")",
            "        request = ua.DeleteMonitoredItemsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteMonitoredItemsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def add_nodes(self, nodestoadd):",
            "        self.logger.info(\"add_nodes\")",
            "        request = ua.AddNodesRequest()",
            "        request.Parameters.NodesToAdd = nodestoadd",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.AddNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def add_references(self, refs):",
            "        self.logger.info(\"add_references\")",
            "        request = ua.AddReferencesRequest()",
            "        request.Parameters.ReferencesToAdd = refs",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.AddReferencesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def delete_references(self, refs):",
            "        self.logger.info(\"delete\")",
            "        request = ua.DeleteReferencesRequest()",
            "        request.Parameters.ReferencesToDelete = refs",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteReferencesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results",
            "",
            "    async def delete_nodes(self, params):",
            "        self.logger.info(\"delete_nodes\")",
            "        request = ua.DeleteNodesRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.DeleteNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def call(self, methodstocall):",
            "        request = ua.CallRequest()",
            "        request.Parameters.MethodsToCall = methodstocall",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.CallResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def history_read(self, params):",
            "        self.logger.info(\"history_read\")",
            "        request = ua.HistoryReadRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.HistoryReadResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def modify_monitored_items(self, params):",
            "        self.logger.info(\"modify_monitored_items\")",
            "        request = ua.ModifyMonitoredItemsRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ModifyMonitoredItemsResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def register_nodes(self, nodes):",
            "        self.logger.info(\"register_nodes\")",
            "        request = ua.RegisterNodesRequest()",
            "        request.Parameters.NodesToRegister = nodes",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.RegisterNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.RegisteredNodeIds",
            "",
            "    async def unregister_nodes(self, nodes):",
            "        self.logger.info(\"unregister_nodes\")",
            "        request = ua.UnregisterNodesRequest()",
            "        request.Parameters.NodesToUnregister = nodes",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.UnregisterNodesResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        # nothing to return for this service",
            "",
            "    async def read_attributes(self, nodeids, attr):",
            "        self.logger.info(\"read_attributes of several nodes\")",
            "        request = ua.ReadRequest()",
            "        for nodeid in nodeids:",
            "            rv = ua.ReadValueId()",
            "            rv.NodeId = nodeid",
            "            rv.AttributeId = attr",
            "            request.Parameters.NodesToRead.append(rv)",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.ReadResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def write_attributes(self, nodeids, datavalues, attributeid=ua.AttributeIds.Value):",
            "        \"\"\"",
            "        Set an attribute of multiple nodes",
            "        datavalue is a ua.DataValue object",
            "        \"\"\"",
            "        self.logger.info(\"write_attributes of several nodes\")",
            "        request = ua.WriteRequest()",
            "        for idx, nodeid in enumerate(nodeids):",
            "            attr = ua.WriteValue()",
            "            attr.NodeId = nodeid",
            "            attr.AttributeId = attributeid",
            "            attr.Value = datavalues[idx]",
            "            request.Parameters.NodesToWrite.append(attr)",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.WriteResponse, data)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Results",
            "",
            "    async def set_monitoring_mode(self, params) -> ua.uatypes.StatusCode:",
            "        \"\"\"",
            "        Update the subscription monitoring mode",
            "        \"\"\"",
            "        self.logger.info(\"set_monitoring_mode\")",
            "        request = ua.SetMonitoringModeRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.SetMonitoringModeResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results",
            "",
            "    async def set_publishing_mode(self, params) -> ua.uatypes.StatusCode:",
            "        \"\"\"",
            "        Update the subscription publishing mode",
            "        \"\"\"",
            "        self.logger.info(\"set_publishing_mode\")",
            "        request = ua.SetPublishingModeRequest()",
            "        request.Parameters = params",
            "        data = await self.protocol.send_request(request)",
            "        response = struct_from_binary(ua.SetPublishingModeResponse, data)",
            "        self.logger.debug(response)",
            "        response.ResponseHeader.ServiceResult.check()",
            "        return response.Parameters.Results"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "23": [
                "UASocketProtocol",
                "__init__"
            ],
            "37": [
                "UASocketProtocol",
                "__init__"
            ],
            "106": [
                "UASocketProtocol",
                "_process_received_message"
            ]
        },
        "addLocation": []
    },
    "asyncua/common/connection.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from dataclasses import dataclass"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import hashlib"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from datetime import datetime, timedelta"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import logging"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " logger = logging.getLogger('asyncua.uaprotocol')"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+@dataclass"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+class TransportLimits:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    '''"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+        Limits of the tcp transport layer to prevent excessive resource usage"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    '''"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    max_recv_buffer: int = 65535"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    max_send_buffer: int = 65535"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    max_chunk_count: int = ((100 * 1024 * 1024) // 65535) + 1 #  max_message_size / max_recv_buffer "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    max_message_size: int = 100 * 1024 * 1024  # 100mb"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    @staticmethod"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    def _select_limit(hint: ua.UInt32, limit: int) -> ua.UInt32:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        if limit <= 0:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+            return hint"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        elif limit < hint:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+            return hint"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+        return ua.UInt32(limit)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    def check_max_msg_size(self, sz: int) -> bool:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        if self.max_message_size == 0:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+            return True"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        return self.max_message_size <= sz"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+    def check_max_chunk_count(self, sz: int) -> bool:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        if self.max_chunk_count == 0:"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+            return True"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        return self.max_chunk_count <= sz"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    def create_acknowledge_limits(self, msg: ua.Hello) -> ua.Acknowledge:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+        ack = ua.Acknowledge()"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        ack.ReceiveBufferSize = min(msg.ReceiveBufferSize, self.max_recv_buffer)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        ack.SendBufferSize = min(msg.SendBufferSize, self.max_send_buffer)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        ack.MaxChunkCount = self._select_limit(msg.MaxChunkCount, self.max_chunk_count)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        ack.MaxMessageSize = self._select_limit(msg.MaxMessageSize, self.max_message_size)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        self.update_limits(ack)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        return ack"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    def create_hello_limits(self, msg: ua.Hello) -> ua.Hello:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        msg.ReceiveBufferSize = self.max_recv_buffer"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        msg.SendBufferSize = self.max_send_buffer"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+        msg.MaxChunkCount = self.max_chunk_count"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        msg.MaxMessageSize = self.max_chunk_count"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    def update_limits(self, msg: ua.Acknowledge) -> None:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        self.max_chunk_count = msg.MaxChunkCount"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        self.max_recv_buffer = msg.ReceiveBufferSize"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        self.max_send_buffer = msg.SendBufferSize"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        self.max_message_size = msg.MaxMessageSize"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "57": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " class MessageChunk:"
            },
            "58": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     \"\"\""
            },
            "59": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     Message Chunk, as described in OPC UA specs Part 6, 6.7.2."
            },
            "60": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     \"\"\""
            },
            "61": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "     Common logic for client and server"
            },
            "62": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "     \"\"\""
            },
            "63": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, security_policy):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+    def __init__(self, security_policy, limits: TransportLimits):"
            },
            "65": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         self._sequence_number = 0"
            },
            "66": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "         self._peer_sequence_number = None"
            },
            "67": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         self._incoming_parts = []"
            },
            "68": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         self.local_nonce = 0"
            },
            "69": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         self.remote_nonce = 0"
            },
            "70": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         self._allow_prev_token = False"
            },
            "71": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._max_chunk_size = 65536"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+        self._limits = limits"
            },
            "73": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "     def set_channel(self, params, request_type, client_nonce):"
            },
            "75": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         \"\"\""
            },
            "76": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "         chunks = MessageChunk.message_to_chunks("
            },
            "77": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "             self.security_policy,"
            },
            "78": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "             message,"
            },
            "79": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._max_chunk_size,"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+            self._limits.max_send_buffer,"
            },
            "81": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "             message_type=message_type,"
            },
            "82": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "             channel_id=self.security_token.ChannelId,"
            },
            "83": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "             request_id=request_id,"
            },
            "84": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "             return self._receive(chunk)"
            },
            "85": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 405,
                "PatchRowcode": "         if header.MessageType == ua.MessageType.Hello:"
            },
            "86": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 406,
                "PatchRowcode": "             msg = struct_from_binary(ua.Hello, body)"
            },
            "87": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._max_chunk_size = msg.ReceiveBufferSize"
            },
            "88": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "             return msg"
            },
            "89": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         if header.MessageType == ua.MessageType.Acknowledge:"
            },
            "90": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             msg = struct_from_binary(ua.Acknowledge, body)"
            },
            "91": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._max_chunk_size = msg.SendBufferSize"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+            self._limits.update_limits(msg)"
            },
            "93": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 411,
                "PatchRowcode": "             return msg"
            },
            "94": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 412,
                "PatchRowcode": "         if header.MessageType == ua.MessageType.Error:"
            },
            "95": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 413,
                "PatchRowcode": "             msg = struct_from_binary(ua.ErrorMessage, body)"
            },
            "96": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "         raise ua.UaError(f\"Unsupported message type {header.MessageType}\")"
            },
            "97": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 417,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 418,
                "PatchRowcode": "     def _receive(self, msg):"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+        if msg.MessageHeader.packet_size > self._limits.max_recv_buffer:"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+            self._incoming_parts = []"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+            raise ua.UaStatusCodeError(ua.StatusCodes.BadRequestTooLarge)"
            },
            "102": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 422,
                "PatchRowcode": "         self._check_incoming_chunk(msg)"
            },
            "103": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "         self._incoming_parts.append(msg)"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+        if not self._limits.check_max_chunk_count(len(self._incoming_parts)):"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+            self._incoming_parts = []"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+            raise ua.UaStatusCodeError(ua.StatusCodes.BadRequestTooLarge)"
            },
            "107": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 427,
                "PatchRowcode": "         if msg.MessageHeader.ChunkType == ua.ChunkType.Intermediate:"
            },
            "108": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 428,
                "PatchRowcode": "             return None"
            },
            "109": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 429,
                "PatchRowcode": "         if msg.MessageHeader.ChunkType == ua.ChunkType.Abort:"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "from datetime import datetime, timedelta",
            "import logging",
            "import copy",
            "",
            "from asyncua import ua",
            "from ..ua.ua_binary import struct_from_binary, struct_to_binary, header_from_binary, header_to_binary",
            "",
            "try:",
            "    from ..crypto.uacrypto import InvalidSignature",
            "except ImportError:",
            "    class InvalidSignature(Exception):  # type: ignore",
            "        pass",
            "",
            "logger = logging.getLogger('asyncua.uaprotocol')",
            "",
            "",
            "class MessageChunk:",
            "    \"\"\"",
            "    Message Chunk, as described in OPC UA specs Part 6, 6.7.2.",
            "    \"\"\"",
            "    def __init__(self, security_policy, body=b'', msg_type=ua.MessageType.SecureMessage, chunk_type=ua.ChunkType.Single):",
            "        self.MessageHeader = ua.Header(msg_type, chunk_type)",
            "        if msg_type in (ua.MessageType.SecureMessage, ua.MessageType.SecureClose):",
            "            self.SecurityHeader = ua.SymmetricAlgorithmHeader()",
            "        elif msg_type == ua.MessageType.SecureOpen:",
            "            self.SecurityHeader = ua.AsymmetricAlgorithmHeader()",
            "        else:",
            "            raise ua.UaError(f\"Unsupported message type: {msg_type}\")",
            "        self.SequenceHeader = ua.SequenceHeader()",
            "        self.Body = body",
            "        self.security_policy = security_policy",
            "",
            "    @staticmethod",
            "    def from_binary(security_policy, data):",
            "        h = header_from_binary(data)",
            "        try:",
            "            return MessageChunk.from_header_and_body(security_policy, h, data)",
            "        except InvalidSignature:",
            "            return MessageChunk.from_header_and_body(security_policy, h, data, use_prev_key=True)",
            "",
            "    @staticmethod",
            "    def from_header_and_body(security_policy, header, buf, use_prev_key=False):",
            "        if not len(buf) >= header.body_size:",
            "            raise ValueError('Full body expected here')",
            "        data = buf.copy(header.body_size)",
            "        buf.skip(header.body_size)",
            "        if header.MessageType in (ua.MessageType.SecureMessage, ua.MessageType.SecureClose):",
            "            security_header = struct_from_binary(ua.SymmetricAlgorithmHeader, data)",
            "            crypto = security_policy.symmetric_cryptography",
            "        elif header.MessageType == ua.MessageType.SecureOpen:",
            "            security_header = struct_from_binary(ua.AsymmetricAlgorithmHeader, data)",
            "            crypto = security_policy.asymmetric_cryptography",
            "        else:",
            "            raise ua.UaError(f\"Unsupported message type: {header.MessageType}\")",
            "        crypto.use_prev_key = use_prev_key",
            "        obj = MessageChunk(crypto)",
            "        obj.MessageHeader = header",
            "        obj.SecurityHeader = security_header",
            "        decrypted = crypto.decrypt(data.read(len(data)))",
            "        signature_size = crypto.vsignature_size()",
            "        if signature_size > 0:",
            "            signature = decrypted[-signature_size:]",
            "            decrypted = decrypted[:-signature_size]",
            "            crypto.verify(header_to_binary(obj.MessageHeader) + struct_to_binary(obj.SecurityHeader) + decrypted, signature)",
            "        data = ua.utils.Buffer(crypto.remove_padding(decrypted))",
            "        obj.SequenceHeader = struct_from_binary(ua.SequenceHeader, data)",
            "        obj.Body = data.read(len(data))",
            "        return obj",
            "",
            "    def encrypted_size(self, plain_size):",
            "        size = plain_size + self.security_policy.signature_size()",
            "        pbs = self.security_policy.plain_block_size()",
            "        if size % pbs != 0:",
            "            raise ua.UaError(\"Encryption error\")",
            "        return size // pbs * self.security_policy.encrypted_block_size()",
            "",
            "    def to_binary(self):",
            "        security = struct_to_binary(self.SecurityHeader)",
            "        encrypted_part = struct_to_binary(self.SequenceHeader) + self.Body",
            "        encrypted_part += self.security_policy.padding(len(encrypted_part))",
            "        self.MessageHeader.body_size = len(security) + self.encrypted_size(len(encrypted_part))",
            "        header = header_to_binary(self.MessageHeader)",
            "        encrypted_part += self.security_policy.signature(header + security + encrypted_part)",
            "        return header + security + self.security_policy.encrypt(encrypted_part)",
            "",
            "    @staticmethod",
            "    def max_body_size(crypto, max_chunk_size):",
            "        max_encrypted_size = max_chunk_size - ua.Header.max_size() - ua.SymmetricAlgorithmHeader.max_size()",
            "        max_plain_size = (max_encrypted_size // crypto.encrypted_block_size()) * crypto.plain_block_size()",
            "        return max_plain_size - ua.SequenceHeader.max_size() - crypto.signature_size() - crypto.min_padding_size()",
            "",
            "    @staticmethod",
            "    def message_to_chunks(security_policy, body, max_chunk_size, message_type=ua.MessageType.SecureMessage, channel_id=1, request_id=1, token_id=1):",
            "        \"\"\"",
            "        Pack message body (as binary string) into one or more chunks.",
            "        Size of each chunk will not exceed max_chunk_size.",
            "        Returns a list of MessageChunks. SequenceNumber is not initialized here,",
            "        it must be set by Secure Channel driver.",
            "        \"\"\"",
            "        if message_type == ua.MessageType.SecureOpen:",
            "            # SecureOpen message must be in a single chunk (specs, Part 6, 6.7.2)",
            "            chunk = MessageChunk(security_policy.asymmetric_cryptography, body, message_type, ua.ChunkType.Single)",
            "            chunk.SecurityHeader.SecurityPolicyURI = security_policy.URI",
            "            if security_policy.host_certificate:",
            "                chunk.SecurityHeader.SenderCertificate = security_policy.host_certificate",
            "            if security_policy.peer_certificate:",
            "                chunk.SecurityHeader.ReceiverCertificateThumbPrint =\\",
            "                    hashlib.sha1(security_policy.peer_certificate).digest()",
            "            chunk.MessageHeader.ChannelId = channel_id",
            "            chunk.SequenceHeader.RequestId = request_id",
            "            return [chunk]",
            "",
            "        crypto = security_policy.symmetric_cryptography",
            "        max_size = MessageChunk.max_body_size(crypto, max_chunk_size)",
            "",
            "        chunks = []",
            "        for i in range(0, len(body), max_size):",
            "            part = body[i:i + max_size]",
            "            if i + max_size >= len(body):",
            "                chunk_type = ua.ChunkType.Single",
            "            else:",
            "                chunk_type = ua.ChunkType.Intermediate",
            "            chunk = MessageChunk(crypto, part, message_type, chunk_type)",
            "            chunk.SecurityHeader.TokenId = token_id",
            "            chunk.MessageHeader.ChannelId = channel_id",
            "            chunk.SequenceHeader.RequestId = request_id",
            "            chunks.append(chunk)",
            "        return chunks",
            "",
            "    def __str__(self):",
            "        return f\"{self.__class__.__name__}({self.MessageHeader}, {self.SequenceHeader},\" \\",
            "               f\" {self.SecurityHeader}, {len(self.Body)} bytes)\"",
            "",
            "    __repr__ = __str__",
            "",
            "",
            "class SecureConnection:",
            "    \"\"\"",
            "    Common logic for client and server",
            "    \"\"\"",
            "    def __init__(self, security_policy):",
            "        self._sequence_number = 0",
            "        self._peer_sequence_number = None",
            "        self._incoming_parts = []",
            "        self.security_policy = security_policy",
            "        self._policies = []",
            "        self._open = False",
            "        self.security_token = ua.ChannelSecurityToken()",
            "        self.next_security_token = ua.ChannelSecurityToken()",
            "        self.prev_security_token = ua.ChannelSecurityToken()",
            "        self.local_nonce = 0",
            "        self.remote_nonce = 0",
            "        self._allow_prev_token = False",
            "        self._max_chunk_size = 65536",
            "",
            "    def set_channel(self, params, request_type, client_nonce):",
            "        \"\"\"",
            "        Called on client side when getting secure channel data from server.",
            "        \"\"\"",
            "        if request_type == ua.SecurityTokenRequestType.Issue:",
            "            self.security_token = params.SecurityToken",
            "            self.local_nonce = client_nonce",
            "            self.remote_nonce = params.ServerNonce",
            "            self.security_policy.make_local_symmetric_key(self.remote_nonce, self.local_nonce)",
            "            self.security_policy.make_remote_symmetric_key(",
            "                self.local_nonce,",
            "                self.remote_nonce,",
            "                self.security_token.RevisedLifetime",
            "            )",
            "            self._open = True",
            "        else:",
            "            self.next_security_token = params.SecurityToken",
            "            self.local_nonce = client_nonce",
            "            self.remote_nonce = params.ServerNonce",
            "",
            "        self._allow_prev_token = True",
            "",
            "    def open(self, params, server):",
            "        \"\"\"",
            "        Called on server side to open secure channel.",
            "        \"\"\"",
            "",
            "        self.local_nonce = ua.utils.create_nonce(self.security_policy.secure_channel_nonce_length)",
            "        self.remote_nonce = params.ClientNonce",
            "        response = ua.OpenSecureChannelResult()",
            "        response.ServerNonce = self.local_nonce",
            "",
            "        if not self._open or params.RequestType == ua.SecurityTokenRequestType.Issue:",
            "            self._open = True",
            "            self.security_token.TokenId = 13  # random value",
            "            self.security_token.ChannelId = server.get_new_channel_id()",
            "            self.security_token.RevisedLifetime = params.RequestedLifetime",
            "            self.security_token.CreatedAt = datetime.utcnow()",
            "",
            "            response.SecurityToken = self.security_token",
            "",
            "            self.security_policy.make_local_symmetric_key(self.remote_nonce, self.local_nonce)",
            "            self.security_policy.make_remote_symmetric_key(",
            "                self.local_nonce,",
            "                self.remote_nonce,",
            "                self.security_token.RevisedLifetime",
            "            )",
            "        else:",
            "            self.next_security_token = copy.deepcopy(self.security_token)",
            "            self.next_security_token.TokenId += 1",
            "            self.next_security_token.RevisedLifetime = params.RequestedLifetime",
            "            self.next_security_token.CreatedAt = datetime.utcnow()",
            "",
            "            response.SecurityToken = self.next_security_token",
            "",
            "        return response",
            "",
            "    def close(self):",
            "        self._open = False",
            "",
            "    def is_open(self):",
            "        return self._open",
            "",
            "    def set_policy_factories(self, policies):",
            "        \"\"\"",
            "        Set a list of available security policies.",
            "        Use this in servers with multiple endpoints with different security.",
            "        \"\"\"",
            "        self._policies = policies",
            "",
            "    @staticmethod",
            "    def _policy_matches(policy, uri, mode=None):",
            "        return policy.URI == uri and (mode is None or policy.Mode == mode)",
            "",
            "    def select_policy(self, uri, peer_certificate, mode=None):",
            "        for policy in self._policies:",
            "            if policy.matches(uri, mode):",
            "                self.security_policy = policy.create(peer_certificate)",
            "                return",
            "        if self.security_policy.URI != uri or (mode is not None and self.security_policy.Mode != mode):",
            "            raise ua.UaError(f\"No matching policy: {uri}, {mode}\")",
            "",
            "    def revolve_tokens(self):",
            "        \"\"\"",
            "        Revolve security tokens of the security channel. Start using the",
            "        next security token negotiated during the renewal of the channel and",
            "        remember the previous token until the other communication party",
            "        \"\"\"",
            "        self.prev_security_token = self.security_token",
            "        self.security_token = self.next_security_token",
            "        self.next_security_token = ua.ChannelSecurityToken()",
            "        self.security_policy.make_local_symmetric_key(self.remote_nonce, self.local_nonce)",
            "        self.security_policy.make_remote_symmetric_key(self.local_nonce, self.remote_nonce, self.security_token.RevisedLifetime)",
            "",
            "    def message_to_binary(self, message, message_type=ua.MessageType.SecureMessage, request_id=0):",
            "        \"\"\"",
            "        Convert OPC UA secure message to binary.",
            "        The only supported types are SecureOpen, SecureMessage, SecureClose.",
            "        If message_type is SecureMessage, the AlgorithmHeader should be passed as arg.",
            "        \"\"\"",
            "        chunks = MessageChunk.message_to_chunks(",
            "            self.security_policy,",
            "            message,",
            "            self._max_chunk_size,",
            "            message_type=message_type,",
            "            channel_id=self.security_token.ChannelId,",
            "            request_id=request_id,",
            "            token_id=self.security_token.TokenId,",
            "        )",
            "        for chunk in chunks:",
            "            self._sequence_number += 1",
            "            if self._sequence_number >= (1 << 32):",
            "                logger.debug(\"Wrapping sequence number: %d -> 1\", self._sequence_number)",
            "                self._sequence_number = 1",
            "            chunk.SequenceHeader.SequenceNumber = self._sequence_number",
            "        return b\"\".join([chunk.to_binary() for chunk in chunks])",
            "",
            "    def _check_sym_header(self, security_hdr):",
            "        \"\"\"",
            "        Validates the symmetric header of the message chunk and revolves the",
            "        security token if needed.",
            "        \"\"\"",
            "        assert isinstance(security_hdr, ua.SymmetricAlgorithmHeader), f\"Expected SymAlgHeader, got: {security_hdr}\"",
            "",
            "        if security_hdr.TokenId == self.security_token.TokenId:",
            "            return",
            "",
            "        if security_hdr.TokenId == self.next_security_token.TokenId:",
            "            self.revolve_tokens()",
            "            return",
            "",
            "        if self._allow_prev_token and security_hdr.TokenId == self.prev_security_token.TokenId:",
            "            # From spec, part 4, section 5.5.2.1: Clients should accept Messages secured by an",
            "            # expired SecurityToken for up to 25 % of the token lifetime. This should ensure that",
            "            # Messages sent by the Server before the token expired are not rejected because of",
            "            # network delays.",
            "            timeout = self.prev_security_token.CreatedAt + \\",
            "                timedelta(milliseconds=self.prev_security_token.RevisedLifetime * 1.25)",
            "            if timeout < datetime.utcnow():",
            "                raise ua.UaError(f\"Security token id {security_hdr.TokenId} has timed out \" f\"({timeout} < {datetime.utcnow()})\")",
            "            return",
            "",
            "        expected_tokens = [self.security_token.TokenId, self.next_security_token.TokenId]",
            "        if self._allow_prev_token:",
            "            expected_tokens.insert(0, self.prev_security_token.TokenId)",
            "        raise ua.UaError(f\"Invalid security token id {security_hdr.TokenId}, expected one of: {expected_tokens}\")",
            "",
            "    def _check_incoming_chunk(self, chunk):",
            "        if not isinstance(chunk, MessageChunk):",
            "            raise ValueError(f'Expected chunk, got: {chunk}')",
            "        if chunk.MessageHeader.MessageType != ua.MessageType.SecureOpen:",
            "            if chunk.MessageHeader.ChannelId != self.security_token.ChannelId:",
            "                raise ua.UaError(f'Wrong channel id {chunk.MessageHeader.ChannelId},' f' expected {self.security_token.ChannelId}')",
            "        if self._incoming_parts:",
            "            if self._incoming_parts[0].SequenceHeader.RequestId != chunk.SequenceHeader.RequestId:",
            "                raise ua.UaError(f'Wrong request id {chunk.SequenceHeader.RequestId},' f' expected {self._incoming_parts[0].SequenceHeader.RequestId}')",
            "        # The sequence number must monotonically increase (but it can wrap around)",
            "        seq_num = chunk.SequenceHeader.SequenceNumber",
            "        if self._peer_sequence_number is not None:",
            "            if seq_num != self._peer_sequence_number + 1:",
            "                wrap_limit = (1 << 32) - 1024",
            "                if seq_num < 1024 and self._peer_sequence_number >= wrap_limit:",
            "                    # The sequence number has wrapped around. See spec. part 6, 6.7.2",
            "                    logger.debug('Sequence number wrapped: %d -> %d', self._peer_sequence_number, seq_num)",
            "                else:",
            "                    # Condition for monotonically increase is not met",
            "                    raise ua.UaError(f\"Received chunk: {chunk} with wrong sequence expecting:\" f\" {self._peer_sequence_number}, received: {seq_num},\" f\" spec says to close connection\")",
            "        self._peer_sequence_number = seq_num",
            "",
            "    def receive_from_header_and_body(self, header, body):",
            "        \"\"\"",
            "        Convert MessageHeader and binary body to OPC UA TCP message (see OPC UA",
            "        specs Part 6, 7.1: Hello, Acknowledge or ErrorMessage), or a Message",
            "        object, or None (if intermediate chunk is received)",
            "        \"\"\"",
            "        if header.MessageType == ua.MessageType.SecureOpen:",
            "            data = body.copy(header.body_size)",
            "            security_header = struct_from_binary(ua.AsymmetricAlgorithmHeader, data)",
            "",
            "            if not self.is_open():",
            "                # Only call select_policy if the channel isn't open. Otherwise",
            "                # it will break the Secure channel renewal.",
            "                self.select_policy(security_header.SecurityPolicyURI, security_header.SenderCertificate)",
            "",
            "        elif header.MessageType in (ua.MessageType.SecureMessage, ua.MessageType.SecureClose):",
            "            data = body.copy(header.body_size)",
            "            security_header = struct_from_binary(ua.SymmetricAlgorithmHeader, data)",
            "            self._check_sym_header(security_header)",
            "",
            "        if header.MessageType in (ua.MessageType.SecureMessage, ua.MessageType.SecureOpen, ua.MessageType.SecureClose):",
            "            try:",
            "                pos = body.cur_pos",
            "                chunk = MessageChunk.from_header_and_body(self.security_policy, header, body, use_prev_key=False)",
            "            except InvalidSignature:",
            "                body.rewind(cur_pos=pos)",
            "                chunk = MessageChunk.from_header_and_body(self.security_policy, header, body, use_prev_key=True)",
            "            return self._receive(chunk)",
            "        if header.MessageType == ua.MessageType.Hello:",
            "            msg = struct_from_binary(ua.Hello, body)",
            "            self._max_chunk_size = msg.ReceiveBufferSize",
            "            return msg",
            "        if header.MessageType == ua.MessageType.Acknowledge:",
            "            msg = struct_from_binary(ua.Acknowledge, body)",
            "            self._max_chunk_size = msg.SendBufferSize",
            "            return msg",
            "        if header.MessageType == ua.MessageType.Error:",
            "            msg = struct_from_binary(ua.ErrorMessage, body)",
            "            logger.warning(f\"Received an error: {msg}\")",
            "            return msg",
            "        raise ua.UaError(f\"Unsupported message type {header.MessageType}\")",
            "",
            "    def _receive(self, msg):",
            "        self._check_incoming_chunk(msg)",
            "        self._incoming_parts.append(msg)",
            "        if msg.MessageHeader.ChunkType == ua.ChunkType.Intermediate:",
            "            return None",
            "        if msg.MessageHeader.ChunkType == ua.ChunkType.Abort:",
            "            err = struct_from_binary(ua.ErrorMessage, ua.utils.Buffer(msg.Body))",
            "            logger.warning(f\"Message {msg} aborted: {err}\")",
            "            # specs Part 6, 6.7.3 say that aborted message shall be ignored",
            "            # and SecureChannel should not be closed",
            "            self._incoming_parts = []",
            "            return None",
            "        if msg.MessageHeader.ChunkType == ua.ChunkType.Single:",
            "            message = ua.Message(self._incoming_parts)",
            "            self._incoming_parts = []",
            "            return message",
            "        raise ua.UaError(f\"Unsupported chunk type: {msg}\")"
        ],
        "afterPatchFile": [
            "from dataclasses import dataclass",
            "import hashlib",
            "from datetime import datetime, timedelta",
            "import logging",
            "import copy",
            "",
            "from asyncua import ua",
            "from ..ua.ua_binary import struct_from_binary, struct_to_binary, header_from_binary, header_to_binary",
            "",
            "try:",
            "    from ..crypto.uacrypto import InvalidSignature",
            "except ImportError:",
            "    class InvalidSignature(Exception):  # type: ignore",
            "        pass",
            "",
            "logger = logging.getLogger('asyncua.uaprotocol')",
            "",
            "",
            "@dataclass",
            "class TransportLimits:",
            "    '''",
            "        Limits of the tcp transport layer to prevent excessive resource usage",
            "    '''",
            "    max_recv_buffer: int = 65535",
            "    max_send_buffer: int = 65535",
            "    max_chunk_count: int = ((100 * 1024 * 1024) // 65535) + 1 #  max_message_size / max_recv_buffer ",
            "    max_message_size: int = 100 * 1024 * 1024  # 100mb",
            "",
            "    @staticmethod",
            "    def _select_limit(hint: ua.UInt32, limit: int) -> ua.UInt32:",
            "        if limit <= 0:",
            "            return hint",
            "        elif limit < hint:",
            "            return hint",
            "        return ua.UInt32(limit)",
            "",
            "    def check_max_msg_size(self, sz: int) -> bool:",
            "        if self.max_message_size == 0:",
            "            return True",
            "        return self.max_message_size <= sz",
            "",
            "    def check_max_chunk_count(self, sz: int) -> bool:",
            "        if self.max_chunk_count == 0:",
            "            return True",
            "        return self.max_chunk_count <= sz",
            "",
            "    def create_acknowledge_limits(self, msg: ua.Hello) -> ua.Acknowledge:",
            "        ack = ua.Acknowledge()",
            "        ack.ReceiveBufferSize = min(msg.ReceiveBufferSize, self.max_recv_buffer)",
            "        ack.SendBufferSize = min(msg.SendBufferSize, self.max_send_buffer)",
            "        ack.MaxChunkCount = self._select_limit(msg.MaxChunkCount, self.max_chunk_count)",
            "        ack.MaxMessageSize = self._select_limit(msg.MaxMessageSize, self.max_message_size)",
            "        self.update_limits(ack)",
            "        return ack",
            "",
            "    def create_hello_limits(self, msg: ua.Hello) -> ua.Hello:",
            "        msg.ReceiveBufferSize = self.max_recv_buffer",
            "        msg.SendBufferSize = self.max_send_buffer",
            "        msg.MaxChunkCount = self.max_chunk_count",
            "        msg.MaxMessageSize = self.max_chunk_count",
            "",
            "    def update_limits(self, msg: ua.Acknowledge) -> None:",
            "        self.max_chunk_count = msg.MaxChunkCount",
            "        self.max_recv_buffer = msg.ReceiveBufferSize",
            "        self.max_send_buffer = msg.SendBufferSize",
            "        self.max_message_size = msg.MaxMessageSize",
            "",
            "",
            "class MessageChunk:",
            "    \"\"\"",
            "    Message Chunk, as described in OPC UA specs Part 6, 6.7.2.",
            "    \"\"\"",
            "    def __init__(self, security_policy, body=b'', msg_type=ua.MessageType.SecureMessage, chunk_type=ua.ChunkType.Single):",
            "        self.MessageHeader = ua.Header(msg_type, chunk_type)",
            "        if msg_type in (ua.MessageType.SecureMessage, ua.MessageType.SecureClose):",
            "            self.SecurityHeader = ua.SymmetricAlgorithmHeader()",
            "        elif msg_type == ua.MessageType.SecureOpen:",
            "            self.SecurityHeader = ua.AsymmetricAlgorithmHeader()",
            "        else:",
            "            raise ua.UaError(f\"Unsupported message type: {msg_type}\")",
            "        self.SequenceHeader = ua.SequenceHeader()",
            "        self.Body = body",
            "        self.security_policy = security_policy",
            "",
            "    @staticmethod",
            "    def from_binary(security_policy, data):",
            "        h = header_from_binary(data)",
            "        try:",
            "            return MessageChunk.from_header_and_body(security_policy, h, data)",
            "        except InvalidSignature:",
            "            return MessageChunk.from_header_and_body(security_policy, h, data, use_prev_key=True)",
            "",
            "    @staticmethod",
            "    def from_header_and_body(security_policy, header, buf, use_prev_key=False):",
            "        if not len(buf) >= header.body_size:",
            "            raise ValueError('Full body expected here')",
            "        data = buf.copy(header.body_size)",
            "        buf.skip(header.body_size)",
            "        if header.MessageType in (ua.MessageType.SecureMessage, ua.MessageType.SecureClose):",
            "            security_header = struct_from_binary(ua.SymmetricAlgorithmHeader, data)",
            "            crypto = security_policy.symmetric_cryptography",
            "        elif header.MessageType == ua.MessageType.SecureOpen:",
            "            security_header = struct_from_binary(ua.AsymmetricAlgorithmHeader, data)",
            "            crypto = security_policy.asymmetric_cryptography",
            "        else:",
            "            raise ua.UaError(f\"Unsupported message type: {header.MessageType}\")",
            "        crypto.use_prev_key = use_prev_key",
            "        obj = MessageChunk(crypto)",
            "        obj.MessageHeader = header",
            "        obj.SecurityHeader = security_header",
            "        decrypted = crypto.decrypt(data.read(len(data)))",
            "        signature_size = crypto.vsignature_size()",
            "        if signature_size > 0:",
            "            signature = decrypted[-signature_size:]",
            "            decrypted = decrypted[:-signature_size]",
            "            crypto.verify(header_to_binary(obj.MessageHeader) + struct_to_binary(obj.SecurityHeader) + decrypted, signature)",
            "        data = ua.utils.Buffer(crypto.remove_padding(decrypted))",
            "        obj.SequenceHeader = struct_from_binary(ua.SequenceHeader, data)",
            "        obj.Body = data.read(len(data))",
            "        return obj",
            "",
            "    def encrypted_size(self, plain_size):",
            "        size = plain_size + self.security_policy.signature_size()",
            "        pbs = self.security_policy.plain_block_size()",
            "        if size % pbs != 0:",
            "            raise ua.UaError(\"Encryption error\")",
            "        return size // pbs * self.security_policy.encrypted_block_size()",
            "",
            "    def to_binary(self):",
            "        security = struct_to_binary(self.SecurityHeader)",
            "        encrypted_part = struct_to_binary(self.SequenceHeader) + self.Body",
            "        encrypted_part += self.security_policy.padding(len(encrypted_part))",
            "        self.MessageHeader.body_size = len(security) + self.encrypted_size(len(encrypted_part))",
            "        header = header_to_binary(self.MessageHeader)",
            "        encrypted_part += self.security_policy.signature(header + security + encrypted_part)",
            "        return header + security + self.security_policy.encrypt(encrypted_part)",
            "",
            "    @staticmethod",
            "    def max_body_size(crypto, max_chunk_size):",
            "        max_encrypted_size = max_chunk_size - ua.Header.max_size() - ua.SymmetricAlgorithmHeader.max_size()",
            "        max_plain_size = (max_encrypted_size // crypto.encrypted_block_size()) * crypto.plain_block_size()",
            "        return max_plain_size - ua.SequenceHeader.max_size() - crypto.signature_size() - crypto.min_padding_size()",
            "",
            "    @staticmethod",
            "    def message_to_chunks(security_policy, body, max_chunk_size, message_type=ua.MessageType.SecureMessage, channel_id=1, request_id=1, token_id=1):",
            "        \"\"\"",
            "        Pack message body (as binary string) into one or more chunks.",
            "        Size of each chunk will not exceed max_chunk_size.",
            "        Returns a list of MessageChunks. SequenceNumber is not initialized here,",
            "        it must be set by Secure Channel driver.",
            "        \"\"\"",
            "        if message_type == ua.MessageType.SecureOpen:",
            "            # SecureOpen message must be in a single chunk (specs, Part 6, 6.7.2)",
            "            chunk = MessageChunk(security_policy.asymmetric_cryptography, body, message_type, ua.ChunkType.Single)",
            "            chunk.SecurityHeader.SecurityPolicyURI = security_policy.URI",
            "            if security_policy.host_certificate:",
            "                chunk.SecurityHeader.SenderCertificate = security_policy.host_certificate",
            "            if security_policy.peer_certificate:",
            "                chunk.SecurityHeader.ReceiverCertificateThumbPrint =\\",
            "                    hashlib.sha1(security_policy.peer_certificate).digest()",
            "            chunk.MessageHeader.ChannelId = channel_id",
            "            chunk.SequenceHeader.RequestId = request_id",
            "            return [chunk]",
            "",
            "        crypto = security_policy.symmetric_cryptography",
            "        max_size = MessageChunk.max_body_size(crypto, max_chunk_size)",
            "",
            "        chunks = []",
            "        for i in range(0, len(body), max_size):",
            "            part = body[i:i + max_size]",
            "            if i + max_size >= len(body):",
            "                chunk_type = ua.ChunkType.Single",
            "            else:",
            "                chunk_type = ua.ChunkType.Intermediate",
            "            chunk = MessageChunk(crypto, part, message_type, chunk_type)",
            "            chunk.SecurityHeader.TokenId = token_id",
            "            chunk.MessageHeader.ChannelId = channel_id",
            "            chunk.SequenceHeader.RequestId = request_id",
            "            chunks.append(chunk)",
            "        return chunks",
            "",
            "    def __str__(self):",
            "        return f\"{self.__class__.__name__}({self.MessageHeader}, {self.SequenceHeader},\" \\",
            "               f\" {self.SecurityHeader}, {len(self.Body)} bytes)\"",
            "",
            "    __repr__ = __str__",
            "",
            "",
            "class SecureConnection:",
            "    \"\"\"",
            "    Common logic for client and server",
            "    \"\"\"",
            "    def __init__(self, security_policy, limits: TransportLimits):",
            "        self._sequence_number = 0",
            "        self._peer_sequence_number = None",
            "        self._incoming_parts = []",
            "        self.security_policy = security_policy",
            "        self._policies = []",
            "        self._open = False",
            "        self.security_token = ua.ChannelSecurityToken()",
            "        self.next_security_token = ua.ChannelSecurityToken()",
            "        self.prev_security_token = ua.ChannelSecurityToken()",
            "        self.local_nonce = 0",
            "        self.remote_nonce = 0",
            "        self._allow_prev_token = False",
            "        self._limits = limits",
            "",
            "    def set_channel(self, params, request_type, client_nonce):",
            "        \"\"\"",
            "        Called on client side when getting secure channel data from server.",
            "        \"\"\"",
            "        if request_type == ua.SecurityTokenRequestType.Issue:",
            "            self.security_token = params.SecurityToken",
            "            self.local_nonce = client_nonce",
            "            self.remote_nonce = params.ServerNonce",
            "            self.security_policy.make_local_symmetric_key(self.remote_nonce, self.local_nonce)",
            "            self.security_policy.make_remote_symmetric_key(",
            "                self.local_nonce,",
            "                self.remote_nonce,",
            "                self.security_token.RevisedLifetime",
            "            )",
            "            self._open = True",
            "        else:",
            "            self.next_security_token = params.SecurityToken",
            "            self.local_nonce = client_nonce",
            "            self.remote_nonce = params.ServerNonce",
            "",
            "        self._allow_prev_token = True",
            "",
            "    def open(self, params, server):",
            "        \"\"\"",
            "        Called on server side to open secure channel.",
            "        \"\"\"",
            "",
            "        self.local_nonce = ua.utils.create_nonce(self.security_policy.secure_channel_nonce_length)",
            "        self.remote_nonce = params.ClientNonce",
            "        response = ua.OpenSecureChannelResult()",
            "        response.ServerNonce = self.local_nonce",
            "",
            "        if not self._open or params.RequestType == ua.SecurityTokenRequestType.Issue:",
            "            self._open = True",
            "            self.security_token.TokenId = 13  # random value",
            "            self.security_token.ChannelId = server.get_new_channel_id()",
            "            self.security_token.RevisedLifetime = params.RequestedLifetime",
            "            self.security_token.CreatedAt = datetime.utcnow()",
            "",
            "            response.SecurityToken = self.security_token",
            "",
            "            self.security_policy.make_local_symmetric_key(self.remote_nonce, self.local_nonce)",
            "            self.security_policy.make_remote_symmetric_key(",
            "                self.local_nonce,",
            "                self.remote_nonce,",
            "                self.security_token.RevisedLifetime",
            "            )",
            "        else:",
            "            self.next_security_token = copy.deepcopy(self.security_token)",
            "            self.next_security_token.TokenId += 1",
            "            self.next_security_token.RevisedLifetime = params.RequestedLifetime",
            "            self.next_security_token.CreatedAt = datetime.utcnow()",
            "",
            "            response.SecurityToken = self.next_security_token",
            "",
            "        return response",
            "",
            "    def close(self):",
            "        self._open = False",
            "",
            "    def is_open(self):",
            "        return self._open",
            "",
            "    def set_policy_factories(self, policies):",
            "        \"\"\"",
            "        Set a list of available security policies.",
            "        Use this in servers with multiple endpoints with different security.",
            "        \"\"\"",
            "        self._policies = policies",
            "",
            "    @staticmethod",
            "    def _policy_matches(policy, uri, mode=None):",
            "        return policy.URI == uri and (mode is None or policy.Mode == mode)",
            "",
            "    def select_policy(self, uri, peer_certificate, mode=None):",
            "        for policy in self._policies:",
            "            if policy.matches(uri, mode):",
            "                self.security_policy = policy.create(peer_certificate)",
            "                return",
            "        if self.security_policy.URI != uri or (mode is not None and self.security_policy.Mode != mode):",
            "            raise ua.UaError(f\"No matching policy: {uri}, {mode}\")",
            "",
            "    def revolve_tokens(self):",
            "        \"\"\"",
            "        Revolve security tokens of the security channel. Start using the",
            "        next security token negotiated during the renewal of the channel and",
            "        remember the previous token until the other communication party",
            "        \"\"\"",
            "        self.prev_security_token = self.security_token",
            "        self.security_token = self.next_security_token",
            "        self.next_security_token = ua.ChannelSecurityToken()",
            "        self.security_policy.make_local_symmetric_key(self.remote_nonce, self.local_nonce)",
            "        self.security_policy.make_remote_symmetric_key(self.local_nonce, self.remote_nonce, self.security_token.RevisedLifetime)",
            "",
            "    def message_to_binary(self, message, message_type=ua.MessageType.SecureMessage, request_id=0):",
            "        \"\"\"",
            "        Convert OPC UA secure message to binary.",
            "        The only supported types are SecureOpen, SecureMessage, SecureClose.",
            "        If message_type is SecureMessage, the AlgorithmHeader should be passed as arg.",
            "        \"\"\"",
            "        chunks = MessageChunk.message_to_chunks(",
            "            self.security_policy,",
            "            message,",
            "            self._limits.max_send_buffer,",
            "            message_type=message_type,",
            "            channel_id=self.security_token.ChannelId,",
            "            request_id=request_id,",
            "            token_id=self.security_token.TokenId,",
            "        )",
            "        for chunk in chunks:",
            "            self._sequence_number += 1",
            "            if self._sequence_number >= (1 << 32):",
            "                logger.debug(\"Wrapping sequence number: %d -> 1\", self._sequence_number)",
            "                self._sequence_number = 1",
            "            chunk.SequenceHeader.SequenceNumber = self._sequence_number",
            "        return b\"\".join([chunk.to_binary() for chunk in chunks])",
            "",
            "    def _check_sym_header(self, security_hdr):",
            "        \"\"\"",
            "        Validates the symmetric header of the message chunk and revolves the",
            "        security token if needed.",
            "        \"\"\"",
            "        assert isinstance(security_hdr, ua.SymmetricAlgorithmHeader), f\"Expected SymAlgHeader, got: {security_hdr}\"",
            "",
            "        if security_hdr.TokenId == self.security_token.TokenId:",
            "            return",
            "",
            "        if security_hdr.TokenId == self.next_security_token.TokenId:",
            "            self.revolve_tokens()",
            "            return",
            "",
            "        if self._allow_prev_token and security_hdr.TokenId == self.prev_security_token.TokenId:",
            "            # From spec, part 4, section 5.5.2.1: Clients should accept Messages secured by an",
            "            # expired SecurityToken for up to 25 % of the token lifetime. This should ensure that",
            "            # Messages sent by the Server before the token expired are not rejected because of",
            "            # network delays.",
            "            timeout = self.prev_security_token.CreatedAt + \\",
            "                timedelta(milliseconds=self.prev_security_token.RevisedLifetime * 1.25)",
            "            if timeout < datetime.utcnow():",
            "                raise ua.UaError(f\"Security token id {security_hdr.TokenId} has timed out \" f\"({timeout} < {datetime.utcnow()})\")",
            "            return",
            "",
            "        expected_tokens = [self.security_token.TokenId, self.next_security_token.TokenId]",
            "        if self._allow_prev_token:",
            "            expected_tokens.insert(0, self.prev_security_token.TokenId)",
            "        raise ua.UaError(f\"Invalid security token id {security_hdr.TokenId}, expected one of: {expected_tokens}\")",
            "",
            "    def _check_incoming_chunk(self, chunk):",
            "        if not isinstance(chunk, MessageChunk):",
            "            raise ValueError(f'Expected chunk, got: {chunk}')",
            "        if chunk.MessageHeader.MessageType != ua.MessageType.SecureOpen:",
            "            if chunk.MessageHeader.ChannelId != self.security_token.ChannelId:",
            "                raise ua.UaError(f'Wrong channel id {chunk.MessageHeader.ChannelId},' f' expected {self.security_token.ChannelId}')",
            "        if self._incoming_parts:",
            "            if self._incoming_parts[0].SequenceHeader.RequestId != chunk.SequenceHeader.RequestId:",
            "                raise ua.UaError(f'Wrong request id {chunk.SequenceHeader.RequestId},' f' expected {self._incoming_parts[0].SequenceHeader.RequestId}')",
            "        # The sequence number must monotonically increase (but it can wrap around)",
            "        seq_num = chunk.SequenceHeader.SequenceNumber",
            "        if self._peer_sequence_number is not None:",
            "            if seq_num != self._peer_sequence_number + 1:",
            "                wrap_limit = (1 << 32) - 1024",
            "                if seq_num < 1024 and self._peer_sequence_number >= wrap_limit:",
            "                    # The sequence number has wrapped around. See spec. part 6, 6.7.2",
            "                    logger.debug('Sequence number wrapped: %d -> %d', self._peer_sequence_number, seq_num)",
            "                else:",
            "                    # Condition for monotonically increase is not met",
            "                    raise ua.UaError(f\"Received chunk: {chunk} with wrong sequence expecting:\" f\" {self._peer_sequence_number}, received: {seq_num},\" f\" spec says to close connection\")",
            "        self._peer_sequence_number = seq_num",
            "",
            "    def receive_from_header_and_body(self, header, body):",
            "        \"\"\"",
            "        Convert MessageHeader and binary body to OPC UA TCP message (see OPC UA",
            "        specs Part 6, 7.1: Hello, Acknowledge or ErrorMessage), or a Message",
            "        object, or None (if intermediate chunk is received)",
            "        \"\"\"",
            "        if header.MessageType == ua.MessageType.SecureOpen:",
            "            data = body.copy(header.body_size)",
            "            security_header = struct_from_binary(ua.AsymmetricAlgorithmHeader, data)",
            "",
            "            if not self.is_open():",
            "                # Only call select_policy if the channel isn't open. Otherwise",
            "                # it will break the Secure channel renewal.",
            "                self.select_policy(security_header.SecurityPolicyURI, security_header.SenderCertificate)",
            "",
            "        elif header.MessageType in (ua.MessageType.SecureMessage, ua.MessageType.SecureClose):",
            "            data = body.copy(header.body_size)",
            "            security_header = struct_from_binary(ua.SymmetricAlgorithmHeader, data)",
            "            self._check_sym_header(security_header)",
            "",
            "        if header.MessageType in (ua.MessageType.SecureMessage, ua.MessageType.SecureOpen, ua.MessageType.SecureClose):",
            "            try:",
            "                pos = body.cur_pos",
            "                chunk = MessageChunk.from_header_and_body(self.security_policy, header, body, use_prev_key=False)",
            "            except InvalidSignature:",
            "                body.rewind(cur_pos=pos)",
            "                chunk = MessageChunk.from_header_and_body(self.security_policy, header, body, use_prev_key=True)",
            "            return self._receive(chunk)",
            "        if header.MessageType == ua.MessageType.Hello:",
            "            msg = struct_from_binary(ua.Hello, body)",
            "            return msg",
            "        if header.MessageType == ua.MessageType.Acknowledge:",
            "            msg = struct_from_binary(ua.Acknowledge, body)",
            "            self._limits.update_limits(msg)",
            "            return msg",
            "        if header.MessageType == ua.MessageType.Error:",
            "            msg = struct_from_binary(ua.ErrorMessage, body)",
            "            logger.warning(f\"Received an error: {msg}\")",
            "            return msg",
            "        raise ua.UaError(f\"Unsupported message type {header.MessageType}\")",
            "",
            "    def _receive(self, msg):",
            "        if msg.MessageHeader.packet_size > self._limits.max_recv_buffer:",
            "            self._incoming_parts = []",
            "            raise ua.UaStatusCodeError(ua.StatusCodes.BadRequestTooLarge)",
            "        self._check_incoming_chunk(msg)",
            "        self._incoming_parts.append(msg)",
            "        if not self._limits.check_max_chunk_count(len(self._incoming_parts)):",
            "            self._incoming_parts = []",
            "            raise ua.UaStatusCodeError(ua.StatusCodes.BadRequestTooLarge)",
            "        if msg.MessageHeader.ChunkType == ua.ChunkType.Intermediate:",
            "            return None",
            "        if msg.MessageHeader.ChunkType == ua.ChunkType.Abort:",
            "            err = struct_from_binary(ua.ErrorMessage, ua.utils.Buffer(msg.Body))",
            "            logger.warning(f\"Message {msg} aborted: {err}\")",
            "            # specs Part 6, 6.7.3 say that aborted message shall be ignored",
            "            # and SecureChannel should not be closed",
            "            self._incoming_parts = []",
            "            return None",
            "        if msg.MessageHeader.ChunkType == ua.ChunkType.Single:",
            "            message = ua.Message(self._incoming_parts)",
            "            self._incoming_parts = []",
            "            return message",
            "        raise ua.UaError(f\"Unsupported chunk type: {msg}\")"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "142": [
                "SecureConnection",
                "__init__"
            ],
            "155": [
                "SecureConnection",
                "__init__"
            ],
            "260": [
                "SecureConnection",
                "message_to_binary"
            ],
            "356": [
                "SecureConnection",
                "receive_from_header_and_body"
            ],
            "360": [
                "SecureConnection",
                "receive_from_header_and_body"
            ]
        },
        "addLocation": []
    },
    "asyncua/server/binary_server_asyncio.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " \"\"\""
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import logging"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import asyncio"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import math"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from typing import Optional"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from ..common.connection import TransportLimits"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from ..ua.ua_binary import header_from_binary"
            },
            "8": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from ..common.utils import Buffer, NotEnoughData"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from .uaprocessor import UaProcessor"
            },
            "10": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": "     Instantiated for every connection."
            },
            "11": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks, limits: TransportLimits):"
            },
            "15": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         self.peer_name = None"
            },
            "16": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         self.transport = None"
            },
            "17": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         self.processor = None"
            },
            "18": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         self.clients = clients"
            },
            "19": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         self.closing_tasks = closing_tasks"
            },
            "20": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         self.messages = asyncio.Queue()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        self.limits = limits"
            },
            "22": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         self._task = None"
            },
            "23": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     def __str__(self):"
            },
            "25": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         self.peer_name = transport.get_extra_info('peername')"
            },
            "26": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         logger.info('New connection from %s', self.peer_name)"
            },
            "27": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         self.transport = transport"
            },
            "28": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.processor = UaProcessor(self.iserver, self.transport)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        self.processor = UaProcessor(self.iserver, self.transport, self.limits)"
            },
            "30": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         self.processor.set_policies(self.policies)"
            },
            "31": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         self.iserver.asyncio_transports.append(transport)"
            },
            "32": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         self.clients.append(self)"
            },
            "33": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.clients = []"
            },
            "34": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         self.closing_tasks = []"
            },
            "35": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         self.cleanup_task = None"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        # Use accectable limits"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        buffer_sz = 65535"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        max_msg_sz = 16 * 1024 * 1024  # 16mb simular to the opc ua c stack so this is a good default"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+        self.limits = TransportLimits("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+            max_recv_buffer=buffer_sz,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+            max_send_buffer=buffer_sz,"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+            max_chunk_count=math.ceil(buffer_sz / max_msg_sz),  # Round up to allow max msg size"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+            max_message_size=max_msg_sz"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        )"
            },
            "45": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "     def set_policies(self, policies):"
            },
            "47": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         self._policies = policies"
            },
            "48": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             policies=self._policies,"
            },
            "49": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             clients=self.clients,"
            },
            "50": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "             closing_tasks=self.closing_tasks,"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            limits=self.limits"
            },
            "52": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         )"
            },
            "53": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "     async def start(self):"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Socket server forwarding request to internal server",
            "\"\"\"",
            "import logging",
            "import asyncio",
            "from typing import Optional",
            "",
            "from ..ua.ua_binary import header_from_binary",
            "from ..common.utils import Buffer, NotEnoughData",
            "from .uaprocessor import UaProcessor",
            "from .internal_server import InternalServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class OPCUAProtocol(asyncio.Protocol):",
            "    \"\"\"",
            "    Instantiated for every connection.",
            "    \"\"\"",
            "",
            "    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks):",
            "        self.peer_name = None",
            "        self.transport = None",
            "        self.processor = None",
            "        self._buffer = b''",
            "        self.iserver: InternalServer = iserver",
            "        self.policies = policies",
            "        self.clients = clients",
            "        self.closing_tasks = closing_tasks",
            "        self.messages = asyncio.Queue()",
            "        self._task = None",
            "",
            "    def __str__(self):",
            "        return f'OPCUAProtocol({self.peer_name}, {self.processor.session})'",
            "",
            "    __repr__ = __str__",
            "",
            "    def connection_made(self, transport):",
            "        self.peer_name = transport.get_extra_info('peername')",
            "        logger.info('New connection from %s', self.peer_name)",
            "        self.transport = transport",
            "        self.processor = UaProcessor(self.iserver, self.transport)",
            "        self.processor.set_policies(self.policies)",
            "        self.iserver.asyncio_transports.append(transport)",
            "        self.clients.append(self)",
            "        self._task = asyncio.create_task(self._process_received_message_loop())",
            "",
            "    def connection_lost(self, ex):",
            "        logger.info('Lost connection from %s, %s', self.peer_name, ex)",
            "        self.transport.close()",
            "        self.iserver.asyncio_transports.remove(self.transport)",
            "        closing_task = asyncio.create_task(self.processor.close())",
            "        self.closing_tasks.append(closing_task)",
            "        if self in self.clients:",
            "            self.clients.remove(self)",
            "        self.messages.put_nowait((None, None))",
            "        self._task.cancel()",
            "",
            "    def data_received(self, data):",
            "        self._buffer += data",
            "        # try to parse the incoming data",
            "        while self._buffer:",
            "            try:",
            "                buf = Buffer(self._buffer)",
            "                try:",
            "                    header = header_from_binary(buf)",
            "                except NotEnoughData:",
            "                    # a packet should at least contain a header otherwise it is malformed (8 or 12 bytes)",
            "                    logger.debug('Not enough data while parsing header from client, empty the buffer')",
            "                    self.transport.close()",
            "                    return",
            "                if header.header_size + header.body_size <= header.header_size:",
            "                    # malformed header prevent invalid access of your buffer",
            "                    logger.error(f'Got malformed header {header}')",
            "                    self.transport.close()",
            "                else:",
            "                    if len(buf) < header.body_size:",
            "                        logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,",
            "                                    len(buf))",
            "                        return",
            "                    # we have a complete message",
            "                    self.messages.put_nowait((header, buf))",
            "                    self._buffer = self._buffer[(header.header_size + header.body_size):]",
            "            except Exception:",
            "                logger.exception('Exception raised while parsing message from client')",
            "                return",
            "",
            "    async def _process_received_message_loop(self):",
            "        \"\"\"",
            "        Take message from the queue and try to process it.",
            "        \"\"\"",
            "        while True:",
            "            header, buf = await self.messages.get()",
            "            if header is None and buf is None:",
            "                # Connection was closed, end task",
            "                break",
            "            try:",
            "                await self._process_one_msg(header, buf)",
            "            except Exception:",
            "                logger.exception('Exception raised while processing message from client')",
            "",
            "    async def _process_one_msg(self, header, buf):",
            "        logger.debug('_process_received_message %s %s', header.body_size, len(buf))",
            "        ret = await self.processor.process(header, buf)",
            "        if not ret:",
            "            logger.info('processor returned False, we close connection from %s', self.peer_name)",
            "            self.transport.close()",
            "            return",
            "",
            "",
            "class BinaryServer:",
            "    def __init__(self, internal_server: InternalServer, hostname, port):",
            "        self.logger = logging.getLogger(__name__)",
            "        self.hostname = hostname",
            "        self.port = port",
            "        self.iserver: InternalServer = internal_server",
            "        self._server: Optional[asyncio.AbstractServer] = None",
            "        self._policies = []",
            "        self.clients = []",
            "        self.closing_tasks = []",
            "        self.cleanup_task = None",
            "",
            "    def set_policies(self, policies):",
            "        self._policies = policies",
            "",
            "    def _make_protocol(self):",
            "        \"\"\"Protocol Factory\"\"\"",
            "        return OPCUAProtocol(",
            "            iserver=self.iserver,",
            "            policies=self._policies,",
            "            clients=self.clients,",
            "            closing_tasks=self.closing_tasks,",
            "        )",
            "",
            "    async def start(self):",
            "        self._server = await asyncio.get_running_loop().create_server(self._make_protocol, self.hostname, self.port)",
            "        # get the port and the hostname from the created server socket",
            "        # only relevant for dynamic port asignment (when self.port == 0)",
            "        if self.port == 0 and len(self._server.sockets) == 1:",
            "            # will work for AF_INET and AF_INET6 socket names",
            "            # these are to only families supported by the create_server call",
            "            sockname = self._server.sockets[0].getsockname()",
            "            self.hostname = sockname[0]",
            "            self.port = sockname[1]",
            "        self.logger.info('Listening on %s:%s', self.hostname, self.port)",
            "        self.cleanup_task = asyncio.create_task(self._close_task_loop())",
            "",
            "    async def stop(self):",
            "        self.logger.info('Closing asyncio socket server')",
            "        for transport in self.iserver.asyncio_transports:",
            "            transport.close()",
            "",
            "        # stop cleanup process and run it a last time",
            "        self.cleanup_task.cancel()",
            "        try:",
            "            await self.cleanup_task",
            "        except asyncio.CancelledError:",
            "            pass",
            "        await self._close_tasks()",
            "",
            "        if self._server:",
            "            asyncio.get_running_loop().call_soon(self._server.close)",
            "            await self._server.wait_closed()",
            "",
            "    async def _close_task_loop(self):",
            "        while True:",
            "            await self._close_tasks()",
            "            await asyncio.sleep(10)",
            "",
            "    async def _close_tasks(self):",
            "        while self.closing_tasks:",
            "            task = self.closing_tasks.pop()",
            "            try:",
            "                await task",
            "            except asyncio.CancelledError:",
            "                # this means a stop request has been sent, it should not be catched",
            "                raise",
            "            except Exception:",
            "                logger.exception(\"Unexpected crash in BinaryServer._close_tasks\")"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Socket server forwarding request to internal server",
            "\"\"\"",
            "import logging",
            "import asyncio",
            "import math",
            "from typing import Optional",
            "",
            "from ..common.connection import TransportLimits",
            "from ..ua.ua_binary import header_from_binary",
            "from ..common.utils import Buffer, NotEnoughData",
            "from .uaprocessor import UaProcessor",
            "from .internal_server import InternalServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class OPCUAProtocol(asyncio.Protocol):",
            "    \"\"\"",
            "    Instantiated for every connection.",
            "    \"\"\"",
            "",
            "    def __init__(self, iserver: InternalServer, policies, clients, closing_tasks, limits: TransportLimits):",
            "        self.peer_name = None",
            "        self.transport = None",
            "        self.processor = None",
            "        self._buffer = b''",
            "        self.iserver: InternalServer = iserver",
            "        self.policies = policies",
            "        self.clients = clients",
            "        self.closing_tasks = closing_tasks",
            "        self.messages = asyncio.Queue()",
            "        self.limits = limits",
            "        self._task = None",
            "",
            "    def __str__(self):",
            "        return f'OPCUAProtocol({self.peer_name}, {self.processor.session})'",
            "",
            "    __repr__ = __str__",
            "",
            "    def connection_made(self, transport):",
            "        self.peer_name = transport.get_extra_info('peername')",
            "        logger.info('New connection from %s', self.peer_name)",
            "        self.transport = transport",
            "        self.processor = UaProcessor(self.iserver, self.transport, self.limits)",
            "        self.processor.set_policies(self.policies)",
            "        self.iserver.asyncio_transports.append(transport)",
            "        self.clients.append(self)",
            "        self._task = asyncio.create_task(self._process_received_message_loop())",
            "",
            "    def connection_lost(self, ex):",
            "        logger.info('Lost connection from %s, %s', self.peer_name, ex)",
            "        self.transport.close()",
            "        self.iserver.asyncio_transports.remove(self.transport)",
            "        closing_task = asyncio.create_task(self.processor.close())",
            "        self.closing_tasks.append(closing_task)",
            "        if self in self.clients:",
            "            self.clients.remove(self)",
            "        self.messages.put_nowait((None, None))",
            "        self._task.cancel()",
            "",
            "    def data_received(self, data):",
            "        self._buffer += data",
            "        # try to parse the incoming data",
            "        while self._buffer:",
            "            try:",
            "                buf = Buffer(self._buffer)",
            "                try:",
            "                    header = header_from_binary(buf)",
            "                except NotEnoughData:",
            "                    # a packet should at least contain a header otherwise it is malformed (8 or 12 bytes)",
            "                    logger.debug('Not enough data while parsing header from client, empty the buffer')",
            "                    self.transport.close()",
            "                    return",
            "                if header.header_size + header.body_size <= header.header_size:",
            "                    # malformed header prevent invalid access of your buffer",
            "                    logger.error(f'Got malformed header {header}')",
            "                    self.transport.close()",
            "                else:",
            "                    if len(buf) < header.body_size:",
            "                        logger.debug('We did not receive enough data from client. Need %s got %s', header.body_size,",
            "                                    len(buf))",
            "                        return",
            "                    # we have a complete message",
            "                    self.messages.put_nowait((header, buf))",
            "                    self._buffer = self._buffer[(header.header_size + header.body_size):]",
            "            except Exception:",
            "                logger.exception('Exception raised while parsing message from client')",
            "                return",
            "",
            "    async def _process_received_message_loop(self):",
            "        \"\"\"",
            "        Take message from the queue and try to process it.",
            "        \"\"\"",
            "        while True:",
            "            header, buf = await self.messages.get()",
            "            if header is None and buf is None:",
            "                # Connection was closed, end task",
            "                break",
            "            try:",
            "                await self._process_one_msg(header, buf)",
            "            except Exception:",
            "                logger.exception('Exception raised while processing message from client')",
            "",
            "    async def _process_one_msg(self, header, buf):",
            "        logger.debug('_process_received_message %s %s', header.body_size, len(buf))",
            "        ret = await self.processor.process(header, buf)",
            "        if not ret:",
            "            logger.info('processor returned False, we close connection from %s', self.peer_name)",
            "            self.transport.close()",
            "            return",
            "",
            "",
            "class BinaryServer:",
            "    def __init__(self, internal_server: InternalServer, hostname, port):",
            "        self.logger = logging.getLogger(__name__)",
            "        self.hostname = hostname",
            "        self.port = port",
            "        self.iserver: InternalServer = internal_server",
            "        self._server: Optional[asyncio.AbstractServer] = None",
            "        self._policies = []",
            "        self.clients = []",
            "        self.closing_tasks = []",
            "        self.cleanup_task = None",
            "        # Use accectable limits",
            "        buffer_sz = 65535",
            "        max_msg_sz = 16 * 1024 * 1024  # 16mb simular to the opc ua c stack so this is a good default",
            "        self.limits = TransportLimits(",
            "            max_recv_buffer=buffer_sz,",
            "            max_send_buffer=buffer_sz,",
            "            max_chunk_count=math.ceil(buffer_sz / max_msg_sz),  # Round up to allow max msg size",
            "            max_message_size=max_msg_sz",
            "        )",
            "",
            "    def set_policies(self, policies):",
            "        self._policies = policies",
            "",
            "    def _make_protocol(self):",
            "        \"\"\"Protocol Factory\"\"\"",
            "        return OPCUAProtocol(",
            "            iserver=self.iserver,",
            "            policies=self._policies,",
            "            clients=self.clients,",
            "            closing_tasks=self.closing_tasks,",
            "            limits=self.limits",
            "        )",
            "",
            "    async def start(self):",
            "        self._server = await asyncio.get_running_loop().create_server(self._make_protocol, self.hostname, self.port)",
            "        # get the port and the hostname from the created server socket",
            "        # only relevant for dynamic port asignment (when self.port == 0)",
            "        if self.port == 0 and len(self._server.sockets) == 1:",
            "            # will work for AF_INET and AF_INET6 socket names",
            "            # these are to only families supported by the create_server call",
            "            sockname = self._server.sockets[0].getsockname()",
            "            self.hostname = sockname[0]",
            "            self.port = sockname[1]",
            "        self.logger.info('Listening on %s:%s', self.hostname, self.port)",
            "        self.cleanup_task = asyncio.create_task(self._close_task_loop())",
            "",
            "    async def stop(self):",
            "        self.logger.info('Closing asyncio socket server')",
            "        for transport in self.iserver.asyncio_transports:",
            "            transport.close()",
            "",
            "        # stop cleanup process and run it a last time",
            "        self.cleanup_task.cancel()",
            "        try:",
            "            await self.cleanup_task",
            "        except asyncio.CancelledError:",
            "            pass",
            "        await self._close_tasks()",
            "",
            "        if self._server:",
            "            asyncio.get_running_loop().call_soon(self._server.close)",
            "            await self._server.wait_closed()",
            "",
            "    async def _close_task_loop(self):",
            "        while True:",
            "            await self._close_tasks()",
            "            await asyncio.sleep(10)",
            "",
            "    async def _close_tasks(self):",
            "        while self.closing_tasks:",
            "            task = self.closing_tasks.pop()",
            "            try:",
            "                await task",
            "            except asyncio.CancelledError:",
            "                # this means a stop request has been sent, it should not be catched",
            "                raise",
            "            except Exception:",
            "                logger.exception(\"Unexpected crash in BinaryServer._close_tasks\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": [
                "OPCUAProtocol",
                "__init__"
            ],
            "42": [
                "OPCUAProtocol",
                "connection_made"
            ]
        },
        "addLocation": []
    },
    "asyncua/server/uaprocessor.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+import copy"
            },
            "1": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import time"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import logging"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from typing import Deque, Optional"
            },
            "4": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from asyncua import ua"
            },
            "5": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ..ua.ua_binary import nodeid_from_binary, struct_from_binary, struct_to_binary, uatcp_to_binary"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from .internal_server import InternalServer, InternalSession"
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ..common.connection import SecureConnection"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from ..common.connection import SecureConnection, TransportLimits"
            },
            "9": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from ..common.utils import ServiceError"
            },
            "10": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " _logger = logging.getLogger(__name__)"
            },
            "12": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     Processor for OPC UA messages. Implements the OPC UA protocol for the server side."
            },
            "13": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     \"\"\""
            },
            "14": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, internal_server: InternalServer, transport):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+    def __init__(self, internal_server: InternalServer, transport, limits: TransportLimits):"
            },
            "17": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         self.iserver: InternalServer = internal_server"
            },
            "18": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         self.name = transport.get_extra_info('peername')"
            },
            "19": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         self.sockname = transport.get_extra_info('sockname')"
            },
            "20": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         self._publish_requests: Deque[PublishRequestData] = deque()"
            },
            "21": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         # used when we need to wait for PublishRequest"
            },
            "22": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         self._publish_results: Deque[ua.PublishResult] = deque()"
            },
            "23": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._connection = SecureConnection(ua.SecurityPolicy())"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        self._limits = copy.deepcopy(limits)  # Copy limits because they get overriden"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        self._connection = SecureConnection(ua.SecurityPolicy(), self._limits)"
            },
            "26": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def set_policies(self, policies):"
            },
            "28": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         self._connection.set_policy_factories(policies)"
            },
            "29": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     async def process(self, header, body):"
            },
            "30": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         try:"
            },
            "31": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             msg = self._connection.receive_from_header_and_body(header, body)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        except ua.uaerrors.BadRequestTooLarge as e:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            _logger.warning(\"Recived request that exceed the transport limits\")"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            err = ua.ErrorMessage(ua.StatusCode(e.code), str(e))"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+            data = uatcp_to_binary(ua.MessageType.Error, err)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+            self._transport.write(data)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            return True"
            },
            "38": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         except ua.uaerrors.BadUserAccessDenied:"
            },
            "39": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "             _logger.warning(\"Unauthenticated user attempted to connect\")"
            },
            "40": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "             return False"
            },
            "41": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             elif header.MessageType == ua.MessageType.SecureMessage:"
            },
            "42": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "                 return await self.process_message(msg.SequenceHeader(), msg.body())"
            },
            "43": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         elif isinstance(msg, ua.Hello):"
            },
            "44": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ack = ua.Acknowledge()"
            },
            "45": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ack.ReceiveBufferSize = msg.ReceiveBufferSize"
            },
            "46": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            ack.SendBufferSize = msg.SendBufferSize"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+            ack = self._limits.create_acknowledge_limits(msg)"
            },
            "48": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "             data = uatcp_to_binary(ua.MessageType.Acknowledge, ack)"
            },
            "49": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "             self._transport.write(data)"
            },
            "50": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         elif isinstance(msg, ua.ErrorMessage):"
            }
        },
        "frontPatchFile": [
            "import time",
            "import logging",
            "from typing import Deque, Optional",
            "from collections import deque",
            "",
            "from asyncua import ua",
            "from ..ua.ua_binary import nodeid_from_binary, struct_from_binary, struct_to_binary, uatcp_to_binary",
            "from .internal_server import InternalServer, InternalSession",
            "from ..common.connection import SecureConnection",
            "from ..common.utils import ServiceError",
            "",
            "_logger = logging.getLogger(__name__)",
            "",
            "",
            "class PublishRequestData:",
            "",
            "    def __init__(self, requesthdr=None, seqhdr=None):",
            "        self.requesthdr = requesthdr",
            "        self.seqhdr = seqhdr",
            "        self.timestamp = time.time()",
            "",
            "",
            "class UaProcessor:",
            "    \"\"\"",
            "    Processor for OPC UA messages. Implements the OPC UA protocol for the server side.",
            "    \"\"\"",
            "",
            "    def __init__(self, internal_server: InternalServer, transport):",
            "        self.iserver: InternalServer = internal_server",
            "        self.name = transport.get_extra_info('peername')",
            "        self.sockname = transport.get_extra_info('sockname')",
            "        self.session: Optional[InternalSession] = None",
            "        self._transport = transport",
            "        # deque for Publish Requests",
            "        self._publish_requests: Deque[PublishRequestData] = deque()",
            "        # used when we need to wait for PublishRequest",
            "        self._publish_results: Deque[ua.PublishResult] = deque()",
            "        self._connection = SecureConnection(ua.SecurityPolicy())",
            "",
            "    def set_policies(self, policies):",
            "        self._connection.set_policy_factories(policies)",
            "",
            "    def send_response(self, requesthandle, seqhdr, response, msgtype=ua.MessageType.SecureMessage):",
            "        response.ResponseHeader.RequestHandle = requesthandle",
            "        data = self._connection.message_to_binary(",
            "            struct_to_binary(response), message_type=msgtype, request_id=seqhdr.RequestId)",
            "        self._transport.write(data)",
            "",
            "    def open_secure_channel(self, algohdr, seqhdr, body):",
            "        request = struct_from_binary(ua.OpenSecureChannelRequest, body)",
            "",
            "        if not self._connection.is_open():",
            "            # Only call select_policy if the channel isn't open. Otherwise",
            "            # it will break the Secure channel renewal.",
            "            self._connection.select_policy(",
            "                algohdr.SecurityPolicyURI, algohdr.SenderCertificate, request.Parameters.SecurityMode)",
            "",
            "        channel = self._connection.open(request.Parameters, self.iserver)",
            "        # send response",
            "        response = ua.OpenSecureChannelResponse()",
            "        response.Parameters = channel",
            "        self.send_response(request.RequestHeader.RequestHandle, seqhdr, response, ua.MessageType.SecureOpen)",
            "",
            "    async def forward_publish_response(self, result: ua.PublishResult):",
            "        \"\"\"",
            "        Try to send a `PublishResponse` with the given `PublishResult`.",
            "        \"\"\"",
            "        # _logger.info(\"forward publish response %s\", result)",
            "        while True:",
            "            if not self._publish_requests:",
            "                self._publish_results.append(result)",
            "                _logger.info(",
            "                    \"Server wants to send publish answer but no publish request is available,\"",
            "                    \"enqueuing notification, length of result queue is %s\",",
            "                    len(self._publish_results)",
            "                )",
            "                return",
            "            # We pop left from the Publish Request deque (FIFO)",
            "            requestdata = self._publish_requests.popleft()",
            "            if (requestdata.requesthdr.TimeoutHint == 0 or",
            "                    requestdata.requesthdr.TimeoutHint != 0 and",
            "                    time.time() - requestdata.timestamp < requestdata.requesthdr.TimeoutHint / 1000):",
            "                # Continue and use `requestdata` only if there was no timeout",
            "                break",
            "        response = ua.PublishResponse()",
            "        response.Parameters = result",
            "        self.send_response(requestdata.requesthdr.RequestHandle, requestdata.seqhdr, response)",
            "",
            "    async def process(self, header, body):",
            "        try:",
            "            msg = self._connection.receive_from_header_and_body(header, body)",
            "        except ua.uaerrors.BadUserAccessDenied:",
            "            _logger.warning(\"Unauthenticated user attempted to connect\")",
            "            return False",
            "        if isinstance(msg, ua.Message):",
            "            if header.MessageType == ua.MessageType.SecureOpen:",
            "                self.open_secure_channel(msg.SecurityHeader(), msg.SequenceHeader(), msg.body())",
            "            elif header.MessageType == ua.MessageType.SecureClose:",
            "                self._connection.close()",
            "                return False",
            "            elif header.MessageType == ua.MessageType.SecureMessage:",
            "                return await self.process_message(msg.SequenceHeader(), msg.body())",
            "        elif isinstance(msg, ua.Hello):",
            "            ack = ua.Acknowledge()",
            "            ack.ReceiveBufferSize = msg.ReceiveBufferSize",
            "            ack.SendBufferSize = msg.SendBufferSize",
            "            data = uatcp_to_binary(ua.MessageType.Acknowledge, ack)",
            "            self._transport.write(data)",
            "        elif isinstance(msg, ua.ErrorMessage):",
            "            _logger.warning(\"Received an error message type\")",
            "        elif msg is None:",
            "            pass  # msg is a ChunkType.Intermediate of an ua.MessageType.SecureMessage",
            "        else:",
            "            _logger.warning(\"Unsupported message type: %s\", header.MessageType)",
            "            raise ServiceError(ua.StatusCodes.BadTcpMessageTypeInvalid)",
            "        return True",
            "",
            "    async def process_message(self, seqhdr, body):",
            "        \"\"\"",
            "        Process incoming messages.",
            "        \"\"\"",
            "        typeid = nodeid_from_binary(body)",
            "        requesthdr = struct_from_binary(ua.RequestHeader, body)",
            "        _logger.debug('process_message %r %r', typeid, requesthdr)",
            "        try:",
            "            return await self._process_message(typeid, requesthdr, seqhdr, body)",
            "        except ServiceError as e:",
            "            status = ua.StatusCode(e.code)",
            "            response = ua.ServiceFault()",
            "            response.ResponseHeader.ServiceResult = status",
            "            _logger.error(\"sending service fault response: %s (%s)\", status.doc, status.name)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "            return True",
            "        except ua.uaerrors.BadUserAccessDenied:",
            "            if self.session:",
            "                user = self.session.user",
            "            else:",
            "                user = 'Someone'",
            "            _logger.warning(\"%s attempted to do something they are not permitted to do\", user)",
            "            response = ua.ServiceFault()",
            "            response.ResponseHeader.ServiceResult = ua.StatusCode(ua.StatusCodes.BadUserAccessDenied)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "        except Exception:",
            "            _logger.exception('Error while processing message')",
            "            response = ua.ServiceFault()",
            "            response.ResponseHeader.ServiceResult = ua.StatusCode(ua.StatusCodes.BadInternalError)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "            return True",
            "",
            "    async def _process_message(self, typeid, requesthdr, seqhdr, body):",
            "        if typeid in [ua.NodeId(ua.ObjectIds.CreateSessionRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.CloseSessionRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.ActivateSessionRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.FindServersRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.GetEndpointsRequest_Encoding_DefaultBinary)]:",
            "            # The connection is first created without a user being attached, and then during activation the",
            "            user = None",
            "        elif self.session is None:",
            "            _logger.warning(\"Received a request of type %d without an existing session\", typeid.Identifier)",
            "            raise ua.uaerrors.BadUserAccessDenied",
            "        else:",
            "            user = self.session.user",
            "            if self._connection.security_policy.permissions is not None:",
            "                if self._connection.security_policy.permissions.check_validity(user, typeid, body) is False:",
            "                    raise ua.uaerrors.BadUserAccessDenied",
            "",
            "        if typeid == ua.NodeId(ua.ObjectIds.CreateSessionRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"Create session request (%s)\", user)",
            "            params = struct_from_binary(ua.CreateSessionParameters, body)",
            "            # create the session on server",
            "            self.session = self.iserver.create_session(self.name, external=True)",
            "            # get a session creation result to send back",
            "            sessiondata = await self.session.create_session(params, sockname=self.sockname)",
            "            response = ua.CreateSessionResponse()",
            "            response.Parameters = sessiondata",
            "            response.Parameters.ServerCertificate = self._connection.security_policy.host_certificate",
            "            if self._connection.security_policy.peer_certificate is None:",
            "                data = params.ClientNonce",
            "            else:",
            "                data = self._connection.security_policy.peer_certificate + params.ClientNonce",
            "            response.Parameters.ServerSignature.Signature = \\",
            "                self._connection.security_policy.asymmetric_cryptography.signature(data)",
            "            response.Parameters.ServerSignature.Algorithm = self._connection.security_policy.AsymmetricSignatureURI",
            "            # _logger.info(\"sending create session response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.CloseSessionRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"Close session request (%s)\", user)",
            "            if self.session:",
            "                deletesubs = ua.ua_binary.Primitives.Boolean.unpack(body)",
            "                await self.session.close_session(deletesubs)",
            "            else:",
            "                _logger.info(\"Request to close non-existing session (%s)\", user)",
            "",
            "            response = ua.CloseSessionResponse()",
            "            _logger.info(\"sending close session response (%s)\", user)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.ActivateSessionRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"Activate session request (%s)\", user)",
            "            params = struct_from_binary(ua.ActivateSessionParameters, body)",
            "            if not self.session:",
            "                _logger.info(\"request to activate non-existing session (%s)\", user)",
            "                raise ServiceError(ua.StatusCodes.BadSessionIdInvalid)",
            "            if self._connection.security_policy.host_certificate is None:",
            "                data = self.session.nonce",
            "            else:",
            "                data = self._connection.security_policy.host_certificate + self.session.nonce",
            "            self._connection.security_policy.asymmetric_cryptography.verify(data, params.ClientSignature.Signature)",
            "            result = self.session.activate_session(params, self._connection.security_policy.peer_certificate)",
            "            response = ua.ActivateSessionResponse()",
            "            response.Parameters = result",
            "            # _logger.info(\"sending read response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "        elif typeid == ua.NodeId(ua.ObjectIds.GetEndpointsRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"get endpoints request (%s)\", user)",
            "            params = struct_from_binary(ua.GetEndpointsParameters, body)",
            "            endpoints = await self.iserver.get_endpoints(params, sockname=self.sockname)",
            "            response = ua.GetEndpointsResponse()",
            "            response.Endpoints = endpoints",
            "            # _logger.info(\"sending get endpoints response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.FindServersRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"find servers request (%s)\", user)",
            "            params = struct_from_binary(ua.FindServersParameters, body)",
            "            servers = self.iserver.find_servers(params)",
            "            response = ua.FindServersResponse()",
            "            response.Servers = servers",
            "            # _logger.info(\"sending find servers response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.RegisterServerRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"register server request %s\", user)",
            "            serv = struct_from_binary(ua.RegisteredServer, body)",
            "            self.iserver.register_server(serv)",
            "            response = ua.RegisterServerResponse()",
            "            # _logger.info(\"sending register server response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.RegisterServer2Request_Encoding_DefaultBinary):",
            "            _logger.info(\"register server 2 request %s\", user)",
            "            params = struct_from_binary(ua.RegisterServer2Parameters, body)",
            "            results = self.iserver.register_server2(params)",
            "            response = ua.RegisterServer2Response()",
            "            response.ConfigurationResults = results",
            "            # _logger.info(\"sending register server 2 response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "        elif typeid == ua.NodeId(ua.ObjectIds.CloseSecureChannelRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"close secure channel request (%s)\", user)",
            "            self._connection.close()",
            "            response = ua.CloseSecureChannelResponse()",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "            return False",
            "        else:",
            "            # All services that requere a active session",
            "            if not self.session:",
            "                _logger.info(\"Request service that need a session (%s)\", user)",
            "                raise ServiceError(ua.StatusCodes.BadSessionIdInvalid)",
            "            if not self.session.is_activated():",
            "                _logger.info(\"Request service that needs a activated session (%s)\", user)",
            "                raise ServiceError(ua.StatusCodes.BadSessionNotActivated)",
            "",
            "            if typeid == ua.NodeId(ua.ObjectIds.ReadRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"Read request (%s)\", user)",
            "                params = struct_from_binary(ua.ReadParameters, body)",
            "                results = await self.session.read(params)",
            "                response = ua.ReadResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending read response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.WriteRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"Write request (%s)\", user)",
            "                params = struct_from_binary(ua.WriteParameters, body)",
            "                results = await self.session.write(params)",
            "                response = ua.WriteResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending write response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.BrowseRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"Browse request (%s)\", user)",
            "                params = struct_from_binary(ua.BrowseParameters, body)",
            "                results = await self.session.browse(params)",
            "                response = ua.BrowseResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending browse response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.TranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"translate browsepaths to nodeids request (%s)\", user)",
            "                params = struct_from_binary(ua.TranslateBrowsePathsToNodeIdsParameters, body)",
            "                paths = await self.session.translate_browsepaths_to_nodeids(params.BrowsePaths)",
            "                response = ua.TranslateBrowsePathsToNodeIdsResponse()",
            "                response.Results = paths",
            "                # _logger.info(\"sending translate browsepaths to nodeids response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.AddNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"add nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.AddNodesParameters, body)",
            "                results = await self.session.add_nodes(params.NodesToAdd)",
            "                response = ua.AddNodesResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending add node response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteNodesParameters, body)",
            "                results = await self.session.delete_nodes(params)",
            "                response = ua.DeleteNodesResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending delete node response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.AddReferencesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"add references request (%s)\", user)",
            "                params = struct_from_binary(ua.AddReferencesParameters, body)",
            "                results = await self.session.add_references(params.ReferencesToAdd)",
            "                response = ua.AddReferencesResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending add references response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteReferencesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete references request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteReferencesParameters, body)",
            "                results = await self.session.delete_references(params.ReferencesToDelete)",
            "                response = ua.DeleteReferencesResponse()",
            "                response.Parameters.Results = results",
            "                # _logger.info(\"sending delete references response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.CreateSubscriptionRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"create subscription request (%s)\", user)",
            "                params = struct_from_binary(ua.CreateSubscriptionParameters, body)",
            "                result = await self.session.create_subscription(params, callback=self.forward_publish_response)",
            "                response = ua.CreateSubscriptionResponse()",
            "                response.Parameters = result",
            "                # _logger.info(\"sending create subscription response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.ModifySubscriptionRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"modify subscription request\")",
            "                params = struct_from_binary(ua.ModifySubscriptionParameters, body)",
            "",
            "                result = self.session.modify_subscription(params, self.forward_publish_response)",
            "",
            "                response = ua.ModifySubscriptionResponse()",
            "                response.Parameters = result",
            "",
            "                #_logger.info(\"sending modify subscription response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteSubscriptionsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete subscriptions request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteSubscriptionsParameters, body)",
            "                results = await self.session.delete_subscriptions(params.SubscriptionIds)",
            "                response = ua.DeleteSubscriptionsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending delete subscription response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.CreateMonitoredItemsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"create monitored items request (%s)\", user)",
            "                params = struct_from_binary(ua.CreateMonitoredItemsParameters, body)",
            "                results = await self.session.create_monitored_items(params)",
            "                response = ua.CreateMonitoredItemsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending create monitored items response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.ModifyMonitoredItemsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"modify monitored items request (%s)\", user)",
            "                params = struct_from_binary(ua.ModifyMonitoredItemsParameters, body)",
            "                results = await self.session.modify_monitored_items(params)",
            "                response = ua.ModifyMonitoredItemsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending modify monitored items response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteMonitoredItemsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete monitored items request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteMonitoredItemsParameters, body)",
            "                results = await self.session.delete_monitored_items(params)",
            "                response = ua.DeleteMonitoredItemsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending delete monitored items response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.HistoryReadRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"history read request (%s)\", user)",
            "                params = struct_from_binary(ua.HistoryReadParameters, body)",
            "                results = await self.session.history_read(params)",
            "                response = ua.HistoryReadResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending history read response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.RegisterNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"register nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.RegisterNodesParameters, body)",
            "                _logger.info(\"Node registration not implemented\")",
            "                response = ua.RegisterNodesResponse()",
            "                response.Parameters.RegisteredNodeIds = params.NodesToRegister",
            "                # _logger.info(\"sending register nodes response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.UnregisterNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"unregister nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.UnregisterNodesParameters, body)",
            "                response = ua.UnregisterNodesResponse()",
            "                # _logger.info(\"sending unregister nodes response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.PublishRequest_Encoding_DefaultBinary):",
            "                _logger.debug(\"publish request (%s)\", user)",
            "                if not self.session:",
            "                    return False",
            "                params = struct_from_binary(ua.PublishParameters, body)",
            "                data = PublishRequestData(requesthdr=requesthdr, seqhdr=seqhdr)",
            "                # Store the Publish Request (will be used to send publish answers from server)",
            "                self._publish_requests.append(data)",
            "                # If there is an enqueued result forward it immediately",
            "                while self._publish_results:",
            "                    result = self._publish_results.popleft()",
            "                    if result.SubscriptionId not in self.session.subscription_service.active_subscription_ids:",
            "                        # Discard the result if the subscription is no longer active",
            "                        continue",
            "                    await self.forward_publish_response(result)",
            "                    break",
            "                self.session.publish(params.SubscriptionAcknowledgements)",
            "                # _logger.debug(\"publish forward to server\")",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.RepublishRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"re-publish request (%s)\", user)",
            "                params = struct_from_binary(ua.RepublishParameters, body)",
            "                msg = self.session.republish(params)",
            "                response = ua.RepublishResponse()",
            "                response.NotificationMessage = msg",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.CallRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"call request (%s)\", user)",
            "                params = struct_from_binary(ua.CallParameters, body)",
            "                results = await self.session.call(params.MethodsToCall)",
            "                response = ua.CallResponse()",
            "                response.Results = results",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.SetMonitoringModeRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"set monitoring mode request (%s)\", user)",
            "                params = struct_from_binary(ua.SetMonitoringModeParameters, body)",
            "                # FIXME: Implement SetMonitoringMode",
            "                # For now send dummy results to keep clients happy",
            "                response = ua.SetMonitoringModeResponse()",
            "                results = ua.SetMonitoringModeResult()",
            "                ids = params.MonitoredItemIds",
            "                statuses = [ua.StatusCode(ua.StatusCodes.Good) for node_id in ids]",
            "                results.Results = statuses",
            "                response.Parameters = results",
            "                _logger.info(\"sending set monitoring mode response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.SetPublishingModeRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"set publishing mode request (%s)\", user)",
            "                params = struct_from_binary(ua.SetPublishingModeParameters, body)",
            "                # FIXME: Implement SetPublishingMode",
            "                # For now send dummy results to keep clients happy",
            "                response = ua.SetPublishingModeResponse()",
            "                results = ua.SetPublishingModeResult()",
            "                ids = params.SubscriptionIds",
            "                statuses = [ua.StatusCode(ua.StatusCodes.Good) for node_id in ids]",
            "                results.Results = statuses",
            "                response.Parameters = results",
            "                _logger.info(\"sending set publishing mode response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            else:",
            "                _logger.warning(\"Unknown message received %s (%s)\", typeid, user)",
            "                raise ServiceError(ua.StatusCodes.BadServiceUnsupported)",
            "",
            "        return True",
            "",
            "    async def close(self):",
            "        \"\"\"",
            "        to be called when client has disconnected to ensure we really close",
            "        everything we should",
            "        \"\"\"",
            "        _logger.info(\"Cleanup client connection: %s\", self.name)",
            "        if self.session:",
            "            await self.session.close_session(True)"
        ],
        "afterPatchFile": [
            "import copy",
            "import time",
            "import logging",
            "from typing import Deque, Optional",
            "from collections import deque",
            "",
            "from asyncua import ua",
            "from ..ua.ua_binary import nodeid_from_binary, struct_from_binary, struct_to_binary, uatcp_to_binary",
            "from .internal_server import InternalServer, InternalSession",
            "from ..common.connection import SecureConnection, TransportLimits",
            "from ..common.utils import ServiceError",
            "",
            "_logger = logging.getLogger(__name__)",
            "",
            "",
            "class PublishRequestData:",
            "",
            "    def __init__(self, requesthdr=None, seqhdr=None):",
            "        self.requesthdr = requesthdr",
            "        self.seqhdr = seqhdr",
            "        self.timestamp = time.time()",
            "",
            "",
            "class UaProcessor:",
            "    \"\"\"",
            "    Processor for OPC UA messages. Implements the OPC UA protocol for the server side.",
            "    \"\"\"",
            "",
            "    def __init__(self, internal_server: InternalServer, transport, limits: TransportLimits):",
            "        self.iserver: InternalServer = internal_server",
            "        self.name = transport.get_extra_info('peername')",
            "        self.sockname = transport.get_extra_info('sockname')",
            "        self.session: Optional[InternalSession] = None",
            "        self._transport = transport",
            "        # deque for Publish Requests",
            "        self._publish_requests: Deque[PublishRequestData] = deque()",
            "        # used when we need to wait for PublishRequest",
            "        self._publish_results: Deque[ua.PublishResult] = deque()",
            "        self._limits = copy.deepcopy(limits)  # Copy limits because they get overriden",
            "        self._connection = SecureConnection(ua.SecurityPolicy(), self._limits)",
            "",
            "    def set_policies(self, policies):",
            "        self._connection.set_policy_factories(policies)",
            "",
            "    def send_response(self, requesthandle, seqhdr, response, msgtype=ua.MessageType.SecureMessage):",
            "        response.ResponseHeader.RequestHandle = requesthandle",
            "        data = self._connection.message_to_binary(",
            "            struct_to_binary(response), message_type=msgtype, request_id=seqhdr.RequestId)",
            "        self._transport.write(data)",
            "",
            "    def open_secure_channel(self, algohdr, seqhdr, body):",
            "        request = struct_from_binary(ua.OpenSecureChannelRequest, body)",
            "",
            "        if not self._connection.is_open():",
            "            # Only call select_policy if the channel isn't open. Otherwise",
            "            # it will break the Secure channel renewal.",
            "            self._connection.select_policy(",
            "                algohdr.SecurityPolicyURI, algohdr.SenderCertificate, request.Parameters.SecurityMode)",
            "",
            "        channel = self._connection.open(request.Parameters, self.iserver)",
            "        # send response",
            "        response = ua.OpenSecureChannelResponse()",
            "        response.Parameters = channel",
            "        self.send_response(request.RequestHeader.RequestHandle, seqhdr, response, ua.MessageType.SecureOpen)",
            "",
            "    async def forward_publish_response(self, result: ua.PublishResult):",
            "        \"\"\"",
            "        Try to send a `PublishResponse` with the given `PublishResult`.",
            "        \"\"\"",
            "        # _logger.info(\"forward publish response %s\", result)",
            "        while True:",
            "            if not self._publish_requests:",
            "                self._publish_results.append(result)",
            "                _logger.info(",
            "                    \"Server wants to send publish answer but no publish request is available,\"",
            "                    \"enqueuing notification, length of result queue is %s\",",
            "                    len(self._publish_results)",
            "                )",
            "                return",
            "            # We pop left from the Publish Request deque (FIFO)",
            "            requestdata = self._publish_requests.popleft()",
            "            if (requestdata.requesthdr.TimeoutHint == 0 or",
            "                    requestdata.requesthdr.TimeoutHint != 0 and",
            "                    time.time() - requestdata.timestamp < requestdata.requesthdr.TimeoutHint / 1000):",
            "                # Continue and use `requestdata` only if there was no timeout",
            "                break",
            "        response = ua.PublishResponse()",
            "        response.Parameters = result",
            "        self.send_response(requestdata.requesthdr.RequestHandle, requestdata.seqhdr, response)",
            "",
            "    async def process(self, header, body):",
            "        try:",
            "            msg = self._connection.receive_from_header_and_body(header, body)",
            "        except ua.uaerrors.BadRequestTooLarge as e:",
            "            _logger.warning(\"Recived request that exceed the transport limits\")",
            "            err = ua.ErrorMessage(ua.StatusCode(e.code), str(e))",
            "            data = uatcp_to_binary(ua.MessageType.Error, err)",
            "            self._transport.write(data)",
            "            return True",
            "        except ua.uaerrors.BadUserAccessDenied:",
            "            _logger.warning(\"Unauthenticated user attempted to connect\")",
            "            return False",
            "        if isinstance(msg, ua.Message):",
            "            if header.MessageType == ua.MessageType.SecureOpen:",
            "                self.open_secure_channel(msg.SecurityHeader(), msg.SequenceHeader(), msg.body())",
            "            elif header.MessageType == ua.MessageType.SecureClose:",
            "                self._connection.close()",
            "                return False",
            "            elif header.MessageType == ua.MessageType.SecureMessage:",
            "                return await self.process_message(msg.SequenceHeader(), msg.body())",
            "        elif isinstance(msg, ua.Hello):",
            "            ack = self._limits.create_acknowledge_limits(msg)",
            "            data = uatcp_to_binary(ua.MessageType.Acknowledge, ack)",
            "            self._transport.write(data)",
            "        elif isinstance(msg, ua.ErrorMessage):",
            "            _logger.warning(\"Received an error message type\")",
            "        elif msg is None:",
            "            pass  # msg is a ChunkType.Intermediate of an ua.MessageType.SecureMessage",
            "        else:",
            "            _logger.warning(\"Unsupported message type: %s\", header.MessageType)",
            "            raise ServiceError(ua.StatusCodes.BadTcpMessageTypeInvalid)",
            "        return True",
            "",
            "    async def process_message(self, seqhdr, body):",
            "        \"\"\"",
            "        Process incoming messages.",
            "        \"\"\"",
            "        typeid = nodeid_from_binary(body)",
            "        requesthdr = struct_from_binary(ua.RequestHeader, body)",
            "        _logger.debug('process_message %r %r', typeid, requesthdr)",
            "        try:",
            "            return await self._process_message(typeid, requesthdr, seqhdr, body)",
            "        except ServiceError as e:",
            "            status = ua.StatusCode(e.code)",
            "            response = ua.ServiceFault()",
            "            response.ResponseHeader.ServiceResult = status",
            "            _logger.error(\"sending service fault response: %s (%s)\", status.doc, status.name)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "            return True",
            "        except ua.uaerrors.BadUserAccessDenied:",
            "            if self.session:",
            "                user = self.session.user",
            "            else:",
            "                user = 'Someone'",
            "            _logger.warning(\"%s attempted to do something they are not permitted to do\", user)",
            "            response = ua.ServiceFault()",
            "            response.ResponseHeader.ServiceResult = ua.StatusCode(ua.StatusCodes.BadUserAccessDenied)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "        except Exception:",
            "            _logger.exception('Error while processing message')",
            "            response = ua.ServiceFault()",
            "            response.ResponseHeader.ServiceResult = ua.StatusCode(ua.StatusCodes.BadInternalError)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "            return True",
            "",
            "    async def _process_message(self, typeid, requesthdr, seqhdr, body):",
            "        if typeid in [ua.NodeId(ua.ObjectIds.CreateSessionRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.CloseSessionRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.ActivateSessionRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.FindServersRequest_Encoding_DefaultBinary),",
            "                      ua.NodeId(ua.ObjectIds.GetEndpointsRequest_Encoding_DefaultBinary)]:",
            "            # The connection is first created without a user being attached, and then during activation the",
            "            user = None",
            "        elif self.session is None:",
            "            _logger.warning(\"Received a request of type %d without an existing session\", typeid.Identifier)",
            "            raise ua.uaerrors.BadUserAccessDenied",
            "        else:",
            "            user = self.session.user",
            "            if self._connection.security_policy.permissions is not None:",
            "                if self._connection.security_policy.permissions.check_validity(user, typeid, body) is False:",
            "                    raise ua.uaerrors.BadUserAccessDenied",
            "",
            "        if typeid == ua.NodeId(ua.ObjectIds.CreateSessionRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"Create session request (%s)\", user)",
            "            params = struct_from_binary(ua.CreateSessionParameters, body)",
            "            # create the session on server",
            "            self.session = self.iserver.create_session(self.name, external=True)",
            "            # get a session creation result to send back",
            "            sessiondata = await self.session.create_session(params, sockname=self.sockname)",
            "            response = ua.CreateSessionResponse()",
            "            response.Parameters = sessiondata",
            "            response.Parameters.ServerCertificate = self._connection.security_policy.host_certificate",
            "            if self._connection.security_policy.peer_certificate is None:",
            "                data = params.ClientNonce",
            "            else:",
            "                data = self._connection.security_policy.peer_certificate + params.ClientNonce",
            "            response.Parameters.ServerSignature.Signature = \\",
            "                self._connection.security_policy.asymmetric_cryptography.signature(data)",
            "            response.Parameters.ServerSignature.Algorithm = self._connection.security_policy.AsymmetricSignatureURI",
            "            # _logger.info(\"sending create session response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.CloseSessionRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"Close session request (%s)\", user)",
            "            if self.session:",
            "                deletesubs = ua.ua_binary.Primitives.Boolean.unpack(body)",
            "                await self.session.close_session(deletesubs)",
            "            else:",
            "                _logger.info(\"Request to close non-existing session (%s)\", user)",
            "",
            "            response = ua.CloseSessionResponse()",
            "            _logger.info(\"sending close session response (%s)\", user)",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.ActivateSessionRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"Activate session request (%s)\", user)",
            "            params = struct_from_binary(ua.ActivateSessionParameters, body)",
            "            if not self.session:",
            "                _logger.info(\"request to activate non-existing session (%s)\", user)",
            "                raise ServiceError(ua.StatusCodes.BadSessionIdInvalid)",
            "            if self._connection.security_policy.host_certificate is None:",
            "                data = self.session.nonce",
            "            else:",
            "                data = self._connection.security_policy.host_certificate + self.session.nonce",
            "            self._connection.security_policy.asymmetric_cryptography.verify(data, params.ClientSignature.Signature)",
            "            result = self.session.activate_session(params, self._connection.security_policy.peer_certificate)",
            "            response = ua.ActivateSessionResponse()",
            "            response.Parameters = result",
            "            # _logger.info(\"sending read response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "        elif typeid == ua.NodeId(ua.ObjectIds.GetEndpointsRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"get endpoints request (%s)\", user)",
            "            params = struct_from_binary(ua.GetEndpointsParameters, body)",
            "            endpoints = await self.iserver.get_endpoints(params, sockname=self.sockname)",
            "            response = ua.GetEndpointsResponse()",
            "            response.Endpoints = endpoints",
            "            # _logger.info(\"sending get endpoints response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.FindServersRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"find servers request (%s)\", user)",
            "            params = struct_from_binary(ua.FindServersParameters, body)",
            "            servers = self.iserver.find_servers(params)",
            "            response = ua.FindServersResponse()",
            "            response.Servers = servers",
            "            # _logger.info(\"sending find servers response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.RegisterServerRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"register server request %s\", user)",
            "            serv = struct_from_binary(ua.RegisteredServer, body)",
            "            self.iserver.register_server(serv)",
            "            response = ua.RegisterServerResponse()",
            "            # _logger.info(\"sending register server response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "        elif typeid == ua.NodeId(ua.ObjectIds.RegisterServer2Request_Encoding_DefaultBinary):",
            "            _logger.info(\"register server 2 request %s\", user)",
            "            params = struct_from_binary(ua.RegisterServer2Parameters, body)",
            "            results = self.iserver.register_server2(params)",
            "            response = ua.RegisterServer2Response()",
            "            response.ConfigurationResults = results",
            "            # _logger.info(\"sending register server 2 response\")",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "        elif typeid == ua.NodeId(ua.ObjectIds.CloseSecureChannelRequest_Encoding_DefaultBinary):",
            "            _logger.info(\"close secure channel request (%s)\", user)",
            "            self._connection.close()",
            "            response = ua.CloseSecureChannelResponse()",
            "            self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "            return False",
            "        else:",
            "            # All services that requere a active session",
            "            if not self.session:",
            "                _logger.info(\"Request service that need a session (%s)\", user)",
            "                raise ServiceError(ua.StatusCodes.BadSessionIdInvalid)",
            "            if not self.session.is_activated():",
            "                _logger.info(\"Request service that needs a activated session (%s)\", user)",
            "                raise ServiceError(ua.StatusCodes.BadSessionNotActivated)",
            "",
            "            if typeid == ua.NodeId(ua.ObjectIds.ReadRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"Read request (%s)\", user)",
            "                params = struct_from_binary(ua.ReadParameters, body)",
            "                results = await self.session.read(params)",
            "                response = ua.ReadResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending read response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.WriteRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"Write request (%s)\", user)",
            "                params = struct_from_binary(ua.WriteParameters, body)",
            "                results = await self.session.write(params)",
            "                response = ua.WriteResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending write response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.BrowseRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"Browse request (%s)\", user)",
            "                params = struct_from_binary(ua.BrowseParameters, body)",
            "                results = await self.session.browse(params)",
            "                response = ua.BrowseResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending browse response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.TranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"translate browsepaths to nodeids request (%s)\", user)",
            "                params = struct_from_binary(ua.TranslateBrowsePathsToNodeIdsParameters, body)",
            "                paths = await self.session.translate_browsepaths_to_nodeids(params.BrowsePaths)",
            "                response = ua.TranslateBrowsePathsToNodeIdsResponse()",
            "                response.Results = paths",
            "                # _logger.info(\"sending translate browsepaths to nodeids response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.AddNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"add nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.AddNodesParameters, body)",
            "                results = await self.session.add_nodes(params.NodesToAdd)",
            "                response = ua.AddNodesResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending add node response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteNodesParameters, body)",
            "                results = await self.session.delete_nodes(params)",
            "                response = ua.DeleteNodesResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending delete node response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.AddReferencesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"add references request (%s)\", user)",
            "                params = struct_from_binary(ua.AddReferencesParameters, body)",
            "                results = await self.session.add_references(params.ReferencesToAdd)",
            "                response = ua.AddReferencesResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending add references response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteReferencesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete references request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteReferencesParameters, body)",
            "                results = await self.session.delete_references(params.ReferencesToDelete)",
            "                response = ua.DeleteReferencesResponse()",
            "                response.Parameters.Results = results",
            "                # _logger.info(\"sending delete references response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.CreateSubscriptionRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"create subscription request (%s)\", user)",
            "                params = struct_from_binary(ua.CreateSubscriptionParameters, body)",
            "                result = await self.session.create_subscription(params, callback=self.forward_publish_response)",
            "                response = ua.CreateSubscriptionResponse()",
            "                response.Parameters = result",
            "                # _logger.info(\"sending create subscription response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.ModifySubscriptionRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"modify subscription request\")",
            "                params = struct_from_binary(ua.ModifySubscriptionParameters, body)",
            "",
            "                result = self.session.modify_subscription(params, self.forward_publish_response)",
            "",
            "                response = ua.ModifySubscriptionResponse()",
            "                response.Parameters = result",
            "",
            "                #_logger.info(\"sending modify subscription response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteSubscriptionsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete subscriptions request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteSubscriptionsParameters, body)",
            "                results = await self.session.delete_subscriptions(params.SubscriptionIds)",
            "                response = ua.DeleteSubscriptionsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending delete subscription response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.CreateMonitoredItemsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"create monitored items request (%s)\", user)",
            "                params = struct_from_binary(ua.CreateMonitoredItemsParameters, body)",
            "                results = await self.session.create_monitored_items(params)",
            "                response = ua.CreateMonitoredItemsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending create monitored items response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.ModifyMonitoredItemsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"modify monitored items request (%s)\", user)",
            "                params = struct_from_binary(ua.ModifyMonitoredItemsParameters, body)",
            "                results = await self.session.modify_monitored_items(params)",
            "                response = ua.ModifyMonitoredItemsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending modify monitored items response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.DeleteMonitoredItemsRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"delete monitored items request (%s)\", user)",
            "                params = struct_from_binary(ua.DeleteMonitoredItemsParameters, body)",
            "                results = await self.session.delete_monitored_items(params)",
            "                response = ua.DeleteMonitoredItemsResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending delete monitored items response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.HistoryReadRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"history read request (%s)\", user)",
            "                params = struct_from_binary(ua.HistoryReadParameters, body)",
            "                results = await self.session.history_read(params)",
            "                response = ua.HistoryReadResponse()",
            "                response.Results = results",
            "                # _logger.info(\"sending history read response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.RegisterNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"register nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.RegisterNodesParameters, body)",
            "                _logger.info(\"Node registration not implemented\")",
            "                response = ua.RegisterNodesResponse()",
            "                response.Parameters.RegisteredNodeIds = params.NodesToRegister",
            "                # _logger.info(\"sending register nodes response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.UnregisterNodesRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"unregister nodes request (%s)\", user)",
            "                params = struct_from_binary(ua.UnregisterNodesParameters, body)",
            "                response = ua.UnregisterNodesResponse()",
            "                # _logger.info(\"sending unregister nodes response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.PublishRequest_Encoding_DefaultBinary):",
            "                _logger.debug(\"publish request (%s)\", user)",
            "                if not self.session:",
            "                    return False",
            "                params = struct_from_binary(ua.PublishParameters, body)",
            "                data = PublishRequestData(requesthdr=requesthdr, seqhdr=seqhdr)",
            "                # Store the Publish Request (will be used to send publish answers from server)",
            "                self._publish_requests.append(data)",
            "                # If there is an enqueued result forward it immediately",
            "                while self._publish_results:",
            "                    result = self._publish_results.popleft()",
            "                    if result.SubscriptionId not in self.session.subscription_service.active_subscription_ids:",
            "                        # Discard the result if the subscription is no longer active",
            "                        continue",
            "                    await self.forward_publish_response(result)",
            "                    break",
            "                self.session.publish(params.SubscriptionAcknowledgements)",
            "                # _logger.debug(\"publish forward to server\")",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.RepublishRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"re-publish request (%s)\", user)",
            "                params = struct_from_binary(ua.RepublishParameters, body)",
            "                msg = self.session.republish(params)",
            "                response = ua.RepublishResponse()",
            "                response.NotificationMessage = msg",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.CallRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"call request (%s)\", user)",
            "                params = struct_from_binary(ua.CallParameters, body)",
            "                results = await self.session.call(params.MethodsToCall)",
            "                response = ua.CallResponse()",
            "                response.Results = results",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.SetMonitoringModeRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"set monitoring mode request (%s)\", user)",
            "                params = struct_from_binary(ua.SetMonitoringModeParameters, body)",
            "                # FIXME: Implement SetMonitoringMode",
            "                # For now send dummy results to keep clients happy",
            "                response = ua.SetMonitoringModeResponse()",
            "                results = ua.SetMonitoringModeResult()",
            "                ids = params.MonitoredItemIds",
            "                statuses = [ua.StatusCode(ua.StatusCodes.Good) for node_id in ids]",
            "                results.Results = statuses",
            "                response.Parameters = results",
            "                _logger.info(\"sending set monitoring mode response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            elif typeid == ua.NodeId(ua.ObjectIds.SetPublishingModeRequest_Encoding_DefaultBinary):",
            "                _logger.info(\"set publishing mode request (%s)\", user)",
            "                params = struct_from_binary(ua.SetPublishingModeParameters, body)",
            "                # FIXME: Implement SetPublishingMode",
            "                # For now send dummy results to keep clients happy",
            "                response = ua.SetPublishingModeResponse()",
            "                results = ua.SetPublishingModeResult()",
            "                ids = params.SubscriptionIds",
            "                statuses = [ua.StatusCode(ua.StatusCodes.Good) for node_id in ids]",
            "                results.Results = statuses",
            "                response.Parameters = results",
            "                _logger.info(\"sending set publishing mode response\")",
            "                self.send_response(requesthdr.RequestHandle, seqhdr, response)",
            "",
            "            else:",
            "                _logger.warning(\"Unknown message received %s (%s)\", typeid, user)",
            "                raise ServiceError(ua.StatusCodes.BadServiceUnsupported)",
            "",
            "        return True",
            "",
            "    async def close(self):",
            "        \"\"\"",
            "        to be called when client has disconnected to ensure we really close",
            "        everything we should",
            "        \"\"\"",
            "        _logger.info(\"Cleanup client connection: %s\", self.name)",
            "        if self.session:",
            "            await self.session.close_session(True)"
        ],
        "action": [
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "9": [],
            "28": [
                "UaProcessor",
                "__init__"
            ],
            "38": [
                "UaProcessor",
                "__init__"
            ],
            "104": [
                "UaProcessor"
            ],
            "105": [
                "UaProcessor"
            ],
            "106": [
                "UaProcessor"
            ]
        },
        "addLocation": []
    }
}