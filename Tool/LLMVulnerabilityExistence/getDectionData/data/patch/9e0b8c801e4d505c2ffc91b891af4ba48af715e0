{
    "src/waitress/parser.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from waitress.buffers import OverflowableBuffer"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from waitress.receiver import ChunkedReceiver, FixedStreamReceiver"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from waitress.rfc7230 import HEADER_FIELD_RE, ONLY_DIGIT_RE"
            },
            "4": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from waitress.utilities import ("
            },
            "5": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     BadRequest,"
            },
            "6": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     RequestEntityTooLarge,"
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     find_double_newline,"
            },
            "8": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " )"
            },
            "9": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .rfc7230 import HEADER_FIELD"
            },
            "11": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "12": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " def unquote_bytes_to_wsgi(bytestring):"
            },
            "14": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     return unquote_to_bytes(bytestring).decode(\"latin-1\")"
            },
            "15": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         headers = self.headers"
            },
            "16": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 221,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         for line in lines:"
            },
            "18": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            header = HEADER_FIELD.match(line)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            header = HEADER_FIELD_RE.match(line)"
            },
            "20": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 224,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             if not header:"
            },
            "22": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "                 raise ParsingError(\"Invalid header\")"
            },
            "23": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 316,
                "PatchRowcode": "                 self.connection_close = True"
            },
            "24": {
                "beforePatchRowNumber": 318,
                "afterPatchRowNumber": 317,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 319,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "         if not self.chunked:"
            },
            "26": {
                "beforePatchRowNumber": 320,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            try:"
            },
            "27": {
                "beforePatchRowNumber": 321,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cl = int(headers.get(\"CONTENT_LENGTH\", 0))"
            },
            "28": {
                "beforePatchRowNumber": 322,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except ValueError:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+            cl = headers.get(\"CONTENT_LENGTH\", \"0\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+            if not ONLY_DIGIT_RE.match(cl.encode(\"latin-1\")):"
            },
            "32": {
                "beforePatchRowNumber": 323,
                "afterPatchRowNumber": 322,
                "PatchRowcode": "                 raise ParsingError(\"Content-Length is invalid\")"
            },
            "33": {
                "beforePatchRowNumber": 324,
                "afterPatchRowNumber": 323,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+            cl = int(cl)"
            },
            "35": {
                "beforePatchRowNumber": 325,
                "afterPatchRowNumber": 325,
                "PatchRowcode": "             self.content_length = cl"
            },
            "36": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 326,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 327,
                "PatchRowcode": "             if cl > 0:"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"HTTP Request Parser",
            "",
            "This server uses asyncore to accept connections and do initial",
            "processing but threads to do work.",
            "\"\"\"",
            "from io import BytesIO",
            "import re",
            "from urllib import parse",
            "from urllib.parse import unquote_to_bytes",
            "",
            "from waitress.buffers import OverflowableBuffer",
            "from waitress.receiver import ChunkedReceiver, FixedStreamReceiver",
            "from waitress.utilities import (",
            "    BadRequest,",
            "    RequestEntityTooLarge,",
            "    RequestHeaderFieldsTooLarge,",
            "    ServerNotImplemented,",
            "    find_double_newline,",
            ")",
            "",
            "from .rfc7230 import HEADER_FIELD",
            "",
            "",
            "def unquote_bytes_to_wsgi(bytestring):",
            "    return unquote_to_bytes(bytestring).decode(\"latin-1\")",
            "",
            "",
            "class ParsingError(Exception):",
            "    pass",
            "",
            "",
            "class TransferEncodingNotImplemented(Exception):",
            "    pass",
            "",
            "",
            "class HTTPRequestParser:",
            "    \"\"\"A structure that collects the HTTP request.",
            "",
            "    Once the stream is completed, the instance is passed to",
            "    a server task constructor.",
            "    \"\"\"",
            "",
            "    completed = False  # Set once request is completed.",
            "    empty = False  # Set if no request was made.",
            "    expect_continue = False  # client sent \"Expect: 100-continue\" header",
            "    headers_finished = False  # True when headers have been read",
            "    header_plus = b\"\"",
            "    chunked = False",
            "    content_length = 0",
            "    header_bytes_received = 0",
            "    body_bytes_received = 0",
            "    body_rcv = None",
            "    version = \"1.0\"",
            "    error = None",
            "    connection_close = False",
            "",
            "    # Other attributes: first_line, header, headers, command, uri, version,",
            "    # path, query, fragment",
            "",
            "    def __init__(self, adj):",
            "        \"\"\"",
            "        adj is an Adjustments object.",
            "        \"\"\"",
            "        # headers is a mapping containing keys translated to uppercase",
            "        # with dashes turned into underscores.",
            "        self.headers = {}",
            "        self.adj = adj",
            "",
            "    def received(self, data):",
            "        \"\"\"",
            "        Receives the HTTP stream for one request.  Returns the number of",
            "        bytes consumed.  Sets the completed flag once both the header and the",
            "        body have been received.",
            "        \"\"\"",
            "",
            "        if self.completed:",
            "            return 0  # Can't consume any more.",
            "",
            "        datalen = len(data)",
            "        br = self.body_rcv",
            "",
            "        if br is None:",
            "            # In header.",
            "            max_header = self.adj.max_request_header_size",
            "",
            "            s = self.header_plus + data",
            "            index = find_double_newline(s)",
            "            consumed = 0",
            "",
            "            if index >= 0:",
            "                # If the headers have ended, and we also have part of the body",
            "                # message in data we still want to validate we aren't going",
            "                # over our limit for received headers.",
            "                self.header_bytes_received += index",
            "                consumed = datalen - (len(s) - index)",
            "            else:",
            "                self.header_bytes_received += datalen",
            "                consumed = datalen",
            "",
            "            # If the first line + headers is over the max length, we return a",
            "            # RequestHeaderFieldsTooLarge error rather than continuing to",
            "            # attempt to parse the headers.",
            "",
            "            if self.header_bytes_received >= max_header:",
            "                self.parse_header(b\"GET / HTTP/1.0\\r\\n\")",
            "                self.error = RequestHeaderFieldsTooLarge(",
            "                    \"exceeds max_header of %s\" % max_header",
            "                )",
            "                self.completed = True",
            "",
            "                return consumed",
            "",
            "            if index >= 0:",
            "                # Header finished.",
            "                header_plus = s[:index]",
            "",
            "                # Remove preceeding blank lines. This is suggested by",
            "                # https://tools.ietf.org/html/rfc7230#section-3.5 to support",
            "                # clients sending an extra CR LF after another request when",
            "                # using HTTP pipelining",
            "                header_plus = header_plus.lstrip()",
            "",
            "                if not header_plus:",
            "                    self.empty = True",
            "                    self.completed = True",
            "                else:",
            "                    try:",
            "                        self.parse_header(header_plus)",
            "                    except ParsingError as e:",
            "                        self.error = BadRequest(e.args[0])",
            "                        self.completed = True",
            "                    except TransferEncodingNotImplemented as e:",
            "                        self.error = ServerNotImplemented(e.args[0])",
            "                        self.completed = True",
            "                    else:",
            "                        if self.body_rcv is None:",
            "                            # no content-length header and not a t-e: chunked",
            "                            # request",
            "                            self.completed = True",
            "",
            "                        if self.content_length > 0:",
            "                            max_body = self.adj.max_request_body_size",
            "                            # we won't accept this request if the content-length",
            "                            # is too large",
            "",
            "                            if self.content_length >= max_body:",
            "                                self.error = RequestEntityTooLarge(",
            "                                    \"exceeds max_body of %s\" % max_body",
            "                                )",
            "                                self.completed = True",
            "                self.headers_finished = True",
            "",
            "                return consumed",
            "",
            "            # Header not finished yet.",
            "            self.header_plus = s",
            "",
            "            return datalen",
            "        else:",
            "            # In body.",
            "            consumed = br.received(data)",
            "            self.body_bytes_received += consumed",
            "            max_body = self.adj.max_request_body_size",
            "",
            "            if self.body_bytes_received >= max_body:",
            "                # this will only be raised during t-e: chunked requests",
            "                self.error = RequestEntityTooLarge(\"exceeds max_body of %s\" % max_body)",
            "                self.completed = True",
            "            elif br.error:",
            "                # garbage in chunked encoding input probably",
            "                self.error = br.error",
            "                self.completed = True",
            "            elif br.completed:",
            "                # The request (with the body) is ready to use.",
            "                self.completed = True",
            "",
            "                if self.chunked:",
            "                    # We've converted the chunked transfer encoding request",
            "                    # body into a normal request body, so we know its content",
            "                    # length; set the header here.  We already popped the",
            "                    # TRANSFER_ENCODING header in parse_header, so this will",
            "                    # appear to the client to be an entirely non-chunked HTTP",
            "                    # request with a valid content-length.",
            "                    self.headers[\"CONTENT_LENGTH\"] = str(br.__len__())",
            "",
            "            return consumed",
            "",
            "    def parse_header(self, header_plus):",
            "        \"\"\"",
            "        Parses the header_plus block of text (the headers plus the",
            "        first line of the request).",
            "        \"\"\"",
            "        index = header_plus.find(b\"\\r\\n\")",
            "",
            "        if index >= 0:",
            "            first_line = header_plus[:index].rstrip()",
            "            header = header_plus[index + 2 :]",
            "        else:",
            "            raise ParsingError(\"HTTP message header invalid\")",
            "",
            "        if b\"\\r\" in first_line or b\"\\n\" in first_line:",
            "            raise ParsingError(\"Bare CR or LF found in HTTP message\")",
            "",
            "        self.first_line = first_line  # for testing",
            "",
            "        lines = get_header_lines(header)",
            "",
            "        headers = self.headers",
            "",
            "        for line in lines:",
            "            header = HEADER_FIELD.match(line)",
            "",
            "            if not header:",
            "                raise ParsingError(\"Invalid header\")",
            "",
            "            key, value = header.group(\"name\", \"value\")",
            "",
            "            if b\"_\" in key:",
            "                # TODO(xistence): Should we drop this request instead?",
            "",
            "                continue",
            "",
            "            # Only strip off whitespace that is considered valid whitespace by",
            "            # RFC7230, don't strip the rest",
            "            value = value.strip(b\" \\t\")",
            "            key1 = key.upper().replace(b\"-\", b\"_\").decode(\"latin-1\")",
            "            # If a header already exists, we append subsequent values",
            "            # separated by a comma. Applications already need to handle",
            "            # the comma separated values, as HTTP front ends might do",
            "            # the concatenation for you (behavior specified in RFC2616).",
            "            try:",
            "                headers[key1] += (b\", \" + value).decode(\"latin-1\")",
            "            except KeyError:",
            "                headers[key1] = value.decode(\"latin-1\")",
            "",
            "        # command, uri, version will be bytes",
            "        command, uri, version = crack_first_line(first_line)",
            "        # self.request_uri is like nginx's request_uri:",
            "        # \"full original request URI (with arguments)\"",
            "        self.request_uri = uri.decode(\"latin-1\")",
            "        version = version.decode(\"latin-1\")",
            "        command = command.decode(\"latin-1\")",
            "        self.command = command",
            "        self.version = version",
            "        (",
            "            self.proxy_scheme,",
            "            self.proxy_netloc,",
            "            self.path,",
            "            self.query,",
            "            self.fragment,",
            "        ) = split_uri(uri)",
            "        self.url_scheme = self.adj.url_scheme",
            "        connection = headers.get(\"CONNECTION\", \"\")",
            "",
            "        if version == \"1.0\":",
            "            if connection.lower() != \"keep-alive\":",
            "                self.connection_close = True",
            "",
            "        if version == \"1.1\":",
            "            # since the server buffers data from chunked transfers and clients",
            "            # never need to deal with chunked requests, downstream clients",
            "            # should not see the HTTP_TRANSFER_ENCODING header; we pop it",
            "            # here",
            "            te = headers.pop(\"TRANSFER_ENCODING\", \"\")",
            "",
            "            # NB: We can not just call bare strip() here because it will also",
            "            # remove other non-printable characters that we explicitly do not",
            "            # want removed so that if someone attempts to smuggle a request",
            "            # with these characters we don't fall prey to it.",
            "            #",
            "            # For example \\x85 is stripped by default, but it is not considered",
            "            # valid whitespace to be stripped by RFC7230.",
            "            encodings = [",
            "                encoding.strip(\" \\t\").lower() for encoding in te.split(\",\") if encoding",
            "            ]",
            "",
            "            for encoding in encodings:",
            "                # Out of the transfer-codings listed in",
            "                # https://tools.ietf.org/html/rfc7230#section-4 we only support",
            "                # chunked at this time.",
            "",
            "                # Note: the identity transfer-coding was removed in RFC7230:",
            "                # https://tools.ietf.org/html/rfc7230#appendix-A.2 and is thus",
            "                # not supported",
            "",
            "                if encoding not in {\"chunked\"}:",
            "                    raise TransferEncodingNotImplemented(",
            "                        \"Transfer-Encoding requested is not supported.\"",
            "                    )",
            "",
            "            if encodings and encodings[-1] == \"chunked\":",
            "                self.chunked = True",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = ChunkedReceiver(buf)",
            "            elif encodings:  # pragma: nocover",
            "                raise TransferEncodingNotImplemented(",
            "                    \"Transfer-Encoding requested is not supported.\"",
            "                )",
            "",
            "            expect = headers.get(\"EXPECT\", \"\").lower()",
            "            self.expect_continue = expect == \"100-continue\"",
            "",
            "            if connection.lower() == \"close\":",
            "                self.connection_close = True",
            "",
            "        if not self.chunked:",
            "            try:",
            "                cl = int(headers.get(\"CONTENT_LENGTH\", 0))",
            "            except ValueError:",
            "                raise ParsingError(\"Content-Length is invalid\")",
            "",
            "            self.content_length = cl",
            "",
            "            if cl > 0:",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = FixedStreamReceiver(cl, buf)",
            "",
            "    def get_body_stream(self):",
            "        body_rcv = self.body_rcv",
            "",
            "        if body_rcv is not None:",
            "            return body_rcv.getfile()",
            "        else:",
            "            return BytesIO()",
            "",
            "    def close(self):",
            "        body_rcv = self.body_rcv",
            "",
            "        if body_rcv is not None:",
            "            body_rcv.getbuf().close()",
            "",
            "",
            "def split_uri(uri):",
            "    # urlsplit handles byte input by returning bytes on py3, so",
            "    # scheme, netloc, path, query, and fragment are bytes",
            "",
            "    scheme = netloc = path = query = fragment = b\"\"",
            "",
            "    # urlsplit below will treat this as a scheme-less netloc, thereby losing",
            "    # the original intent of the request. Here we shamelessly stole 4 lines of",
            "    # code from the CPython stdlib to parse out the fragment and query but",
            "    # leave the path alone. See",
            "    # https://github.com/python/cpython/blob/8c9e9b0cd5b24dfbf1424d1f253d02de80e8f5ef/Lib/urllib/parse.py#L465-L468",
            "    # and https://github.com/Pylons/waitress/issues/260",
            "",
            "    if uri[:2] == b\"//\":",
            "        path = uri",
            "",
            "        if b\"#\" in path:",
            "            path, fragment = path.split(b\"#\", 1)",
            "",
            "        if b\"?\" in path:",
            "            path, query = path.split(b\"?\", 1)",
            "    else:",
            "        try:",
            "            scheme, netloc, path, query, fragment = parse.urlsplit(uri)",
            "        except UnicodeError:",
            "            raise ParsingError(\"Bad URI\")",
            "",
            "    return (",
            "        scheme.decode(\"latin-1\"),",
            "        netloc.decode(\"latin-1\"),",
            "        unquote_bytes_to_wsgi(path),",
            "        query.decode(\"latin-1\"),",
            "        fragment.decode(\"latin-1\"),",
            "    )",
            "",
            "",
            "def get_header_lines(header):",
            "    \"\"\"",
            "    Splits the header into lines, putting multi-line headers together.",
            "    \"\"\"",
            "    r = []",
            "    lines = header.split(b\"\\r\\n\")",
            "",
            "    for line in lines:",
            "        if not line:",
            "            continue",
            "",
            "        if b\"\\r\" in line or b\"\\n\" in line:",
            "            raise ParsingError(",
            "                'Bare CR or LF found in header line \"%s\"' % str(line, \"latin-1\")",
            "            )",
            "",
            "        if line.startswith((b\" \", b\"\\t\")):",
            "            if not r:",
            "                # https://corte.si/posts/code/pathod/pythonservers/index.html",
            "                raise ParsingError('Malformed header line \"%s\"' % str(line, \"latin-1\"))",
            "            r[-1] += line",
            "        else:",
            "            r.append(line)",
            "",
            "    return r",
            "",
            "",
            "first_line_re = re.compile(",
            "    b\"([^ ]+) \"",
            "    b\"((?:[^ :?#]+://[^ ?#/]*(?:[0-9]{1,5})?)?[^ ]+)\"",
            "    b\"(( HTTP/([0-9.]+))$|$)\"",
            ")",
            "",
            "",
            "def crack_first_line(line):",
            "    m = first_line_re.match(line)",
            "",
            "    if m is not None and m.end() == len(line):",
            "        if m.group(3):",
            "            version = m.group(5)",
            "        else:",
            "            version = b\"\"",
            "        method = m.group(1)",
            "",
            "        # the request methods that are currently defined are all uppercase:",
            "        # https://www.iana.org/assignments/http-methods/http-methods.xhtml and",
            "        # the request method is case sensitive according to",
            "        # https://tools.ietf.org/html/rfc7231#section-4.1",
            "",
            "        # By disallowing anything but uppercase methods we save poor",
            "        # unsuspecting souls from sending lowercase HTTP methods to waitress",
            "        # and having the request complete, while servers like nginx drop the",
            "        # request onto the floor.",
            "",
            "        if method != method.upper():",
            "            raise ParsingError('Malformed HTTP method \"%s\"' % str(method, \"latin-1\"))",
            "        uri = m.group(2)",
            "",
            "        return method, uri, version",
            "    else:",
            "        return b\"\", b\"\", b\"\""
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"HTTP Request Parser",
            "",
            "This server uses asyncore to accept connections and do initial",
            "processing but threads to do work.",
            "\"\"\"",
            "from io import BytesIO",
            "import re",
            "from urllib import parse",
            "from urllib.parse import unquote_to_bytes",
            "",
            "from waitress.buffers import OverflowableBuffer",
            "from waitress.receiver import ChunkedReceiver, FixedStreamReceiver",
            "from waitress.rfc7230 import HEADER_FIELD_RE, ONLY_DIGIT_RE",
            "from waitress.utilities import (",
            "    BadRequest,",
            "    RequestEntityTooLarge,",
            "    RequestHeaderFieldsTooLarge,",
            "    ServerNotImplemented,",
            "    find_double_newline,",
            ")",
            "",
            "",
            "def unquote_bytes_to_wsgi(bytestring):",
            "    return unquote_to_bytes(bytestring).decode(\"latin-1\")",
            "",
            "",
            "class ParsingError(Exception):",
            "    pass",
            "",
            "",
            "class TransferEncodingNotImplemented(Exception):",
            "    pass",
            "",
            "",
            "class HTTPRequestParser:",
            "    \"\"\"A structure that collects the HTTP request.",
            "",
            "    Once the stream is completed, the instance is passed to",
            "    a server task constructor.",
            "    \"\"\"",
            "",
            "    completed = False  # Set once request is completed.",
            "    empty = False  # Set if no request was made.",
            "    expect_continue = False  # client sent \"Expect: 100-continue\" header",
            "    headers_finished = False  # True when headers have been read",
            "    header_plus = b\"\"",
            "    chunked = False",
            "    content_length = 0",
            "    header_bytes_received = 0",
            "    body_bytes_received = 0",
            "    body_rcv = None",
            "    version = \"1.0\"",
            "    error = None",
            "    connection_close = False",
            "",
            "    # Other attributes: first_line, header, headers, command, uri, version,",
            "    # path, query, fragment",
            "",
            "    def __init__(self, adj):",
            "        \"\"\"",
            "        adj is an Adjustments object.",
            "        \"\"\"",
            "        # headers is a mapping containing keys translated to uppercase",
            "        # with dashes turned into underscores.",
            "        self.headers = {}",
            "        self.adj = adj",
            "",
            "    def received(self, data):",
            "        \"\"\"",
            "        Receives the HTTP stream for one request.  Returns the number of",
            "        bytes consumed.  Sets the completed flag once both the header and the",
            "        body have been received.",
            "        \"\"\"",
            "",
            "        if self.completed:",
            "            return 0  # Can't consume any more.",
            "",
            "        datalen = len(data)",
            "        br = self.body_rcv",
            "",
            "        if br is None:",
            "            # In header.",
            "            max_header = self.adj.max_request_header_size",
            "",
            "            s = self.header_plus + data",
            "            index = find_double_newline(s)",
            "            consumed = 0",
            "",
            "            if index >= 0:",
            "                # If the headers have ended, and we also have part of the body",
            "                # message in data we still want to validate we aren't going",
            "                # over our limit for received headers.",
            "                self.header_bytes_received += index",
            "                consumed = datalen - (len(s) - index)",
            "            else:",
            "                self.header_bytes_received += datalen",
            "                consumed = datalen",
            "",
            "            # If the first line + headers is over the max length, we return a",
            "            # RequestHeaderFieldsTooLarge error rather than continuing to",
            "            # attempt to parse the headers.",
            "",
            "            if self.header_bytes_received >= max_header:",
            "                self.parse_header(b\"GET / HTTP/1.0\\r\\n\")",
            "                self.error = RequestHeaderFieldsTooLarge(",
            "                    \"exceeds max_header of %s\" % max_header",
            "                )",
            "                self.completed = True",
            "",
            "                return consumed",
            "",
            "            if index >= 0:",
            "                # Header finished.",
            "                header_plus = s[:index]",
            "",
            "                # Remove preceeding blank lines. This is suggested by",
            "                # https://tools.ietf.org/html/rfc7230#section-3.5 to support",
            "                # clients sending an extra CR LF after another request when",
            "                # using HTTP pipelining",
            "                header_plus = header_plus.lstrip()",
            "",
            "                if not header_plus:",
            "                    self.empty = True",
            "                    self.completed = True",
            "                else:",
            "                    try:",
            "                        self.parse_header(header_plus)",
            "                    except ParsingError as e:",
            "                        self.error = BadRequest(e.args[0])",
            "                        self.completed = True",
            "                    except TransferEncodingNotImplemented as e:",
            "                        self.error = ServerNotImplemented(e.args[0])",
            "                        self.completed = True",
            "                    else:",
            "                        if self.body_rcv is None:",
            "                            # no content-length header and not a t-e: chunked",
            "                            # request",
            "                            self.completed = True",
            "",
            "                        if self.content_length > 0:",
            "                            max_body = self.adj.max_request_body_size",
            "                            # we won't accept this request if the content-length",
            "                            # is too large",
            "",
            "                            if self.content_length >= max_body:",
            "                                self.error = RequestEntityTooLarge(",
            "                                    \"exceeds max_body of %s\" % max_body",
            "                                )",
            "                                self.completed = True",
            "                self.headers_finished = True",
            "",
            "                return consumed",
            "",
            "            # Header not finished yet.",
            "            self.header_plus = s",
            "",
            "            return datalen",
            "        else:",
            "            # In body.",
            "            consumed = br.received(data)",
            "            self.body_bytes_received += consumed",
            "            max_body = self.adj.max_request_body_size",
            "",
            "            if self.body_bytes_received >= max_body:",
            "                # this will only be raised during t-e: chunked requests",
            "                self.error = RequestEntityTooLarge(\"exceeds max_body of %s\" % max_body)",
            "                self.completed = True",
            "            elif br.error:",
            "                # garbage in chunked encoding input probably",
            "                self.error = br.error",
            "                self.completed = True",
            "            elif br.completed:",
            "                # The request (with the body) is ready to use.",
            "                self.completed = True",
            "",
            "                if self.chunked:",
            "                    # We've converted the chunked transfer encoding request",
            "                    # body into a normal request body, so we know its content",
            "                    # length; set the header here.  We already popped the",
            "                    # TRANSFER_ENCODING header in parse_header, so this will",
            "                    # appear to the client to be an entirely non-chunked HTTP",
            "                    # request with a valid content-length.",
            "                    self.headers[\"CONTENT_LENGTH\"] = str(br.__len__())",
            "",
            "            return consumed",
            "",
            "    def parse_header(self, header_plus):",
            "        \"\"\"",
            "        Parses the header_plus block of text (the headers plus the",
            "        first line of the request).",
            "        \"\"\"",
            "        index = header_plus.find(b\"\\r\\n\")",
            "",
            "        if index >= 0:",
            "            first_line = header_plus[:index].rstrip()",
            "            header = header_plus[index + 2 :]",
            "        else:",
            "            raise ParsingError(\"HTTP message header invalid\")",
            "",
            "        if b\"\\r\" in first_line or b\"\\n\" in first_line:",
            "            raise ParsingError(\"Bare CR or LF found in HTTP message\")",
            "",
            "        self.first_line = first_line  # for testing",
            "",
            "        lines = get_header_lines(header)",
            "",
            "        headers = self.headers",
            "",
            "        for line in lines:",
            "            header = HEADER_FIELD_RE.match(line)",
            "",
            "            if not header:",
            "                raise ParsingError(\"Invalid header\")",
            "",
            "            key, value = header.group(\"name\", \"value\")",
            "",
            "            if b\"_\" in key:",
            "                # TODO(xistence): Should we drop this request instead?",
            "",
            "                continue",
            "",
            "            # Only strip off whitespace that is considered valid whitespace by",
            "            # RFC7230, don't strip the rest",
            "            value = value.strip(b\" \\t\")",
            "            key1 = key.upper().replace(b\"-\", b\"_\").decode(\"latin-1\")",
            "            # If a header already exists, we append subsequent values",
            "            # separated by a comma. Applications already need to handle",
            "            # the comma separated values, as HTTP front ends might do",
            "            # the concatenation for you (behavior specified in RFC2616).",
            "            try:",
            "                headers[key1] += (b\", \" + value).decode(\"latin-1\")",
            "            except KeyError:",
            "                headers[key1] = value.decode(\"latin-1\")",
            "",
            "        # command, uri, version will be bytes",
            "        command, uri, version = crack_first_line(first_line)",
            "        # self.request_uri is like nginx's request_uri:",
            "        # \"full original request URI (with arguments)\"",
            "        self.request_uri = uri.decode(\"latin-1\")",
            "        version = version.decode(\"latin-1\")",
            "        command = command.decode(\"latin-1\")",
            "        self.command = command",
            "        self.version = version",
            "        (",
            "            self.proxy_scheme,",
            "            self.proxy_netloc,",
            "            self.path,",
            "            self.query,",
            "            self.fragment,",
            "        ) = split_uri(uri)",
            "        self.url_scheme = self.adj.url_scheme",
            "        connection = headers.get(\"CONNECTION\", \"\")",
            "",
            "        if version == \"1.0\":",
            "            if connection.lower() != \"keep-alive\":",
            "                self.connection_close = True",
            "",
            "        if version == \"1.1\":",
            "            # since the server buffers data from chunked transfers and clients",
            "            # never need to deal with chunked requests, downstream clients",
            "            # should not see the HTTP_TRANSFER_ENCODING header; we pop it",
            "            # here",
            "            te = headers.pop(\"TRANSFER_ENCODING\", \"\")",
            "",
            "            # NB: We can not just call bare strip() here because it will also",
            "            # remove other non-printable characters that we explicitly do not",
            "            # want removed so that if someone attempts to smuggle a request",
            "            # with these characters we don't fall prey to it.",
            "            #",
            "            # For example \\x85 is stripped by default, but it is not considered",
            "            # valid whitespace to be stripped by RFC7230.",
            "            encodings = [",
            "                encoding.strip(\" \\t\").lower() for encoding in te.split(\",\") if encoding",
            "            ]",
            "",
            "            for encoding in encodings:",
            "                # Out of the transfer-codings listed in",
            "                # https://tools.ietf.org/html/rfc7230#section-4 we only support",
            "                # chunked at this time.",
            "",
            "                # Note: the identity transfer-coding was removed in RFC7230:",
            "                # https://tools.ietf.org/html/rfc7230#appendix-A.2 and is thus",
            "                # not supported",
            "",
            "                if encoding not in {\"chunked\"}:",
            "                    raise TransferEncodingNotImplemented(",
            "                        \"Transfer-Encoding requested is not supported.\"",
            "                    )",
            "",
            "            if encodings and encodings[-1] == \"chunked\":",
            "                self.chunked = True",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = ChunkedReceiver(buf)",
            "            elif encodings:  # pragma: nocover",
            "                raise TransferEncodingNotImplemented(",
            "                    \"Transfer-Encoding requested is not supported.\"",
            "                )",
            "",
            "            expect = headers.get(\"EXPECT\", \"\").lower()",
            "            self.expect_continue = expect == \"100-continue\"",
            "",
            "            if connection.lower() == \"close\":",
            "                self.connection_close = True",
            "",
            "        if not self.chunked:",
            "            cl = headers.get(\"CONTENT_LENGTH\", \"0\")",
            "",
            "            if not ONLY_DIGIT_RE.match(cl.encode(\"latin-1\")):",
            "                raise ParsingError(\"Content-Length is invalid\")",
            "",
            "            cl = int(cl)",
            "            self.content_length = cl",
            "",
            "            if cl > 0:",
            "                buf = OverflowableBuffer(self.adj.inbuf_overflow)",
            "                self.body_rcv = FixedStreamReceiver(cl, buf)",
            "",
            "    def get_body_stream(self):",
            "        body_rcv = self.body_rcv",
            "",
            "        if body_rcv is not None:",
            "            return body_rcv.getfile()",
            "        else:",
            "            return BytesIO()",
            "",
            "    def close(self):",
            "        body_rcv = self.body_rcv",
            "",
            "        if body_rcv is not None:",
            "            body_rcv.getbuf().close()",
            "",
            "",
            "def split_uri(uri):",
            "    # urlsplit handles byte input by returning bytes on py3, so",
            "    # scheme, netloc, path, query, and fragment are bytes",
            "",
            "    scheme = netloc = path = query = fragment = b\"\"",
            "",
            "    # urlsplit below will treat this as a scheme-less netloc, thereby losing",
            "    # the original intent of the request. Here we shamelessly stole 4 lines of",
            "    # code from the CPython stdlib to parse out the fragment and query but",
            "    # leave the path alone. See",
            "    # https://github.com/python/cpython/blob/8c9e9b0cd5b24dfbf1424d1f253d02de80e8f5ef/Lib/urllib/parse.py#L465-L468",
            "    # and https://github.com/Pylons/waitress/issues/260",
            "",
            "    if uri[:2] == b\"//\":",
            "        path = uri",
            "",
            "        if b\"#\" in path:",
            "            path, fragment = path.split(b\"#\", 1)",
            "",
            "        if b\"?\" in path:",
            "            path, query = path.split(b\"?\", 1)",
            "    else:",
            "        try:",
            "            scheme, netloc, path, query, fragment = parse.urlsplit(uri)",
            "        except UnicodeError:",
            "            raise ParsingError(\"Bad URI\")",
            "",
            "    return (",
            "        scheme.decode(\"latin-1\"),",
            "        netloc.decode(\"latin-1\"),",
            "        unquote_bytes_to_wsgi(path),",
            "        query.decode(\"latin-1\"),",
            "        fragment.decode(\"latin-1\"),",
            "    )",
            "",
            "",
            "def get_header_lines(header):",
            "    \"\"\"",
            "    Splits the header into lines, putting multi-line headers together.",
            "    \"\"\"",
            "    r = []",
            "    lines = header.split(b\"\\r\\n\")",
            "",
            "    for line in lines:",
            "        if not line:",
            "            continue",
            "",
            "        if b\"\\r\" in line or b\"\\n\" in line:",
            "            raise ParsingError(",
            "                'Bare CR or LF found in header line \"%s\"' % str(line, \"latin-1\")",
            "            )",
            "",
            "        if line.startswith((b\" \", b\"\\t\")):",
            "            if not r:",
            "                # https://corte.si/posts/code/pathod/pythonservers/index.html",
            "                raise ParsingError('Malformed header line \"%s\"' % str(line, \"latin-1\"))",
            "            r[-1] += line",
            "        else:",
            "            r.append(line)",
            "",
            "    return r",
            "",
            "",
            "first_line_re = re.compile(",
            "    b\"([^ ]+) \"",
            "    b\"((?:[^ :?#]+://[^ ?#/]*(?:[0-9]{1,5})?)?[^ ]+)\"",
            "    b\"(( HTTP/([0-9.]+))$|$)\"",
            ")",
            "",
            "",
            "def crack_first_line(line):",
            "    m = first_line_re.match(line)",
            "",
            "    if m is not None and m.end() == len(line):",
            "        if m.group(3):",
            "            version = m.group(5)",
            "        else:",
            "            version = b\"\"",
            "        method = m.group(1)",
            "",
            "        # the request methods that are currently defined are all uppercase:",
            "        # https://www.iana.org/assignments/http-methods/http-methods.xhtml and",
            "        # the request method is case sensitive according to",
            "        # https://tools.ietf.org/html/rfc7231#section-4.1",
            "",
            "        # By disallowing anything but uppercase methods we save poor",
            "        # unsuspecting souls from sending lowercase HTTP methods to waitress",
            "        # and having the request complete, while servers like nginx drop the",
            "        # request onto the floor.",
            "",
            "        if method != method.upper():",
            "            raise ParsingError('Malformed HTTP method \"%s\"' % str(method, \"latin-1\"))",
            "        uri = m.group(2)",
            "",
            "        return method, uri, version",
            "    else:",
            "        return b\"\", b\"\", b\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "34": [],
            "35": [],
            "224": [
                "HTTPRequestParser",
                "parse_header"
            ],
            "320": [
                "HTTPRequestParser",
                "parse_header"
            ],
            "321": [
                "HTTPRequestParser",
                "parse_header"
            ],
            "322": [
                "HTTPRequestParser",
                "parse_header"
            ]
        },
        "addLocation": []
    },
    "src/waitress/receiver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " \"\"\"Data Chunk Receiver"
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+from waitress.rfc7230 import CHUNK_EXT_RE, ONLY_HEXDIG_RE"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from waitress.utilities import BadRequest, find_double_newline"
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "                     s = b\"\""
            },
            "8": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "                 else:"
            },
            "9": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "                     self.chunk_end = b\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "                     if pos == 0:"
            },
            "12": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "                         # Chop off the terminating CR LF from the chunk"
            },
            "13": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "                         s = s[2:]"
            },
            "14": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "                     line = s[:pos]"
            },
            "15": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "                     s = s[pos + 2 :]"
            },
            "16": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "                     self.control_line = b\"\""
            },
            "17": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    line = line.strip()"
            },
            "18": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "                     if line:"
            },
            "20": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "                         # Begin a new chunk."
            },
            "21": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "                         semi = line.find(b\";\")"
            },
            "22": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "                         if semi >= 0:"
            },
            "24": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            # discard extension info."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                            extinfo = line[semi:]"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+                            valid_ext_info = CHUNK_EXT_RE.match(extinfo)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+                            if not valid_ext_info:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+                                self.error = BadRequest(\"Invalid chunk extension\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                                self.all_chunks_received = True"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+                                break"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "                             line = line[:semi]"
            },
            "35": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        try:"
            },
            "36": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            sz = int(line.strip(), 16)  # hexadecimal"
            },
            "37": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        except ValueError:  # garbage in input"
            },
            "38": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            self.error = BadRequest(\"garbage in chunked encoding input\")"
            },
            "39": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            sz = 0"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                        if not ONLY_HEXDIG_RE.match(line):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                            self.error = BadRequest(\"Invalid chunk size\")"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                            self.all_chunks_received = True"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                            break"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+                        # Can not fail due to matching against the regular"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+                        # expression above"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+                        sz = int(line, 16)  # hexadecimal"
            },
            "50": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "                         if sz > 0:"
            },
            "52": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "                             # Start a new chunk."
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"Data Chunk Receiver",
            "\"\"\"",
            "",
            "from waitress.utilities import BadRequest, find_double_newline",
            "",
            "",
            "class FixedStreamReceiver:",
            "",
            "    # See IStreamConsumer",
            "    completed = False",
            "    error = None",
            "",
            "    def __init__(self, cl, buf):",
            "        self.remain = cl",
            "        self.buf = buf",
            "",
            "    def __len__(self):",
            "        return self.buf.__len__()",
            "",
            "    def received(self, data):",
            "        \"See IStreamConsumer\"",
            "        rm = self.remain",
            "",
            "        if rm < 1:",
            "            self.completed = True  # Avoid any chance of spinning",
            "",
            "            return 0",
            "        datalen = len(data)",
            "",
            "        if rm <= datalen:",
            "            self.buf.append(data[:rm])",
            "            self.remain = 0",
            "            self.completed = True",
            "",
            "            return rm",
            "        else:",
            "            self.buf.append(data)",
            "            self.remain -= datalen",
            "",
            "            return datalen",
            "",
            "    def getfile(self):",
            "        return self.buf.getfile()",
            "",
            "    def getbuf(self):",
            "        return self.buf",
            "",
            "",
            "class ChunkedReceiver:",
            "",
            "    chunk_remainder = 0",
            "    validate_chunk_end = False",
            "    control_line = b\"\"",
            "    chunk_end = b\"\"",
            "    all_chunks_received = False",
            "    trailer = b\"\"",
            "    completed = False",
            "    error = None",
            "",
            "    # max_control_line = 1024",
            "    # max_trailer = 65536",
            "",
            "    def __init__(self, buf):",
            "        self.buf = buf",
            "",
            "    def __len__(self):",
            "        return self.buf.__len__()",
            "",
            "    def received(self, s):",
            "        # Returns the number of bytes consumed.",
            "",
            "        if self.completed:",
            "            return 0",
            "        orig_size = len(s)",
            "",
            "        while s:",
            "            rm = self.chunk_remainder",
            "",
            "            if rm > 0:",
            "                # Receive the remainder of a chunk.",
            "                to_write = s[:rm]",
            "                self.buf.append(to_write)",
            "                written = len(to_write)",
            "                s = s[written:]",
            "",
            "                self.chunk_remainder -= written",
            "",
            "                if self.chunk_remainder == 0:",
            "                    self.validate_chunk_end = True",
            "            elif self.validate_chunk_end:",
            "                s = self.chunk_end + s",
            "",
            "                pos = s.find(b\"\\r\\n\")",
            "",
            "                if pos < 0 and len(s) < 2:",
            "                    self.chunk_end = s",
            "                    s = b\"\"",
            "                else:",
            "                    self.chunk_end = b\"\"",
            "                    if pos == 0:",
            "                        # Chop off the terminating CR LF from the chunk",
            "                        s = s[2:]",
            "                    else:",
            "                        self.error = BadRequest(\"Chunk not properly terminated\")",
            "                        self.all_chunks_received = True",
            "",
            "                    # Always exit this loop",
            "                    self.validate_chunk_end = False",
            "            elif not self.all_chunks_received:",
            "                # Receive a control line.",
            "                s = self.control_line + s",
            "                pos = s.find(b\"\\r\\n\")",
            "",
            "                if pos < 0:",
            "                    # Control line not finished.",
            "                    self.control_line = s",
            "                    s = b\"\"",
            "                else:",
            "                    # Control line finished.",
            "                    line = s[:pos]",
            "                    s = s[pos + 2 :]",
            "                    self.control_line = b\"\"",
            "                    line = line.strip()",
            "",
            "                    if line:",
            "                        # Begin a new chunk.",
            "                        semi = line.find(b\";\")",
            "",
            "                        if semi >= 0:",
            "                            # discard extension info.",
            "                            line = line[:semi]",
            "                        try:",
            "                            sz = int(line.strip(), 16)  # hexadecimal",
            "                        except ValueError:  # garbage in input",
            "                            self.error = BadRequest(\"garbage in chunked encoding input\")",
            "                            sz = 0",
            "",
            "                        if sz > 0:",
            "                            # Start a new chunk.",
            "                            self.chunk_remainder = sz",
            "                        else:",
            "                            # Finished chunks.",
            "                            self.all_chunks_received = True",
            "                    # else expect a control line.",
            "            else:",
            "                # Receive the trailer.",
            "                trailer = self.trailer + s",
            "",
            "                if trailer.startswith(b\"\\r\\n\"):",
            "                    # No trailer.",
            "                    self.completed = True",
            "",
            "                    return orig_size - (len(trailer) - 2)",
            "                pos = find_double_newline(trailer)",
            "",
            "                if pos < 0:",
            "                    # Trailer not finished.",
            "                    self.trailer = trailer",
            "                    s = b\"\"",
            "                else:",
            "                    # Finished the trailer.",
            "                    self.completed = True",
            "                    self.trailer = trailer[:pos]",
            "",
            "                    return orig_size - (len(trailer) - pos)",
            "",
            "        return orig_size",
            "",
            "    def getfile(self):",
            "        return self.buf.getfile()",
            "",
            "    def getbuf(self):",
            "        return self.buf"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001, 2002 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"Data Chunk Receiver",
            "\"\"\"",
            "",
            "from waitress.rfc7230 import CHUNK_EXT_RE, ONLY_HEXDIG_RE",
            "from waitress.utilities import BadRequest, find_double_newline",
            "",
            "",
            "class FixedStreamReceiver:",
            "",
            "    # See IStreamConsumer",
            "    completed = False",
            "    error = None",
            "",
            "    def __init__(self, cl, buf):",
            "        self.remain = cl",
            "        self.buf = buf",
            "",
            "    def __len__(self):",
            "        return self.buf.__len__()",
            "",
            "    def received(self, data):",
            "        \"See IStreamConsumer\"",
            "        rm = self.remain",
            "",
            "        if rm < 1:",
            "            self.completed = True  # Avoid any chance of spinning",
            "",
            "            return 0",
            "        datalen = len(data)",
            "",
            "        if rm <= datalen:",
            "            self.buf.append(data[:rm])",
            "            self.remain = 0",
            "            self.completed = True",
            "",
            "            return rm",
            "        else:",
            "            self.buf.append(data)",
            "            self.remain -= datalen",
            "",
            "            return datalen",
            "",
            "    def getfile(self):",
            "        return self.buf.getfile()",
            "",
            "    def getbuf(self):",
            "        return self.buf",
            "",
            "",
            "class ChunkedReceiver:",
            "",
            "    chunk_remainder = 0",
            "    validate_chunk_end = False",
            "    control_line = b\"\"",
            "    chunk_end = b\"\"",
            "    all_chunks_received = False",
            "    trailer = b\"\"",
            "    completed = False",
            "    error = None",
            "",
            "    # max_control_line = 1024",
            "    # max_trailer = 65536",
            "",
            "    def __init__(self, buf):",
            "        self.buf = buf",
            "",
            "    def __len__(self):",
            "        return self.buf.__len__()",
            "",
            "    def received(self, s):",
            "        # Returns the number of bytes consumed.",
            "",
            "        if self.completed:",
            "            return 0",
            "        orig_size = len(s)",
            "",
            "        while s:",
            "            rm = self.chunk_remainder",
            "",
            "            if rm > 0:",
            "                # Receive the remainder of a chunk.",
            "                to_write = s[:rm]",
            "                self.buf.append(to_write)",
            "                written = len(to_write)",
            "                s = s[written:]",
            "",
            "                self.chunk_remainder -= written",
            "",
            "                if self.chunk_remainder == 0:",
            "                    self.validate_chunk_end = True",
            "            elif self.validate_chunk_end:",
            "                s = self.chunk_end + s",
            "",
            "                pos = s.find(b\"\\r\\n\")",
            "",
            "                if pos < 0 and len(s) < 2:",
            "                    self.chunk_end = s",
            "                    s = b\"\"",
            "                else:",
            "                    self.chunk_end = b\"\"",
            "",
            "                    if pos == 0:",
            "                        # Chop off the terminating CR LF from the chunk",
            "                        s = s[2:]",
            "                    else:",
            "                        self.error = BadRequest(\"Chunk not properly terminated\")",
            "                        self.all_chunks_received = True",
            "",
            "                    # Always exit this loop",
            "                    self.validate_chunk_end = False",
            "            elif not self.all_chunks_received:",
            "                # Receive a control line.",
            "                s = self.control_line + s",
            "                pos = s.find(b\"\\r\\n\")",
            "",
            "                if pos < 0:",
            "                    # Control line not finished.",
            "                    self.control_line = s",
            "                    s = b\"\"",
            "                else:",
            "                    # Control line finished.",
            "                    line = s[:pos]",
            "                    s = s[pos + 2 :]",
            "                    self.control_line = b\"\"",
            "",
            "                    if line:",
            "                        # Begin a new chunk.",
            "                        semi = line.find(b\";\")",
            "",
            "                        if semi >= 0:",
            "                            extinfo = line[semi:]",
            "                            valid_ext_info = CHUNK_EXT_RE.match(extinfo)",
            "",
            "                            if not valid_ext_info:",
            "                                self.error = BadRequest(\"Invalid chunk extension\")",
            "                                self.all_chunks_received = True",
            "",
            "                                break",
            "",
            "                            line = line[:semi]",
            "",
            "                        if not ONLY_HEXDIG_RE.match(line):",
            "                            self.error = BadRequest(\"Invalid chunk size\")",
            "                            self.all_chunks_received = True",
            "",
            "                            break",
            "",
            "                        # Can not fail due to matching against the regular",
            "                        # expression above",
            "                        sz = int(line, 16)  # hexadecimal",
            "",
            "                        if sz > 0:",
            "                            # Start a new chunk.",
            "                            self.chunk_remainder = sz",
            "                        else:",
            "                            # Finished chunks.",
            "                            self.all_chunks_received = True",
            "                    # else expect a control line.",
            "            else:",
            "                # Receive the trailer.",
            "                trailer = self.trailer + s",
            "",
            "                if trailer.startswith(b\"\\r\\n\"):",
            "                    # No trailer.",
            "                    self.completed = True",
            "",
            "                    return orig_size - (len(trailer) - 2)",
            "                pos = find_double_newline(trailer)",
            "",
            "                if pos < 0:",
            "                    # Trailer not finished.",
            "                    self.trailer = trailer",
            "                    s = b\"\"",
            "                else:",
            "                    # Finished the trailer.",
            "                    self.completed = True",
            "                    self.trailer = trailer[:pos]",
            "",
            "                    return orig_size - (len(trailer) - pos)",
            "",
            "        return orig_size",
            "",
            "    def getfile(self):",
            "        return self.buf.getfile()",
            "",
            "    def getbuf(self):",
            "        return self.buf"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "136": [
                "ChunkedReceiver",
                "received"
            ],
            "143": [
                "ChunkedReceiver",
                "received"
            ],
            "145": [
                "ChunkedReceiver",
                "received"
            ],
            "146": [
                "ChunkedReceiver",
                "received"
            ],
            "147": [
                "ChunkedReceiver",
                "received"
            ],
            "148": [
                "ChunkedReceiver",
                "received"
            ],
            "149": [
                "ChunkedReceiver",
                "received"
            ]
        },
        "addLocation": [
            "src.octoprint.filemanager.storage.LocalFileStorage._copy_metadata_entry"
        ]
    },
    "src/waitress/rfc7230.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import re"
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+HEXDIG = \"[0-9a-fA-F]\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+DIGIT = \"[0-9]\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " WS = \"[ \\t]\""
            },
            "7": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " OWS = WS + \"{0,}?\""
            },
            "8": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " RWS = WS + \"{1,}?\""
            },
            "9": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " #                  ; visible (printing) characters"
            },
            "10": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " VCHAR = r\"\\x21-\\x7e\""
            },
            "11": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+QDTEXT = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + OBS_TEXT + \"]\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+QUOTED_PAIR = r\"\\\\\" + \"([\\t \" + VCHAR + OBS_TEXT + \"])\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+QUOTED_STRING = '\"(?:(?:' + QDTEXT + \")|(?:\" + QUOTED_PAIR + '))*\"'"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " # header-field   = field-name \":\" OWS field-value OWS"
            },
            "19": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " # field-name     = token"
            },
            "20": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " # field-value    = *( field-content / obs-fold )"
            },
            "21": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " # Which allows the field value here to just see if there is even a value in the first place"
            },
            "22": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " FIELD_VALUE = \"(?:\" + FIELD_CONTENT + \")?\""
            },
            "23": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-HEADER_FIELD = re.compile("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+# chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+# chunk-ext-name = token"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+# chunk-ext-val  = token / quoted-string"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+CHUNK_EXT_NAME = TOKEN"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+CHUNK_EXT_VAL = \"(?:\" + TOKEN + \")|(?:\" + QUOTED_STRING + \")\""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+CHUNK_EXT = ("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    \"(?:;(?P<extension>\" + CHUNK_EXT_NAME + \")(?:=(?P<value>\" + CHUNK_EXT_VAL + \"))?)*\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+# Pre-compiled regular expressions for use elsewhere"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+ONLY_HEXDIG_RE = re.compile((\"^\" + HEXDIG + \"+$\").encode(\"latin-1\"))"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+ONLY_DIGIT_RE = re.compile((\"^\" + DIGIT + \"+$\").encode(\"latin-1\"))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+HEADER_FIELD_RE = re.compile("
            },
            "39": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     ("
            },
            "40": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         \"^(?P<name>\" + TOKEN + \"):\" + OWS + \"(?P<value>\" + FIELD_VALUE + \")\" + OWS + \"$\""
            },
            "41": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     ).encode(\"latin-1\")"
            },
            "42": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+QUOTED_PAIR_RE = re.compile(QUOTED_PAIR)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+QUOTED_STRING_RE = re.compile(QUOTED_STRING)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+CHUNK_EXT_RE = re.compile((\"^\" + CHUNK_EXT + \"$\").encode(\"latin-1\"))"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "This contains a bunch of RFC7230 definitions and regular expressions that are",
            "needed to properly parse HTTP messages.",
            "\"\"\"",
            "",
            "import re",
            "",
            "WS = \"[ \\t]\"",
            "OWS = WS + \"{0,}?\"",
            "RWS = WS + \"{1,}?\"",
            "BWS = OWS",
            "",
            "# RFC 7230 Section 3.2.6 \"Field Value Components\":",
            "# tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"",
            "#                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"",
            "#                / DIGIT / ALPHA",
            "# obs-text      = %x80-FF",
            "TCHAR = r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]\"",
            "OBS_TEXT = r\"\\x80-\\xff\"",
            "",
            "TOKEN = TCHAR + \"{1,}\"",
            "",
            "# RFC 5234 Appendix B.1 \"Core Rules\":",
            "# VCHAR         =  %x21-7E",
            "#                  ; visible (printing) characters",
            "VCHAR = r\"\\x21-\\x7e\"",
            "",
            "# header-field   = field-name \":\" OWS field-value OWS",
            "# field-name     = token",
            "# field-value    = *( field-content / obs-fold )",
            "# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]",
            "# field-vchar    = VCHAR / obs-text",
            "",
            "# Errata from: https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4189",
            "# changes field-content to:",
            "#",
            "# field-content  = field-vchar [ 1*( SP / HTAB / field-vchar )",
            "#                  field-vchar ]",
            "",
            "FIELD_VCHAR = \"[\" + VCHAR + OBS_TEXT + \"]\"",
            "# Field content is more greedy than the ABNF, in that it will match the whole value",
            "FIELD_CONTENT = FIELD_VCHAR + \"+(?:[ \\t]+\" + FIELD_VCHAR + \"+)*\"",
            "# Which allows the field value here to just see if there is even a value in the first place",
            "FIELD_VALUE = \"(?:\" + FIELD_CONTENT + \")?\"",
            "",
            "HEADER_FIELD = re.compile(",
            "    (",
            "        \"^(?P<name>\" + TOKEN + \"):\" + OWS + \"(?P<value>\" + FIELD_VALUE + \")\" + OWS + \"$\"",
            "    ).encode(\"latin-1\")",
            ")"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "This contains a bunch of RFC7230 definitions and regular expressions that are",
            "needed to properly parse HTTP messages.",
            "\"\"\"",
            "",
            "import re",
            "",
            "HEXDIG = \"[0-9a-fA-F]\"",
            "DIGIT = \"[0-9]\"",
            "",
            "WS = \"[ \\t]\"",
            "OWS = WS + \"{0,}?\"",
            "RWS = WS + \"{1,}?\"",
            "BWS = OWS",
            "",
            "# RFC 7230 Section 3.2.6 \"Field Value Components\":",
            "# tchar          = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"",
            "#                / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"",
            "#                / DIGIT / ALPHA",
            "# obs-text      = %x80-FF",
            "TCHAR = r\"[!#$%&'*+\\-.^_`|~0-9A-Za-z]\"",
            "OBS_TEXT = r\"\\x80-\\xff\"",
            "",
            "TOKEN = TCHAR + \"{1,}\"",
            "",
            "# RFC 5234 Appendix B.1 \"Core Rules\":",
            "# VCHAR         =  %x21-7E",
            "#                  ; visible (printing) characters",
            "VCHAR = r\"\\x21-\\x7e\"",
            "",
            "# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')",
            "QDTEXT = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + OBS_TEXT + \"]\"",
            "",
            "QUOTED_PAIR = r\"\\\\\" + \"([\\t \" + VCHAR + OBS_TEXT + \"])\"",
            "QUOTED_STRING = '\"(?:(?:' + QDTEXT + \")|(?:\" + QUOTED_PAIR + '))*\"'",
            "",
            "# header-field   = field-name \":\" OWS field-value OWS",
            "# field-name     = token",
            "# field-value    = *( field-content / obs-fold )",
            "# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]",
            "# field-vchar    = VCHAR / obs-text",
            "",
            "# Errata from: https://www.rfc-editor.org/errata_search.php?rfc=7230&eid=4189",
            "# changes field-content to:",
            "#",
            "# field-content  = field-vchar [ 1*( SP / HTAB / field-vchar )",
            "#                  field-vchar ]",
            "",
            "FIELD_VCHAR = \"[\" + VCHAR + OBS_TEXT + \"]\"",
            "# Field content is more greedy than the ABNF, in that it will match the whole value",
            "FIELD_CONTENT = FIELD_VCHAR + \"+(?:[ \\t]+\" + FIELD_VCHAR + \"+)*\"",
            "# Which allows the field value here to just see if there is even a value in the first place",
            "FIELD_VALUE = \"(?:\" + FIELD_CONTENT + \")?\"",
            "",
            "# chunk-ext      = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )",
            "# chunk-ext-name = token",
            "# chunk-ext-val  = token / quoted-string",
            "",
            "CHUNK_EXT_NAME = TOKEN",
            "CHUNK_EXT_VAL = \"(?:\" + TOKEN + \")|(?:\" + QUOTED_STRING + \")\"",
            "CHUNK_EXT = (",
            "    \"(?:;(?P<extension>\" + CHUNK_EXT_NAME + \")(?:=(?P<value>\" + CHUNK_EXT_VAL + \"))?)*\"",
            ")",
            "",
            "# Pre-compiled regular expressions for use elsewhere",
            "ONLY_HEXDIG_RE = re.compile((\"^\" + HEXDIG + \"+$\").encode(\"latin-1\"))",
            "ONLY_DIGIT_RE = re.compile((\"^\" + DIGIT + \"+$\").encode(\"latin-1\"))",
            "HEADER_FIELD_RE = re.compile(",
            "    (",
            "        \"^(?P<name>\" + TOKEN + \"):\" + OWS + \"(?P<value>\" + FIELD_VALUE + \")\" + OWS + \"$\"",
            "    ).encode(\"latin-1\")",
            ")",
            "QUOTED_PAIR_RE = re.compile(QUOTED_PAIR)",
            "QUOTED_STRING_RE = re.compile(QUOTED_STRING)",
            "CHUNK_EXT_RE = re.compile((\"^\" + CHUNK_EXT + \"$\").encode(\"latin-1\"))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "46": [
                "HEADER_FIELD"
            ]
        },
        "addLocation": []
    },
    "src/waitress/utilities.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import stat"
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " import time"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .rfc7230 import OBS_TEXT, VCHAR"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from .rfc7230 import QUOTED_PAIR_RE, QUOTED_STRING_RE"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " logger = logging.getLogger(\"waitress\")"
            },
            "7": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " queue_logger = logging.getLogger(\"waitress.queue\")"
            },
            "8": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     return retval"
            },
            "9": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# RFC 5234 Appendix B.1 \"Core Rules\":"
            },
            "12": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# VCHAR         =  %x21-7E"
            },
            "13": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-#                  ; visible (printing) characters"
            },
            "14": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-vchar_re = VCHAR"
            },
            "15": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# RFC 7230 Section 3.2.6 \"Field Value Components\":"
            },
            "17": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE"
            },
            "18": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# qdtext        = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text"
            },
            "19": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# obs-text      = %x80-FF"
            },
            "20": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )"
            },
            "21": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-obs_text_re = OBS_TEXT"
            },
            "22": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "23": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')"
            },
            "24": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-qdtext_re = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + obs_text_re + \"]\""
            },
            "25": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-quoted_pair_re = r\"\\\\\" + \"([\\t \" + vchar_re + obs_text_re + \"])\""
            },
            "27": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-quoted_string_re = '\"(?:(?:' + qdtext_re + \")|(?:\" + quoted_pair_re + '))*\"'"
            },
            "28": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "29": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-quoted_string = re.compile(quoted_string_re)"
            },
            "30": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-quoted_pair = re.compile(quoted_pair_re)"
            },
            "31": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "32": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "33": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 219,
                "PatchRowcode": " def undquote(value):"
            },
            "34": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "     if value.startswith('\"') and value.endswith('\"'):"
            },
            "35": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "         # So it claims to be DQUOTE'ed, let's validate that"
            },
            "36": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        matches = quoted_string.match(value)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        matches = QUOTED_STRING_RE.match(value)"
            },
            "38": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 223,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         if matches and matches.end() == len(value):"
            },
            "40": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "             # Remove the DQUOTE's from the value"
            },
            "41": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "             value = value[1:-1]"
            },
            "42": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "             # Remove all backslashes that are followed by a valid vchar or"
            },
            "44": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             # obs-text"
            },
            "45": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            value = quoted_pair.sub(r\"\\1\", value)"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+            value = QUOTED_PAIR_RE.sub(r\"\\1\", value)"
            },
            "47": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 231,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "             return value"
            },
            "49": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     elif not value.startswith('\"') and not value.endswith('\"'):"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2004 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"Utility functions",
            "\"\"\"",
            "",
            "import calendar",
            "import errno",
            "import logging",
            "import os",
            "import re",
            "import stat",
            "import time",
            "",
            "from .rfc7230 import OBS_TEXT, VCHAR",
            "",
            "logger = logging.getLogger(\"waitress\")",
            "queue_logger = logging.getLogger(\"waitress.queue\")",
            "",
            "",
            "def find_double_newline(s):",
            "    \"\"\"Returns the position just after a double newline in the given string.\"\"\"",
            "    pos = s.find(b\"\\r\\n\\r\\n\")",
            "",
            "    if pos >= 0:",
            "        pos += 4",
            "",
            "    return pos",
            "",
            "",
            "def concat(*args):",
            "    return \"\".join(args)",
            "",
            "",
            "def join(seq, field=\" \"):",
            "    return field.join(seq)",
            "",
            "",
            "def group(s):",
            "    return \"(\" + s + \")\"",
            "",
            "",
            "short_days = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"]",
            "long_days = [",
            "    \"sunday\",",
            "    \"monday\",",
            "    \"tuesday\",",
            "    \"wednesday\",",
            "    \"thursday\",",
            "    \"friday\",",
            "    \"saturday\",",
            "]",
            "",
            "short_day_reg = group(join(short_days, \"|\"))",
            "long_day_reg = group(join(long_days, \"|\"))",
            "",
            "daymap = {}",
            "",
            "for i in range(7):",
            "    daymap[short_days[i]] = i",
            "    daymap[long_days[i]] = i",
            "",
            "hms_reg = join(3 * [group(\"[0-9][0-9]\")], \":\")",
            "",
            "months = [",
            "    \"jan\",",
            "    \"feb\",",
            "    \"mar\",",
            "    \"apr\",",
            "    \"may\",",
            "    \"jun\",",
            "    \"jul\",",
            "    \"aug\",",
            "    \"sep\",",
            "    \"oct\",",
            "    \"nov\",",
            "    \"dec\",",
            "]",
            "",
            "monmap = {}",
            "",
            "for i in range(12):",
            "    monmap[months[i]] = i + 1",
            "",
            "months_reg = group(join(months, \"|\"))",
            "",
            "# From draft-ietf-http-v11-spec-07.txt/3.3.1",
            "#       Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123",
            "#       Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036",
            "#       Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format",
            "",
            "# rfc822 format",
            "rfc822_date = join(",
            "    [",
            "        concat(short_day_reg, \",\"),  # day",
            "        group(\"[0-9][0-9]?\"),  # date",
            "        months_reg,  # month",
            "        group(\"[0-9]+\"),  # year",
            "        hms_reg,  # hour minute second",
            "        \"gmt\",",
            "    ],",
            "    \" \",",
            ")",
            "",
            "rfc822_reg = re.compile(rfc822_date)",
            "",
            "",
            "def unpack_rfc822(m):",
            "    g = m.group",
            "",
            "    return (",
            "        int(g(4)),  # year",
            "        monmap[g(3)],  # month",
            "        int(g(2)),  # day",
            "        int(g(5)),  # hour",
            "        int(g(6)),  # minute",
            "        int(g(7)),  # second",
            "        0,",
            "        0,",
            "        0,",
            "    )",
            "",
            "",
            "# rfc850 format",
            "rfc850_date = join(",
            "    [",
            "        concat(long_day_reg, \",\"),",
            "        join([group(\"[0-9][0-9]?\"), months_reg, group(\"[0-9]+\")], \"-\"),",
            "        hms_reg,",
            "        \"gmt\",",
            "    ],",
            "    \" \",",
            ")",
            "",
            "rfc850_reg = re.compile(rfc850_date)",
            "# they actually unpack the same way",
            "def unpack_rfc850(m):",
            "    g = m.group",
            "    yr = g(4)",
            "",
            "    if len(yr) == 2:",
            "        yr = \"19\" + yr",
            "",
            "    return (",
            "        int(yr),  # year",
            "        monmap[g(3)],  # month",
            "        int(g(2)),  # day",
            "        int(g(5)),  # hour",
            "        int(g(6)),  # minute",
            "        int(g(7)),  # second",
            "        0,",
            "        0,",
            "        0,",
            "    )",
            "",
            "",
            "# parsdate.parsedate - ~700/sec.",
            "# parse_http_date    - ~1333/sec.",
            "",
            "weekdayname = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]",
            "monthname = [",
            "    None,",
            "    \"Jan\",",
            "    \"Feb\",",
            "    \"Mar\",",
            "    \"Apr\",",
            "    \"May\",",
            "    \"Jun\",",
            "    \"Jul\",",
            "    \"Aug\",",
            "    \"Sep\",",
            "    \"Oct\",",
            "    \"Nov\",",
            "    \"Dec\",",
            "]",
            "",
            "",
            "def build_http_date(when):",
            "    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(when)",
            "",
            "    return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\" % (",
            "        weekdayname[wd],",
            "        day,",
            "        monthname[month],",
            "        year,",
            "        hh,",
            "        mm,",
            "        ss,",
            "    )",
            "",
            "",
            "def parse_http_date(d):",
            "    d = d.lower()",
            "    m = rfc850_reg.match(d)",
            "",
            "    if m and m.end() == len(d):",
            "        retval = int(calendar.timegm(unpack_rfc850(m)))",
            "    else:",
            "        m = rfc822_reg.match(d)",
            "",
            "        if m and m.end() == len(d):",
            "            retval = int(calendar.timegm(unpack_rfc822(m)))",
            "        else:",
            "            return 0",
            "",
            "    return retval",
            "",
            "",
            "# RFC 5234 Appendix B.1 \"Core Rules\":",
            "# VCHAR         =  %x21-7E",
            "#                  ; visible (printing) characters",
            "vchar_re = VCHAR",
            "",
            "# RFC 7230 Section 3.2.6 \"Field Value Components\":",
            "# quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE",
            "# qdtext        = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text",
            "# obs-text      = %x80-FF",
            "# quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )",
            "obs_text_re = OBS_TEXT",
            "",
            "# The '\\\\' between \\x5b and \\x5d is needed to escape \\x5d (']')",
            "qdtext_re = \"[\\t \\x21\\x23-\\x5b\\\\\\x5d-\\x7e\" + obs_text_re + \"]\"",
            "",
            "quoted_pair_re = r\"\\\\\" + \"([\\t \" + vchar_re + obs_text_re + \"])\"",
            "quoted_string_re = '\"(?:(?:' + qdtext_re + \")|(?:\" + quoted_pair_re + '))*\"'",
            "",
            "quoted_string = re.compile(quoted_string_re)",
            "quoted_pair = re.compile(quoted_pair_re)",
            "",
            "",
            "def undquote(value):",
            "    if value.startswith('\"') and value.endswith('\"'):",
            "        # So it claims to be DQUOTE'ed, let's validate that",
            "        matches = quoted_string.match(value)",
            "",
            "        if matches and matches.end() == len(value):",
            "            # Remove the DQUOTE's from the value",
            "            value = value[1:-1]",
            "",
            "            # Remove all backslashes that are followed by a valid vchar or",
            "            # obs-text",
            "            value = quoted_pair.sub(r\"\\1\", value)",
            "",
            "            return value",
            "    elif not value.startswith('\"') and not value.endswith('\"'):",
            "        return value",
            "",
            "    raise ValueError(\"Invalid quoting in value\")",
            "",
            "",
            "def cleanup_unix_socket(path):",
            "    try:",
            "        st = os.stat(path)",
            "    except OSError as exc:",
            "        if exc.errno != errno.ENOENT:",
            "            raise  # pragma: no cover",
            "    else:",
            "        if stat.S_ISSOCK(st.st_mode):",
            "            try:",
            "                os.remove(path)",
            "            except OSError:  # pragma: no cover",
            "                # avoid race condition error during tests",
            "                pass",
            "",
            "",
            "class Error:",
            "    code = 500",
            "    reason = \"Internal Server Error\"",
            "",
            "    def __init__(self, body):",
            "        self.body = body",
            "",
            "    def to_response(self):",
            "        status = \"%s %s\" % (self.code, self.reason)",
            "        body = \"%s\\r\\n\\r\\n%s\" % (self.reason, self.body)",
            "        tag = \"\\r\\n\\r\\n(generated by waitress)\"",
            "        body = body + tag",
            "        headers = [(\"Content-Type\", \"text/plain\")]",
            "",
            "        return status, headers, body",
            "",
            "    def wsgi_response(self, environ, start_response):",
            "        status, headers, body = self.to_response()",
            "        start_response(status, headers)",
            "        yield body",
            "",
            "",
            "class BadRequest(Error):",
            "    code = 400",
            "    reason = \"Bad Request\"",
            "",
            "",
            "class RequestHeaderFieldsTooLarge(BadRequest):",
            "    code = 431",
            "    reason = \"Request Header Fields Too Large\"",
            "",
            "",
            "class RequestEntityTooLarge(BadRequest):",
            "    code = 413",
            "    reason = \"Request Entity Too Large\"",
            "",
            "",
            "class InternalServerError(Error):",
            "    code = 500",
            "    reason = \"Internal Server Error\"",
            "",
            "",
            "class ServerNotImplemented(Error):",
            "    code = 501",
            "    reason = \"Not Implemented\""
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2004 Zope Foundation and Contributors.",
            "# All Rights Reserved.",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\"Utility functions",
            "\"\"\"",
            "",
            "import calendar",
            "import errno",
            "import logging",
            "import os",
            "import re",
            "import stat",
            "import time",
            "",
            "from .rfc7230 import QUOTED_PAIR_RE, QUOTED_STRING_RE",
            "",
            "logger = logging.getLogger(\"waitress\")",
            "queue_logger = logging.getLogger(\"waitress.queue\")",
            "",
            "",
            "def find_double_newline(s):",
            "    \"\"\"Returns the position just after a double newline in the given string.\"\"\"",
            "    pos = s.find(b\"\\r\\n\\r\\n\")",
            "",
            "    if pos >= 0:",
            "        pos += 4",
            "",
            "    return pos",
            "",
            "",
            "def concat(*args):",
            "    return \"\".join(args)",
            "",
            "",
            "def join(seq, field=\" \"):",
            "    return field.join(seq)",
            "",
            "",
            "def group(s):",
            "    return \"(\" + s + \")\"",
            "",
            "",
            "short_days = [\"sun\", \"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\"]",
            "long_days = [",
            "    \"sunday\",",
            "    \"monday\",",
            "    \"tuesday\",",
            "    \"wednesday\",",
            "    \"thursday\",",
            "    \"friday\",",
            "    \"saturday\",",
            "]",
            "",
            "short_day_reg = group(join(short_days, \"|\"))",
            "long_day_reg = group(join(long_days, \"|\"))",
            "",
            "daymap = {}",
            "",
            "for i in range(7):",
            "    daymap[short_days[i]] = i",
            "    daymap[long_days[i]] = i",
            "",
            "hms_reg = join(3 * [group(\"[0-9][0-9]\")], \":\")",
            "",
            "months = [",
            "    \"jan\",",
            "    \"feb\",",
            "    \"mar\",",
            "    \"apr\",",
            "    \"may\",",
            "    \"jun\",",
            "    \"jul\",",
            "    \"aug\",",
            "    \"sep\",",
            "    \"oct\",",
            "    \"nov\",",
            "    \"dec\",",
            "]",
            "",
            "monmap = {}",
            "",
            "for i in range(12):",
            "    monmap[months[i]] = i + 1",
            "",
            "months_reg = group(join(months, \"|\"))",
            "",
            "# From draft-ietf-http-v11-spec-07.txt/3.3.1",
            "#       Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123",
            "#       Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036",
            "#       Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format",
            "",
            "# rfc822 format",
            "rfc822_date = join(",
            "    [",
            "        concat(short_day_reg, \",\"),  # day",
            "        group(\"[0-9][0-9]?\"),  # date",
            "        months_reg,  # month",
            "        group(\"[0-9]+\"),  # year",
            "        hms_reg,  # hour minute second",
            "        \"gmt\",",
            "    ],",
            "    \" \",",
            ")",
            "",
            "rfc822_reg = re.compile(rfc822_date)",
            "",
            "",
            "def unpack_rfc822(m):",
            "    g = m.group",
            "",
            "    return (",
            "        int(g(4)),  # year",
            "        monmap[g(3)],  # month",
            "        int(g(2)),  # day",
            "        int(g(5)),  # hour",
            "        int(g(6)),  # minute",
            "        int(g(7)),  # second",
            "        0,",
            "        0,",
            "        0,",
            "    )",
            "",
            "",
            "# rfc850 format",
            "rfc850_date = join(",
            "    [",
            "        concat(long_day_reg, \",\"),",
            "        join([group(\"[0-9][0-9]?\"), months_reg, group(\"[0-9]+\")], \"-\"),",
            "        hms_reg,",
            "        \"gmt\",",
            "    ],",
            "    \" \",",
            ")",
            "",
            "rfc850_reg = re.compile(rfc850_date)",
            "# they actually unpack the same way",
            "def unpack_rfc850(m):",
            "    g = m.group",
            "    yr = g(4)",
            "",
            "    if len(yr) == 2:",
            "        yr = \"19\" + yr",
            "",
            "    return (",
            "        int(yr),  # year",
            "        monmap[g(3)],  # month",
            "        int(g(2)),  # day",
            "        int(g(5)),  # hour",
            "        int(g(6)),  # minute",
            "        int(g(7)),  # second",
            "        0,",
            "        0,",
            "        0,",
            "    )",
            "",
            "",
            "# parsdate.parsedate - ~700/sec.",
            "# parse_http_date    - ~1333/sec.",
            "",
            "weekdayname = [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]",
            "monthname = [",
            "    None,",
            "    \"Jan\",",
            "    \"Feb\",",
            "    \"Mar\",",
            "    \"Apr\",",
            "    \"May\",",
            "    \"Jun\",",
            "    \"Jul\",",
            "    \"Aug\",",
            "    \"Sep\",",
            "    \"Oct\",",
            "    \"Nov\",",
            "    \"Dec\",",
            "]",
            "",
            "",
            "def build_http_date(when):",
            "    year, month, day, hh, mm, ss, wd, y, z = time.gmtime(when)",
            "",
            "    return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\" % (",
            "        weekdayname[wd],",
            "        day,",
            "        monthname[month],",
            "        year,",
            "        hh,",
            "        mm,",
            "        ss,",
            "    )",
            "",
            "",
            "def parse_http_date(d):",
            "    d = d.lower()",
            "    m = rfc850_reg.match(d)",
            "",
            "    if m and m.end() == len(d):",
            "        retval = int(calendar.timegm(unpack_rfc850(m)))",
            "    else:",
            "        m = rfc822_reg.match(d)",
            "",
            "        if m and m.end() == len(d):",
            "            retval = int(calendar.timegm(unpack_rfc822(m)))",
            "        else:",
            "            return 0",
            "",
            "    return retval",
            "",
            "",
            "def undquote(value):",
            "    if value.startswith('\"') and value.endswith('\"'):",
            "        # So it claims to be DQUOTE'ed, let's validate that",
            "        matches = QUOTED_STRING_RE.match(value)",
            "",
            "        if matches and matches.end() == len(value):",
            "            # Remove the DQUOTE's from the value",
            "            value = value[1:-1]",
            "",
            "            # Remove all backslashes that are followed by a valid vchar or",
            "            # obs-text",
            "            value = QUOTED_PAIR_RE.sub(r\"\\1\", value)",
            "",
            "            return value",
            "    elif not value.startswith('\"') and not value.endswith('\"'):",
            "        return value",
            "",
            "    raise ValueError(\"Invalid quoting in value\")",
            "",
            "",
            "def cleanup_unix_socket(path):",
            "    try:",
            "        st = os.stat(path)",
            "    except OSError as exc:",
            "        if exc.errno != errno.ENOENT:",
            "            raise  # pragma: no cover",
            "    else:",
            "        if stat.S_ISSOCK(st.st_mode):",
            "            try:",
            "                os.remove(path)",
            "            except OSError:  # pragma: no cover",
            "                # avoid race condition error during tests",
            "                pass",
            "",
            "",
            "class Error:",
            "    code = 500",
            "    reason = \"Internal Server Error\"",
            "",
            "    def __init__(self, body):",
            "        self.body = body",
            "",
            "    def to_response(self):",
            "        status = \"%s %s\" % (self.code, self.reason)",
            "        body = \"%s\\r\\n\\r\\n%s\" % (self.reason, self.body)",
            "        tag = \"\\r\\n\\r\\n(generated by waitress)\"",
            "        body = body + tag",
            "        headers = [(\"Content-Type\", \"text/plain\")]",
            "",
            "        return status, headers, body",
            "",
            "    def wsgi_response(self, environ, start_response):",
            "        status, headers, body = self.to_response()",
            "        start_response(status, headers)",
            "        yield body",
            "",
            "",
            "class BadRequest(Error):",
            "    code = 400",
            "    reason = \"Bad Request\"",
            "",
            "",
            "class RequestHeaderFieldsTooLarge(BadRequest):",
            "    code = 431",
            "    reason = \"Request Header Fields Too Large\"",
            "",
            "",
            "class RequestEntityTooLarge(BadRequest):",
            "    code = 413",
            "    reason = \"Request Entity Too Large\"",
            "",
            "",
            "class InternalServerError(Error):",
            "    code = 500",
            "    reason = \"Internal Server Error\"",
            "",
            "",
            "class ServerNotImplemented(Error):",
            "    code = 501",
            "    reason = \"Not Implemented\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [],
            "219": [],
            "220": [],
            "221": [],
            "222": [
                "vchar_re"
            ],
            "223": [],
            "224": [],
            "225": [],
            "226": [],
            "227": [],
            "228": [],
            "229": [
                "obs_text_re"
            ],
            "230": [],
            "231": [],
            "232": [
                "qdtext_re"
            ],
            "233": [],
            "234": [
                "quoted_pair_re"
            ],
            "235": [
                "quoted_string_re"
            ],
            "236": [],
            "237": [
                "quoted_string"
            ],
            "238": [
                "quoted_pair"
            ],
            "239": [],
            "240": [],
            "244": [
                "undquote"
            ],
            "252": [
                "undquote"
            ]
        },
        "addLocation": []
    }
}