{
    "octavia/common/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "                deprecated_for_removal=True,"
            },
            "1": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "                deprecated_reason='Superseded by amp_image_tag option.',"
            },
            "2": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "                help=_('Glance image id for the Amphora image to boot')),"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    cfg.StrOpt('amp_image_owner_id',"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+               default='',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+               help=_('Restrict glance image selection to a specific '"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+                      'owner ID.  This is a recommended security setting.')),"
            },
            "7": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "     cfg.StrOpt('amp_ssh_key_name',"
            },
            "8": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "                default='',"
            },
            "9": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "                help=_('SSH key name used to boot the Amphora')),"
            }
        },
        "frontPatchFile": [
            "# Copyright 2011 VMware, Inc., 2014 A10 Networks",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Routines for configuring Octavia",
            "\"\"\"",
            "",
            "from oslo_config import cfg",
            "from oslo_db import options as db_options",
            "from oslo_log import log as logging",
            "import oslo_messaging as messaging",
            "",
            "from octavia.common import constants",
            "from octavia.common import utils",
            "from octavia.i18n import _LI",
            "from octavia import version",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "core_opts = [",
            "    cfg.IPOpt('bind_host', default='127.0.0.1',",
            "              help=_(\"The host IP to bind to\")),",
            "    cfg.PortOpt('bind_port', default=9876,",
            "                help=_(\"The port to bind to\")),",
            "    cfg.StrOpt('api_handler', default='queue_producer',",
            "               help=_(\"The handler that the API communicates with\")),",
            "    cfg.StrOpt('api_paste_config', default=\"api-paste.ini\",",
            "               help=_(\"The API paste config file to use\")),",
            "    cfg.StrOpt('api_extensions_path', default=\"\",",
            "               help=_(\"The path for API extensions\")),",
            "    cfg.StrOpt('auth_strategy', default='keystone',",
            "               help=_(\"The type of authentication to use\")),",
            "    cfg.BoolOpt('allow_bulk', default=True,",
            "                help=_(\"Allow the usage of the bulk API\")),",
            "    cfg.BoolOpt('allow_pagination', default=False,",
            "                help=_(\"Allow the usage of the pagination\")),",
            "    cfg.BoolOpt('allow_sorting', default=False,",
            "                help=_(\"Allow the usage of the sorting\")),",
            "    cfg.StrOpt('pagination_max_limit', default=\"-1\",",
            "               help=_(\"The maximum number of items returned in a single \"",
            "                      \"response. The string 'infinite' or a negative \"",
            "                      \"integer value means 'no limit'\")),",
            "    cfg.StrOpt('host', default=utils.get_hostname(),",
            "               help=_(\"The hostname Octavia is running on\")),",
            "    cfg.StrOpt('octavia_plugins',",
            "               default='hot_plug_plugin',",
            "               help=_('Name of the controller plugin to use'))",
            "]",
            "",
            "# Options only used by the amphora agent",
            "amphora_agent_opts = [",
            "    cfg.StrOpt('agent_server_ca', default='/etc/octavia/certs/client_ca.pem',",
            "               help=_(\"The ca which signed the client certificates\")),",
            "    cfg.StrOpt('agent_server_cert', default='/etc/octavia/certs/server.pem',",
            "               help=_(\"The server certificate for the agent.py server \"",
            "                      \"to use\")),",
            "    cfg.StrOpt('agent_server_network_dir',",
            "               default='/etc/netns/{}/network/interfaces.d/'.format(",
            "                   constants.AMPHORA_NAMESPACE),",
            "               help=_(\"The directory where new network interfaces \"",
            "                      \"are located\")),",
            "    cfg.StrOpt('agent_server_network_file',",
            "               help=_(\"The file where the network interfaces are located. \"",
            "                      \"Specifying this will override any value set for \"",
            "                      \"agent_server_network_dir.\")),",
            "    # Do not specify in octavia.conf, loaded at runtime",
            "    cfg.StrOpt('amphora_id', help=_(\"The amphora ID.\")),",
            "]",
            "",
            "networking_opts = [",
            "    cfg.StrOpt('lb_network_name', help=_('Name of amphora internal network')),",
            "    cfg.IntOpt('max_retries', default=15,",
            "               help=_('The maximum attempts to retry an action with the '",
            "                      'networking service.')),",
            "    cfg.IntOpt('retry_interval', default=1,",
            "               help=_('Seconds to wait before retrying an action with the '",
            "                      'networking service.')),",
            "    cfg.IntOpt('port_detach_timeout', default=300,",
            "               help=_('Seconds to wait for a port to detach from an '",
            "                      'amphora.'))",
            "]",
            "",
            "healthmanager_opts = [",
            "    cfg.IPOpt('bind_ip', default='127.0.0.1',",
            "              help=_('IP address the controller will listen on for '",
            "                     'heart beats')),",
            "    cfg.PortOpt('bind_port', default=5555,",
            "                help=_('Port number the controller will listen on'",
            "                       'for heart beats')),",
            "    cfg.IntOpt('failover_threads',",
            "               default=10,",
            "               help=_('Number of threads performing amphora failovers.')),",
            "    cfg.IntOpt('status_update_threads',",
            "               default=50,",
            "               help=_('Number of threads performing amphora status update.')),",
            "    cfg.StrOpt('heartbeat_key',",
            "               help=_('key used to validate amphora sending'",
            "                      'the message'), secret=True),",
            "    cfg.IntOpt('heartbeat_timeout',",
            "               default=60,",
            "               help=_('Interval, in seconds, to wait before failing over an '",
            "                      'amphora.')),",
            "    cfg.IntOpt('health_check_interval',",
            "               default=3,",
            "               help=_('Sleep time between health checks in seconds.')),",
            "    cfg.IntOpt('sock_rlimit', default=0,",
            "               help=_(' sets the value of the heartbeat recv buffer')),",
            "",
            "    # Used by the health manager on the amphora",
            "    cfg.ListOpt('controller_ip_port_list',",
            "                help=_('List of controller ip and port pairs for the '",
            "                       'heartbeat receivers. Example 127.0.0.1:5555, '",
            "                       '192.168.0.1:5555'),",
            "                default=[]),",
            "    cfg.IntOpt('heartbeat_interval',",
            "               default=10,",
            "               help=_('Sleep time between sending heartbeats.')),",
            "    cfg.StrOpt('event_streamer_driver',",
            "               help=_('Specifies which driver to use for the event_streamer '",
            "                      'for syncing the octavia and neutron_lbaas dbs. If you '",
            "                      'don\\'t need to sync the database or are running '",
            "                      'octavia in stand alone mode use the '",
            "                      'noop_event_streamer'),",
            "               default='noop_event_streamer')]",
            "",
            "oslo_messaging_opts = [",
            "    cfg.StrOpt('topic'),",
            "    cfg.StrOpt('event_stream_topic',",
            "               default='neutron_lbaas_event',",
            "               help=_('topic name for communicating events through a queue')),",
            "]",
            "",
            "keystone_authtoken_v3_opts = [",
            "    cfg.StrOpt('admin_user_domain', default='default',",
            "               help=_('Admin user keystone authentication domain')),",
            "    cfg.StrOpt('admin_project_domain', default='default',",
            "               help=_('Admin project keystone authentication domain'))",
            "]",
            "",
            "haproxy_amphora_opts = [",
            "    cfg.StrOpt('base_path',",
            "               default='/var/lib/octavia',",
            "               help=_('Base directory for amphora files.')),",
            "    cfg.StrOpt('base_cert_dir',",
            "               default='/var/lib/octavia/certs',",
            "               help=_('Base directory for cert storage.')),",
            "    cfg.StrOpt('haproxy_template', help=_('Custom haproxy template.')),",
            "    cfg.IntOpt('connection_max_retries',",
            "               default=300,",
            "               help=_('Retry threshold for connecting to amphorae.')),",
            "    cfg.IntOpt('connection_retry_interval',",
            "               default=5,",
            "               help=_('Retry timeout between connection attempts in '",
            "                      'seconds.')),",
            "    cfg.StrOpt('haproxy_stick_size', default='10k',",
            "               help=_('Size of the HAProxy stick table. Accepts k, m, g '",
            "                      'suffixes.  Example: 10k')),",
            "",
            "    # REST server",
            "    cfg.IPOpt('bind_host', default='0.0.0.0',  # nosec",
            "              help=_(\"The host IP to bind to\")),",
            "    cfg.PortOpt('bind_port', default=9443,",
            "                help=_(\"The port to bind to\")),",
            "    cfg.StrOpt('haproxy_cmd', default='/usr/sbin/haproxy',",
            "               help=_(\"The full path to haproxy\")),",
            "    cfg.IntOpt('respawn_count', default=2,",
            "               help=_(\"The respawn count for haproxy's upstart script\")),",
            "    cfg.IntOpt('respawn_interval', default=2,",
            "               help=_(\"The respawn interval for haproxy's upstart script\")),",
            "    cfg.FloatOpt('rest_request_conn_timeout', default=10,",
            "                 help=_(\"The time in seconds to wait for a REST API \"",
            "                        \"to connect.\")),",
            "    cfg.FloatOpt('rest_request_read_timeout', default=60,",
            "                 help=_(\"The time in seconds to wait for a REST API \"",
            "                        \"response.\")),",
            "    # REST client",
            "    cfg.StrOpt('client_cert', default='/etc/octavia/certs/client.pem',",
            "               help=_(\"The client certificate to talk to the agent\")),",
            "    cfg.StrOpt('server_ca', default='/etc/octavia/certs/server_ca.pem',",
            "               help=_(\"The ca which signed the server certificates\")),",
            "    cfg.BoolOpt('use_upstart', default=True,",
            "                help=_(\"If False, use sysvinit.\")),",
            "]",
            "",
            "controller_worker_opts = [",
            "    cfg.IntOpt('amp_active_retries',",
            "               default=10,",
            "               help=_('Retry attempts to wait for Amphora to become active')),",
            "    cfg.IntOpt('amp_active_wait_sec',",
            "               default=10,",
            "               help=_('Seconds to wait between checks on whether an Amphora '",
            "                      'has become active')),",
            "    cfg.StrOpt('amp_flavor_id',",
            "               default='',",
            "               help=_('Nova instance flavor id for the Amphora')),",
            "    cfg.StrOpt('amp_image_tag',",
            "               default='',",
            "               help=_('Glance image tag for the Amphora image to boot. '",
            "                      'Use this option to be able to update the image '",
            "                      'without reconfiguring Octavia. '",
            "                      'Ignored if amp_image_id is defined.')),",
            "    cfg.StrOpt('amp_image_id',",
            "               default='',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='Superseded by amp_image_tag option.',",
            "               help=_('Glance image id for the Amphora image to boot')),",
            "    cfg.StrOpt('amp_ssh_key_name',",
            "               default='',",
            "               help=_('SSH key name used to boot the Amphora')),",
            "    cfg.BoolOpt('amp_ssh_access_allowed',",
            "                default=True,",
            "                help=_('Determines whether or not to allow access '",
            "                       'to the Amphorae')),",
            "    cfg.ListOpt('amp_boot_network_list',",
            "                default='',",
            "                help=_('List of networks to attach to the Amphorae. '",
            "                       'All networks defined in the list will '",
            "                       'be attached to each amphora.')),",
            "    cfg.StrOpt('amp_network',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='Replaced by amp_boot_network_list.',",
            "               default='',",
            "               help=_('Network to attach to the Amphorae.')),",
            "    cfg.ListOpt('amp_secgroup_list',",
            "                default='',",
            "                help=_('List of security groups to attach to the Amphora.')),",
            "    cfg.StrOpt('client_ca',",
            "               default='/etc/octavia/certs/ca_01.pem',",
            "               help=_('Client CA for the amphora agent to use')),",
            "    cfg.StrOpt('amphora_driver',",
            "               default='amphora_noop_driver',",
            "               help=_('Name of the amphora driver to use')),",
            "    cfg.StrOpt('compute_driver',",
            "               default='compute_noop_driver',",
            "               help=_('Name of the compute driver to use')),",
            "    cfg.StrOpt('network_driver',",
            "               default='network_noop_driver',",
            "               help=_('Name of the network driver to use')),",
            "    cfg.StrOpt('cert_generator',",
            "               default='local_cert_generator',",
            "               help=_('Name of the cert generator to use')),",
            "    cfg.StrOpt('loadbalancer_topology',",
            "               default=constants.TOPOLOGY_SINGLE,",
            "               choices=constants.SUPPORTED_LB_TOPOLOGIES,",
            "               help=_('Load balancer topology configuration. '",
            "                      'SINGLE - One amphora per load balancer. '",
            "                      'ACTIVE_STANDBY - Two amphora per load balancer.')),",
            "    cfg.BoolOpt('user_data_config_drive', default=False,",
            "                help=_('If True, build cloud-init user-data that is passed '",
            "                       'to the config drive on Amphora boot instead of '",
            "                       'personality files. If False, utilize personality '",
            "                       'files.'))",
            "]",
            "",
            "task_flow_opts = [",
            "    cfg.StrOpt('engine',",
            "               default='serial',",
            "               help=_('TaskFlow engine to use')),",
            "    cfg.IntOpt('max_workers',",
            "               default=5,",
            "               help=_('The maximum number of workers'))",
            "]",
            "",
            "core_cli_opts = []",
            "",
            "certificate_opts = [",
            "    cfg.StrOpt('cert_manager',",
            "               default='barbican_cert_manager',",
            "               help='Name of the cert manager to use'),",
            "    cfg.StrOpt('cert_generator',",
            "               default='local_cert_generator',",
            "               help='Name of the cert generator to use'),",
            "    cfg.StrOpt('barbican_auth',",
            "               default='barbican_acl_auth',",
            "               help='Name of the Barbican authentication method to use'),",
            "    cfg.StrOpt('region_name',",
            "               help='Region in Identity service catalog to use for '",
            "                    'communication with the barbican service.'),",
            "    cfg.StrOpt('endpoint_type',",
            "               default='publicURL',",
            "               help='The endpoint_type to be used for barbican service.')",
            "]",
            "",
            "house_keeping_opts = [",
            "    cfg.IntOpt('spare_check_interval',",
            "               default=30,",
            "               help=_('Spare check interval in seconds')),",
            "    cfg.IntOpt('spare_amphora_pool_size',",
            "               default=0,",
            "               help=_('Number of spare amphorae')),",
            "    cfg.IntOpt('cleanup_interval',",
            "               default=30,",
            "               help=_('DB cleanup interval in seconds')),",
            "    cfg.IntOpt('amphora_expiry_age',",
            "               default=604800,",
            "               help=_('Amphora expiry age in seconds')),",
            "    cfg.IntOpt('load_balancer_expiry_age',",
            "               default=604800,",
            "               help=_('Load balancer expiry age in seconds')),",
            "    cfg.IntOpt('cert_interval',",
            "               default=3600,",
            "               help=_('Certificate check interval in seconds')),",
            "    # 14 days for cert expiry buffer",
            "    cfg.IntOpt('cert_expiry_buffer',",
            "               default=1209600,",
            "               help=_('Seconds until certificate expiration')),",
            "    cfg.IntOpt('cert_rotate_threads',",
            "               default=10,",
            "               help=_('Number of threads performing amphora certificate'",
            "                      ' rotation'))",
            "]",
            "",
            "anchor_opts = [",
            "    cfg.StrOpt('url',",
            "               default='http://localhost:9999/v1/sign/default',",
            "               help=_('Anchor URL')),",
            "    cfg.StrOpt('username',",
            "               help=_('Anchor username')),",
            "    cfg.StrOpt('password',",
            "               help=_('Anchor password'),",
            "               secret=True)",
            "]",
            "",
            "keepalived_vrrp_opts = [",
            "    cfg.IntOpt('vrrp_advert_int',",
            "               default=1,",
            "               help=_('Amphora role and priority advertisement interval '",
            "                      'in seconds.')),",
            "    cfg.IntOpt('vrrp_check_interval',",
            "               default=5,",
            "               help=_('VRRP health check script run interval in seconds.')),",
            "    cfg.IntOpt('vrrp_fail_count',",
            "               default=2,",
            "               help=_('Number of successive failures before transition to a '",
            "                      'fail state.')),",
            "    cfg.IntOpt('vrrp_success_count',",
            "               default=2,",
            "               help=_('Number of consecutive successes before transition to a '",
            "                      'success state.')),",
            "    cfg.IntOpt('vrrp_garp_refresh_interval',",
            "               default=5,",
            "               help=_('Time in seconds between gratuitous ARP announcements '",
            "                      'from the MASTER.')),",
            "    cfg.IntOpt('vrrp_garp_refresh_count',",
            "               default=2,",
            "               help=_('Number of gratuitous ARP announcements to make on '",
            "                      'each refresh interval.'))",
            "",
            "]",
            "",
            "nova_opts = [",
            "    cfg.StrOpt('service_name',",
            "               help=_('The name of the nova service in the keystone catalog')),",
            "    cfg.StrOpt('endpoint', help=_('A new endpoint to override the endpoint '",
            "                                  'in the keystone catalog.')),",
            "    cfg.StrOpt('region_name',",
            "               help=_('Region in Identity service catalog to use for '",
            "                      'communication with the OpenStack services.')),",
            "    cfg.StrOpt('endpoint_type', default='publicURL',",
            "               help=_('Endpoint interface in identity service to use')),",
            "    cfg.StrOpt('ca_certificates_file',",
            "               help=_('CA certificates file path')),",
            "    cfg.BoolOpt('insecure',",
            "                default=False,",
            "                help=_('Disable certificate validation on SSL connections ')),",
            "    cfg.BoolOpt('enable_anti_affinity', default=False,",
            "                help=_('Flag to indicate if nova anti-affinity feature is '",
            "                       'turned on.'))",
            "]",
            "",
            "neutron_opts = [",
            "    cfg.StrOpt('service_name',",
            "               help=_('The name of the neutron service in the '",
            "                      'keystone catalog')),",
            "    cfg.StrOpt('endpoint', help=_('A new endpoint to override the endpoint '",
            "                                  'in the keystone catalog.')),",
            "    cfg.StrOpt('region_name',",
            "               help=_('Region in Identity service catalog to use for '",
            "                      'communication with the OpenStack services.')),",
            "    cfg.StrOpt('endpoint_type', default='publicURL',",
            "               help=_('Endpoint interface in identity service to use')),",
            "    cfg.StrOpt('ca_certificates_file',",
            "               help=_('CA certificates file path')),",
            "    cfg.BoolOpt('insecure',",
            "                default=False,",
            "                help=_('Disable certificate validation on SSL connections ')),",
            "]",
            "",
            "glance_opts = [",
            "    cfg.StrOpt('service_name',",
            "               help=_('The name of the glance service in the '",
            "                      'keystone catalog')),",
            "    cfg.StrOpt('endpoint', help=_('A new endpoint to override the endpoint '",
            "                                  'in the keystone catalog.')),",
            "    cfg.StrOpt('region_name',",
            "               help=_('Region in Identity service catalog to use for '",
            "                      'communication with the OpenStack services.')),",
            "    cfg.StrOpt('endpoint_type', default='publicURL',",
            "               help=_('Endpoint interface in identity service to use')),",
            "    cfg.StrOpt('ca_certificates_file',",
            "               help=_('CA certificates file path')),",
            "    cfg.BoolOpt('insecure',",
            "                default=False,",
            "                help=_('Disable certificate validation on SSL connections ')),",
            "]",
            "",
            "",
            "# Register the configuration options",
            "cfg.CONF.register_opts(core_opts)",
            "cfg.CONF.register_opts(amphora_agent_opts, group='amphora_agent')",
            "cfg.CONF.register_opts(networking_opts, group='networking')",
            "cfg.CONF.register_opts(oslo_messaging_opts, group='oslo_messaging')",
            "cfg.CONF.register_opts(haproxy_amphora_opts, group='haproxy_amphora')",
            "cfg.CONF.register_opts(controller_worker_opts, group='controller_worker')",
            "cfg.CONF.register_opts(keepalived_vrrp_opts, group='keepalived_vrrp')",
            "cfg.CONF.register_opts(task_flow_opts, group='task_flow')",
            "cfg.CONF.register_opts(oslo_messaging_opts, group='oslo_messaging')",
            "cfg.CONF.register_opts(house_keeping_opts, group='house_keeping')",
            "cfg.CONF.register_opts(anchor_opts, group='anchor')",
            "cfg.CONF.register_cli_opts(core_cli_opts)",
            "cfg.CONF.register_opts(certificate_opts, group='certificates')",
            "cfg.CONF.register_cli_opts(healthmanager_opts, group='health_manager')",
            "cfg.CONF.import_group('keystone_authtoken', 'keystonemiddleware.auth_token')",
            "cfg.CONF.register_opts(keystone_authtoken_v3_opts,",
            "                       group='keystone_authtoken_v3')",
            "cfg.CONF.register_opts(nova_opts, group='nova')",
            "cfg.CONF.register_opts(glance_opts, group='glance')",
            "cfg.CONF.register_opts(neutron_opts, group='neutron')",
            "",
            "",
            "# Ensure that the control exchange is set correctly",
            "messaging.set_transport_defaults(control_exchange='octavia')",
            "_SQL_CONNECTION_DEFAULT = 'sqlite://'",
            "# Update the default QueuePool parameters. These can be tweaked by the",
            "# configuration variables - max_pool_size, max_overflow and pool_timeout",
            "db_options.set_defaults(cfg.CONF, connection=_SQL_CONNECTION_DEFAULT,",
            "                        max_pool_size=10, max_overflow=20, pool_timeout=10)",
            "",
            "logging.register_options(cfg.CONF)",
            "",
            "",
            "def init(args, **kwargs):",
            "    cfg.CONF(args=args, project='octavia',",
            "             version='%%prog %s' % version.version_info.release_string(),",
            "             **kwargs)",
            "",
            "",
            "def setup_logging(conf):",
            "    \"\"\"Sets up the logging options for a log with supplied name.",
            "",
            "    :param conf: a cfg.ConfOpts object",
            "    \"\"\"",
            "    product_name = \"octavia\"",
            "    logging.setup(conf, product_name)",
            "    LOG.info(_LI(\"Logging enabled!\"))",
            "",
            "",
            "# def load_paste_app(app_name):",
            "#     \"\"\"Builds and returns a WSGI app from a paste config file.",
            "",
            "#     :param app_name: Name of the application to load",
            "#     :raises ConfigFilesNotFoundError when config file cannot be located",
            "#     :raises RuntimeError when application cannot be loaded from config file",
            "#     \"\"\"",
            "",
            "#     config_path = cfg.CONF.find_file(cfg.CONF.api_paste_config)",
            "#     if not config_path:",
            "#         raise cfg.ConfigFilesNotFoundError(",
            "#             config_files=[cfg.CONF.api_paste_config])",
            "#     config_path = os.path.abspath(config_path)",
            "#     LOG.info(_LI(\"Config paste file: %s\"), config_path)",
            "",
            "#     try:",
            "#         app = deploy.loadapp(\"config:%s\" % config_path, name=app_name)",
            "#     except (LookupError, ImportError):",
            "#         msg = (_(\"Unable to load %(app_name)s from \"",
            "#                  \"configuration file %(config_path)s.\") %",
            "#                {'app_name': app_name,",
            "#                 'config_path': config_path})",
            "#         LOG.exception(msg)",
            "#         raise RuntimeError(msg)",
            "#     return app"
        ],
        "afterPatchFile": [
            "# Copyright 2011 VMware, Inc., 2014 A10 Networks",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Routines for configuring Octavia",
            "\"\"\"",
            "",
            "from oslo_config import cfg",
            "from oslo_db import options as db_options",
            "from oslo_log import log as logging",
            "import oslo_messaging as messaging",
            "",
            "from octavia.common import constants",
            "from octavia.common import utils",
            "from octavia.i18n import _LI",
            "from octavia import version",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "core_opts = [",
            "    cfg.IPOpt('bind_host', default='127.0.0.1',",
            "              help=_(\"The host IP to bind to\")),",
            "    cfg.PortOpt('bind_port', default=9876,",
            "                help=_(\"The port to bind to\")),",
            "    cfg.StrOpt('api_handler', default='queue_producer',",
            "               help=_(\"The handler that the API communicates with\")),",
            "    cfg.StrOpt('api_paste_config', default=\"api-paste.ini\",",
            "               help=_(\"The API paste config file to use\")),",
            "    cfg.StrOpt('api_extensions_path', default=\"\",",
            "               help=_(\"The path for API extensions\")),",
            "    cfg.StrOpt('auth_strategy', default='keystone',",
            "               help=_(\"The type of authentication to use\")),",
            "    cfg.BoolOpt('allow_bulk', default=True,",
            "                help=_(\"Allow the usage of the bulk API\")),",
            "    cfg.BoolOpt('allow_pagination', default=False,",
            "                help=_(\"Allow the usage of the pagination\")),",
            "    cfg.BoolOpt('allow_sorting', default=False,",
            "                help=_(\"Allow the usage of the sorting\")),",
            "    cfg.StrOpt('pagination_max_limit', default=\"-1\",",
            "               help=_(\"The maximum number of items returned in a single \"",
            "                      \"response. The string 'infinite' or a negative \"",
            "                      \"integer value means 'no limit'\")),",
            "    cfg.StrOpt('host', default=utils.get_hostname(),",
            "               help=_(\"The hostname Octavia is running on\")),",
            "    cfg.StrOpt('octavia_plugins',",
            "               default='hot_plug_plugin',",
            "               help=_('Name of the controller plugin to use'))",
            "]",
            "",
            "# Options only used by the amphora agent",
            "amphora_agent_opts = [",
            "    cfg.StrOpt('agent_server_ca', default='/etc/octavia/certs/client_ca.pem',",
            "               help=_(\"The ca which signed the client certificates\")),",
            "    cfg.StrOpt('agent_server_cert', default='/etc/octavia/certs/server.pem',",
            "               help=_(\"The server certificate for the agent.py server \"",
            "                      \"to use\")),",
            "    cfg.StrOpt('agent_server_network_dir',",
            "               default='/etc/netns/{}/network/interfaces.d/'.format(",
            "                   constants.AMPHORA_NAMESPACE),",
            "               help=_(\"The directory where new network interfaces \"",
            "                      \"are located\")),",
            "    cfg.StrOpt('agent_server_network_file',",
            "               help=_(\"The file where the network interfaces are located. \"",
            "                      \"Specifying this will override any value set for \"",
            "                      \"agent_server_network_dir.\")),",
            "    # Do not specify in octavia.conf, loaded at runtime",
            "    cfg.StrOpt('amphora_id', help=_(\"The amphora ID.\")),",
            "]",
            "",
            "networking_opts = [",
            "    cfg.StrOpt('lb_network_name', help=_('Name of amphora internal network')),",
            "    cfg.IntOpt('max_retries', default=15,",
            "               help=_('The maximum attempts to retry an action with the '",
            "                      'networking service.')),",
            "    cfg.IntOpt('retry_interval', default=1,",
            "               help=_('Seconds to wait before retrying an action with the '",
            "                      'networking service.')),",
            "    cfg.IntOpt('port_detach_timeout', default=300,",
            "               help=_('Seconds to wait for a port to detach from an '",
            "                      'amphora.'))",
            "]",
            "",
            "healthmanager_opts = [",
            "    cfg.IPOpt('bind_ip', default='127.0.0.1',",
            "              help=_('IP address the controller will listen on for '",
            "                     'heart beats')),",
            "    cfg.PortOpt('bind_port', default=5555,",
            "                help=_('Port number the controller will listen on'",
            "                       'for heart beats')),",
            "    cfg.IntOpt('failover_threads',",
            "               default=10,",
            "               help=_('Number of threads performing amphora failovers.')),",
            "    cfg.IntOpt('status_update_threads',",
            "               default=50,",
            "               help=_('Number of threads performing amphora status update.')),",
            "    cfg.StrOpt('heartbeat_key',",
            "               help=_('key used to validate amphora sending'",
            "                      'the message'), secret=True),",
            "    cfg.IntOpt('heartbeat_timeout',",
            "               default=60,",
            "               help=_('Interval, in seconds, to wait before failing over an '",
            "                      'amphora.')),",
            "    cfg.IntOpt('health_check_interval',",
            "               default=3,",
            "               help=_('Sleep time between health checks in seconds.')),",
            "    cfg.IntOpt('sock_rlimit', default=0,",
            "               help=_(' sets the value of the heartbeat recv buffer')),",
            "",
            "    # Used by the health manager on the amphora",
            "    cfg.ListOpt('controller_ip_port_list',",
            "                help=_('List of controller ip and port pairs for the '",
            "                       'heartbeat receivers. Example 127.0.0.1:5555, '",
            "                       '192.168.0.1:5555'),",
            "                default=[]),",
            "    cfg.IntOpt('heartbeat_interval',",
            "               default=10,",
            "               help=_('Sleep time between sending heartbeats.')),",
            "    cfg.StrOpt('event_streamer_driver',",
            "               help=_('Specifies which driver to use for the event_streamer '",
            "                      'for syncing the octavia and neutron_lbaas dbs. If you '",
            "                      'don\\'t need to sync the database or are running '",
            "                      'octavia in stand alone mode use the '",
            "                      'noop_event_streamer'),",
            "               default='noop_event_streamer')]",
            "",
            "oslo_messaging_opts = [",
            "    cfg.StrOpt('topic'),",
            "    cfg.StrOpt('event_stream_topic',",
            "               default='neutron_lbaas_event',",
            "               help=_('topic name for communicating events through a queue')),",
            "]",
            "",
            "keystone_authtoken_v3_opts = [",
            "    cfg.StrOpt('admin_user_domain', default='default',",
            "               help=_('Admin user keystone authentication domain')),",
            "    cfg.StrOpt('admin_project_domain', default='default',",
            "               help=_('Admin project keystone authentication domain'))",
            "]",
            "",
            "haproxy_amphora_opts = [",
            "    cfg.StrOpt('base_path',",
            "               default='/var/lib/octavia',",
            "               help=_('Base directory for amphora files.')),",
            "    cfg.StrOpt('base_cert_dir',",
            "               default='/var/lib/octavia/certs',",
            "               help=_('Base directory for cert storage.')),",
            "    cfg.StrOpt('haproxy_template', help=_('Custom haproxy template.')),",
            "    cfg.IntOpt('connection_max_retries',",
            "               default=300,",
            "               help=_('Retry threshold for connecting to amphorae.')),",
            "    cfg.IntOpt('connection_retry_interval',",
            "               default=5,",
            "               help=_('Retry timeout between connection attempts in '",
            "                      'seconds.')),",
            "    cfg.StrOpt('haproxy_stick_size', default='10k',",
            "               help=_('Size of the HAProxy stick table. Accepts k, m, g '",
            "                      'suffixes.  Example: 10k')),",
            "",
            "    # REST server",
            "    cfg.IPOpt('bind_host', default='0.0.0.0',  # nosec",
            "              help=_(\"The host IP to bind to\")),",
            "    cfg.PortOpt('bind_port', default=9443,",
            "                help=_(\"The port to bind to\")),",
            "    cfg.StrOpt('haproxy_cmd', default='/usr/sbin/haproxy',",
            "               help=_(\"The full path to haproxy\")),",
            "    cfg.IntOpt('respawn_count', default=2,",
            "               help=_(\"The respawn count for haproxy's upstart script\")),",
            "    cfg.IntOpt('respawn_interval', default=2,",
            "               help=_(\"The respawn interval for haproxy's upstart script\")),",
            "    cfg.FloatOpt('rest_request_conn_timeout', default=10,",
            "                 help=_(\"The time in seconds to wait for a REST API \"",
            "                        \"to connect.\")),",
            "    cfg.FloatOpt('rest_request_read_timeout', default=60,",
            "                 help=_(\"The time in seconds to wait for a REST API \"",
            "                        \"response.\")),",
            "    # REST client",
            "    cfg.StrOpt('client_cert', default='/etc/octavia/certs/client.pem',",
            "               help=_(\"The client certificate to talk to the agent\")),",
            "    cfg.StrOpt('server_ca', default='/etc/octavia/certs/server_ca.pem',",
            "               help=_(\"The ca which signed the server certificates\")),",
            "    cfg.BoolOpt('use_upstart', default=True,",
            "                help=_(\"If False, use sysvinit.\")),",
            "]",
            "",
            "controller_worker_opts = [",
            "    cfg.IntOpt('amp_active_retries',",
            "               default=10,",
            "               help=_('Retry attempts to wait for Amphora to become active')),",
            "    cfg.IntOpt('amp_active_wait_sec',",
            "               default=10,",
            "               help=_('Seconds to wait between checks on whether an Amphora '",
            "                      'has become active')),",
            "    cfg.StrOpt('amp_flavor_id',",
            "               default='',",
            "               help=_('Nova instance flavor id for the Amphora')),",
            "    cfg.StrOpt('amp_image_tag',",
            "               default='',",
            "               help=_('Glance image tag for the Amphora image to boot. '",
            "                      'Use this option to be able to update the image '",
            "                      'without reconfiguring Octavia. '",
            "                      'Ignored if amp_image_id is defined.')),",
            "    cfg.StrOpt('amp_image_id',",
            "               default='',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='Superseded by amp_image_tag option.',",
            "               help=_('Glance image id for the Amphora image to boot')),",
            "    cfg.StrOpt('amp_image_owner_id',",
            "               default='',",
            "               help=_('Restrict glance image selection to a specific '",
            "                      'owner ID.  This is a recommended security setting.')),",
            "    cfg.StrOpt('amp_ssh_key_name',",
            "               default='',",
            "               help=_('SSH key name used to boot the Amphora')),",
            "    cfg.BoolOpt('amp_ssh_access_allowed',",
            "                default=True,",
            "                help=_('Determines whether or not to allow access '",
            "                       'to the Amphorae')),",
            "    cfg.ListOpt('amp_boot_network_list',",
            "                default='',",
            "                help=_('List of networks to attach to the Amphorae. '",
            "                       'All networks defined in the list will '",
            "                       'be attached to each amphora.')),",
            "    cfg.StrOpt('amp_network',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='Replaced by amp_boot_network_list.',",
            "               default='',",
            "               help=_('Network to attach to the Amphorae.')),",
            "    cfg.ListOpt('amp_secgroup_list',",
            "                default='',",
            "                help=_('List of security groups to attach to the Amphora.')),",
            "    cfg.StrOpt('client_ca',",
            "               default='/etc/octavia/certs/ca_01.pem',",
            "               help=_('Client CA for the amphora agent to use')),",
            "    cfg.StrOpt('amphora_driver',",
            "               default='amphora_noop_driver',",
            "               help=_('Name of the amphora driver to use')),",
            "    cfg.StrOpt('compute_driver',",
            "               default='compute_noop_driver',",
            "               help=_('Name of the compute driver to use')),",
            "    cfg.StrOpt('network_driver',",
            "               default='network_noop_driver',",
            "               help=_('Name of the network driver to use')),",
            "    cfg.StrOpt('cert_generator',",
            "               default='local_cert_generator',",
            "               help=_('Name of the cert generator to use')),",
            "    cfg.StrOpt('loadbalancer_topology',",
            "               default=constants.TOPOLOGY_SINGLE,",
            "               choices=constants.SUPPORTED_LB_TOPOLOGIES,",
            "               help=_('Load balancer topology configuration. '",
            "                      'SINGLE - One amphora per load balancer. '",
            "                      'ACTIVE_STANDBY - Two amphora per load balancer.')),",
            "    cfg.BoolOpt('user_data_config_drive', default=False,",
            "                help=_('If True, build cloud-init user-data that is passed '",
            "                       'to the config drive on Amphora boot instead of '",
            "                       'personality files. If False, utilize personality '",
            "                       'files.'))",
            "]",
            "",
            "task_flow_opts = [",
            "    cfg.StrOpt('engine',",
            "               default='serial',",
            "               help=_('TaskFlow engine to use')),",
            "    cfg.IntOpt('max_workers',",
            "               default=5,",
            "               help=_('The maximum number of workers'))",
            "]",
            "",
            "core_cli_opts = []",
            "",
            "certificate_opts = [",
            "    cfg.StrOpt('cert_manager',",
            "               default='barbican_cert_manager',",
            "               help='Name of the cert manager to use'),",
            "    cfg.StrOpt('cert_generator',",
            "               default='local_cert_generator',",
            "               help='Name of the cert generator to use'),",
            "    cfg.StrOpt('barbican_auth',",
            "               default='barbican_acl_auth',",
            "               help='Name of the Barbican authentication method to use'),",
            "    cfg.StrOpt('region_name',",
            "               help='Region in Identity service catalog to use for '",
            "                    'communication with the barbican service.'),",
            "    cfg.StrOpt('endpoint_type',",
            "               default='publicURL',",
            "               help='The endpoint_type to be used for barbican service.')",
            "]",
            "",
            "house_keeping_opts = [",
            "    cfg.IntOpt('spare_check_interval',",
            "               default=30,",
            "               help=_('Spare check interval in seconds')),",
            "    cfg.IntOpt('spare_amphora_pool_size',",
            "               default=0,",
            "               help=_('Number of spare amphorae')),",
            "    cfg.IntOpt('cleanup_interval',",
            "               default=30,",
            "               help=_('DB cleanup interval in seconds')),",
            "    cfg.IntOpt('amphora_expiry_age',",
            "               default=604800,",
            "               help=_('Amphora expiry age in seconds')),",
            "    cfg.IntOpt('load_balancer_expiry_age',",
            "               default=604800,",
            "               help=_('Load balancer expiry age in seconds')),",
            "    cfg.IntOpt('cert_interval',",
            "               default=3600,",
            "               help=_('Certificate check interval in seconds')),",
            "    # 14 days for cert expiry buffer",
            "    cfg.IntOpt('cert_expiry_buffer',",
            "               default=1209600,",
            "               help=_('Seconds until certificate expiration')),",
            "    cfg.IntOpt('cert_rotate_threads',",
            "               default=10,",
            "               help=_('Number of threads performing amphora certificate'",
            "                      ' rotation'))",
            "]",
            "",
            "anchor_opts = [",
            "    cfg.StrOpt('url',",
            "               default='http://localhost:9999/v1/sign/default',",
            "               help=_('Anchor URL')),",
            "    cfg.StrOpt('username',",
            "               help=_('Anchor username')),",
            "    cfg.StrOpt('password',",
            "               help=_('Anchor password'),",
            "               secret=True)",
            "]",
            "",
            "keepalived_vrrp_opts = [",
            "    cfg.IntOpt('vrrp_advert_int',",
            "               default=1,",
            "               help=_('Amphora role and priority advertisement interval '",
            "                      'in seconds.')),",
            "    cfg.IntOpt('vrrp_check_interval',",
            "               default=5,",
            "               help=_('VRRP health check script run interval in seconds.')),",
            "    cfg.IntOpt('vrrp_fail_count',",
            "               default=2,",
            "               help=_('Number of successive failures before transition to a '",
            "                      'fail state.')),",
            "    cfg.IntOpt('vrrp_success_count',",
            "               default=2,",
            "               help=_('Number of consecutive successes before transition to a '",
            "                      'success state.')),",
            "    cfg.IntOpt('vrrp_garp_refresh_interval',",
            "               default=5,",
            "               help=_('Time in seconds between gratuitous ARP announcements '",
            "                      'from the MASTER.')),",
            "    cfg.IntOpt('vrrp_garp_refresh_count',",
            "               default=2,",
            "               help=_('Number of gratuitous ARP announcements to make on '",
            "                      'each refresh interval.'))",
            "",
            "]",
            "",
            "nova_opts = [",
            "    cfg.StrOpt('service_name',",
            "               help=_('The name of the nova service in the keystone catalog')),",
            "    cfg.StrOpt('endpoint', help=_('A new endpoint to override the endpoint '",
            "                                  'in the keystone catalog.')),",
            "    cfg.StrOpt('region_name',",
            "               help=_('Region in Identity service catalog to use for '",
            "                      'communication with the OpenStack services.')),",
            "    cfg.StrOpt('endpoint_type', default='publicURL',",
            "               help=_('Endpoint interface in identity service to use')),",
            "    cfg.StrOpt('ca_certificates_file',",
            "               help=_('CA certificates file path')),",
            "    cfg.BoolOpt('insecure',",
            "                default=False,",
            "                help=_('Disable certificate validation on SSL connections ')),",
            "    cfg.BoolOpt('enable_anti_affinity', default=False,",
            "                help=_('Flag to indicate if nova anti-affinity feature is '",
            "                       'turned on.'))",
            "]",
            "",
            "neutron_opts = [",
            "    cfg.StrOpt('service_name',",
            "               help=_('The name of the neutron service in the '",
            "                      'keystone catalog')),",
            "    cfg.StrOpt('endpoint', help=_('A new endpoint to override the endpoint '",
            "                                  'in the keystone catalog.')),",
            "    cfg.StrOpt('region_name',",
            "               help=_('Region in Identity service catalog to use for '",
            "                      'communication with the OpenStack services.')),",
            "    cfg.StrOpt('endpoint_type', default='publicURL',",
            "               help=_('Endpoint interface in identity service to use')),",
            "    cfg.StrOpt('ca_certificates_file',",
            "               help=_('CA certificates file path')),",
            "    cfg.BoolOpt('insecure',",
            "                default=False,",
            "                help=_('Disable certificate validation on SSL connections ')),",
            "]",
            "",
            "glance_opts = [",
            "    cfg.StrOpt('service_name',",
            "               help=_('The name of the glance service in the '",
            "                      'keystone catalog')),",
            "    cfg.StrOpt('endpoint', help=_('A new endpoint to override the endpoint '",
            "                                  'in the keystone catalog.')),",
            "    cfg.StrOpt('region_name',",
            "               help=_('Region in Identity service catalog to use for '",
            "                      'communication with the OpenStack services.')),",
            "    cfg.StrOpt('endpoint_type', default='publicURL',",
            "               help=_('Endpoint interface in identity service to use')),",
            "    cfg.StrOpt('ca_certificates_file',",
            "               help=_('CA certificates file path')),",
            "    cfg.BoolOpt('insecure',",
            "                default=False,",
            "                help=_('Disable certificate validation on SSL connections ')),",
            "]",
            "",
            "",
            "# Register the configuration options",
            "cfg.CONF.register_opts(core_opts)",
            "cfg.CONF.register_opts(amphora_agent_opts, group='amphora_agent')",
            "cfg.CONF.register_opts(networking_opts, group='networking')",
            "cfg.CONF.register_opts(oslo_messaging_opts, group='oslo_messaging')",
            "cfg.CONF.register_opts(haproxy_amphora_opts, group='haproxy_amphora')",
            "cfg.CONF.register_opts(controller_worker_opts, group='controller_worker')",
            "cfg.CONF.register_opts(keepalived_vrrp_opts, group='keepalived_vrrp')",
            "cfg.CONF.register_opts(task_flow_opts, group='task_flow')",
            "cfg.CONF.register_opts(oslo_messaging_opts, group='oslo_messaging')",
            "cfg.CONF.register_opts(house_keeping_opts, group='house_keeping')",
            "cfg.CONF.register_opts(anchor_opts, group='anchor')",
            "cfg.CONF.register_cli_opts(core_cli_opts)",
            "cfg.CONF.register_opts(certificate_opts, group='certificates')",
            "cfg.CONF.register_cli_opts(healthmanager_opts, group='health_manager')",
            "cfg.CONF.import_group('keystone_authtoken', 'keystonemiddleware.auth_token')",
            "cfg.CONF.register_opts(keystone_authtoken_v3_opts,",
            "                       group='keystone_authtoken_v3')",
            "cfg.CONF.register_opts(nova_opts, group='nova')",
            "cfg.CONF.register_opts(glance_opts, group='glance')",
            "cfg.CONF.register_opts(neutron_opts, group='neutron')",
            "",
            "",
            "# Ensure that the control exchange is set correctly",
            "messaging.set_transport_defaults(control_exchange='octavia')",
            "_SQL_CONNECTION_DEFAULT = 'sqlite://'",
            "# Update the default QueuePool parameters. These can be tweaked by the",
            "# configuration variables - max_pool_size, max_overflow and pool_timeout",
            "db_options.set_defaults(cfg.CONF, connection=_SQL_CONNECTION_DEFAULT,",
            "                        max_pool_size=10, max_overflow=20, pool_timeout=10)",
            "",
            "logging.register_options(cfg.CONF)",
            "",
            "",
            "def init(args, **kwargs):",
            "    cfg.CONF(args=args, project='octavia',",
            "             version='%%prog %s' % version.version_info.release_string(),",
            "             **kwargs)",
            "",
            "",
            "def setup_logging(conf):",
            "    \"\"\"Sets up the logging options for a log with supplied name.",
            "",
            "    :param conf: a cfg.ConfOpts object",
            "    \"\"\"",
            "    product_name = \"octavia\"",
            "    logging.setup(conf, product_name)",
            "    LOG.info(_LI(\"Logging enabled!\"))",
            "",
            "",
            "# def load_paste_app(app_name):",
            "#     \"\"\"Builds and returns a WSGI app from a paste config file.",
            "",
            "#     :param app_name: Name of the application to load",
            "#     :raises ConfigFilesNotFoundError when config file cannot be located",
            "#     :raises RuntimeError when application cannot be loaded from config file",
            "#     \"\"\"",
            "",
            "#     config_path = cfg.CONF.find_file(cfg.CONF.api_paste_config)",
            "#     if not config_path:",
            "#         raise cfg.ConfigFilesNotFoundError(",
            "#             config_files=[cfg.CONF.api_paste_config])",
            "#     config_path = os.path.abspath(config_path)",
            "#     LOG.info(_LI(\"Config paste file: %s\"), config_path)",
            "",
            "#     try:",
            "#         app = deploy.loadapp(\"config:%s\" % config_path, name=app_name)",
            "#     except (LookupError, ImportError):",
            "#         msg = (_(\"Unable to load %(app_name)s from \"",
            "#                  \"configuration file %(config_path)s.\") %",
            "#                {'app_name': app_name,",
            "#                 'config_path': config_path})",
            "#         LOG.exception(msg)",
            "#         raise RuntimeError(msg)",
            "#     return app"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "octavia/common/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": " AMP_ACTION_START = 'start'"
            },
            "1": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": " AMP_ACTION_STOP = 'stop'"
            },
            "2": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 333,
                "PatchRowcode": " AMP_ACTION_RELOAD = 'reload'"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+GLANCE_IMAGE_ACTIVE = 'active'"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 Rackspace",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "LB_ALGORITHM_ROUND_ROBIN = 'ROUND_ROBIN'",
            "LB_ALGORITHM_LEAST_CONNECTIONS = 'LEAST_CONNECTIONS'",
            "LB_ALGORITHM_SOURCE_IP = 'SOURCE_IP'",
            "SUPPORTED_LB_ALGORITHMS = (LB_ALGORITHM_LEAST_CONNECTIONS,",
            "                           LB_ALGORITHM_ROUND_ROBIN,",
            "                           LB_ALGORITHM_SOURCE_IP)",
            "",
            "SESSION_PERSISTENCE_SOURCE_IP = 'SOURCE_IP'",
            "SESSION_PERSISTENCE_HTTP_COOKIE = 'HTTP_COOKIE'",
            "SESSION_PERSISTENCE_APP_COOKIE = 'APP_COOKIE'",
            "SUPPORTED_SP_TYPES = (SESSION_PERSISTENCE_SOURCE_IP,",
            "                      SESSION_PERSISTENCE_HTTP_COOKIE,",
            "                      SESSION_PERSISTENCE_APP_COOKIE)",
            "",
            "HEALTH_MONITOR_PING = 'PING'",
            "HEALTH_MONITOR_TCP = 'TCP'",
            "HEALTH_MONITOR_HTTP = 'HTTP'",
            "HEALTH_MONITOR_HTTPS = 'HTTPS'",
            "SUPPORTED_HEALTH_MONITOR_TYPES = (HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS,",
            "                                  HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP)",
            "",
            "UPDATE_STATS = 'UPDATE_STATS'",
            "UPDATE_HEALTH = 'UPDATE_HEALTH'",
            "",
            "PROTOCOL_TCP = 'TCP'",
            "PROTOCOL_HTTP = 'HTTP'",
            "PROTOCOL_HTTPS = 'HTTPS'",
            "PROTOCOL_TERMINATED_HTTPS = 'TERMINATED_HTTPS'",
            "SUPPORTED_PROTOCOLS = (PROTOCOL_TCP, PROTOCOL_HTTPS, PROTOCOL_HTTP,",
            "                       PROTOCOL_TERMINATED_HTTPS)",
            "",
            "# Note: The database Amphora table has a foreign key constraint against",
            "#       the provisioning_status table",
            "# Amphora has been allocated to a load balancer",
            "AMPHORA_ALLOCATED = 'ALLOCATED'",
            "# Amphora is being built",
            "AMPHORA_BOOTING = 'BOOTING'",
            "# Amphora is ready to be allocated to a load balancer",
            "AMPHORA_READY = 'READY'",
            "",
            "ACTIVE = 'ACTIVE'",
            "PENDING_DELETE = 'PENDING_DELETE'",
            "PENDING_UPDATE = 'PENDING_UPDATE'",
            "PENDING_CREATE = 'PENDING_CREATE'",
            "DELETED = 'DELETED'",
            "ERROR = 'ERROR'",
            "SUPPORTED_PROVISIONING_STATUSES = (ACTIVE, AMPHORA_ALLOCATED,",
            "                                   AMPHORA_BOOTING, AMPHORA_READY,",
            "                                   PENDING_DELETE, PENDING_CREATE,",
            "                                   PENDING_UPDATE, DELETED, ERROR)",
            "MUTABLE_STATUSES = (ACTIVE,)",
            "DELETABLE_STATUSES = (ACTIVE, ERROR)",
            "",
            "SUPPORTED_AMPHORA_STATUSES = (AMPHORA_ALLOCATED, AMPHORA_BOOTING,",
            "                              AMPHORA_READY, DELETED, PENDING_DELETE)",
            "",
            "ONLINE = 'ONLINE'",
            "OFFLINE = 'OFFLINE'",
            "DEGRADED = 'DEGRADED'",
            "ERROR = 'ERROR'",
            "NO_MONITOR = 'NO_MONITOR'",
            "OPERATING_STATUS = 'operating_status'",
            "SUPPORTED_OPERATING_STATUSES = (ONLINE, OFFLINE, DEGRADED, ERROR, NO_MONITOR)",
            "",
            "AMPHORA_VM = 'VM'",
            "SUPPORTED_AMPHORA_TYPES = (AMPHORA_VM,)",
            "",
            "# L7 constants",
            "L7RULE_TYPE_HOST_NAME = 'HOST_NAME'",
            "L7RULE_TYPE_PATH = 'PATH'",
            "L7RULE_TYPE_FILE_TYPE = 'FILE_TYPE'",
            "L7RULE_TYPE_HEADER = 'HEADER'",
            "L7RULE_TYPE_COOKIE = 'COOKIE'",
            "SUPPORTED_L7RULE_TYPES = (L7RULE_TYPE_HOST_NAME, L7RULE_TYPE_PATH,",
            "                          L7RULE_TYPE_FILE_TYPE, L7RULE_TYPE_HEADER,",
            "                          L7RULE_TYPE_COOKIE)",
            "",
            "L7RULE_COMPARE_TYPE_REGEX = 'REGEX'",
            "L7RULE_COMPARE_TYPE_STARTS_WITH = 'STARTS_WITH'",
            "L7RULE_COMPARE_TYPE_ENDS_WITH = 'ENDS_WITH'",
            "L7RULE_COMPARE_TYPE_CONTAINS = 'CONTAINS'",
            "L7RULE_COMPARE_TYPE_EQUAL_TO = 'EQUAL_TO'",
            "SUPPORTED_L7RULE_COMPARE_TYPES = (L7RULE_COMPARE_TYPE_REGEX,",
            "                                  L7RULE_COMPARE_TYPE_STARTS_WITH,",
            "                                  L7RULE_COMPARE_TYPE_ENDS_WITH,",
            "                                  L7RULE_COMPARE_TYPE_CONTAINS,",
            "                                  L7RULE_COMPARE_TYPE_EQUAL_TO)",
            "",
            "L7POLICY_ACTION_REJECT = 'REJECT'",
            "L7POLICY_ACTION_REDIRECT_TO_URL = 'REDIRECT_TO_URL'",
            "L7POLICY_ACTION_REDIRECT_TO_POOL = 'REDIRECT_TO_POOL'",
            "SUPPORTED_L7POLICY_ACTIONS = (L7POLICY_ACTION_REJECT,",
            "                              L7POLICY_ACTION_REDIRECT_TO_URL,",
            "                              L7POLICY_ACTION_REDIRECT_TO_POOL)",
            "",
            "# Largest a 32-bit integer can be, which is a limitation",
            "# here if you're using MySQL, as most probably are. This just needs",
            "# to be larger than any existing rule position numbers which will",
            "# definitely be the case with 2147483647",
            "MAX_POLICY_POSITION = 2147483647",
            "",
            "# Testing showed haproxy config failed to parse after more than",
            "# 53 rules per policy",
            "MAX_L7RULES_PER_L7POLICY = 50",
            "",
            "# See RFCs 2616, 2965, 6265, 7230: Should match characters valid in a",
            "# http header or cookie name.",
            "HTTP_HEADER_NAME_REGEX = r'\\A[a-zA-Z0-9!#$%&\\'*+-.^_`|~]+\\Z'",
            "",
            "# See RFCs 2616, 2965, 6265: Should match characters valid in a cookie value.",
            "HTTP_COOKIE_VALUE_REGEX = r'\\A[a-zA-Z0-9!#$%&\\'()*+-./:<=>?@[\\]^_`{|}~]+\\Z'",
            "",
            "# See RFC 7230: Should match characters valid in a header value.",
            "HTTP_HEADER_VALUE_REGEX = (r'\\A[a-zA-Z0-9'",
            "                           r'!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]+\\Z')",
            "",
            "# Also in RFC 7230: Should match characters valid in a header value",
            "# when quoted with double quotes.",
            "HTTP_QUOTED_HEADER_VALUE_REGEX = (r'\\A\"[a-zA-Z0-9 \\t'",
            "                                  r'!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]*\"\\Z')",
            "",
            "# Task/Flow constants",
            "AMPHORA = 'amphora'",
            "FAILED_AMPHORA = 'failed_amphora'",
            "FAILOVER_AMPHORA = 'failover_amphora'",
            "AMPHORAE = 'amphorae'",
            "AMPHORA_ID = 'amphora_id'",
            "FAILOVER_AMPHORA_ID = 'failover_amphora_id'",
            "DELTA = 'delta'",
            "DELTAS = 'deltas'",
            "HEALTH_MON = 'health_mon'",
            "LISTENER = 'listener'",
            "LISTENERS = 'listeners'",
            "LOADBALANCER = 'loadbalancer'",
            "LOADBALANCER_ID = 'loadbalancer_id'",
            "SERVER_GROUP_ID = 'server_group_id'",
            "ANTI_AFFINITY = 'anti-affinity'",
            "MEMBER = 'member'",
            "MEMBER_ID = 'member_id'",
            "COMPUTE_ID = 'compute_id'",
            "COMPUTE_OBJ = 'compute_obj'",
            "AMP_DATA = 'amp_data'",
            "AMPS_DATA = 'amps_data'",
            "NICS = 'nics'",
            "VIP = 'vip'",
            "POOL = 'pool'",
            "POOL_ID = 'pool_id'",
            "L7POLICY = 'l7policy'",
            "L7RULE = 'l7rule'",
            "OBJECT = 'object'",
            "SERVER_PEM = 'server_pem'",
            "UPDATE_DICT = 'update_dict'",
            "VIP_NETWORK = 'vip_network'",
            "AMPHORAE_NETWORK_CONFIG = 'amphorae_network_config'",
            "ADDED_PORTS = 'added_ports'",
            "PORTS = 'ports'",
            "MEMBER_PORTS = 'member_ports'",
            "LOADBALANCER_TOPOLOGY = 'topology'",
            "",
            "CERT_ROTATE_AMPHORA_FLOW = 'octavia-cert-rotate-amphora-flow'",
            "CREATE_AMPHORA_FLOW = 'octavia-create-amphora-flow'",
            "CREATE_AMPHORA_FOR_LB_FLOW = 'octavia-create-amp-for-lb-flow'",
            "CREATE_HEALTH_MONITOR_FLOW = 'octavia-create-health-monitor-flow'",
            "CREATE_LISTENER_FLOW = 'octavia-create-listener_flow'",
            "PRE_CREATE_LOADBALANCER_FLOW = 'octavia-pre-create-loadbalancer-flow'",
            "CREATE_SERVER_GROUP_FLOW = 'octavia-create-server-group-flow'",
            "UPDATE_LB_SERVERGROUPID_FLOW = 'octavia-update-lb-server-group-id-flow'",
            "CREATE_LISTENERS_FLOW = 'octavia-create-all-listeners-flow'",
            "CREATE_LOADBALANCER_FLOW = 'octavia-create-loadbalancer-flow'",
            "CREATE_LOADBALANCER_GRAPH_FLOW = 'octavia-create-loadbalancer-graph-flow'",
            "CREATE_MEMBER_FLOW = 'octavia-create-member-flow'",
            "CREATE_POOL_FLOW = 'octavia-create-pool-flow'",
            "CREATE_L7POLICY_FLOW = 'octavia-create-l7policy-flow'",
            "CREATE_L7RULE_FLOW = 'octavia-create-l7rule-flow'",
            "DELETE_AMPHORA_FLOW = 'octavia-delete-amphora-flow'",
            "DELETE_HEALTH_MONITOR_FLOW = 'octavia-delete-health-monitor-flow'",
            "DELETE_LISTENER_FLOW = 'octavia-delete-listener_flow'",
            "DELETE_LOADBALANCER_FLOW = 'octavia-delete-loadbalancer-flow'",
            "DELETE_MEMBER_FLOW = 'octavia-delete-member-flow'",
            "DELETE_POOL_FLOW = 'octavia-delete-pool-flow'",
            "DELETE_L7POLICY_FLOW = 'octavia-delete-l7policy-flow'",
            "DELETE_L7RULE_FLOW = 'octavia-delete-l7policy-flow'",
            "FAILOVER_AMPHORA_FLOW = 'octavia-failover-amphora-flow'",
            "LOADBALANCER_NETWORKING_SUBFLOW = 'octavia-new-loadbalancer-net-subflow'",
            "UPDATE_HEALTH_MONITOR_FLOW = 'octavia-update-health-monitor-flow'",
            "UPDATE_LISTENER_FLOW = 'octavia-update-listener-flow'",
            "UPDATE_LOADBALANCER_FLOW = 'octavia-update-loadbalancer-flow'",
            "UPDATE_MEMBER_FLOW = 'octavia-update-member-flow'",
            "UPDATE_POOL_FLOW = 'octavia-update-pool-flow'",
            "UPDATE_L7POLICY_FLOW = 'octavia-update-l7policy-flow'",
            "UPDATE_L7RULE_FLOW = 'octavia-update-l7rule-flow'",
            "",
            "POST_MAP_AMP_TO_LB_SUBFLOW = 'octavia-post-map-amp-to-lb-subflow'",
            "CREATE_AMP_FOR_LB_SUBFLOW = 'octavia-create-amp-for-lb-subflow'",
            "GET_AMPHORA_FOR_LB_SUBFLOW = 'octavia-get-amphora-for-lb-subflow'",
            "POST_LB_AMP_ASSOCIATION_SUBFLOW = (",
            "    'octavia-post-loadbalancer-amp_association-subflow')",
            "",
            "MAP_LOADBALANCER_TO_AMPHORA = 'octavia-mapload-balancer-to-amphora'",
            "RELOAD_AMPHORA = 'octavia-reload-amphora'",
            "CREATE_AMPHORA_INDB = 'octavia-create-amphora-indb'",
            "GENERATE_SERVER_PEM = 'octavia-generate-serverpem'",
            "UPDATE_CERT_EXPIRATION = 'octavia-update-cert-expiration'",
            "CERT_COMPUTE_CREATE = 'octavia-cert-compute-create'",
            "COMPUTE_CREATE = 'octavia-compute-create'",
            "UPDATE_AMPHORA_COMPUTEID = 'octavia-update-amphora-computeid'",
            "MARK_AMPHORA_BOOTING_INDB = 'octavia-mark-amphora-booting-indb'",
            "WAIT_FOR_AMPHORA = 'octavia-wait_for_amphora'",
            "COMPUTE_WAIT = 'octavia-compute-wait'",
            "UPDATE_AMPHORA_INFO = 'octavia-update-amphora-info'",
            "AMPHORA_FINALIZE = 'octavia-amphora-finalize'",
            "MARK_AMPHORA_ALLOCATED_INDB = 'octavia-mark-amphora-allocated-indb'",
            "RELOADLOAD_BALANCER = 'octavia-reloadload-balancer'",
            "MARK_LB_ACTIVE_INDB = 'octavia-mark-lb-active-indb'",
            "MARK_AMP_MASTER_INDB = 'octavia-mark-amp-master-indb'",
            "MARK_AMP_BACKUP_INDB = 'octavia-mark-amp-backup-indb'",
            "MARK_AMP_STANDALONE_INDB = 'octavia-mark-amp-standalone-indb'",
            "GET_VRRP_SUBFLOW = 'octavia-get-vrrp-subflow'",
            "AMP_VRRP_UPDATE = 'octavia-amphora-vrrp-update'",
            "AMP_VRRP_START = 'octavia-amphora-vrrp-start'",
            "AMP_VRRP_STOP = 'octavia-amphora-vrrp-stop'",
            "AMP_UPDATE_VRRP_INTF = 'octavia-amphora-update-vrrp-intf'",
            "CREATE_VRRP_GROUP_FOR_LB = 'octavia-create-vrrp-group-for-lb'",
            "CREATE_VRRP_SECURITY_RULES = 'octavia-create-vrrp-security-rules'",
            "",
            "GENERATE_SERVER_PEM_TASK = 'GenerateServerPEMTask'",
            "",
            "# Task Names",
            "RELOAD_LB_AFTER_AMP_ASSOC = 'reload-lb-after-amp-assoc'",
            "RELOAD_LB_AFTER_AMP_ASSOC_FULL_GRAPH = 'reload-lb-after-amp-assoc-full-graph'",
            "RELOAD_LB_AFTER_PLUG_VIP = 'reload-lb-after-plug-vip'",
            "",
            "NOVA_1 = '1.1'",
            "NOVA_21 = '2.1'",
            "NOVA_3 = '3'",
            "NOVA_VERSIONS = (NOVA_1, NOVA_21, NOVA_3)",
            "",
            "RPC_NAMESPACE_CONTROLLER_AGENT = 'controller'",
            "",
            "",
            "# Active standalone roles and topology",
            "TOPOLOGY_SINGLE = 'SINGLE'",
            "TOPOLOGY_ACTIVE_STANDBY = 'ACTIVE_STANDBY'",
            "ROLE_MASTER = 'MASTER'",
            "ROLE_BACKUP = 'BACKUP'",
            "ROLE_STANDALONE = 'STANDALONE'",
            "",
            "SUPPORTED_LB_TOPOLOGIES = (TOPOLOGY_ACTIVE_STANDBY, TOPOLOGY_SINGLE)",
            "SUPPORTED_AMPHORA_ROLES = (ROLE_BACKUP, ROLE_MASTER, ROLE_STANDALONE)",
            "",
            "TOPOLOGY_STATUS_OK = 'OK'",
            "",
            "ROLE_MASTER_PRIORITY = 100",
            "ROLE_BACKUP_PRIORITY = 90",
            "",
            "VRRP_AUTH_DEFAULT = 'PASS'",
            "VRRP_AUTH_AH = 'AH'",
            "SUPPORTED_VRRP_AUTH = (VRRP_AUTH_DEFAULT, VRRP_AUTH_AH)",
            "",
            "KEEPALIVED_CMD = '/usr/sbin/keepalived '",
            "# The DEFAULT_VRRP_ID value needs to be variable for multi tenant support",
            "# per amphora in the future",
            "DEFAULT_VRRP_ID = 1",
            "VRRP_PROTOCOL_NUM = 112",
            "AUTH_HEADER_PROTOCOL_NUMBER = 51",
            "",
            "",
            "TEMPLATES = '/templates'",
            "AGENT_API_TEMPLATES = '/templates'",
            "",
            "AGENT_CONF_TEMPLATE = 'amphora_agent_conf.template'",
            "USER_DATA_CONFIG_DRIVE_TEMPLATE = 'user_data_config_drive.template'",
            "",
            "OPEN = 'OPEN'",
            "FULL = 'FULL'",
            "",
            "# OPEN = HAProxy listener status nbconn < maxconn",
            "# FULL = HAProxy listener status not nbconn < maxconn",
            "HAPROXY_LISTENER_STATUSES = (OPEN, FULL)",
            "",
            "UP = 'UP'",
            "DOWN = 'DOWN'",
            "",
            "# UP = HAProxy backend has working or no servers",
            "# DOWN = HAProxy backend has no working servers",
            "HAPROXY_BACKEND_STATUSES = (UP, DOWN)",
            "",
            "",
            "NO_CHECK = 'no check'",
            "",
            "HAPROXY_MEMBER_STATUSES = (UP, DOWN, NO_CHECK)",
            "",
            "API_VERSION = '0.5'",
            "",
            "HAPROXY_BASE_PEER_PORT = 1025",
            "KEEPALIVED_CONF = 'keepalived.conf.j2'",
            "CHECK_SCRIPT_CONF = 'keepalived_check_script.conf.j2'",
            "",
            "PLUGGED_INTERFACES = '/var/lib/octavia/plugged_interfaces'",
            "AMPHORA_NAMESPACE = 'amphora-haproxy'",
            "",
            "# List of HTTP headers which are supported for insertion",
            "SUPPORTED_HTTP_HEADERS = ['X-Forwarded-For',",
            "                          'X-Forwarded-Port']",
            "",
            "FLOW_DOC_TITLES = {'AmphoraFlows': 'Amphora Flows',",
            "                   'LoadBalancerFlows': 'Load Balancer Flows',",
            "                   'ListenerFlows': 'Listener Flows',",
            "                   'PoolFlows': 'Pool Flows',",
            "                   'MemberFlows': 'Member Flows',",
            "                   'HealthMonitorFlows': 'Health Monitor Flows',",
            "                   'L7PolicyFlows': 'Layer 7 Policy Flows',",
            "                   'L7RuleFlows': 'Layer 7 Rule Flows'}",
            "",
            "NETNS_PRIMARY_INTERFACE = 'eth1'",
            "",
            "AMP_ACTION_START = 'start'",
            "AMP_ACTION_STOP = 'stop'",
            "AMP_ACTION_RELOAD = 'reload'"
        ],
        "afterPatchFile": [
            "# Copyright 2014 Rackspace",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "LB_ALGORITHM_ROUND_ROBIN = 'ROUND_ROBIN'",
            "LB_ALGORITHM_LEAST_CONNECTIONS = 'LEAST_CONNECTIONS'",
            "LB_ALGORITHM_SOURCE_IP = 'SOURCE_IP'",
            "SUPPORTED_LB_ALGORITHMS = (LB_ALGORITHM_LEAST_CONNECTIONS,",
            "                           LB_ALGORITHM_ROUND_ROBIN,",
            "                           LB_ALGORITHM_SOURCE_IP)",
            "",
            "SESSION_PERSISTENCE_SOURCE_IP = 'SOURCE_IP'",
            "SESSION_PERSISTENCE_HTTP_COOKIE = 'HTTP_COOKIE'",
            "SESSION_PERSISTENCE_APP_COOKIE = 'APP_COOKIE'",
            "SUPPORTED_SP_TYPES = (SESSION_PERSISTENCE_SOURCE_IP,",
            "                      SESSION_PERSISTENCE_HTTP_COOKIE,",
            "                      SESSION_PERSISTENCE_APP_COOKIE)",
            "",
            "HEALTH_MONITOR_PING = 'PING'",
            "HEALTH_MONITOR_TCP = 'TCP'",
            "HEALTH_MONITOR_HTTP = 'HTTP'",
            "HEALTH_MONITOR_HTTPS = 'HTTPS'",
            "SUPPORTED_HEALTH_MONITOR_TYPES = (HEALTH_MONITOR_HTTP, HEALTH_MONITOR_HTTPS,",
            "                                  HEALTH_MONITOR_PING, HEALTH_MONITOR_TCP)",
            "",
            "UPDATE_STATS = 'UPDATE_STATS'",
            "UPDATE_HEALTH = 'UPDATE_HEALTH'",
            "",
            "PROTOCOL_TCP = 'TCP'",
            "PROTOCOL_HTTP = 'HTTP'",
            "PROTOCOL_HTTPS = 'HTTPS'",
            "PROTOCOL_TERMINATED_HTTPS = 'TERMINATED_HTTPS'",
            "SUPPORTED_PROTOCOLS = (PROTOCOL_TCP, PROTOCOL_HTTPS, PROTOCOL_HTTP,",
            "                       PROTOCOL_TERMINATED_HTTPS)",
            "",
            "# Note: The database Amphora table has a foreign key constraint against",
            "#       the provisioning_status table",
            "# Amphora has been allocated to a load balancer",
            "AMPHORA_ALLOCATED = 'ALLOCATED'",
            "# Amphora is being built",
            "AMPHORA_BOOTING = 'BOOTING'",
            "# Amphora is ready to be allocated to a load balancer",
            "AMPHORA_READY = 'READY'",
            "",
            "ACTIVE = 'ACTIVE'",
            "PENDING_DELETE = 'PENDING_DELETE'",
            "PENDING_UPDATE = 'PENDING_UPDATE'",
            "PENDING_CREATE = 'PENDING_CREATE'",
            "DELETED = 'DELETED'",
            "ERROR = 'ERROR'",
            "SUPPORTED_PROVISIONING_STATUSES = (ACTIVE, AMPHORA_ALLOCATED,",
            "                                   AMPHORA_BOOTING, AMPHORA_READY,",
            "                                   PENDING_DELETE, PENDING_CREATE,",
            "                                   PENDING_UPDATE, DELETED, ERROR)",
            "MUTABLE_STATUSES = (ACTIVE,)",
            "DELETABLE_STATUSES = (ACTIVE, ERROR)",
            "",
            "SUPPORTED_AMPHORA_STATUSES = (AMPHORA_ALLOCATED, AMPHORA_BOOTING,",
            "                              AMPHORA_READY, DELETED, PENDING_DELETE)",
            "",
            "ONLINE = 'ONLINE'",
            "OFFLINE = 'OFFLINE'",
            "DEGRADED = 'DEGRADED'",
            "ERROR = 'ERROR'",
            "NO_MONITOR = 'NO_MONITOR'",
            "OPERATING_STATUS = 'operating_status'",
            "SUPPORTED_OPERATING_STATUSES = (ONLINE, OFFLINE, DEGRADED, ERROR, NO_MONITOR)",
            "",
            "AMPHORA_VM = 'VM'",
            "SUPPORTED_AMPHORA_TYPES = (AMPHORA_VM,)",
            "",
            "# L7 constants",
            "L7RULE_TYPE_HOST_NAME = 'HOST_NAME'",
            "L7RULE_TYPE_PATH = 'PATH'",
            "L7RULE_TYPE_FILE_TYPE = 'FILE_TYPE'",
            "L7RULE_TYPE_HEADER = 'HEADER'",
            "L7RULE_TYPE_COOKIE = 'COOKIE'",
            "SUPPORTED_L7RULE_TYPES = (L7RULE_TYPE_HOST_NAME, L7RULE_TYPE_PATH,",
            "                          L7RULE_TYPE_FILE_TYPE, L7RULE_TYPE_HEADER,",
            "                          L7RULE_TYPE_COOKIE)",
            "",
            "L7RULE_COMPARE_TYPE_REGEX = 'REGEX'",
            "L7RULE_COMPARE_TYPE_STARTS_WITH = 'STARTS_WITH'",
            "L7RULE_COMPARE_TYPE_ENDS_WITH = 'ENDS_WITH'",
            "L7RULE_COMPARE_TYPE_CONTAINS = 'CONTAINS'",
            "L7RULE_COMPARE_TYPE_EQUAL_TO = 'EQUAL_TO'",
            "SUPPORTED_L7RULE_COMPARE_TYPES = (L7RULE_COMPARE_TYPE_REGEX,",
            "                                  L7RULE_COMPARE_TYPE_STARTS_WITH,",
            "                                  L7RULE_COMPARE_TYPE_ENDS_WITH,",
            "                                  L7RULE_COMPARE_TYPE_CONTAINS,",
            "                                  L7RULE_COMPARE_TYPE_EQUAL_TO)",
            "",
            "L7POLICY_ACTION_REJECT = 'REJECT'",
            "L7POLICY_ACTION_REDIRECT_TO_URL = 'REDIRECT_TO_URL'",
            "L7POLICY_ACTION_REDIRECT_TO_POOL = 'REDIRECT_TO_POOL'",
            "SUPPORTED_L7POLICY_ACTIONS = (L7POLICY_ACTION_REJECT,",
            "                              L7POLICY_ACTION_REDIRECT_TO_URL,",
            "                              L7POLICY_ACTION_REDIRECT_TO_POOL)",
            "",
            "# Largest a 32-bit integer can be, which is a limitation",
            "# here if you're using MySQL, as most probably are. This just needs",
            "# to be larger than any existing rule position numbers which will",
            "# definitely be the case with 2147483647",
            "MAX_POLICY_POSITION = 2147483647",
            "",
            "# Testing showed haproxy config failed to parse after more than",
            "# 53 rules per policy",
            "MAX_L7RULES_PER_L7POLICY = 50",
            "",
            "# See RFCs 2616, 2965, 6265, 7230: Should match characters valid in a",
            "# http header or cookie name.",
            "HTTP_HEADER_NAME_REGEX = r'\\A[a-zA-Z0-9!#$%&\\'*+-.^_`|~]+\\Z'",
            "",
            "# See RFCs 2616, 2965, 6265: Should match characters valid in a cookie value.",
            "HTTP_COOKIE_VALUE_REGEX = r'\\A[a-zA-Z0-9!#$%&\\'()*+-./:<=>?@[\\]^_`{|}~]+\\Z'",
            "",
            "# See RFC 7230: Should match characters valid in a header value.",
            "HTTP_HEADER_VALUE_REGEX = (r'\\A[a-zA-Z0-9'",
            "                           r'!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]+\\Z')",
            "",
            "# Also in RFC 7230: Should match characters valid in a header value",
            "# when quoted with double quotes.",
            "HTTP_QUOTED_HEADER_VALUE_REGEX = (r'\\A\"[a-zA-Z0-9 \\t'",
            "                                  r'!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~\\\\]*\"\\Z')",
            "",
            "# Task/Flow constants",
            "AMPHORA = 'amphora'",
            "FAILED_AMPHORA = 'failed_amphora'",
            "FAILOVER_AMPHORA = 'failover_amphora'",
            "AMPHORAE = 'amphorae'",
            "AMPHORA_ID = 'amphora_id'",
            "FAILOVER_AMPHORA_ID = 'failover_amphora_id'",
            "DELTA = 'delta'",
            "DELTAS = 'deltas'",
            "HEALTH_MON = 'health_mon'",
            "LISTENER = 'listener'",
            "LISTENERS = 'listeners'",
            "LOADBALANCER = 'loadbalancer'",
            "LOADBALANCER_ID = 'loadbalancer_id'",
            "SERVER_GROUP_ID = 'server_group_id'",
            "ANTI_AFFINITY = 'anti-affinity'",
            "MEMBER = 'member'",
            "MEMBER_ID = 'member_id'",
            "COMPUTE_ID = 'compute_id'",
            "COMPUTE_OBJ = 'compute_obj'",
            "AMP_DATA = 'amp_data'",
            "AMPS_DATA = 'amps_data'",
            "NICS = 'nics'",
            "VIP = 'vip'",
            "POOL = 'pool'",
            "POOL_ID = 'pool_id'",
            "L7POLICY = 'l7policy'",
            "L7RULE = 'l7rule'",
            "OBJECT = 'object'",
            "SERVER_PEM = 'server_pem'",
            "UPDATE_DICT = 'update_dict'",
            "VIP_NETWORK = 'vip_network'",
            "AMPHORAE_NETWORK_CONFIG = 'amphorae_network_config'",
            "ADDED_PORTS = 'added_ports'",
            "PORTS = 'ports'",
            "MEMBER_PORTS = 'member_ports'",
            "LOADBALANCER_TOPOLOGY = 'topology'",
            "",
            "CERT_ROTATE_AMPHORA_FLOW = 'octavia-cert-rotate-amphora-flow'",
            "CREATE_AMPHORA_FLOW = 'octavia-create-amphora-flow'",
            "CREATE_AMPHORA_FOR_LB_FLOW = 'octavia-create-amp-for-lb-flow'",
            "CREATE_HEALTH_MONITOR_FLOW = 'octavia-create-health-monitor-flow'",
            "CREATE_LISTENER_FLOW = 'octavia-create-listener_flow'",
            "PRE_CREATE_LOADBALANCER_FLOW = 'octavia-pre-create-loadbalancer-flow'",
            "CREATE_SERVER_GROUP_FLOW = 'octavia-create-server-group-flow'",
            "UPDATE_LB_SERVERGROUPID_FLOW = 'octavia-update-lb-server-group-id-flow'",
            "CREATE_LISTENERS_FLOW = 'octavia-create-all-listeners-flow'",
            "CREATE_LOADBALANCER_FLOW = 'octavia-create-loadbalancer-flow'",
            "CREATE_LOADBALANCER_GRAPH_FLOW = 'octavia-create-loadbalancer-graph-flow'",
            "CREATE_MEMBER_FLOW = 'octavia-create-member-flow'",
            "CREATE_POOL_FLOW = 'octavia-create-pool-flow'",
            "CREATE_L7POLICY_FLOW = 'octavia-create-l7policy-flow'",
            "CREATE_L7RULE_FLOW = 'octavia-create-l7rule-flow'",
            "DELETE_AMPHORA_FLOW = 'octavia-delete-amphora-flow'",
            "DELETE_HEALTH_MONITOR_FLOW = 'octavia-delete-health-monitor-flow'",
            "DELETE_LISTENER_FLOW = 'octavia-delete-listener_flow'",
            "DELETE_LOADBALANCER_FLOW = 'octavia-delete-loadbalancer-flow'",
            "DELETE_MEMBER_FLOW = 'octavia-delete-member-flow'",
            "DELETE_POOL_FLOW = 'octavia-delete-pool-flow'",
            "DELETE_L7POLICY_FLOW = 'octavia-delete-l7policy-flow'",
            "DELETE_L7RULE_FLOW = 'octavia-delete-l7policy-flow'",
            "FAILOVER_AMPHORA_FLOW = 'octavia-failover-amphora-flow'",
            "LOADBALANCER_NETWORKING_SUBFLOW = 'octavia-new-loadbalancer-net-subflow'",
            "UPDATE_HEALTH_MONITOR_FLOW = 'octavia-update-health-monitor-flow'",
            "UPDATE_LISTENER_FLOW = 'octavia-update-listener-flow'",
            "UPDATE_LOADBALANCER_FLOW = 'octavia-update-loadbalancer-flow'",
            "UPDATE_MEMBER_FLOW = 'octavia-update-member-flow'",
            "UPDATE_POOL_FLOW = 'octavia-update-pool-flow'",
            "UPDATE_L7POLICY_FLOW = 'octavia-update-l7policy-flow'",
            "UPDATE_L7RULE_FLOW = 'octavia-update-l7rule-flow'",
            "",
            "POST_MAP_AMP_TO_LB_SUBFLOW = 'octavia-post-map-amp-to-lb-subflow'",
            "CREATE_AMP_FOR_LB_SUBFLOW = 'octavia-create-amp-for-lb-subflow'",
            "GET_AMPHORA_FOR_LB_SUBFLOW = 'octavia-get-amphora-for-lb-subflow'",
            "POST_LB_AMP_ASSOCIATION_SUBFLOW = (",
            "    'octavia-post-loadbalancer-amp_association-subflow')",
            "",
            "MAP_LOADBALANCER_TO_AMPHORA = 'octavia-mapload-balancer-to-amphora'",
            "RELOAD_AMPHORA = 'octavia-reload-amphora'",
            "CREATE_AMPHORA_INDB = 'octavia-create-amphora-indb'",
            "GENERATE_SERVER_PEM = 'octavia-generate-serverpem'",
            "UPDATE_CERT_EXPIRATION = 'octavia-update-cert-expiration'",
            "CERT_COMPUTE_CREATE = 'octavia-cert-compute-create'",
            "COMPUTE_CREATE = 'octavia-compute-create'",
            "UPDATE_AMPHORA_COMPUTEID = 'octavia-update-amphora-computeid'",
            "MARK_AMPHORA_BOOTING_INDB = 'octavia-mark-amphora-booting-indb'",
            "WAIT_FOR_AMPHORA = 'octavia-wait_for_amphora'",
            "COMPUTE_WAIT = 'octavia-compute-wait'",
            "UPDATE_AMPHORA_INFO = 'octavia-update-amphora-info'",
            "AMPHORA_FINALIZE = 'octavia-amphora-finalize'",
            "MARK_AMPHORA_ALLOCATED_INDB = 'octavia-mark-amphora-allocated-indb'",
            "RELOADLOAD_BALANCER = 'octavia-reloadload-balancer'",
            "MARK_LB_ACTIVE_INDB = 'octavia-mark-lb-active-indb'",
            "MARK_AMP_MASTER_INDB = 'octavia-mark-amp-master-indb'",
            "MARK_AMP_BACKUP_INDB = 'octavia-mark-amp-backup-indb'",
            "MARK_AMP_STANDALONE_INDB = 'octavia-mark-amp-standalone-indb'",
            "GET_VRRP_SUBFLOW = 'octavia-get-vrrp-subflow'",
            "AMP_VRRP_UPDATE = 'octavia-amphora-vrrp-update'",
            "AMP_VRRP_START = 'octavia-amphora-vrrp-start'",
            "AMP_VRRP_STOP = 'octavia-amphora-vrrp-stop'",
            "AMP_UPDATE_VRRP_INTF = 'octavia-amphora-update-vrrp-intf'",
            "CREATE_VRRP_GROUP_FOR_LB = 'octavia-create-vrrp-group-for-lb'",
            "CREATE_VRRP_SECURITY_RULES = 'octavia-create-vrrp-security-rules'",
            "",
            "GENERATE_SERVER_PEM_TASK = 'GenerateServerPEMTask'",
            "",
            "# Task Names",
            "RELOAD_LB_AFTER_AMP_ASSOC = 'reload-lb-after-amp-assoc'",
            "RELOAD_LB_AFTER_AMP_ASSOC_FULL_GRAPH = 'reload-lb-after-amp-assoc-full-graph'",
            "RELOAD_LB_AFTER_PLUG_VIP = 'reload-lb-after-plug-vip'",
            "",
            "NOVA_1 = '1.1'",
            "NOVA_21 = '2.1'",
            "NOVA_3 = '3'",
            "NOVA_VERSIONS = (NOVA_1, NOVA_21, NOVA_3)",
            "",
            "RPC_NAMESPACE_CONTROLLER_AGENT = 'controller'",
            "",
            "",
            "# Active standalone roles and topology",
            "TOPOLOGY_SINGLE = 'SINGLE'",
            "TOPOLOGY_ACTIVE_STANDBY = 'ACTIVE_STANDBY'",
            "ROLE_MASTER = 'MASTER'",
            "ROLE_BACKUP = 'BACKUP'",
            "ROLE_STANDALONE = 'STANDALONE'",
            "",
            "SUPPORTED_LB_TOPOLOGIES = (TOPOLOGY_ACTIVE_STANDBY, TOPOLOGY_SINGLE)",
            "SUPPORTED_AMPHORA_ROLES = (ROLE_BACKUP, ROLE_MASTER, ROLE_STANDALONE)",
            "",
            "TOPOLOGY_STATUS_OK = 'OK'",
            "",
            "ROLE_MASTER_PRIORITY = 100",
            "ROLE_BACKUP_PRIORITY = 90",
            "",
            "VRRP_AUTH_DEFAULT = 'PASS'",
            "VRRP_AUTH_AH = 'AH'",
            "SUPPORTED_VRRP_AUTH = (VRRP_AUTH_DEFAULT, VRRP_AUTH_AH)",
            "",
            "KEEPALIVED_CMD = '/usr/sbin/keepalived '",
            "# The DEFAULT_VRRP_ID value needs to be variable for multi tenant support",
            "# per amphora in the future",
            "DEFAULT_VRRP_ID = 1",
            "VRRP_PROTOCOL_NUM = 112",
            "AUTH_HEADER_PROTOCOL_NUMBER = 51",
            "",
            "",
            "TEMPLATES = '/templates'",
            "AGENT_API_TEMPLATES = '/templates'",
            "",
            "AGENT_CONF_TEMPLATE = 'amphora_agent_conf.template'",
            "USER_DATA_CONFIG_DRIVE_TEMPLATE = 'user_data_config_drive.template'",
            "",
            "OPEN = 'OPEN'",
            "FULL = 'FULL'",
            "",
            "# OPEN = HAProxy listener status nbconn < maxconn",
            "# FULL = HAProxy listener status not nbconn < maxconn",
            "HAPROXY_LISTENER_STATUSES = (OPEN, FULL)",
            "",
            "UP = 'UP'",
            "DOWN = 'DOWN'",
            "",
            "# UP = HAProxy backend has working or no servers",
            "# DOWN = HAProxy backend has no working servers",
            "HAPROXY_BACKEND_STATUSES = (UP, DOWN)",
            "",
            "",
            "NO_CHECK = 'no check'",
            "",
            "HAPROXY_MEMBER_STATUSES = (UP, DOWN, NO_CHECK)",
            "",
            "API_VERSION = '0.5'",
            "",
            "HAPROXY_BASE_PEER_PORT = 1025",
            "KEEPALIVED_CONF = 'keepalived.conf.j2'",
            "CHECK_SCRIPT_CONF = 'keepalived_check_script.conf.j2'",
            "",
            "PLUGGED_INTERFACES = '/var/lib/octavia/plugged_interfaces'",
            "AMPHORA_NAMESPACE = 'amphora-haproxy'",
            "",
            "# List of HTTP headers which are supported for insertion",
            "SUPPORTED_HTTP_HEADERS = ['X-Forwarded-For',",
            "                          'X-Forwarded-Port']",
            "",
            "FLOW_DOC_TITLES = {'AmphoraFlows': 'Amphora Flows',",
            "                   'LoadBalancerFlows': 'Load Balancer Flows',",
            "                   'ListenerFlows': 'Listener Flows',",
            "                   'PoolFlows': 'Pool Flows',",
            "                   'MemberFlows': 'Member Flows',",
            "                   'HealthMonitorFlows': 'Health Monitor Flows',",
            "                   'L7PolicyFlows': 'Layer 7 Policy Flows',",
            "                   'L7RuleFlows': 'Layer 7 Rule Flows'}",
            "",
            "NETNS_PRIMARY_INTERFACE = 'eth1'",
            "",
            "AMP_ACTION_START = 'start'",
            "AMP_ACTION_STOP = 'stop'",
            "AMP_ACTION_RELOAD = 'reload'",
            "GLANCE_IMAGE_ACTIVE = 'active'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "octavia/compute/compute_base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     @abc.abstractmethod"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     def build(self, name=\"amphora_name\", amphora_flavor=None,"
            },
            "3": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-              image_id=None, image_tag=None,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+              image_id=None, image_tag=None, image_owner=None,"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "               key_name=None, sec_groups=None, network_ids=None,"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "               config_drive_files=None, user_data=None, server_group_id=None):"
            },
            "7": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         \"\"\"Build a new amphora."
            }
        },
        "frontPatchFile": [
            "#    Copyright 2011-2014 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import abc",
            "",
            "import six",
            "",
            "",
            "@six.add_metaclass(abc.ABCMeta)",
            "class ComputeBase(object):",
            "",
            "    @abc.abstractmethod",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              config_drive_files=None, user_data=None, server_group_id=None):",
            "        \"\"\"Build a new amphora.",
            "",
            "        :param name: Optional name for Amphora",
            "        :param amphora_flavor: Optionally specify a flavor",
            "        :param image_id: ID of the base image for the amphora instance",
            "        :param image_tag: tag of the base image for the amphora instance",
            "        :param key_name: Optionally specify a keypair",
            "        :param sec_groups: Optionally specify list of security groups",
            "        :param network_ids: A list of network IDs to attach to the amphora",
            "        :param config_drive_files:  An optional dict of files to overwrite on",
            "        the server upon boot. Keys are file names (i.e. /etc/passwd)",
            "        and values are the file contents (either as a string or as",
            "        a file-like object). A maximum of five entries is allowed,",
            "        and each file must be 10k or less.",
            "        :param user_data: Optional user data to pass to be exposed by the",
            "        metadata server this can be a file type object as well or",
            "        a string",
            "        :param server_group_id: Optional server group id(uuid) which is used",
            "        for anti_affinity feature",
            "",
            "        :raises ComputeBuildException: if compute failed to build amphora",
            "        :returns: UUID of amphora",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def delete(self, compute_id):",
            "        \"\"\"Delete the specified amphora",
            "",
            "        :param compute_id: The id of the amphora to delete",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def status(self, compute_id):",
            "        \"\"\"Check whether the specified amphora is up",
            "",
            "        :param compute_id: the ID of the desired amphora",
            "        :returns: The compute \"status\" response (\"ONLINE\" or \"OFFLINE\")",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def get_amphora(self, compute_id):",
            "        \"\"\"Retrieve an amphora object",
            "",
            "        :param compute_id: the id of the desired amphora",
            "        :returns: the amphora object",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def create_server_group(self, name, policy):",
            "        \"\"\"Create a server group object",
            "",
            "        :param name: the name of the server group",
            "        :param policy: the policy of the server group",
            "        :returns: the server group object",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def delete_server_group(self, server_group_id):",
            "        \"\"\"Delete a server group object",
            "",
            "        :param server_group_id: the uuid of a server group",
            "        \"\"\"",
            "        pass"
        ],
        "afterPatchFile": [
            "#    Copyright 2011-2014 OpenStack Foundation",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import abc",
            "",
            "import six",
            "",
            "",
            "@six.add_metaclass(abc.ABCMeta)",
            "class ComputeBase(object):",
            "",
            "    @abc.abstractmethod",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None, image_owner=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              config_drive_files=None, user_data=None, server_group_id=None):",
            "        \"\"\"Build a new amphora.",
            "",
            "        :param name: Optional name for Amphora",
            "        :param amphora_flavor: Optionally specify a flavor",
            "        :param image_id: ID of the base image for the amphora instance",
            "        :param image_tag: tag of the base image for the amphora instance",
            "        :param key_name: Optionally specify a keypair",
            "        :param sec_groups: Optionally specify list of security groups",
            "        :param network_ids: A list of network IDs to attach to the amphora",
            "        :param config_drive_files:  An optional dict of files to overwrite on",
            "        the server upon boot. Keys are file names (i.e. /etc/passwd)",
            "        and values are the file contents (either as a string or as",
            "        a file-like object). A maximum of five entries is allowed,",
            "        and each file must be 10k or less.",
            "        :param user_data: Optional user data to pass to be exposed by the",
            "        metadata server this can be a file type object as well or",
            "        a string",
            "        :param server_group_id: Optional server group id(uuid) which is used",
            "        for anti_affinity feature",
            "",
            "        :raises ComputeBuildException: if compute failed to build amphora",
            "        :returns: UUID of amphora",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def delete(self, compute_id):",
            "        \"\"\"Delete the specified amphora",
            "",
            "        :param compute_id: The id of the amphora to delete",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def status(self, compute_id):",
            "        \"\"\"Check whether the specified amphora is up",
            "",
            "        :param compute_id: the ID of the desired amphora",
            "        :returns: The compute \"status\" response (\"ONLINE\" or \"OFFLINE\")",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def get_amphora(self, compute_id):",
            "        \"\"\"Retrieve an amphora object",
            "",
            "        :param compute_id: the id of the desired amphora",
            "        :returns: the amphora object",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def create_server_group(self, name, policy):",
            "        \"\"\"Create a server group object",
            "",
            "        :param name: the name of the server group",
            "        :param policy: the policy of the server group",
            "        :returns: the server group object",
            "        \"\"\"",
            "        pass",
            "",
            "    @abc.abstractmethod",
            "    def delete_server_group(self, server_group_id):",
            "        \"\"\"Delete a server group object",
            "",
            "        :param server_group_id: the uuid of a server group",
            "        \"\"\"",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "25": [
                "ComputeBase",
                "build"
            ]
        },
        "addLocation": []
    },
    "octavia/compute/drivers/noop_driver/driver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         self.computeconfig = {}"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     def build(self, name=\"amphora_name\", amphora_flavor=None,"
            },
            "3": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-              image_id=None, image_tag=None,"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+              image_id=None, image_tag=None, image_owner=None,"
            },
            "5": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "               key_name=None, sec_groups=None, network_ids=None,"
            },
            "6": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "               config_drive_files=None, user_data=None, port_ids=None,"
            },
            "7": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "               server_group_id=None):"
            },
            "8": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         LOG.debug(\"Compute %s no-op, build name %s, amphora_flavor %s, \""
            },
            "9": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"image_id %s, image_tag %s, key_name %s, sec_groups %s, \""
            },
            "10": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"network_ids %s, config_drive_files %s, user_data %s, \""
            },
            "11": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"port_ids %s, server_group_id %s\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+                  \"image_id %s, image_tag %s, image_owner %s, key_name %s, \""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+                  \"sec_groups %s, network_ids %s, config_drive_files %s, \""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+                  \"user_data %s, port_ids %s, server_group_id %s\","
            },
            "15": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "                   self.__class__.__name__,"
            },
            "16": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  name, amphora_flavor, image_id, image_tag,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+                  name, amphora_flavor, image_id, image_tag, image_owner,"
            },
            "18": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "                   key_name, sec_groups, network_ids, config_drive_files,"
            },
            "19": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "                   user_data, port_ids, server_group_id)"
            },
            "20": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         self.computeconfig[(name, amphora_flavor, image_id, image_tag,"
            },
            "21": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            key_name, user_data)] = ("
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+                            image_owner, key_name, user_data)] = ("
            },
            "23": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             name, amphora_flavor,"
            },
            "24": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            image_id, image_tag, key_name, sec_groups,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            image_id, image_tag, image_owner, key_name, sec_groups,"
            },
            "26": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "             network_ids, config_drive_files,"
            },
            "27": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "             user_data, port_ids, 'build')"
            },
            "28": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         compute_id = uuidutils.generate_uuid()"
            },
            "29": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         self.driver = NoopManager()"
            },
            "30": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     def build(self, name=\"amphora_name\", amphora_flavor=None,"
            },
            "32": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-              image_id=None, image_tag=None,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+              image_id=None, image_tag=None, image_owner=None,"
            },
            "34": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "               key_name=None, sec_groups=None, network_ids=None,"
            },
            "35": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "               config_drive_files=None, user_data=None, port_ids=None,"
            },
            "36": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "               server_group_id=None):"
            },
            "37": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         compute_id = self.driver.build(name, amphora_flavor,"
            },
            "39": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                       image_id, image_tag,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                                       image_id, image_tag, image_owner,"
            },
            "41": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "                                        key_name, sec_groups, network_ids,"
            },
            "42": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "                                        config_drive_files, user_data, port_ids,"
            },
            "43": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "                                        server_group_id)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import uuidutils",
            "",
            "from octavia.common import constants",
            "from octavia.common import data_models",
            "from octavia.compute import compute_base as driver_base",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class NoopManager(object):",
            "    def __init__(self):",
            "        super(NoopManager, self).__init__()",
            "        self.computeconfig = {}",
            "",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              config_drive_files=None, user_data=None, port_ids=None,",
            "              server_group_id=None):",
            "        LOG.debug(\"Compute %s no-op, build name %s, amphora_flavor %s, \"",
            "                  \"image_id %s, image_tag %s, key_name %s, sec_groups %s, \"",
            "                  \"network_ids %s, config_drive_files %s, user_data %s, \"",
            "                  \"port_ids %s, server_group_id %s\",",
            "                  self.__class__.__name__,",
            "                  name, amphora_flavor, image_id, image_tag,",
            "                  key_name, sec_groups, network_ids, config_drive_files,",
            "                  user_data, port_ids, server_group_id)",
            "        self.computeconfig[(name, amphora_flavor, image_id, image_tag,",
            "                            key_name, user_data)] = (",
            "            name, amphora_flavor,",
            "            image_id, image_tag, key_name, sec_groups,",
            "            network_ids, config_drive_files,",
            "            user_data, port_ids, 'build')",
            "        compute_id = uuidutils.generate_uuid()",
            "        return compute_id",
            "",
            "    def delete(self, compute_id):",
            "        LOG.debug(\"Compute %s no-op, compute_id %s\",",
            "                  self.__class__.__name__, compute_id)",
            "        self.computeconfig[compute_id] = (compute_id, 'delete')",
            "",
            "    def status(self, compute_id):",
            "        LOG.debug(\"Compute %s no-op, compute_id %s\",",
            "                  self.__class__.__name__, compute_id)",
            "        self.computeconfig[compute_id] = (compute_id, 'status')",
            "        return constants.UP",
            "",
            "    def get_amphora(self, compute_id):",
            "        LOG.debug(\"Compute %s no-op, compute_id %s\",",
            "                  self.__class__.__name__, compute_id)",
            "        self.computeconfig[compute_id] = (compute_id, 'get_amphora')",
            "        return data_models.Amphora(",
            "            compute_id=compute_id,",
            "            status=constants.ACTIVE,",
            "            lb_network_ip='192.0.2.1'",
            "        )",
            "",
            "    def create_server_group(self, name, policy):",
            "        LOG.debug(\"Create Server Group %s no-op, name %s, policy %s \",",
            "                  self.__class__.__name__, name, policy)",
            "        self.computeconfig[(name, policy)] = (name, policy, 'create')",
            "",
            "    def delete_server_group(self, server_group_id):",
            "        LOG.debug(\"Delete Server Group %s no-op, id %s \",",
            "                  self.__class__.__name__, server_group_id)",
            "        self.computeconfig[server_group_id] = (server_group_id, 'delete')",
            "",
            "",
            "class NoopComputeDriver(driver_base.ComputeBase):",
            "    def __init__(self):",
            "        super(NoopComputeDriver, self).__init__()",
            "        self.driver = NoopManager()",
            "",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              config_drive_files=None, user_data=None, port_ids=None,",
            "              server_group_id=None):",
            "",
            "        compute_id = self.driver.build(name, amphora_flavor,",
            "                                       image_id, image_tag,",
            "                                       key_name, sec_groups, network_ids,",
            "                                       config_drive_files, user_data, port_ids,",
            "                                       server_group_id)",
            "        return compute_id",
            "",
            "    def delete(self, compute_id):",
            "        self.driver.delete(compute_id)",
            "",
            "    def status(self, compute_id):",
            "        return self.driver.status(compute_id)",
            "",
            "    def get_amphora(self, compute_id):",
            "        return self.driver.get_amphora(compute_id)",
            "",
            "    def create_server_group(self, name, policy):",
            "        return self.driver.create_server_group(name, policy)",
            "",
            "    def delete_server_group(self, server_group_id):",
            "        self.driver.delete_server_group(server_group_id)"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from oslo_log import log as logging",
            "from oslo_utils import uuidutils",
            "",
            "from octavia.common import constants",
            "from octavia.common import data_models",
            "from octavia.compute import compute_base as driver_base",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class NoopManager(object):",
            "    def __init__(self):",
            "        super(NoopManager, self).__init__()",
            "        self.computeconfig = {}",
            "",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None, image_owner=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              config_drive_files=None, user_data=None, port_ids=None,",
            "              server_group_id=None):",
            "        LOG.debug(\"Compute %s no-op, build name %s, amphora_flavor %s, \"",
            "                  \"image_id %s, image_tag %s, image_owner %s, key_name %s, \"",
            "                  \"sec_groups %s, network_ids %s, config_drive_files %s, \"",
            "                  \"user_data %s, port_ids %s, server_group_id %s\",",
            "                  self.__class__.__name__,",
            "                  name, amphora_flavor, image_id, image_tag, image_owner,",
            "                  key_name, sec_groups, network_ids, config_drive_files,",
            "                  user_data, port_ids, server_group_id)",
            "        self.computeconfig[(name, amphora_flavor, image_id, image_tag,",
            "                            image_owner, key_name, user_data)] = (",
            "            name, amphora_flavor,",
            "            image_id, image_tag, image_owner, key_name, sec_groups,",
            "            network_ids, config_drive_files,",
            "            user_data, port_ids, 'build')",
            "        compute_id = uuidutils.generate_uuid()",
            "        return compute_id",
            "",
            "    def delete(self, compute_id):",
            "        LOG.debug(\"Compute %s no-op, compute_id %s\",",
            "                  self.__class__.__name__, compute_id)",
            "        self.computeconfig[compute_id] = (compute_id, 'delete')",
            "",
            "    def status(self, compute_id):",
            "        LOG.debug(\"Compute %s no-op, compute_id %s\",",
            "                  self.__class__.__name__, compute_id)",
            "        self.computeconfig[compute_id] = (compute_id, 'status')",
            "        return constants.UP",
            "",
            "    def get_amphora(self, compute_id):",
            "        LOG.debug(\"Compute %s no-op, compute_id %s\",",
            "                  self.__class__.__name__, compute_id)",
            "        self.computeconfig[compute_id] = (compute_id, 'get_amphora')",
            "        return data_models.Amphora(",
            "            compute_id=compute_id,",
            "            status=constants.ACTIVE,",
            "            lb_network_ip='192.0.2.1'",
            "        )",
            "",
            "    def create_server_group(self, name, policy):",
            "        LOG.debug(\"Create Server Group %s no-op, name %s, policy %s \",",
            "                  self.__class__.__name__, name, policy)",
            "        self.computeconfig[(name, policy)] = (name, policy, 'create')",
            "",
            "    def delete_server_group(self, server_group_id):",
            "        LOG.debug(\"Delete Server Group %s no-op, id %s \",",
            "                  self.__class__.__name__, server_group_id)",
            "        self.computeconfig[server_group_id] = (server_group_id, 'delete')",
            "",
            "",
            "class NoopComputeDriver(driver_base.ComputeBase):",
            "    def __init__(self):",
            "        super(NoopComputeDriver, self).__init__()",
            "        self.driver = NoopManager()",
            "",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None, image_owner=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              config_drive_files=None, user_data=None, port_ids=None,",
            "              server_group_id=None):",
            "",
            "        compute_id = self.driver.build(name, amphora_flavor,",
            "                                       image_id, image_tag, image_owner,",
            "                                       key_name, sec_groups, network_ids,",
            "                                       config_drive_files, user_data, port_ids,",
            "                                       server_group_id)",
            "        return compute_id",
            "",
            "    def delete(self, compute_id):",
            "        self.driver.delete(compute_id)",
            "",
            "    def status(self, compute_id):",
            "        return self.driver.status(compute_id)",
            "",
            "    def get_amphora(self, compute_id):",
            "        return self.driver.get_amphora(compute_id)",
            "",
            "    def create_server_group(self, name, policy):",
            "        return self.driver.create_server_group(name, policy)",
            "",
            "    def delete_server_group(self, server_group_id):",
            "        self.driver.delete_server_group(server_group_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "31": [
                "NoopManager",
                "build"
            ],
            "36": [
                "NoopManager",
                "build"
            ],
            "37": [
                "NoopManager",
                "build"
            ],
            "38": [
                "NoopManager",
                "build"
            ],
            "40": [
                "NoopManager",
                "build"
            ],
            "44": [
                "NoopManager",
                "build"
            ],
            "46": [
                "NoopManager",
                "build"
            ],
            "90": [
                "NoopComputeDriver",
                "build"
            ],
            "96": [
                "NoopComputeDriver",
                "build"
            ]
        },
        "addLocation": []
    },
    "octavia/compute/drivers/nova_driver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " CONF.import_group('nova', 'octavia.common.config')"
            },
            "1": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _extract_amp_image_id_by_tag(client, image_tag):"
            },
            "4": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    images = list(client.images.list("
            },
            "5": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filters={'tag': [image_tag]},"
            },
            "6": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        sort='created_at:desc',"
            },
            "7": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        limit=2))"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+def _extract_amp_image_id_by_tag(client, image_tag, image_owner):"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    if image_owner:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        images = list(client.images.list("
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            filters={'tag': [image_tag],"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+                     'owner': image_owner,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+                     'status': constants.GLANCE_IMAGE_ACTIVE},"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+            sort='created_at:desc',"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+            limit=2))"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    else:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        images = list(client.images.list("
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+            filters={'tag': [image_tag],"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                     'status': constants.GLANCE_IMAGE_ACTIVE},"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            sort='created_at:desc',"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            limit=2))"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "     if not images:"
            },
            "24": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         raise exceptions.GlanceNoTaggedImages(tag=image_tag)"
            },
            "25": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     image_id = images[0]['id']"
            },
            "26": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     return image_id"
            },
            "27": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def _get_image_uuid(client, image_id, image_tag):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+def _get_image_uuid(client, image_id, image_tag, image_owner):"
            },
            "31": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     if image_id:"
            },
            "32": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         if image_tag:"
            },
            "33": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "             LOG.warning("
            },
            "34": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "                 _LW(\"Both amp_image_id and amp_image_tag options defined. \""
            },
            "35": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"Using the former.\"))"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                    \"Using the amp_image_id.\"))"
            },
            "37": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         return image_id"
            },
            "38": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return _extract_amp_image_id_by_tag(client, image_tag)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    return _extract_amp_image_id_by_tag(client, image_tag, image_owner)"
            },
            "41": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " class VirtualMachineManager(compute_base.ComputeBase):"
            },
            "44": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         self.server_groups = self._nova_client.server_groups"
            },
            "45": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "     def build(self, name=\"amphora_name\", amphora_flavor=None,"
            },
            "47": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-              image_id=None, image_tag=None,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+              image_id=None, image_tag=None, image_owner=None,"
            },
            "49": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "               key_name=None, sec_groups=None, network_ids=None,"
            },
            "50": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "               port_ids=None, config_drive_files=None, user_data=None,"
            },
            "51": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "               server_group_id=None):"
            },
            "52": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "                 \"group\": server_group_id}"
            },
            "53": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "             image_id = _get_image_uuid("
            },
            "55": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self._glance_client, image_id, image_tag)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                self._glance_client, image_id, image_tag, image_owner)"
            },
            "57": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "             amphora = self.manager.create("
            },
            "58": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "                 name=name, image=image_id, flavor=amphora_flavor,"
            },
            "59": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "                 key_name=key_name, security_groups=sec_groups,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 Rackspace",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from novaclient import exceptions as nova_exceptions",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "",
            "from octavia.common import clients",
            "from octavia.common import constants",
            "from octavia.common import data_models as models",
            "from octavia.common import exceptions",
            "from octavia.compute import compute_base",
            "from octavia.i18n import _LE, _LW",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = cfg.CONF",
            "CONF.import_group('glance', 'octavia.common.config')",
            "CONF.import_group('keystone_authtoken', 'octavia.common.config')",
            "CONF.import_group('networking', 'octavia.common.config')",
            "CONF.import_group('nova', 'octavia.common.config')",
            "",
            "",
            "def _extract_amp_image_id_by_tag(client, image_tag):",
            "    images = list(client.images.list(",
            "        filters={'tag': [image_tag]},",
            "        sort='created_at:desc',",
            "        limit=2))",
            "    if not images:",
            "        raise exceptions.GlanceNoTaggedImages(tag=image_tag)",
            "    image_id = images[0]['id']",
            "    num_images = len(images)",
            "    if num_images > 1:",
            "        LOG.warning(",
            "            _LW(\"A single Glance image should be tagged with %(tag)s tag, \"",
            "                \"but at least two were found. Using %(image_id)s.\"),",
            "            {'tag': image_tag, 'image_id': image_id}",
            "        )",
            "    return image_id",
            "",
            "",
            "def _get_image_uuid(client, image_id, image_tag):",
            "    if image_id:",
            "        if image_tag:",
            "            LOG.warning(",
            "                _LW(\"Both amp_image_id and amp_image_tag options defined. \"",
            "                    \"Using the former.\"))",
            "        return image_id",
            "",
            "    return _extract_amp_image_id_by_tag(client, image_tag)",
            "",
            "",
            "class VirtualMachineManager(compute_base.ComputeBase):",
            "    '''Compute implementation of virtual machines via nova.'''",
            "",
            "    def __init__(self):",
            "        super(VirtualMachineManager, self).__init__()",
            "        # Must initialize nova api",
            "        self._nova_client = clients.NovaAuth.get_nova_client(",
            "            endpoint=CONF.nova.endpoint,",
            "            region=CONF.nova.region_name,",
            "            endpoint_type=CONF.nova.endpoint_type,",
            "            insecure=CONF.nova.insecure,",
            "            cacert=CONF.nova.ca_certificates_file)",
            "        self._glance_client = clients.GlanceAuth.get_glance_client(",
            "            service_name=CONF.glance.service_name,",
            "            endpoint=CONF.glance.endpoint,",
            "            region=CONF.glance.region_name,",
            "            endpoint_type=CONF.glance.endpoint_type,",
            "            insecure=CONF.glance.insecure,",
            "            cacert=CONF.glance.ca_certificates_file)",
            "        self.manager = self._nova_client.servers",
            "        self.server_groups = self._nova_client.server_groups",
            "",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              port_ids=None, config_drive_files=None, user_data=None,",
            "              server_group_id=None):",
            "        '''Create a new virtual machine.",
            "",
            "        :param name: optional name for amphora",
            "        :param amphora_flavor: image flavor for virtual machine",
            "        :param image_id: image ID for virtual machine",
            "        :param image_tag: image tag for virtual machine",
            "        :param key_name: keypair to add to the virtual machine",
            "        :param sec_groups: Security group IDs for virtual machine",
            "        :param network_ids: Network IDs to include on virtual machine",
            "        :param port_ids: Port IDs to include on virtual machine",
            "        :param config_drive_files:  An optional dict of files to overwrite on",
            "        the server upon boot. Keys are file names (i.e. /etc/passwd)",
            "        and values are the file contents (either as a string or as",
            "        a file-like object). A maximum of five entries is allowed,",
            "        and each file must be 10k or less.",
            "        :param user_data: Optional user data to pass to be exposed by the",
            "        metadata server this can be a file type object as well or",
            "        a string",
            "        :param server_group_id: Optional server group id(uuid) which is used",
            "        for anti_affinity feature",
            "",
            "        :raises ComputeBuildException: if nova failed to build virtual machine",
            "        :returns: UUID of amphora",
            "        '''",
            "",
            "        try:",
            "            network_ids = network_ids or []",
            "            port_ids = port_ids or []",
            "            nics = []",
            "            if network_ids:",
            "                nics.extend([{\"net-id\": net_id} for net_id in network_ids])",
            "            if port_ids:",
            "                nics.extend([{\"port-id\": port_id} for port_id in port_ids])",
            "",
            "            server_group = None if server_group_id is None else {",
            "                \"group\": server_group_id}",
            "",
            "            image_id = _get_image_uuid(",
            "                self._glance_client, image_id, image_tag)",
            "            amphora = self.manager.create(",
            "                name=name, image=image_id, flavor=amphora_flavor,",
            "                key_name=key_name, security_groups=sec_groups,",
            "                nics=nics,",
            "                files=config_drive_files,",
            "                userdata=user_data,",
            "                config_drive=True,",
            "                scheduler_hints=server_group",
            "            )",
            "",
            "            return amphora.id",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error building nova virtual machine.\"))",
            "            raise exceptions.ComputeBuildException()",
            "",
            "    def delete(self, compute_id):",
            "        '''Delete a virtual machine.",
            "",
            "        :param compute_id: virtual machine UUID",
            "        '''",
            "        try:",
            "            self.manager.delete(server=compute_id)",
            "        except nova_exceptions.NotFound:",
            "            LOG.warning(_LW(\"Nova instance with id: %s not found. \"",
            "                            \"Assuming already deleted.\"), compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error deleting nova virtual machine.\"))",
            "            raise exceptions.ComputeDeleteException()",
            "",
            "    def status(self, compute_id):",
            "        '''Retrieve the status of a virtual machine.",
            "",
            "        :param compute_id: virtual machine UUID",
            "        :returns: constant of amphora status",
            "        '''",
            "        try:",
            "            amphora = self.get_amphora(compute_id)",
            "            if amphora and amphora.status == 'ACTIVE':",
            "                return constants.UP",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error retrieving nova virtual machine status.\"))",
            "            raise exceptions.ComputeStatusException()",
            "        return constants.DOWN",
            "",
            "    def get_amphora(self, compute_id):",
            "        '''Retrieve the information in nova of a virtual machine.",
            "",
            "        :param amphora_id: virtual machine UUID",
            "        :returns: an amphora object",
            "        '''",
            "        # utilize nova client ServerManager 'get' method to retrieve info",
            "        try:",
            "            amphora = self.manager.get(compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error retrieving nova virtual machine.\"))",
            "            raise exceptions.ComputeGetException()",
            "        return self._translate_amphora(amphora)",
            "",
            "    def _translate_amphora(self, nova_response):",
            "        '''Convert a nova virtual machine into an amphora object.",
            "",
            "        :param nova_response: JSON response from nova",
            "        :returns: an amphora object",
            "        '''",
            "        # Extract interfaces of virtual machine to populate desired amphora",
            "        # fields",
            "",
            "        lb_network_ip = None",
            "",
            "        try:",
            "            inf_list = nova_response.interface_list()",
            "            for interface in inf_list:",
            "                net_id = interface.net_id",
            "                if net_id in CONF.controller_worker.amp_boot_network_list:",
            "                    lb_network_ip = interface.fixed_ips[0]['ip_address']",
            "                    break",
            "                elif net_id == CONF.controller_worker.amp_network:",
            "                    # TODO(ptoohill) deprecated, remove this block when ready..",
            "                    lb_network_ip = interface.fixed_ips[0]['ip_address']",
            "                    break",
            "        except Exception:",
            "            LOG.debug('Extracting virtual interfaces through nova '",
            "                      'os-interfaces extension failed.')",
            "",
            "        response = models.Amphora(",
            "            compute_id=nova_response.id,",
            "            status=nova_response.status,",
            "            lb_network_ip=lb_network_ip",
            "        )",
            "        return response",
            "",
            "    def create_server_group(self, name, policy):",
            "        \"\"\"Create a server group object",
            "",
            "        :param name: the name of the server group",
            "        :param policy: the policy of the server group",
            "        :raises: Generic exception if the server group is not created",
            "        :returns: the server group object",
            "        \"\"\"",
            "        kwargs = {'name': name,",
            "                  'policies': [policy]}",
            "        try:",
            "            server_group_obj = self.server_groups.create(**kwargs)",
            "            return server_group_obj",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error create server group instance.\"))",
            "            raise exceptions.ServerGroupObjectCreateException()",
            "",
            "    def delete_server_group(self, server_group_id):",
            "        \"\"\"Delete a server group object",
            "",
            "        :raises: Generic exception if the server group is not deleted",
            "        :param server_group_id: the uuid of a server group",
            "        \"\"\"",
            "        try:",
            "            self.server_groups.delete(server_group_id)",
            "",
            "        except nova_exceptions.NotFound:",
            "            LOG.warning(_LW(\"Server group instance with id: %s not found. \"",
            "                            \"Assuming already deleted.\"), server_group_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error delete server group instance.\"))",
            "            raise exceptions.ServerGroupObjectDeleteException()"
        ],
        "afterPatchFile": [
            "# Copyright 2014 Rackspace",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "from novaclient import exceptions as nova_exceptions",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "",
            "from octavia.common import clients",
            "from octavia.common import constants",
            "from octavia.common import data_models as models",
            "from octavia.common import exceptions",
            "from octavia.compute import compute_base",
            "from octavia.i18n import _LE, _LW",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "CONF = cfg.CONF",
            "CONF.import_group('glance', 'octavia.common.config')",
            "CONF.import_group('keystone_authtoken', 'octavia.common.config')",
            "CONF.import_group('networking', 'octavia.common.config')",
            "CONF.import_group('nova', 'octavia.common.config')",
            "",
            "",
            "def _extract_amp_image_id_by_tag(client, image_tag, image_owner):",
            "    if image_owner:",
            "        images = list(client.images.list(",
            "            filters={'tag': [image_tag],",
            "                     'owner': image_owner,",
            "                     'status': constants.GLANCE_IMAGE_ACTIVE},",
            "            sort='created_at:desc',",
            "            limit=2))",
            "    else:",
            "        images = list(client.images.list(",
            "            filters={'tag': [image_tag],",
            "                     'status': constants.GLANCE_IMAGE_ACTIVE},",
            "            sort='created_at:desc',",
            "            limit=2))",
            "",
            "    if not images:",
            "        raise exceptions.GlanceNoTaggedImages(tag=image_tag)",
            "    image_id = images[0]['id']",
            "    num_images = len(images)",
            "    if num_images > 1:",
            "        LOG.warning(",
            "            _LW(\"A single Glance image should be tagged with %(tag)s tag, \"",
            "                \"but at least two were found. Using %(image_id)s.\"),",
            "            {'tag': image_tag, 'image_id': image_id}",
            "        )",
            "    return image_id",
            "",
            "",
            "def _get_image_uuid(client, image_id, image_tag, image_owner):",
            "    if image_id:",
            "        if image_tag:",
            "            LOG.warning(",
            "                _LW(\"Both amp_image_id and amp_image_tag options defined. \"",
            "                    \"Using the amp_image_id.\"))",
            "        return image_id",
            "",
            "    return _extract_amp_image_id_by_tag(client, image_tag, image_owner)",
            "",
            "",
            "class VirtualMachineManager(compute_base.ComputeBase):",
            "    '''Compute implementation of virtual machines via nova.'''",
            "",
            "    def __init__(self):",
            "        super(VirtualMachineManager, self).__init__()",
            "        # Must initialize nova api",
            "        self._nova_client = clients.NovaAuth.get_nova_client(",
            "            endpoint=CONF.nova.endpoint,",
            "            region=CONF.nova.region_name,",
            "            endpoint_type=CONF.nova.endpoint_type,",
            "            insecure=CONF.nova.insecure,",
            "            cacert=CONF.nova.ca_certificates_file)",
            "        self._glance_client = clients.GlanceAuth.get_glance_client(",
            "            service_name=CONF.glance.service_name,",
            "            endpoint=CONF.glance.endpoint,",
            "            region=CONF.glance.region_name,",
            "            endpoint_type=CONF.glance.endpoint_type,",
            "            insecure=CONF.glance.insecure,",
            "            cacert=CONF.glance.ca_certificates_file)",
            "        self.manager = self._nova_client.servers",
            "        self.server_groups = self._nova_client.server_groups",
            "",
            "    def build(self, name=\"amphora_name\", amphora_flavor=None,",
            "              image_id=None, image_tag=None, image_owner=None,",
            "              key_name=None, sec_groups=None, network_ids=None,",
            "              port_ids=None, config_drive_files=None, user_data=None,",
            "              server_group_id=None):",
            "        '''Create a new virtual machine.",
            "",
            "        :param name: optional name for amphora",
            "        :param amphora_flavor: image flavor for virtual machine",
            "        :param image_id: image ID for virtual machine",
            "        :param image_tag: image tag for virtual machine",
            "        :param key_name: keypair to add to the virtual machine",
            "        :param sec_groups: Security group IDs for virtual machine",
            "        :param network_ids: Network IDs to include on virtual machine",
            "        :param port_ids: Port IDs to include on virtual machine",
            "        :param config_drive_files:  An optional dict of files to overwrite on",
            "        the server upon boot. Keys are file names (i.e. /etc/passwd)",
            "        and values are the file contents (either as a string or as",
            "        a file-like object). A maximum of five entries is allowed,",
            "        and each file must be 10k or less.",
            "        :param user_data: Optional user data to pass to be exposed by the",
            "        metadata server this can be a file type object as well or",
            "        a string",
            "        :param server_group_id: Optional server group id(uuid) which is used",
            "        for anti_affinity feature",
            "",
            "        :raises ComputeBuildException: if nova failed to build virtual machine",
            "        :returns: UUID of amphora",
            "        '''",
            "",
            "        try:",
            "            network_ids = network_ids or []",
            "            port_ids = port_ids or []",
            "            nics = []",
            "            if network_ids:",
            "                nics.extend([{\"net-id\": net_id} for net_id in network_ids])",
            "            if port_ids:",
            "                nics.extend([{\"port-id\": port_id} for port_id in port_ids])",
            "",
            "            server_group = None if server_group_id is None else {",
            "                \"group\": server_group_id}",
            "",
            "            image_id = _get_image_uuid(",
            "                self._glance_client, image_id, image_tag, image_owner)",
            "            amphora = self.manager.create(",
            "                name=name, image=image_id, flavor=amphora_flavor,",
            "                key_name=key_name, security_groups=sec_groups,",
            "                nics=nics,",
            "                files=config_drive_files,",
            "                userdata=user_data,",
            "                config_drive=True,",
            "                scheduler_hints=server_group",
            "            )",
            "",
            "            return amphora.id",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error building nova virtual machine.\"))",
            "            raise exceptions.ComputeBuildException()",
            "",
            "    def delete(self, compute_id):",
            "        '''Delete a virtual machine.",
            "",
            "        :param compute_id: virtual machine UUID",
            "        '''",
            "        try:",
            "            self.manager.delete(server=compute_id)",
            "        except nova_exceptions.NotFound:",
            "            LOG.warning(_LW(\"Nova instance with id: %s not found. \"",
            "                            \"Assuming already deleted.\"), compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error deleting nova virtual machine.\"))",
            "            raise exceptions.ComputeDeleteException()",
            "",
            "    def status(self, compute_id):",
            "        '''Retrieve the status of a virtual machine.",
            "",
            "        :param compute_id: virtual machine UUID",
            "        :returns: constant of amphora status",
            "        '''",
            "        try:",
            "            amphora = self.get_amphora(compute_id)",
            "            if amphora and amphora.status == 'ACTIVE':",
            "                return constants.UP",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error retrieving nova virtual machine status.\"))",
            "            raise exceptions.ComputeStatusException()",
            "        return constants.DOWN",
            "",
            "    def get_amphora(self, compute_id):",
            "        '''Retrieve the information in nova of a virtual machine.",
            "",
            "        :param amphora_id: virtual machine UUID",
            "        :returns: an amphora object",
            "        '''",
            "        # utilize nova client ServerManager 'get' method to retrieve info",
            "        try:",
            "            amphora = self.manager.get(compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error retrieving nova virtual machine.\"))",
            "            raise exceptions.ComputeGetException()",
            "        return self._translate_amphora(amphora)",
            "",
            "    def _translate_amphora(self, nova_response):",
            "        '''Convert a nova virtual machine into an amphora object.",
            "",
            "        :param nova_response: JSON response from nova",
            "        :returns: an amphora object",
            "        '''",
            "        # Extract interfaces of virtual machine to populate desired amphora",
            "        # fields",
            "",
            "        lb_network_ip = None",
            "",
            "        try:",
            "            inf_list = nova_response.interface_list()",
            "            for interface in inf_list:",
            "                net_id = interface.net_id",
            "                if net_id in CONF.controller_worker.amp_boot_network_list:",
            "                    lb_network_ip = interface.fixed_ips[0]['ip_address']",
            "                    break",
            "                elif net_id == CONF.controller_worker.amp_network:",
            "                    # TODO(ptoohill) deprecated, remove this block when ready..",
            "                    lb_network_ip = interface.fixed_ips[0]['ip_address']",
            "                    break",
            "        except Exception:",
            "            LOG.debug('Extracting virtual interfaces through nova '",
            "                      'os-interfaces extension failed.')",
            "",
            "        response = models.Amphora(",
            "            compute_id=nova_response.id,",
            "            status=nova_response.status,",
            "            lb_network_ip=lb_network_ip",
            "        )",
            "        return response",
            "",
            "    def create_server_group(self, name, policy):",
            "        \"\"\"Create a server group object",
            "",
            "        :param name: the name of the server group",
            "        :param policy: the policy of the server group",
            "        :raises: Generic exception if the server group is not created",
            "        :returns: the server group object",
            "        \"\"\"",
            "        kwargs = {'name': name,",
            "                  'policies': [policy]}",
            "        try:",
            "            server_group_obj = self.server_groups.create(**kwargs)",
            "            return server_group_obj",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error create server group instance.\"))",
            "            raise exceptions.ServerGroupObjectCreateException()",
            "",
            "    def delete_server_group(self, server_group_id):",
            "        \"\"\"Delete a server group object",
            "",
            "        :raises: Generic exception if the server group is not deleted",
            "        :param server_group_id: the uuid of a server group",
            "        \"\"\"",
            "        try:",
            "            self.server_groups.delete(server_group_id)",
            "",
            "        except nova_exceptions.NotFound:",
            "            LOG.warning(_LW(\"Server group instance with id: %s not found. \"",
            "                            \"Assuming already deleted.\"), server_group_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Error delete server group instance.\"))",
            "            raise exceptions.ServerGroupObjectDeleteException()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "35": [
                "_extract_amp_image_id_by_tag"
            ],
            "36": [
                "_extract_amp_image_id_by_tag"
            ],
            "37": [
                "_extract_amp_image_id_by_tag"
            ],
            "38": [
                "_extract_amp_image_id_by_tag"
            ],
            "39": [
                "_extract_amp_image_id_by_tag"
            ],
            "53": [
                "_get_image_uuid"
            ],
            "58": [
                "_get_image_uuid"
            ],
            "61": [
                "_get_image_uuid"
            ],
            "87": [
                "VirtualMachineManager",
                "build"
            ],
            "129": [
                "VirtualMachineManager",
                "build"
            ]
        },
        "addLocation": []
    },
    "octavia/controller/worker/tasks/compute_tasks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "                 amphora_flavor=CONF.controller_worker.amp_flavor_id,"
            },
            "1": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "                 image_id=CONF.controller_worker.amp_image_id,"
            },
            "2": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "                 image_tag=CONF.controller_worker.amp_image_tag,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+                image_owner=CONF.controller_worker.amp_image_owner_id,"
            },
            "4": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "                 key_name=key_name,"
            },
            "5": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "                 sec_groups=CONF.controller_worker.amp_secgroup_list,"
            },
            "6": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "                 network_ids=network_ids,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "#",
            "",
            "import logging",
            "import time",
            "",
            "from oslo_config import cfg",
            "import six",
            "from stevedore import driver as stevedore_driver",
            "from taskflow import task",
            "from taskflow.types import failure",
            "",
            "from octavia.amphorae.backends.agent import agent_jinja_cfg",
            "from octavia.common import constants",
            "from octavia.common import exceptions",
            "from octavia.common.jinja import user_data_jinja_cfg",
            "from octavia.i18n import _LE, _LW",
            "",
            "CONF = cfg.CONF",
            "CONF.import_group('controller_worker', 'octavia.common.config')",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class BaseComputeTask(task.Task):",
            "    \"\"\"Base task to load drivers common to the tasks.\"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        super(BaseComputeTask, self).__init__(**kwargs)",
            "        self.compute = stevedore_driver.DriverManager(",
            "            namespace='octavia.compute.drivers',",
            "            name=CONF.controller_worker.compute_driver,",
            "            invoke_on_load=True",
            "        ).driver",
            "",
            "",
            "class ComputeCreate(BaseComputeTask):",
            "    \"\"\"Create the compute instance for a new amphora.\"\"\"",
            "",
            "    def execute(self, amphora_id, ports=None, config_drive_files=None,",
            "                server_group_id=None):",
            "        \"\"\"Create an amphora",
            "",
            "        :returns: an amphora",
            "        \"\"\"",
            "        ports = ports or []",
            "        network_ids = CONF.controller_worker.amp_boot_network_list[:]",
            "        # TODO(ptoohill) amp_network is now deprecated, remove when ready...",
            "        if CONF.controller_worker.amp_network:",
            "            network_ids.append(CONF.controller_worker.amp_network)",
            "        config_drive_files = config_drive_files or {}",
            "        user_data = None",
            "        LOG.debug(\"Compute create execute for amphora with id %s\", amphora_id)",
            "",
            "        user_data_config_drive = CONF.controller_worker.user_data_config_drive",
            "        ssh_access = CONF.controller_worker.amp_ssh_access_allowed",
            "        ssh_key = CONF.controller_worker.amp_ssh_key_name",
            "        key_name = None if not ssh_access else ssh_key",
            "",
            "        try:",
            "            agent_cfg = agent_jinja_cfg.AgentJinjaTemplater()",
            "            config_drive_files['/etc/octavia/amphora-agent.conf'] = (",
            "                agent_cfg.build_agent_config(amphora_id))",
            "            if user_data_config_drive:",
            "                udtemplater = user_data_jinja_cfg.UserDataJinjaCfg()",
            "                user_data = udtemplater.build_user_data_config(",
            "                    config_drive_files)",
            "                config_drive_files = None",
            "",
            "            compute_id = self.compute.build(",
            "                name=\"amphora-\" + amphora_id,",
            "                amphora_flavor=CONF.controller_worker.amp_flavor_id,",
            "                image_id=CONF.controller_worker.amp_image_id,",
            "                image_tag=CONF.controller_worker.amp_image_tag,",
            "                key_name=key_name,",
            "                sec_groups=CONF.controller_worker.amp_secgroup_list,",
            "                network_ids=network_ids,",
            "                port_ids=[port.id for port in ports],",
            "                config_drive_files=config_drive_files,",
            "                user_data=user_data,",
            "                server_group_id=server_group_id)",
            "",
            "            LOG.debug(\"Server created with id: %s for amphora id: %s\",",
            "                      compute_id, amphora_id)",
            "            return compute_id",
            "",
            "        except Exception:",
            "            LOG.exception(_LE(\"Compute create for amphora id: %s failed\"),",
            "                          amphora_id)",
            "            raise",
            "",
            "    def revert(self, result, amphora_id, *args, **kwargs):",
            "        \"\"\"This method will revert the creation of the",
            "",
            "        amphora. So it will just delete it in this flow",
            "        \"\"\"",
            "        if isinstance(result, failure.Failure):",
            "            return",
            "        compute_id = result",
            "        LOG.warning(_LW(\"Reverting compute create for amphora with id\"",
            "                        \"%(amp)s and compute id: %(comp)s\"),",
            "                    {'amp': amphora_id, 'comp': compute_id})",
            "        try:",
            "            self.compute.delete(compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Reverting compute create failed\"))",
            "",
            "",
            "class CertComputeCreate(ComputeCreate):",
            "    def execute(self, amphora_id, server_pem, ports=None,",
            "                server_group_id=None):",
            "        \"\"\"Create an amphora",
            "",
            "        :returns: an amphora",
            "        \"\"\"",
            "",
            "        # load client certificate",
            "        with open(CONF.controller_worker.client_ca, 'r') as client_ca:",
            "            ca = client_ca.read()",
            "        config_drive_files = {",
            "            '/etc/octavia/certs/server.pem': server_pem,",
            "            '/etc/octavia/certs/client_ca.pem': ca}",
            "        return super(CertComputeCreate, self).execute(",
            "            amphora_id, ports=ports, config_drive_files=config_drive_files,",
            "            server_group_id=server_group_id)",
            "",
            "",
            "class DeleteAmphoraeOnLoadBalancer(BaseComputeTask):",
            "    \"\"\"Delete the amphorae on a load balancer.",
            "",
            "    Iterate through amphorae, deleting them",
            "    \"\"\"",
            "",
            "    def execute(self, loadbalancer):",
            "        for amp in six.moves.filter(",
            "            lambda amp: amp.status == constants.AMPHORA_ALLOCATED,",
            "                loadbalancer.amphorae):",
            "",
            "            try:",
            "                self.compute.delete(amp.compute_id)",
            "            except Exception:",
            "                LOG.exception(_LE(\"Compute delete for amphora id: %s failed\"),",
            "                              amp.id)",
            "                raise",
            "",
            "",
            "class ComputeDelete(BaseComputeTask):",
            "    def execute(self, amphora):",
            "        LOG.debug(\"Compute Delete execute for amphora with id %s\", amphora.id)",
            "",
            "        try:",
            "            self.compute.delete(amphora.compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Compute delete for amphora id: %s failed\"),",
            "                          amphora.id)",
            "            raise",
            "",
            "",
            "class ComputeWait(BaseComputeTask):",
            "    \"\"\"Wait for the compute driver to mark the amphora active.\"\"\"",
            "",
            "    def execute(self, compute_id):",
            "        \"\"\"Wait for the compute driver to mark the amphora active",
            "",
            "        :raises: Generic exception if the amphora is not active",
            "        :returns: An amphora object",
            "        \"\"\"",
            "        for i in range(CONF.controller_worker.amp_active_retries):",
            "            amp = self.compute.get_amphora(compute_id)",
            "            if amp.status == constants.ACTIVE:",
            "                return amp",
            "            elif amp.status == constants.ERROR:",
            "                raise exceptions.ComputeBuildException()",
            "            time.sleep(CONF.controller_worker.amp_active_wait_sec)",
            "",
            "        raise exceptions.ComputeWaitTimeoutException()",
            "",
            "",
            "class NovaServerGroupCreate(BaseComputeTask):",
            "    def execute(self, loadbalancer_id):",
            "        \"\"\"Create a server group by nova client api",
            "",
            "        :param loadbalancer_id: will be used for server group's name",
            "        :param policy: will used for server group's policy",
            "        :raises: Generic exception if the server group is not created",
            "        :returns: server group's id",
            "        \"\"\"",
            "",
            "        name = 'octavia-lb-' + loadbalancer_id",
            "        server_group = self.compute.create_server_group(",
            "            name, constants.ANTI_AFFINITY)",
            "        LOG.debug(\"Server Group created with id: %s for load balancer id: \"",
            "                  \"%s\", server_group.id, loadbalancer_id)",
            "        return server_group.id",
            "",
            "    def revert(self, result, *args, **kwargs):",
            "        \"\"\"This method will revert the creation of the",
            "",
            "        :param result: here it refers to server group id",
            "        \"\"\"",
            "        server_group_id = result",
            "        LOG.warning(_LW(\"Reverting server group create with id:%s\"),",
            "                    server_group_id)",
            "        self.compute.delete_server_group(server_group_id)",
            "",
            "",
            "class NovaServerGroupDelete(BaseComputeTask):",
            "    def execute(self, server_group_id):",
            "        if server_group_id is not None:",
            "            self.compute.delete_server_group(server_group_id)",
            "        else:",
            "            return"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "#",
            "",
            "import logging",
            "import time",
            "",
            "from oslo_config import cfg",
            "import six",
            "from stevedore import driver as stevedore_driver",
            "from taskflow import task",
            "from taskflow.types import failure",
            "",
            "from octavia.amphorae.backends.agent import agent_jinja_cfg",
            "from octavia.common import constants",
            "from octavia.common import exceptions",
            "from octavia.common.jinja import user_data_jinja_cfg",
            "from octavia.i18n import _LE, _LW",
            "",
            "CONF = cfg.CONF",
            "CONF.import_group('controller_worker', 'octavia.common.config')",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "class BaseComputeTask(task.Task):",
            "    \"\"\"Base task to load drivers common to the tasks.\"\"\"",
            "",
            "    def __init__(self, **kwargs):",
            "        super(BaseComputeTask, self).__init__(**kwargs)",
            "        self.compute = stevedore_driver.DriverManager(",
            "            namespace='octavia.compute.drivers',",
            "            name=CONF.controller_worker.compute_driver,",
            "            invoke_on_load=True",
            "        ).driver",
            "",
            "",
            "class ComputeCreate(BaseComputeTask):",
            "    \"\"\"Create the compute instance for a new amphora.\"\"\"",
            "",
            "    def execute(self, amphora_id, ports=None, config_drive_files=None,",
            "                server_group_id=None):",
            "        \"\"\"Create an amphora",
            "",
            "        :returns: an amphora",
            "        \"\"\"",
            "        ports = ports or []",
            "        network_ids = CONF.controller_worker.amp_boot_network_list[:]",
            "        # TODO(ptoohill) amp_network is now deprecated, remove when ready...",
            "        if CONF.controller_worker.amp_network:",
            "            network_ids.append(CONF.controller_worker.amp_network)",
            "        config_drive_files = config_drive_files or {}",
            "        user_data = None",
            "        LOG.debug(\"Compute create execute for amphora with id %s\", amphora_id)",
            "",
            "        user_data_config_drive = CONF.controller_worker.user_data_config_drive",
            "        ssh_access = CONF.controller_worker.amp_ssh_access_allowed",
            "        ssh_key = CONF.controller_worker.amp_ssh_key_name",
            "        key_name = None if not ssh_access else ssh_key",
            "",
            "        try:",
            "            agent_cfg = agent_jinja_cfg.AgentJinjaTemplater()",
            "            config_drive_files['/etc/octavia/amphora-agent.conf'] = (",
            "                agent_cfg.build_agent_config(amphora_id))",
            "            if user_data_config_drive:",
            "                udtemplater = user_data_jinja_cfg.UserDataJinjaCfg()",
            "                user_data = udtemplater.build_user_data_config(",
            "                    config_drive_files)",
            "                config_drive_files = None",
            "",
            "            compute_id = self.compute.build(",
            "                name=\"amphora-\" + amphora_id,",
            "                amphora_flavor=CONF.controller_worker.amp_flavor_id,",
            "                image_id=CONF.controller_worker.amp_image_id,",
            "                image_tag=CONF.controller_worker.amp_image_tag,",
            "                image_owner=CONF.controller_worker.amp_image_owner_id,",
            "                key_name=key_name,",
            "                sec_groups=CONF.controller_worker.amp_secgroup_list,",
            "                network_ids=network_ids,",
            "                port_ids=[port.id for port in ports],",
            "                config_drive_files=config_drive_files,",
            "                user_data=user_data,",
            "                server_group_id=server_group_id)",
            "",
            "            LOG.debug(\"Server created with id: %s for amphora id: %s\",",
            "                      compute_id, amphora_id)",
            "            return compute_id",
            "",
            "        except Exception:",
            "            LOG.exception(_LE(\"Compute create for amphora id: %s failed\"),",
            "                          amphora_id)",
            "            raise",
            "",
            "    def revert(self, result, amphora_id, *args, **kwargs):",
            "        \"\"\"This method will revert the creation of the",
            "",
            "        amphora. So it will just delete it in this flow",
            "        \"\"\"",
            "        if isinstance(result, failure.Failure):",
            "            return",
            "        compute_id = result",
            "        LOG.warning(_LW(\"Reverting compute create for amphora with id\"",
            "                        \"%(amp)s and compute id: %(comp)s\"),",
            "                    {'amp': amphora_id, 'comp': compute_id})",
            "        try:",
            "            self.compute.delete(compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Reverting compute create failed\"))",
            "",
            "",
            "class CertComputeCreate(ComputeCreate):",
            "    def execute(self, amphora_id, server_pem, ports=None,",
            "                server_group_id=None):",
            "        \"\"\"Create an amphora",
            "",
            "        :returns: an amphora",
            "        \"\"\"",
            "",
            "        # load client certificate",
            "        with open(CONF.controller_worker.client_ca, 'r') as client_ca:",
            "            ca = client_ca.read()",
            "        config_drive_files = {",
            "            '/etc/octavia/certs/server.pem': server_pem,",
            "            '/etc/octavia/certs/client_ca.pem': ca}",
            "        return super(CertComputeCreate, self).execute(",
            "            amphora_id, ports=ports, config_drive_files=config_drive_files,",
            "            server_group_id=server_group_id)",
            "",
            "",
            "class DeleteAmphoraeOnLoadBalancer(BaseComputeTask):",
            "    \"\"\"Delete the amphorae on a load balancer.",
            "",
            "    Iterate through amphorae, deleting them",
            "    \"\"\"",
            "",
            "    def execute(self, loadbalancer):",
            "        for amp in six.moves.filter(",
            "            lambda amp: amp.status == constants.AMPHORA_ALLOCATED,",
            "                loadbalancer.amphorae):",
            "",
            "            try:",
            "                self.compute.delete(amp.compute_id)",
            "            except Exception:",
            "                LOG.exception(_LE(\"Compute delete for amphora id: %s failed\"),",
            "                              amp.id)",
            "                raise",
            "",
            "",
            "class ComputeDelete(BaseComputeTask):",
            "    def execute(self, amphora):",
            "        LOG.debug(\"Compute Delete execute for amphora with id %s\", amphora.id)",
            "",
            "        try:",
            "            self.compute.delete(amphora.compute_id)",
            "        except Exception:",
            "            LOG.exception(_LE(\"Compute delete for amphora id: %s failed\"),",
            "                          amphora.id)",
            "            raise",
            "",
            "",
            "class ComputeWait(BaseComputeTask):",
            "    \"\"\"Wait for the compute driver to mark the amphora active.\"\"\"",
            "",
            "    def execute(self, compute_id):",
            "        \"\"\"Wait for the compute driver to mark the amphora active",
            "",
            "        :raises: Generic exception if the amphora is not active",
            "        :returns: An amphora object",
            "        \"\"\"",
            "        for i in range(CONF.controller_worker.amp_active_retries):",
            "            amp = self.compute.get_amphora(compute_id)",
            "            if amp.status == constants.ACTIVE:",
            "                return amp",
            "            elif amp.status == constants.ERROR:",
            "                raise exceptions.ComputeBuildException()",
            "            time.sleep(CONF.controller_worker.amp_active_wait_sec)",
            "",
            "        raise exceptions.ComputeWaitTimeoutException()",
            "",
            "",
            "class NovaServerGroupCreate(BaseComputeTask):",
            "    def execute(self, loadbalancer_id):",
            "        \"\"\"Create a server group by nova client api",
            "",
            "        :param loadbalancer_id: will be used for server group's name",
            "        :param policy: will used for server group's policy",
            "        :raises: Generic exception if the server group is not created",
            "        :returns: server group's id",
            "        \"\"\"",
            "",
            "        name = 'octavia-lb-' + loadbalancer_id",
            "        server_group = self.compute.create_server_group(",
            "            name, constants.ANTI_AFFINITY)",
            "        LOG.debug(\"Server Group created with id: %s for load balancer id: \"",
            "                  \"%s\", server_group.id, loadbalancer_id)",
            "        return server_group.id",
            "",
            "    def revert(self, result, *args, **kwargs):",
            "        \"\"\"This method will revert the creation of the",
            "",
            "        :param result: here it refers to server group id",
            "        \"\"\"",
            "        server_group_id = result",
            "        LOG.warning(_LW(\"Reverting server group create with id:%s\"),",
            "                    server_group_id)",
            "        self.compute.delete_server_group(server_group_id)",
            "",
            "",
            "class NovaServerGroupDelete(BaseComputeTask):",
            "    def execute(self, server_group_id):",
            "        if server_group_id is not None:",
            "            self.compute.delete_server_group(server_group_id)",
            "        else:",
            "            return"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "PyPDF2.pdf"
        ]
    },
    "octavia/tests/unit/compute/drivers/test_nova_driver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         with mock.patch.object(nova_common,"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "                                '_extract_amp_image_id_by_tag',"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "                                return_value='fakeid') as extract:"
            },
            "3": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            image_id = nova_common._get_image_uuid(client, '', 'faketag')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+            image_id = nova_common._get_image_uuid(client, '', 'faketag', None)"
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": "         self.assertEqual('fakeid', image_id)"
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        extract.assert_called_with(client, 'faketag')"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        extract.assert_called_with(client, 'faketag', None)"
            },
            "8": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     def test__get_image_uuid_notag(self):"
            },
            "10": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         client = mock.Mock()"
            },
            "11": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        image_id = nova_common._get_image_uuid(client, 'fakeid', '')"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        image_id = nova_common._get_image_uuid(client, 'fakeid', '', None)"
            },
            "13": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         self.assertEqual('fakeid', image_id)"
            },
            "14": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     def test__get_image_uuid_id_beats_tag(self):"
            },
            "16": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "         client = mock.Mock()"
            },
            "17": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        image_id = nova_common._get_image_uuid(client, 'fakeid', 'faketag')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        image_id = nova_common._get_image_uuid(client, 'fakeid',"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+                                               'faketag', None)"
            },
            "20": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "         self.assertEqual('fakeid', image_id)"
            },
            "21": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         self.client.images.list.return_value = []"
            },
            "24": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         self.assertRaises("
            },
            "25": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "             exceptions.GlanceNoTaggedImages,"
            },
            "26": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            nova_common._extract_amp_image_id_by_tag, self.client, 'faketag')"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            nova_common._extract_amp_image_id_by_tag, self.client,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            'faketag', None)"
            },
            "29": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def test_single_image(self):"
            },
            "31": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         images = ["
            },
            "32": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "             {'id': uuidutils.generate_uuid(), 'tag': 'faketag'}"
            },
            "33": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         ]"
            },
            "34": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         self.client.images.list.return_value = images"
            },
            "35": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         image_id = nova_common._extract_amp_image_id_by_tag(self.client,"
            },
            "36": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                            'faketag')"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                                                            'faketag', None)"
            },
            "38": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         self.assertIn(image_id, images[0]['id'])"
            },
            "39": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     def test_multiple_images_returns_one_of_images(self):"
            },
            "41": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         ]"
            },
            "42": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self.client.images.list.return_value = images"
            },
            "43": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         image_id = nova_common._extract_amp_image_id_by_tag(self.client,"
            },
            "44": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                            'faketag')"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+                                                            'faketag', None)"
            },
            "46": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         self.assertIn(image_id, [image['id'] for image in images])"
            },
            "47": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "48": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#    Copyright 2014 Rackspace",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from novaclient import exceptions as nova_exceptions",
            "from oslo_config import cfg",
            "from oslo_utils import uuidutils",
            "",
            "from octavia.common import clients",
            "from octavia.common import constants",
            "from octavia.common import data_models as models",
            "from octavia.common import exceptions",
            "import octavia.compute.drivers.nova_driver as nova_common",
            "import octavia.tests.unit.base as base",
            "",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "class Test_GetImageUuid(base.TestCase):",
            "",
            "    def test__get_image_uuid_tag(self):",
            "        client = mock.Mock()",
            "        with mock.patch.object(nova_common,",
            "                               '_extract_amp_image_id_by_tag',",
            "                               return_value='fakeid') as extract:",
            "            image_id = nova_common._get_image_uuid(client, '', 'faketag')",
            "        self.assertEqual('fakeid', image_id)",
            "        extract.assert_called_with(client, 'faketag')",
            "",
            "    def test__get_image_uuid_notag(self):",
            "        client = mock.Mock()",
            "        image_id = nova_common._get_image_uuid(client, 'fakeid', '')",
            "        self.assertEqual('fakeid', image_id)",
            "",
            "    def test__get_image_uuid_id_beats_tag(self):",
            "        client = mock.Mock()",
            "        image_id = nova_common._get_image_uuid(client, 'fakeid', 'faketag')",
            "        self.assertEqual('fakeid', image_id)",
            "",
            "",
            "class Test_ExtractAmpImageIdByTag(base.TestCase):",
            "",
            "    def setUp(self):",
            "        super(Test_ExtractAmpImageIdByTag, self).setUp()",
            "        client_mock = mock.patch.object(clients.GlanceAuth,",
            "                                        'get_glance_client')",
            "        self.client = client_mock.start().return_value",
            "",
            "    def test_no_images(self):",
            "        self.client.images.list.return_value = []",
            "        self.assertRaises(",
            "            exceptions.GlanceNoTaggedImages,",
            "            nova_common._extract_amp_image_id_by_tag, self.client, 'faketag')",
            "",
            "    def test_single_image(self):",
            "        images = [",
            "            {'id': uuidutils.generate_uuid(), 'tag': 'faketag'}",
            "        ]",
            "        self.client.images.list.return_value = images",
            "        image_id = nova_common._extract_amp_image_id_by_tag(self.client,",
            "                                                            'faketag')",
            "        self.assertIn(image_id, images[0]['id'])",
            "",
            "    def test_multiple_images_returns_one_of_images(self):",
            "        images = [",
            "            {'id': image_id, 'tag': 'faketag'}",
            "            for image_id in [uuidutils.generate_uuid() for i in range(10)]",
            "        ]",
            "        self.client.images.list.return_value = images",
            "        image_id = nova_common._extract_amp_image_id_by_tag(self.client,",
            "                                                            'faketag')",
            "        self.assertIn(image_id, [image['id'] for image in images])",
            "",
            "",
            "class TestNovaClient(base.TestCase):",
            "",
            "    def setUp(self):",
            "        CONF.set_override(group='keystone_authtoken', name='auth_version',",
            "                          override='2', enforce_type=True)",
            "        self.net_name = \"lb-mgmt-net\"",
            "        CONF.set_override(group='networking', name='lb_network_name',",
            "                          override=self.net_name, enforce_type=True)",
            "        CONF.set_override(group='controller_worker',",
            "                          name='amp_boot_network_list',",
            "                          override=[1, 2], enforce_type=True)",
            "",
            "        self.amphora = models.Amphora(",
            "            compute_id=uuidutils.generate_uuid(),",
            "            status='ACTIVE',",
            "            lb_network_ip='10.0.0.1'",
            "        )",
            "",
            "        self.nova_response = mock.Mock()",
            "        self.nova_response.id = self.amphora.compute_id",
            "        self.nova_response.status = 'ACTIVE'",
            "",
            "        self.interface_list = mock.MagicMock()",
            "        self.interface_list.net_id = 1",
            "        self.interface_list.fixed_ips = [mock.MagicMock()]",
            "        self.interface_list.fixed_ips[0] = {'ip_address': '10.0.0.1'}",
            "",
            "        self.loadbalancer_id = uuidutils.generate_uuid()",
            "        self.server_group_policy = constants.ANTI_AFFINITY",
            "        self.server_group_id = uuidutils.generate_uuid()",
            "",
            "        self.manager = nova_common.VirtualMachineManager()",
            "        self.manager.manager = mock.MagicMock()",
            "        self.manager.server_groups = mock.MagicMock()",
            "        self.manager._nova_client = mock.MagicMock()",
            "",
            "        self.nova_response.interface_list.side_effect = [[self.interface_list]]",
            "        self.manager.manager.get.return_value = self.nova_response",
            "        self.manager.manager.create.return_value = self.nova_response",
            "        self.manager.server_groups.create.return_value = mock.Mock()",
            "",
            "        self.nova_response.addresses = {self.net_name: [{'addr': '10.0.0.1'}]}",
            "",
            "        self.nova_network = mock.Mock()",
            "        self.nova_network.label = self.net_name",
            "",
            "        self.server_group_name = 'octavia-lb-' + self.loadbalancer_id",
            "        self.server_group_kwargs = {'name': self.server_group_name,",
            "                                    'policies': [self.server_group_policy]}",
            "",
            "        self.server_group_mock = mock.Mock()",
            "        self.server_group_mock.name = self.server_group_name",
            "        self.server_group_mock.policy = self.server_group_policy",
            "        self.server_group_mock.id = self.server_group_id",
            "",
            "        super(TestNovaClient, self).setUp()",
            "",
            "    def test_build(self):",
            "        amphora_id = self.manager.build(amphora_flavor=1, image_id=1,",
            "                                        key_name=1,",
            "                                        sec_groups=1,",
            "                                        network_ids=[1],",
            "                                        port_ids=[2],",
            "                                        user_data='Blah',",
            "                                        config_drive_files='Files Blah')",
            "",
            "        self.assertEqual(self.amphora.compute_id, amphora_id)",
            "",
            "        self.manager.manager.create.assert_called_with(",
            "            name=\"amphora_name\",",
            "            nics=[{'net-id': 1}, {'port-id': 2}],",
            "            image=1,",
            "            flavor=1,",
            "            key_name=1,",
            "            security_groups=1,",
            "            files='Files Blah',",
            "            userdata='Blah',",
            "            config_drive=True,",
            "            scheduler_hints=None)",
            "",
            "    def test_bad_build(self):",
            "        self.manager.manager.create.side_effect = Exception",
            "        self.assertRaises(exceptions.ComputeBuildException, self.manager.build)",
            "",
            "    def test_build_extracts_image_id_by_tag(self):",
            "        expected_id = 'fakeid-by-tag'",
            "        with mock.patch.object(nova_common, '_get_image_uuid',",
            "                               return_value=expected_id):",
            "            self.manager.build(image_id='fakeid', image_tag='tag')",
            "",
            "        self.assertEqual(expected_id,",
            "                         self.manager.manager.create.call_args[1]['image'])",
            "",
            "    def test_delete(self):",
            "        amphora_id = self.manager.build(amphora_flavor=1, image_id=1,",
            "                                        key_name=1, sec_groups=1,",
            "                                        network_ids=[1])",
            "        self.manager.delete(amphora_id)",
            "        self.manager.manager.delete.assert_called_with(server=amphora_id)",
            "",
            "    def test_bad_delete(self):",
            "        self.manager.manager.delete.side_effect = Exception",
            "        amphora_id = self.manager.build(amphora_flavor=1, image_id=1,",
            "                                        key_name=1, sec_groups=1,",
            "                                        network_ids=[1])",
            "        self.assertRaises(exceptions.ComputeDeleteException,",
            "                          self.manager.delete, amphora_id)",
            "",
            "    def test_status(self):",
            "        status = self.manager.status(self.amphora.id)",
            "        self.assertEqual(constants.UP, status)",
            "",
            "    def test_bad_status(self):",
            "        self.manager.manager.get.side_effect = Exception",
            "        self.assertRaises(exceptions.ComputeStatusException,",
            "                          self.manager.status, self.amphora.id)",
            "",
            "    def test_get_amphora(self):",
            "        amphora = self.manager.get_amphora(self.amphora.compute_id)",
            "        self.assertEqual(self.amphora, amphora)",
            "        self.manager.manager.get.called_with(server=amphora.id)",
            "",
            "    def test_bad_get_amphora(self):",
            "        self.manager.manager.get.side_effect = Exception",
            "        self.assertRaises(exceptions.ComputeGetException,",
            "                          self.manager.get_amphora, self.amphora.id)",
            "",
            "    def test_translate_amphora(self):",
            "        amphora = self.manager._translate_amphora(self.nova_response)",
            "        self.assertEqual(self.amphora, amphora)",
            "        self.nova_response.interface_list.called_with()",
            "",
            "    def test_bad_translate_amphora(self):",
            "        self.nova_response.interface_list.side_effect = Exception",
            "        self.manager._nova_client.networks.get.side_effect = Exception",
            "        self.assertIsNone(",
            "            self.manager._translate_amphora(self.nova_response).lb_network_ip)",
            "        self.nova_response.interface_list.called_with()",
            "",
            "    def test_create_server_group(self):",
            "        self.manager.server_groups.create.return_value = self.server_group_mock",
            "",
            "        sg = self.manager.create_server_group(self.server_group_name,",
            "                                              self.server_group_policy)",
            "",
            "        self.assertEqual(sg.id, self.server_group_id)",
            "        self.assertEqual(sg.name, self.server_group_name)",
            "        self.assertEqual(sg.policy, self.server_group_policy)",
            "        self.manager.server_groups.create.called_with(",
            "            **self.server_group_kwargs)",
            "",
            "    def test_bad_create_server_group(self):",
            "        self.manager.server_groups.create.side_effect = Exception",
            "        self.assertRaises(exceptions.ServerGroupObjectCreateException,",
            "                          self.manager.create_server_group,",
            "                          self.server_group_name, self.server_group_policy)",
            "        self.manager.server_groups.create.called_with(",
            "            **self.server_group_kwargs)",
            "",
            "    def test_delete_server_group(self):",
            "        self.manager.delete_server_group(self.server_group_id)",
            "        self.manager.server_groups.delete.called_with(self.server_group_id)",
            "",
            "    def test_bad_delete_server_group(self):",
            "        self.manager.server_groups.delete.side_effect = [",
            "            nova_exceptions.NotFound('test_exception'), Exception]",
            "",
            "        # NotFound should not raise an exception",
            "",
            "        self.manager.delete_server_group(self.server_group_id)",
            "        self.manager.server_groups.delete.called_with(self.server_group_id)",
            "",
            "        # Catch the exception for server group object delete exception",
            "",
            "        self.assertRaises(exceptions.ServerGroupObjectDeleteException,",
            "                          self.manager.delete_server_group,",
            "                          self.server_group_id)",
            "        self.manager.server_groups.delete.called_with(self.server_group_id)"
        ],
        "afterPatchFile": [
            "#    Copyright 2014 Rackspace",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import mock",
            "from novaclient import exceptions as nova_exceptions",
            "from oslo_config import cfg",
            "from oslo_utils import uuidutils",
            "",
            "from octavia.common import clients",
            "from octavia.common import constants",
            "from octavia.common import data_models as models",
            "from octavia.common import exceptions",
            "import octavia.compute.drivers.nova_driver as nova_common",
            "import octavia.tests.unit.base as base",
            "",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "class Test_GetImageUuid(base.TestCase):",
            "",
            "    def test__get_image_uuid_tag(self):",
            "        client = mock.Mock()",
            "        with mock.patch.object(nova_common,",
            "                               '_extract_amp_image_id_by_tag',",
            "                               return_value='fakeid') as extract:",
            "            image_id = nova_common._get_image_uuid(client, '', 'faketag', None)",
            "        self.assertEqual('fakeid', image_id)",
            "        extract.assert_called_with(client, 'faketag', None)",
            "",
            "    def test__get_image_uuid_notag(self):",
            "        client = mock.Mock()",
            "        image_id = nova_common._get_image_uuid(client, 'fakeid', '', None)",
            "        self.assertEqual('fakeid', image_id)",
            "",
            "    def test__get_image_uuid_id_beats_tag(self):",
            "        client = mock.Mock()",
            "        image_id = nova_common._get_image_uuid(client, 'fakeid',",
            "                                               'faketag', None)",
            "        self.assertEqual('fakeid', image_id)",
            "",
            "",
            "class Test_ExtractAmpImageIdByTag(base.TestCase):",
            "",
            "    def setUp(self):",
            "        super(Test_ExtractAmpImageIdByTag, self).setUp()",
            "        client_mock = mock.patch.object(clients.GlanceAuth,",
            "                                        'get_glance_client')",
            "        self.client = client_mock.start().return_value",
            "",
            "    def test_no_images(self):",
            "        self.client.images.list.return_value = []",
            "        self.assertRaises(",
            "            exceptions.GlanceNoTaggedImages,",
            "            nova_common._extract_amp_image_id_by_tag, self.client,",
            "            'faketag', None)",
            "",
            "    def test_single_image(self):",
            "        images = [",
            "            {'id': uuidutils.generate_uuid(), 'tag': 'faketag'}",
            "        ]",
            "        self.client.images.list.return_value = images",
            "        image_id = nova_common._extract_amp_image_id_by_tag(self.client,",
            "                                                            'faketag', None)",
            "        self.assertIn(image_id, images[0]['id'])",
            "",
            "    def test_multiple_images_returns_one_of_images(self):",
            "        images = [",
            "            {'id': image_id, 'tag': 'faketag'}",
            "            for image_id in [uuidutils.generate_uuid() for i in range(10)]",
            "        ]",
            "        self.client.images.list.return_value = images",
            "        image_id = nova_common._extract_amp_image_id_by_tag(self.client,",
            "                                                            'faketag', None)",
            "        self.assertIn(image_id, [image['id'] for image in images])",
            "",
            "",
            "class TestNovaClient(base.TestCase):",
            "",
            "    def setUp(self):",
            "        CONF.set_override(group='keystone_authtoken', name='auth_version',",
            "                          override='2', enforce_type=True)",
            "        self.net_name = \"lb-mgmt-net\"",
            "        CONF.set_override(group='networking', name='lb_network_name',",
            "                          override=self.net_name, enforce_type=True)",
            "        CONF.set_override(group='controller_worker',",
            "                          name='amp_boot_network_list',",
            "                          override=[1, 2], enforce_type=True)",
            "",
            "        self.amphora = models.Amphora(",
            "            compute_id=uuidutils.generate_uuid(),",
            "            status='ACTIVE',",
            "            lb_network_ip='10.0.0.1'",
            "        )",
            "",
            "        self.nova_response = mock.Mock()",
            "        self.nova_response.id = self.amphora.compute_id",
            "        self.nova_response.status = 'ACTIVE'",
            "",
            "        self.interface_list = mock.MagicMock()",
            "        self.interface_list.net_id = 1",
            "        self.interface_list.fixed_ips = [mock.MagicMock()]",
            "        self.interface_list.fixed_ips[0] = {'ip_address': '10.0.0.1'}",
            "",
            "        self.loadbalancer_id = uuidutils.generate_uuid()",
            "        self.server_group_policy = constants.ANTI_AFFINITY",
            "        self.server_group_id = uuidutils.generate_uuid()",
            "",
            "        self.manager = nova_common.VirtualMachineManager()",
            "        self.manager.manager = mock.MagicMock()",
            "        self.manager.server_groups = mock.MagicMock()",
            "        self.manager._nova_client = mock.MagicMock()",
            "",
            "        self.nova_response.interface_list.side_effect = [[self.interface_list]]",
            "        self.manager.manager.get.return_value = self.nova_response",
            "        self.manager.manager.create.return_value = self.nova_response",
            "        self.manager.server_groups.create.return_value = mock.Mock()",
            "",
            "        self.nova_response.addresses = {self.net_name: [{'addr': '10.0.0.1'}]}",
            "",
            "        self.nova_network = mock.Mock()",
            "        self.nova_network.label = self.net_name",
            "",
            "        self.server_group_name = 'octavia-lb-' + self.loadbalancer_id",
            "        self.server_group_kwargs = {'name': self.server_group_name,",
            "                                    'policies': [self.server_group_policy]}",
            "",
            "        self.server_group_mock = mock.Mock()",
            "        self.server_group_mock.name = self.server_group_name",
            "        self.server_group_mock.policy = self.server_group_policy",
            "        self.server_group_mock.id = self.server_group_id",
            "",
            "        super(TestNovaClient, self).setUp()",
            "",
            "    def test_build(self):",
            "        amphora_id = self.manager.build(amphora_flavor=1, image_id=1,",
            "                                        key_name=1,",
            "                                        sec_groups=1,",
            "                                        network_ids=[1],",
            "                                        port_ids=[2],",
            "                                        user_data='Blah',",
            "                                        config_drive_files='Files Blah')",
            "",
            "        self.assertEqual(self.amphora.compute_id, amphora_id)",
            "",
            "        self.manager.manager.create.assert_called_with(",
            "            name=\"amphora_name\",",
            "            nics=[{'net-id': 1}, {'port-id': 2}],",
            "            image=1,",
            "            flavor=1,",
            "            key_name=1,",
            "            security_groups=1,",
            "            files='Files Blah',",
            "            userdata='Blah',",
            "            config_drive=True,",
            "            scheduler_hints=None)",
            "",
            "    def test_bad_build(self):",
            "        self.manager.manager.create.side_effect = Exception",
            "        self.assertRaises(exceptions.ComputeBuildException, self.manager.build)",
            "",
            "    def test_build_extracts_image_id_by_tag(self):",
            "        expected_id = 'fakeid-by-tag'",
            "        with mock.patch.object(nova_common, '_get_image_uuid',",
            "                               return_value=expected_id):",
            "            self.manager.build(image_id='fakeid', image_tag='tag')",
            "",
            "        self.assertEqual(expected_id,",
            "                         self.manager.manager.create.call_args[1]['image'])",
            "",
            "    def test_delete(self):",
            "        amphora_id = self.manager.build(amphora_flavor=1, image_id=1,",
            "                                        key_name=1, sec_groups=1,",
            "                                        network_ids=[1])",
            "        self.manager.delete(amphora_id)",
            "        self.manager.manager.delete.assert_called_with(server=amphora_id)",
            "",
            "    def test_bad_delete(self):",
            "        self.manager.manager.delete.side_effect = Exception",
            "        amphora_id = self.manager.build(amphora_flavor=1, image_id=1,",
            "                                        key_name=1, sec_groups=1,",
            "                                        network_ids=[1])",
            "        self.assertRaises(exceptions.ComputeDeleteException,",
            "                          self.manager.delete, amphora_id)",
            "",
            "    def test_status(self):",
            "        status = self.manager.status(self.amphora.id)",
            "        self.assertEqual(constants.UP, status)",
            "",
            "    def test_bad_status(self):",
            "        self.manager.manager.get.side_effect = Exception",
            "        self.assertRaises(exceptions.ComputeStatusException,",
            "                          self.manager.status, self.amphora.id)",
            "",
            "    def test_get_amphora(self):",
            "        amphora = self.manager.get_amphora(self.amphora.compute_id)",
            "        self.assertEqual(self.amphora, amphora)",
            "        self.manager.manager.get.called_with(server=amphora.id)",
            "",
            "    def test_bad_get_amphora(self):",
            "        self.manager.manager.get.side_effect = Exception",
            "        self.assertRaises(exceptions.ComputeGetException,",
            "                          self.manager.get_amphora, self.amphora.id)",
            "",
            "    def test_translate_amphora(self):",
            "        amphora = self.manager._translate_amphora(self.nova_response)",
            "        self.assertEqual(self.amphora, amphora)",
            "        self.nova_response.interface_list.called_with()",
            "",
            "    def test_bad_translate_amphora(self):",
            "        self.nova_response.interface_list.side_effect = Exception",
            "        self.manager._nova_client.networks.get.side_effect = Exception",
            "        self.assertIsNone(",
            "            self.manager._translate_amphora(self.nova_response).lb_network_ip)",
            "        self.nova_response.interface_list.called_with()",
            "",
            "    def test_create_server_group(self):",
            "        self.manager.server_groups.create.return_value = self.server_group_mock",
            "",
            "        sg = self.manager.create_server_group(self.server_group_name,",
            "                                              self.server_group_policy)",
            "",
            "        self.assertEqual(sg.id, self.server_group_id)",
            "        self.assertEqual(sg.name, self.server_group_name)",
            "        self.assertEqual(sg.policy, self.server_group_policy)",
            "        self.manager.server_groups.create.called_with(",
            "            **self.server_group_kwargs)",
            "",
            "    def test_bad_create_server_group(self):",
            "        self.manager.server_groups.create.side_effect = Exception",
            "        self.assertRaises(exceptions.ServerGroupObjectCreateException,",
            "                          self.manager.create_server_group,",
            "                          self.server_group_name, self.server_group_policy)",
            "        self.manager.server_groups.create.called_with(",
            "            **self.server_group_kwargs)",
            "",
            "    def test_delete_server_group(self):",
            "        self.manager.delete_server_group(self.server_group_id)",
            "        self.manager.server_groups.delete.called_with(self.server_group_id)",
            "",
            "    def test_bad_delete_server_group(self):",
            "        self.manager.server_groups.delete.side_effect = [",
            "            nova_exceptions.NotFound('test_exception'), Exception]",
            "",
            "        # NotFound should not raise an exception",
            "",
            "        self.manager.delete_server_group(self.server_group_id)",
            "        self.manager.server_groups.delete.called_with(self.server_group_id)",
            "",
            "        # Catch the exception for server group object delete exception",
            "",
            "        self.assertRaises(exceptions.ServerGroupObjectDeleteException,",
            "                          self.manager.delete_server_group,",
            "                          self.server_group_id)",
            "        self.manager.server_groups.delete.called_with(self.server_group_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "38": [
                "Test_GetImageUuid",
                "test__get_image_uuid_tag"
            ],
            "40": [
                "Test_GetImageUuid",
                "test__get_image_uuid_tag"
            ],
            "44": [
                "Test_GetImageUuid",
                "test__get_image_uuid_notag"
            ],
            "49": [
                "Test_GetImageUuid",
                "test__get_image_uuid_id_beats_tag"
            ],
            "65": [
                "Test_ExtractAmpImageIdByTag",
                "test_no_images"
            ],
            "73": [
                "Test_ExtractAmpImageIdByTag",
                "test_single_image"
            ],
            "83": [
                "Test_ExtractAmpImageIdByTag",
                "test_multiple_images_returns_one_of_images"
            ]
        },
        "addLocation": []
    },
    "octavia/tests/unit/controller/worker/tasks/test_compute_tasks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     @mock.patch('stevedore.driver.DriverManager.driver')"
            },
            "1": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     def test_compute_create(self, mock_driver, mock_conf, mock_jinja):"
            },
            "2": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        image_owner_id = uuidutils.generate_uuid()"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+        conf = oslo_fixture.Config(cfg.CONF)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        conf.config(group=\"controller_worker\","
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                    amp_image_owner_id=image_owner_id)"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         createcompute = compute_tasks.ComputeCreate()"
            },
            "9": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         mock_driver.build.return_value = COMPUTE_ID"
            },
            "11": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "             amphora_flavor=AMP_FLAVOR_ID,"
            },
            "12": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "             image_id=AMP_IMAGE_ID,"
            },
            "13": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "             image_tag=AMP_IMAGE_TAG,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+            image_owner=image_owner_id,"
            },
            "15": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             key_name=AMP_SSH_KEY_NAME,"
            },
            "16": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             sec_groups=AMP_SEC_GROUPS,"
            },
            "17": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "             network_ids=AMP_NET,"
            },
            "18": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         createcompute.revert(COMPUTE_ID, _amphora_mock.id)"
            },
            "20": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        conf.config(group=\"controller_worker\","
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                    amp_image_owner_id='')"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     @mock.patch('jinja2.Environment.get_template')"
            },
            "25": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     @mock.patch('octavia.amphorae.backends.agent.'"
            },
            "26": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "                 'agent_jinja_cfg.AgentJinjaTemplater.'"
            },
            "27": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "             amphora_flavor=AMP_FLAVOR_ID,"
            },
            "28": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             image_id=AMP_IMAGE_ID,"
            },
            "29": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             image_tag=AMP_IMAGE_TAG,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            image_owner='',"
            },
            "31": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             key_name=AMP_SSH_KEY_NAME,"
            },
            "32": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "             sec_groups=AMP_SEC_GROUPS,"
            },
            "33": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "             network_ids=AMP_NET,"
            },
            "34": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "             amphora_flavor=AMP_FLAVOR_ID,"
            },
            "35": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "             image_id=AMP_IMAGE_ID,"
            },
            "36": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "             image_tag=AMP_IMAGE_TAG,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            image_owner='',"
            },
            "38": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "             key_name=None,"
            },
            "39": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "             sec_groups=AMP_SEC_GROUPS,"
            },
            "40": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             network_ids=AMP_NET,"
            },
            "41": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "             amphora_flavor=AMP_FLAVOR_ID,"
            },
            "42": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "             image_id=AMP_IMAGE_ID,"
            },
            "43": {
                "beforePatchRowNumber": 278,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "             image_tag=AMP_IMAGE_TAG,"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+            image_owner='',"
            },
            "45": {
                "beforePatchRowNumber": 279,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "             key_name=AMP_SSH_KEY_NAME,"
            },
            "46": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "             sec_groups=AMP_SEC_GROUPS,"
            },
            "47": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "             network_ids=AMP_NET,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "#",
            "",
            "import mock",
            "from oslo_config import cfg",
            "from oslo_config import fixture as oslo_fixture",
            "from oslo_utils import uuidutils",
            "",
            "from octavia.common import constants",
            "from octavia.common import exceptions",
            "from octavia.controller.worker.tasks import compute_tasks",
            "from octavia.tests.common import utils as test_utils",
            "import octavia.tests.unit.base as base",
            "",
            "",
            "AMP_FLAVOR_ID = 10",
            "AMP_IMAGE_ID = 11",
            "AMP_IMAGE_TAG = 'glance_tag'",
            "AMP_SSH_KEY_NAME = None",
            "AMP_NET = [uuidutils.generate_uuid()]",
            "AMP_SEC_GROUPS = []",
            "AMP_WAIT = 12",
            "AMPHORA_ID = uuidutils.generate_uuid()",
            "COMPUTE_ID = uuidutils.generate_uuid()",
            "LB_NET_IP = '192.0.2.1'",
            "PORT_ID = uuidutils.generate_uuid()",
            "AUTH_VERSION = '2'",
            "SERVER_GRPOUP_ID = uuidutils.generate_uuid()",
            "",
            "",
            "class TestException(Exception):",
            "",
            "    def __init__(self, value):",
            "        self.value = value",
            "",
            "    def __str__(self):",
            "        return repr(self.value)",
            "",
            "_amphora_mock = mock.MagicMock()",
            "_amphora_mock.id = AMPHORA_ID",
            "_amphora_mock.compute_id = COMPUTE_ID",
            "_load_balancer_mock = mock.MagicMock()",
            "_load_balancer_mock.amphorae = [_amphora_mock]",
            "_port = mock.MagicMock()",
            "_port.id = PORT_ID",
            "",
            "",
            "class TestComputeTasks(base.TestCase):",
            "",
            "    def setUp(self):",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", amp_flavor_id=AMP_FLAVOR_ID)",
            "        conf.config(group=\"controller_worker\", amp_image_id=AMP_IMAGE_ID)",
            "        conf.config(group=\"controller_worker\", amp_image_tag=AMP_IMAGE_TAG)",
            "        conf.config(group=\"controller_worker\",",
            "                    amp_ssh_key_name=AMP_SSH_KEY_NAME)",
            "        conf.config(group=\"controller_worker\", amp_boot_network_list=AMP_NET)",
            "        conf.config(group=\"controller_worker\", amp_active_wait_sec=AMP_WAIT)",
            "        conf.config(group=\"controller_worker\",",
            "                    amp_secgroup_list=AMP_SEC_GROUPS)",
            "        conf.config(group=\"keystone_authtoken\", auth_version=AUTH_VERSION)",
            "",
            "        _amphora_mock.id = AMPHORA_ID",
            "        _amphora_mock.status = constants.AMPHORA_ALLOCATED",
            "",
            "        logging_mock = mock.MagicMock()",
            "        compute_tasks.LOG = logging_mock",
            "",
            "        super(TestComputeTasks, self).setUp()",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create(self, mock_driver, mock_conf, mock_jinja):",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, ports=[_port],",
            "                                           server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            key_name=AMP_SSH_KEY_NAME,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[PORT_ID],",
            "            config_drive_files={'/etc/octavia/'",
            "                                'amphora-agent.conf': 'test_conf'},",
            "            user_data=None,",
            "            server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        assert(compute_id == COMPUTE_ID)",
            "",
            "        # Test that a build exception is raised",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock, config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(",
            "            COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('octavia.common.jinja.'",
            "                'user_data_jinja_cfg.UserDataJinjaCfg.'",
            "                'build_user_data_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create_user_data(self, mock_driver,",
            "                                      mock_ud_conf, mock_conf, mock_jinja):",
            "",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", user_data_config_drive=True)",
            "        mock_ud_conf.return_value = 'test_ud_conf'",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, ports=[_port])",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            key_name=AMP_SSH_KEY_NAME,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[PORT_ID],",
            "            config_drive_files=None,",
            "            user_data='test_ud_conf',",
            "            server_group_id=None)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        assert(compute_id == COMPUTE_ID)",
            "",
            "        # Test that a build exception is raised",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock, config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(",
            "            COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", user_data_config_drive=False)",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create_without_ssh_access(self, mock_driver,",
            "                                               mock_conf, mock_jinja):",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", amp_ssh_access_allowed=False)",
            "",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, ports=[_port],",
            "                                           server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            key_name=None,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[PORT_ID],",
            "            config_drive_files={'/etc/octavia/'",
            "                                'amphora-agent.conf': 'test_conf'},",
            "            user_data=None,",
            "            server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        self.assertEqual(COMPUTE_ID, compute_id)",
            "",
            "        # Test that a build exception is raised",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock, config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(",
            "            COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create_cert(self, mock_driver, mock_conf, mock_jinja):",
            "        createcompute = compute_tasks.CertComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        path = '/etc/octavia/certs/ca_01.pem'",
            "        self.useFixture(test_utils.OpenFixture(path, 'test'))",
            "",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, 'test_cert',",
            "                                           server_group_id=SERVER_GRPOUP_ID",
            "                                           )",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            key_name=AMP_SSH_KEY_NAME,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[],",
            "            user_data=None,",
            "            config_drive_files={",
            "                '/etc/octavia/certs/server.pem': 'test_cert',",
            "                '/etc/octavia/certs/client_ca.pem': 'test',",
            "                '/etc/octavia/amphora-agent.conf': 'test_conf'},",
            "            server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        assert (compute_id == COMPUTE_ID)",
            "",
            "        # Test that a build exception is raised",
            "        self.useFixture(test_utils.OpenFixture(path, 'test'))",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock,",
            "                          config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    @mock.patch('time.sleep')",
            "    def test_compute_wait(self,",
            "                          mock_time_sleep,",
            "                          mock_driver):",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "        _amphora_mock.status = constants.ACTIVE",
            "        _amphora_mock.lb_network_ip = LB_NET_IP",
            "",
            "        mock_driver.get_amphora.return_value = _amphora_mock",
            "",
            "        computewait = compute_tasks.ComputeWait()",
            "        computewait.execute(COMPUTE_ID)",
            "",
            "        mock_driver.get_amphora.assert_called_once_with(COMPUTE_ID)",
            "",
            "        _amphora_mock.status = constants.DELETED",
            "",
            "        self.assertRaises(exceptions.ComputeWaitTimeoutException,",
            "                          computewait.execute,",
            "                          _amphora_mock)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    @mock.patch('time.sleep')",
            "    def test_compute_wait_error_status(self, mock_time_sleep, mock_driver):",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "        _amphora_mock.status = constants.ACTIVE",
            "        _amphora_mock.lb_network_ip = LB_NET_IP",
            "",
            "        mock_driver.get_amphora.return_value = _amphora_mock",
            "",
            "        computewait = compute_tasks.ComputeWait()",
            "        computewait.execute(COMPUTE_ID)",
            "",
            "        mock_driver.get_amphora.assert_called_once_with(COMPUTE_ID)",
            "",
            "        _amphora_mock.status = constants.ERROR",
            "",
            "        self.assertRaises(exceptions.ComputeBuildException,",
            "                          computewait.execute,",
            "                          _amphora_mock)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_delete_amphorae_on_load_balancer(self, mock_driver):",
            "",
            "        delete_amps = compute_tasks.DeleteAmphoraeOnLoadBalancer()",
            "        delete_amps.execute(_load_balancer_mock)",
            "",
            "        mock_driver.delete.assert_called_once_with(COMPUTE_ID)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_delete(self, mock_driver):",
            "",
            "        delete_compute = compute_tasks.ComputeDelete()",
            "        delete_compute.execute(_amphora_mock)",
            "",
            "        mock_driver.delete.assert_called_once_with(COMPUTE_ID)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_nova_server_group_create(self, mock_driver):",
            "        nova_sever_group_obj = compute_tasks.NovaServerGroupCreate()",
            "",
            "        server_group_test_id = '6789'",
            "        fake_server_group = mock.MagicMock()",
            "        fake_server_group.id = server_group_test_id",
            "        fake_server_group.policy = 'anti-affinity'",
            "        mock_driver.create_server_group.return_value = fake_server_group",
            "",
            "        # Test execute()",
            "        sg_id = nova_sever_group_obj.execute('123')",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.create_server_group.assert_called_once_with(",
            "            'octavia-lb-123', 'anti-affinity')",
            "",
            "        # Make sure it returns the expected server group_id",
            "        assert(sg_id == server_group_test_id)",
            "",
            "        # Test revert()",
            "        nova_sever_group_obj.revert(sg_id)",
            "",
            "        # Validate that the delete_server_group method was called properly",
            "        mock_driver.delete_server_group.assert_called_once_with(sg_id)",
            "        nova_sever_group_obj.revert(sg_id)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_nova_server_group_delete_with_sever_group_id(self, mock_driver):",
            "        nova_sever_group_obj = compute_tasks.NovaServerGroupDelete()",
            "        sg_id = '6789'",
            "        nova_sever_group_obj.execute(sg_id)",
            "        mock_driver.delete_server_group.assert_called_once_with(sg_id)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_nova_server_group_delete_with_None(self, mock_driver):",
            "        nova_sever_group_obj = compute_tasks.NovaServerGroupDelete()",
            "        sg_id = None",
            "        nova_sever_group_obj.execute(sg_id)",
            "        self.assertFalse(mock_driver.delete_server_group.called, sg_id)"
        ],
        "afterPatchFile": [
            "# Copyright 2015 Hewlett-Packard Development Company, L.P.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "# http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "#",
            "",
            "import mock",
            "from oslo_config import cfg",
            "from oslo_config import fixture as oslo_fixture",
            "from oslo_utils import uuidutils",
            "",
            "from octavia.common import constants",
            "from octavia.common import exceptions",
            "from octavia.controller.worker.tasks import compute_tasks",
            "from octavia.tests.common import utils as test_utils",
            "import octavia.tests.unit.base as base",
            "",
            "",
            "AMP_FLAVOR_ID = 10",
            "AMP_IMAGE_ID = 11",
            "AMP_IMAGE_TAG = 'glance_tag'",
            "AMP_SSH_KEY_NAME = None",
            "AMP_NET = [uuidutils.generate_uuid()]",
            "AMP_SEC_GROUPS = []",
            "AMP_WAIT = 12",
            "AMPHORA_ID = uuidutils.generate_uuid()",
            "COMPUTE_ID = uuidutils.generate_uuid()",
            "LB_NET_IP = '192.0.2.1'",
            "PORT_ID = uuidutils.generate_uuid()",
            "AUTH_VERSION = '2'",
            "SERVER_GRPOUP_ID = uuidutils.generate_uuid()",
            "",
            "",
            "class TestException(Exception):",
            "",
            "    def __init__(self, value):",
            "        self.value = value",
            "",
            "    def __str__(self):",
            "        return repr(self.value)",
            "",
            "_amphora_mock = mock.MagicMock()",
            "_amphora_mock.id = AMPHORA_ID",
            "_amphora_mock.compute_id = COMPUTE_ID",
            "_load_balancer_mock = mock.MagicMock()",
            "_load_balancer_mock.amphorae = [_amphora_mock]",
            "_port = mock.MagicMock()",
            "_port.id = PORT_ID",
            "",
            "",
            "class TestComputeTasks(base.TestCase):",
            "",
            "    def setUp(self):",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", amp_flavor_id=AMP_FLAVOR_ID)",
            "        conf.config(group=\"controller_worker\", amp_image_id=AMP_IMAGE_ID)",
            "        conf.config(group=\"controller_worker\", amp_image_tag=AMP_IMAGE_TAG)",
            "        conf.config(group=\"controller_worker\",",
            "                    amp_ssh_key_name=AMP_SSH_KEY_NAME)",
            "        conf.config(group=\"controller_worker\", amp_boot_network_list=AMP_NET)",
            "        conf.config(group=\"controller_worker\", amp_active_wait_sec=AMP_WAIT)",
            "        conf.config(group=\"controller_worker\",",
            "                    amp_secgroup_list=AMP_SEC_GROUPS)",
            "        conf.config(group=\"keystone_authtoken\", auth_version=AUTH_VERSION)",
            "",
            "        _amphora_mock.id = AMPHORA_ID",
            "        _amphora_mock.status = constants.AMPHORA_ALLOCATED",
            "",
            "        logging_mock = mock.MagicMock()",
            "        compute_tasks.LOG = logging_mock",
            "",
            "        super(TestComputeTasks, self).setUp()",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create(self, mock_driver, mock_conf, mock_jinja):",
            "",
            "        image_owner_id = uuidutils.generate_uuid()",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\",",
            "                    amp_image_owner_id=image_owner_id)",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, ports=[_port],",
            "                                           server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            image_owner=image_owner_id,",
            "            key_name=AMP_SSH_KEY_NAME,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[PORT_ID],",
            "            config_drive_files={'/etc/octavia/'",
            "                                'amphora-agent.conf': 'test_conf'},",
            "            user_data=None,",
            "            server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        assert(compute_id == COMPUTE_ID)",
            "",
            "        # Test that a build exception is raised",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock, config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(",
            "            COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "",
            "        conf.config(group=\"controller_worker\",",
            "                    amp_image_owner_id='')",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('octavia.common.jinja.'",
            "                'user_data_jinja_cfg.UserDataJinjaCfg.'",
            "                'build_user_data_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create_user_data(self, mock_driver,",
            "                                      mock_ud_conf, mock_conf, mock_jinja):",
            "",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", user_data_config_drive=True)",
            "        mock_ud_conf.return_value = 'test_ud_conf'",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, ports=[_port])",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            image_owner='',",
            "            key_name=AMP_SSH_KEY_NAME,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[PORT_ID],",
            "            config_drive_files=None,",
            "            user_data='test_ud_conf',",
            "            server_group_id=None)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        assert(compute_id == COMPUTE_ID)",
            "",
            "        # Test that a build exception is raised",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock, config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(",
            "            COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", user_data_config_drive=False)",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create_without_ssh_access(self, mock_driver,",
            "                                               mock_conf, mock_jinja):",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        conf = oslo_fixture.Config(cfg.CONF)",
            "        conf.config(group=\"controller_worker\", amp_ssh_access_allowed=False)",
            "",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, ports=[_port],",
            "                                           server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            image_owner='',",
            "            key_name=None,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[PORT_ID],",
            "            config_drive_files={'/etc/octavia/'",
            "                                'amphora-agent.conf': 'test_conf'},",
            "            user_data=None,",
            "            server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        self.assertEqual(COMPUTE_ID, compute_id)",
            "",
            "        # Test that a build exception is raised",
            "        createcompute = compute_tasks.ComputeCreate()",
            "",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock, config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(",
            "            COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "",
            "    @mock.patch('jinja2.Environment.get_template')",
            "    @mock.patch('octavia.amphorae.backends.agent.'",
            "                'agent_jinja_cfg.AgentJinjaTemplater.'",
            "                'build_agent_config', return_value='test_conf')",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_create_cert(self, mock_driver, mock_conf, mock_jinja):",
            "        createcompute = compute_tasks.CertComputeCreate()",
            "",
            "        mock_driver.build.return_value = COMPUTE_ID",
            "        path = '/etc/octavia/certs/ca_01.pem'",
            "        self.useFixture(test_utils.OpenFixture(path, 'test'))",
            "",
            "        # Test execute()",
            "        compute_id = createcompute.execute(_amphora_mock.id, 'test_cert',",
            "                                           server_group_id=SERVER_GRPOUP_ID",
            "                                           )",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.build.assert_called_once_with(",
            "            name=\"amphora-\" + _amphora_mock.id,",
            "            amphora_flavor=AMP_FLAVOR_ID,",
            "            image_id=AMP_IMAGE_ID,",
            "            image_tag=AMP_IMAGE_TAG,",
            "            image_owner='',",
            "            key_name=AMP_SSH_KEY_NAME,",
            "            sec_groups=AMP_SEC_GROUPS,",
            "            network_ids=AMP_NET,",
            "            port_ids=[],",
            "            user_data=None,",
            "            config_drive_files={",
            "                '/etc/octavia/certs/server.pem': 'test_cert',",
            "                '/etc/octavia/certs/client_ca.pem': 'test',",
            "                '/etc/octavia/amphora-agent.conf': 'test_conf'},",
            "            server_group_id=SERVER_GRPOUP_ID)",
            "",
            "        # Make sure it returns the expected compute_id",
            "        assert (compute_id == COMPUTE_ID)",
            "",
            "        # Test that a build exception is raised",
            "        self.useFixture(test_utils.OpenFixture(path, 'test'))",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        self.assertRaises(TypeError,",
            "                          createcompute.execute,",
            "                          _amphora_mock,",
            "                          config_drive_files='test_cert')",
            "",
            "        # Test revert()",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "",
            "        createcompute = compute_tasks.ComputeCreate()",
            "        createcompute.revert(compute_id, _amphora_mock.id)",
            "",
            "        # Validate that the delete method was called properly",
            "        mock_driver.delete.assert_called_once_with(COMPUTE_ID)",
            "",
            "        # Test that a delete exception is not raised",
            "",
            "        createcompute.revert(COMPUTE_ID, _amphora_mock.id)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    @mock.patch('time.sleep')",
            "    def test_compute_wait(self,",
            "                          mock_time_sleep,",
            "                          mock_driver):",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "        _amphora_mock.status = constants.ACTIVE",
            "        _amphora_mock.lb_network_ip = LB_NET_IP",
            "",
            "        mock_driver.get_amphora.return_value = _amphora_mock",
            "",
            "        computewait = compute_tasks.ComputeWait()",
            "        computewait.execute(COMPUTE_ID)",
            "",
            "        mock_driver.get_amphora.assert_called_once_with(COMPUTE_ID)",
            "",
            "        _amphora_mock.status = constants.DELETED",
            "",
            "        self.assertRaises(exceptions.ComputeWaitTimeoutException,",
            "                          computewait.execute,",
            "                          _amphora_mock)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    @mock.patch('time.sleep')",
            "    def test_compute_wait_error_status(self, mock_time_sleep, mock_driver):",
            "",
            "        _amphora_mock.compute_id = COMPUTE_ID",
            "        _amphora_mock.status = constants.ACTIVE",
            "        _amphora_mock.lb_network_ip = LB_NET_IP",
            "",
            "        mock_driver.get_amphora.return_value = _amphora_mock",
            "",
            "        computewait = compute_tasks.ComputeWait()",
            "        computewait.execute(COMPUTE_ID)",
            "",
            "        mock_driver.get_amphora.assert_called_once_with(COMPUTE_ID)",
            "",
            "        _amphora_mock.status = constants.ERROR",
            "",
            "        self.assertRaises(exceptions.ComputeBuildException,",
            "                          computewait.execute,",
            "                          _amphora_mock)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_delete_amphorae_on_load_balancer(self, mock_driver):",
            "",
            "        delete_amps = compute_tasks.DeleteAmphoraeOnLoadBalancer()",
            "        delete_amps.execute(_load_balancer_mock)",
            "",
            "        mock_driver.delete.assert_called_once_with(COMPUTE_ID)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_compute_delete(self, mock_driver):",
            "",
            "        delete_compute = compute_tasks.ComputeDelete()",
            "        delete_compute.execute(_amphora_mock)",
            "",
            "        mock_driver.delete.assert_called_once_with(COMPUTE_ID)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_nova_server_group_create(self, mock_driver):",
            "        nova_sever_group_obj = compute_tasks.NovaServerGroupCreate()",
            "",
            "        server_group_test_id = '6789'",
            "        fake_server_group = mock.MagicMock()",
            "        fake_server_group.id = server_group_test_id",
            "        fake_server_group.policy = 'anti-affinity'",
            "        mock_driver.create_server_group.return_value = fake_server_group",
            "",
            "        # Test execute()",
            "        sg_id = nova_sever_group_obj.execute('123')",
            "",
            "        # Validate that the build method was called properly",
            "        mock_driver.create_server_group.assert_called_once_with(",
            "            'octavia-lb-123', 'anti-affinity')",
            "",
            "        # Make sure it returns the expected server group_id",
            "        assert(sg_id == server_group_test_id)",
            "",
            "        # Test revert()",
            "        nova_sever_group_obj.revert(sg_id)",
            "",
            "        # Validate that the delete_server_group method was called properly",
            "        mock_driver.delete_server_group.assert_called_once_with(sg_id)",
            "        nova_sever_group_obj.revert(sg_id)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_nova_server_group_delete_with_sever_group_id(self, mock_driver):",
            "        nova_sever_group_obj = compute_tasks.NovaServerGroupDelete()",
            "        sg_id = '6789'",
            "        nova_sever_group_obj.execute(sg_id)",
            "        mock_driver.delete_server_group.assert_called_once_with(sg_id)",
            "",
            "    @mock.patch('stevedore.driver.DriverManager.driver')",
            "    def test_nova_server_group_delete_with_None(self, mock_driver):",
            "        nova_sever_group_obj = compute_tasks.NovaServerGroupDelete()",
            "        sg_id = None",
            "        nova_sever_group_obj.execute(sg_id)",
            "        self.assertFalse(mock_driver.delete_server_group.called, sg_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "octavia.tests.unit.controller.worker.tasks.test_compute_tasks.TestComputeTasks.self",
            "PyPDF2.pdf"
        ]
    }
}