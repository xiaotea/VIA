{
    "html5lib/serializer/htmlserializer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " spaceCharacters = \"\".join(spaceCharacters)"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-quoteAttributeSpec = re.compile(\"[\" + spaceCharacters + \"\\\"'=<>`]\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+quoteAttributeSpecChars = spaceCharacters + \"\\\"'=<>`\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+quoteAttributeSpec = re.compile(\"[\" + quoteAttributeSpecChars + \"]\")"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+quoteAttributeLegacy = re.compile(\"[\" + quoteAttributeSpecChars +"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+                                  \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+                                  \"\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+                                  \"\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+                                  \"\\x20\\x2f\\x60\\xa0\\u1680\\u180e\\u180f\\u2000\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+                                  \"\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+                                  \"\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+                                  \"\\u3000]\")"
            },
            "14": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " try:"
            },
            "16": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     from codecs import register_error, xmlcharrefreplace_errors"
            },
            "17": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " class HTMLSerializer(object):"
            },
            "18": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "     # attribute quoting options"
            },
            "20": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    quote_attr_values = False"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+    quote_attr_values = \"legacy\"  # be secure by default"
            },
            "22": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     quote_char = '\"'"
            },
            "23": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "     use_best_quote_char = True"
            },
            "24": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 87,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         inject_meta_charset=True|False"
            },
            "26": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "           Whether it insert a meta element to define the character set of the"
            },
            "27": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "           document."
            },
            "28": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        quote_attr_values=True|False"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        quote_attr_values=\"legacy\"|\"spec\"|\"always\""
            },
            "30": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "           Whether to quote attribute values that don't require quoting"
            },
            "31": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-          per HTML5 parsing rules."
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+          per legacy browser behaviour, when required by the standard, or always."
            },
            "33": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         quote_char=u'\"'|u\"'\""
            },
            "34": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "           Use given quote character for attribute quoting. Default is to"
            },
            "35": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "           use double quote unless attribute value contains a double quote,"
            },
            "36": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "                         (k not in booleanAttributes.get(name, tuple()) and"
            },
            "37": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "                          k not in booleanAttributes.get(\"\", tuple())):"
            },
            "38": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "                         yield self.encodeStrict(\"=\")"
            },
            "39": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        if self.quote_attr_values:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+                        if self.quote_attr_values == \"always\" or len(v) == 0:"
            },
            "41": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "                             quote_attr = True"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+                        elif self.quote_attr_values == \"spec\":"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+                            quote_attr = quoteAttributeSpec.search(v) is not None"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+                        elif self.quote_attr_values == \"legacy\":"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+                            quote_attr = quoteAttributeLegacy.search(v) is not None"
            },
            "46": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "                         else:"
            },
            "47": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                            quote_attr = len(v) == 0 or quoteAttributeSpec.search(v)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+                            raise ValueError(\"quote_attr_values must be one of: \""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+                                             \"'always', 'spec', or 'legacy'\")"
            },
            "50": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "                         v = v.replace(\"&\", \"&amp;\")"
            },
            "51": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "                         if self.escape_lt_in_attrs:"
            },
            "52": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "                             v = v.replace(\"<\", \"&lt;\")"
            }
        },
        "frontPatchFile": [
            "from __future__ import absolute_import, division, unicode_literals",
            "from six import text_type",
            "",
            "import re",
            "",
            "from ..constants import voidElements, booleanAttributes, spaceCharacters",
            "from ..constants import rcdataElements, entities, xmlEntities",
            "from .. import utils",
            "from xml.sax.saxutils import escape",
            "",
            "spaceCharacters = \"\".join(spaceCharacters)",
            "",
            "quoteAttributeSpec = re.compile(\"[\" + spaceCharacters + \"\\\"'=<>`]\")",
            "",
            "try:",
            "    from codecs import register_error, xmlcharrefreplace_errors",
            "except ImportError:",
            "    unicode_encode_errors = \"strict\"",
            "else:",
            "    unicode_encode_errors = \"htmlentityreplace\"",
            "",
            "    encode_entity_map = {}",
            "    is_ucs4 = len(\"\\U0010FFFF\") == 1",
            "    for k, v in list(entities.items()):",
            "        # skip multi-character entities",
            "        if ((is_ucs4 and len(v) > 1) or",
            "                (not is_ucs4 and len(v) > 2)):",
            "            continue",
            "        if v != \"&\":",
            "            if len(v) == 2:",
            "                v = utils.surrogatePairToCodepoint(v)",
            "            else:",
            "                v = ord(v)",
            "            if v not in encode_entity_map or k.islower():",
            "                # prefer &lt; over &LT; and similarly for &amp;, &gt;, etc.",
            "                encode_entity_map[v] = k",
            "",
            "    def htmlentityreplace_errors(exc):",
            "        if isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):",
            "            res = []",
            "            codepoints = []",
            "            skip = False",
            "            for i, c in enumerate(exc.object[exc.start:exc.end]):",
            "                if skip:",
            "                    skip = False",
            "                    continue",
            "                index = i + exc.start",
            "                if utils.isSurrogatePair(exc.object[index:min([exc.end, index + 2])]):",
            "                    codepoint = utils.surrogatePairToCodepoint(exc.object[index:index + 2])",
            "                    skip = True",
            "                else:",
            "                    codepoint = ord(c)",
            "                codepoints.append(codepoint)",
            "            for cp in codepoints:",
            "                e = encode_entity_map.get(cp)",
            "                if e:",
            "                    res.append(\"&\")",
            "                    res.append(e)",
            "                    if not e.endswith(\";\"):",
            "                        res.append(\";\")",
            "                else:",
            "                    res.append(\"&#x%s;\" % (hex(cp)[2:]))",
            "            return (\"\".join(res), exc.end)",
            "        else:",
            "            return xmlcharrefreplace_errors(exc)",
            "",
            "    register_error(unicode_encode_errors, htmlentityreplace_errors)",
            "",
            "    del register_error",
            "",
            "",
            "class HTMLSerializer(object):",
            "",
            "    # attribute quoting options",
            "    quote_attr_values = False",
            "    quote_char = '\"'",
            "    use_best_quote_char = True",
            "",
            "    # tag syntax options",
            "    omit_optional_tags = True",
            "    minimize_boolean_attributes = True",
            "    use_trailing_solidus = False",
            "    space_before_trailing_solidus = True",
            "",
            "    # escaping options",
            "    escape_lt_in_attrs = False",
            "    escape_rcdata = False",
            "    resolve_entities = True",
            "",
            "    # miscellaneous options",
            "    alphabetical_attributes = False",
            "    inject_meta_charset = True",
            "    strip_whitespace = False",
            "    sanitize = False",
            "",
            "    options = (\"quote_attr_values\", \"quote_char\", \"use_best_quote_char\",",
            "               \"omit_optional_tags\", \"minimize_boolean_attributes\",",
            "               \"use_trailing_solidus\", \"space_before_trailing_solidus\",",
            "               \"escape_lt_in_attrs\", \"escape_rcdata\", \"resolve_entities\",",
            "               \"alphabetical_attributes\", \"inject_meta_charset\",",
            "               \"strip_whitespace\", \"sanitize\")",
            "",
            "    def __init__(self, **kwargs):",
            "        \"\"\"Initialize HTMLSerializer.",
            "",
            "        Keyword options (default given first unless specified) include:",
            "",
            "        inject_meta_charset=True|False",
            "          Whether it insert a meta element to define the character set of the",
            "          document.",
            "        quote_attr_values=True|False",
            "          Whether to quote attribute values that don't require quoting",
            "          per HTML5 parsing rules.",
            "        quote_char=u'\"'|u\"'\"",
            "          Use given quote character for attribute quoting. Default is to",
            "          use double quote unless attribute value contains a double quote,",
            "          in which case single quotes are used instead.",
            "        escape_lt_in_attrs=False|True",
            "          Whether to escape < in attribute values.",
            "        escape_rcdata=False|True",
            "          Whether to escape characters that need to be escaped within normal",
            "          elements within rcdata elements such as style.",
            "        resolve_entities=True|False",
            "          Whether to resolve named character entities that appear in the",
            "          source tree. The XML predefined entities &lt; &gt; &amp; &quot; &apos;",
            "          are unaffected by this setting.",
            "        strip_whitespace=False|True",
            "          Whether to remove semantically meaningless whitespace. (This",
            "          compresses all whitespace to a single space except within pre.)",
            "        minimize_boolean_attributes=True|False",
            "          Shortens boolean attributes to give just the attribute value,",
            "          for example <input disabled=\"disabled\"> becomes <input disabled>.",
            "        use_trailing_solidus=False|True",
            "          Includes a close-tag slash at the end of the start tag of void",
            "          elements (empty elements whose end tag is forbidden). E.g. <hr/>.",
            "        space_before_trailing_solidus=True|False",
            "          Places a space immediately before the closing slash in a tag",
            "          using a trailing solidus. E.g. <hr />. Requires use_trailing_solidus.",
            "        sanitize=False|True",
            "          Strip all unsafe or unknown constructs from output.",
            "          See `html5lib user documentation`_",
            "        omit_optional_tags=True|False",
            "          Omit start/end tags that are optional.",
            "        alphabetical_attributes=False|True",
            "          Reorder attributes to be in alphabetical order.",
            "",
            "        .. _html5lib user documentation: http://code.google.com/p/html5lib/wiki/UserDocumentation",
            "        \"\"\"",
            "        if 'quote_char' in kwargs:",
            "            self.use_best_quote_char = False",
            "        for attr in self.options:",
            "            setattr(self, attr, kwargs.get(attr, getattr(self, attr)))",
            "        self.errors = []",
            "        self.strict = False",
            "",
            "    def encode(self, string):",
            "        assert(isinstance(string, text_type))",
            "        if self.encoding:",
            "            return string.encode(self.encoding, unicode_encode_errors)",
            "        else:",
            "            return string",
            "",
            "    def encodeStrict(self, string):",
            "        assert(isinstance(string, text_type))",
            "        if self.encoding:",
            "            return string.encode(self.encoding, \"strict\")",
            "        else:",
            "            return string",
            "",
            "    def serialize(self, treewalker, encoding=None):",
            "        self.encoding = encoding",
            "        in_cdata = False",
            "        self.errors = []",
            "",
            "        if encoding and self.inject_meta_charset:",
            "            from ..filters.inject_meta_charset import Filter",
            "            treewalker = Filter(treewalker, encoding)",
            "        # WhitespaceFilter should be used before OptionalTagFilter",
            "        # for maximum efficiently of this latter filter",
            "        if self.strip_whitespace:",
            "            from ..filters.whitespace import Filter",
            "            treewalker = Filter(treewalker)",
            "        if self.sanitize:",
            "            from ..filters.sanitizer import Filter",
            "            treewalker = Filter(treewalker)",
            "        if self.omit_optional_tags:",
            "            from ..filters.optionaltags import Filter",
            "            treewalker = Filter(treewalker)",
            "        # Alphabetical attributes must be last, as other filters",
            "        # could add attributes and alter the order",
            "        if self.alphabetical_attributes:",
            "            from ..filters.alphabeticalattributes import Filter",
            "            treewalker = Filter(treewalker)",
            "",
            "        for token in treewalker:",
            "            type = token[\"type\"]",
            "            if type == \"Doctype\":",
            "                doctype = \"<!DOCTYPE %s\" % token[\"name\"]",
            "",
            "                if token[\"publicId\"]:",
            "                    doctype += ' PUBLIC \"%s\"' % token[\"publicId\"]",
            "                elif token[\"systemId\"]:",
            "                    doctype += \" SYSTEM\"",
            "                if token[\"systemId\"]:",
            "                    if token[\"systemId\"].find('\"') >= 0:",
            "                        if token[\"systemId\"].find(\"'\") >= 0:",
            "                            self.serializeError(\"System identifer contains both single and double quote characters\")",
            "                        quote_char = \"'\"",
            "                    else:",
            "                        quote_char = '\"'",
            "                    doctype += \" %s%s%s\" % (quote_char, token[\"systemId\"], quote_char)",
            "",
            "                doctype += \">\"",
            "                yield self.encodeStrict(doctype)",
            "",
            "            elif type in (\"Characters\", \"SpaceCharacters\"):",
            "                if type == \"SpaceCharacters\" or in_cdata:",
            "                    if in_cdata and token[\"data\"].find(\"</\") >= 0:",
            "                        self.serializeError(\"Unexpected </ in CDATA\")",
            "                    yield self.encode(token[\"data\"])",
            "                else:",
            "                    yield self.encode(escape(token[\"data\"]))",
            "",
            "            elif type in (\"StartTag\", \"EmptyTag\"):",
            "                name = token[\"name\"]",
            "                yield self.encodeStrict(\"<%s\" % name)",
            "                if name in rcdataElements and not self.escape_rcdata:",
            "                    in_cdata = True",
            "                elif in_cdata:",
            "                    self.serializeError(\"Unexpected child element of a CDATA element\")",
            "                for (attr_namespace, attr_name), attr_value in token[\"data\"].items():",
            "                    # TODO: Add namespace support here",
            "                    k = attr_name",
            "                    v = attr_value",
            "                    yield self.encodeStrict(' ')",
            "",
            "                    yield self.encodeStrict(k)",
            "                    if not self.minimize_boolean_attributes or \\",
            "                        (k not in booleanAttributes.get(name, tuple()) and",
            "                         k not in booleanAttributes.get(\"\", tuple())):",
            "                        yield self.encodeStrict(\"=\")",
            "                        if self.quote_attr_values:",
            "                            quote_attr = True",
            "                        else:",
            "                            quote_attr = len(v) == 0 or quoteAttributeSpec.search(v)",
            "                        v = v.replace(\"&\", \"&amp;\")",
            "                        if self.escape_lt_in_attrs:",
            "                            v = v.replace(\"<\", \"&lt;\")",
            "                        if quote_attr:",
            "                            quote_char = self.quote_char",
            "                            if self.use_best_quote_char:",
            "                                if \"'\" in v and '\"' not in v:",
            "                                    quote_char = '\"'",
            "                                elif '\"' in v and \"'\" not in v:",
            "                                    quote_char = \"'\"",
            "                            if quote_char == \"'\":",
            "                                v = v.replace(\"'\", \"&#39;\")",
            "                            else:",
            "                                v = v.replace('\"', \"&quot;\")",
            "                            yield self.encodeStrict(quote_char)",
            "                            yield self.encode(v)",
            "                            yield self.encodeStrict(quote_char)",
            "                        else:",
            "                            yield self.encode(v)",
            "                if name in voidElements and self.use_trailing_solidus:",
            "                    if self.space_before_trailing_solidus:",
            "                        yield self.encodeStrict(\" /\")",
            "                    else:",
            "                        yield self.encodeStrict(\"/\")",
            "                yield self.encode(\">\")",
            "",
            "            elif type == \"EndTag\":",
            "                name = token[\"name\"]",
            "                if name in rcdataElements:",
            "                    in_cdata = False",
            "                elif in_cdata:",
            "                    self.serializeError(\"Unexpected child element of a CDATA element\")",
            "                yield self.encodeStrict(\"</%s>\" % name)",
            "",
            "            elif type == \"Comment\":",
            "                data = token[\"data\"]",
            "                if data.find(\"--\") >= 0:",
            "                    self.serializeError(\"Comment contains --\")",
            "                yield self.encodeStrict(\"<!--%s-->\" % token[\"data\"])",
            "",
            "            elif type == \"Entity\":",
            "                name = token[\"name\"]",
            "                key = name + \";\"",
            "                if key not in entities:",
            "                    self.serializeError(\"Entity %s not recognized\" % name)",
            "                if self.resolve_entities and key not in xmlEntities:",
            "                    data = entities[key]",
            "                else:",
            "                    data = \"&%s;\" % name",
            "                yield self.encodeStrict(data)",
            "",
            "            else:",
            "                self.serializeError(token[\"data\"])",
            "",
            "    def render(self, treewalker, encoding=None):",
            "        if encoding:",
            "            return b\"\".join(list(self.serialize(treewalker, encoding)))",
            "        else:",
            "            return \"\".join(list(self.serialize(treewalker)))",
            "",
            "    def serializeError(self, data=\"XXX ERROR MESSAGE NEEDED\"):",
            "        # XXX The idea is to make data mandatory.",
            "        self.errors.append(data)",
            "        if self.strict:",
            "            raise SerializeError",
            "",
            "",
            "def SerializeError(Exception):",
            "    \"\"\"Error in serialized tree\"\"\"",
            "    pass"
        ],
        "afterPatchFile": [
            "from __future__ import absolute_import, division, unicode_literals",
            "from six import text_type",
            "",
            "import re",
            "",
            "from ..constants import voidElements, booleanAttributes, spaceCharacters",
            "from ..constants import rcdataElements, entities, xmlEntities",
            "from .. import utils",
            "from xml.sax.saxutils import escape",
            "",
            "spaceCharacters = \"\".join(spaceCharacters)",
            "",
            "quoteAttributeSpecChars = spaceCharacters + \"\\\"'=<>`\"",
            "quoteAttributeSpec = re.compile(\"[\" + quoteAttributeSpecChars + \"]\")",
            "quoteAttributeLegacy = re.compile(\"[\" + quoteAttributeSpecChars +",
            "                                  \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\"",
            "                                  \"\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\"",
            "                                  \"\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"",
            "                                  \"\\x20\\x2f\\x60\\xa0\\u1680\\u180e\\u180f\\u2000\"",
            "                                  \"\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\"",
            "                                  \"\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\"",
            "                                  \"\\u3000]\")",
            "",
            "try:",
            "    from codecs import register_error, xmlcharrefreplace_errors",
            "except ImportError:",
            "    unicode_encode_errors = \"strict\"",
            "else:",
            "    unicode_encode_errors = \"htmlentityreplace\"",
            "",
            "    encode_entity_map = {}",
            "    is_ucs4 = len(\"\\U0010FFFF\") == 1",
            "    for k, v in list(entities.items()):",
            "        # skip multi-character entities",
            "        if ((is_ucs4 and len(v) > 1) or",
            "                (not is_ucs4 and len(v) > 2)):",
            "            continue",
            "        if v != \"&\":",
            "            if len(v) == 2:",
            "                v = utils.surrogatePairToCodepoint(v)",
            "            else:",
            "                v = ord(v)",
            "            if v not in encode_entity_map or k.islower():",
            "                # prefer &lt; over &LT; and similarly for &amp;, &gt;, etc.",
            "                encode_entity_map[v] = k",
            "",
            "    def htmlentityreplace_errors(exc):",
            "        if isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):",
            "            res = []",
            "            codepoints = []",
            "            skip = False",
            "            for i, c in enumerate(exc.object[exc.start:exc.end]):",
            "                if skip:",
            "                    skip = False",
            "                    continue",
            "                index = i + exc.start",
            "                if utils.isSurrogatePair(exc.object[index:min([exc.end, index + 2])]):",
            "                    codepoint = utils.surrogatePairToCodepoint(exc.object[index:index + 2])",
            "                    skip = True",
            "                else:",
            "                    codepoint = ord(c)",
            "                codepoints.append(codepoint)",
            "            for cp in codepoints:",
            "                e = encode_entity_map.get(cp)",
            "                if e:",
            "                    res.append(\"&\")",
            "                    res.append(e)",
            "                    if not e.endswith(\";\"):",
            "                        res.append(\";\")",
            "                else:",
            "                    res.append(\"&#x%s;\" % (hex(cp)[2:]))",
            "            return (\"\".join(res), exc.end)",
            "        else:",
            "            return xmlcharrefreplace_errors(exc)",
            "",
            "    register_error(unicode_encode_errors, htmlentityreplace_errors)",
            "",
            "    del register_error",
            "",
            "",
            "class HTMLSerializer(object):",
            "",
            "    # attribute quoting options",
            "    quote_attr_values = \"legacy\"  # be secure by default",
            "    quote_char = '\"'",
            "    use_best_quote_char = True",
            "",
            "    # tag syntax options",
            "    omit_optional_tags = True",
            "    minimize_boolean_attributes = True",
            "    use_trailing_solidus = False",
            "    space_before_trailing_solidus = True",
            "",
            "    # escaping options",
            "    escape_lt_in_attrs = False",
            "    escape_rcdata = False",
            "    resolve_entities = True",
            "",
            "    # miscellaneous options",
            "    alphabetical_attributes = False",
            "    inject_meta_charset = True",
            "    strip_whitespace = False",
            "    sanitize = False",
            "",
            "    options = (\"quote_attr_values\", \"quote_char\", \"use_best_quote_char\",",
            "               \"omit_optional_tags\", \"minimize_boolean_attributes\",",
            "               \"use_trailing_solidus\", \"space_before_trailing_solidus\",",
            "               \"escape_lt_in_attrs\", \"escape_rcdata\", \"resolve_entities\",",
            "               \"alphabetical_attributes\", \"inject_meta_charset\",",
            "               \"strip_whitespace\", \"sanitize\")",
            "",
            "    def __init__(self, **kwargs):",
            "        \"\"\"Initialize HTMLSerializer.",
            "",
            "        Keyword options (default given first unless specified) include:",
            "",
            "        inject_meta_charset=True|False",
            "          Whether it insert a meta element to define the character set of the",
            "          document.",
            "        quote_attr_values=\"legacy\"|\"spec\"|\"always\"",
            "          Whether to quote attribute values that don't require quoting",
            "          per legacy browser behaviour, when required by the standard, or always.",
            "        quote_char=u'\"'|u\"'\"",
            "          Use given quote character for attribute quoting. Default is to",
            "          use double quote unless attribute value contains a double quote,",
            "          in which case single quotes are used instead.",
            "        escape_lt_in_attrs=False|True",
            "          Whether to escape < in attribute values.",
            "        escape_rcdata=False|True",
            "          Whether to escape characters that need to be escaped within normal",
            "          elements within rcdata elements such as style.",
            "        resolve_entities=True|False",
            "          Whether to resolve named character entities that appear in the",
            "          source tree. The XML predefined entities &lt; &gt; &amp; &quot; &apos;",
            "          are unaffected by this setting.",
            "        strip_whitespace=False|True",
            "          Whether to remove semantically meaningless whitespace. (This",
            "          compresses all whitespace to a single space except within pre.)",
            "        minimize_boolean_attributes=True|False",
            "          Shortens boolean attributes to give just the attribute value,",
            "          for example <input disabled=\"disabled\"> becomes <input disabled>.",
            "        use_trailing_solidus=False|True",
            "          Includes a close-tag slash at the end of the start tag of void",
            "          elements (empty elements whose end tag is forbidden). E.g. <hr/>.",
            "        space_before_trailing_solidus=True|False",
            "          Places a space immediately before the closing slash in a tag",
            "          using a trailing solidus. E.g. <hr />. Requires use_trailing_solidus.",
            "        sanitize=False|True",
            "          Strip all unsafe or unknown constructs from output.",
            "          See `html5lib user documentation`_",
            "        omit_optional_tags=True|False",
            "          Omit start/end tags that are optional.",
            "        alphabetical_attributes=False|True",
            "          Reorder attributes to be in alphabetical order.",
            "",
            "        .. _html5lib user documentation: http://code.google.com/p/html5lib/wiki/UserDocumentation",
            "        \"\"\"",
            "        if 'quote_char' in kwargs:",
            "            self.use_best_quote_char = False",
            "        for attr in self.options:",
            "            setattr(self, attr, kwargs.get(attr, getattr(self, attr)))",
            "        self.errors = []",
            "        self.strict = False",
            "",
            "    def encode(self, string):",
            "        assert(isinstance(string, text_type))",
            "        if self.encoding:",
            "            return string.encode(self.encoding, unicode_encode_errors)",
            "        else:",
            "            return string",
            "",
            "    def encodeStrict(self, string):",
            "        assert(isinstance(string, text_type))",
            "        if self.encoding:",
            "            return string.encode(self.encoding, \"strict\")",
            "        else:",
            "            return string",
            "",
            "    def serialize(self, treewalker, encoding=None):",
            "        self.encoding = encoding",
            "        in_cdata = False",
            "        self.errors = []",
            "",
            "        if encoding and self.inject_meta_charset:",
            "            from ..filters.inject_meta_charset import Filter",
            "            treewalker = Filter(treewalker, encoding)",
            "        # WhitespaceFilter should be used before OptionalTagFilter",
            "        # for maximum efficiently of this latter filter",
            "        if self.strip_whitespace:",
            "            from ..filters.whitespace import Filter",
            "            treewalker = Filter(treewalker)",
            "        if self.sanitize:",
            "            from ..filters.sanitizer import Filter",
            "            treewalker = Filter(treewalker)",
            "        if self.omit_optional_tags:",
            "            from ..filters.optionaltags import Filter",
            "            treewalker = Filter(treewalker)",
            "        # Alphabetical attributes must be last, as other filters",
            "        # could add attributes and alter the order",
            "        if self.alphabetical_attributes:",
            "            from ..filters.alphabeticalattributes import Filter",
            "            treewalker = Filter(treewalker)",
            "",
            "        for token in treewalker:",
            "            type = token[\"type\"]",
            "            if type == \"Doctype\":",
            "                doctype = \"<!DOCTYPE %s\" % token[\"name\"]",
            "",
            "                if token[\"publicId\"]:",
            "                    doctype += ' PUBLIC \"%s\"' % token[\"publicId\"]",
            "                elif token[\"systemId\"]:",
            "                    doctype += \" SYSTEM\"",
            "                if token[\"systemId\"]:",
            "                    if token[\"systemId\"].find('\"') >= 0:",
            "                        if token[\"systemId\"].find(\"'\") >= 0:",
            "                            self.serializeError(\"System identifer contains both single and double quote characters\")",
            "                        quote_char = \"'\"",
            "                    else:",
            "                        quote_char = '\"'",
            "                    doctype += \" %s%s%s\" % (quote_char, token[\"systemId\"], quote_char)",
            "",
            "                doctype += \">\"",
            "                yield self.encodeStrict(doctype)",
            "",
            "            elif type in (\"Characters\", \"SpaceCharacters\"):",
            "                if type == \"SpaceCharacters\" or in_cdata:",
            "                    if in_cdata and token[\"data\"].find(\"</\") >= 0:",
            "                        self.serializeError(\"Unexpected </ in CDATA\")",
            "                    yield self.encode(token[\"data\"])",
            "                else:",
            "                    yield self.encode(escape(token[\"data\"]))",
            "",
            "            elif type in (\"StartTag\", \"EmptyTag\"):",
            "                name = token[\"name\"]",
            "                yield self.encodeStrict(\"<%s\" % name)",
            "                if name in rcdataElements and not self.escape_rcdata:",
            "                    in_cdata = True",
            "                elif in_cdata:",
            "                    self.serializeError(\"Unexpected child element of a CDATA element\")",
            "                for (attr_namespace, attr_name), attr_value in token[\"data\"].items():",
            "                    # TODO: Add namespace support here",
            "                    k = attr_name",
            "                    v = attr_value",
            "                    yield self.encodeStrict(' ')",
            "",
            "                    yield self.encodeStrict(k)",
            "                    if not self.minimize_boolean_attributes or \\",
            "                        (k not in booleanAttributes.get(name, tuple()) and",
            "                         k not in booleanAttributes.get(\"\", tuple())):",
            "                        yield self.encodeStrict(\"=\")",
            "                        if self.quote_attr_values == \"always\" or len(v) == 0:",
            "                            quote_attr = True",
            "                        elif self.quote_attr_values == \"spec\":",
            "                            quote_attr = quoteAttributeSpec.search(v) is not None",
            "                        elif self.quote_attr_values == \"legacy\":",
            "                            quote_attr = quoteAttributeLegacy.search(v) is not None",
            "                        else:",
            "                            raise ValueError(\"quote_attr_values must be one of: \"",
            "                                             \"'always', 'spec', or 'legacy'\")",
            "                        v = v.replace(\"&\", \"&amp;\")",
            "                        if self.escape_lt_in_attrs:",
            "                            v = v.replace(\"<\", \"&lt;\")",
            "                        if quote_attr:",
            "                            quote_char = self.quote_char",
            "                            if self.use_best_quote_char:",
            "                                if \"'\" in v and '\"' not in v:",
            "                                    quote_char = '\"'",
            "                                elif '\"' in v and \"'\" not in v:",
            "                                    quote_char = \"'\"",
            "                            if quote_char == \"'\":",
            "                                v = v.replace(\"'\", \"&#39;\")",
            "                            else:",
            "                                v = v.replace('\"', \"&quot;\")",
            "                            yield self.encodeStrict(quote_char)",
            "                            yield self.encode(v)",
            "                            yield self.encodeStrict(quote_char)",
            "                        else:",
            "                            yield self.encode(v)",
            "                if name in voidElements and self.use_trailing_solidus:",
            "                    if self.space_before_trailing_solidus:",
            "                        yield self.encodeStrict(\" /\")",
            "                    else:",
            "                        yield self.encodeStrict(\"/\")",
            "                yield self.encode(\">\")",
            "",
            "            elif type == \"EndTag\":",
            "                name = token[\"name\"]",
            "                if name in rcdataElements:",
            "                    in_cdata = False",
            "                elif in_cdata:",
            "                    self.serializeError(\"Unexpected child element of a CDATA element\")",
            "                yield self.encodeStrict(\"</%s>\" % name)",
            "",
            "            elif type == \"Comment\":",
            "                data = token[\"data\"]",
            "                if data.find(\"--\") >= 0:",
            "                    self.serializeError(\"Comment contains --\")",
            "                yield self.encodeStrict(\"<!--%s-->\" % token[\"data\"])",
            "",
            "            elif type == \"Entity\":",
            "                name = token[\"name\"]",
            "                key = name + \";\"",
            "                if key not in entities:",
            "                    self.serializeError(\"Entity %s not recognized\" % name)",
            "                if self.resolve_entities and key not in xmlEntities:",
            "                    data = entities[key]",
            "                else:",
            "                    data = \"&%s;\" % name",
            "                yield self.encodeStrict(data)",
            "",
            "            else:",
            "                self.serializeError(token[\"data\"])",
            "",
            "    def render(self, treewalker, encoding=None):",
            "        if encoding:",
            "            return b\"\".join(list(self.serialize(treewalker, encoding)))",
            "        else:",
            "            return \"\".join(list(self.serialize(treewalker)))",
            "",
            "    def serializeError(self, data=\"XXX ERROR MESSAGE NEEDED\"):",
            "        # XXX The idea is to make data mandatory.",
            "        self.errors.append(data)",
            "        if self.strict:",
            "            raise SerializeError",
            "",
            "",
            "def SerializeError(Exception):",
            "    \"\"\"Error in serialized tree\"\"\"",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [
                "quoteAttributeSpec"
            ],
            "75": [
                "HTMLSerializer"
            ],
            "111": [
                "HTMLSerializer",
                "__init__"
            ],
            "113": [
                "HTMLSerializer",
                "__init__"
            ],
            "242": [
                "HTMLSerializer",
                "serialize"
            ],
            "245": [
                "HTMLSerializer",
                "serialize"
            ]
        },
        "addLocation": []
    },
    "html5lib/tests/test_serializer.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     throwsWithLatin1([[\"Comment\", \"\\u0101\"]])"
            },
            "1": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+@pytest.mark.parametrize(\"c\", list(\"\\t\\n\\u000C\\x20\\r\\\"'=<>`\"))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+def testSpecQuoteAttribute(c):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    input_ = [[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\","
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+               [{\"namespace\": None, \"name\": \"foo\", \"value\": c}]]]"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    if c == '\"':"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        output_ = [\"<span foo='%s'>\" % c]"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+    else:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        output_ = ['<span foo=\"%s\">' % c]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    options_ = {\"quote_attr_values\": \"spec\"}"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+    runSerializerTest(input_, output_, options_)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+@pytest.mark.parametrize(\"c\", list(\"\\t\\n\\u000C\\x20\\r\\\"'=<>`\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+                                   \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+                                   \"\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+                                   \"\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+                                   \"\\x20\\x2f\\x60\\xa0\\u1680\\u180e\\u180f\\u2000\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                                   \"\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\""
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                                   \"\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                                   \"\\u3000\"))"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+def testLegacyQuoteAttribute(c):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+    input_ = [[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\","
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+               [{\"namespace\": None, \"name\": \"foo\", \"value\": c}]]]"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    if c == '\"':"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        output_ = [\"<span foo='%s'>\" % c]"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    else:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        output_ = ['<span foo=\"%s\">' % c]"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    options_ = {\"quote_attr_values\": \"legacy\"}"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    runSerializerTest(input_, output_, options_)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " @pytest.fixture"
            },
            "35": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 181,
                "PatchRowcode": " def lxml_parser():"
            },
            "36": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "     return etree.XMLParser(resolve_entities=False)"
            }
        },
        "frontPatchFile": [
            "from __future__ import absolute_import, division, unicode_literals",
            "",
            "import os",
            "import json",
            "",
            "import pytest",
            "",
            "from .support import get_data_files",
            "",
            "from html5lib import constants",
            "from html5lib.filters.lint import Filter as Lint",
            "from html5lib.serializer import HTMLSerializer, serialize",
            "from html5lib.treewalkers._base import TreeWalker",
            "",
            "optionals_loaded = []",
            "",
            "try:",
            "    from lxml import etree",
            "    optionals_loaded.append(\"lxml\")",
            "except ImportError:",
            "    pass",
            "",
            "default_namespace = constants.namespaces[\"html\"]",
            "",
            "",
            "class JsonWalker(TreeWalker):",
            "    def __iter__(self):",
            "        for token in self.tree:",
            "            type = token[0]",
            "            if type == \"StartTag\":",
            "                if len(token) == 4:",
            "                    namespace, name, attrib = token[1:4]",
            "                else:",
            "                    namespace = default_namespace",
            "                    name, attrib = token[1:3]",
            "                yield self.startTag(namespace, name, self._convertAttrib(attrib))",
            "            elif type == \"EndTag\":",
            "                if len(token) == 3:",
            "                    namespace, name = token[1:3]",
            "                else:",
            "                    namespace = default_namespace",
            "                    name = token[1]",
            "                yield self.endTag(namespace, name)",
            "            elif type == \"EmptyTag\":",
            "                if len(token) == 4:",
            "                    namespace, name, attrib = token[1:]",
            "                else:",
            "                    namespace = default_namespace",
            "                    name, attrib = token[1:]",
            "                for token in self.emptyTag(namespace, name, self._convertAttrib(attrib)):",
            "                    yield token",
            "            elif type == \"Comment\":",
            "                yield self.comment(token[1])",
            "            elif type in (\"Characters\", \"SpaceCharacters\"):",
            "                for token in self.text(token[1]):",
            "                    yield token",
            "            elif type == \"Doctype\":",
            "                if len(token) == 4:",
            "                    yield self.doctype(token[1], token[2], token[3])",
            "                elif len(token) == 3:",
            "                    yield self.doctype(token[1], token[2])",
            "                else:",
            "                    yield self.doctype(token[1])",
            "            else:",
            "                raise ValueError(\"Unknown token type: \" + type)",
            "",
            "    def _convertAttrib(self, attribs):",
            "        \"\"\"html5lib tree-walkers use a dict of (namespace, name): value for",
            "        attributes, but JSON cannot represent this. Convert from the format",
            "        in the serializer tests (a list of dicts with \"namespace\", \"name\",",
            "        and \"value\" as keys) to html5lib's tree-walker format.\"\"\"",
            "        attrs = {}",
            "        for attrib in attribs:",
            "            name = (attrib[\"namespace\"], attrib[\"name\"])",
            "            assert(name not in attrs)",
            "            attrs[name] = attrib[\"value\"]",
            "        return attrs",
            "",
            "",
            "def serialize_html(input, options):",
            "    options = dict([(str(k), v) for k, v in options.items()])",
            "    stream = Lint(JsonWalker(input), False)",
            "    serializer = HTMLSerializer(alphabetical_attributes=True, **options)",
            "    return serializer.render(stream, options.get(\"encoding\", None))",
            "",
            "",
            "def runSerializerTest(input, expected, options):",
            "    encoding = options.get(\"encoding\", None)",
            "",
            "    if encoding:",
            "        expected = list(map(lambda x: x.encode(encoding), expected))",
            "",
            "    result = serialize_html(input, options)",
            "    if len(expected) == 1:",
            "        assert expected[0] == result, \"Expected:\\n%s\\nActual:\\n%s\\nOptions:\\n%s\" % (expected[0], result, str(options))",
            "    elif result not in expected:",
            "        assert False, \"Expected: %s, Received: %s\" % (expected, result)",
            "",
            "",
            "def throwsWithLatin1(input):",
            "    with pytest.raises(UnicodeEncodeError):",
            "        serialize_html(input, {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testDoctypeName():",
            "    throwsWithLatin1([[\"Doctype\", \"\\u0101\"]])",
            "",
            "",
            "def testDoctypePublicId():",
            "    throwsWithLatin1([[\"Doctype\", \"potato\", \"\\u0101\"]])",
            "",
            "",
            "def testDoctypeSystemId():",
            "    throwsWithLatin1([[\"Doctype\", \"potato\", \"potato\", \"\\u0101\"]])",
            "",
            "",
            "def testCdataCharacters():",
            "    runSerializerTest([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"style\", {}], [\"Characters\", \"\\u0101\"]],",
            "                      [\"<style>&amacr;\"], {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testCharacters():",
            "    runSerializerTest([[\"Characters\", \"\\u0101\"]],",
            "                      [\"&amacr;\"], {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testStartTagName():",
            "    throwsWithLatin1([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"\\u0101\", []]])",
            "",
            "",
            "def testAttributeName():",
            "    throwsWithLatin1([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\", [{\"namespace\": None, \"name\": \"\\u0101\", \"value\": \"potato\"}]]])",
            "",
            "",
            "def testAttributeValue():",
            "    runSerializerTest([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\",",
            "                        [{\"namespace\": None, \"name\": \"potato\", \"value\": \"\\u0101\"}]]],",
            "                      [\"<span potato=&amacr;>\"], {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testEndTagName():",
            "    throwsWithLatin1([[\"EndTag\", \"http://www.w3.org/1999/xhtml\", \"\\u0101\"]])",
            "",
            "",
            "def testComment():",
            "    throwsWithLatin1([[\"Comment\", \"\\u0101\"]])",
            "",
            "",
            "@pytest.fixture",
            "def lxml_parser():",
            "    return etree.XMLParser(resolve_entities=False)",
            "",
            "",
            "@pytest.mark.skipif(\"lxml\" not in optionals_loaded, reason=\"lxml not importable\")",
            "def testEntityReplacement(lxml_parser):",
            "    doc = '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&beta;</html>'",
            "    tree = etree.fromstring(doc, parser=lxml_parser).getroottree()",
            "    result = serialize(tree, tree=\"lxml\", omit_optional_tags=False)",
            "    assert result == '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>\\u03B2</html>'",
            "",
            "",
            "@pytest.mark.skipif(\"lxml\" not in optionals_loaded, reason=\"lxml not importable\")",
            "def testEntityXML(lxml_parser):",
            "    doc = '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&gt;</html>'",
            "    tree = etree.fromstring(doc, parser=lxml_parser).getroottree()",
            "    result = serialize(tree, tree=\"lxml\", omit_optional_tags=False)",
            "    assert result == '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&gt;</html>'",
            "",
            "",
            "@pytest.mark.skipif(\"lxml\" not in optionals_loaded, reason=\"lxml not importable\")",
            "def testEntityNoResolve(lxml_parser):",
            "    doc = '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&beta;</html>'",
            "    tree = etree.fromstring(doc, parser=lxml_parser).getroottree()",
            "    result = serialize(tree, tree=\"lxml\", omit_optional_tags=False,",
            "                                  resolve_entities=False)",
            "    assert result == '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&beta;</html>'",
            "",
            "",
            "def test_serializer():",
            "    for filename in get_data_files('serializer-testdata', '*.test', os.path.dirname(__file__)):",
            "        with open(filename) as fp:",
            "            tests = json.load(fp)",
            "            for index, test in enumerate(tests['tests']):",
            "                yield runSerializerTest, test[\"input\"], test[\"expected\"], test.get(\"options\", {})"
        ],
        "afterPatchFile": [
            "from __future__ import absolute_import, division, unicode_literals",
            "",
            "import os",
            "import json",
            "",
            "import pytest",
            "",
            "from .support import get_data_files",
            "",
            "from html5lib import constants",
            "from html5lib.filters.lint import Filter as Lint",
            "from html5lib.serializer import HTMLSerializer, serialize",
            "from html5lib.treewalkers._base import TreeWalker",
            "",
            "optionals_loaded = []",
            "",
            "try:",
            "    from lxml import etree",
            "    optionals_loaded.append(\"lxml\")",
            "except ImportError:",
            "    pass",
            "",
            "default_namespace = constants.namespaces[\"html\"]",
            "",
            "",
            "class JsonWalker(TreeWalker):",
            "    def __iter__(self):",
            "        for token in self.tree:",
            "            type = token[0]",
            "            if type == \"StartTag\":",
            "                if len(token) == 4:",
            "                    namespace, name, attrib = token[1:4]",
            "                else:",
            "                    namespace = default_namespace",
            "                    name, attrib = token[1:3]",
            "                yield self.startTag(namespace, name, self._convertAttrib(attrib))",
            "            elif type == \"EndTag\":",
            "                if len(token) == 3:",
            "                    namespace, name = token[1:3]",
            "                else:",
            "                    namespace = default_namespace",
            "                    name = token[1]",
            "                yield self.endTag(namespace, name)",
            "            elif type == \"EmptyTag\":",
            "                if len(token) == 4:",
            "                    namespace, name, attrib = token[1:]",
            "                else:",
            "                    namespace = default_namespace",
            "                    name, attrib = token[1:]",
            "                for token in self.emptyTag(namespace, name, self._convertAttrib(attrib)):",
            "                    yield token",
            "            elif type == \"Comment\":",
            "                yield self.comment(token[1])",
            "            elif type in (\"Characters\", \"SpaceCharacters\"):",
            "                for token in self.text(token[1]):",
            "                    yield token",
            "            elif type == \"Doctype\":",
            "                if len(token) == 4:",
            "                    yield self.doctype(token[1], token[2], token[3])",
            "                elif len(token) == 3:",
            "                    yield self.doctype(token[1], token[2])",
            "                else:",
            "                    yield self.doctype(token[1])",
            "            else:",
            "                raise ValueError(\"Unknown token type: \" + type)",
            "",
            "    def _convertAttrib(self, attribs):",
            "        \"\"\"html5lib tree-walkers use a dict of (namespace, name): value for",
            "        attributes, but JSON cannot represent this. Convert from the format",
            "        in the serializer tests (a list of dicts with \"namespace\", \"name\",",
            "        and \"value\" as keys) to html5lib's tree-walker format.\"\"\"",
            "        attrs = {}",
            "        for attrib in attribs:",
            "            name = (attrib[\"namespace\"], attrib[\"name\"])",
            "            assert(name not in attrs)",
            "            attrs[name] = attrib[\"value\"]",
            "        return attrs",
            "",
            "",
            "def serialize_html(input, options):",
            "    options = dict([(str(k), v) for k, v in options.items()])",
            "    stream = Lint(JsonWalker(input), False)",
            "    serializer = HTMLSerializer(alphabetical_attributes=True, **options)",
            "    return serializer.render(stream, options.get(\"encoding\", None))",
            "",
            "",
            "def runSerializerTest(input, expected, options):",
            "    encoding = options.get(\"encoding\", None)",
            "",
            "    if encoding:",
            "        expected = list(map(lambda x: x.encode(encoding), expected))",
            "",
            "    result = serialize_html(input, options)",
            "    if len(expected) == 1:",
            "        assert expected[0] == result, \"Expected:\\n%s\\nActual:\\n%s\\nOptions:\\n%s\" % (expected[0], result, str(options))",
            "    elif result not in expected:",
            "        assert False, \"Expected: %s, Received: %s\" % (expected, result)",
            "",
            "",
            "def throwsWithLatin1(input):",
            "    with pytest.raises(UnicodeEncodeError):",
            "        serialize_html(input, {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testDoctypeName():",
            "    throwsWithLatin1([[\"Doctype\", \"\\u0101\"]])",
            "",
            "",
            "def testDoctypePublicId():",
            "    throwsWithLatin1([[\"Doctype\", \"potato\", \"\\u0101\"]])",
            "",
            "",
            "def testDoctypeSystemId():",
            "    throwsWithLatin1([[\"Doctype\", \"potato\", \"potato\", \"\\u0101\"]])",
            "",
            "",
            "def testCdataCharacters():",
            "    runSerializerTest([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"style\", {}], [\"Characters\", \"\\u0101\"]],",
            "                      [\"<style>&amacr;\"], {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testCharacters():",
            "    runSerializerTest([[\"Characters\", \"\\u0101\"]],",
            "                      [\"&amacr;\"], {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testStartTagName():",
            "    throwsWithLatin1([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"\\u0101\", []]])",
            "",
            "",
            "def testAttributeName():",
            "    throwsWithLatin1([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\", [{\"namespace\": None, \"name\": \"\\u0101\", \"value\": \"potato\"}]]])",
            "",
            "",
            "def testAttributeValue():",
            "    runSerializerTest([[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\",",
            "                        [{\"namespace\": None, \"name\": \"potato\", \"value\": \"\\u0101\"}]]],",
            "                      [\"<span potato=&amacr;>\"], {\"encoding\": \"iso-8859-1\"})",
            "",
            "",
            "def testEndTagName():",
            "    throwsWithLatin1([[\"EndTag\", \"http://www.w3.org/1999/xhtml\", \"\\u0101\"]])",
            "",
            "",
            "def testComment():",
            "    throwsWithLatin1([[\"Comment\", \"\\u0101\"]])",
            "",
            "",
            "@pytest.mark.parametrize(\"c\", list(\"\\t\\n\\u000C\\x20\\r\\\"'=<>`\"))",
            "def testSpecQuoteAttribute(c):",
            "    input_ = [[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\",",
            "               [{\"namespace\": None, \"name\": \"foo\", \"value\": c}]]]",
            "    if c == '\"':",
            "        output_ = [\"<span foo='%s'>\" % c]",
            "    else:",
            "        output_ = ['<span foo=\"%s\">' % c]",
            "    options_ = {\"quote_attr_values\": \"spec\"}",
            "    runSerializerTest(input_, output_, options_)",
            "",
            "",
            "@pytest.mark.parametrize(\"c\", list(\"\\t\\n\\u000C\\x20\\r\\\"'=<>`\"",
            "                                   \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\"",
            "                                   \"\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\"",
            "                                   \"\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\"",
            "                                   \"\\x20\\x2f\\x60\\xa0\\u1680\\u180e\\u180f\\u2000\"",
            "                                   \"\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\"",
            "                                   \"\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\"",
            "                                   \"\\u3000\"))",
            "def testLegacyQuoteAttribute(c):",
            "    input_ = [[\"StartTag\", \"http://www.w3.org/1999/xhtml\", \"span\",",
            "               [{\"namespace\": None, \"name\": \"foo\", \"value\": c}]]]",
            "    if c == '\"':",
            "        output_ = [\"<span foo='%s'>\" % c]",
            "    else:",
            "        output_ = ['<span foo=\"%s\">' % c]",
            "    options_ = {\"quote_attr_values\": \"legacy\"}",
            "    runSerializerTest(input_, output_, options_)",
            "",
            "",
            "@pytest.fixture",
            "def lxml_parser():",
            "    return etree.XMLParser(resolve_entities=False)",
            "",
            "",
            "@pytest.mark.skipif(\"lxml\" not in optionals_loaded, reason=\"lxml not importable\")",
            "def testEntityReplacement(lxml_parser):",
            "    doc = '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&beta;</html>'",
            "    tree = etree.fromstring(doc, parser=lxml_parser).getroottree()",
            "    result = serialize(tree, tree=\"lxml\", omit_optional_tags=False)",
            "    assert result == '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>\\u03B2</html>'",
            "",
            "",
            "@pytest.mark.skipif(\"lxml\" not in optionals_loaded, reason=\"lxml not importable\")",
            "def testEntityXML(lxml_parser):",
            "    doc = '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&gt;</html>'",
            "    tree = etree.fromstring(doc, parser=lxml_parser).getroottree()",
            "    result = serialize(tree, tree=\"lxml\", omit_optional_tags=False)",
            "    assert result == '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&gt;</html>'",
            "",
            "",
            "@pytest.mark.skipif(\"lxml\" not in optionals_loaded, reason=\"lxml not importable\")",
            "def testEntityNoResolve(lxml_parser):",
            "    doc = '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&beta;</html>'",
            "    tree = etree.fromstring(doc, parser=lxml_parser).getroottree()",
            "    result = serialize(tree, tree=\"lxml\", omit_optional_tags=False,",
            "                                  resolve_entities=False)",
            "    assert result == '<!DOCTYPE html SYSTEM \"about:legacy-compat\"><html>&beta;</html>'",
            "",
            "",
            "def test_serializer():",
            "    for filename in get_data_files('serializer-testdata', '*.test', os.path.dirname(__file__)):",
            "        with open(filename) as fp:",
            "            tests = json.load(fp)",
            "            for index, test in enumerate(tests['tests']):",
            "                yield runSerializerTest, test[\"input\"], test[\"expected\"], test.get(\"options\", {})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "html5lib.tests.test_serializer.runSerializerTest.expected",
            "html5lib.tests.test_serializer.runSerializerTest.options",
            "html5lib.tests.test_serializer.serialize_html.options",
            "airflow.www.views.LogModelView",
            "html5lib.tests.test_serializer.runSerializerTest.input",
            "html5lib.tests.test_serializer.serialize_html.input"
        ]
    }
}