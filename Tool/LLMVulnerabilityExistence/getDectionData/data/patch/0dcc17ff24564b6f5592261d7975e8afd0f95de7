{
    "auth/auth/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " uvloop.install()"
            },
            "1": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " CLOUD = get_global_config()['cloud']"
            },
            "3": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-ORGANIZATION_DOMAIN = os.environ['HAIL_ORGANIZATION_DOMAIN']"
            },
            "4": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " DEFAULT_NAMESPACE = os.environ['HAIL_DEFAULT_NAMESPACE']"
            },
            "5": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " is_test_deployment = DEFAULT_NAMESPACE != 'default'"
            },
            "7": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "     cleanup_session(session)"
            },
            "8": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 333,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "     try:"
            },
            "10": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        flow_result = request.app[AppKeys.FLOW_CLIENT].receive_callback(request, flow_dict)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 335,
                "PatchRowcode": "+        flow_client = request.app[AppKeys.FLOW_CLIENT]"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 336,
                "PatchRowcode": "+        flow_result = flow_client.receive_callback(request, flow_dict)"
            },
            "13": {
                "beforePatchRowNumber": 337,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         login_id = flow_result.login_id"
            },
            "14": {
                "beforePatchRowNumber": 338,
                "afterPatchRowNumber": 338,
                "PatchRowcode": "     except asyncio.CancelledError:"
            },
            "15": {
                "beforePatchRowNumber": 339,
                "afterPatchRowNumber": 339,
                "PatchRowcode": "         raise"
            },
            "16": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 352,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "         assert caller == 'signup'"
            },
            "18": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 354,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        username, domain = flow_result.email.split('@')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+        username, _ = flow_result.unverified_email.split('@')"
            },
            "21": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "         username = ''.join(c for c in username if c.isalnum())"
            },
            "22": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 357,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if domain != ORGANIZATION_DOMAIN:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+        assert flow_client.organization_id() is not None"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+        if flow_result.organization_id != flow_client.organization_id():"
            },
            "26": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "             raise web.HTTPUnauthorized()"
            },
            "27": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 361,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "         try:"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import json",
            "import logging",
            "import os",
            "import re",
            "import typing",
            "from contextlib import AsyncExitStack",
            "from typing import List, NoReturn, Optional",
            "",
            "import aiohttp_session",
            "import kubernetes_asyncio.client",
            "import kubernetes_asyncio.client.rest",
            "import kubernetes_asyncio.config",
            "import uvloop",
            "from aiohttp import web",
            "from prometheus_async.aio.web import server_stats  # type: ignore",
            "",
            "from gear import (",
            "    Authenticator,",
            "    Database,",
            "    K8sCache,",
            "    Transaction,",
            "    UserData,",
            "    check_csrf_token,",
            "    create_session,",
            "    json_request,",
            "    json_response,",
            "    maybe_parse_bearer_header,",
            "    monitor_endpoints_middleware,",
            "    setup_aiohttp_session,",
            "    transaction,",
            ")",
            "from gear.auth import AIOHTTPHandler, get_session_id",
            "from gear.cloud_config import get_global_config",
            "from gear.profiling import install_profiler_if_requested",
            "from hailtop import httpx",
            "from hailtop.auth import AzureFlow, Flow, GoogleFlow, IdentityProvider",
            "from hailtop.config import get_deploy_config",
            "from hailtop.hail_logging import AccessLogger",
            "from hailtop.tls import internal_server_ssl_context",
            "from hailtop.utils import secret_alnum_string",
            "from web_common import render_template, set_message, setup_aiohttp_jinja2, setup_common_static_routes",
            "",
            "from .exceptions import (",
            "    AuthUserError,",
            "    DuplicateLoginID,",
            "    DuplicateUsername,",
            "    EmptyLoginID,",
            "    InvalidType,",
            "    InvalidUsername,",
            "    MultipleExistingUsers,",
            "    MultipleUserTypes,",
            "    PreviouslyDeletedUser,",
            "    UnknownUser,",
            ")",
            "",
            "log = logging.getLogger('auth')",
            "",
            "uvloop.install()",
            "",
            "CLOUD = get_global_config()['cloud']",
            "ORGANIZATION_DOMAIN = os.environ['HAIL_ORGANIZATION_DOMAIN']",
            "DEFAULT_NAMESPACE = os.environ['HAIL_DEFAULT_NAMESPACE']",
            "",
            "is_test_deployment = DEFAULT_NAMESPACE != 'default'",
            "",
            "deploy_config = get_deploy_config()",
            "",
            "routes = web.RouteTableDef()",
            "",
            "",
            "async def get_internal_auth_token(request: web.Request) -> Optional[str]:",
            "    if 'X-Hail-Internal-Authorization' in request.headers and DEFAULT_NAMESPACE == 'default':",
            "        return maybe_parse_bearer_header(request.headers['X-Hail-Internal-Authorization'])",
            "    return None",
            "",
            "",
            "class LocalAuthenticator(Authenticator):",
            "    async def _fetch_userdata(self, request: web.Request) -> Optional[UserData]:",
            "        session_id = await get_internal_auth_token(request) or await get_session_id(request)",
            "        if not session_id:",
            "            return None",
            "        return await get_userinfo(request, session_id)",
            "",
            "",
            "auth = LocalAuthenticator()",
            "",
            "",
            "async def user_from_login_id(db: Database, login_id: str) -> Optional[UserData]:",
            "    users = [x async for x in db.select_and_fetchall(\"SELECT * FROM users WHERE login_id = %s;\", login_id)]",
            "    if len(users) == 1:",
            "        return typing.cast(UserData, users[0])",
            "    assert len(users) == 0, users",
            "    return None",
            "",
            "",
            "async def users_with_username_or_login_id(tx: Transaction, username: str, login_id: Optional[str]) -> List[dict]:",
            "    where_conditions = ['username = %s']",
            "    where_args = [username]",
            "",
            "    if login_id is not None:",
            "        where_conditions.append('login_id = %s')",
            "        where_args.append(login_id)",
            "",
            "    existing_users = [",
            "        x",
            "        async for x in tx.execute_and_fetchall(",
            "            f\"SELECT * FROM users WHERE {' OR '.join(where_conditions)} LOCK IN SHARE MODE;\", where_args",
            "        )",
            "    ]",
            "",
            "    return existing_users",
            "",
            "",
            "async def check_valid_new_user(tx: Transaction, username, login_id, is_developer, is_service_account) -> Optional[dict]:",
            "    if not isinstance(username, str):",
            "        raise InvalidType('username', username, 'str')",
            "    if login_id is not None and not isinstance(login_id, str):",
            "        raise InvalidType('login_id', login_id, 'str')",
            "    if not isinstance(is_developer, bool):",
            "        raise InvalidType('is_developer', is_developer, 'bool')",
            "    if not isinstance(is_service_account, bool):",
            "        raise InvalidType('is_service_account', is_service_account, 'bool')",
            "    if is_developer and is_service_account:",
            "        raise MultipleUserTypes(username)",
            "    if not is_service_account and not login_id:",
            "        raise EmptyLoginID(username)",
            "    if not username or not all(c for c in username if c.isalnum()):",
            "        raise InvalidUsername(username)",
            "",
            "    existing_users = await users_with_username_or_login_id(tx, username, login_id)",
            "",
            "    if len(existing_users) > 1:",
            "        raise MultipleExistingUsers(username, login_id)",
            "",
            "    if len(existing_users) == 1:",
            "        existing_user = existing_users[0]",
            "        expected_username = existing_user['username']",
            "        expected_login_id = existing_user['login_id']",
            "        if username != expected_username:",
            "            raise DuplicateLoginID(expected_username, login_id)",
            "        if login_id != expected_login_id:",
            "            raise DuplicateUsername(username, expected_login_id)",
            "        if existing_user['state'] in ('deleting', 'deleted'):",
            "            raise PreviouslyDeletedUser(username)",
            "        return existing_user",
            "",
            "    return None",
            "",
            "",
            "async def insert_new_user(",
            "    db: Database,",
            "    username: str,",
            "    login_id: Optional[str],",
            "    is_developer: bool,",
            "    is_service_account: bool,",
            "    *,",
            "    hail_identity: Optional[str] = None,",
            "    hail_credentials_secret_name: Optional[str] = None,",
            ") -> bool:",
            "    @transaction(db)",
            "    async def _insert(tx):",
            "        existing_user = await check_valid_new_user(tx, username, login_id, is_developer, is_service_account)",
            "        if existing_user is not None:",
            "            return False",
            "",
            "        await tx.execute_insertone(",
            "            '''",
            "INSERT INTO users (state, username, login_id, is_developer, is_service_account, hail_identity, hail_credentials_secret_name)",
            "VALUES (%s, %s, %s, %s, %s, %s, %s);",
            "''',",
            "            (",
            "                'creating',",
            "                username,",
            "                login_id,",
            "                is_developer,",
            "                is_service_account,",
            "                hail_identity,",
            "                hail_credentials_secret_name,",
            "            ),",
            "        )",
            "",
            "    await _insert()",
            "    return True",
            "",
            "",
            "def cleanup_session(session):",
            "    def _delete(key):",
            "        if key in session:",
            "            del session[key]",
            "",
            "    _delete('pending')",
            "    _delete('login_id')",
            "    _delete('next')",
            "    _delete('caller')",
            "    _delete('session_id')",
            "    _delete('flow')",
            "",
            "",
            "@routes.get('/healthcheck')",
            "async def get_healthcheck(_) -> web.Response:",
            "    return web.Response()",
            "",
            "",
            "@routes.get('')",
            "@routes.get('/')",
            "@auth.maybe_authenticated_user",
            "async def get_index(request: web.Request, userdata: Optional[UserData]) -> web.Response:",
            "    return await render_template('auth', request, userdata, 'index.html', {})",
            "",
            "",
            "@routes.get('/creating')",
            "@auth.maybe_authenticated_user",
            "async def creating_account(request: web.Request, userdata: Optional[UserData]) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    session = await aiohttp_session.get_session(request)",
            "    if 'pending' in session:",
            "        login_id = session['login_id']",
            "        user = await user_from_login_id(db, login_id)",
            "",
            "        next_url = deploy_config.external_url('auth', '/user')",
            "        next_page = session.pop('next', next_url)",
            "",
            "        cleanup_session(session)",
            "",
            "        if user is None:",
            "            set_message(session, f'Account does not exist for login id {login_id}.', 'error')",
            "            raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "        page_context = {'username': user['username'], 'state': user['state'], 'login_id': user['login_id']}",
            "",
            "        if user['state'] in ('deleting', 'deleted'):",
            "            return await render_template('auth', request, userdata, 'account-error.html', page_context)",
            "",
            "        if user['state'] == 'active':",
            "            session_id = await create_session(db, user['id'])",
            "            session['session_id'] = session_id",
            "            set_message(session, f'Account has been created for {user[\"username\"]}.', 'info')",
            "            raise web.HTTPFound(next_page)",
            "",
            "        assert user['state'] == 'creating'",
            "        session['pending'] = True",
            "        session['login_id'] = login_id",
            "        session['next'] = next_page",
            "        return await render_template('auth', request, userdata, 'account-creating.html', page_context)",
            "",
            "    raise web.HTTPUnauthorized()",
            "",
            "",
            "@routes.get('/creating/wait')",
            "async def creating_account_wait(request):",
            "    session = await aiohttp_session.get_session(request)",
            "    if 'pending' not in session:",
            "        raise web.HTTPUnauthorized()",
            "    return await _wait_websocket(request, session['login_id'])",
            "",
            "",
            "async def _wait_websocket(request, login_id):",
            "    app = request.app",
            "    db = app[AppKeys.DB]",
            "",
            "    user = await user_from_login_id(db, login_id)",
            "    if not user:",
            "        raise web.HTTPNotFound()",
            "",
            "    ws = web.WebSocketResponse()",
            "    await ws.prepare(request)",
            "",
            "    try:",
            "        count = 0",
            "        user = await user_from_login_id(db, login_id)",
            "        assert user",
            "        while count < 10 and user['state'] == 'creating':",
            "            user = await user_from_login_id(db, login_id)",
            "            assert user",
            "            await asyncio.sleep(1)",
            "            count += 1",
            "",
            "        if count >= 10:",
            "            log.info(f\"user {user['username']} is still in state creating\")",
            "",
            "        ready = user['state'] == 'active'",
            "",
            "        await ws.send_str(str(int(ready)))",
            "        return ws",
            "    finally:",
            "        await ws.close()",
            "",
            "",
            "@routes.get('/signup')",
            "async def signup(request) -> NoReturn:",
            "    next_page = request.query.get('next', deploy_config.external_url('auth', '/user'))",
            "",
            "    flow_data = request.app[AppKeys.FLOW_CLIENT].initiate_flow(deploy_config.external_url('auth', '/oauth2callback'))",
            "",
            "    session = await aiohttp_session.new_session(request)",
            "    cleanup_session(session)",
            "    session['next'] = next_page",
            "    session['caller'] = 'signup'",
            "    session['flow'] = flow_data",
            "",
            "    raise web.HTTPFound(flow_data['authorization_url'])",
            "",
            "",
            "@routes.get('/login')",
            "async def login(request) -> NoReturn:",
            "    next_page = request.query.get('next', deploy_config.external_url('auth', '/user'))",
            "",
            "    flow_data = request.app[AppKeys.FLOW_CLIENT].initiate_flow(deploy_config.external_url('auth', '/oauth2callback'))",
            "",
            "    session = await aiohttp_session.new_session(request)",
            "    cleanup_session(session)",
            "    session['next'] = next_page",
            "    session['caller'] = 'login'",
            "    session['flow'] = flow_data",
            "",
            "    raise web.HTTPFound(flow_data['authorization_url'])",
            "",
            "",
            "@routes.get('/oauth2callback')",
            "async def callback(request) -> web.Response:",
            "    session = await aiohttp_session.get_session(request)",
            "    if 'flow' not in session:",
            "        raise web.HTTPUnauthorized()",
            "",
            "    next_url = deploy_config.external_url('auth', '/user')",
            "    creating_url = deploy_config.external_url('auth', '/creating')",
            "",
            "    caller = session['caller']",
            "    next_page = session.pop('next', next_url)",
            "    flow_dict = session['flow']",
            "    flow_dict['callback_uri'] = deploy_config.external_url('auth', '/oauth2callback')",
            "    cleanup_session(session)",
            "",
            "    try:",
            "        flow_result = request.app[AppKeys.FLOW_CLIENT].receive_callback(request, flow_dict)",
            "        login_id = flow_result.login_id",
            "    except asyncio.CancelledError:",
            "        raise",
            "    except Exception as e:",
            "        log.exception('oauth2 callback: could not fetch and verify token')",
            "        raise web.HTTPUnauthorized() from e",
            "",
            "    db = request.app[AppKeys.DB]",
            "",
            "    user = await user_from_login_id(db, login_id)",
            "",
            "    if user is None:",
            "        if caller == 'login':",
            "            set_message(session, f'Account does not exist for login id {login_id}', 'error')",
            "            raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "        assert caller == 'signup'",
            "",
            "        username, domain = flow_result.email.split('@')",
            "        username = ''.join(c for c in username if c.isalnum())",
            "",
            "        if domain != ORGANIZATION_DOMAIN:",
            "            raise web.HTTPUnauthorized()",
            "",
            "        try:",
            "            await insert_new_user(db, username, login_id, is_developer=False, is_service_account=False)",
            "        except AuthUserError as e:",
            "            set_message(session, e.message, 'error')",
            "            raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "        session['pending'] = True",
            "        session['login_id'] = login_id",
            "",
            "        raise web.HTTPFound(creating_url)",
            "",
            "    if user['state'] in ('deleting', 'deleted'):",
            "        page_context = {'username': user['username'], 'state': user['state'], 'login_id': user['login_id']}",
            "        return await render_template('auth', request, user, 'account-error.html', page_context)",
            "",
            "    if user['state'] == 'creating':",
            "        if caller == 'signup':",
            "            set_message(session, f'Account is already creating for login id {login_id}', 'error')",
            "        if caller == 'login':",
            "            set_message(session, f'Account for login id {login_id} is still being created.', 'error')",
            "        session['pending'] = True",
            "        session['login_id'] = user['login_id']",
            "        raise web.HTTPFound(creating_url)",
            "",
            "    assert user['state'] == 'active'",
            "    if caller == 'signup':",
            "        set_message(session, f'Account has already been created for {user[\"username\"]}.', 'info')",
            "    session_id = await create_session(db, user['id'])",
            "    session['session_id'] = session_id",
            "    raise web.HTTPFound(next_page)",
            "",
            "",
            "@routes.post('/api/v1alpha/users/{user}/create')",
            "@auth.authenticated_developers_only()",
            "async def create_user(request: web.Request, _) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    username = request.match_info['user']",
            "",
            "    body = await json_request(request)",
            "    login_id = body['login_id']",
            "    is_developer = body['is_developer']",
            "    is_service_account = body['is_service_account']",
            "",
            "    hail_identity = body.get('hail_identity')",
            "    hail_credentials_secret_name = body.get('hail_credentials_secret_name')",
            "    if (hail_identity or hail_credentials_secret_name) and not is_test_deployment:",
            "        raise web.HTTPBadRequest(text='Cannot specify an existing hail identity for a new user')",
            "",
            "    try:",
            "        await insert_new_user(",
            "            db,",
            "            username,",
            "            login_id,",
            "            is_developer,",
            "            is_service_account,",
            "            hail_identity=hail_identity,",
            "            hail_credentials_secret_name=hail_credentials_secret_name,",
            "        )",
            "    except AuthUserError as e:",
            "        raise e.http_response()",
            "",
            "    return web.json_response()",
            "",
            "",
            "@routes.get('/user')",
            "@auth.authenticated_users_only()",
            "async def user_page(request: web.Request, userdata: UserData) -> web.Response:",
            "    return await render_template('auth', request, userdata, 'user.html', {'cloud': CLOUD})",
            "",
            "",
            "async def create_copy_paste_token(db, session_id, max_age_secs=300):",
            "    copy_paste_token = secret_alnum_string()",
            "    await db.just_execute(",
            "        \"INSERT INTO copy_paste_tokens (id, session_id, max_age_secs) VALUES(%s, %s, %s);\",",
            "        (copy_paste_token, session_id, max_age_secs),",
            "    )",
            "    return copy_paste_token",
            "",
            "",
            "@routes.post('/copy-paste-token')",
            "@auth.authenticated_users_only()",
            "async def get_copy_paste_token(request: web.Request, userdata: UserData) -> web.Response:",
            "    session = await aiohttp_session.get_session(request)",
            "    session_id = session['session_id']",
            "    db = request.app[AppKeys.DB]",
            "    copy_paste_token = await create_copy_paste_token(db, session_id)",
            "    page_context = {'copy_paste_token': copy_paste_token}",
            "    return await render_template('auth', request, userdata, 'copy-paste-token.html', page_context)",
            "",
            "",
            "@routes.post('/api/v1alpha/copy-paste-token')",
            "@auth.authenticated_users_only()",
            "async def get_copy_paste_token_api(request: web.Request, _) -> web.Response:",
            "    session_id = await get_session_id(request)",
            "    db = request.app[AppKeys.DB]",
            "    copy_paste_token = await create_copy_paste_token(db, session_id)",
            "    return web.Response(body=copy_paste_token)",
            "",
            "",
            "@routes.post('/logout')",
            "@auth.maybe_authenticated_user",
            "async def logout(request: web.Request, userdata: Optional[UserData]) -> NoReturn:",
            "    if not userdata:",
            "        raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "    db = request.app[AppKeys.DB]",
            "    session_id = await get_session_id(request)",
            "    await db.just_execute('DELETE FROM sessions WHERE session_id = %s;', session_id)",
            "",
            "    session = await aiohttp_session.get_session(request)",
            "    cleanup_session(session)",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "",
            "@routes.get('/api/v1alpha/login')",
            "async def rest_login(request: web.Request) -> web.Response:",
            "    callback_port = request.query['callback_port']",
            "    callback_uri = f'http://127.0.0.1:{callback_port}/oauth2callback'",
            "    flow_data = request.app[AppKeys.FLOW_CLIENT].initiate_flow(callback_uri)",
            "    flow_data['callback_uri'] = callback_uri",
            "",
            "    # keeping authorization_url and state for backwards compatibility",
            "    return json_response(",
            "        {'flow': flow_data, 'authorization_url': flow_data['authorization_url'], 'state': flow_data['state']}",
            "    )",
            "",
            "",
            "@routes.get('/api/v1alpha/oauth2-client')",
            "async def hailctl_oauth_client(request):  # pylint: disable=unused-argument",
            "    idp = IdentityProvider.GOOGLE if CLOUD == 'gcp' else IdentityProvider.MICROSOFT",
            "    return json_response({'idp': idp.value, 'oauth2_client': request.app[AppKeys.HAILCTL_CLIENT_CONFIG]})",
            "",
            "",
            "@routes.get('/roles')",
            "@auth.authenticated_developers_only()",
            "async def get_roles(request: web.Request, userdata: UserData) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    roles = [x async for x in db.select_and_fetchall('SELECT * FROM roles;')]",
            "    page_context = {'roles': roles}",
            "    return await render_template('auth', request, userdata, 'roles.html', page_context)",
            "",
            "",
            "@routes.post('/roles')",
            "@auth.authenticated_developers_only()",
            "async def post_create_role(request: web.Request, _) -> NoReturn:",
            "    session = await aiohttp_session.get_session(request)",
            "    db = request.app[AppKeys.DB]",
            "    post = await request.post()",
            "    name = str(post['name'])",
            "",
            "    role_id = await db.execute_insertone(",
            "        '''",
            "INSERT INTO `roles` (`name`)",
            "VALUES (%s);",
            "''',",
            "        (name),",
            "    )",
            "",
            "    set_message(session, f'Created role {role_id} {name}.', 'info')",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', '/roles'))",
            "",
            "",
            "@routes.get('/users')",
            "@auth.authenticated_developers_only()",
            "async def get_users(request: web.Request, userdata: UserData) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    users = [x async for x in db.select_and_fetchall('SELECT * FROM users;')]",
            "    page_context = {'users': users}",
            "    return await render_template('auth', request, userdata, 'users.html', page_context)",
            "",
            "",
            "@routes.post('/users')",
            "@auth.authenticated_developers_only()",
            "async def post_create_user(request: web.Request, _) -> NoReturn:",
            "    session = await aiohttp_session.get_session(request)",
            "    db = request.app[AppKeys.DB]",
            "    post = await request.post()",
            "    username = str(post['username'])",
            "    login_id = str(post['login_id']) if 'login_id' in post else None",
            "    is_developer = post.get('is_developer') == '1'",
            "    is_service_account = post.get('is_service_account') == '1'",
            "",
            "    try:",
            "        created_user = await insert_new_user(db, username, login_id, is_developer, is_service_account)",
            "    except AuthUserError as e:",
            "        set_message(session, e.message, 'error')",
            "        raise web.HTTPFound(deploy_config.external_url('auth', '/users'))",
            "",
            "    if created_user:",
            "        set_message(session, f'Created user {username} {login_id}.', 'info')",
            "    else:",
            "        set_message(session, f'User {username} {login_id} already exists.', 'info')",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', '/users'))",
            "",
            "",
            "@routes.get('/api/v1alpha/users')",
            "@auth.authenticated_users_only()",
            "async def rest_get_users(request: web.Request, userdata: UserData) -> web.Response:",
            "    if userdata['is_developer'] != 1 and userdata['username'] != 'ci':",
            "        raise web.HTTPUnauthorized()",
            "",
            "    db = request.app[AppKeys.DB]",
            "    _query = '''",
            "SELECT id, username, login_id, state, is_developer, is_service_account, hail_identity",
            "FROM users;",
            "'''",
            "    users = [x async for x in db.select_and_fetchall(_query)]",
            "    return json_response(users)",
            "",
            "",
            "@routes.get('/api/v1alpha/users/{user}')",
            "@auth.authenticated_developers_only()",
            "async def rest_get_user(request: web.Request, _) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    username = request.match_info['user']",
            "",
            "    user = await db.select_and_fetchone(",
            "        '''",
            "SELECT id, username, login_id, state, is_developer, is_service_account, hail_identity FROM users",
            "WHERE username = %s;",
            "''',",
            "        (username,),",
            "    )",
            "    if user is None:",
            "        raise web.HTTPNotFound()",
            "    return json_response(user)",
            "",
            "",
            "async def _delete_user(db: Database, username: str, id: Optional[str]):",
            "    where_conditions = ['state != \"deleted\"', 'username = %s']",
            "    where_args = [username]",
            "",
            "    if id is not None:",
            "        where_conditions.append('id = %s')",
            "        where_args.append(id)",
            "",
            "    n_rows = await db.execute_update(",
            "        f'''",
            "UPDATE users",
            "SET state = 'deleting'",
            "WHERE {' AND '.join(where_conditions)};",
            "''',",
            "        where_args,",
            "    )",
            "",
            "    if n_rows == 0:",
            "        raise UnknownUser(username)",
            "",
            "",
            "@routes.post('/users/delete')",
            "@auth.authenticated_developers_only()",
            "async def delete_user(request: web.Request, _) -> NoReturn:",
            "    session = await aiohttp_session.get_session(request)",
            "    db = request.app[AppKeys.DB]",
            "    post = await request.post()",
            "    id = str(post['id'])",
            "    username = str(post['username'])",
            "",
            "    try:",
            "        await _delete_user(db, username, id)",
            "        set_message(session, f'Deleted user {id} {username}.', 'info')",
            "    except UnknownUser:",
            "        set_message(session, f'Delete failed, no such user {id} {username}.', 'error')",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', '/users'))",
            "",
            "",
            "@routes.delete('/api/v1alpha/users/{user}')",
            "@auth.authenticated_developers_only()",
            "async def rest_delete_user(request: web.Request, _) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    username = request.match_info['user']",
            "",
            "    try:",
            "        await _delete_user(db, username, None)",
            "    except UnknownUser as e:",
            "        raise e.http_response()",
            "",
            "    return web.json_response()",
            "",
            "",
            "@routes.get('/api/v1alpha/oauth2callback')",
            "async def rest_callback(request):",
            "    flow_json = request.query.get('flow')",
            "    if flow_json is None:",
            "        # backwards compatibility with older versions of hailctl",
            "        callback_port = request.query['callback_port']",
            "        flow_dict = {",
            "            'state': request.query['state'],",
            "            'callback_uri': f'http://127.0.0.1:{callback_port}/oauth2callback',",
            "        }",
            "    else:",
            "        flow_dict = json.loads(request.query['flow'])",
            "",
            "    try:",
            "        flow_result = request.app[AppKeys.FLOW_CLIENT].receive_callback(request, flow_dict)",
            "    except asyncio.CancelledError:",
            "        raise",
            "    except Exception as e:",
            "        log.exception('fetching and decoding token')",
            "        raise web.HTTPUnauthorized() from e",
            "",
            "    db = request.app[AppKeys.DB]",
            "    users = [",
            "        x",
            "        async for x in db.select_and_fetchall(",
            "            \"SELECT * FROM users WHERE login_id = %s AND state = 'active';\", flow_result.login_id",
            "        )",
            "    ]",
            "",
            "    if len(users) != 1:",
            "        raise web.HTTPUnauthorized()",
            "    user = users[0]",
            "",
            "    session_id = await create_session(db, user['id'], max_age_secs=None)",
            "",
            "    return json_response({'token': session_id, 'username': user['username']})",
            "",
            "",
            "@routes.post('/api/v1alpha/copy-paste-login')",
            "async def rest_copy_paste_login(request):",
            "    copy_paste_token = request.query['copy_paste_token']",
            "    db = request.app[AppKeys.DB]",
            "",
            "    @transaction(db)",
            "    async def maybe_pop_token(tx):",
            "        session = await tx.execute_and_fetchone(",
            "            \"\"\"",
            "SELECT sessions.session_id AS session_id, users.username AS username FROM copy_paste_tokens",
            "INNER JOIN sessions ON sessions.session_id = copy_paste_tokens.session_id",
            "INNER JOIN users ON users.id = sessions.user_id",
            "WHERE copy_paste_tokens.id = %s",
            "  AND NOW() < TIMESTAMPADD(SECOND, copy_paste_tokens.max_age_secs, copy_paste_tokens.created)",
            "  AND users.state = 'active';\"\"\",",
            "            copy_paste_token,",
            "        )",
            "        if session is None:",
            "            raise web.HTTPUnauthorized()",
            "        await tx.just_execute(\"DELETE FROM copy_paste_tokens WHERE id = %s;\", copy_paste_token)",
            "        return session",
            "",
            "    session = await maybe_pop_token()",
            "    return json_response({'token': session['session_id'], 'username': session['username']})",
            "",
            "",
            "@routes.post('/api/v1alpha/logout')",
            "@auth.authenticated_users_only()",
            "async def rest_logout(request: web.Request, _) -> web.Response:",
            "    session_id = await get_session_id(request)",
            "    db = request.app[AppKeys.DB]",
            "    await db.just_execute('DELETE FROM sessions WHERE session_id = %s;', session_id)",
            "",
            "    return web.Response(status=200)",
            "",
            "",
            "async def get_userinfo(request: web.Request, auth_token: str) -> UserData:",
            "    flow_client = request.app[AppKeys.FLOW_CLIENT]",
            "    client_session = request.app[AppKeys.CLIENT_SESSION]",
            "",
            "    userdata = await get_userinfo_from_hail_session_id(request, auth_token)",
            "    if userdata:",
            "        return userdata",
            "",
            "    hailctl_oauth_client = request.app[AppKeys.HAILCTL_CLIENT_CONFIG]",
            "    uid = await flow_client.get_identity_uid_from_access_token(",
            "        client_session, auth_token, oauth2_client=hailctl_oauth_client",
            "    )",
            "    if uid:",
            "        return await get_userinfo_from_login_id_or_hail_identity_id(request, uid)",
            "",
            "    raise web.HTTPUnauthorized()",
            "",
            "",
            "async def get_userinfo_from_login_id_or_hail_identity_id(",
            "    request: web.Request, login_id_or_hail_idenity_uid: str",
            ") -> UserData:",
            "    db = request.app[AppKeys.DB]",
            "",
            "    users = [",
            "        x",
            "        async for x in db.select_and_fetchall(",
            "            '''",
            "SELECT users.*",
            "FROM users",
            "WHERE (users.login_id = %s OR users.hail_identity_uid = %s) AND users.state = 'active'",
            "''',",
            "            (login_id_or_hail_idenity_uid, login_id_or_hail_idenity_uid),",
            "        )",
            "    ]",
            "",
            "    if len(users) != 1:",
            "        log.info('Unknown login id')",
            "        raise web.HTTPUnauthorized()",
            "    return typing.cast(UserData, users[0])",
            "",
            "",
            "async def get_userinfo_from_hail_session_id(request: web.Request, session_id: str) -> Optional[UserData]:",
            "    # b64 encoding of 32-byte session ID is 44 bytes",
            "    if len(session_id) != 44:",
            "        return None",
            "",
            "    db = request.app[AppKeys.DB]",
            "    users = [",
            "        x",
            "        async for x in db.select_and_fetchall(",
            "            '''",
            "SELECT users.*",
            "FROM users",
            "INNER JOIN sessions ON users.id = sessions.user_id",
            "WHERE users.state = 'active' AND sessions.session_id = %s AND (ISNULL(sessions.max_age_secs) OR (NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created)));",
            "''',",
            "            session_id,",
            "            'get_userinfo',",
            "        )",
            "    ]",
            "",
            "    if len(users) != 1:",
            "        return None",
            "    return typing.cast(UserData, users[0])",
            "",
            "",
            "@routes.get('/api/v1alpha/userinfo')",
            "@auth.authenticated_users_only()",
            "async def userinfo(_, userdata: UserData) -> web.Response:",
            "    return json_response(userdata)",
            "",
            "",
            "@routes.route('*', '/api/v1alpha/verify_dev_credentials', name='verify_dev')",
            "@auth.authenticated_users_only()",
            "async def verify_dev_credentials(_, userdata: UserData) -> web.Response:",
            "    if userdata['is_developer'] != 1:",
            "        raise web.HTTPUnauthorized()",
            "    return web.Response(status=200)",
            "",
            "",
            "@routes.route('*', '/api/v1alpha/verify_dev_or_sa_credentials', name='verify_dev_or_sa')",
            "@auth.authenticated_users_only()",
            "async def verify_dev_or_sa_credentials(_, userdata: UserData) -> web.Response:",
            "    if userdata['is_developer'] != 1 and userdata['is_service_account'] != 1:",
            "        raise web.HTTPUnauthorized()",
            "    return web.Response(status=200)",
            "",
            "",
            "class AppKeys:",
            "    DB = web.AppKey('db', Database)",
            "    CLIENT_SESSION = web.AppKey('client_session', httpx.ClientSession)",
            "    FLOW_CLIENT = web.AppKey('flow_client', Flow)",
            "    HAILCTL_CLIENT_CONFIG = web.AppKey('hailctl_client_config', dict)",
            "    K8S_CLIENT = web.AppKey('k8s_client', kubernetes_asyncio.client.CoreV1Api)",
            "    K8S_CACHE = web.AppKey('k8s_cache', K8sCache)",
            "",
            "",
            "async def on_startup(app):",
            "    db = Database()",
            "    await db.async_init(maxsize=50)",
            "    app[AppKeys.DB] = db",
            "    app[AppKeys.CLIENT_SESSION] = httpx.client_session()",
            "",
            "    credentials_file = '/auth-oauth2-client-secret/client_secret.json'",
            "    if CLOUD == 'gcp':",
            "        app[AppKeys.FLOW_CLIENT] = GoogleFlow(credentials_file)",
            "    else:",
            "        assert CLOUD == 'azure'",
            "        app[AppKeys.FLOW_CLIENT] = AzureFlow(credentials_file)",
            "",
            "    with open('/auth-oauth2-client-secret/hailctl_client_secret.json', 'r', encoding='utf-8') as f:",
            "        app[AppKeys.HAILCTL_CLIENT_CONFIG] = json.loads(f.read())",
            "",
            "    kubernetes_asyncio.config.load_incluster_config()",
            "    app[AppKeys.K8S_CLIENT] = kubernetes_asyncio.client.CoreV1Api()",
            "    app[AppKeys.K8S_CACHE] = K8sCache(app[AppKeys.K8S_CLIENT])",
            "",
            "",
            "async def on_cleanup(app):",
            "    async with AsyncExitStack() as cleanup:",
            "        cleanup.push_async_callback(app[AppKeys.K8S_CLIENT].api_client.rest_client.pool_manager.close)",
            "        cleanup.push_async_callback(app[AppKeys.DB].async_close)",
            "        cleanup.push_async_callback(app[AppKeys.CLIENT_SESSION].close)",
            "",
            "",
            "class AuthAccessLogger(AccessLogger):",
            "    def __init__(self, logger: logging.Logger, log_format: str):",
            "        super().__init__(logger, log_format)",
            "        self.exclude = [",
            "            (endpoint[0], re.compile(deploy_config.base_path('auth') + endpoint[1]))",
            "            for endpoint in [",
            "                ('GET', '/api/v1alpha/userinfo'),",
            "            ]",
            "        ]",
            "",
            "    def log(self, request, response, time):",
            "        for method, path_expr in self.exclude:",
            "            if path_expr.fullmatch(request.path) and method == request.method:",
            "                return",
            "",
            "        super().log(request, response, time)",
            "",
            "",
            "@web.middleware",
            "async def auth_check_csrf_token(request: web.Request, handler: AIOHTTPHandler):",
            "    # The below are used by gateway / Envoy reverse proxies for auth checks, but",
            "    # Envoy calls those auth endpoints with the same HTTP method as the original",
            "    # user's request. In the case where a user is trying to POST to a protected",
            "    # service, that will additionally trigger a CSRF check on the auth endpoint",
            "    # which cannot always be conducted if, for example, the backend service is",
            "    # Grafana which conducts its own CSRF mitigations separate from our own.",
            "    # These auth endpoints are not CSRF-vulnerable so we opt out of CSRF-token",
            "    # validation.",
            "    # See: https://github.com/envoyproxy/envoy/issues/5357",
            "    envoy_auth_endpoints = {request.app.router[name].canonical for name in ('verify_dev', 'verify_dev_or_sa')}",
            "    if request.path in envoy_auth_endpoints:",
            "        return await handler(request)",
            "",
            "    return await check_csrf_token(request, handler)",
            "",
            "",
            "def run():",
            "    install_profiler_if_requested('auth')",
            "",
            "    app = web.Application(middlewares=[auth_check_csrf_token, monitor_endpoints_middleware])",
            "",
            "    setup_aiohttp_jinja2(app, 'auth')",
            "    setup_aiohttp_session(app)",
            "",
            "    setup_common_static_routes(routes)",
            "    app.add_routes(routes)",
            "    app.router.add_get(\"/metrics\", server_stats)",
            "",
            "    app.on_startup.append(on_startup)",
            "    app.on_cleanup.append(on_cleanup)",
            "",
            "    web.run_app(",
            "        deploy_config.prefix_application(app, 'auth'),",
            "        host='0.0.0.0',",
            "        port=443,",
            "        access_log_class=AuthAccessLogger,",
            "        ssl_context=internal_server_ssl_context(),",
            "    )"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import json",
            "import logging",
            "import os",
            "import re",
            "import typing",
            "from contextlib import AsyncExitStack",
            "from typing import List, NoReturn, Optional",
            "",
            "import aiohttp_session",
            "import kubernetes_asyncio.client",
            "import kubernetes_asyncio.client.rest",
            "import kubernetes_asyncio.config",
            "import uvloop",
            "from aiohttp import web",
            "from prometheus_async.aio.web import server_stats  # type: ignore",
            "",
            "from gear import (",
            "    Authenticator,",
            "    Database,",
            "    K8sCache,",
            "    Transaction,",
            "    UserData,",
            "    check_csrf_token,",
            "    create_session,",
            "    json_request,",
            "    json_response,",
            "    maybe_parse_bearer_header,",
            "    monitor_endpoints_middleware,",
            "    setup_aiohttp_session,",
            "    transaction,",
            ")",
            "from gear.auth import AIOHTTPHandler, get_session_id",
            "from gear.cloud_config import get_global_config",
            "from gear.profiling import install_profiler_if_requested",
            "from hailtop import httpx",
            "from hailtop.auth import AzureFlow, Flow, GoogleFlow, IdentityProvider",
            "from hailtop.config import get_deploy_config",
            "from hailtop.hail_logging import AccessLogger",
            "from hailtop.tls import internal_server_ssl_context",
            "from hailtop.utils import secret_alnum_string",
            "from web_common import render_template, set_message, setup_aiohttp_jinja2, setup_common_static_routes",
            "",
            "from .exceptions import (",
            "    AuthUserError,",
            "    DuplicateLoginID,",
            "    DuplicateUsername,",
            "    EmptyLoginID,",
            "    InvalidType,",
            "    InvalidUsername,",
            "    MultipleExistingUsers,",
            "    MultipleUserTypes,",
            "    PreviouslyDeletedUser,",
            "    UnknownUser,",
            ")",
            "",
            "log = logging.getLogger('auth')",
            "",
            "uvloop.install()",
            "",
            "CLOUD = get_global_config()['cloud']",
            "DEFAULT_NAMESPACE = os.environ['HAIL_DEFAULT_NAMESPACE']",
            "",
            "is_test_deployment = DEFAULT_NAMESPACE != 'default'",
            "",
            "deploy_config = get_deploy_config()",
            "",
            "routes = web.RouteTableDef()",
            "",
            "",
            "async def get_internal_auth_token(request: web.Request) -> Optional[str]:",
            "    if 'X-Hail-Internal-Authorization' in request.headers and DEFAULT_NAMESPACE == 'default':",
            "        return maybe_parse_bearer_header(request.headers['X-Hail-Internal-Authorization'])",
            "    return None",
            "",
            "",
            "class LocalAuthenticator(Authenticator):",
            "    async def _fetch_userdata(self, request: web.Request) -> Optional[UserData]:",
            "        session_id = await get_internal_auth_token(request) or await get_session_id(request)",
            "        if not session_id:",
            "            return None",
            "        return await get_userinfo(request, session_id)",
            "",
            "",
            "auth = LocalAuthenticator()",
            "",
            "",
            "async def user_from_login_id(db: Database, login_id: str) -> Optional[UserData]:",
            "    users = [x async for x in db.select_and_fetchall(\"SELECT * FROM users WHERE login_id = %s;\", login_id)]",
            "    if len(users) == 1:",
            "        return typing.cast(UserData, users[0])",
            "    assert len(users) == 0, users",
            "    return None",
            "",
            "",
            "async def users_with_username_or_login_id(tx: Transaction, username: str, login_id: Optional[str]) -> List[dict]:",
            "    where_conditions = ['username = %s']",
            "    where_args = [username]",
            "",
            "    if login_id is not None:",
            "        where_conditions.append('login_id = %s')",
            "        where_args.append(login_id)",
            "",
            "    existing_users = [",
            "        x",
            "        async for x in tx.execute_and_fetchall(",
            "            f\"SELECT * FROM users WHERE {' OR '.join(where_conditions)} LOCK IN SHARE MODE;\", where_args",
            "        )",
            "    ]",
            "",
            "    return existing_users",
            "",
            "",
            "async def check_valid_new_user(tx: Transaction, username, login_id, is_developer, is_service_account) -> Optional[dict]:",
            "    if not isinstance(username, str):",
            "        raise InvalidType('username', username, 'str')",
            "    if login_id is not None and not isinstance(login_id, str):",
            "        raise InvalidType('login_id', login_id, 'str')",
            "    if not isinstance(is_developer, bool):",
            "        raise InvalidType('is_developer', is_developer, 'bool')",
            "    if not isinstance(is_service_account, bool):",
            "        raise InvalidType('is_service_account', is_service_account, 'bool')",
            "    if is_developer and is_service_account:",
            "        raise MultipleUserTypes(username)",
            "    if not is_service_account and not login_id:",
            "        raise EmptyLoginID(username)",
            "    if not username or not all(c for c in username if c.isalnum()):",
            "        raise InvalidUsername(username)",
            "",
            "    existing_users = await users_with_username_or_login_id(tx, username, login_id)",
            "",
            "    if len(existing_users) > 1:",
            "        raise MultipleExistingUsers(username, login_id)",
            "",
            "    if len(existing_users) == 1:",
            "        existing_user = existing_users[0]",
            "        expected_username = existing_user['username']",
            "        expected_login_id = existing_user['login_id']",
            "        if username != expected_username:",
            "            raise DuplicateLoginID(expected_username, login_id)",
            "        if login_id != expected_login_id:",
            "            raise DuplicateUsername(username, expected_login_id)",
            "        if existing_user['state'] in ('deleting', 'deleted'):",
            "            raise PreviouslyDeletedUser(username)",
            "        return existing_user",
            "",
            "    return None",
            "",
            "",
            "async def insert_new_user(",
            "    db: Database,",
            "    username: str,",
            "    login_id: Optional[str],",
            "    is_developer: bool,",
            "    is_service_account: bool,",
            "    *,",
            "    hail_identity: Optional[str] = None,",
            "    hail_credentials_secret_name: Optional[str] = None,",
            ") -> bool:",
            "    @transaction(db)",
            "    async def _insert(tx):",
            "        existing_user = await check_valid_new_user(tx, username, login_id, is_developer, is_service_account)",
            "        if existing_user is not None:",
            "            return False",
            "",
            "        await tx.execute_insertone(",
            "            '''",
            "INSERT INTO users (state, username, login_id, is_developer, is_service_account, hail_identity, hail_credentials_secret_name)",
            "VALUES (%s, %s, %s, %s, %s, %s, %s);",
            "''',",
            "            (",
            "                'creating',",
            "                username,",
            "                login_id,",
            "                is_developer,",
            "                is_service_account,",
            "                hail_identity,",
            "                hail_credentials_secret_name,",
            "            ),",
            "        )",
            "",
            "    await _insert()",
            "    return True",
            "",
            "",
            "def cleanup_session(session):",
            "    def _delete(key):",
            "        if key in session:",
            "            del session[key]",
            "",
            "    _delete('pending')",
            "    _delete('login_id')",
            "    _delete('next')",
            "    _delete('caller')",
            "    _delete('session_id')",
            "    _delete('flow')",
            "",
            "",
            "@routes.get('/healthcheck')",
            "async def get_healthcheck(_) -> web.Response:",
            "    return web.Response()",
            "",
            "",
            "@routes.get('')",
            "@routes.get('/')",
            "@auth.maybe_authenticated_user",
            "async def get_index(request: web.Request, userdata: Optional[UserData]) -> web.Response:",
            "    return await render_template('auth', request, userdata, 'index.html', {})",
            "",
            "",
            "@routes.get('/creating')",
            "@auth.maybe_authenticated_user",
            "async def creating_account(request: web.Request, userdata: Optional[UserData]) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    session = await aiohttp_session.get_session(request)",
            "    if 'pending' in session:",
            "        login_id = session['login_id']",
            "        user = await user_from_login_id(db, login_id)",
            "",
            "        next_url = deploy_config.external_url('auth', '/user')",
            "        next_page = session.pop('next', next_url)",
            "",
            "        cleanup_session(session)",
            "",
            "        if user is None:",
            "            set_message(session, f'Account does not exist for login id {login_id}.', 'error')",
            "            raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "        page_context = {'username': user['username'], 'state': user['state'], 'login_id': user['login_id']}",
            "",
            "        if user['state'] in ('deleting', 'deleted'):",
            "            return await render_template('auth', request, userdata, 'account-error.html', page_context)",
            "",
            "        if user['state'] == 'active':",
            "            session_id = await create_session(db, user['id'])",
            "            session['session_id'] = session_id",
            "            set_message(session, f'Account has been created for {user[\"username\"]}.', 'info')",
            "            raise web.HTTPFound(next_page)",
            "",
            "        assert user['state'] == 'creating'",
            "        session['pending'] = True",
            "        session['login_id'] = login_id",
            "        session['next'] = next_page",
            "        return await render_template('auth', request, userdata, 'account-creating.html', page_context)",
            "",
            "    raise web.HTTPUnauthorized()",
            "",
            "",
            "@routes.get('/creating/wait')",
            "async def creating_account_wait(request):",
            "    session = await aiohttp_session.get_session(request)",
            "    if 'pending' not in session:",
            "        raise web.HTTPUnauthorized()",
            "    return await _wait_websocket(request, session['login_id'])",
            "",
            "",
            "async def _wait_websocket(request, login_id):",
            "    app = request.app",
            "    db = app[AppKeys.DB]",
            "",
            "    user = await user_from_login_id(db, login_id)",
            "    if not user:",
            "        raise web.HTTPNotFound()",
            "",
            "    ws = web.WebSocketResponse()",
            "    await ws.prepare(request)",
            "",
            "    try:",
            "        count = 0",
            "        user = await user_from_login_id(db, login_id)",
            "        assert user",
            "        while count < 10 and user['state'] == 'creating':",
            "            user = await user_from_login_id(db, login_id)",
            "            assert user",
            "            await asyncio.sleep(1)",
            "            count += 1",
            "",
            "        if count >= 10:",
            "            log.info(f\"user {user['username']} is still in state creating\")",
            "",
            "        ready = user['state'] == 'active'",
            "",
            "        await ws.send_str(str(int(ready)))",
            "        return ws",
            "    finally:",
            "        await ws.close()",
            "",
            "",
            "@routes.get('/signup')",
            "async def signup(request) -> NoReturn:",
            "    next_page = request.query.get('next', deploy_config.external_url('auth', '/user'))",
            "",
            "    flow_data = request.app[AppKeys.FLOW_CLIENT].initiate_flow(deploy_config.external_url('auth', '/oauth2callback'))",
            "",
            "    session = await aiohttp_session.new_session(request)",
            "    cleanup_session(session)",
            "    session['next'] = next_page",
            "    session['caller'] = 'signup'",
            "    session['flow'] = flow_data",
            "",
            "    raise web.HTTPFound(flow_data['authorization_url'])",
            "",
            "",
            "@routes.get('/login')",
            "async def login(request) -> NoReturn:",
            "    next_page = request.query.get('next', deploy_config.external_url('auth', '/user'))",
            "",
            "    flow_data = request.app[AppKeys.FLOW_CLIENT].initiate_flow(deploy_config.external_url('auth', '/oauth2callback'))",
            "",
            "    session = await aiohttp_session.new_session(request)",
            "    cleanup_session(session)",
            "    session['next'] = next_page",
            "    session['caller'] = 'login'",
            "    session['flow'] = flow_data",
            "",
            "    raise web.HTTPFound(flow_data['authorization_url'])",
            "",
            "",
            "@routes.get('/oauth2callback')",
            "async def callback(request) -> web.Response:",
            "    session = await aiohttp_session.get_session(request)",
            "    if 'flow' not in session:",
            "        raise web.HTTPUnauthorized()",
            "",
            "    next_url = deploy_config.external_url('auth', '/user')",
            "    creating_url = deploy_config.external_url('auth', '/creating')",
            "",
            "    caller = session['caller']",
            "    next_page = session.pop('next', next_url)",
            "    flow_dict = session['flow']",
            "    flow_dict['callback_uri'] = deploy_config.external_url('auth', '/oauth2callback')",
            "    cleanup_session(session)",
            "",
            "    try:",
            "        flow_client = request.app[AppKeys.FLOW_CLIENT]",
            "        flow_result = flow_client.receive_callback(request, flow_dict)",
            "        login_id = flow_result.login_id",
            "    except asyncio.CancelledError:",
            "        raise",
            "    except Exception as e:",
            "        log.exception('oauth2 callback: could not fetch and verify token')",
            "        raise web.HTTPUnauthorized() from e",
            "",
            "    db = request.app[AppKeys.DB]",
            "",
            "    user = await user_from_login_id(db, login_id)",
            "",
            "    if user is None:",
            "        if caller == 'login':",
            "            set_message(session, f'Account does not exist for login id {login_id}', 'error')",
            "            raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "        assert caller == 'signup'",
            "",
            "        username, _ = flow_result.unverified_email.split('@')",
            "        username = ''.join(c for c in username if c.isalnum())",
            "",
            "        assert flow_client.organization_id() is not None",
            "        if flow_result.organization_id != flow_client.organization_id():",
            "            raise web.HTTPUnauthorized()",
            "",
            "        try:",
            "            await insert_new_user(db, username, login_id, is_developer=False, is_service_account=False)",
            "        except AuthUserError as e:",
            "            set_message(session, e.message, 'error')",
            "            raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "        session['pending'] = True",
            "        session['login_id'] = login_id",
            "",
            "        raise web.HTTPFound(creating_url)",
            "",
            "    if user['state'] in ('deleting', 'deleted'):",
            "        page_context = {'username': user['username'], 'state': user['state'], 'login_id': user['login_id']}",
            "        return await render_template('auth', request, user, 'account-error.html', page_context)",
            "",
            "    if user['state'] == 'creating':",
            "        if caller == 'signup':",
            "            set_message(session, f'Account is already creating for login id {login_id}', 'error')",
            "        if caller == 'login':",
            "            set_message(session, f'Account for login id {login_id} is still being created.', 'error')",
            "        session['pending'] = True",
            "        session['login_id'] = user['login_id']",
            "        raise web.HTTPFound(creating_url)",
            "",
            "    assert user['state'] == 'active'",
            "    if caller == 'signup':",
            "        set_message(session, f'Account has already been created for {user[\"username\"]}.', 'info')",
            "    session_id = await create_session(db, user['id'])",
            "    session['session_id'] = session_id",
            "    raise web.HTTPFound(next_page)",
            "",
            "",
            "@routes.post('/api/v1alpha/users/{user}/create')",
            "@auth.authenticated_developers_only()",
            "async def create_user(request: web.Request, _) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    username = request.match_info['user']",
            "",
            "    body = await json_request(request)",
            "    login_id = body['login_id']",
            "    is_developer = body['is_developer']",
            "    is_service_account = body['is_service_account']",
            "",
            "    hail_identity = body.get('hail_identity')",
            "    hail_credentials_secret_name = body.get('hail_credentials_secret_name')",
            "    if (hail_identity or hail_credentials_secret_name) and not is_test_deployment:",
            "        raise web.HTTPBadRequest(text='Cannot specify an existing hail identity for a new user')",
            "",
            "    try:",
            "        await insert_new_user(",
            "            db,",
            "            username,",
            "            login_id,",
            "            is_developer,",
            "            is_service_account,",
            "            hail_identity=hail_identity,",
            "            hail_credentials_secret_name=hail_credentials_secret_name,",
            "        )",
            "    except AuthUserError as e:",
            "        raise e.http_response()",
            "",
            "    return web.json_response()",
            "",
            "",
            "@routes.get('/user')",
            "@auth.authenticated_users_only()",
            "async def user_page(request: web.Request, userdata: UserData) -> web.Response:",
            "    return await render_template('auth', request, userdata, 'user.html', {'cloud': CLOUD})",
            "",
            "",
            "async def create_copy_paste_token(db, session_id, max_age_secs=300):",
            "    copy_paste_token = secret_alnum_string()",
            "    await db.just_execute(",
            "        \"INSERT INTO copy_paste_tokens (id, session_id, max_age_secs) VALUES(%s, %s, %s);\",",
            "        (copy_paste_token, session_id, max_age_secs),",
            "    )",
            "    return copy_paste_token",
            "",
            "",
            "@routes.post('/copy-paste-token')",
            "@auth.authenticated_users_only()",
            "async def get_copy_paste_token(request: web.Request, userdata: UserData) -> web.Response:",
            "    session = await aiohttp_session.get_session(request)",
            "    session_id = session['session_id']",
            "    db = request.app[AppKeys.DB]",
            "    copy_paste_token = await create_copy_paste_token(db, session_id)",
            "    page_context = {'copy_paste_token': copy_paste_token}",
            "    return await render_template('auth', request, userdata, 'copy-paste-token.html', page_context)",
            "",
            "",
            "@routes.post('/api/v1alpha/copy-paste-token')",
            "@auth.authenticated_users_only()",
            "async def get_copy_paste_token_api(request: web.Request, _) -> web.Response:",
            "    session_id = await get_session_id(request)",
            "    db = request.app[AppKeys.DB]",
            "    copy_paste_token = await create_copy_paste_token(db, session_id)",
            "    return web.Response(body=copy_paste_token)",
            "",
            "",
            "@routes.post('/logout')",
            "@auth.maybe_authenticated_user",
            "async def logout(request: web.Request, userdata: Optional[UserData]) -> NoReturn:",
            "    if not userdata:",
            "        raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "    db = request.app[AppKeys.DB]",
            "    session_id = await get_session_id(request)",
            "    await db.just_execute('DELETE FROM sessions WHERE session_id = %s;', session_id)",
            "",
            "    session = await aiohttp_session.get_session(request)",
            "    cleanup_session(session)",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', ''))",
            "",
            "",
            "@routes.get('/api/v1alpha/login')",
            "async def rest_login(request: web.Request) -> web.Response:",
            "    callback_port = request.query['callback_port']",
            "    callback_uri = f'http://127.0.0.1:{callback_port}/oauth2callback'",
            "    flow_data = request.app[AppKeys.FLOW_CLIENT].initiate_flow(callback_uri)",
            "    flow_data['callback_uri'] = callback_uri",
            "",
            "    # keeping authorization_url and state for backwards compatibility",
            "    return json_response(",
            "        {'flow': flow_data, 'authorization_url': flow_data['authorization_url'], 'state': flow_data['state']}",
            "    )",
            "",
            "",
            "@routes.get('/api/v1alpha/oauth2-client')",
            "async def hailctl_oauth_client(request):  # pylint: disable=unused-argument",
            "    idp = IdentityProvider.GOOGLE if CLOUD == 'gcp' else IdentityProvider.MICROSOFT",
            "    return json_response({'idp': idp.value, 'oauth2_client': request.app[AppKeys.HAILCTL_CLIENT_CONFIG]})",
            "",
            "",
            "@routes.get('/roles')",
            "@auth.authenticated_developers_only()",
            "async def get_roles(request: web.Request, userdata: UserData) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    roles = [x async for x in db.select_and_fetchall('SELECT * FROM roles;')]",
            "    page_context = {'roles': roles}",
            "    return await render_template('auth', request, userdata, 'roles.html', page_context)",
            "",
            "",
            "@routes.post('/roles')",
            "@auth.authenticated_developers_only()",
            "async def post_create_role(request: web.Request, _) -> NoReturn:",
            "    session = await aiohttp_session.get_session(request)",
            "    db = request.app[AppKeys.DB]",
            "    post = await request.post()",
            "    name = str(post['name'])",
            "",
            "    role_id = await db.execute_insertone(",
            "        '''",
            "INSERT INTO `roles` (`name`)",
            "VALUES (%s);",
            "''',",
            "        (name),",
            "    )",
            "",
            "    set_message(session, f'Created role {role_id} {name}.', 'info')",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', '/roles'))",
            "",
            "",
            "@routes.get('/users')",
            "@auth.authenticated_developers_only()",
            "async def get_users(request: web.Request, userdata: UserData) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    users = [x async for x in db.select_and_fetchall('SELECT * FROM users;')]",
            "    page_context = {'users': users}",
            "    return await render_template('auth', request, userdata, 'users.html', page_context)",
            "",
            "",
            "@routes.post('/users')",
            "@auth.authenticated_developers_only()",
            "async def post_create_user(request: web.Request, _) -> NoReturn:",
            "    session = await aiohttp_session.get_session(request)",
            "    db = request.app[AppKeys.DB]",
            "    post = await request.post()",
            "    username = str(post['username'])",
            "    login_id = str(post['login_id']) if 'login_id' in post else None",
            "    is_developer = post.get('is_developer') == '1'",
            "    is_service_account = post.get('is_service_account') == '1'",
            "",
            "    try:",
            "        created_user = await insert_new_user(db, username, login_id, is_developer, is_service_account)",
            "    except AuthUserError as e:",
            "        set_message(session, e.message, 'error')",
            "        raise web.HTTPFound(deploy_config.external_url('auth', '/users'))",
            "",
            "    if created_user:",
            "        set_message(session, f'Created user {username} {login_id}.', 'info')",
            "    else:",
            "        set_message(session, f'User {username} {login_id} already exists.', 'info')",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', '/users'))",
            "",
            "",
            "@routes.get('/api/v1alpha/users')",
            "@auth.authenticated_users_only()",
            "async def rest_get_users(request: web.Request, userdata: UserData) -> web.Response:",
            "    if userdata['is_developer'] != 1 and userdata['username'] != 'ci':",
            "        raise web.HTTPUnauthorized()",
            "",
            "    db = request.app[AppKeys.DB]",
            "    _query = '''",
            "SELECT id, username, login_id, state, is_developer, is_service_account, hail_identity",
            "FROM users;",
            "'''",
            "    users = [x async for x in db.select_and_fetchall(_query)]",
            "    return json_response(users)",
            "",
            "",
            "@routes.get('/api/v1alpha/users/{user}')",
            "@auth.authenticated_developers_only()",
            "async def rest_get_user(request: web.Request, _) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    username = request.match_info['user']",
            "",
            "    user = await db.select_and_fetchone(",
            "        '''",
            "SELECT id, username, login_id, state, is_developer, is_service_account, hail_identity FROM users",
            "WHERE username = %s;",
            "''',",
            "        (username,),",
            "    )",
            "    if user is None:",
            "        raise web.HTTPNotFound()",
            "    return json_response(user)",
            "",
            "",
            "async def _delete_user(db: Database, username: str, id: Optional[str]):",
            "    where_conditions = ['state != \"deleted\"', 'username = %s']",
            "    where_args = [username]",
            "",
            "    if id is not None:",
            "        where_conditions.append('id = %s')",
            "        where_args.append(id)",
            "",
            "    n_rows = await db.execute_update(",
            "        f'''",
            "UPDATE users",
            "SET state = 'deleting'",
            "WHERE {' AND '.join(where_conditions)};",
            "''',",
            "        where_args,",
            "    )",
            "",
            "    if n_rows == 0:",
            "        raise UnknownUser(username)",
            "",
            "",
            "@routes.post('/users/delete')",
            "@auth.authenticated_developers_only()",
            "async def delete_user(request: web.Request, _) -> NoReturn:",
            "    session = await aiohttp_session.get_session(request)",
            "    db = request.app[AppKeys.DB]",
            "    post = await request.post()",
            "    id = str(post['id'])",
            "    username = str(post['username'])",
            "",
            "    try:",
            "        await _delete_user(db, username, id)",
            "        set_message(session, f'Deleted user {id} {username}.', 'info')",
            "    except UnknownUser:",
            "        set_message(session, f'Delete failed, no such user {id} {username}.', 'error')",
            "",
            "    raise web.HTTPFound(deploy_config.external_url('auth', '/users'))",
            "",
            "",
            "@routes.delete('/api/v1alpha/users/{user}')",
            "@auth.authenticated_developers_only()",
            "async def rest_delete_user(request: web.Request, _) -> web.Response:",
            "    db = request.app[AppKeys.DB]",
            "    username = request.match_info['user']",
            "",
            "    try:",
            "        await _delete_user(db, username, None)",
            "    except UnknownUser as e:",
            "        raise e.http_response()",
            "",
            "    return web.json_response()",
            "",
            "",
            "@routes.get('/api/v1alpha/oauth2callback')",
            "async def rest_callback(request):",
            "    flow_json = request.query.get('flow')",
            "    if flow_json is None:",
            "        # backwards compatibility with older versions of hailctl",
            "        callback_port = request.query['callback_port']",
            "        flow_dict = {",
            "            'state': request.query['state'],",
            "            'callback_uri': f'http://127.0.0.1:{callback_port}/oauth2callback',",
            "        }",
            "    else:",
            "        flow_dict = json.loads(request.query['flow'])",
            "",
            "    try:",
            "        flow_result = request.app[AppKeys.FLOW_CLIENT].receive_callback(request, flow_dict)",
            "    except asyncio.CancelledError:",
            "        raise",
            "    except Exception as e:",
            "        log.exception('fetching and decoding token')",
            "        raise web.HTTPUnauthorized() from e",
            "",
            "    db = request.app[AppKeys.DB]",
            "    users = [",
            "        x",
            "        async for x in db.select_and_fetchall(",
            "            \"SELECT * FROM users WHERE login_id = %s AND state = 'active';\", flow_result.login_id",
            "        )",
            "    ]",
            "",
            "    if len(users) != 1:",
            "        raise web.HTTPUnauthorized()",
            "    user = users[0]",
            "",
            "    session_id = await create_session(db, user['id'], max_age_secs=None)",
            "",
            "    return json_response({'token': session_id, 'username': user['username']})",
            "",
            "",
            "@routes.post('/api/v1alpha/copy-paste-login')",
            "async def rest_copy_paste_login(request):",
            "    copy_paste_token = request.query['copy_paste_token']",
            "    db = request.app[AppKeys.DB]",
            "",
            "    @transaction(db)",
            "    async def maybe_pop_token(tx):",
            "        session = await tx.execute_and_fetchone(",
            "            \"\"\"",
            "SELECT sessions.session_id AS session_id, users.username AS username FROM copy_paste_tokens",
            "INNER JOIN sessions ON sessions.session_id = copy_paste_tokens.session_id",
            "INNER JOIN users ON users.id = sessions.user_id",
            "WHERE copy_paste_tokens.id = %s",
            "  AND NOW() < TIMESTAMPADD(SECOND, copy_paste_tokens.max_age_secs, copy_paste_tokens.created)",
            "  AND users.state = 'active';\"\"\",",
            "            copy_paste_token,",
            "        )",
            "        if session is None:",
            "            raise web.HTTPUnauthorized()",
            "        await tx.just_execute(\"DELETE FROM copy_paste_tokens WHERE id = %s;\", copy_paste_token)",
            "        return session",
            "",
            "    session = await maybe_pop_token()",
            "    return json_response({'token': session['session_id'], 'username': session['username']})",
            "",
            "",
            "@routes.post('/api/v1alpha/logout')",
            "@auth.authenticated_users_only()",
            "async def rest_logout(request: web.Request, _) -> web.Response:",
            "    session_id = await get_session_id(request)",
            "    db = request.app[AppKeys.DB]",
            "    await db.just_execute('DELETE FROM sessions WHERE session_id = %s;', session_id)",
            "",
            "    return web.Response(status=200)",
            "",
            "",
            "async def get_userinfo(request: web.Request, auth_token: str) -> UserData:",
            "    flow_client = request.app[AppKeys.FLOW_CLIENT]",
            "    client_session = request.app[AppKeys.CLIENT_SESSION]",
            "",
            "    userdata = await get_userinfo_from_hail_session_id(request, auth_token)",
            "    if userdata:",
            "        return userdata",
            "",
            "    hailctl_oauth_client = request.app[AppKeys.HAILCTL_CLIENT_CONFIG]",
            "    uid = await flow_client.get_identity_uid_from_access_token(",
            "        client_session, auth_token, oauth2_client=hailctl_oauth_client",
            "    )",
            "    if uid:",
            "        return await get_userinfo_from_login_id_or_hail_identity_id(request, uid)",
            "",
            "    raise web.HTTPUnauthorized()",
            "",
            "",
            "async def get_userinfo_from_login_id_or_hail_identity_id(",
            "    request: web.Request, login_id_or_hail_idenity_uid: str",
            ") -> UserData:",
            "    db = request.app[AppKeys.DB]",
            "",
            "    users = [",
            "        x",
            "        async for x in db.select_and_fetchall(",
            "            '''",
            "SELECT users.*",
            "FROM users",
            "WHERE (users.login_id = %s OR users.hail_identity_uid = %s) AND users.state = 'active'",
            "''',",
            "            (login_id_or_hail_idenity_uid, login_id_or_hail_idenity_uid),",
            "        )",
            "    ]",
            "",
            "    if len(users) != 1:",
            "        log.info('Unknown login id')",
            "        raise web.HTTPUnauthorized()",
            "    return typing.cast(UserData, users[0])",
            "",
            "",
            "async def get_userinfo_from_hail_session_id(request: web.Request, session_id: str) -> Optional[UserData]:",
            "    # b64 encoding of 32-byte session ID is 44 bytes",
            "    if len(session_id) != 44:",
            "        return None",
            "",
            "    db = request.app[AppKeys.DB]",
            "    users = [",
            "        x",
            "        async for x in db.select_and_fetchall(",
            "            '''",
            "SELECT users.*",
            "FROM users",
            "INNER JOIN sessions ON users.id = sessions.user_id",
            "WHERE users.state = 'active' AND sessions.session_id = %s AND (ISNULL(sessions.max_age_secs) OR (NOW() < TIMESTAMPADD(SECOND, sessions.max_age_secs, sessions.created)));",
            "''',",
            "            session_id,",
            "            'get_userinfo',",
            "        )",
            "    ]",
            "",
            "    if len(users) != 1:",
            "        return None",
            "    return typing.cast(UserData, users[0])",
            "",
            "",
            "@routes.get('/api/v1alpha/userinfo')",
            "@auth.authenticated_users_only()",
            "async def userinfo(_, userdata: UserData) -> web.Response:",
            "    return json_response(userdata)",
            "",
            "",
            "@routes.route('*', '/api/v1alpha/verify_dev_credentials', name='verify_dev')",
            "@auth.authenticated_users_only()",
            "async def verify_dev_credentials(_, userdata: UserData) -> web.Response:",
            "    if userdata['is_developer'] != 1:",
            "        raise web.HTTPUnauthorized()",
            "    return web.Response(status=200)",
            "",
            "",
            "@routes.route('*', '/api/v1alpha/verify_dev_or_sa_credentials', name='verify_dev_or_sa')",
            "@auth.authenticated_users_only()",
            "async def verify_dev_or_sa_credentials(_, userdata: UserData) -> web.Response:",
            "    if userdata['is_developer'] != 1 and userdata['is_service_account'] != 1:",
            "        raise web.HTTPUnauthorized()",
            "    return web.Response(status=200)",
            "",
            "",
            "class AppKeys:",
            "    DB = web.AppKey('db', Database)",
            "    CLIENT_SESSION = web.AppKey('client_session', httpx.ClientSession)",
            "    FLOW_CLIENT = web.AppKey('flow_client', Flow)",
            "    HAILCTL_CLIENT_CONFIG = web.AppKey('hailctl_client_config', dict)",
            "    K8S_CLIENT = web.AppKey('k8s_client', kubernetes_asyncio.client.CoreV1Api)",
            "    K8S_CACHE = web.AppKey('k8s_cache', K8sCache)",
            "",
            "",
            "async def on_startup(app):",
            "    db = Database()",
            "    await db.async_init(maxsize=50)",
            "    app[AppKeys.DB] = db",
            "    app[AppKeys.CLIENT_SESSION] = httpx.client_session()",
            "",
            "    credentials_file = '/auth-oauth2-client-secret/client_secret.json'",
            "    if CLOUD == 'gcp':",
            "        app[AppKeys.FLOW_CLIENT] = GoogleFlow(credentials_file)",
            "    else:",
            "        assert CLOUD == 'azure'",
            "        app[AppKeys.FLOW_CLIENT] = AzureFlow(credentials_file)",
            "",
            "    with open('/auth-oauth2-client-secret/hailctl_client_secret.json', 'r', encoding='utf-8') as f:",
            "        app[AppKeys.HAILCTL_CLIENT_CONFIG] = json.loads(f.read())",
            "",
            "    kubernetes_asyncio.config.load_incluster_config()",
            "    app[AppKeys.K8S_CLIENT] = kubernetes_asyncio.client.CoreV1Api()",
            "    app[AppKeys.K8S_CACHE] = K8sCache(app[AppKeys.K8S_CLIENT])",
            "",
            "",
            "async def on_cleanup(app):",
            "    async with AsyncExitStack() as cleanup:",
            "        cleanup.push_async_callback(app[AppKeys.K8S_CLIENT].api_client.rest_client.pool_manager.close)",
            "        cleanup.push_async_callback(app[AppKeys.DB].async_close)",
            "        cleanup.push_async_callback(app[AppKeys.CLIENT_SESSION].close)",
            "",
            "",
            "class AuthAccessLogger(AccessLogger):",
            "    def __init__(self, logger: logging.Logger, log_format: str):",
            "        super().__init__(logger, log_format)",
            "        self.exclude = [",
            "            (endpoint[0], re.compile(deploy_config.base_path('auth') + endpoint[1]))",
            "            for endpoint in [",
            "                ('GET', '/api/v1alpha/userinfo'),",
            "            ]",
            "        ]",
            "",
            "    def log(self, request, response, time):",
            "        for method, path_expr in self.exclude:",
            "            if path_expr.fullmatch(request.path) and method == request.method:",
            "                return",
            "",
            "        super().log(request, response, time)",
            "",
            "",
            "@web.middleware",
            "async def auth_check_csrf_token(request: web.Request, handler: AIOHTTPHandler):",
            "    # The below are used by gateway / Envoy reverse proxies for auth checks, but",
            "    # Envoy calls those auth endpoints with the same HTTP method as the original",
            "    # user's request. In the case where a user is trying to POST to a protected",
            "    # service, that will additionally trigger a CSRF check on the auth endpoint",
            "    # which cannot always be conducted if, for example, the backend service is",
            "    # Grafana which conducts its own CSRF mitigations separate from our own.",
            "    # These auth endpoints are not CSRF-vulnerable so we opt out of CSRF-token",
            "    # validation.",
            "    # See: https://github.com/envoyproxy/envoy/issues/5357",
            "    envoy_auth_endpoints = {request.app.router[name].canonical for name in ('verify_dev', 'verify_dev_or_sa')}",
            "    if request.path in envoy_auth_endpoints:",
            "        return await handler(request)",
            "",
            "    return await check_csrf_token(request, handler)",
            "",
            "",
            "def run():",
            "    install_profiler_if_requested('auth')",
            "",
            "    app = web.Application(middlewares=[auth_check_csrf_token, monitor_endpoints_middleware])",
            "",
            "    setup_aiohttp_jinja2(app, 'auth')",
            "    setup_aiohttp_session(app)",
            "",
            "    setup_common_static_routes(routes)",
            "    app.add_routes(routes)",
            "    app.router.add_get(\"/metrics\", server_stats)",
            "",
            "    app.on_startup.append(on_startup)",
            "    app.on_cleanup.append(on_cleanup)",
            "",
            "    web.run_app(",
            "        deploy_config.prefix_application(app, 'auth'),",
            "        host='0.0.0.0',",
            "        port=443,",
            "        access_log_class=AuthAccessLogger,",
            "        ssl_context=internal_server_ssl_context(),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "62": [
                "ORGANIZATION_DOMAIN"
            ],
            "336": [
                "flow_result"
            ],
            "355": [],
            "358": []
        },
        "addLocation": []
    },
    "hail/python/hailtop/auth/flow.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from cryptography.hazmat.primitives import serialization"
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import json"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import logging"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+import os"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import urllib.parse"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from typing import Any, Dict, List, Mapping, Optional, TypedDict, ClassVar"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " class FlowResult:"
            },
            "10": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, login_id: str, email: str, token: Mapping[Any, Any]):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    def __init__(self,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+                 login_id: str,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+                 unverified_email: str,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+                 organization_id: Optional[str],"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+                 token: Mapping[Any, Any]):"
            },
            "16": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         self.login_id = login_id"
            },
            "17": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.email = email"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        self.unverified_email = unverified_email"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        self.organization_id = organization_id  # In Azure, a Tenant ID. In Google, a domain name."
            },
            "20": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         self.token = token"
            },
            "21": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " class Flow(abc.ABC):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    @abc.abstractmethod"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    async def organization_id(self) -> str:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        \"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        The unique identifier of the organization (e.g. Azure Tenant, Google Organization) in"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        which this Hail Batch instance lives."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        \"\"\""
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        raise NotImplementedError"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     @abc.abstractmethod"
            },
            "33": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     def initiate_flow(self, redirect_uri: str) -> dict:"
            },
            "34": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         \"\"\""
            },
            "35": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         \"\"\""
            },
            "36": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 79,
                "PatchRowcode": "         raise NotImplementedError"
            },
            "37": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " class GoogleFlow(Flow):"
            },
            "40": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     scopes: ClassVar[List[str]] = ["
            },
            "41": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         'https://www.googleapis.com/auth/userinfo.profile',"
            },
            "42": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     def __init__(self, credentials_file: str):"
            },
            "43": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         self._credentials_file = credentials_file"
            },
            "44": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+    def organization_id(self) -> str:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+        if organization_id := os.environ.get('HAIL_ORGANIZATION_DOMAIN'):"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            return organization_id"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        raise ValueError('Only available in the auth pod')"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "     def initiate_flow(self, redirect_uri: str) -> dict:"
            },
            "51": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file("
            },
            "52": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "             self._credentials_file, scopes=GoogleFlow.scopes, state=None"
            },
            "53": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             flow.credentials.id_token, google.auth.transport.requests.Request()  # type: ignore"
            },
            "54": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         )"
            },
            "55": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "         email = token['email']"
            },
            "56": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return FlowResult(email, email, token)"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        return FlowResult(email, email, token.get('hd'), token)"
            },
            "58": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     @staticmethod"
            },
            "60": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "     def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:"
            },
            "61": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "             if not (is_human_with_hail_audience or is_service_account):"
            },
            "62": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "                 return None"
            },
            "63": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            email = userinfo['email']"
            },
            "65": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if email.endswith('iam.gserviceaccount.com'):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            domain = userinfo.get('hd')"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            if domain == 'iam.gserviceaccount.com':"
            },
            "68": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "                 return userinfo['sub']"
            },
            "69": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "             # We don't currently track user's unique GCP IAM ID (sub) in the database, just their email,"
            },
            "70": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "             # but we should eventually use the sub as that is guaranteed to be unique to the user."
            },
            "71": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return email"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            return userinfo['email']"
            },
            "73": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "         except httpx.ClientResponseError as e:"
            },
            "74": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "             if e.status in (400, 401):"
            },
            "75": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                 return None"
            },
            "76": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         self._client = msal.ConfidentialClientApplication(data['appId'], data['password'], authority)"
            },
            "77": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         self._tenant_id = tenant_id"
            },
            "78": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    def organization_id(self) -> str:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        return self._tenant_id"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "     def initiate_flow(self, redirect_uri: str) -> dict:"
            },
            "83": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        flow = self._client.initiate_auth_code_flow(scopes=[], redirect_uri=redirect_uri)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        flow = self._client.initiate_auth_code_flow("
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            scopes=[],  # confusingly, scopes=[] is the only way to get the openid, profile, and"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                        # offline_access scopes"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                        # https://github.com/AzureAD/microsoft-authentication-library-for-python/blob/dev/msal/application.py#L568-L580"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            redirect_uri=redirect_uri"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        )"
            },
            "90": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         return {"
            },
            "91": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "             'flow': flow,"
            },
            "92": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "             'authorization_url': flow['auth_uri'],"
            },
            "93": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "         if tid != self._tenant_id:"
            },
            "94": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "             raise ValueError('invalid tenant id')"
            },
            "95": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 212,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return FlowResult(token['id_token_claims']['oid'], token['id_token_claims']['preferred_username'], token)"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        return FlowResult("
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+            token['id_token_claims']['oid'],"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            token['id_token_claims']['preferred_username'],"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            token['id_token_claims']['tid'],"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            token"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+        )"
            },
            "103": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 219,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "     @staticmethod"
            },
            "105": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "     def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:"
            }
        },
        "frontPatchFile": [
            "import abc",
            "import base64",
            "from cryptography import x509",
            "from cryptography.hazmat.primitives import serialization",
            "import json",
            "import logging",
            "import urllib.parse",
            "from typing import Any, Dict, List, Mapping, Optional, TypedDict, ClassVar",
            "",
            "import aiohttp.web",
            "import google.auth.transport.requests",
            "import google.oauth2.id_token",
            "import google_auth_oauthlib.flow",
            "import jwt",
            "import msal",
            "",
            "from hailtop import httpx",
            "from hailtop.utils import retry_transient_errors",
            "",
            "log = logging.getLogger('auth')",
            "",
            "",
            "class FlowResult:",
            "    def __init__(self, login_id: str, email: str, token: Mapping[Any, Any]):",
            "        self.login_id = login_id",
            "        self.email = email",
            "        self.token = token",
            "",
            "",
            "class Flow(abc.ABC):",
            "    @abc.abstractmethod",
            "    def initiate_flow(self, redirect_uri: str) -> dict:",
            "        \"\"\"",
            "        Initiates the OAuth2 flow. Usually run in response to a user clicking a login button.",
            "        The returned dict should be stored in a secure session so that the server can",
            "        identify to which OAuth2 flow a client is responding. In particular, the server must",
            "        pass this dict to :meth:`.receive_callback` in the OAuth2 callback.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @abc.abstractmethod",
            "    def receive_callback(self, request: aiohttp.web.Request, flow_dict: dict) -> FlowResult:",
            "        \"\"\"Concludes the OAuth2 flow by returning the user's identity and credentials.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    @abc.abstractmethod",
            "    def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Performs an OAuth2 flow for credentials installed on the user's machine.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    @abc.abstractmethod",
            "    async def logout_installed_app(oauth2_credentials: Dict[str, Any]):",
            "        \"\"\"Revokes the OAuth2 credentials on the user's machine.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    @abc.abstractmethod",
            "    async def get_identity_uid_from_access_token(session: httpx.ClientSession, access_token: str, *, oauth2_client: dict) -> Optional[str]:",
            "        \"\"\"",
            "        Validate a user-provided access token. If the token is valid, return the identity",
            "        to which it belongs. If it is not valid, return None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "",
            "class GoogleFlow(Flow):",
            "    scopes: ClassVar[List[str]] = [",
            "        'https://www.googleapis.com/auth/userinfo.profile',",
            "        'https://www.googleapis.com/auth/userinfo.email',",
            "        'openid',",
            "    ]",
            "",
            "    def __init__(self, credentials_file: str):",
            "        self._credentials_file = credentials_file",
            "",
            "    def initiate_flow(self, redirect_uri: str) -> dict:",
            "        flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(",
            "            self._credentials_file, scopes=GoogleFlow.scopes, state=None",
            "        )",
            "        flow.redirect_uri = redirect_uri",
            "        authorization_url, state = flow.authorization_url(access_type='offline', include_granted_scopes='true')",
            "",
            "        return {",
            "            'authorization_url': authorization_url,",
            "            'redirect_uri': redirect_uri,",
            "            'state': state,",
            "        }",
            "",
            "    def receive_callback(self, request: aiohttp.web.Request, flow_dict: dict) -> FlowResult:",
            "        flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(",
            "            self._credentials_file, scopes=GoogleFlow.scopes, state=flow_dict['state']",
            "        )",
            "        flow.redirect_uri = flow_dict['callback_uri']",
            "        flow.fetch_token(code=request.query['code'])",
            "        token = google.oauth2.id_token.verify_oauth2_token(",
            "            flow.credentials.id_token, google.auth.transport.requests.Request()  # type: ignore",
            "        )",
            "        email = token['email']",
            "        return FlowResult(email, email, token)",
            "",
            "    @staticmethod",
            "    def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:",
            "        flow = google_auth_oauthlib.flow.InstalledAppFlow.from_client_config(oauth2_client, GoogleFlow.scopes)",
            "        credentials = flow.run_local_server()",
            "        return {",
            "            'client_id': credentials.client_id,",
            "            'client_secret': credentials.client_secret,",
            "            'refresh_token': credentials.refresh_token,",
            "            'type': 'authorized_user',",
            "        }",
            "",
            "    @staticmethod",
            "    async def logout_installed_app(oauth2_credentials: Dict[str, Any]):",
            "        async with httpx.client_session() as session:",
            "            await session.post(",
            "                'https://oauth2.googleapis.com/revoke',",
            "                params={'token': oauth2_credentials['refresh_token']},",
            "                headers={'content-type': 'application/x-www-form-urlencoded'}",
            "            )",
            "",
            "    @staticmethod",
            "    async def get_identity_uid_from_access_token(session: httpx.ClientSession, access_token: str, *, oauth2_client: dict) -> Optional[str]:",
            "        oauth2_client_audience = oauth2_client['installed']['client_id']",
            "        try:",
            "            userinfo = await retry_transient_errors(",
            "                session.get_read_json,",
            "                'https://www.googleapis.com/oauth2/v3/tokeninfo',",
            "                params={'access_token': access_token},",
            "            )",
            "            is_human_with_hail_audience = userinfo['aud'] == oauth2_client_audience",
            "            is_service_account = userinfo['aud'] == userinfo['sub']",
            "            if not (is_human_with_hail_audience or is_service_account):",
            "                return None",
            "",
            "            email = userinfo['email']",
            "            if email.endswith('iam.gserviceaccount.com'):",
            "                return userinfo['sub']",
            "            # We don't currently track user's unique GCP IAM ID (sub) in the database, just their email,",
            "            # but we should eventually use the sub as that is guaranteed to be unique to the user.",
            "            return email",
            "        except httpx.ClientResponseError as e:",
            "            if e.status in (400, 401):",
            "                return None",
            "            raise",
            "",
            "",
            "class AadJwk(TypedDict):",
            "    kid: str",
            "    x5c: List[str]",
            "",
            "",
            "class AzureFlow(Flow):",
            "    _aad_keys: Optional[List[AadJwk]] = None",
            "",
            "    def __init__(self, credentials_file: str):",
            "        with open(credentials_file, encoding='utf-8') as f:",
            "            data = json.loads(f.read())",
            "",
            "        tenant_id = data['tenant']",
            "        authority = f'https://login.microsoftonline.com/{tenant_id}'",
            "        self._client = msal.ConfidentialClientApplication(data['appId'], data['password'], authority)",
            "        self._tenant_id = tenant_id",
            "",
            "    def initiate_flow(self, redirect_uri: str) -> dict:",
            "        flow = self._client.initiate_auth_code_flow(scopes=[], redirect_uri=redirect_uri)",
            "        return {",
            "            'flow': flow,",
            "            'authorization_url': flow['auth_uri'],",
            "            'state': flow['state'],",
            "        }",
            "",
            "    def receive_callback(self, request: aiohttp.web.Request, flow_dict: dict) -> FlowResult:",
            "        query_key_to_list_of_values = urllib.parse.parse_qs(request.query_string)",
            "        query_dict = {k: v[0] for k, v in query_key_to_list_of_values.items()}",
            "",
            "        token = self._client.acquire_token_by_auth_code_flow(flow_dict['flow'], query_dict)",
            "",
            "        if 'error' in token:",
            "            raise ValueError(token)",
            "",
            "        tid = token['id_token_claims']['tid']",
            "        if tid != self._tenant_id:",
            "            raise ValueError('invalid tenant id')",
            "",
            "        return FlowResult(token['id_token_claims']['oid'], token['id_token_claims']['preferred_username'], token)",
            "",
            "    @staticmethod",
            "    def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:",
            "        tenant_id = oauth2_client['tenant']",
            "        authority = f'https://login.microsoftonline.com/{tenant_id}'",
            "        app = msal.PublicClientApplication(oauth2_client['appId'], authority=authority)",
            "        credentials = app.acquire_token_interactive([oauth2_client['userOauthScope']])",
            "        return {**oauth2_client, 'refreshToken': credentials['refresh_token']}",
            "",
            "    @staticmethod",
            "    async def logout_installed_app(_: Dict[str, Any]):",
            "        # AAD does not support revocation of a single refresh token,",
            "        # only all refresh tokens issued to all applications for a particular",
            "        # user, which we neither wish nor should have the permissions",
            "        # to perform.",
            "        # See: https://learn.microsoft.com/en-us/answers/questions/1158831/invalidate-old-refresh-token-after-using-it-to-get",
            "        pass",
            "",
            "    @staticmethod",
            "    async def get_identity_uid_from_access_token(session: httpx.ClientSession, access_token: str, *, oauth2_client: dict) -> Optional[str]:",
            "        audience = oauth2_client['appIdentifierUri']",
            "",
            "        try:",
            "            kid = jwt.get_unverified_header(access_token)['kid']",
            "",
            "            if AzureFlow._aad_keys is None:",
            "                resp = await session.get_read_json('https://login.microsoftonline.com/common/discovery/keys')",
            "                AzureFlow._aad_keys = resp['keys']",
            "",
            "            # This code is taken nearly verbatim from",
            "            # https://github.com/AzureAD/microsoft-authentication-library-for-python/issues/147",
            "            # At time of writing, the community response in that issue is the recommended way to validate",
            "            # AAD access tokens in python as it is not a part of the MSAL library.",
            "",
            "            jwk = next(key for key in AzureFlow._aad_keys if key['kid'] == kid)",
            "            der_cert = base64.b64decode(jwk['x5c'][0])",
            "            cert = x509.load_der_x509_certificate(der_cert)",
            "            pem_key = cert.public_key().public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo).decode()",
            "",
            "            decoded = jwt.decode(access_token, pem_key, algorithms=['RS256'], audience=audience)",
            "            return decoded['oid']",
            "        except jwt.InvalidTokenError:",
            "            return None"
        ],
        "afterPatchFile": [
            "import abc",
            "import base64",
            "from cryptography import x509",
            "from cryptography.hazmat.primitives import serialization",
            "import json",
            "import logging",
            "import os",
            "import urllib.parse",
            "from typing import Any, Dict, List, Mapping, Optional, TypedDict, ClassVar",
            "",
            "import aiohttp.web",
            "import google.auth.transport.requests",
            "import google.oauth2.id_token",
            "import google_auth_oauthlib.flow",
            "import jwt",
            "import msal",
            "",
            "from hailtop import httpx",
            "from hailtop.utils import retry_transient_errors",
            "",
            "log = logging.getLogger('auth')",
            "",
            "",
            "class FlowResult:",
            "    def __init__(self,",
            "                 login_id: str,",
            "                 unverified_email: str,",
            "                 organization_id: Optional[str],",
            "                 token: Mapping[Any, Any]):",
            "        self.login_id = login_id",
            "        self.unverified_email = unverified_email",
            "        self.organization_id = organization_id  # In Azure, a Tenant ID. In Google, a domain name.",
            "        self.token = token",
            "",
            "",
            "class Flow(abc.ABC):",
            "    @abc.abstractmethod",
            "    async def organization_id(self) -> str:",
            "        \"\"\"",
            "        The unique identifier of the organization (e.g. Azure Tenant, Google Organization) in",
            "        which this Hail Batch instance lives.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @abc.abstractmethod",
            "    def initiate_flow(self, redirect_uri: str) -> dict:",
            "        \"\"\"",
            "        Initiates the OAuth2 flow. Usually run in response to a user clicking a login button.",
            "        The returned dict should be stored in a secure session so that the server can",
            "        identify to which OAuth2 flow a client is responding. In particular, the server must",
            "        pass this dict to :meth:`.receive_callback` in the OAuth2 callback.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "    @abc.abstractmethod",
            "    def receive_callback(self, request: aiohttp.web.Request, flow_dict: dict) -> FlowResult:",
            "        \"\"\"Concludes the OAuth2 flow by returning the user's identity and credentials.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    @abc.abstractmethod",
            "    def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:",
            "        \"\"\"Performs an OAuth2 flow for credentials installed on the user's machine.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    @abc.abstractmethod",
            "    async def logout_installed_app(oauth2_credentials: Dict[str, Any]):",
            "        \"\"\"Revokes the OAuth2 credentials on the user's machine.\"\"\"",
            "        raise NotImplementedError",
            "",
            "    @staticmethod",
            "    @abc.abstractmethod",
            "    async def get_identity_uid_from_access_token(session: httpx.ClientSession, access_token: str, *, oauth2_client: dict) -> Optional[str]:",
            "        \"\"\"",
            "        Validate a user-provided access token. If the token is valid, return the identity",
            "        to which it belongs. If it is not valid, return None.",
            "        \"\"\"",
            "        raise NotImplementedError",
            "",
            "class GoogleFlow(Flow):",
            "    scopes: ClassVar[List[str]] = [",
            "        'https://www.googleapis.com/auth/userinfo.profile',",
            "        'https://www.googleapis.com/auth/userinfo.email',",
            "        'openid',",
            "    ]",
            "",
            "    def __init__(self, credentials_file: str):",
            "        self._credentials_file = credentials_file",
            "",
            "    def organization_id(self) -> str:",
            "        if organization_id := os.environ.get('HAIL_ORGANIZATION_DOMAIN'):",
            "            return organization_id",
            "        raise ValueError('Only available in the auth pod')",
            "",
            "    def initiate_flow(self, redirect_uri: str) -> dict:",
            "        flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(",
            "            self._credentials_file, scopes=GoogleFlow.scopes, state=None",
            "        )",
            "        flow.redirect_uri = redirect_uri",
            "        authorization_url, state = flow.authorization_url(access_type='offline', include_granted_scopes='true')",
            "",
            "        return {",
            "            'authorization_url': authorization_url,",
            "            'redirect_uri': redirect_uri,",
            "            'state': state,",
            "        }",
            "",
            "    def receive_callback(self, request: aiohttp.web.Request, flow_dict: dict) -> FlowResult:",
            "        flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(",
            "            self._credentials_file, scopes=GoogleFlow.scopes, state=flow_dict['state']",
            "        )",
            "        flow.redirect_uri = flow_dict['callback_uri']",
            "        flow.fetch_token(code=request.query['code'])",
            "        token = google.oauth2.id_token.verify_oauth2_token(",
            "            flow.credentials.id_token, google.auth.transport.requests.Request()  # type: ignore",
            "        )",
            "        email = token['email']",
            "        return FlowResult(email, email, token.get('hd'), token)",
            "",
            "    @staticmethod",
            "    def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:",
            "        flow = google_auth_oauthlib.flow.InstalledAppFlow.from_client_config(oauth2_client, GoogleFlow.scopes)",
            "        credentials = flow.run_local_server()",
            "        return {",
            "            'client_id': credentials.client_id,",
            "            'client_secret': credentials.client_secret,",
            "            'refresh_token': credentials.refresh_token,",
            "            'type': 'authorized_user',",
            "        }",
            "",
            "    @staticmethod",
            "    async def logout_installed_app(oauth2_credentials: Dict[str, Any]):",
            "        async with httpx.client_session() as session:",
            "            await session.post(",
            "                'https://oauth2.googleapis.com/revoke',",
            "                params={'token': oauth2_credentials['refresh_token']},",
            "                headers={'content-type': 'application/x-www-form-urlencoded'}",
            "            )",
            "",
            "    @staticmethod",
            "    async def get_identity_uid_from_access_token(session: httpx.ClientSession, access_token: str, *, oauth2_client: dict) -> Optional[str]:",
            "        oauth2_client_audience = oauth2_client['installed']['client_id']",
            "        try:",
            "            userinfo = await retry_transient_errors(",
            "                session.get_read_json,",
            "                'https://www.googleapis.com/oauth2/v3/tokeninfo',",
            "                params={'access_token': access_token},",
            "            )",
            "            is_human_with_hail_audience = userinfo['aud'] == oauth2_client_audience",
            "            is_service_account = userinfo['aud'] == userinfo['sub']",
            "            if not (is_human_with_hail_audience or is_service_account):",
            "                return None",
            "",
            "            domain = userinfo.get('hd')",
            "            if domain == 'iam.gserviceaccount.com':",
            "                return userinfo['sub']",
            "            # We don't currently track user's unique GCP IAM ID (sub) in the database, just their email,",
            "            # but we should eventually use the sub as that is guaranteed to be unique to the user.",
            "            return userinfo['email']",
            "        except httpx.ClientResponseError as e:",
            "            if e.status in (400, 401):",
            "                return None",
            "            raise",
            "",
            "",
            "class AadJwk(TypedDict):",
            "    kid: str",
            "    x5c: List[str]",
            "",
            "",
            "class AzureFlow(Flow):",
            "    _aad_keys: Optional[List[AadJwk]] = None",
            "",
            "    def __init__(self, credentials_file: str):",
            "        with open(credentials_file, encoding='utf-8') as f:",
            "            data = json.loads(f.read())",
            "",
            "        tenant_id = data['tenant']",
            "        authority = f'https://login.microsoftonline.com/{tenant_id}'",
            "        self._client = msal.ConfidentialClientApplication(data['appId'], data['password'], authority)",
            "        self._tenant_id = tenant_id",
            "",
            "    def organization_id(self) -> str:",
            "        return self._tenant_id",
            "",
            "    def initiate_flow(self, redirect_uri: str) -> dict:",
            "        flow = self._client.initiate_auth_code_flow(",
            "            scopes=[],  # confusingly, scopes=[] is the only way to get the openid, profile, and",
            "                        # offline_access scopes",
            "                        # https://github.com/AzureAD/microsoft-authentication-library-for-python/blob/dev/msal/application.py#L568-L580",
            "            redirect_uri=redirect_uri",
            "        )",
            "        return {",
            "            'flow': flow,",
            "            'authorization_url': flow['auth_uri'],",
            "            'state': flow['state'],",
            "        }",
            "",
            "    def receive_callback(self, request: aiohttp.web.Request, flow_dict: dict) -> FlowResult:",
            "        query_key_to_list_of_values = urllib.parse.parse_qs(request.query_string)",
            "        query_dict = {k: v[0] for k, v in query_key_to_list_of_values.items()}",
            "",
            "        token = self._client.acquire_token_by_auth_code_flow(flow_dict['flow'], query_dict)",
            "",
            "        if 'error' in token:",
            "            raise ValueError(token)",
            "",
            "        tid = token['id_token_claims']['tid']",
            "        if tid != self._tenant_id:",
            "            raise ValueError('invalid tenant id')",
            "",
            "        return FlowResult(",
            "            token['id_token_claims']['oid'],",
            "            token['id_token_claims']['preferred_username'],",
            "            token['id_token_claims']['tid'],",
            "            token",
            "        )",
            "",
            "    @staticmethod",
            "    def perform_installed_app_login_flow(oauth2_client: Dict[str, Any]) -> Dict[str, Any]:",
            "        tenant_id = oauth2_client['tenant']",
            "        authority = f'https://login.microsoftonline.com/{tenant_id}'",
            "        app = msal.PublicClientApplication(oauth2_client['appId'], authority=authority)",
            "        credentials = app.acquire_token_interactive([oauth2_client['userOauthScope']])",
            "        return {**oauth2_client, 'refreshToken': credentials['refresh_token']}",
            "",
            "    @staticmethod",
            "    async def logout_installed_app(_: Dict[str, Any]):",
            "        # AAD does not support revocation of a single refresh token,",
            "        # only all refresh tokens issued to all applications for a particular",
            "        # user, which we neither wish nor should have the permissions",
            "        # to perform.",
            "        # See: https://learn.microsoft.com/en-us/answers/questions/1158831/invalidate-old-refresh-token-after-using-it-to-get",
            "        pass",
            "",
            "    @staticmethod",
            "    async def get_identity_uid_from_access_token(session: httpx.ClientSession, access_token: str, *, oauth2_client: dict) -> Optional[str]:",
            "        audience = oauth2_client['appIdentifierUri']",
            "",
            "        try:",
            "            kid = jwt.get_unverified_header(access_token)['kid']",
            "",
            "            if AzureFlow._aad_keys is None:",
            "                resp = await session.get_read_json('https://login.microsoftonline.com/common/discovery/keys')",
            "                AzureFlow._aad_keys = resp['keys']",
            "",
            "            # This code is taken nearly verbatim from",
            "            # https://github.com/AzureAD/microsoft-authentication-library-for-python/issues/147",
            "            # At time of writing, the community response in that issue is the recommended way to validate",
            "            # AAD access tokens in python as it is not a part of the MSAL library.",
            "",
            "            jwk = next(key for key in AzureFlow._aad_keys if key['kid'] == kid)",
            "            der_cert = base64.b64decode(jwk['x5c'][0])",
            "            cert = x509.load_der_x509_certificate(der_cert)",
            "            pem_key = cert.public_key().public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo).decode()",
            "",
            "            decoded = jwt.decode(access_token, pem_key, algorithms=['RS256'], audience=audience)",
            "            return decoded['oid']",
            "        except jwt.InvalidTokenError:",
            "            return None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [
                "FlowResult",
                "__init__"
            ],
            "26": [
                "FlowResult",
                "__init__"
            ],
            "67": [],
            "101": [
                "GoogleFlow",
                "receive_callback"
            ],
            "137": [
                "GoogleFlow"
            ],
            "138": [
                "GoogleFlow"
            ],
            "142": [
                "GoogleFlow"
            ],
            "167": [
                "AzureFlow",
                "initiate_flow"
            ],
            "187": [
                "AzureFlow",
                "receive_callback"
            ]
        },
        "addLocation": []
    }
}