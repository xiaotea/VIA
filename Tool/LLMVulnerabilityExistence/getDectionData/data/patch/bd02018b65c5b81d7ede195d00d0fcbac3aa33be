{
    "ckan/logic/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from ckan.types import ("
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     Action, ChainedAction,"
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     ChainedAuthFunction, DataDict, ErrorDict, Context, FlattenDataDict,"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Schema, Validator, ValidatorFactory)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    FlattenKey, Schema, Validator, ValidatorFactory"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+)"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " Decorated = TypeVar(\"Decorated\")"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "                 except ValueError:"
            },
            "10": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "                     raise df.DataError('Bad key')"
            },
            "11": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         tuplized_dict[tuple(key_list)] = value"
            },
            "12": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return tuplized_dict"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+    # Sanitize key indexes to make sure they are sequential"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+    seq_tuplized_dict: FlattenDataDict = {}"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+    # sequential field indexes grouped by common prefix"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    groups: dict[FlattenKey, dict[FlattenKey, int]] = defaultdict(dict)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    for key in sorted(tuplized_dict.keys()):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        new_key = key"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+        # iterate over even(numeric) parts of the key"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+        for idx in range(1, len(key), 2):"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+            # narrow down scope by common prefix"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+            group = groups[key[:idx]]"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+            # if the identifier(i.e `(extra, 123)`, `(resource, 9)`) is met for"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+            # the first time, generate for it next number in the index"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+            # sequence. Index of the latest added item is always equals to the"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+            # number of unique identifiers minus one(because list indexation"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+            # starts from 0 in Python). If identifier already present(i.e, we"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+            # process `(extra, 10, VALUE)` after processing `(extra, 10,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+            # KEY)`), reuse sequential index of this identifier"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+            seq_index = group.setdefault(key[idx-1:idx+1], len(group))"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+            # replace the currently processed key segment with computed"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+            # sequential index"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+            new_key = new_key[:idx] + (seq_index,) + new_key[idx+1:]"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+        seq_tuplized_dict[new_key] = tuplized_dict[key]"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+    return seq_tuplized_dict"
            },
            "42": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 288,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 290,
                "PatchRowcode": " def untuplize_dict(tuplized_dict: FlattenDataDict) -> dict[str, Any]:"
            }
        },
        "frontPatchFile": [
            "# encoding: utf-8",
            "from __future__ import annotations",
            "from contextlib import contextmanager",
            "",
            "import functools",
            "import logging",
            "import re",
            "import importlib",
            "",
            "from collections import defaultdict",
            "from typing import (Any, Callable, Container, Iterable, Optional,",
            "                    TypeVar, Union, cast, overload)",
            "from typing_extensions import Literal",
            "",
            "from werkzeug.datastructures import MultiDict",
            "from sqlalchemy import exc",
            "",
            "import ckan.model as model",
            "import ckan.authz as authz",
            "import ckan.lib.navl.dictization_functions as df",
            "import ckan.plugins as p",
            "import ckan.lib.signals as signals",
            "",
            "from ckan.common import _, g",
            "from ckan.types import (",
            "    Action, ChainedAction,",
            "    ChainedAuthFunction, DataDict, ErrorDict, Context, FlattenDataDict,",
            "    Schema, Validator, ValidatorFactory)",
            "",
            "Decorated = TypeVar(\"Decorated\")",
            "",
            "log = logging.getLogger(__name__)",
            "_validate = df.validate",
            "",
            "_PG_ERR_CODE = {'unique_violation': '23505'}",
            "",
            "",
            "class NameConflict(Exception):",
            "    pass",
            "",
            "",
            "class UsernamePasswordError(Exception):",
            "    pass",
            "",
            "",
            "class ActionError(Exception):",
            "    message: Optional[str]",
            "",
            "    def __init__(self, message: Optional[str] = '') -> None:",
            "        self.message = message",
            "        super(ActionError, self).__init__(message)",
            "",
            "    def __str__(self):",
            "        msg = self.message",
            "        if not isinstance(msg, str):",
            "            msg = str(msg)",
            "        return msg",
            "",
            "",
            "class NotFound(ActionError):",
            "    '''Exception raised by logic functions when a given object is not found.",
            "",
            "    For example :py:func:`~ckan.logic.action.get.package_show` raises",
            "    :py:exc:`~ckan.plugins.toolkit.ObjectNotFound` if no package with the",
            "    given ``id`` exists.",
            "",
            "    '''",
            "    pass",
            "",
            "",
            "class NotAuthorized(ActionError):",
            "    '''Exception raised when the user is not authorized to call the action.",
            "",
            "    For example :py:func:`~ckan.logic.action.create.package_create` raises",
            "    :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not authorized",
            "    to create packages.",
            "    '''",
            "    pass",
            "",
            "",
            "class ValidationError(ActionError):",
            "    '''Exception raised by action functions when validating their given",
            "    ``data_dict`` fails.",
            "",
            "    '''",
            "    error_dict: ErrorDict",
            "",
            "    def __init__(self,",
            "                 errors: Union[str, ErrorDict],",
            "                 error_summary: Optional[dict[str, str]] = None,",
            "                 extra_msg: Optional[str] = None) -> None:",
            "        if not isinstance(errors, dict):",
            "            error_dict: ErrorDict = {'message': errors}",
            "        else:",
            "            error_dict = errors",
            "        # tags errors are a mess so let's clean them up",
            "        if 'tags' in error_dict:",
            "            tag_errors: list[Union[str, dict[str, Any]]] = []",
            "            for error in cast(\"list[dict[str, Any]]\", error_dict['tags']):",
            "                try:",
            "                    tag_errors.append(', '.join(error['name']))",
            "                except KeyError:",
            "                    # e.g. if it is a vocabulary_id error",
            "                    if error:",
            "                        tag_errors.append(error)",
            "            error_dict['tags'] = tag_errors",
            "        self.error_dict = error_dict",
            "        self._error_summary = error_summary",
            "        super(ValidationError, self).__init__(extra_msg)",
            "",
            "    @property",
            "    def error_summary(self) -> dict[str, str]:",
            "        ''' autogenerate the summary if not supplied '''",
            "        def summarise(error_dict: ErrorDict) -> dict[str, str]:",
            "            ''' Do some i18n stuff on the error_dict keys '''",
            "",
            "            def prettify(field_name: str):",
            "                field_name = re.sub(r'(?<!\\w)[Uu]rl(?!\\w)', 'URL',",
            "                                    field_name.replace('_', ' ').capitalize())",
            "                return _(field_name.replace('_', ' '))",
            "",
            "            summary = {}",
            "",
            "            for key, error in error_dict.items():",
            "                if key == 'resources':",
            "                    summary[_('Resources')] = _('Package resource(s) invalid')",
            "                elif key == 'extras':",
            "                    errors_extras = []",
            "                    for item in cast(\"list[dict[str, Any]]\", error):",
            "                        if (item.get('key') and",
            "                                item['key'][0] not in errors_extras):",
            "                            errors_extras.append(item['key'][0])",
            "                    summary[_('Extras')] = ', '.join(errors_extras)",
            "                elif key == 'extras_validation':",
            "                    assert isinstance(error, list)",
            "                    summary[_('Extras')] = error[0]",
            "                elif key == 'tags':",
            "                    assert isinstance(error, list)",
            "                    summary[_('Tags')] = error[0]",
            "                else:",
            "                    assert isinstance(error, list)",
            "                    summary[_(prettify(key))] = error[0]",
            "            return summary",
            "",
            "        if self._error_summary:",
            "            return self._error_summary",
            "        return summarise(self.error_dict)",
            "",
            "    def __str__(self):",
            "        err_msgs = (super(ValidationError, self).__str__(),",
            "                    self.error_dict)",
            "        return ' - '.join([str(err_msg) for err_msg in err_msgs if err_msg])",
            "",
            "",
            "def checks_and_delete_if_csrf_token_in_forms(parsed: dict[str, Any]):",
            "    '''",
            "    Checks and delete, if the csrf_token is in \"parsed\".",
            "    We don't want the csrf_token to be a part of a data_dict",
            "    as it will expose the token to the metadata.",
            "    This way we are deleting the token from every data_dict that fills",
            "    from request.form instead of deleting it separately in every",
            "    view/blueprint.",
            "    '''",
            "    from ckan.common import config",
            "",
            "    # WTF_CSRF_FIELD_NAME is added by flask_wtf",
            "    csrf_token = config.get(\"WTF_CSRF_FIELD_NAME\")",
            "    if csrf_token in parsed:",
            "        parsed.pop(csrf_token)",
            "    return parsed",
            "",
            "",
            "def parse_params(",
            "    params: 'MultiDict[str, Any]',",
            "    ignore_keys: Optional['Container[str]'] = None",
            ") -> dict[str, Union[str, list[str]]]:",
            "    '''Takes a dict and returns it with some values standardised.",
            "    This is done on a dict before calling tuplize_dict on it.",
            "    '''",
            "    parsed = {}",
            "    for key in params:",
            "        if ignore_keys and key in ignore_keys:",
            "            continue",
            "        # flask request has `getlist` instead of pylons' `getall`",
            "",
            "        if hasattr(params, 'getall'):",
            "            # type_ignore_reason: pylons legacy",
            "            value = params.getall(key)  # type: ignore",
            "        else:",
            "            value = params.getlist(key)",
            "",
            "        # Blank values become ''",
            "        if not value:",
            "            value = ''",
            "        # A list with only one item is stripped of being a list",
            "        if len(value) == 1:",
            "            value = value[0]",
            "        parsed[key] = value",
            "",
            "    parsed = checks_and_delete_if_csrf_token_in_forms(parsed)",
            "    return parsed",
            "",
            "",
            "def clean_dict(data_dict: dict[str, Any]) -> dict[str, Any]:",
            "    '''Takes a dict and if any of the values are lists of dicts,",
            "    the empty dicts are stripped from the lists (recursive).",
            "",
            "    e.g.",
            "    >>> clean_dict(",
            "        {'name': u'testgrp4',",
            "         'title': u'',",
            "         'description': u'',",
            "         'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],",
            "         'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'},",
            "                    {'key': u'', 'value': u''},",
            "                    {'key': u'', 'value': u''}],",
            "         'state': u'active'}",
            "    {'name': u'testgrp4',",
            "     'title': u'',",
            "     'description': u'',",
            "     'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],",
            "     'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'}],",
            "     'state': u'active'}",
            "",
            "    '''",
            "    for value in data_dict.values():",
            "        if not isinstance(value, list):",
            "            continue",
            "        for inner_dict in value[:]:",
            "            if isinstance(inner_dict, str):",
            "                break",
            "            if not any(inner_dict.values()):",
            "                value.remove(inner_dict)",
            "            else:",
            "                clean_dict(inner_dict)",
            "    return data_dict",
            "",
            "",
            "def tuplize_dict(data_dict: dict[str, Any]) -> FlattenDataDict:",
            "    '''Takes a dict with keys of the form 'table__0__key' and converts them",
            "    to a tuple like ('table', 0, 'key').",
            "",
            "    Dict should be put through parse_dict before this function, to have",
            "    values standardized.",
            "",
            "    May raise a DataError if the format of the key is incorrect.",
            "    '''",
            "    tuplized_dict: FlattenDataDict = {}",
            "    for k, value in data_dict.items():",
            "        key_list = cast(\"list[Union[str, int]]\", k.split('__'))",
            "        for num, key in enumerate(key_list):",
            "            if num % 2 == 1:",
            "                try:",
            "                    key_list[num] = int(key)",
            "                except ValueError:",
            "                    raise df.DataError('Bad key')",
            "        tuplized_dict[tuple(key_list)] = value",
            "    return tuplized_dict",
            "",
            "",
            "def untuplize_dict(tuplized_dict: FlattenDataDict) -> dict[str, Any]:",
            "",
            "    data_dict = {}",
            "    for key, value in tuplized_dict.items():",
            "        new_key = '__'.join([str(item) for item in key])",
            "        data_dict[new_key] = value",
            "    return data_dict",
            "",
            "",
            "def flatten_to_string_key(dict: dict[str, Any]) -> dict[str, Any]:",
            "",
            "    flattented = df.flatten_dict(dict)",
            "    return untuplize_dict(flattented)",
            "",
            "",
            "def _prepopulate_context(context: Optional[Context]) -> Context:",
            "    if context is None:",
            "        context = {}",
            "    context.setdefault('model', model)",
            "    context.setdefault('session', model.Session)",
            "",
            "    try:",
            "        user = g.user",
            "    except AttributeError:",
            "        # g.user not set",
            "        user = \"\"",
            "    except RuntimeError:",
            "        # Outside of request context",
            "        user = \"\"",
            "    except TypeError:",
            "        # g not registered",
            "        user = \"\"",
            "",
            "    context.setdefault('user', user)",
            "    return context",
            "",
            "",
            "def check_access(action: str,",
            "                 context: Context,",
            "                 data_dict: Optional[dict[str, Any]] = None) -> Literal[True]:",
            "    '''Calls the authorization function for the provided action",
            "",
            "    This is the only function that should be called to determine whether a",
            "    user (or an anonymous request) is allowed to perform a particular action.",
            "",
            "    The function accepts a context object, which should contain a 'user' key",
            "    with the name of the user performing the action, and optionally a",
            "    dictionary with extra data to be passed to the authorization function.",
            "",
            "    For example::",
            "",
            "        check_access('package_update', context, data_dict)",
            "",
            "    If not already there, the function will add an `auth_user_obj` key to the",
            "    context object with the actual User object (in case it exists in the",
            "    database). This check is only performed once per context object.",
            "",
            "    Raise :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not",
            "    authorized to call the named action function.",
            "",
            "    If the user *is* authorized to call the action, return ``True``.",
            "",
            "    :param action: the name of the action function, eg. ``'package_create'``",
            "    :type action: string",
            "",
            "    :param context:",
            "    :type context: dict",
            "",
            "    :param data_dict:",
            "    :type data_dict: dict",
            "",
            "    :raises: :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not",
            "        authorized to call the named action",
            "",
            "    '''",
            "",
            "    # Auth Auditing.  We remove this call from the __auth_audit stack to show",
            "    # we have called the auth function",
            "    try:",
            "        audit: Optional[tuple[str, int]] = context.get('__auth_audit', [])[-1]",
            "    except IndexError:",
            "        audit = None",
            "    if audit and audit[0] == action:",
            "        context['__auth_audit'].pop()",
            "",
            "    if 'auth_user_obj' not in context:",
            "        context['auth_user_obj'] = None",
            "",
            "    context = _prepopulate_context(context)",
            "",
            "    if not context.get('__auth_user_obj_checked'):",
            "        if context[\"user\"] and not context[\"auth_user_obj\"]:",
            "            context['auth_user_obj'] = model.User.get(context['user'])",
            "        context['__auth_user_obj_checked'] = True",
            "",
            "    try:",
            "        logic_authorization = authz.is_authorized(action, context, data_dict)",
            "        if not logic_authorization['success']:",
            "            msg = cast(str, logic_authorization.get('msg', ''))",
            "            raise NotAuthorized(msg)",
            "    except NotAuthorized as e:",
            "        log.debug(u'check access NotAuthorized - %s user=%s \"%s\"',",
            "                  action, context[\"user\"], str(e))",
            "        raise",
            "",
            "    log.debug('check access OK - %s user=%s', action, context[\"user\"])",
            "    return True",
            "",
            "",
            "_actions: dict[str, Action] = {}",
            "",
            "",
            "def clear_actions_cache() -> None:",
            "    _actions.clear()",
            "",
            "",
            "def chained_action(func: ChainedAction) -> ChainedAction:",
            "    '''Decorator function allowing action function to be chained.",
            "",
            "    This allows a plugin to modify the behaviour of an existing action",
            "    function. A Chained action function must be defined as",
            "    ``action_function(original_action, context, data_dict)`` where the",
            "    first parameter will be set to the action function in the next plugin",
            "    or in core ckan. The chained action may call the original_action",
            "    function, optionally passing different values, handling exceptions,",
            "    returning different values and/or raising different exceptions",
            "    to the caller.",
            "",
            "    Usage::",
            "",
            "        from ckan.plugins.toolkit import chained_action",
            "",
            "        @chained_action",
            "        @side_effect_free",
            "        def package_search(original_action, context, data_dict):",
            "            return original_action(context, data_dict)",
            "",
            "    :param func: chained action function",
            "    :type func: callable",
            "",
            "    :returns: chained action function",
            "    :rtype: callable",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    func.chained_action = True  # type: ignore",
            "",
            "    return func",
            "",
            "",
            "def _is_chained_action(func: Action) -> bool:",
            "    return getattr(func, 'chained_action', False)",
            "",
            "",
            "def get_action(action: str) -> Action:",
            "    '''Return the named :py:mod:`ckan.logic.action` function.",
            "",
            "    For example ``get_action('package_create')`` will normally return the",
            "    :py:func:`ckan.logic.action.create.package_create()` function.",
            "",
            "    For documentation of the available action functions, see",
            "    :ref:`api-reference`.",
            "",
            "    You should always use ``get_action()`` instead of importing an action",
            "    function directly, because :py:class:`~ckan.plugins.interfaces.IActions`",
            "    plugins can override action functions, causing ``get_action()`` to return a",
            "    plugin-provided function instead of the default one.",
            "",
            "    Usage::",
            "",
            "        import ckan.plugins.toolkit as toolkit",
            "",
            "        # Call the package_create action function:",
            "        toolkit.get_action('package_create')(context, data_dict)",
            "",
            "    As the context parameter passed to an action function is commonly::",
            "",
            "        context = {'model': ckan.model, 'session': ckan.model.Session,",
            "                   'user': user}",
            "",
            "    an action function returned by ``get_action()`` will automatically add",
            "    these parameters to the context if they are not defined.  This is",
            "    especially useful for plugins as they should not really be importing parts",
            "    of ckan eg :py:mod:`ckan.model` and as such do not have access to ``model``",
            "    or ``model.Session``.",
            "",
            "    If a ``context`` of ``None`` is passed to the action function then the",
            "    default context dict will be created.",
            "",
            "    .. note::",
            "",
            "        Many action functions modify the context dict. It can therefore",
            "        not be reused for multiple calls of the same or different action",
            "        functions.",
            "",
            "    :param action: name of the action function to return,",
            "        eg. ``'package_create'``",
            "    :type action: string",
            "",
            "    :returns: the named action function",
            "    :rtype: callable",
            "",
            "    '''",
            "",
            "    if _actions:",
            "        if action not in _actions:",
            "            raise KeyError(\"Action '%s' not found\" % action)",
            "        return _actions[action]",
            "    # Otherwise look in all the plugins to resolve all possible First",
            "    # get the default ones in the ckan/logic/action directory Rather",
            "    # than writing them out in full will use importlib.import_module",
            "    # to load anything from ckan.logic.action that looks like it might",
            "    # be an action",
            "    for action_module_name in ['get', 'create', 'update', 'delete', 'patch']:",
            "        module = importlib.import_module(",
            "            '.' + action_module_name, 'ckan.logic.action')",
            "        for k, v in authz.get_local_functions(module):",
            "            _actions[k] = v",
            "            # Allow all actions defined in logic/action/get.py to",
            "            # be side-effect free.",
            "            if action_module_name == 'get' and \\",
            "               not hasattr(v, 'side_effect_free'):",
            "                v.side_effect_free = True",
            "",
            "    # Then overwrite them with any specific ones in the plugins:",
            "    resolved_action_plugins: dict[str, str] = {}",
            "    fetched_actions = {}",
            "    chained_actions = defaultdict(list)",
            "    for plugin in p.PluginImplementations(p.IActions):",
            "        for name, action_function in plugin.get_actions().items():",
            "            if _is_chained_action(action_function):",
            "                chained_actions[name].append(action_function)",
            "            elif name in resolved_action_plugins:",
            "                raise NameConflict(",
            "                    'The action %r is already implemented in %r' % (",
            "                        name,",
            "                        resolved_action_plugins[name]",
            "                    )",
            "                )",
            "            else:",
            "                resolved_action_plugins[name] = plugin.name",
            "                # Extensions are exempted from the auth audit for now",
            "                # This needs to be resolved later",
            "                # type_ignore_reason: custom attribute",
            "                action_function.auth_audit_exempt = True  # type: ignore",
            "                fetched_actions[name] = action_function",
            "    for name, func_list in chained_actions.items():",
            "        if name not in fetched_actions and name not in _actions:",
            "            # nothing to override from plugins or core",
            "            raise NotFound('The action %r is not found for chained action' % (",
            "                name))",
            "        for func in reversed(func_list):",
            "            # try other plugins first, fall back to core",
            "            prev_func = fetched_actions.get(name, _actions.get(name))",
            "            new_func = functools.partial(func, prev_func)",
            "            # persisting attributes to the new partial function",
            "            for attribute, value in func.__dict__.items():",
            "                setattr(new_func, attribute, value)",
            "            fetched_actions[name] = new_func",
            "",
            "    # Use the updated ones in preference to the originals.",
            "    _actions.update(fetched_actions)",
            "",
            "    # wrap the functions",
            "    for action_name, _action in _actions.items():",
            "        def make_wrapped(_action: Action, action_name: str):",
            "            def wrapped(context: Optional[Context] = None,",
            "                        data_dict: Optional[DataDict] = None, **kw: Any):",
            "                if kw:",
            "                    log.critical('%s was passed extra keywords %r'",
            "                                 % (_action.__name__, kw))",
            "",
            "                context = _prepopulate_context(context)",
            "",
            "                if data_dict is None:",
            "                    data_dict = {}",
            "",
            "                # Auth Auditing - checks that the action function did call",
            "                # check_access (unless there is no accompanying auth function).",
            "                # We push the action name and id onto the __auth_audit stack",
            "                # before calling the action, and check_access removes it.",
            "                # (We need the id of the action in case the action is wrapped",
            "                # inside an action of the same name, which happens in the",
            "                # datastore)",
            "                context.setdefault('__auth_audit', [])",
            "                context['__auth_audit'].append((action_name, id(_action)))",
            "",
            "                # check_access(action_name, context, data_dict=None)",
            "                result = _action(context, data_dict, **kw)",
            "                try:",
            "                    audit = context['__auth_audit'][-1]",
            "                    if audit[0] == action_name and audit[1] == id(_action):",
            "                        if action_name not in authz.auth_functions_list():",
            "                            log.debug('No auth function for %s' % action_name)",
            "                        elif not getattr(_action, 'auth_audit_exempt', False):",
            "                            raise Exception(",
            "                                'Action function {0} did not call its '",
            "                                'auth function'",
            "                                .format(action_name))",
            "                        # remove from audit stack",
            "                        context['__auth_audit'].pop()",
            "                except IndexError:",
            "                    pass",
            "",
            "                signals.action_succeeded.send(",
            "                    action_name, context=context, data_dict=data_dict,",
            "                    result=result)",
            "                return result",
            "            return wrapped",
            "",
            "        fn = make_wrapped(_action, action_name)",
            "        # we need to mirror the docstring",
            "        fn.__doc__ = _action.__doc__",
            "        # we need to retain the side effect free behaviour",
            "        if getattr(_action, 'side_effect_free', False):",
            "            # type_ignore_reason: custom attribute",
            "            fn.side_effect_free = True  # type: ignore",
            "        _actions[action_name] = fn",
            "",
            "    return _actions[action]",
            "",
            "",
            "@overload",
            "def get_or_bust(data_dict: dict[str, Any], keys: str) -> Any:",
            "    ...",
            "",
            "",
            "@overload",
            "def get_or_bust(",
            "        data_dict: dict[str, Any], keys: Iterable[str]) -> tuple[Any, ...]:",
            "    ...",
            "",
            "",
            "def get_or_bust(",
            "        data_dict: dict[str, Any],",
            "        keys: Union[str, Iterable[str]]) -> Union[Any, tuple[Any, ...]]:",
            "    '''Return the value(s) from the given data_dict for the given key(s).",
            "",
            "    Usage::",
            "",
            "        single_value = get_or_bust(data_dict, 'a_key')",
            "        value_1, value_2 = get_or_bust(data_dict, ['key1', 'key2'])",
            "",
            "    :param data_dict: the dictionary to return the values from",
            "    :type data_dict: dictionary",
            "",
            "    :param keys: the key(s) for the value(s) to return",
            "    :type keys: either a string or a list",
            "",
            "    :returns: a single value from the dict if a single key was given,",
            "        or a tuple of values if a list of keys was given",
            "",
            "    :raises: :py:exc:`ckan.logic.ValidationError` if one of the given keys is",
            "        not in the given dictionary",
            "",
            "    '''",
            "    if isinstance(keys, str):",
            "        keys = [keys]",
            "",
            "    from ckan.logic.schema import create_schema_for_required_keys",
            "    schema = create_schema_for_required_keys(keys)",
            "",
            "    data_dict, errors = _validate(data_dict, schema)",
            "",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    # preserve original key order",
            "    values = [data_dict[key] for key in keys]",
            "    if len(values) == 1:",
            "        return values[0]",
            "    return tuple(values)",
            "",
            "",
            "def validate(schema_func: Callable[[], Schema],",
            "             can_skip_validator: bool = False) -> Callable[[Action], Action]:",
            "    ''' A decorator that validates an action function against a given schema",
            "    '''",
            "    def action_decorator(action: Action) -> Action:",
            "        @functools.wraps(action)",
            "        def wrapper(context: Context, data_dict: DataDict):",
            "            if can_skip_validator:",
            "                if context.get('skip_validation'):",
            "                    return action(context, data_dict)",
            "",
            "            schema = context.get('schema', schema_func())",
            "            data_dict, errors = _validate(data_dict, schema, context)",
            "            if errors:",
            "                raise ValidationError(errors)",
            "            return action(context, data_dict)",
            "        return wrapper",
            "    return action_decorator",
            "",
            "",
            "def side_effect_free(action: Decorated) -> Decorated:",
            "    '''A decorator that marks the given action function as side-effect-free.",
            "",
            "    Action functions decorated with this decorator can be called with an HTTP",
            "    GET request to the :doc:`Action API </api/index>`. Action functions that",
            "    don't have this decorator must be called with a POST request.",
            "",
            "    If your CKAN extension defines its own action functions using the",
            "    :py:class:`~ckan.plugins.interfaces.IActions` plugin interface, you can use",
            "    this decorator to make your actions available with GET requests instead of",
            "    just with POST requests.",
            "",
            "    Example::",
            "",
            "        import ckan.plugins.toolkit as toolkit",
            "",
            "        @toolkit.side_effect_free",
            "        def my_custom_action_function(context, data_dict):",
            "            ...",
            "",
            "    (Then implement :py:class:`~ckan.plugins.interfaces.IActions` to register",
            "    your action function with CKAN.)",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.side_effect_free = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_sysadmins_check(action: Decorated) -> Decorated:",
            "    '''A decorator that prevents sysadmins from being automatically authorized",
            "    to call an action function.",
            "",
            "    Normally sysadmins are allowed to call any action function (for example",
            "    when they're using the :doc:`Action API </api/index>` or the web",
            "    interface), if the user is a sysadmin the action function's authorization",
            "    function will not even be called.",
            "",
            "    If an action function is decorated with this decorator, then its",
            "    authorization function will always be called, even if the user is a",
            "    sysadmin.",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_sysadmins_check = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_audit_exempt(action: Decorated) -> Decorated:",
            "    ''' Dirty hack to stop auth audit being done '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_audit_exempt = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_allow_anonymous_access(action: Decorated) -> Decorated:",
            "    ''' Flag an auth function as not requiring a logged in user",
            "",
            "    This means that check_access won't automatically raise a NotAuthorized",
            "    exception if an authenticated user is not provided in the context. (The",
            "    auth function can still return False if for some reason access is not",
            "    granted).",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_allow_anonymous_access = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_disallow_anonymous_access(action: Decorated) -> Decorated:",
            "    ''' Flag an auth function as requiring a logged in user",
            "",
            "    This means that check_access will automatically raise a NotAuthorized",
            "    exception if an authenticated user is not provided in the context, without",
            "    calling the actual auth function.",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_allow_anonymous_access = False  # type: ignore",
            "    return action",
            "",
            "",
            "def chained_auth_function(func: ChainedAuthFunction) -> ChainedAuthFunction:",
            "    '''",
            "    Decorator function allowing authentication functions to be chained.",
            "",
            "    This chain starts with the last chained auth function to be registered and",
            "    ends with the original auth function (or a non-chained plugin override",
            "    version). Chained auth functions must accept an extra parameter,",
            "    specifically the next auth function in the chain, for example::",
            "",
            "        auth_function(next_auth, context, data_dict).",
            "",
            "    The chained auth function may call the next_auth function, optionally",
            "    passing different values, handling exceptions, returning different",
            "    values and/or raising different exceptions to the caller.",
            "",
            "    Usage::",
            "",
            "        from ckan.plugins.toolkit import chained_auth_function",
            "",
            "        @chained_auth_function",
            "        @auth_allow_anonymous_access",
            "        def user_show(next_auth, context, data_dict=None):",
            "            return next_auth(context, data_dict)",
            "",
            "    :param func: chained authentication function",
            "    :type func: callable",
            "",
            "    :returns: chained authentication function",
            "    :rtype: callable",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    func.chained_auth_function = True  # type: ignore",
            "    return func",
            "",
            "",
            "class UnknownValidator(Exception):",
            "    '''Exception raised when a requested validator function cannot be found.",
            "",
            "    '''",
            "    pass",
            "",
            "",
            "_validators_cache: dict[str, Union[Validator, ValidatorFactory]] = {}",
            "",
            "",
            "def clear_validators_cache() -> None:",
            "    _validators_cache.clear()",
            "",
            "",
            "# This function exists mainly so that validators can be made available to",
            "# extensions via ckan.plugins.toolkit.",
            "def get_validator(",
            "        validator: str) -> Union[Validator, ValidatorFactory]:",
            "    '''Return a validator function by name.",
            "",
            "    :param validator: the name of the validator function to return,",
            "        eg. ``'package_name_exists'``",
            "    :type validator: string",
            "",
            "    :raises: :py:exc:`~ckan.plugins.toolkit.UnknownValidator` if the named",
            "        validator is not found",
            "",
            "    :returns: the named validator function",
            "    :rtype: ``types.FunctionType``",
            "",
            "    '''",
            "    if not _validators_cache:",
            "        validators = _import_module_functions('ckan.lib.navl.validators')",
            "        _validators_cache.update(validators)",
            "        validators = _import_module_functions('ckan.logic.validators')",
            "        _validators_cache.update(validators)",
            "        converters = _import_module_functions('ckan.logic.converters')",
            "        _validators_cache.update(converters)",
            "        _validators_cache.update({'OneOf': _validators_cache['one_of']})",
            "",
            "        for plugin in p.PluginImplementations(p.IValidators):",
            "            for name, fn in plugin.get_validators().items():",
            "                log.debug('Validator function {0} from plugin {1} was inserted'",
            "                          .format(name, plugin.name))",
            "                _validators_cache[name] = fn",
            "    try:",
            "        return _validators_cache[validator]",
            "    except KeyError:",
            "        raise UnknownValidator('Validator `%s` does not exist' % validator)",
            "",
            "",
            "def model_name_to_class(model_module: Any, model_name: str) -> Any:",
            "    '''Return the class in model_module that has the same name as the",
            "    received string.",
            "",
            "    Raises AttributeError if there's no model in model_module named model_name.",
            "    '''",
            "    model_class_name = model_name.title()",
            "    try:",
            "        return getattr(model_module, model_class_name)",
            "    except AttributeError:",
            "        raise ValidationError({",
            "            \"message\": \"%s isn't a valid model\" % model_class_name})",
            "",
            "",
            "def _import_module_functions(",
            "        module_path: str) -> dict[str, Callable[..., Any]]:",
            "    '''Import a module and get the functions and return them in a dict'''",
            "    module = importlib.import_module(module_path)",
            "    return {",
            "        k: v",
            "        for k, v in authz.get_local_functions(module)",
            "    }",
            "",
            "",
            "@contextmanager",
            "def guard_against_duplicated_email(email: str):",
            "    try:",
            "        yield",
            "    except exc.IntegrityError as e:",
            "        if e.orig.pgcode == _PG_ERR_CODE[\"unique_violation\"]:",
            "            model.Session.rollback()",
            "            raise ValidationError({",
            "                \"email\": [",
            "                    \"The email address '{email}' belongs to \"",
            "                    \"a registered user.\".format(email=email)",
            "                ]",
            "            })",
            "        raise",
            "",
            "",
            "def fresh_context(",
            "    context: Context,",
            ") -> Context:",
            "    \"\"\" Copy just the minimum fields into a new context",
            "        for cases in which we reuse the context and",
            "        we want a clean version with minimum fields \"\"\"",
            "    new_context = {",
            "        k: context[k] for k in (",
            "            'model', 'session', 'user', 'auth_user_obj',",
            "            'ignore_auth', 'defer_commit',",
            "        ) if k in context",
            "    }",
            "    new_context = cast(Context, new_context)",
            "    return new_context"
        ],
        "afterPatchFile": [
            "# encoding: utf-8",
            "from __future__ import annotations",
            "from contextlib import contextmanager",
            "",
            "import functools",
            "import logging",
            "import re",
            "import importlib",
            "",
            "from collections import defaultdict",
            "from typing import (Any, Callable, Container, Iterable, Optional,",
            "                    TypeVar, Union, cast, overload)",
            "from typing_extensions import Literal",
            "",
            "from werkzeug.datastructures import MultiDict",
            "from sqlalchemy import exc",
            "",
            "import ckan.model as model",
            "import ckan.authz as authz",
            "import ckan.lib.navl.dictization_functions as df",
            "import ckan.plugins as p",
            "import ckan.lib.signals as signals",
            "",
            "from ckan.common import _, g",
            "from ckan.types import (",
            "    Action, ChainedAction,",
            "    ChainedAuthFunction, DataDict, ErrorDict, Context, FlattenDataDict,",
            "    FlattenKey, Schema, Validator, ValidatorFactory",
            ")",
            "",
            "Decorated = TypeVar(\"Decorated\")",
            "",
            "log = logging.getLogger(__name__)",
            "_validate = df.validate",
            "",
            "_PG_ERR_CODE = {'unique_violation': '23505'}",
            "",
            "",
            "class NameConflict(Exception):",
            "    pass",
            "",
            "",
            "class UsernamePasswordError(Exception):",
            "    pass",
            "",
            "",
            "class ActionError(Exception):",
            "    message: Optional[str]",
            "",
            "    def __init__(self, message: Optional[str] = '') -> None:",
            "        self.message = message",
            "        super(ActionError, self).__init__(message)",
            "",
            "    def __str__(self):",
            "        msg = self.message",
            "        if not isinstance(msg, str):",
            "            msg = str(msg)",
            "        return msg",
            "",
            "",
            "class NotFound(ActionError):",
            "    '''Exception raised by logic functions when a given object is not found.",
            "",
            "    For example :py:func:`~ckan.logic.action.get.package_show` raises",
            "    :py:exc:`~ckan.plugins.toolkit.ObjectNotFound` if no package with the",
            "    given ``id`` exists.",
            "",
            "    '''",
            "    pass",
            "",
            "",
            "class NotAuthorized(ActionError):",
            "    '''Exception raised when the user is not authorized to call the action.",
            "",
            "    For example :py:func:`~ckan.logic.action.create.package_create` raises",
            "    :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not authorized",
            "    to create packages.",
            "    '''",
            "    pass",
            "",
            "",
            "class ValidationError(ActionError):",
            "    '''Exception raised by action functions when validating their given",
            "    ``data_dict`` fails.",
            "",
            "    '''",
            "    error_dict: ErrorDict",
            "",
            "    def __init__(self,",
            "                 errors: Union[str, ErrorDict],",
            "                 error_summary: Optional[dict[str, str]] = None,",
            "                 extra_msg: Optional[str] = None) -> None:",
            "        if not isinstance(errors, dict):",
            "            error_dict: ErrorDict = {'message': errors}",
            "        else:",
            "            error_dict = errors",
            "        # tags errors are a mess so let's clean them up",
            "        if 'tags' in error_dict:",
            "            tag_errors: list[Union[str, dict[str, Any]]] = []",
            "            for error in cast(\"list[dict[str, Any]]\", error_dict['tags']):",
            "                try:",
            "                    tag_errors.append(', '.join(error['name']))",
            "                except KeyError:",
            "                    # e.g. if it is a vocabulary_id error",
            "                    if error:",
            "                        tag_errors.append(error)",
            "            error_dict['tags'] = tag_errors",
            "        self.error_dict = error_dict",
            "        self._error_summary = error_summary",
            "        super(ValidationError, self).__init__(extra_msg)",
            "",
            "    @property",
            "    def error_summary(self) -> dict[str, str]:",
            "        ''' autogenerate the summary if not supplied '''",
            "        def summarise(error_dict: ErrorDict) -> dict[str, str]:",
            "            ''' Do some i18n stuff on the error_dict keys '''",
            "",
            "            def prettify(field_name: str):",
            "                field_name = re.sub(r'(?<!\\w)[Uu]rl(?!\\w)', 'URL',",
            "                                    field_name.replace('_', ' ').capitalize())",
            "                return _(field_name.replace('_', ' '))",
            "",
            "            summary = {}",
            "",
            "            for key, error in error_dict.items():",
            "                if key == 'resources':",
            "                    summary[_('Resources')] = _('Package resource(s) invalid')",
            "                elif key == 'extras':",
            "                    errors_extras = []",
            "                    for item in cast(\"list[dict[str, Any]]\", error):",
            "                        if (item.get('key') and",
            "                                item['key'][0] not in errors_extras):",
            "                            errors_extras.append(item['key'][0])",
            "                    summary[_('Extras')] = ', '.join(errors_extras)",
            "                elif key == 'extras_validation':",
            "                    assert isinstance(error, list)",
            "                    summary[_('Extras')] = error[0]",
            "                elif key == 'tags':",
            "                    assert isinstance(error, list)",
            "                    summary[_('Tags')] = error[0]",
            "                else:",
            "                    assert isinstance(error, list)",
            "                    summary[_(prettify(key))] = error[0]",
            "            return summary",
            "",
            "        if self._error_summary:",
            "            return self._error_summary",
            "        return summarise(self.error_dict)",
            "",
            "    def __str__(self):",
            "        err_msgs = (super(ValidationError, self).__str__(),",
            "                    self.error_dict)",
            "        return ' - '.join([str(err_msg) for err_msg in err_msgs if err_msg])",
            "",
            "",
            "def checks_and_delete_if_csrf_token_in_forms(parsed: dict[str, Any]):",
            "    '''",
            "    Checks and delete, if the csrf_token is in \"parsed\".",
            "    We don't want the csrf_token to be a part of a data_dict",
            "    as it will expose the token to the metadata.",
            "    This way we are deleting the token from every data_dict that fills",
            "    from request.form instead of deleting it separately in every",
            "    view/blueprint.",
            "    '''",
            "    from ckan.common import config",
            "",
            "    # WTF_CSRF_FIELD_NAME is added by flask_wtf",
            "    csrf_token = config.get(\"WTF_CSRF_FIELD_NAME\")",
            "    if csrf_token in parsed:",
            "        parsed.pop(csrf_token)",
            "    return parsed",
            "",
            "",
            "def parse_params(",
            "    params: 'MultiDict[str, Any]',",
            "    ignore_keys: Optional['Container[str]'] = None",
            ") -> dict[str, Union[str, list[str]]]:",
            "    '''Takes a dict and returns it with some values standardised.",
            "    This is done on a dict before calling tuplize_dict on it.",
            "    '''",
            "    parsed = {}",
            "    for key in params:",
            "        if ignore_keys and key in ignore_keys:",
            "            continue",
            "        # flask request has `getlist` instead of pylons' `getall`",
            "",
            "        if hasattr(params, 'getall'):",
            "            # type_ignore_reason: pylons legacy",
            "            value = params.getall(key)  # type: ignore",
            "        else:",
            "            value = params.getlist(key)",
            "",
            "        # Blank values become ''",
            "        if not value:",
            "            value = ''",
            "        # A list with only one item is stripped of being a list",
            "        if len(value) == 1:",
            "            value = value[0]",
            "        parsed[key] = value",
            "",
            "    parsed = checks_and_delete_if_csrf_token_in_forms(parsed)",
            "    return parsed",
            "",
            "",
            "def clean_dict(data_dict: dict[str, Any]) -> dict[str, Any]:",
            "    '''Takes a dict and if any of the values are lists of dicts,",
            "    the empty dicts are stripped from the lists (recursive).",
            "",
            "    e.g.",
            "    >>> clean_dict(",
            "        {'name': u'testgrp4',",
            "         'title': u'',",
            "         'description': u'',",
            "         'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],",
            "         'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'},",
            "                    {'key': u'', 'value': u''},",
            "                    {'key': u'', 'value': u''}],",
            "         'state': u'active'}",
            "    {'name': u'testgrp4',",
            "     'title': u'',",
            "     'description': u'',",
            "     'packages': [{'name': u'testpkg'}, {'name': u'testpkg'}],",
            "     'extras': [{'key': u'packages', 'value': u'[\"testpkg\"]'}],",
            "     'state': u'active'}",
            "",
            "    '''",
            "    for value in data_dict.values():",
            "        if not isinstance(value, list):",
            "            continue",
            "        for inner_dict in value[:]:",
            "            if isinstance(inner_dict, str):",
            "                break",
            "            if not any(inner_dict.values()):",
            "                value.remove(inner_dict)",
            "            else:",
            "                clean_dict(inner_dict)",
            "    return data_dict",
            "",
            "",
            "def tuplize_dict(data_dict: dict[str, Any]) -> FlattenDataDict:",
            "    '''Takes a dict with keys of the form 'table__0__key' and converts them",
            "    to a tuple like ('table', 0, 'key').",
            "",
            "    Dict should be put through parse_dict before this function, to have",
            "    values standardized.",
            "",
            "    May raise a DataError if the format of the key is incorrect.",
            "    '''",
            "    tuplized_dict: FlattenDataDict = {}",
            "    for k, value in data_dict.items():",
            "        key_list = cast(\"list[Union[str, int]]\", k.split('__'))",
            "        for num, key in enumerate(key_list):",
            "            if num % 2 == 1:",
            "                try:",
            "                    key_list[num] = int(key)",
            "                except ValueError:",
            "                    raise df.DataError('Bad key')",
            "        tuplized_dict[tuple(key_list)] = value",
            "",
            "    # Sanitize key indexes to make sure they are sequential",
            "    seq_tuplized_dict: FlattenDataDict = {}",
            "    # sequential field indexes grouped by common prefix",
            "    groups: dict[FlattenKey, dict[FlattenKey, int]] = defaultdict(dict)",
            "    for key in sorted(tuplized_dict.keys()):",
            "        new_key = key",
            "",
            "        # iterate over even(numeric) parts of the key",
            "        for idx in range(1, len(key), 2):",
            "            # narrow down scope by common prefix",
            "            group = groups[key[:idx]]",
            "",
            "            # if the identifier(i.e `(extra, 123)`, `(resource, 9)`) is met for",
            "            # the first time, generate for it next number in the index",
            "            # sequence. Index of the latest added item is always equals to the",
            "            # number of unique identifiers minus one(because list indexation",
            "            # starts from 0 in Python). If identifier already present(i.e, we",
            "            # process `(extra, 10, VALUE)` after processing `(extra, 10,",
            "            # KEY)`), reuse sequential index of this identifier",
            "            seq_index = group.setdefault(key[idx-1:idx+1], len(group))",
            "",
            "            # replace the currently processed key segment with computed",
            "            # sequential index",
            "            new_key = new_key[:idx] + (seq_index,) + new_key[idx+1:]",
            "",
            "        seq_tuplized_dict[new_key] = tuplized_dict[key]",
            "",
            "    return seq_tuplized_dict",
            "",
            "",
            "def untuplize_dict(tuplized_dict: FlattenDataDict) -> dict[str, Any]:",
            "",
            "    data_dict = {}",
            "    for key, value in tuplized_dict.items():",
            "        new_key = '__'.join([str(item) for item in key])",
            "        data_dict[new_key] = value",
            "    return data_dict",
            "",
            "",
            "def flatten_to_string_key(dict: dict[str, Any]) -> dict[str, Any]:",
            "",
            "    flattented = df.flatten_dict(dict)",
            "    return untuplize_dict(flattented)",
            "",
            "",
            "def _prepopulate_context(context: Optional[Context]) -> Context:",
            "    if context is None:",
            "        context = {}",
            "    context.setdefault('model', model)",
            "    context.setdefault('session', model.Session)",
            "",
            "    try:",
            "        user = g.user",
            "    except AttributeError:",
            "        # g.user not set",
            "        user = \"\"",
            "    except RuntimeError:",
            "        # Outside of request context",
            "        user = \"\"",
            "    except TypeError:",
            "        # g not registered",
            "        user = \"\"",
            "",
            "    context.setdefault('user', user)",
            "    return context",
            "",
            "",
            "def check_access(action: str,",
            "                 context: Context,",
            "                 data_dict: Optional[dict[str, Any]] = None) -> Literal[True]:",
            "    '''Calls the authorization function for the provided action",
            "",
            "    This is the only function that should be called to determine whether a",
            "    user (or an anonymous request) is allowed to perform a particular action.",
            "",
            "    The function accepts a context object, which should contain a 'user' key",
            "    with the name of the user performing the action, and optionally a",
            "    dictionary with extra data to be passed to the authorization function.",
            "",
            "    For example::",
            "",
            "        check_access('package_update', context, data_dict)",
            "",
            "    If not already there, the function will add an `auth_user_obj` key to the",
            "    context object with the actual User object (in case it exists in the",
            "    database). This check is only performed once per context object.",
            "",
            "    Raise :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not",
            "    authorized to call the named action function.",
            "",
            "    If the user *is* authorized to call the action, return ``True``.",
            "",
            "    :param action: the name of the action function, eg. ``'package_create'``",
            "    :type action: string",
            "",
            "    :param context:",
            "    :type context: dict",
            "",
            "    :param data_dict:",
            "    :type data_dict: dict",
            "",
            "    :raises: :py:exc:`~ckan.plugins.toolkit.NotAuthorized` if the user is not",
            "        authorized to call the named action",
            "",
            "    '''",
            "",
            "    # Auth Auditing.  We remove this call from the __auth_audit stack to show",
            "    # we have called the auth function",
            "    try:",
            "        audit: Optional[tuple[str, int]] = context.get('__auth_audit', [])[-1]",
            "    except IndexError:",
            "        audit = None",
            "    if audit and audit[0] == action:",
            "        context['__auth_audit'].pop()",
            "",
            "    if 'auth_user_obj' not in context:",
            "        context['auth_user_obj'] = None",
            "",
            "    context = _prepopulate_context(context)",
            "",
            "    if not context.get('__auth_user_obj_checked'):",
            "        if context[\"user\"] and not context[\"auth_user_obj\"]:",
            "            context['auth_user_obj'] = model.User.get(context['user'])",
            "        context['__auth_user_obj_checked'] = True",
            "",
            "    try:",
            "        logic_authorization = authz.is_authorized(action, context, data_dict)",
            "        if not logic_authorization['success']:",
            "            msg = cast(str, logic_authorization.get('msg', ''))",
            "            raise NotAuthorized(msg)",
            "    except NotAuthorized as e:",
            "        log.debug(u'check access NotAuthorized - %s user=%s \"%s\"',",
            "                  action, context[\"user\"], str(e))",
            "        raise",
            "",
            "    log.debug('check access OK - %s user=%s', action, context[\"user\"])",
            "    return True",
            "",
            "",
            "_actions: dict[str, Action] = {}",
            "",
            "",
            "def clear_actions_cache() -> None:",
            "    _actions.clear()",
            "",
            "",
            "def chained_action(func: ChainedAction) -> ChainedAction:",
            "    '''Decorator function allowing action function to be chained.",
            "",
            "    This allows a plugin to modify the behaviour of an existing action",
            "    function. A Chained action function must be defined as",
            "    ``action_function(original_action, context, data_dict)`` where the",
            "    first parameter will be set to the action function in the next plugin",
            "    or in core ckan. The chained action may call the original_action",
            "    function, optionally passing different values, handling exceptions,",
            "    returning different values and/or raising different exceptions",
            "    to the caller.",
            "",
            "    Usage::",
            "",
            "        from ckan.plugins.toolkit import chained_action",
            "",
            "        @chained_action",
            "        @side_effect_free",
            "        def package_search(original_action, context, data_dict):",
            "            return original_action(context, data_dict)",
            "",
            "    :param func: chained action function",
            "    :type func: callable",
            "",
            "    :returns: chained action function",
            "    :rtype: callable",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    func.chained_action = True  # type: ignore",
            "",
            "    return func",
            "",
            "",
            "def _is_chained_action(func: Action) -> bool:",
            "    return getattr(func, 'chained_action', False)",
            "",
            "",
            "def get_action(action: str) -> Action:",
            "    '''Return the named :py:mod:`ckan.logic.action` function.",
            "",
            "    For example ``get_action('package_create')`` will normally return the",
            "    :py:func:`ckan.logic.action.create.package_create()` function.",
            "",
            "    For documentation of the available action functions, see",
            "    :ref:`api-reference`.",
            "",
            "    You should always use ``get_action()`` instead of importing an action",
            "    function directly, because :py:class:`~ckan.plugins.interfaces.IActions`",
            "    plugins can override action functions, causing ``get_action()`` to return a",
            "    plugin-provided function instead of the default one.",
            "",
            "    Usage::",
            "",
            "        import ckan.plugins.toolkit as toolkit",
            "",
            "        # Call the package_create action function:",
            "        toolkit.get_action('package_create')(context, data_dict)",
            "",
            "    As the context parameter passed to an action function is commonly::",
            "",
            "        context = {'model': ckan.model, 'session': ckan.model.Session,",
            "                   'user': user}",
            "",
            "    an action function returned by ``get_action()`` will automatically add",
            "    these parameters to the context if they are not defined.  This is",
            "    especially useful for plugins as they should not really be importing parts",
            "    of ckan eg :py:mod:`ckan.model` and as such do not have access to ``model``",
            "    or ``model.Session``.",
            "",
            "    If a ``context`` of ``None`` is passed to the action function then the",
            "    default context dict will be created.",
            "",
            "    .. note::",
            "",
            "        Many action functions modify the context dict. It can therefore",
            "        not be reused for multiple calls of the same or different action",
            "        functions.",
            "",
            "    :param action: name of the action function to return,",
            "        eg. ``'package_create'``",
            "    :type action: string",
            "",
            "    :returns: the named action function",
            "    :rtype: callable",
            "",
            "    '''",
            "",
            "    if _actions:",
            "        if action not in _actions:",
            "            raise KeyError(\"Action '%s' not found\" % action)",
            "        return _actions[action]",
            "    # Otherwise look in all the plugins to resolve all possible First",
            "    # get the default ones in the ckan/logic/action directory Rather",
            "    # than writing them out in full will use importlib.import_module",
            "    # to load anything from ckan.logic.action that looks like it might",
            "    # be an action",
            "    for action_module_name in ['get', 'create', 'update', 'delete', 'patch']:",
            "        module = importlib.import_module(",
            "            '.' + action_module_name, 'ckan.logic.action')",
            "        for k, v in authz.get_local_functions(module):",
            "            _actions[k] = v",
            "            # Allow all actions defined in logic/action/get.py to",
            "            # be side-effect free.",
            "            if action_module_name == 'get' and \\",
            "               not hasattr(v, 'side_effect_free'):",
            "                v.side_effect_free = True",
            "",
            "    # Then overwrite them with any specific ones in the plugins:",
            "    resolved_action_plugins: dict[str, str] = {}",
            "    fetched_actions = {}",
            "    chained_actions = defaultdict(list)",
            "    for plugin in p.PluginImplementations(p.IActions):",
            "        for name, action_function in plugin.get_actions().items():",
            "            if _is_chained_action(action_function):",
            "                chained_actions[name].append(action_function)",
            "            elif name in resolved_action_plugins:",
            "                raise NameConflict(",
            "                    'The action %r is already implemented in %r' % (",
            "                        name,",
            "                        resolved_action_plugins[name]",
            "                    )",
            "                )",
            "            else:",
            "                resolved_action_plugins[name] = plugin.name",
            "                # Extensions are exempted from the auth audit for now",
            "                # This needs to be resolved later",
            "                # type_ignore_reason: custom attribute",
            "                action_function.auth_audit_exempt = True  # type: ignore",
            "                fetched_actions[name] = action_function",
            "    for name, func_list in chained_actions.items():",
            "        if name not in fetched_actions and name not in _actions:",
            "            # nothing to override from plugins or core",
            "            raise NotFound('The action %r is not found for chained action' % (",
            "                name))",
            "        for func in reversed(func_list):",
            "            # try other plugins first, fall back to core",
            "            prev_func = fetched_actions.get(name, _actions.get(name))",
            "            new_func = functools.partial(func, prev_func)",
            "            # persisting attributes to the new partial function",
            "            for attribute, value in func.__dict__.items():",
            "                setattr(new_func, attribute, value)",
            "            fetched_actions[name] = new_func",
            "",
            "    # Use the updated ones in preference to the originals.",
            "    _actions.update(fetched_actions)",
            "",
            "    # wrap the functions",
            "    for action_name, _action in _actions.items():",
            "        def make_wrapped(_action: Action, action_name: str):",
            "            def wrapped(context: Optional[Context] = None,",
            "                        data_dict: Optional[DataDict] = None, **kw: Any):",
            "                if kw:",
            "                    log.critical('%s was passed extra keywords %r'",
            "                                 % (_action.__name__, kw))",
            "",
            "                context = _prepopulate_context(context)",
            "",
            "                if data_dict is None:",
            "                    data_dict = {}",
            "",
            "                # Auth Auditing - checks that the action function did call",
            "                # check_access (unless there is no accompanying auth function).",
            "                # We push the action name and id onto the __auth_audit stack",
            "                # before calling the action, and check_access removes it.",
            "                # (We need the id of the action in case the action is wrapped",
            "                # inside an action of the same name, which happens in the",
            "                # datastore)",
            "                context.setdefault('__auth_audit', [])",
            "                context['__auth_audit'].append((action_name, id(_action)))",
            "",
            "                # check_access(action_name, context, data_dict=None)",
            "                result = _action(context, data_dict, **kw)",
            "                try:",
            "                    audit = context['__auth_audit'][-1]",
            "                    if audit[0] == action_name and audit[1] == id(_action):",
            "                        if action_name not in authz.auth_functions_list():",
            "                            log.debug('No auth function for %s' % action_name)",
            "                        elif not getattr(_action, 'auth_audit_exempt', False):",
            "                            raise Exception(",
            "                                'Action function {0} did not call its '",
            "                                'auth function'",
            "                                .format(action_name))",
            "                        # remove from audit stack",
            "                        context['__auth_audit'].pop()",
            "                except IndexError:",
            "                    pass",
            "",
            "                signals.action_succeeded.send(",
            "                    action_name, context=context, data_dict=data_dict,",
            "                    result=result)",
            "                return result",
            "            return wrapped",
            "",
            "        fn = make_wrapped(_action, action_name)",
            "        # we need to mirror the docstring",
            "        fn.__doc__ = _action.__doc__",
            "        # we need to retain the side effect free behaviour",
            "        if getattr(_action, 'side_effect_free', False):",
            "            # type_ignore_reason: custom attribute",
            "            fn.side_effect_free = True  # type: ignore",
            "        _actions[action_name] = fn",
            "",
            "    return _actions[action]",
            "",
            "",
            "@overload",
            "def get_or_bust(data_dict: dict[str, Any], keys: str) -> Any:",
            "    ...",
            "",
            "",
            "@overload",
            "def get_or_bust(",
            "        data_dict: dict[str, Any], keys: Iterable[str]) -> tuple[Any, ...]:",
            "    ...",
            "",
            "",
            "def get_or_bust(",
            "        data_dict: dict[str, Any],",
            "        keys: Union[str, Iterable[str]]) -> Union[Any, tuple[Any, ...]]:",
            "    '''Return the value(s) from the given data_dict for the given key(s).",
            "",
            "    Usage::",
            "",
            "        single_value = get_or_bust(data_dict, 'a_key')",
            "        value_1, value_2 = get_or_bust(data_dict, ['key1', 'key2'])",
            "",
            "    :param data_dict: the dictionary to return the values from",
            "    :type data_dict: dictionary",
            "",
            "    :param keys: the key(s) for the value(s) to return",
            "    :type keys: either a string or a list",
            "",
            "    :returns: a single value from the dict if a single key was given,",
            "        or a tuple of values if a list of keys was given",
            "",
            "    :raises: :py:exc:`ckan.logic.ValidationError` if one of the given keys is",
            "        not in the given dictionary",
            "",
            "    '''",
            "    if isinstance(keys, str):",
            "        keys = [keys]",
            "",
            "    from ckan.logic.schema import create_schema_for_required_keys",
            "    schema = create_schema_for_required_keys(keys)",
            "",
            "    data_dict, errors = _validate(data_dict, schema)",
            "",
            "    if errors:",
            "        raise ValidationError(errors)",
            "",
            "    # preserve original key order",
            "    values = [data_dict[key] for key in keys]",
            "    if len(values) == 1:",
            "        return values[0]",
            "    return tuple(values)",
            "",
            "",
            "def validate(schema_func: Callable[[], Schema],",
            "             can_skip_validator: bool = False) -> Callable[[Action], Action]:",
            "    ''' A decorator that validates an action function against a given schema",
            "    '''",
            "    def action_decorator(action: Action) -> Action:",
            "        @functools.wraps(action)",
            "        def wrapper(context: Context, data_dict: DataDict):",
            "            if can_skip_validator:",
            "                if context.get('skip_validation'):",
            "                    return action(context, data_dict)",
            "",
            "            schema = context.get('schema', schema_func())",
            "            data_dict, errors = _validate(data_dict, schema, context)",
            "            if errors:",
            "                raise ValidationError(errors)",
            "            return action(context, data_dict)",
            "        return wrapper",
            "    return action_decorator",
            "",
            "",
            "def side_effect_free(action: Decorated) -> Decorated:",
            "    '''A decorator that marks the given action function as side-effect-free.",
            "",
            "    Action functions decorated with this decorator can be called with an HTTP",
            "    GET request to the :doc:`Action API </api/index>`. Action functions that",
            "    don't have this decorator must be called with a POST request.",
            "",
            "    If your CKAN extension defines its own action functions using the",
            "    :py:class:`~ckan.plugins.interfaces.IActions` plugin interface, you can use",
            "    this decorator to make your actions available with GET requests instead of",
            "    just with POST requests.",
            "",
            "    Example::",
            "",
            "        import ckan.plugins.toolkit as toolkit",
            "",
            "        @toolkit.side_effect_free",
            "        def my_custom_action_function(context, data_dict):",
            "            ...",
            "",
            "    (Then implement :py:class:`~ckan.plugins.interfaces.IActions` to register",
            "    your action function with CKAN.)",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.side_effect_free = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_sysadmins_check(action: Decorated) -> Decorated:",
            "    '''A decorator that prevents sysadmins from being automatically authorized",
            "    to call an action function.",
            "",
            "    Normally sysadmins are allowed to call any action function (for example",
            "    when they're using the :doc:`Action API </api/index>` or the web",
            "    interface), if the user is a sysadmin the action function's authorization",
            "    function will not even be called.",
            "",
            "    If an action function is decorated with this decorator, then its",
            "    authorization function will always be called, even if the user is a",
            "    sysadmin.",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_sysadmins_check = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_audit_exempt(action: Decorated) -> Decorated:",
            "    ''' Dirty hack to stop auth audit being done '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_audit_exempt = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_allow_anonymous_access(action: Decorated) -> Decorated:",
            "    ''' Flag an auth function as not requiring a logged in user",
            "",
            "    This means that check_access won't automatically raise a NotAuthorized",
            "    exception if an authenticated user is not provided in the context. (The",
            "    auth function can still return False if for some reason access is not",
            "    granted).",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_allow_anonymous_access = True  # type: ignore",
            "    return action",
            "",
            "",
            "def auth_disallow_anonymous_access(action: Decorated) -> Decorated:",
            "    ''' Flag an auth function as requiring a logged in user",
            "",
            "    This means that check_access will automatically raise a NotAuthorized",
            "    exception if an authenticated user is not provided in the context, without",
            "    calling the actual auth function.",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    action.auth_allow_anonymous_access = False  # type: ignore",
            "    return action",
            "",
            "",
            "def chained_auth_function(func: ChainedAuthFunction) -> ChainedAuthFunction:",
            "    '''",
            "    Decorator function allowing authentication functions to be chained.",
            "",
            "    This chain starts with the last chained auth function to be registered and",
            "    ends with the original auth function (or a non-chained plugin override",
            "    version). Chained auth functions must accept an extra parameter,",
            "    specifically the next auth function in the chain, for example::",
            "",
            "        auth_function(next_auth, context, data_dict).",
            "",
            "    The chained auth function may call the next_auth function, optionally",
            "    passing different values, handling exceptions, returning different",
            "    values and/or raising different exceptions to the caller.",
            "",
            "    Usage::",
            "",
            "        from ckan.plugins.toolkit import chained_auth_function",
            "",
            "        @chained_auth_function",
            "        @auth_allow_anonymous_access",
            "        def user_show(next_auth, context, data_dict=None):",
            "            return next_auth(context, data_dict)",
            "",
            "    :param func: chained authentication function",
            "    :type func: callable",
            "",
            "    :returns: chained authentication function",
            "    :rtype: callable",
            "",
            "    '''",
            "    # type_ignore_reason: custom attribute",
            "    func.chained_auth_function = True  # type: ignore",
            "    return func",
            "",
            "",
            "class UnknownValidator(Exception):",
            "    '''Exception raised when a requested validator function cannot be found.",
            "",
            "    '''",
            "    pass",
            "",
            "",
            "_validators_cache: dict[str, Union[Validator, ValidatorFactory]] = {}",
            "",
            "",
            "def clear_validators_cache() -> None:",
            "    _validators_cache.clear()",
            "",
            "",
            "# This function exists mainly so that validators can be made available to",
            "# extensions via ckan.plugins.toolkit.",
            "def get_validator(",
            "        validator: str) -> Union[Validator, ValidatorFactory]:",
            "    '''Return a validator function by name.",
            "",
            "    :param validator: the name of the validator function to return,",
            "        eg. ``'package_name_exists'``",
            "    :type validator: string",
            "",
            "    :raises: :py:exc:`~ckan.plugins.toolkit.UnknownValidator` if the named",
            "        validator is not found",
            "",
            "    :returns: the named validator function",
            "    :rtype: ``types.FunctionType``",
            "",
            "    '''",
            "    if not _validators_cache:",
            "        validators = _import_module_functions('ckan.lib.navl.validators')",
            "        _validators_cache.update(validators)",
            "        validators = _import_module_functions('ckan.logic.validators')",
            "        _validators_cache.update(validators)",
            "        converters = _import_module_functions('ckan.logic.converters')",
            "        _validators_cache.update(converters)",
            "        _validators_cache.update({'OneOf': _validators_cache['one_of']})",
            "",
            "        for plugin in p.PluginImplementations(p.IValidators):",
            "            for name, fn in plugin.get_validators().items():",
            "                log.debug('Validator function {0} from plugin {1} was inserted'",
            "                          .format(name, plugin.name))",
            "                _validators_cache[name] = fn",
            "    try:",
            "        return _validators_cache[validator]",
            "    except KeyError:",
            "        raise UnknownValidator('Validator `%s` does not exist' % validator)",
            "",
            "",
            "def model_name_to_class(model_module: Any, model_name: str) -> Any:",
            "    '''Return the class in model_module that has the same name as the",
            "    received string.",
            "",
            "    Raises AttributeError if there's no model in model_module named model_name.",
            "    '''",
            "    model_class_name = model_name.title()",
            "    try:",
            "        return getattr(model_module, model_class_name)",
            "    except AttributeError:",
            "        raise ValidationError({",
            "            \"message\": \"%s isn't a valid model\" % model_class_name})",
            "",
            "",
            "def _import_module_functions(",
            "        module_path: str) -> dict[str, Callable[..., Any]]:",
            "    '''Import a module and get the functions and return them in a dict'''",
            "    module = importlib.import_module(module_path)",
            "    return {",
            "        k: v",
            "        for k, v in authz.get_local_functions(module)",
            "    }",
            "",
            "",
            "@contextmanager",
            "def guard_against_duplicated_email(email: str):",
            "    try:",
            "        yield",
            "    except exc.IntegrityError as e:",
            "        if e.orig.pgcode == _PG_ERR_CODE[\"unique_violation\"]:",
            "            model.Session.rollback()",
            "            raise ValidationError({",
            "                \"email\": [",
            "                    \"The email address '{email}' belongs to \"",
            "                    \"a registered user.\".format(email=email)",
            "                ]",
            "            })",
            "        raise",
            "",
            "",
            "def fresh_context(",
            "    context: Context,",
            ") -> Context:",
            "    \"\"\" Copy just the minimum fields into a new context",
            "        for cases in which we reuse the context and",
            "        we want a clean version with minimum fields \"\"\"",
            "    new_context = {",
            "        k: context[k] for k in (",
            "            'model', 'session', 'user', 'auth_user_obj',",
            "            'ignore_auth', 'defer_commit',",
            "        ) if k in context",
            "    }",
            "    new_context = cast(Context, new_context)",
            "    return new_context"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [],
            "258": [
                "tuplize_dict"
            ]
        },
        "addLocation": []
    },
    "ckan/tests/logic/test_logic.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from unittest import mock"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import pytest"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from ckan import logic, model"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+import ckan.lib.navl.dictization_functions as df"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ckan.types import Context"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import ckan.tests.factories as factories"
            },
            "7": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     with pytest.raises(logic.NotAuthorized):"
            },
            "9": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "         for dataset in dataset3:"
            },
            "10": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             logic.check_access(\"package_show\", context, {'id': dataset[\"id\"]})"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+def test_tuplize_dict():"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+    data_dict = {"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        \"author\": \"Test Author\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+        \"extras__0__key\": \"extra1\","
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        \"extras__0__value\": \"value1\","
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        \"extras__1__key\": \"extra2\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        \"extras__1__value\": \"value2\","
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        \"extras__2__key\": \"extra3\","
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        \"extras__2__value\": \"value3\","
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        \"extras__3__key\": \"\","
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+        \"extras__3__value\": \"\","
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+        \"groups__0__id\": \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        \"name\": \"test-title\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+        \"notes\": \"Test desc\","
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        \"owner_org\": \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\","
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        \"private\": \"True\","
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        \"tag_string\": \"economy,climate\","
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        \"title\": \"Test title\","
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+    }"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    expected = {"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        (\"author\",): \"Test Author\","
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        (\"extras\", 0, \"key\"): \"extra1\","
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        (\"extras\", 0, \"value\"): \"value1\","
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        (\"extras\", 1, \"key\"): \"extra2\","
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        (\"extras\", 1, \"value\"): \"value2\","
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        (\"extras\", 2, \"key\"): \"extra3\","
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        (\"extras\", 2, \"value\"): \"value3\","
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        (\"extras\", 3, \"key\"): \"\","
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        (\"extras\", 3, \"value\"): \"\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+        (\"groups\", 0, \"id\"): \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\","
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        (\"name\",): \"test-title\","
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        (\"notes\",): \"Test desc\","
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        (\"owner_org\",): \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\","
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        (\"private\",): \"True\","
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        (\"tag_string\",): \"economy,climate\","
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        (\"title\",): \"Test title\","
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    }"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    assert logic.tuplize_dict(data_dict) == expected"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+def test_tuplize_dict_random_indexes():"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+    data_dict = {"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        \"extras__22__key\": \"extra2\","
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        \"extras__22__value\": \"value2\","
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+        \"extras__1__key\": \"extra1\","
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        \"extras__1__value\": \"value1\","
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        \"extras__245566546__key\": \"extra3\","
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+        \"extras__245566546__value\": \"value3\","
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+        \"groups__13__id\": \"group2\","
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+        \"groups__1__id\": \"group1\","
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        \"groups__13__nested__7__name\": \"latter\","
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        \"groups__13__nested__2__name\": \"former\","
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    }"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+    expected = {"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        (\"extras\", 0, \"key\"): \"extra1\","
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        (\"extras\", 0, \"value\"): \"value1\","
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        (\"extras\", 1, \"key\"): \"extra2\","
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+        (\"extras\", 1, \"value\"): \"value2\","
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        (\"extras\", 2, \"key\"): \"extra3\","
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        (\"extras\", 2, \"value\"): \"value3\","
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        (\"groups\", 0, \"id\"): \"group1\","
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        (\"groups\", 1, \"id\"): \"group2\","
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        (\"groups\", 1, \"nested\", 0, \"name\"): \"former\","
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        (\"groups\", 1, \"nested\", 1, \"name\"): \"latter\","
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    }"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+    assert logic.tuplize_dict(data_dict) == expected"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+def test_tuplize_dict_wrong_index():"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    with pytest.raises(df.DataError):"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        data_dict = {"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            \"extras__2a__key\": \"extra\","
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        }"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+        logic.tuplize_dict(data_dict)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "from unittest import mock",
            "import pytest",
            "from ckan import logic, model",
            "from ckan.types import Context",
            "import ckan.tests.factories as factories",
            "",
            "",
            "def test_model_name_to_class():",
            "    assert logic.model_name_to_class(model, \"package\") == model.Package",
            "    with pytest.raises(logic.ValidationError):",
            "        logic.model_name_to_class(model, \"inexistent_model_name\")",
            "",
            "",
            "def test_check_access_auth_user_obj_is_not_set():",
            "",
            "    user_names = (\"unknown_user\", \"\", None)",
            "    for user_name in user_names:",
            "        context = {\"user\": user_name}",
            "",
            "        result = logic.check_access(\"package_search\", context)",
            "",
            "        assert result",
            "        assert context[\"__auth_user_obj_checked\"]",
            "        assert context[\"auth_user_obj\"] is None",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "def test_check_access_auth_user_obj_is_set():",
            "    user = factories.User()",
            "    context = {\"user\": user[\"name\"]}",
            "",
            "    result = logic.check_access(\"package_create\", context)",
            "",
            "    assert result",
            "    assert context[\"__auth_user_obj_checked\"]",
            "    assert context[\"auth_user_obj\"].name == user[\"name\"]",
            "",
            "",
            "@mock.patch(\"ckan.authz.is_authorized\")",
            "def test_user_inside_context_of_check_access(is_authorized: mock.Mock):",
            "    logic.check_access(\"package_create\", {})",
            "    is_authorized.assert_called_once()",
            "    context = is_authorized.call_args[0][1]",
            "    assert context[\"user\"] == \"\"",
            "",
            "    is_authorized.reset_mock()",
            "",
            "    logic.check_access(\"package_create\", {\"user\": \"test\"})",
            "    context = is_authorized.call_args[0][1]",
            "    assert context[\"user\"] == \"test\"",
            "",
            "",
            "def test_get_action_optional_params():",
            "",
            "    assert \"ckan_version\" in logic.get_action(\"status_show\")()",
            "",
            "",
            "def test_fresh_context():",
            "    \"\"\" Test the fresh_context function.",
            "        It should return a new context object only with",
            "        'model', 'session', 'user', 'auth_user_obj', 'ignore_auth'",
            "        values (if they exists).\"\"\"",
            "",
            "    dirty_context: Context = {",
            "        \"user\": \"test\",",
            "        \"ignore_auth\": True,",
            "        \"to_be_cleaned\": \"test\",",
            "    }",
            "",
            "    cleaned_context = logic.fresh_context(dirty_context)",
            "",
            "    assert \"to_be_cleaned\" not in cleaned_context",
            "    assert cleaned_context[\"user\"] == \"test\"",
            "    assert cleaned_context[\"ignore_auth\"] is True",
            "    assert \"model\" not in cleaned_context",
            "    assert \"session\" not in cleaned_context",
            "    assert \"auth_user_obj\" not in cleaned_context",
            "",
            "",
            "def test_check_access_auth_user_for_different_objects():",
            "    user1 = factories.User()",
            "    user2 = factories.User()",
            "    context = {\"user\": user1[\"name\"]}",
            "",
            "    organization1 = factories.Organization(user=user1)",
            "    organization2 = factories.Organization(user=user2)",
            "",
            "    datasets1 = [",
            "        factories.Dataset(owner_org=organization1[\"id\"], private=True)",
            "        for _ in range(0, 1)",
            "    ]",
            "    datasets2 = [",
            "        factories.Dataset(owner_org=organization2[\"id\"], private=True)",
            "        for _ in range(0, 1)",
            "    ]",
            "    dataset3 = datasets1 + datasets2",
            "",
            "    with pytest.raises(logic.NotAuthorized):",
            "        for dataset in dataset3:",
            "            logic.check_access(\"package_show\", context, {'id': dataset[\"id\"]})"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "from unittest import mock",
            "import pytest",
            "from ckan import logic, model",
            "import ckan.lib.navl.dictization_functions as df",
            "",
            "from ckan.types import Context",
            "import ckan.tests.factories as factories",
            "",
            "",
            "def test_model_name_to_class():",
            "    assert logic.model_name_to_class(model, \"package\") == model.Package",
            "    with pytest.raises(logic.ValidationError):",
            "        logic.model_name_to_class(model, \"inexistent_model_name\")",
            "",
            "",
            "def test_check_access_auth_user_obj_is_not_set():",
            "",
            "    user_names = (\"unknown_user\", \"\", None)",
            "    for user_name in user_names:",
            "        context = {\"user\": user_name}",
            "",
            "        result = logic.check_access(\"package_search\", context)",
            "",
            "        assert result",
            "        assert context[\"__auth_user_obj_checked\"]",
            "        assert context[\"auth_user_obj\"] is None",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "def test_check_access_auth_user_obj_is_set():",
            "    user = factories.User()",
            "    context = {\"user\": user[\"name\"]}",
            "",
            "    result = logic.check_access(\"package_create\", context)",
            "",
            "    assert result",
            "    assert context[\"__auth_user_obj_checked\"]",
            "    assert context[\"auth_user_obj\"].name == user[\"name\"]",
            "",
            "",
            "@mock.patch(\"ckan.authz.is_authorized\")",
            "def test_user_inside_context_of_check_access(is_authorized: mock.Mock):",
            "    logic.check_access(\"package_create\", {})",
            "    is_authorized.assert_called_once()",
            "    context = is_authorized.call_args[0][1]",
            "    assert context[\"user\"] == \"\"",
            "",
            "    is_authorized.reset_mock()",
            "",
            "    logic.check_access(\"package_create\", {\"user\": \"test\"})",
            "    context = is_authorized.call_args[0][1]",
            "    assert context[\"user\"] == \"test\"",
            "",
            "",
            "def test_get_action_optional_params():",
            "",
            "    assert \"ckan_version\" in logic.get_action(\"status_show\")()",
            "",
            "",
            "def test_fresh_context():",
            "    \"\"\" Test the fresh_context function.",
            "        It should return a new context object only with",
            "        'model', 'session', 'user', 'auth_user_obj', 'ignore_auth'",
            "        values (if they exists).\"\"\"",
            "",
            "    dirty_context: Context = {",
            "        \"user\": \"test\",",
            "        \"ignore_auth\": True,",
            "        \"to_be_cleaned\": \"test\",",
            "    }",
            "",
            "    cleaned_context = logic.fresh_context(dirty_context)",
            "",
            "    assert \"to_be_cleaned\" not in cleaned_context",
            "    assert cleaned_context[\"user\"] == \"test\"",
            "    assert cleaned_context[\"ignore_auth\"] is True",
            "    assert \"model\" not in cleaned_context",
            "    assert \"session\" not in cleaned_context",
            "    assert \"auth_user_obj\" not in cleaned_context",
            "",
            "",
            "def test_check_access_auth_user_for_different_objects():",
            "    user1 = factories.User()",
            "    user2 = factories.User()",
            "    context = {\"user\": user1[\"name\"]}",
            "",
            "    organization1 = factories.Organization(user=user1)",
            "    organization2 = factories.Organization(user=user2)",
            "",
            "    datasets1 = [",
            "        factories.Dataset(owner_org=organization1[\"id\"], private=True)",
            "        for _ in range(0, 1)",
            "    ]",
            "    datasets2 = [",
            "        factories.Dataset(owner_org=organization2[\"id\"], private=True)",
            "        for _ in range(0, 1)",
            "    ]",
            "    dataset3 = datasets1 + datasets2",
            "",
            "    with pytest.raises(logic.NotAuthorized):",
            "        for dataset in dataset3:",
            "            logic.check_access(\"package_show\", context, {'id': dataset[\"id\"]})",
            "",
            "",
            "def test_tuplize_dict():",
            "",
            "    data_dict = {",
            "        \"author\": \"Test Author\",",
            "        \"extras__0__key\": \"extra1\",",
            "        \"extras__0__value\": \"value1\",",
            "        \"extras__1__key\": \"extra2\",",
            "        \"extras__1__value\": \"value2\",",
            "        \"extras__2__key\": \"extra3\",",
            "        \"extras__2__value\": \"value3\",",
            "        \"extras__3__key\": \"\",",
            "        \"extras__3__value\": \"\",",
            "        \"groups__0__id\": \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",",
            "        \"name\": \"test-title\",",
            "        \"notes\": \"Test desc\",",
            "        \"owner_org\": \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",",
            "        \"private\": \"True\",",
            "        \"tag_string\": \"economy,climate\",",
            "        \"title\": \"Test title\",",
            "    }",
            "",
            "    expected = {",
            "        (\"author\",): \"Test Author\",",
            "        (\"extras\", 0, \"key\"): \"extra1\",",
            "        (\"extras\", 0, \"value\"): \"value1\",",
            "        (\"extras\", 1, \"key\"): \"extra2\",",
            "        (\"extras\", 1, \"value\"): \"value2\",",
            "        (\"extras\", 2, \"key\"): \"extra3\",",
            "        (\"extras\", 2, \"value\"): \"value3\",",
            "        (\"extras\", 3, \"key\"): \"\",",
            "        (\"extras\", 3, \"value\"): \"\",",
            "        (\"groups\", 0, \"id\"): \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",",
            "        (\"name\",): \"test-title\",",
            "        (\"notes\",): \"Test desc\",",
            "        (\"owner_org\",): \"5a65eae8-ef2b-4a85-8022-d9e5a71ad074\",",
            "        (\"private\",): \"True\",",
            "        (\"tag_string\",): \"economy,climate\",",
            "        (\"title\",): \"Test title\",",
            "    }",
            "",
            "    assert logic.tuplize_dict(data_dict) == expected",
            "",
            "",
            "def test_tuplize_dict_random_indexes():",
            "",
            "    data_dict = {",
            "        \"extras__22__key\": \"extra2\",",
            "        \"extras__22__value\": \"value2\",",
            "        \"extras__1__key\": \"extra1\",",
            "        \"extras__1__value\": \"value1\",",
            "        \"extras__245566546__key\": \"extra3\",",
            "        \"extras__245566546__value\": \"value3\",",
            "        \"groups__13__id\": \"group2\",",
            "        \"groups__1__id\": \"group1\",",
            "        \"groups__13__nested__7__name\": \"latter\",",
            "        \"groups__13__nested__2__name\": \"former\",",
            "",
            "    }",
            "",
            "    expected = {",
            "        (\"extras\", 0, \"key\"): \"extra1\",",
            "        (\"extras\", 0, \"value\"): \"value1\",",
            "        (\"extras\", 1, \"key\"): \"extra2\",",
            "        (\"extras\", 1, \"value\"): \"value2\",",
            "        (\"extras\", 2, \"key\"): \"extra3\",",
            "        (\"extras\", 2, \"value\"): \"value3\",",
            "        (\"groups\", 0, \"id\"): \"group1\",",
            "        (\"groups\", 1, \"id\"): \"group2\",",
            "        (\"groups\", 1, \"nested\", 0, \"name\"): \"former\",",
            "        (\"groups\", 1, \"nested\", 1, \"name\"): \"latter\",",
            "    }",
            "",
            "    assert logic.tuplize_dict(data_dict) == expected",
            "",
            "",
            "def test_tuplize_dict_wrong_index():",
            "",
            "    with pytest.raises(df.DataError):",
            "        data_dict = {",
            "            \"extras__2a__key\": \"extra\",",
            "        }",
            "        logic.tuplize_dict(data_dict)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "trytond.tools.misc.get_smtp_server"
        ]
    }
}