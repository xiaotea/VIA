{
    "consoleme/lib/defaults.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         required: true"
            },
            "1": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "     condition:"
            },
            "2": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "       StringLike:"
            },
            "3": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ses:FromAddress: \"{from_address}\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        ses:FromAddress: \"${from_address}\""
            },
            "5": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     action_map:"
            },
            "6": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "       - name: send_email"
            },
            "7": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "         text: Send Email"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Large default configuration values are stored here",
            "\"\"\"",
            "import yaml",
            "",
            "SELF_SERVICE_IAM_DEFAULTS = yaml.safe_load(",
            "    \"\"\"",
            "permissions_map:",
            "  s3:",
            "    text: S3 Bucket",
            "    description: S3 Permissions",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Bucket Name",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=s3&show_full_arn_for_s3_buckets=true&search={query}",
            "      - name: bucket_prefix",
            "        type: text_input",
            "        text: Prefix (Folder under S3 that you need access to).",
            "        required: true",
            "        default: /*",
            "    action_map:",
            "      - name: list",
            "        text: List",
            "        permissions:",
            "          - s3:ListBucket",
            "          - s3:ListBucketVersions",
            "      - name: get",
            "        text: Get",
            "        permissions:",
            "          - s3:GetObject",
            "          - s3:GetObjectTagging",
            "          - s3:GetObjectVersion",
            "          - s3:GetObjectVersionTagging",
            "          - s3:GetObjectAcl",
            "          - s3:GetObjectVersionAcl",
            "      - name: put",
            "        text: Put",
            "        permissions:",
            "          - s3:PutObject",
            "          - s3:PutObjectTagging",
            "          - s3:PutObjectVersionTagging",
            "          - s3:ListMultipartUploadParts*",
            "          - s3:AbortMultipartUpload",
            "      - name: delete",
            "        text: Delete",
            "        permissions:",
            "          - s3:DeleteObject",
            "          - s3:DeleteObjectTagging",
            "          - s3:DeleteObjectVersion",
            "          - s3:DeleteObjectVersionTagging",
            "  sqs:",
            "    text: SQS Queue",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Queue ARN",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=sqs&search={query}",
            "    action_map:",
            "      - name: send_messages",
            "        text: Send Message (Queue Producer)",
            "        permissions:",
            "          - sqs:GetQueueAttributes",
            "          - sqs:GetQueueUrl",
            "          - sqs:SendMessage",
            "      - name: receive_messages",
            "        text: Receive/Delete Messages (Queue Consumer)",
            "        permissions:",
            "          - sqs:GetQueueAttributes",
            "          - sqs:GetQueueUrl",
            "          - sqs:ReceiveMessage",
            "          - sqs:DeleteMessage",
            "      - name: set_queue_attributes",
            "        text: Set Queue Attributes",
            "        permissions:",
            "          - sqs:SetQueueAttributes",
            "      - name: purge_messages",
            "        text: Purge Queue (You monster!)",
            "        permissions:",
            "          - sqs:PurgeQueue",
            "  sns:",
            "    text: SNS Topic",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Topic ARN",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=sns&search={query}",
            "    action_map:",
            "      - name: get_topic_attributes",
            "        text: Get Topic Attributes",
            "        permissions:",
            "          - sns:GetEndpointAttributes",
            "          - sns:GetTopicAttributes",
            "      - name: publish",
            "        text: Publish",
            "        permissions:",
            "          - sns:Publish",
            "      - name: subscribe",
            "        text: Subscribe",
            "        permissions:",
            "          - sns:Subscribe",
            "          - sns:ConfirmSubscription",
            "      - name: unsubscribe",
            "        text: Unsubscribe",
            "        permissions:",
            "          - sns:Unsubscribe",
            "  rds:",
            "    text: RDS",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: EC2 resource you need access to",
            "        required: true",
            "        default: \"arn:aws:iam::{account_id}:role/rds-monitoring-role\"",
            "    action_map:",
            "      - name: passrole",
            "        text: PassRole",
            "        permissions:",
            "          - iam:PassRole",
            "  ec2:",
            "    text: EC2",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: EC2 resource you need access to",
            "        required: true",
            "        default: \"*\"",
            "    action_map:",
            "      - name: volmount",
            "        text: VolMount",
            "        permissions:",
            "          - ec2:attachvolume",
            "          - ec2:createvolume",
            "          - ec2:describelicenses",
            "          - ec2:describevolumes",
            "          - ec2:detachvolume",
            "          - ec2:reportinstancestatus",
            "          - ec2:resetsnapshotattribute",
            "      - name: ipv6",
            "        text: Enable IPv6",
            "        permissions:",
            "          - ec2:AssignIpv6Addresses",
            "  route53:",
            "    text: Route53",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: Route53 Domain you need access to",
            "        required: true",
            "        default: \"*\"",
            "    action_map:",
            "      - name: list_records",
            "        text: List Records",
            "        permissions:",
            "          - route53:listresourcerecordsets",
            "      - name: change_records",
            "        text: Change Records",
            "        permissions:",
            "          - route53:changeresourcerecordsets",
            "  sts:",
            "    text: STS AssumeRole",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Role ARN that you wish to assume",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=iam_arn&search={query}",
            "    action_map:",
            "      - name: assume_role",
            "        text: Assume Role",
            "        permissions:",
            "          - sts:AssumeRole",
            "  ses:",
            "    text: SES - Send Email",
            "    inputs:",
            "      - name: from_address",
            "        type: text_input",
            "        text: Email Address to send from",
            "        required: true",
            "        default: \"emailaddress@example.com\"",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: ARN of the resource to send from",
            "        required: true",
            "    condition:",
            "      StringLike:",
            "        ses:FromAddress: \"{from_address}\"",
            "    action_map:",
            "      - name: send_email",
            "        text: Send Email",
            "        permissions:",
            "          - ses:SendEmail",
            "          - ses:SendRawEmail",
            "  crud_lookup:",
            "    text: Other",
            "    description: |-",
            "      Define the service (rds, route53, rekognition, etc), the resource (An ARN or a wildcard), and the list of actions",
            "      (List, Read, Write, Permissions Management, Tagging) that you need access to. If you know the specific IAM",
            "      permissions you need, use \"Advanced Mode\" from the dropdown instead.",
            "    inputs:",
            "      - name: service_name",
            "        type: single_typeahead_input",
            "        text: Service (s3, sqs, sns, rekognition, etc)",
            "        required: true",
            "        typeahead_endpoint: /api/v1/policyuniverse/autocomplete/?only_filter_services=true&prefix={query}",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Resource ARN or Wildcard (*)",
            "        required: true",
            "        typeahead_endpoint: /api/v2/typeahead/resources?typeahead={query}&ui_formatted=true",
            "    action_map:",
            "      - name: list",
            "        text: List",
            "        permissions:",
            "          - List",
            "      - name: read",
            "        text: Read",
            "        permissions:",
            "          - Read",
            "      - name: write",
            "        text: Write",
            "        permissions:",
            "          - Write",
            "      - name: permissions-management",
            "        text: Permissions Management",
            "        permissions:",
            "          - Permissions management",
            "      - name: tagging",
            "        text: Tagging",
            "        permissions:",
            "          - Tagging\"\"\"",
            ")",
            "",
            "PERMISSION_TEMPLATE_DEFAULTS = yaml.safe_load(",
            "    \"\"\"",
            "- key: default",
            "  text: Default Template",
            "  value: |-",
            "    {",
            "         \"Statement\":[",
            "             {",
            "                 \"Action\":[",
            "                     \"\"",
            "                 ],",
            "                 \"Effect\":\"Allow\",",
            "                 \"Resource\": [",
            "                     \"\"",
            "                 ]",
            "             }",
            "         ],",
            "         \"Version\":\"2012-10-17\"",
            "     }",
            "- key: s3write",
            "  text: S3 Write Access",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"s3:ListBucket\",",
            "                    \"s3:GetObject\",",
            "                    \"s3:PutObject\",",
            "                    \"s3:DeleteObject\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"arn:aws:s3:::BUCKET_NAME\",",
            "                    \"arn:aws:s3:::BUCKET_NAME/OPTIONAL_PREFIX/*\"",
            "                ],",
            "                \"Sid\":\"s3readwrite\"",
            "            }",
            "        ]",
            "    }",
            "- key: s3read",
            "  text: S3 Read Access",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"s3:ListBucket\",",
            "                    \"s3:GetObject\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"arn:aws:s3:::BUCKET_NAME\",",
            "                    \"arn:aws:s3:::BUCKET_NAME/OPTIONAL_PREFIX/*\"",
            "                ],",
            "                \"Sid\":\"s3readonly\"",
            "            }",
            "        ]",
            "    }",
            "- key: sqs",
            "  text: SQS",
            "  value: |-",
            "    {",
            "      \"Statement\": [",
            "        {",
            "          \"Action\": [",
            "            \"sqs:ReceiveMessage\",",
            "            \"sqs:SendMessage\",",
            "            \"sqs:DeleteMessage\",",
            "            \"sqs:GetQueueUrl\",",
            "            \"sqs:GetQueueAttributes\"",
            "          ],",
            "          \"Effect\": \"Allow\",",
            "          \"Resource\": \"QUEUE_ARN\"",
            "        }",
            "      ]",
            "    }",
            "- key: sns",
            "  text: SNS",
            "  value: |-",
            "    {",
            "      \"Statement\": [",
            "        {",
            "          \"Action\": [",
            "            \"sns:Publish\",",
            "            \"sns:Subscribe\",",
            "            \"sns:Unsubscribe\"",
            "          ],",
            "          \"Effect\": \"Allow\",",
            "          \"Resource\": \"TOPIC_ARN\"",
            "        }",
            "      ]",
            "    }",
            "- key: rdspassrole",
            "  text: RDS Monitoring PassRole",
            "  value: |-",
            "    {",
            "      \"Statement\": [",
            "        {",
            "          \"Action\": [",
            "            \"iam:PassRole\"",
            "          ],",
            "          \"Effect\": \"Allow\",",
            "          \"Resource\": \"arn:aws:iam::<ACCOUNTID>:role/rds-monitoring-role\"",
            "        }",
            "      ]",
            "    }",
            "- key: ses",
            "  text: SES",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"ses:SendEmail\",",
            "                    \"ses:SendRawEmail\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": \"arn:aws:ses:*:123456789012:identity/example.com\",",
            "                \"Condition\": {",
            "                    \"StringLike\": {",
            "                        \"ses:FromAddress\": \"SENDER@example.com\"",
            "                    }",
            "                }",
            "            }",
            "        ]",
            "    }",
            "- key: sts",
            "  text: STS - Assume role",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"sts:AssumeRole\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": \"arn:aws:iam::ACCOUNT_NUMBER:role/ROLE\"",
            "            }",
            "        ]",
            "    }",
            "- key: route53",
            "  text: Route53 List/Change Record Sets",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"route53:changeresourcerecordsets\",",
            "                    \"route53:listresourcerecordsets\"",
            "                ],",
            "                \"Resource\": [",
            "                    \"*\"",
            "                ],",
            "                \"Effect\": \"Allow\"",
            "            }",
            "        ]",
            "    }",
            "- key: ec2_create_volume",
            "  text: EC2 Volmount",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"ec2:attachvolume\",",
            "                    \"ec2:createvolume\",",
            "                    \"ec2:describelicenses\",",
            "                    \"ec2:describevolumes\",",
            "                    \"ec2:detachvolume\",",
            "                    \"ec2:reportinstancestatus\",",
            "                    \"ec2:resetsnapshotattribute\"",
            "                ],",
            "                \"Resource\": [",
            "                    \"*\"",
            "                ],",
            "                \"Effect\": \"Allow\"",
            "            }",
            "        ]",
            "    }",
            "- key: put_cloudwatch_data",
            "  text: Cloudwatch - putmetricdata",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"cloudwatch:putmetricdata\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ]",
            "            }",
            "        ],",
            "        \"Version\":\"2012-10-17\"",
            "    }",
            "- key: eni_auto_attach",
            "  text: ENI - Auto attach",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"ec2:AttachNetworkInterface\",",
            "                    \"ec2:Describe*\",",
            "                    \"ec2:DetachNetworkInterface\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ],",
            "                \"Sid\":\"eniauto\"",
            "            }",
            "        ],",
            "        \"Version\":\"2012-10-17\"",
            "    }",
            "- key: ec2_ipv6",
            "  text: EC2 - AssignIpv6Addresses",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"ec2:AssignIpv6Addresses\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ]",
            "            }",
            "        ]",
            "    }",
            "- key: volmount",
            "  text: EC2 - volmount",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                      \"ec2:attachvolume\",",
            "                      \"ec2:createsnapshot\",",
            "                      \"ec2:createtags\",",
            "                      \"ec2:createvolume\",",
            "                      \"ec2:deletesnapshot\",",
            "                      \"ec2:describeinstances\",",
            "                      \"ec2:describetags\",",
            "                      \"ec2:describevolumes\",",
            "                      \"ec2:modifyinstanceattribute\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ]",
            "            }",
            "        ]",
            "    }",
            "-   key: securitygroupmutate",
            "    text: EC2 - Security Group Read/Write",
            "    value: |-",
            "      {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"ec2:authorizesecuritygroupingress\",",
            "                    \"ec2:revokesecuritygroupingress\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": [",
            "                    \"arn:aws:ec2:REGION:ACCOUNT_NUMBER:security-group/SECURITY_GROUP_ID\"",
            "                ],",
            "                \"Sid\": \"sgmutate\"",
            "            },",
            "            {",
            "                \"Action\": [",
            "                    \"ec2:describesecuritygroup*\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": [",
            "                    \"*\"",
            "                ],",
            "                \"Sid\": \"sgdescribe\"",
            "            }",
            "        ]",
            "      }",
            "\"\"\"",
            ")"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Large default configuration values are stored here",
            "\"\"\"",
            "import yaml",
            "",
            "SELF_SERVICE_IAM_DEFAULTS = yaml.safe_load(",
            "    \"\"\"",
            "permissions_map:",
            "  s3:",
            "    text: S3 Bucket",
            "    description: S3 Permissions",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Bucket Name",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=s3&show_full_arn_for_s3_buckets=true&search={query}",
            "      - name: bucket_prefix",
            "        type: text_input",
            "        text: Prefix (Folder under S3 that you need access to).",
            "        required: true",
            "        default: /*",
            "    action_map:",
            "      - name: list",
            "        text: List",
            "        permissions:",
            "          - s3:ListBucket",
            "          - s3:ListBucketVersions",
            "      - name: get",
            "        text: Get",
            "        permissions:",
            "          - s3:GetObject",
            "          - s3:GetObjectTagging",
            "          - s3:GetObjectVersion",
            "          - s3:GetObjectVersionTagging",
            "          - s3:GetObjectAcl",
            "          - s3:GetObjectVersionAcl",
            "      - name: put",
            "        text: Put",
            "        permissions:",
            "          - s3:PutObject",
            "          - s3:PutObjectTagging",
            "          - s3:PutObjectVersionTagging",
            "          - s3:ListMultipartUploadParts*",
            "          - s3:AbortMultipartUpload",
            "      - name: delete",
            "        text: Delete",
            "        permissions:",
            "          - s3:DeleteObject",
            "          - s3:DeleteObjectTagging",
            "          - s3:DeleteObjectVersion",
            "          - s3:DeleteObjectVersionTagging",
            "  sqs:",
            "    text: SQS Queue",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Queue ARN",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=sqs&search={query}",
            "    action_map:",
            "      - name: send_messages",
            "        text: Send Message (Queue Producer)",
            "        permissions:",
            "          - sqs:GetQueueAttributes",
            "          - sqs:GetQueueUrl",
            "          - sqs:SendMessage",
            "      - name: receive_messages",
            "        text: Receive/Delete Messages (Queue Consumer)",
            "        permissions:",
            "          - sqs:GetQueueAttributes",
            "          - sqs:GetQueueUrl",
            "          - sqs:ReceiveMessage",
            "          - sqs:DeleteMessage",
            "      - name: set_queue_attributes",
            "        text: Set Queue Attributes",
            "        permissions:",
            "          - sqs:SetQueueAttributes",
            "      - name: purge_messages",
            "        text: Purge Queue (You monster!)",
            "        permissions:",
            "          - sqs:PurgeQueue",
            "  sns:",
            "    text: SNS Topic",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Topic ARN",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=sns&search={query}",
            "    action_map:",
            "      - name: get_topic_attributes",
            "        text: Get Topic Attributes",
            "        permissions:",
            "          - sns:GetEndpointAttributes",
            "          - sns:GetTopicAttributes",
            "      - name: publish",
            "        text: Publish",
            "        permissions:",
            "          - sns:Publish",
            "      - name: subscribe",
            "        text: Subscribe",
            "        permissions:",
            "          - sns:Subscribe",
            "          - sns:ConfirmSubscription",
            "      - name: unsubscribe",
            "        text: Unsubscribe",
            "        permissions:",
            "          - sns:Unsubscribe",
            "  rds:",
            "    text: RDS",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: EC2 resource you need access to",
            "        required: true",
            "        default: \"arn:aws:iam::{account_id}:role/rds-monitoring-role\"",
            "    action_map:",
            "      - name: passrole",
            "        text: PassRole",
            "        permissions:",
            "          - iam:PassRole",
            "  ec2:",
            "    text: EC2",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: EC2 resource you need access to",
            "        required: true",
            "        default: \"*\"",
            "    action_map:",
            "      - name: volmount",
            "        text: VolMount",
            "        permissions:",
            "          - ec2:attachvolume",
            "          - ec2:createvolume",
            "          - ec2:describelicenses",
            "          - ec2:describevolumes",
            "          - ec2:detachvolume",
            "          - ec2:reportinstancestatus",
            "          - ec2:resetsnapshotattribute",
            "      - name: ipv6",
            "        text: Enable IPv6",
            "        permissions:",
            "          - ec2:AssignIpv6Addresses",
            "  route53:",
            "    text: Route53",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: Route53 Domain you need access to",
            "        required: true",
            "        default: \"*\"",
            "    action_map:",
            "      - name: list_records",
            "        text: List Records",
            "        permissions:",
            "          - route53:listresourcerecordsets",
            "      - name: change_records",
            "        text: Change Records",
            "        permissions:",
            "          - route53:changeresourcerecordsets",
            "  sts:",
            "    text: STS AssumeRole",
            "    description: \"\"",
            "    inputs:",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Role ARN that you wish to assume",
            "        required: true",
            "        typeahead_endpoint: /policies/typeahead?resource=iam_arn&search={query}",
            "    action_map:",
            "      - name: assume_role",
            "        text: Assume Role",
            "        permissions:",
            "          - sts:AssumeRole",
            "  ses:",
            "    text: SES - Send Email",
            "    inputs:",
            "      - name: from_address",
            "        type: text_input",
            "        text: Email Address to send from",
            "        required: true",
            "        default: \"emailaddress@example.com\"",
            "      - name: resource_arn",
            "        type: text_input",
            "        text: ARN of the resource to send from",
            "        required: true",
            "    condition:",
            "      StringLike:",
            "        ses:FromAddress: \"${from_address}\"",
            "    action_map:",
            "      - name: send_email",
            "        text: Send Email",
            "        permissions:",
            "          - ses:SendEmail",
            "          - ses:SendRawEmail",
            "  crud_lookup:",
            "    text: Other",
            "    description: |-",
            "      Define the service (rds, route53, rekognition, etc), the resource (An ARN or a wildcard), and the list of actions",
            "      (List, Read, Write, Permissions Management, Tagging) that you need access to. If you know the specific IAM",
            "      permissions you need, use \"Advanced Mode\" from the dropdown instead.",
            "    inputs:",
            "      - name: service_name",
            "        type: single_typeahead_input",
            "        text: Service (s3, sqs, sns, rekognition, etc)",
            "        required: true",
            "        typeahead_endpoint: /api/v1/policyuniverse/autocomplete/?only_filter_services=true&prefix={query}",
            "      - name: resource_arn",
            "        type: typeahead_input",
            "        text: Resource ARN or Wildcard (*)",
            "        required: true",
            "        typeahead_endpoint: /api/v2/typeahead/resources?typeahead={query}&ui_formatted=true",
            "    action_map:",
            "      - name: list",
            "        text: List",
            "        permissions:",
            "          - List",
            "      - name: read",
            "        text: Read",
            "        permissions:",
            "          - Read",
            "      - name: write",
            "        text: Write",
            "        permissions:",
            "          - Write",
            "      - name: permissions-management",
            "        text: Permissions Management",
            "        permissions:",
            "          - Permissions management",
            "      - name: tagging",
            "        text: Tagging",
            "        permissions:",
            "          - Tagging\"\"\"",
            ")",
            "",
            "PERMISSION_TEMPLATE_DEFAULTS = yaml.safe_load(",
            "    \"\"\"",
            "- key: default",
            "  text: Default Template",
            "  value: |-",
            "    {",
            "         \"Statement\":[",
            "             {",
            "                 \"Action\":[",
            "                     \"\"",
            "                 ],",
            "                 \"Effect\":\"Allow\",",
            "                 \"Resource\": [",
            "                     \"\"",
            "                 ]",
            "             }",
            "         ],",
            "         \"Version\":\"2012-10-17\"",
            "     }",
            "- key: s3write",
            "  text: S3 Write Access",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"s3:ListBucket\",",
            "                    \"s3:GetObject\",",
            "                    \"s3:PutObject\",",
            "                    \"s3:DeleteObject\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"arn:aws:s3:::BUCKET_NAME\",",
            "                    \"arn:aws:s3:::BUCKET_NAME/OPTIONAL_PREFIX/*\"",
            "                ],",
            "                \"Sid\":\"s3readwrite\"",
            "            }",
            "        ]",
            "    }",
            "- key: s3read",
            "  text: S3 Read Access",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"s3:ListBucket\",",
            "                    \"s3:GetObject\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"arn:aws:s3:::BUCKET_NAME\",",
            "                    \"arn:aws:s3:::BUCKET_NAME/OPTIONAL_PREFIX/*\"",
            "                ],",
            "                \"Sid\":\"s3readonly\"",
            "            }",
            "        ]",
            "    }",
            "- key: sqs",
            "  text: SQS",
            "  value: |-",
            "    {",
            "      \"Statement\": [",
            "        {",
            "          \"Action\": [",
            "            \"sqs:ReceiveMessage\",",
            "            \"sqs:SendMessage\",",
            "            \"sqs:DeleteMessage\",",
            "            \"sqs:GetQueueUrl\",",
            "            \"sqs:GetQueueAttributes\"",
            "          ],",
            "          \"Effect\": \"Allow\",",
            "          \"Resource\": \"QUEUE_ARN\"",
            "        }",
            "      ]",
            "    }",
            "- key: sns",
            "  text: SNS",
            "  value: |-",
            "    {",
            "      \"Statement\": [",
            "        {",
            "          \"Action\": [",
            "            \"sns:Publish\",",
            "            \"sns:Subscribe\",",
            "            \"sns:Unsubscribe\"",
            "          ],",
            "          \"Effect\": \"Allow\",",
            "          \"Resource\": \"TOPIC_ARN\"",
            "        }",
            "      ]",
            "    }",
            "- key: rdspassrole",
            "  text: RDS Monitoring PassRole",
            "  value: |-",
            "    {",
            "      \"Statement\": [",
            "        {",
            "          \"Action\": [",
            "            \"iam:PassRole\"",
            "          ],",
            "          \"Effect\": \"Allow\",",
            "          \"Resource\": \"arn:aws:iam::<ACCOUNTID>:role/rds-monitoring-role\"",
            "        }",
            "      ]",
            "    }",
            "- key: ses",
            "  text: SES",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"ses:SendEmail\",",
            "                    \"ses:SendRawEmail\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": \"arn:aws:ses:*:123456789012:identity/example.com\",",
            "                \"Condition\": {",
            "                    \"StringLike\": {",
            "                        \"ses:FromAddress\": \"SENDER@example.com\"",
            "                    }",
            "                }",
            "            }",
            "        ]",
            "    }",
            "- key: sts",
            "  text: STS - Assume role",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"sts:AssumeRole\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": \"arn:aws:iam::ACCOUNT_NUMBER:role/ROLE\"",
            "            }",
            "        ]",
            "    }",
            "- key: route53",
            "  text: Route53 List/Change Record Sets",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"route53:changeresourcerecordsets\",",
            "                    \"route53:listresourcerecordsets\"",
            "                ],",
            "                \"Resource\": [",
            "                    \"*\"",
            "                ],",
            "                \"Effect\": \"Allow\"",
            "            }",
            "        ]",
            "    }",
            "- key: ec2_create_volume",
            "  text: EC2 Volmount",
            "  value: |-",
            "    {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"ec2:attachvolume\",",
            "                    \"ec2:createvolume\",",
            "                    \"ec2:describelicenses\",",
            "                    \"ec2:describevolumes\",",
            "                    \"ec2:detachvolume\",",
            "                    \"ec2:reportinstancestatus\",",
            "                    \"ec2:resetsnapshotattribute\"",
            "                ],",
            "                \"Resource\": [",
            "                    \"*\"",
            "                ],",
            "                \"Effect\": \"Allow\"",
            "            }",
            "        ]",
            "    }",
            "- key: put_cloudwatch_data",
            "  text: Cloudwatch - putmetricdata",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"cloudwatch:putmetricdata\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ]",
            "            }",
            "        ],",
            "        \"Version\":\"2012-10-17\"",
            "    }",
            "- key: eni_auto_attach",
            "  text: ENI - Auto attach",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"ec2:AttachNetworkInterface\",",
            "                    \"ec2:Describe*\",",
            "                    \"ec2:DetachNetworkInterface\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ],",
            "                \"Sid\":\"eniauto\"",
            "            }",
            "        ],",
            "        \"Version\":\"2012-10-17\"",
            "    }",
            "- key: ec2_ipv6",
            "  text: EC2 - AssignIpv6Addresses",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                    \"ec2:AssignIpv6Addresses\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ]",
            "            }",
            "        ]",
            "    }",
            "- key: volmount",
            "  text: EC2 - volmount",
            "  value: |-",
            "    {",
            "        \"Statement\":[",
            "            {",
            "                \"Action\":[",
            "                      \"ec2:attachvolume\",",
            "                      \"ec2:createsnapshot\",",
            "                      \"ec2:createtags\",",
            "                      \"ec2:createvolume\",",
            "                      \"ec2:deletesnapshot\",",
            "                      \"ec2:describeinstances\",",
            "                      \"ec2:describetags\",",
            "                      \"ec2:describevolumes\",",
            "                      \"ec2:modifyinstanceattribute\"",
            "                ],",
            "                \"Effect\":\"Allow\",",
            "                \"Resource\":[",
            "                    \"*\"",
            "                ]",
            "            }",
            "        ]",
            "    }",
            "-   key: securitygroupmutate",
            "    text: EC2 - Security Group Read/Write",
            "    value: |-",
            "      {",
            "        \"Statement\": [",
            "            {",
            "                \"Action\": [",
            "                    \"ec2:authorizesecuritygroupingress\",",
            "                    \"ec2:revokesecuritygroupingress\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": [",
            "                    \"arn:aws:ec2:REGION:ACCOUNT_NUMBER:security-group/SECURITY_GROUP_ID\"",
            "                ],",
            "                \"Sid\": \"sgmutate\"",
            "            },",
            "            {",
            "                \"Action\": [",
            "                    \"ec2:describesecuritygroup*\"",
            "                ],",
            "                \"Effect\": \"Allow\",",
            "                \"Resource\": [",
            "                    \"*\"",
            "                ],",
            "                \"Sid\": \"sgdescribe\"",
            "            }",
            "        ]",
            "      }",
            "\"\"\"",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "196": []
        },
        "addLocation": []
    },
    "consoleme/lib/generic.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "             await iterate_and_format_dict(v, replacements)"
            },
            "1": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         else:"
            },
            "2": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "             try:"
            },
            "3": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                d[k] = v.format(**replacements)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+                s = string.Template(v)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                d[k] = s.safe_substitute(**replacements)"
            },
            "6": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             except KeyError:"
            },
            "7": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "                 pass"
            },
            "8": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "     return d"
            }
        },
        "frontPatchFile": [
            "import random",
            "import re",
            "import string",
            "from datetime import datetime",
            "from random import randint",
            "from typing import Any, Dict, List, Optional, Union",
            "from urllib.parse import unquote_plus",
            "",
            "import pandas as pd",
            "import ujson as json",
            "from dateutil import parser",
            "",
            "from consoleme.config import config",
            "from consoleme.exceptions.exceptions import MissingRequestParameter",
            "from consoleme.models import (",
            "    AwsResourcePrincipalModel,",
            "    HoneybeeAwsResourceTemplatePrincipalModel,",
            ")",
            "",
            "",
            "def str2bool(v: Optional[Union[bool, str]]) -> bool:",
            "    if isinstance(v, bytes):",
            "        v = v.decode()",
            "    if not v:",
            "        return False",
            "    if type(v) is bool and v is True:",
            "        return True",
            "    return v.lower() in [\"true\", \"True\"]",
            "",
            "",
            "# Yield successive n-sized",
            "# chunks from list list_.",
            "def divide_chunks(list_, n):",
            "    \"\"\"",
            "    Yields successive n=zied chunks from list l by looping",
            "    until length l.",
            "",
            "    `divide_chunks([\"a\",\"b\",\"c\",\"d\",\"e\"], 2)` yields:",
            "    ['a', 'b', 'c']",
            "    ['d', 'e']",
            "    \"\"\"",
            "    for i in range(0, len(list_), n):",
            "        yield list_[i : i + n]",
            "",
            "",
            "def generate_html(d: List[Dict[str, Union[str, bool]]]) -> str:",
            "    \"\"\"",
            "    Pass in a dict with a list of rows to include in a formatted table. This will return the HTML for the table.",
            "",
            "    :param d:",
            "    :return:",
            "        html: HTML formatted table",
            "    \"\"\"",
            "    if not d:",
            "        return",
            "    pd.set_option(\"display.max_colwidth\", -1)",
            "    df = pd.DataFrame(d)",
            "    html = df.to_html(classes=[\"ui\", \"celled\", \"table\"], escape=False, index=False)",
            "    return html",
            "",
            "",
            "def auto_split(s: str) -> List[str]:",
            "    results = []",
            "",
            "    for i in s.splitlines():",
            "        results.extend(i.split(\",\"))",
            "    return results",
            "",
            "",
            "def is_valid_role_arn(arn: str) -> bool:",
            "    # This is valid enough as far as we are concerned.",
            "    if not arn.startswith(\"arn:aws:iam::\"):",
            "        return False",
            "    return True",
            "",
            "",
            "def regex_filter(",
            "    filter: Dict[str, str], items: List[Dict[str, Union[str, None, bool]]]",
            ") -> List[Dict[str, Union[str, None, bool]]]:",
            "    if filter.get(\"filter\"):",
            "        results = []",
            "        if filter.get(\"type\", \"\") == \"date\":",
            "            from_date = None",
            "            to_date = None",
            "            try:",
            "                if filter.get(\"from_date\"):",
            "                    from_date = parser.parse(filter.get(\"from_date\"))",
            "                if filter.get(\"to_date\"):",
            "                    to_date = parser.parse(filter.get(\"to_date\"))",
            "                if not from_date and not to_date:",
            "                    return items",
            "            except:  # noqa",
            "                # Unable to parse date. Return items.",
            "                return results",
            "            for item in items:",
            "                item_date = parser.parse(",
            "                    item.get(filter.get(\"field\"))",
            "                )  # What if invalid date",
            "                if from_date and to_date and from_date <= item_date <= to_date:",
            "                    results.append(item)",
            "                    continue",
            "                if from_date and not to_date and item_date >= from_date:",
            "                    results.append(item)",
            "                    continue",
            "                if to_date and not from_date and item_date <= to_date:",
            "                    results.append(item)",
            "                    continue",
            "            return results",
            "        else:",
            "            regexp = re.compile(r\"{}\".format(filter.get(\"filter\")), re.IGNORECASE)",
            "            for item in items:",
            "                try:",
            "                    if regexp.search(item.get(filter.get(\"field\"))):",
            "                        results.append(item)",
            "                except re.error:",
            "                    # Regex error. Return no results",
            "                    pass",
            "            return results",
            "    else:",
            "        return items",
            "",
            "",
            "def is_in_group(",
            "    user: str, user_groups: List[str], required_groups: Union[List[str], str]",
            ") -> bool:",
            "    if isinstance(required_groups, str):",
            "        required_groups = [required_groups]",
            "    for group in required_groups:",
            "        if group in user_groups or user == group:",
            "            return True",
            "    return False",
            "",
            "",
            "async def write_json_error(message, obj):",
            "    result = {\"status\": \"error\", \"message\": message}",
            "    obj.write(json.dumps(result))",
            "    obj.finish()",
            "",
            "",
            "async def sort_nested_dictionary_lists(d):",
            "    for k, v in d.items():",
            "        if isinstance(v, list):",
            "            for i in range(0, len(v)):",
            "                if isinstance(v[i], dict):",
            "                    v[i] = await sort_nested_dictionary_lists(v[i])",
            "                d[k] = sorted(v)",
            "        if isinstance(v, dict):",
            "            d[k] = await sort_nested_dictionary_lists(v)",
            "    return d",
            "",
            "",
            "def is_in_time_range(t, time_range):",
            "    valid_days = time_range.get(\"days\")",
            "    if t.weekday() not in valid_days:",
            "        return False",
            "    valid_start_time = t.replace(",
            "        hour=time_range.get(\"hour_start\", 0),",
            "        minute=time_range.get(\"minute_start\", 0),",
            "        second=0,",
            "        microsecond=0,",
            "    )",
            "    valid_end_time = t.replace(",
            "        hour=time_range.get(\"hour_end\", 0),",
            "        minute=time_range.get(\"minute_end\", 0),",
            "        second=0,",
            "        microsecond=0,",
            "    )",
            "    if t < valid_start_time or t > valid_end_time:",
            "        return False",
            "    return True",
            "",
            "",
            "async def get_random_security_logo():",
            "    if config.get(\"consoleme_logo.image\"):",
            "        return config.get(\"consoleme_logo.image\")",
            "    month = datetime.now().month",
            "    summer = month in [6, 7, 8]",
            "",
            "    dir = \"sunglasses\" if summer else \"nosunglasses\"",
            "    file = f\"{randint(1, 3)}.png\"  # nosec",
            "    return f\"/images/logos/{dir}/{file}\"",
            "",
            "",
            "async def generate_random_string(string_length=4):",
            "    letters = string.ascii_lowercase",
            "    return \"\".join(random.choice(letters) for i in range(string_length))  # nosec",
            "",
            "",
            "async def filter_table(filter_key, filter_value, data):",
            "    if not (filter_key and filter_value):",
            "        # Filter parameters are incorrect. Don't filter",
            "        return data",
            "    results = []",
            "    if isinstance(filter_value, str):",
            "        try:",
            "            regexp = re.compile(r\"{}\".format(str(filter_value).strip()), re.IGNORECASE)",
            "        except:  # noqa",
            "            # Regex is incorrect. Don't filter",
            "            return data",
            "",
            "        for d in data:",
            "            try:",
            "                if regexp.search(str(d.get(filter_key))):",
            "                    results.append(d)",
            "            except re.error:",
            "                # Regex error. Return no results",
            "                pass",
            "        return results",
            "    elif (",
            "        isinstance(filter_value, list)",
            "        and len(filter_value) == 2",
            "        and isinstance(filter_value[0], int)",
            "        and isinstance(filter_value[1], int)",
            "    ):",
            "        # Handles epoch time filter. We expect a start_time and an end_time in",
            "        # a list of elements, and they should be integers",
            "        for d in data:",
            "            if filter_value[0] < int(d.get(filter_key)) < filter_value[1]:",
            "                results.append(d)",
            "        return results",
            "",
            "",
            "async def iterate_and_format_dict(d: Dict, replacements: Dict):",
            "    \"\"\"",
            "    Iterates through the values of a dictionary (with or without nested dictionaries), and formats values accordingly",
            "    if they exist in the `replacements` dictionary.",
            "",
            "    Example args:",
            "        d = {\"something\": {\"nested\": \"1{thing}1\"},",
            "        replacements = {\"thing\": \"toreplace\", \"thing2\": \"dontreplace\"}",
            "    Returns: {\"something\": {\"nested\": \"1toreplace1\"}",
            "",
            "",
            "    :param d:",
            "    :param replacements:",
            "    :return:",
            "    \"\"\"",
            "    for k, v in d.items():",
            "        if isinstance(v, dict):",
            "            await iterate_and_format_dict(v, replacements)",
            "        else:",
            "            try:",
            "                d[k] = v.format(**replacements)",
            "            except KeyError:",
            "                pass",
            "    return d",
            "",
            "",
            "async def should_force_redirect(req):",
            "    \"\"\"",
            "    ConsoleMe should only force a 302 redirect for non-XHR requests",
            "    \"\"\"",
            "    if req.headers.get(\"X-Requested-With\", \"\") == \"XMLHttpRequest\":",
            "        return False",
            "    if req.headers.get(\"Accept\") == \"application/json\":",
            "        return False",
            "    return True",
            "",
            "",
            "def sort_dict(original):",
            "    \"\"\"Recursively sorts dictionary keys and dictionary values in alphabetical order\"\"\"",
            "    if isinstance(original, dict):",
            "        res = (",
            "            dict()",
            "        )  # Make a new \"ordered\" dictionary. No need for Collections in Python 3.7+",
            "        for k, v in sorted(original.items()):",
            "            res[k] = v",
            "        d = res",
            "    else:",
            "        d = original",
            "    for k in d:",
            "        if isinstance(d[k], str):",
            "            continue",
            "        if isinstance(d[k], list) and len(d[k]) > 1 and isinstance(d[k][0], str):",
            "            d[k] = sorted(d[k])",
            "        if isinstance(d[k], dict):",
            "            d[k] = sort_dict(d[k])",
            "        if isinstance(d[k], list) and len(d[k]) >= 1 and isinstance(d[k][0], dict):",
            "            for i in range(len(d[k])):",
            "                d[k][i] = sort_dict(d[k][i])",
            "    return d",
            "",
            "",
            "def un_wrap_json(json_obj: Any) -> Any:",
            "    \"\"\"Helper function to unwrap nested JSON in the AWS Config resource configuration.\"\"\"",
            "    # pylint: disable=C0103,W0703,R0911",
            "    # Is this a field that we can safely return?",
            "    if isinstance(json_obj, (type(None), int, bool, float)):  # noqa",
            "        return json_obj",
            "    # Is this a Datetime? Convert it to a string and return it:",
            "    if isinstance(json_obj, datetime):",
            "        return str(json_obj)",
            "    # Is this a Dictionary?",
            "    if isinstance(json_obj, dict):",
            "        decoded = {}",
            "        for k, v in json_obj.items():",
            "            decoded[k] = un_wrap_json(v)",
            "    # Is this a List?",
            "    elif isinstance(json_obj, list):",
            "        decoded = []",
            "        for x in json_obj:",
            "            decoded.append(un_wrap_json(x))",
            "        # Yes, try to sort the contents of lists. This is because AWS does not consistently store list ordering for many resource types:",
            "        try:",
            "            sorted_list = sorted(decoded)",
            "            decoded = sorted_list",
            "        except Exception:  # noqa  # nosec   # If we can't sort then NBD",
            "            pass",
            "    else:",
            "        # Try to load the JSON string:",
            "        try:",
            "            # Check if the string starts with a \"[\" or a \"{\" (because apparently '123' is a valid JSON)",
            "            for check_field in {",
            "                \"{\",",
            "                \"[\",",
            "                '\"{',",
            "                '\"[',",
            "            }:  # Some of the double-wrapping is really ridiculous",
            "                if json_obj.startswith(check_field):",
            "                    decoded = json.loads(json_obj)",
            "                    # If we loaded this properly, then we need to pass the decoded JSON back in for all the nested stuff:",
            "                    return un_wrap_json(decoded)",
            "            # Check if this string is URL Encoded - if it is, then re-run it through:",
            "            decoded = unquote_plus(json_obj)",
            "            if decoded != json_obj:",
            "                return un_wrap_json(decoded)",
            "            return json_obj",
            "        # If we didn't get a JSON back (exception), then just return the raw value back:",
            "        except Exception:  # noqa",
            "            return json_obj",
            "    return decoded",
            "",
            "",
            "def un_wrap_json_and_dump_values(json_obj: Any) -> Any:",
            "    json_obj = un_wrap_json(json_obj)",
            "    for k, v in json_obj.items():",
            "        json_obj[k] = json.dumps(v)",
            "    return json_obj",
            "",
            "",
            "async def get_principal_friendly_name(principal):",
            "    if isinstance(principal, HoneybeeAwsResourceTemplatePrincipalModel):",
            "        return principal.resource_identifier",
            "    if isinstance(principal, AwsResourcePrincipalModel):",
            "        return principal.principal_arn",
            "    raise MissingRequestParameter(\"Unable to determine principal\")",
            "",
            "",
            "class Struct:",
            "    def __init__(self, **entries):",
            "        self.__dict__.update(entries)"
        ],
        "afterPatchFile": [
            "import random",
            "import re",
            "import string",
            "from datetime import datetime",
            "from random import randint",
            "from typing import Any, Dict, List, Optional, Union",
            "from urllib.parse import unquote_plus",
            "",
            "import pandas as pd",
            "import ujson as json",
            "from dateutil import parser",
            "",
            "from consoleme.config import config",
            "from consoleme.exceptions.exceptions import MissingRequestParameter",
            "from consoleme.models import (",
            "    AwsResourcePrincipalModel,",
            "    HoneybeeAwsResourceTemplatePrincipalModel,",
            ")",
            "",
            "",
            "def str2bool(v: Optional[Union[bool, str]]) -> bool:",
            "    if isinstance(v, bytes):",
            "        v = v.decode()",
            "    if not v:",
            "        return False",
            "    if type(v) is bool and v is True:",
            "        return True",
            "    return v.lower() in [\"true\", \"True\"]",
            "",
            "",
            "# Yield successive n-sized",
            "# chunks from list list_.",
            "def divide_chunks(list_, n):",
            "    \"\"\"",
            "    Yields successive n=zied chunks from list l by looping",
            "    until length l.",
            "",
            "    `divide_chunks([\"a\",\"b\",\"c\",\"d\",\"e\"], 2)` yields:",
            "    ['a', 'b', 'c']",
            "    ['d', 'e']",
            "    \"\"\"",
            "    for i in range(0, len(list_), n):",
            "        yield list_[i : i + n]",
            "",
            "",
            "def generate_html(d: List[Dict[str, Union[str, bool]]]) -> str:",
            "    \"\"\"",
            "    Pass in a dict with a list of rows to include in a formatted table. This will return the HTML for the table.",
            "",
            "    :param d:",
            "    :return:",
            "        html: HTML formatted table",
            "    \"\"\"",
            "    if not d:",
            "        return",
            "    pd.set_option(\"display.max_colwidth\", -1)",
            "    df = pd.DataFrame(d)",
            "    html = df.to_html(classes=[\"ui\", \"celled\", \"table\"], escape=False, index=False)",
            "    return html",
            "",
            "",
            "def auto_split(s: str) -> List[str]:",
            "    results = []",
            "",
            "    for i in s.splitlines():",
            "        results.extend(i.split(\",\"))",
            "    return results",
            "",
            "",
            "def is_valid_role_arn(arn: str) -> bool:",
            "    # This is valid enough as far as we are concerned.",
            "    if not arn.startswith(\"arn:aws:iam::\"):",
            "        return False",
            "    return True",
            "",
            "",
            "def regex_filter(",
            "    filter: Dict[str, str], items: List[Dict[str, Union[str, None, bool]]]",
            ") -> List[Dict[str, Union[str, None, bool]]]:",
            "    if filter.get(\"filter\"):",
            "        results = []",
            "        if filter.get(\"type\", \"\") == \"date\":",
            "            from_date = None",
            "            to_date = None",
            "            try:",
            "                if filter.get(\"from_date\"):",
            "                    from_date = parser.parse(filter.get(\"from_date\"))",
            "                if filter.get(\"to_date\"):",
            "                    to_date = parser.parse(filter.get(\"to_date\"))",
            "                if not from_date and not to_date:",
            "                    return items",
            "            except:  # noqa",
            "                # Unable to parse date. Return items.",
            "                return results",
            "            for item in items:",
            "                item_date = parser.parse(",
            "                    item.get(filter.get(\"field\"))",
            "                )  # What if invalid date",
            "                if from_date and to_date and from_date <= item_date <= to_date:",
            "                    results.append(item)",
            "                    continue",
            "                if from_date and not to_date and item_date >= from_date:",
            "                    results.append(item)",
            "                    continue",
            "                if to_date and not from_date and item_date <= to_date:",
            "                    results.append(item)",
            "                    continue",
            "            return results",
            "        else:",
            "            regexp = re.compile(r\"{}\".format(filter.get(\"filter\")), re.IGNORECASE)",
            "            for item in items:",
            "                try:",
            "                    if regexp.search(item.get(filter.get(\"field\"))):",
            "                        results.append(item)",
            "                except re.error:",
            "                    # Regex error. Return no results",
            "                    pass",
            "            return results",
            "    else:",
            "        return items",
            "",
            "",
            "def is_in_group(",
            "    user: str, user_groups: List[str], required_groups: Union[List[str], str]",
            ") -> bool:",
            "    if isinstance(required_groups, str):",
            "        required_groups = [required_groups]",
            "    for group in required_groups:",
            "        if group in user_groups or user == group:",
            "            return True",
            "    return False",
            "",
            "",
            "async def write_json_error(message, obj):",
            "    result = {\"status\": \"error\", \"message\": message}",
            "    obj.write(json.dumps(result))",
            "    obj.finish()",
            "",
            "",
            "async def sort_nested_dictionary_lists(d):",
            "    for k, v in d.items():",
            "        if isinstance(v, list):",
            "            for i in range(0, len(v)):",
            "                if isinstance(v[i], dict):",
            "                    v[i] = await sort_nested_dictionary_lists(v[i])",
            "                d[k] = sorted(v)",
            "        if isinstance(v, dict):",
            "            d[k] = await sort_nested_dictionary_lists(v)",
            "    return d",
            "",
            "",
            "def is_in_time_range(t, time_range):",
            "    valid_days = time_range.get(\"days\")",
            "    if t.weekday() not in valid_days:",
            "        return False",
            "    valid_start_time = t.replace(",
            "        hour=time_range.get(\"hour_start\", 0),",
            "        minute=time_range.get(\"minute_start\", 0),",
            "        second=0,",
            "        microsecond=0,",
            "    )",
            "    valid_end_time = t.replace(",
            "        hour=time_range.get(\"hour_end\", 0),",
            "        minute=time_range.get(\"minute_end\", 0),",
            "        second=0,",
            "        microsecond=0,",
            "    )",
            "    if t < valid_start_time or t > valid_end_time:",
            "        return False",
            "    return True",
            "",
            "",
            "async def get_random_security_logo():",
            "    if config.get(\"consoleme_logo.image\"):",
            "        return config.get(\"consoleme_logo.image\")",
            "    month = datetime.now().month",
            "    summer = month in [6, 7, 8]",
            "",
            "    dir = \"sunglasses\" if summer else \"nosunglasses\"",
            "    file = f\"{randint(1, 3)}.png\"  # nosec",
            "    return f\"/images/logos/{dir}/{file}\"",
            "",
            "",
            "async def generate_random_string(string_length=4):",
            "    letters = string.ascii_lowercase",
            "    return \"\".join(random.choice(letters) for i in range(string_length))  # nosec",
            "",
            "",
            "async def filter_table(filter_key, filter_value, data):",
            "    if not (filter_key and filter_value):",
            "        # Filter parameters are incorrect. Don't filter",
            "        return data",
            "    results = []",
            "    if isinstance(filter_value, str):",
            "        try:",
            "            regexp = re.compile(r\"{}\".format(str(filter_value).strip()), re.IGNORECASE)",
            "        except:  # noqa",
            "            # Regex is incorrect. Don't filter",
            "            return data",
            "",
            "        for d in data:",
            "            try:",
            "                if regexp.search(str(d.get(filter_key))):",
            "                    results.append(d)",
            "            except re.error:",
            "                # Regex error. Return no results",
            "                pass",
            "        return results",
            "    elif (",
            "        isinstance(filter_value, list)",
            "        and len(filter_value) == 2",
            "        and isinstance(filter_value[0], int)",
            "        and isinstance(filter_value[1], int)",
            "    ):",
            "        # Handles epoch time filter. We expect a start_time and an end_time in",
            "        # a list of elements, and they should be integers",
            "        for d in data:",
            "            if filter_value[0] < int(d.get(filter_key)) < filter_value[1]:",
            "                results.append(d)",
            "        return results",
            "",
            "",
            "async def iterate_and_format_dict(d: Dict, replacements: Dict):",
            "    \"\"\"",
            "    Iterates through the values of a dictionary (with or without nested dictionaries), and formats values accordingly",
            "    if they exist in the `replacements` dictionary.",
            "",
            "    Example args:",
            "        d = {\"something\": {\"nested\": \"1{thing}1\"},",
            "        replacements = {\"thing\": \"toreplace\", \"thing2\": \"dontreplace\"}",
            "    Returns: {\"something\": {\"nested\": \"1toreplace1\"}",
            "",
            "",
            "    :param d:",
            "    :param replacements:",
            "    :return:",
            "    \"\"\"",
            "    for k, v in d.items():",
            "        if isinstance(v, dict):",
            "            await iterate_and_format_dict(v, replacements)",
            "        else:",
            "            try:",
            "                s = string.Template(v)",
            "                d[k] = s.safe_substitute(**replacements)",
            "            except KeyError:",
            "                pass",
            "    return d",
            "",
            "",
            "async def should_force_redirect(req):",
            "    \"\"\"",
            "    ConsoleMe should only force a 302 redirect for non-XHR requests",
            "    \"\"\"",
            "    if req.headers.get(\"X-Requested-With\", \"\") == \"XMLHttpRequest\":",
            "        return False",
            "    if req.headers.get(\"Accept\") == \"application/json\":",
            "        return False",
            "    return True",
            "",
            "",
            "def sort_dict(original):",
            "    \"\"\"Recursively sorts dictionary keys and dictionary values in alphabetical order\"\"\"",
            "    if isinstance(original, dict):",
            "        res = (",
            "            dict()",
            "        )  # Make a new \"ordered\" dictionary. No need for Collections in Python 3.7+",
            "        for k, v in sorted(original.items()):",
            "            res[k] = v",
            "        d = res",
            "    else:",
            "        d = original",
            "    for k in d:",
            "        if isinstance(d[k], str):",
            "            continue",
            "        if isinstance(d[k], list) and len(d[k]) > 1 and isinstance(d[k][0], str):",
            "            d[k] = sorted(d[k])",
            "        if isinstance(d[k], dict):",
            "            d[k] = sort_dict(d[k])",
            "        if isinstance(d[k], list) and len(d[k]) >= 1 and isinstance(d[k][0], dict):",
            "            for i in range(len(d[k])):",
            "                d[k][i] = sort_dict(d[k][i])",
            "    return d",
            "",
            "",
            "def un_wrap_json(json_obj: Any) -> Any:",
            "    \"\"\"Helper function to unwrap nested JSON in the AWS Config resource configuration.\"\"\"",
            "    # pylint: disable=C0103,W0703,R0911",
            "    # Is this a field that we can safely return?",
            "    if isinstance(json_obj, (type(None), int, bool, float)):  # noqa",
            "        return json_obj",
            "    # Is this a Datetime? Convert it to a string and return it:",
            "    if isinstance(json_obj, datetime):",
            "        return str(json_obj)",
            "    # Is this a Dictionary?",
            "    if isinstance(json_obj, dict):",
            "        decoded = {}",
            "        for k, v in json_obj.items():",
            "            decoded[k] = un_wrap_json(v)",
            "    # Is this a List?",
            "    elif isinstance(json_obj, list):",
            "        decoded = []",
            "        for x in json_obj:",
            "            decoded.append(un_wrap_json(x))",
            "        # Yes, try to sort the contents of lists. This is because AWS does not consistently store list ordering for many resource types:",
            "        try:",
            "            sorted_list = sorted(decoded)",
            "            decoded = sorted_list",
            "        except Exception:  # noqa  # nosec   # If we can't sort then NBD",
            "            pass",
            "    else:",
            "        # Try to load the JSON string:",
            "        try:",
            "            # Check if the string starts with a \"[\" or a \"{\" (because apparently '123' is a valid JSON)",
            "            for check_field in {",
            "                \"{\",",
            "                \"[\",",
            "                '\"{',",
            "                '\"[',",
            "            }:  # Some of the double-wrapping is really ridiculous",
            "                if json_obj.startswith(check_field):",
            "                    decoded = json.loads(json_obj)",
            "                    # If we loaded this properly, then we need to pass the decoded JSON back in for all the nested stuff:",
            "                    return un_wrap_json(decoded)",
            "            # Check if this string is URL Encoded - if it is, then re-run it through:",
            "            decoded = unquote_plus(json_obj)",
            "            if decoded != json_obj:",
            "                return un_wrap_json(decoded)",
            "            return json_obj",
            "        # If we didn't get a JSON back (exception), then just return the raw value back:",
            "        except Exception:  # noqa",
            "            return json_obj",
            "    return decoded",
            "",
            "",
            "def un_wrap_json_and_dump_values(json_obj: Any) -> Any:",
            "    json_obj = un_wrap_json(json_obj)",
            "    for k, v in json_obj.items():",
            "        json_obj[k] = json.dumps(v)",
            "    return json_obj",
            "",
            "",
            "async def get_principal_friendly_name(principal):",
            "    if isinstance(principal, HoneybeeAwsResourceTemplatePrincipalModel):",
            "        return principal.resource_identifier",
            "    if isinstance(principal, AwsResourcePrincipalModel):",
            "        return principal.principal_arn",
            "    raise MissingRequestParameter(\"Unable to determine principal\")",
            "",
            "",
            "class Struct:",
            "    def __init__(self, **entries):",
            "        self.__dict__.update(entries)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "243": []
        },
        "addLocation": []
    }
}