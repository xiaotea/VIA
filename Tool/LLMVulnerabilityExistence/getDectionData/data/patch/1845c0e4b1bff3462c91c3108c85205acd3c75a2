{
    "oauthenticator/gitlab.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from traitlets import Set"
            },
            "2": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .common import next_page_from_links"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from .oauth2 import OAuthLoginHandler, OAuthenticator"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " # Support gitlab.com and gitlab community edition installations"
            },
            "7": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     def _check_group_whitelist(self, username, user_id, is_admin, access_token):"
            },
            "8": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         http_client = AsyncHTTPClient()"
            },
            "9": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         headers = _api_headers(access_token)"
            },
            "10": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if is_admin:"
            },
            "11": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # For admins, /groups returns *all* groups. As a workaround"
            },
            "12": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # we check if we are a member of each group in the whitelist"
            },
            "13": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            for group in map(url_escape, self.gitlab_group_whitelist):"
            },
            "14": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                url = \"%s/groups/%s/members/%d\" % (GITLAB_API, group, user_id)"
            },
            "15": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req = HTTPRequest(url, method=\"GET\", headers=headers)"
            },
            "16": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                resp = yield http_client.fetch(req, raise_error=False)"
            },
            "17": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if resp.code == 200:"
            },
            "18": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return True  # user _is_ in group"
            },
            "19": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "20": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # For regular users we get all the groups to which they have access"
            },
            "21": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # and check if any of these are in the whitelisted groups"
            },
            "22": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            next_page = url_concat(\"%s/groups\" % GITLAB_API,"
            },
            "23": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   dict(all_available=True))"
            },
            "24": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            while next_page:"
            },
            "25": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                req = HTTPRequest(next_page, method=\"GET\", headers=headers)"
            },
            "26": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                resp = yield http_client.fetch(req)"
            },
            "27": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                resp_json = json.loads(resp.body.decode('utf8', 'replace'))"
            },
            "28": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                next_page = next_page_from_links(resp)"
            },
            "29": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                user_groups = set(entry[\"path\"] for entry in resp_json)"
            },
            "30": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # check if any of the organizations seen thus far are in whitelist"
            },
            "31": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if len(self.gitlab_group_whitelist & user_groups) > 0:"
            },
            "32": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    return True"
            },
            "33": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return False"
            },
            "34": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+        # Check if we are a member of each group in the whitelist"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        for group in map(url_escape, self.gitlab_group_whitelist):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+            url = \"%s/groups/%s/members/%d\" % (GITLAB_API, group, user_id)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+            req = HTTPRequest(url, method=\"GET\", headers=headers)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+            resp = yield http_client.fetch(req, raise_error=False)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            if resp.code == 200:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+                return True  # user _is_ in group"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+        return False"
            },
            "43": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "45": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " class LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use GitLab OAuth with JupyterHub",
            "",
            "Modified for GitLab by Laszlo Dobos (@dobos)",
            "based on the GitHub plugin by Kyle Kelley (@rgbkrk)",
            "\"\"\"",
            "",
            "",
            "import json",
            "import os",
            "import sys",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import gen, web",
            "",
            "from tornado.escape import url_escape",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import Set",
            "",
            "from .common import next_page_from_links",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "# Support gitlab.com and gitlab community edition installations",
            "GITLAB_HOST = os.environ.get('GITLAB_HOST') or 'https://gitlab.com'",
            "GITLAB_API_VERSION = os.environ.get('GITLAB_API_VERSION') or '4'",
            "GITLAB_API = '%s/api/v%s' % (GITLAB_HOST, GITLAB_API_VERSION)",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {\"Accept\": \"application/json\",",
            "            \"User-Agent\": \"JupyterHub\",",
            "            \"Authorization\": \"Bearer {}\".format(access_token)",
            "           }",
            "",
            "",
            "class GitLabMixin(OAuth2Mixin):",
            "    _OAUTH_AUTHORIZE_URL = \"%s/oauth/authorize\" % GITLAB_HOST",
            "    _OAUTH_ACCESS_TOKEN_URL = \"%s/oauth/access_token\" % GITLAB_HOST",
            "",
            "",
            "class GitLabLoginHandler(OAuthLoginHandler, GitLabMixin):",
            "    pass",
            "",
            "",
            "class GitLabOAuthenticator(OAuthenticator):",
            "",
            "    login_service = \"GitLab\"",
            "",
            "    client_id_env = 'GITLAB_CLIENT_ID'",
            "    client_secret_env = 'GITLAB_CLIENT_SECRET'",
            "    login_handler = GitLabLoginHandler",
            "",
            "    gitlab_group_whitelist = Set(",
            "        config=True,",
            "        help=\"Automatically whitelist members of selected groups\",",
            "    )",
            "",
            "",
            "    @gen.coroutine",
            "    def authenticate(self, handler, data=None):",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a GitLab Access Token",
            "        #",
            "        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md",
            "",
            "        # GitLab specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            code=code,",
            "            grant_type=\"authorization_code\",",
            "            redirect_uri=self.get_callback_url(handler),",
            "        )",
            "",
            "",
            "        validate_server_cert = self.validate_server_cert",
            "",
            "        url = url_concat(\"%s/oauth/token\" % GITLAB_HOST,",
            "                         params)",
            "",
            "        req = HTTPRequest(url,",
            "                          method=\"POST\",",
            "                          headers={\"Accept\": \"application/json\"},",
            "                          validate_cert=validate_server_cert,",
            "                          body='' # Body is required for a POST...",
            "                          )",
            "",
            "        resp = yield http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        access_token = resp_json['access_token']",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(\"%s/user\" % GITLAB_API,",
            "                          method=\"GET\",",
            "                          validate_cert=validate_server_cert,",
            "                          headers=_api_headers(access_token)",
            "                          )",
            "        resp = yield http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"username\"]",
            "        user_id = resp_json[\"id\"]",
            "        is_admin = resp_json.get(\"is_admin\", False)",
            "",
            "        # Check if user is a member of any whitelisted organizations.",
            "        # This check is performed here, as it requires `access_token`.",
            "        if self.gitlab_group_whitelist:",
            "            user_in_group = yield self._check_group_whitelist(",
            "                username, user_id, is_admin, access_token)",
            "            if not user_in_group:",
            "                self.log.warning(\"%s not in group whitelist\", username)",
            "                return None",
            "        return {",
            "            'name': username,",
            "            'auth_state': {",
            "                'access_token': access_token,",
            "                'gitlab_user': resp_json,",
            "            }",
            "        }",
            "",
            "",
            "    @gen.coroutine",
            "    def _check_group_whitelist(self, username, user_id, is_admin, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        if is_admin:",
            "            # For admins, /groups returns *all* groups. As a workaround",
            "            # we check if we are a member of each group in the whitelist",
            "            for group in map(url_escape, self.gitlab_group_whitelist):",
            "                url = \"%s/groups/%s/members/%d\" % (GITLAB_API, group, user_id)",
            "                req = HTTPRequest(url, method=\"GET\", headers=headers)",
            "                resp = yield http_client.fetch(req, raise_error=False)",
            "                if resp.code == 200:",
            "                    return True  # user _is_ in group",
            "        else:",
            "            # For regular users we get all the groups to which they have access",
            "            # and check if any of these are in the whitelisted groups",
            "            next_page = url_concat(\"%s/groups\" % GITLAB_API,",
            "                                   dict(all_available=True))",
            "            while next_page:",
            "                req = HTTPRequest(next_page, method=\"GET\", headers=headers)",
            "                resp = yield http_client.fetch(req)",
            "                resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "                next_page = next_page_from_links(resp)",
            "                user_groups = set(entry[\"path\"] for entry in resp_json)",
            "                # check if any of the organizations seen thus far are in whitelist",
            "                if len(self.gitlab_group_whitelist & user_groups) > 0:",
            "                    return True",
            "            return False",
            "",
            "",
            "",
            "class LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "    pass"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Custom Authenticator to use GitLab OAuth with JupyterHub",
            "",
            "Modified for GitLab by Laszlo Dobos (@dobos)",
            "based on the GitHub plugin by Kyle Kelley (@rgbkrk)",
            "\"\"\"",
            "",
            "",
            "import json",
            "import os",
            "import sys",
            "",
            "from tornado.auth import OAuth2Mixin",
            "from tornado import gen, web",
            "",
            "from tornado.escape import url_escape",
            "from tornado.httputil import url_concat",
            "from tornado.httpclient import HTTPRequest, AsyncHTTPClient",
            "",
            "from jupyterhub.auth import LocalAuthenticator",
            "",
            "from traitlets import Set",
            "",
            "from .oauth2 import OAuthLoginHandler, OAuthenticator",
            "",
            "# Support gitlab.com and gitlab community edition installations",
            "GITLAB_HOST = os.environ.get('GITLAB_HOST') or 'https://gitlab.com'",
            "GITLAB_API_VERSION = os.environ.get('GITLAB_API_VERSION') or '4'",
            "GITLAB_API = '%s/api/v%s' % (GITLAB_HOST, GITLAB_API_VERSION)",
            "",
            "",
            "def _api_headers(access_token):",
            "    return {\"Accept\": \"application/json\",",
            "            \"User-Agent\": \"JupyterHub\",",
            "            \"Authorization\": \"Bearer {}\".format(access_token)",
            "           }",
            "",
            "",
            "class GitLabMixin(OAuth2Mixin):",
            "    _OAUTH_AUTHORIZE_URL = \"%s/oauth/authorize\" % GITLAB_HOST",
            "    _OAUTH_ACCESS_TOKEN_URL = \"%s/oauth/access_token\" % GITLAB_HOST",
            "",
            "",
            "class GitLabLoginHandler(OAuthLoginHandler, GitLabMixin):",
            "    pass",
            "",
            "",
            "class GitLabOAuthenticator(OAuthenticator):",
            "",
            "    login_service = \"GitLab\"",
            "",
            "    client_id_env = 'GITLAB_CLIENT_ID'",
            "    client_secret_env = 'GITLAB_CLIENT_SECRET'",
            "    login_handler = GitLabLoginHandler",
            "",
            "    gitlab_group_whitelist = Set(",
            "        config=True,",
            "        help=\"Automatically whitelist members of selected groups\",",
            "    )",
            "",
            "",
            "    @gen.coroutine",
            "    def authenticate(self, handler, data=None):",
            "        code = handler.get_argument(\"code\")",
            "        # TODO: Configure the curl_httpclient for tornado",
            "        http_client = AsyncHTTPClient()",
            "",
            "        # Exchange the OAuth code for a GitLab Access Token",
            "        #",
            "        # See: https://github.com/gitlabhq/gitlabhq/blob/master/doc/api/oauth2.md",
            "",
            "        # GitLab specifies a POST request yet requires URL parameters",
            "        params = dict(",
            "            client_id=self.client_id,",
            "            client_secret=self.client_secret,",
            "            code=code,",
            "            grant_type=\"authorization_code\",",
            "            redirect_uri=self.get_callback_url(handler),",
            "        )",
            "",
            "",
            "        validate_server_cert = self.validate_server_cert",
            "",
            "        url = url_concat(\"%s/oauth/token\" % GITLAB_HOST,",
            "                         params)",
            "",
            "        req = HTTPRequest(url,",
            "                          method=\"POST\",",
            "                          headers={\"Accept\": \"application/json\"},",
            "                          validate_cert=validate_server_cert,",
            "                          body='' # Body is required for a POST...",
            "                          )",
            "",
            "        resp = yield http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        access_token = resp_json['access_token']",
            "",
            "        # Determine who the logged in user is",
            "        req = HTTPRequest(\"%s/user\" % GITLAB_API,",
            "                          method=\"GET\",",
            "                          validate_cert=validate_server_cert,",
            "                          headers=_api_headers(access_token)",
            "                          )",
            "        resp = yield http_client.fetch(req)",
            "        resp_json = json.loads(resp.body.decode('utf8', 'replace'))",
            "",
            "        username = resp_json[\"username\"]",
            "        user_id = resp_json[\"id\"]",
            "        is_admin = resp_json.get(\"is_admin\", False)",
            "",
            "        # Check if user is a member of any whitelisted organizations.",
            "        # This check is performed here, as it requires `access_token`.",
            "        if self.gitlab_group_whitelist:",
            "            user_in_group = yield self._check_group_whitelist(",
            "                username, user_id, is_admin, access_token)",
            "            if not user_in_group:",
            "                self.log.warning(\"%s not in group whitelist\", username)",
            "                return None",
            "        return {",
            "            'name': username,",
            "            'auth_state': {",
            "                'access_token': access_token,",
            "                'gitlab_user': resp_json,",
            "            }",
            "        }",
            "",
            "",
            "    @gen.coroutine",
            "    def _check_group_whitelist(self, username, user_id, is_admin, access_token):",
            "        http_client = AsyncHTTPClient()",
            "        headers = _api_headers(access_token)",
            "        # Check if we are a member of each group in the whitelist",
            "        for group in map(url_escape, self.gitlab_group_whitelist):",
            "            url = \"%s/groups/%s/members/%d\" % (GITLAB_API, group, user_id)",
            "            req = HTTPRequest(url, method=\"GET\", headers=headers)",
            "            resp = yield http_client.fetch(req, raise_error=False)",
            "            if resp.code == 200:",
            "                return True  # user _is_ in group",
            "        return False",
            "",
            "",
            "class LocalGitLabOAuthenticator(LocalAuthenticator, GitLabOAuthenticator):",
            "",
            "    \"\"\"A version that mixes in local system user creation\"\"\"",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "24": [],
            "134": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "135": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "136": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "137": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "138": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "139": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "140": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "141": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "142": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "143": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "144": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "145": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "146": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "147": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "148": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "149": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "150": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "151": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "152": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "153": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "154": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "155": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "156": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "157": [
                "GitLabOAuthenticator",
                "_check_group_whitelist"
            ],
            "158": []
        },
        "addLocation": []
    }
}