{
    "MoinMoin/security/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "                 handler = getattr(self, \"_special_\"+entry, None)"
            },
            "1": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "                 allowed = handler(name, dowhat, rightsdict)"
            },
            "2": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "             elif entry in groups:"
            },
            "3": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if name in groups[entry]:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                this_group = groups[entry]"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                if name in this_group:"
            },
            "6": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "                     allowed = rightsdict.get(dowhat)"
            },
            "7": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "                 else:"
            },
            "8": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "                     for special in self.special_users:"
            },
            "9": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        if special in entry:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+                        if special in this_group:"
            },
            "11": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "                             handler = getattr(self, \"_special_\" + special, None)"
            },
            "12": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "                             allowed = handler(name, dowhat, rightsdict)"
            },
            "13": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "                             break # order of self.special_users is important"
            }
        },
        "frontPatchFile": [
            "# Copyright: 2000-2004 Juergen Hermann <jh@web.de>",
            "# Copyright: 2003-2008,2011 MoinMoin:ThomasWaldmann",
            "# Copyright: 2003 Gustavo Niemeyer",
            "# Copyright: 2005 Oliver Graf",
            "# Copyright: 2007 Alexander Schremmer",
            "# License: GNU GPL v2 (or any later version), see LICENSE.txt for details.",
            "",
            "\"\"\"",
            "MoinMoin - Wiki Security Interface and Access Control Lists",
            "",
            "",
            "This implements the basic interface for user permissions and",
            "system policy. If you want to define your own policy, inherit",
            "from the base class 'Permissions', so that when new permissions",
            "are defined, you get the defaults.",
            "",
            "Then assign your new class to \"SecurityPolicy\" in wikiconfig;",
            "and I mean the class, not an instance of it!",
            "\"\"\"",
            "",
            "",
            "from functools import wraps",
            "",
            "from flask import current_app as app",
            "from flask import g as flaskg",
            "from flask import abort",
            "",
            "from MoinMoin import user",
            "from MoinMoin.i18n import _, L_, N_",
            "",
            "",
            "def require_permission(permission):",
            "    \"\"\"",
            "    view decorator to require a specific permission",
            "",
            "    if the permission is not granted, abort with 403",
            "    \"\"\"",
            "    def wrap(f):",
            "        @wraps(f)",
            "        def wrapped_f(*args, **kw):",
            "            has_permission = getattr(flaskg.user.may, permission)",
            "            if not has_permission():",
            "                abort(403)",
            "            return f(*args, **kw)",
            "        return wrapped_f",
            "    return wrap",
            "",
            "",
            "class Permissions(object):",
            "    \"\"\" Basic interface for user permissions and system policy.",
            "",
            "    Note that you still need to allow some of the related actions, this",
            "    just controls their behavior, not their activation.",
            "",
            "    When sub classing this class, you must extend the class methods, not",
            "    replace them, or you might break the ACLs in the wiki.",
            "    Correct sub classing looks like this::",
            "",
            "        def read(self, itemname):",
            "            # Your special security rule",
            "            if something:",
            "                return False",
            "",
            "            # Do not just return True or you break (ignore) ACLs!",
            "            # This call will return correct permissions by checking ACLs:",
            "            return Permissions.read(itemname)",
            "    \"\"\"",
            "    def __init__(self, user):",
            "        self.name = user.name",
            "",
            "    def __getattr__(self, attr):",
            "        \"\"\" Shortcut to handle all known ACL rights.",
            "",
            "        if attr is a valid acl right, return a checking function for it.",
            "        Else raise an AttributeError.",
            "",
            "        :param attr: one of ACL rights as defined in acl_rights_(contents|functions)",
            "        :rtype: function",
            "        :returns: checking function for that right",
            "        \"\"\"",
            "        if attr in app.cfg.acl_rights_contents:",
            "            return lambda itemname: flaskg.storage.may(itemname, attr, username=self.name)",
            "        if attr in app.cfg.acl_rights_functions:",
            "            may = app.cfg.cache.acl_functions.may",
            "            return lambda: may(self.name, attr)",
            "        raise AttributeError(attr)",
            "",
            "",
            "# make an alias for the default policy",
            "Default = Permissions",
            "",
            "",
            "class AccessControlList(object):",
            "    \"\"\"",
            "    Access Control List - controls who may do what.",
            "",
            "    Syntax of an ACL string:",
            "",
            "        [+|-]User[,User,...]:[right[,right,...]] [[+|-]SomeGroup:...] ...",
            "        ... [[+|-]Known:...] [[+|-]All:...]",
            "",
            "        \"User\" is a user name and triggers only if the user matches.",
            "        Any name can be used in acl lines, including names with spaces",
            "        using exotic languages.",
            "",
            "        \"SomeGroup\" is a group name. The group defines its members somehow,",
            "        e.g. on a wiki page of this name as first level list with the group",
            "        members' names.",
            "",
            "        \"Known\" is a special group containing all valid / known users.",
            "",
            "        \"All\" is a special group containing all users (Known and Anonymous users).",
            "",
            "        \"right\" may be an arbitrary word like read, write or admin.",
            "        Only valid words are accepted, others are ignored (see valid param).",
            "        It is allowed to specify no rights, which means that no rights are given.",
            "",
            "    How ACL is processed",
            "",
            "        When some user is trying to access some ACL-protected resource,",
            "        the ACLs will be processed in the order they are found. The first",
            "        matching ACL will tell if the user has access to that resource",
            "        or not.",
            "",
            "        For example, the following ACL tells that SomeUser is able to",
            "        read and write the resources protected by that ACL, while any",
            "        member of SomeGroup (besides SomeUser, if part of that group)",
            "        may also admin that, and every other user is able to read it.",
            "",
            "            SomeUser:read,write SomeGroup:read,write,admin All:read",
            "",
            "        In this example, SomeUser can read and write but can not admin",
            "        items. Rights that are NOT specified on the right list are",
            "        automatically set to NO.",
            "",
            "    Using Prefixes",
            "",
            "        To make the system more flexible, there are also two modifiers:",
            "        the prefixes \"+\" and \"-\".",
            "",
            "            +SomeUser:read -OtherUser:write",
            "",
            "        The acl line above will grant SomeUser read right, and OtherUser",
            "        write right, but will NOT block automatically all other rights",
            "        for these users. For example, if SomeUser asks to write, the",
            "        above acl line does not define if he can or can not write. He",
            "        will be able to write if the acls checked before or afterwards",
            "        allow this (see configuration options).",
            "",
            "        Using prefixes, this acl line:",
            "",
            "            SomeUser:read,write SomeGroup:read,write,admin All:read",
            "",
            "        Can be written as:",
            "",
            "            -SomeUser:admin SomeGroup:read,write,admin All:read",
            "",
            "        Or even:",
            "",
            "            +All:read -SomeUser:admin SomeGroup:read,write,admin",
            "",
            "        Note that you probably would not want to use the second and",
            "        third examples in ACL entries of some item. They are very",
            "        useful in the wiki configuration though.",
            "    \"\"\"",
            "",
            "    special_users = [\"All\", \"Known\", \"Trusted\"] # order is important",
            "",
            "    def __init__(self, lines=[], default='', valid=None):",
            "        \"\"\" Initialize an ACL, starting from <nothing>.",
            "        \"\"\"",
            "        assert valid is not None",
            "        self.acl_rights_valid = valid",
            "        self.default = default",
            "        assert isinstance(lines, (list, tuple))",
            "        if lines:",
            "            self.acl = [] # [ ('User', {\"read\": 0, ...}), ... ]",
            "            self.acl_lines = []",
            "            for line in lines:",
            "                self._addLine(line)",
            "        else:",
            "            self.acl = None",
            "            self.acl_lines = None",
            "",
            "    def has_acl(self):",
            "        \"\"\" Checks whether we have a real acl here. \"\"\"",
            "        # self.acl == None means that there is NO acl.",
            "        # self.acl == [] means that there is a empty acl.",
            "        return self.acl is not None",
            "",
            "    def _addLine(self, aclstring, remember=1):",
            "        \"\"\" Add another ACL line",
            "",
            "        This can be used in multiple subsequent calls to process longer lists.",
            "",
            "        :param aclstring: acl string from item or configuration",
            "        :param remember: should add the line to self.acl_lines",
            "        \"\"\"",
            "        # Remember lines",
            "        if remember:",
            "            self.acl_lines.append(aclstring)",
            "",
            "        # Iterate over entries and rights, parsed by acl string iterator",
            "        acliter = ACLStringIterator(self.acl_rights_valid, aclstring)",
            "        for modifier, entries, rights in acliter:",
            "            if entries == ['Default']:",
            "                self._addLine(self.default, remember=0)",
            "            else:",
            "                for entry in entries:",
            "                    rightsdict = {}",
            "                    if modifier:",
            "                        # Only user rights are added to the right dict.",
            "                        # + add right with value of 1",
            "                        # - add right with value of 0",
            "                        for right in rights:",
            "                            rightsdict[right] = (modifier == '+')",
            "                    else:",
            "                        # All rights from acl_rights_valid are added to the",
            "                        # dict, user rights with value of 1, and other with",
            "                        # value of 0",
            "                        for right in self.acl_rights_valid:",
            "                            rightsdict[right] = (right in rights)",
            "                    self.acl.append((entry, rightsdict))",
            "",
            "    def may(self, name, dowhat):",
            "        \"\"\" May <name> <dowhat>? Returns boolean answer.",
            "",
            "            Note: this just checks THIS ACL, the before/default/after ACL must",
            "                  be handled elsewhere, if needed.",
            "        \"\"\"",
            "        groups = flaskg.groups",
            "        allowed = None",
            "        for entry, rightsdict in self.acl:",
            "            if entry in self.special_users:",
            "                handler = getattr(self, \"_special_\"+entry, None)",
            "                allowed = handler(name, dowhat, rightsdict)",
            "            elif entry in groups:",
            "                if name in groups[entry]:",
            "                    allowed = rightsdict.get(dowhat)",
            "                else:",
            "                    for special in self.special_users:",
            "                        if special in entry:",
            "                            handler = getattr(self, \"_special_\" + special, None)",
            "                            allowed = handler(name, dowhat, rightsdict)",
            "                            break # order of self.special_users is important",
            "            elif entry == name:",
            "                allowed = rightsdict.get(dowhat)",
            "            if allowed is not None:",
            "                return allowed",
            "        return allowed # should be None",
            "",
            "    def _special_All(self, name, dowhat, rightsdict):",
            "        return rightsdict.get(dowhat)",
            "",
            "    def _special_Known(self, name, dowhat, rightsdict):",
            "        \"\"\" check if user <name> is known to us,",
            "            that means that there is a valid user account present.",
            "            works for subscription emails.",
            "        \"\"\"",
            "        if user.search_users(name_exact=name): # is a user with this name known?",
            "            return rightsdict.get(dowhat)",
            "        return None",
            "",
            "    def _special_Trusted(self, name, dowhat, rightsdict):",
            "        \"\"\" check if user <name> is the current user AND is has logged in using",
            "            an authentication method that set the trusted attribute.",
            "            Does not work for subsription emails that should be sent to <user>,",
            "            as the user is not logged in in that case.",
            "        \"\"\"",
            "        if flaskg.user.name == name and flaskg.user.trusted:",
            "            return rightsdict.get(dowhat)",
            "        return None",
            "",
            "    def __eq__(self, other):",
            "        return self.acl_lines == other.acl_lines",
            "",
            "    def __ne__(self, other):",
            "        return self.acl_lines != other.acl_lines",
            "",
            "",
            "class ACLStringIterator(object):",
            "    \"\"\" Iterator for acl string",
            "",
            "    Parse acl string and return the next entry on each call to next.",
            "    Implements the Iterator protocol.",
            "",
            "    Usage::",
            "",
            "        iter = ACLStringIterator(rights_valid, 'user name:right')",
            "        for modifier, entries, rights in iter:",
            "            # process data",
            "    \"\"\"",
            "",
            "    def __init__(self, rights, aclstring):",
            "        \"\"\" Initialize acl iterator",
            "",
            "        :param rights: the acl rights to consider when parsing",
            "        :param aclstring: string to parse",
            "        \"\"\"",
            "        self.rights = rights",
            "        self.rest = aclstring.strip()",
            "        self.finished = 0",
            "",
            "    def __iter__(self):",
            "        \"\"\" Required by the Iterator protocol \"\"\"",
            "        return self",
            "",
            "    def next(self):",
            "        \"\"\" Return the next values from the acl string",
            "",
            "        When the iterator is finished and you try to call next, it",
            "        raises a StopIteration. The iterator finishes as soon as the",
            "        string is fully parsed or can not be parsed any more.",
            "",
            "        :rtype: 3 tuple - (modifier, [entry, ...], [right, ...])",
            "        :returns: values for one item in an acl string",
            "        \"\"\"",
            "        # Handle finished state, required by iterator protocol",
            "        if self.rest == '':",
            "            self.finished = 1",
            "        if self.finished:",
            "            raise StopIteration",
            "",
            "        # Get optional modifier [+|-]entries:rights",
            "        modifier = ''",
            "        if self.rest[0] in ('+', '-'):",
            "            modifier, self.rest = self.rest[0], self.rest[1:]",
            "",
            "        # Handle the Default meta acl",
            "        if self.rest.startswith('Default ') or self.rest == 'Default':",
            "            self.rest = self.rest[8:]",
            "            entries, rights = ['Default'], []",
            "",
            "        # Handle entries:rights pairs",
            "        else:",
            "            # Get entries",
            "            try:",
            "                entries, self.rest = self.rest.split(':', 1)",
            "            except ValueError:",
            "                self.finished = 1",
            "                raise StopIteration(\"Can't parse rest of string\")",
            "            if entries == '':",
            "                entries = []",
            "            else:",
            "                # TODO strip each entry from blanks?",
            "                entries = entries.split(',')",
            "",
            "            # Get rights",
            "            try:",
            "                rights, self.rest = self.rest.split(' ', 1)",
            "                # Remove extra white space after rights fragment,",
            "                # allowing using multiple spaces between items.",
            "                self.rest = self.rest.lstrip()",
            "            except ValueError:",
            "                rights, self.rest = self.rest, ''",
            "            rights = [r for r in rights.split(',') if r in self.rights]",
            "",
            "        return modifier, entries, rights"
        ],
        "afterPatchFile": [
            "# Copyright: 2000-2004 Juergen Hermann <jh@web.de>",
            "# Copyright: 2003-2008,2011 MoinMoin:ThomasWaldmann",
            "# Copyright: 2003 Gustavo Niemeyer",
            "# Copyright: 2005 Oliver Graf",
            "# Copyright: 2007 Alexander Schremmer",
            "# License: GNU GPL v2 (or any later version), see LICENSE.txt for details.",
            "",
            "\"\"\"",
            "MoinMoin - Wiki Security Interface and Access Control Lists",
            "",
            "",
            "This implements the basic interface for user permissions and",
            "system policy. If you want to define your own policy, inherit",
            "from the base class 'Permissions', so that when new permissions",
            "are defined, you get the defaults.",
            "",
            "Then assign your new class to \"SecurityPolicy\" in wikiconfig;",
            "and I mean the class, not an instance of it!",
            "\"\"\"",
            "",
            "",
            "from functools import wraps",
            "",
            "from flask import current_app as app",
            "from flask import g as flaskg",
            "from flask import abort",
            "",
            "from MoinMoin import user",
            "from MoinMoin.i18n import _, L_, N_",
            "",
            "",
            "def require_permission(permission):",
            "    \"\"\"",
            "    view decorator to require a specific permission",
            "",
            "    if the permission is not granted, abort with 403",
            "    \"\"\"",
            "    def wrap(f):",
            "        @wraps(f)",
            "        def wrapped_f(*args, **kw):",
            "            has_permission = getattr(flaskg.user.may, permission)",
            "            if not has_permission():",
            "                abort(403)",
            "            return f(*args, **kw)",
            "        return wrapped_f",
            "    return wrap",
            "",
            "",
            "class Permissions(object):",
            "    \"\"\" Basic interface for user permissions and system policy.",
            "",
            "    Note that you still need to allow some of the related actions, this",
            "    just controls their behavior, not their activation.",
            "",
            "    When sub classing this class, you must extend the class methods, not",
            "    replace them, or you might break the ACLs in the wiki.",
            "    Correct sub classing looks like this::",
            "",
            "        def read(self, itemname):",
            "            # Your special security rule",
            "            if something:",
            "                return False",
            "",
            "            # Do not just return True or you break (ignore) ACLs!",
            "            # This call will return correct permissions by checking ACLs:",
            "            return Permissions.read(itemname)",
            "    \"\"\"",
            "    def __init__(self, user):",
            "        self.name = user.name",
            "",
            "    def __getattr__(self, attr):",
            "        \"\"\" Shortcut to handle all known ACL rights.",
            "",
            "        if attr is a valid acl right, return a checking function for it.",
            "        Else raise an AttributeError.",
            "",
            "        :param attr: one of ACL rights as defined in acl_rights_(contents|functions)",
            "        :rtype: function",
            "        :returns: checking function for that right",
            "        \"\"\"",
            "        if attr in app.cfg.acl_rights_contents:",
            "            return lambda itemname: flaskg.storage.may(itemname, attr, username=self.name)",
            "        if attr in app.cfg.acl_rights_functions:",
            "            may = app.cfg.cache.acl_functions.may",
            "            return lambda: may(self.name, attr)",
            "        raise AttributeError(attr)",
            "",
            "",
            "# make an alias for the default policy",
            "Default = Permissions",
            "",
            "",
            "class AccessControlList(object):",
            "    \"\"\"",
            "    Access Control List - controls who may do what.",
            "",
            "    Syntax of an ACL string:",
            "",
            "        [+|-]User[,User,...]:[right[,right,...]] [[+|-]SomeGroup:...] ...",
            "        ... [[+|-]Known:...] [[+|-]All:...]",
            "",
            "        \"User\" is a user name and triggers only if the user matches.",
            "        Any name can be used in acl lines, including names with spaces",
            "        using exotic languages.",
            "",
            "        \"SomeGroup\" is a group name. The group defines its members somehow,",
            "        e.g. on a wiki page of this name as first level list with the group",
            "        members' names.",
            "",
            "        \"Known\" is a special group containing all valid / known users.",
            "",
            "        \"All\" is a special group containing all users (Known and Anonymous users).",
            "",
            "        \"right\" may be an arbitrary word like read, write or admin.",
            "        Only valid words are accepted, others are ignored (see valid param).",
            "        It is allowed to specify no rights, which means that no rights are given.",
            "",
            "    How ACL is processed",
            "",
            "        When some user is trying to access some ACL-protected resource,",
            "        the ACLs will be processed in the order they are found. The first",
            "        matching ACL will tell if the user has access to that resource",
            "        or not.",
            "",
            "        For example, the following ACL tells that SomeUser is able to",
            "        read and write the resources protected by that ACL, while any",
            "        member of SomeGroup (besides SomeUser, if part of that group)",
            "        may also admin that, and every other user is able to read it.",
            "",
            "            SomeUser:read,write SomeGroup:read,write,admin All:read",
            "",
            "        In this example, SomeUser can read and write but can not admin",
            "        items. Rights that are NOT specified on the right list are",
            "        automatically set to NO.",
            "",
            "    Using Prefixes",
            "",
            "        To make the system more flexible, there are also two modifiers:",
            "        the prefixes \"+\" and \"-\".",
            "",
            "            +SomeUser:read -OtherUser:write",
            "",
            "        The acl line above will grant SomeUser read right, and OtherUser",
            "        write right, but will NOT block automatically all other rights",
            "        for these users. For example, if SomeUser asks to write, the",
            "        above acl line does not define if he can or can not write. He",
            "        will be able to write if the acls checked before or afterwards",
            "        allow this (see configuration options).",
            "",
            "        Using prefixes, this acl line:",
            "",
            "            SomeUser:read,write SomeGroup:read,write,admin All:read",
            "",
            "        Can be written as:",
            "",
            "            -SomeUser:admin SomeGroup:read,write,admin All:read",
            "",
            "        Or even:",
            "",
            "            +All:read -SomeUser:admin SomeGroup:read,write,admin",
            "",
            "        Note that you probably would not want to use the second and",
            "        third examples in ACL entries of some item. They are very",
            "        useful in the wiki configuration though.",
            "    \"\"\"",
            "",
            "    special_users = [\"All\", \"Known\", \"Trusted\"] # order is important",
            "",
            "    def __init__(self, lines=[], default='', valid=None):",
            "        \"\"\" Initialize an ACL, starting from <nothing>.",
            "        \"\"\"",
            "        assert valid is not None",
            "        self.acl_rights_valid = valid",
            "        self.default = default",
            "        assert isinstance(lines, (list, tuple))",
            "        if lines:",
            "            self.acl = [] # [ ('User', {\"read\": 0, ...}), ... ]",
            "            self.acl_lines = []",
            "            for line in lines:",
            "                self._addLine(line)",
            "        else:",
            "            self.acl = None",
            "            self.acl_lines = None",
            "",
            "    def has_acl(self):",
            "        \"\"\" Checks whether we have a real acl here. \"\"\"",
            "        # self.acl == None means that there is NO acl.",
            "        # self.acl == [] means that there is a empty acl.",
            "        return self.acl is not None",
            "",
            "    def _addLine(self, aclstring, remember=1):",
            "        \"\"\" Add another ACL line",
            "",
            "        This can be used in multiple subsequent calls to process longer lists.",
            "",
            "        :param aclstring: acl string from item or configuration",
            "        :param remember: should add the line to self.acl_lines",
            "        \"\"\"",
            "        # Remember lines",
            "        if remember:",
            "            self.acl_lines.append(aclstring)",
            "",
            "        # Iterate over entries and rights, parsed by acl string iterator",
            "        acliter = ACLStringIterator(self.acl_rights_valid, aclstring)",
            "        for modifier, entries, rights in acliter:",
            "            if entries == ['Default']:",
            "                self._addLine(self.default, remember=0)",
            "            else:",
            "                for entry in entries:",
            "                    rightsdict = {}",
            "                    if modifier:",
            "                        # Only user rights are added to the right dict.",
            "                        # + add right with value of 1",
            "                        # - add right with value of 0",
            "                        for right in rights:",
            "                            rightsdict[right] = (modifier == '+')",
            "                    else:",
            "                        # All rights from acl_rights_valid are added to the",
            "                        # dict, user rights with value of 1, and other with",
            "                        # value of 0",
            "                        for right in self.acl_rights_valid:",
            "                            rightsdict[right] = (right in rights)",
            "                    self.acl.append((entry, rightsdict))",
            "",
            "    def may(self, name, dowhat):",
            "        \"\"\" May <name> <dowhat>? Returns boolean answer.",
            "",
            "            Note: this just checks THIS ACL, the before/default/after ACL must",
            "                  be handled elsewhere, if needed.",
            "        \"\"\"",
            "        groups = flaskg.groups",
            "        allowed = None",
            "        for entry, rightsdict in self.acl:",
            "            if entry in self.special_users:",
            "                handler = getattr(self, \"_special_\"+entry, None)",
            "                allowed = handler(name, dowhat, rightsdict)",
            "            elif entry in groups:",
            "                this_group = groups[entry]",
            "                if name in this_group:",
            "                    allowed = rightsdict.get(dowhat)",
            "                else:",
            "                    for special in self.special_users:",
            "                        if special in this_group:",
            "                            handler = getattr(self, \"_special_\" + special, None)",
            "                            allowed = handler(name, dowhat, rightsdict)",
            "                            break # order of self.special_users is important",
            "            elif entry == name:",
            "                allowed = rightsdict.get(dowhat)",
            "            if allowed is not None:",
            "                return allowed",
            "        return allowed # should be None",
            "",
            "    def _special_All(self, name, dowhat, rightsdict):",
            "        return rightsdict.get(dowhat)",
            "",
            "    def _special_Known(self, name, dowhat, rightsdict):",
            "        \"\"\" check if user <name> is known to us,",
            "            that means that there is a valid user account present.",
            "            works for subscription emails.",
            "        \"\"\"",
            "        if user.search_users(name_exact=name): # is a user with this name known?",
            "            return rightsdict.get(dowhat)",
            "        return None",
            "",
            "    def _special_Trusted(self, name, dowhat, rightsdict):",
            "        \"\"\" check if user <name> is the current user AND is has logged in using",
            "            an authentication method that set the trusted attribute.",
            "            Does not work for subsription emails that should be sent to <user>,",
            "            as the user is not logged in in that case.",
            "        \"\"\"",
            "        if flaskg.user.name == name and flaskg.user.trusted:",
            "            return rightsdict.get(dowhat)",
            "        return None",
            "",
            "    def __eq__(self, other):",
            "        return self.acl_lines == other.acl_lines",
            "",
            "    def __ne__(self, other):",
            "        return self.acl_lines != other.acl_lines",
            "",
            "",
            "class ACLStringIterator(object):",
            "    \"\"\" Iterator for acl string",
            "",
            "    Parse acl string and return the next entry on each call to next.",
            "    Implements the Iterator protocol.",
            "",
            "    Usage::",
            "",
            "        iter = ACLStringIterator(rights_valid, 'user name:right')",
            "        for modifier, entries, rights in iter:",
            "            # process data",
            "    \"\"\"",
            "",
            "    def __init__(self, rights, aclstring):",
            "        \"\"\" Initialize acl iterator",
            "",
            "        :param rights: the acl rights to consider when parsing",
            "        :param aclstring: string to parse",
            "        \"\"\"",
            "        self.rights = rights",
            "        self.rest = aclstring.strip()",
            "        self.finished = 0",
            "",
            "    def __iter__(self):",
            "        \"\"\" Required by the Iterator protocol \"\"\"",
            "        return self",
            "",
            "    def next(self):",
            "        \"\"\" Return the next values from the acl string",
            "",
            "        When the iterator is finished and you try to call next, it",
            "        raises a StopIteration. The iterator finishes as soon as the",
            "        string is fully parsed or can not be parsed any more.",
            "",
            "        :rtype: 3 tuple - (modifier, [entry, ...], [right, ...])",
            "        :returns: values for one item in an acl string",
            "        \"\"\"",
            "        # Handle finished state, required by iterator protocol",
            "        if self.rest == '':",
            "            self.finished = 1",
            "        if self.finished:",
            "            raise StopIteration",
            "",
            "        # Get optional modifier [+|-]entries:rights",
            "        modifier = ''",
            "        if self.rest[0] in ('+', '-'):",
            "            modifier, self.rest = self.rest[0], self.rest[1:]",
            "",
            "        # Handle the Default meta acl",
            "        if self.rest.startswith('Default ') or self.rest == 'Default':",
            "            self.rest = self.rest[8:]",
            "            entries, rights = ['Default'], []",
            "",
            "        # Handle entries:rights pairs",
            "        else:",
            "            # Get entries",
            "            try:",
            "                entries, self.rest = self.rest.split(':', 1)",
            "            except ValueError:",
            "                self.finished = 1",
            "                raise StopIteration(\"Can't parse rest of string\")",
            "            if entries == '':",
            "                entries = []",
            "            else:",
            "                # TODO strip each entry from blanks?",
            "                entries = entries.split(',')",
            "",
            "            # Get rights",
            "            try:",
            "                rights, self.rest = self.rest.split(' ', 1)",
            "                # Remove extra white space after rights fragment,",
            "                # allowing using multiple spaces between items.",
            "                self.rest = self.rest.lstrip()",
            "            except ValueError:",
            "                rights, self.rest = self.rest, ''",
            "            rights = [r for r in rights.split(',') if r in self.rights]",
            "",
            "        return modifier, entries, rights"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "238": [
                "AccessControlList",
                "may"
            ],
            "242": [
                "AccessControlList",
                "may"
            ]
        },
        "addLocation": []
    },
    "MoinMoin/security/_tests/test_security.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from MoinMoin.user import User"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from MoinMoin.config import ACL"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from MoinMoin.datastruct import ConfigGroups"
            },
            "4": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from MoinMoin._tests import update_item"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from MoinMoin._tests import become_trusted"
            },
            "7": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "                 assert not acl.may(user, right)"
            },
            "8": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 260,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+class TestGroupACL(object):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 262,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 263,
                "PatchRowcode": "+    from MoinMoin._tests import wikiconfig"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+    class Config(wikiconfig.Config):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        def groups(cfg):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+            groups = {"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+                u'PGroup': frozenset([u'Antony', u'Beatrice', ]),"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+                u'AGroup': frozenset([u'All', ]),"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+                # note: the next line is a INTENDED misnomer, there is \"All\" in"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+                # the group NAME, but not in the group members. This makes"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+                # sure that a bug that erroneously checked \"in groupname\" (instead"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+                # of \"in groupmembers\") does not reappear."
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+                u'AllGroup': frozenset([]), # note: intended misnomer"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+            }"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+            return ConfigGroups(groups)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+    def testApplyACLByGroup(self):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+        \"\"\" security: applying acl by group name\"\"\""
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+        # This acl string..."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        acl_rights = ["
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 281,
                "PatchRowcode": "+            \"PGroup,AllGroup:read,write,admin \""
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 282,
                "PatchRowcode": "+            \"AGroup:read \""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 283,
                "PatchRowcode": "+            ]"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 284,
                "PatchRowcode": "+        acl = AccessControlList(acl_rights, valid=app.cfg.acl_rights_contents)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+        # Should apply these rights:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+        users = ("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+            # user, rights"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+            ('Antony', ('read', 'write', 'admin', )),  # in PGroup"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+            ('Beatrice', ('read', 'write', 'admin', )),  # in PGroup"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+            ('Charles', ('read', )),  # virtually in AGroup"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+            )"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+        # Check rights"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 295,
                "PatchRowcode": "+        for user, may in users:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+            mayNot = [right for right in app.cfg.acl_rights_contents"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 297,
                "PatchRowcode": "+                      if right not in may]"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 298,
                "PatchRowcode": "+            # User should have these rights..."
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+            for right in may:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 300,
                "PatchRowcode": "+                assert acl.may(user, right)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 301,
                "PatchRowcode": "+            # But NOT these:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 302,
                "PatchRowcode": "+            for right in mayNot:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+                assert not acl.may(user, right)"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 306,
                "PatchRowcode": " class TestItemAcls(object):"
            },
            "56": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 307,
                "PatchRowcode": "     \"\"\" security: real-life access control list on items testing"
            },
            "57": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "# Copyright: 2003-2004 by Juergen Hermann <jh@web.de>",
            "# Copyright: 2007 by MoinMoin:ReimarBauer",
            "# Copyright: 2007,2009 by MoinMoin:ThomasWaldmann",
            "# License: GNU GPL v2 (or any later version), see LICENSE.txt for details.",
            "",
            "\"\"\"",
            "    MoinMoin - MoinMoin.security Tests",
            "\"\"\"",
            "",
            "",
            "import pytest",
            "",
            "from flask import current_app as app",
            "",
            "from MoinMoin.security import AccessControlList, ACLStringIterator",
            "",
            "from MoinMoin.user import User",
            "from MoinMoin.config import ACL",
            "",
            "from MoinMoin._tests import update_item",
            "from MoinMoin._tests import become_trusted",
            "",
            "",
            "def acliter(acl):",
            "    \"\"\"",
            "    return a acl string iterator (using cfg.acl_rights_contents as valid acl rights)",
            "    \"\"\"",
            "    return ACLStringIterator(app.cfg.acl_rights_contents, acl)",
            "",
            "",
            "class TestACLStringIterator(object):",
            "",
            "    def testEmpty(self):",
            "        \"\"\" security: empty acl string raise StopIteration \"\"\"",
            "        acl_iter = acliter('')",
            "        pytest.raises(StopIteration, acl_iter.next)",
            "",
            "    def testWhiteSpace(self):",
            "        \"\"\" security: white space acl string raise StopIteration \"\"\"",
            "        acl_iter = acliter('       ')",
            "        pytest.raises(StopIteration, acl_iter.next)",
            "",
            "    def testDefault(self):",
            "        \"\"\" security: default meta acl \"\"\"",
            "        acl_iter = acliter('Default Default')",
            "        for mod, entries, rights in acl_iter:",
            "            assert entries == ['Default']",
            "            assert rights == []",
            "",
            "    def testEmptyRights(self):",
            "        \"\"\" security: empty rights \"\"\"",
            "        acl_iter = acliter('WikiName:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['WikiName']",
            "        assert rights == []",
            "",
            "    def testSingleWikiNameSingleRight(self):",
            "        \"\"\" security: single wiki name, single right \"\"\"",
            "        acl_iter = acliter('WikiName:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['WikiName']",
            "        assert rights == ['read']",
            "",
            "    def testMultipleWikiNameAndRights(self):",
            "        \"\"\" security: multiple wiki names and rights \"\"\"",
            "        acl_iter = acliter('UserOne,UserTwo:read,write')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne', 'UserTwo']",
            "        assert rights == ['read', 'write']",
            "",
            "    def testMultipleWikiNameAndRightsSpaces(self):",
            "        \"\"\" security: multiple names with spaces \"\"\"",
            "        acl_iter = acliter('user one,user two:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user one', 'user two']",
            "        assert rights == ['read']",
            "",
            "    def testMultipleEntries(self):",
            "        \"\"\" security: multiple entries \"\"\"",
            "        acl_iter = acliter('UserOne:read,write UserTwo:read All:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserTwo']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['All']",
            "        assert rights == []",
            "",
            "    def testNameWithSpaces(self):",
            "        \"\"\" security: single name with spaces \"\"\"",
            "        acl_iter = acliter('user one:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user one']",
            "        assert rights == ['read']",
            "",
            "    def testMultipleEntriesWithSpaces(self):",
            "        \"\"\" security: multiple entries with spaces \"\"\"",
            "        acl_iter = acliter('user one:read,write user two:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user one']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user two']",
            "        assert rights == ['read']",
            "",
            "    def testMixedNames(self):",
            "        \"\"\" security: mixed wiki names and names with spaces \"\"\"",
            "        acl_iter = acliter('UserOne,user two:read,write user three,UserFour:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne', 'user two']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user three', 'UserFour']",
            "        assert rights == ['read']",
            "",
            "    def testModifier(self):",
            "        \"\"\" security: acl modifiers \"\"\"",
            "        acl_iter = acliter('+UserOne:read -UserTwo:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert mod == '+'",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert mod == '-'",
            "        assert entries == ['UserTwo']",
            "        assert rights == []",
            "",
            "    def testIgnoreInvalidACL(self):",
            "        \"\"\" security: ignore invalid acl",
            "",
            "        The last part of this acl can not be parsed. If it ends with :",
            "        then it will be parsed as one name with spaces.",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read user two is ignored')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read']",
            "        pytest.raises(StopIteration, acl_iter.next)",
            "",
            "    def testEmptyNamesWithRight(self):",
            "        \"\"\" security: empty names with rights",
            "",
            "        The documents does not talk about this case, may() should ignore",
            "        the rights because there is no entry.",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read :read All:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == []",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['All']",
            "        assert rights == []",
            "",
            "    def testIgnoreInvalidRights(self):",
            "        \"\"\" security: ignore rights not in acl_rights_contents",
            "",
            "        Note: this is also important for ACL regeneration (see also acl",
            "              regeneration test for storage.backends.fs19).",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read,sing,write,drink,sleep')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert rights == ['read', 'write']",
            "",
            "        # we use strange usernames that include invalid rights as substrings",
            "        acls = list(acliter(u\"JimAdelete,JoeArevert:admin,read,delete,write,revert\"))",
            "        # now check that we have lost the invalid rights 'delete' and 'revert',",
            "        # but the usernames should be still intact.",
            "        assert acls == [('', [u'JimAdelete', u'JoeArevert'], ['admin', 'read', 'write', ])]",
            "",
            "    def testBadGuy(self):",
            "        \"\"\" security: bad guy may not allowed anything",
            "",
            "        This test was failing on the apply acl rights test.",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read,write BadGuy: All:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['BadGuy']",
            "        assert rights == []",
            "",
            "    def testAllowExtraWhitespace(self):",
            "        \"\"\" security: allow extra white space between entries \"\"\"",
            "        acl_iter = acliter('UserOne,user two:read,write   user three,UserFour:read  All:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne', 'user two']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user three', 'UserFour']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['All']",
            "        assert rights == []",
            "",
            "",
            "class TestAcl(object):",
            "    \"\"\" security: testing access control list",
            "",
            "    TO DO: test unknown user?",
            "    \"\"\"",
            "    def testApplyACLByUser(self):",
            "        \"\"\" security: applying acl by user name\"\"\"",
            "        # This acl string...",
            "        acl_rights = [",
            "            \"-MinusGuy:read \"",
            "            \"+MinusGuy:read \"",
            "            \"+PlusGuy:read \"",
            "            \"-PlusGuy:read \"",
            "            \"Admin1,Admin2:read,write,admin  \"",
            "            \"Admin3:read,write,admin  \"",
            "            \"JoeDoe:read,write  \"",
            "            \"name with spaces,another one:read,write  \"",
            "            \"CamelCase,extended name:read,write  \"",
            "            \"BadGuy:  \"",
            "            \"All:read  \"",
            "            ]",
            "        acl = AccessControlList(acl_rights, valid=app.cfg.acl_rights_contents)",
            "",
            "        # Should apply these rights:",
            "        users = (",
            "            # user,                 rights",
            "            # CamelCase names",
            "            ('Admin1', ('read', 'write', 'admin')),",
            "            ('Admin2', ('read', 'write', 'admin')),",
            "            ('Admin3', ('read', 'write', 'admin')),",
            "            ('JoeDoe', ('read', 'write')),",
            "            ('SomeGuy', ('read', )),",
            "            # Extended names or mix of extended and CamelCase",
            "            ('name with spaces', ('read', 'write', )),",
            "            ('another one', ('read', 'write', )),",
            "            ('CamelCase', ('read', 'write', )),",
            "            ('extended name', ('read', 'write', )),",
            "            # Blocking bad guys",
            "            ('BadGuy', ()),",
            "            # All other users - every one not mentioned in the acl lines",
            "            ('All', ('read', )),",
            "            ('Anonymous', ('read', )),",
            "            # we check whether ACL processing stops for a user/right match",
            "            # with ACL modifiers",
            "            ('MinusGuy', ()),",
            "            ('PlusGuy', ('read', )),",
            "            )",
            "",
            "        # Check rights",
            "        for user, may in users:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            # User should have these rights...",
            "            for right in may:",
            "                assert acl.may(user, right)",
            "            # But NOT these:",
            "            for right in mayNot:",
            "                assert not acl.may(user, right)",
            "",
            "",
            "class TestItemAcls(object):",
            "    \"\"\" security: real-life access control list on items testing",
            "    \"\"\"",
            "    mainitem_name = u'AclTestMainItem'",
            "    subitem1_name = u'AclTestMainItem/SubItem1'",
            "    subitem2_name = u'AclTestMainItem/SubItem2'",
            "    item_rwforall = u'EveryoneMayReadWriteMe'",
            "    subitem_4boss = u'EveryoneMayReadWriteMe/OnlyTheBossMayWMe'",
            "    items = [",
            "        # itemname, acl, content",
            "        (mainitem_name, u'JoeDoe: JaneDoe:read,write', u'Foo!'),",
            "        # acl None means: \"no acl given in item metadata\" - this will trigger",
            "        # usage of default acl (non-hierarchical) or usage of default acl and",
            "        # inheritance (hierarchical):",
            "        (subitem1_name, None, u'FooFoo!'),",
            "        # acl u'' means: \"empty acl (no rights for noone) given\" - this will",
            "        # INHIBIT usage of default acl / inheritance (we DO HAVE an item acl,",
            "        # it is just empty!):",
            "        (subitem2_name, u'', u'BarBar!'),",
            "        (item_rwforall, u'All:read,write', u'May be read from and written to by anyone'),",
            "        (subitem_4boss, u'JoeDoe:read,write', u'Only JoeDoe (the boss) may write'),",
            "    ]",
            "",
            "    from MoinMoin._tests import wikiconfig",
            "    class Config(wikiconfig.Config):",
            "        content_acl = dict(hierarchic=False, before=u\"WikiAdmin:admin,read,write,create,destroy\", default=u\"All:read,write\", after=u\"All:read\")",
            "",
            "    def setup_method(self, method):",
            "        become_trusted(username=u'WikiAdmin')",
            "        for item_name, item_acl, item_content in self.items:",
            "            if item_acl is not None:",
            "                update_item(item_name, {ACL: item_acl}, item_content)",
            "            else:",
            "                update_item(item_name, {}, item_content)",
            "",
            "    def testItemACLs(self):",
            "        \"\"\" security: test item acls \"\"\"",
            "        tests = [",
            "            # itemname, username, expected_rights",
            "            (self.mainitem_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.mainitem_name, u'AnyUser', ['read']), # by after acl",
            "            (self.mainitem_name, u'JaneDoe', ['read', 'write']), # by item acl",
            "            (self.mainitem_name, u'JoeDoe', []), # by item acl",
            "            (self.subitem1_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem1_name, u'AnyUser', ['read', 'write']), # by default acl",
            "            (self.subitem1_name, u'JoeDoe', ['read', 'write']), # by default acl",
            "            (self.subitem1_name, u'JaneDoe', ['read', 'write']), # by default acl",
            "            (self.subitem2_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem2_name, u'AnyUser', ['read']), # by after acl",
            "            (self.subitem2_name, u'JoeDoe', ['read']), # by after acl",
            "            (self.subitem2_name, u'JaneDoe', ['read']), # by after acl",
            "        ]",
            "",
            "        for itemname, username, may in tests:",
            "            u = User(auth_username=username)",
            "            u.valid = True",
            "",
            "            def _have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert can_access, \"{0!r} may {1} {2!r} (normal)\".format(u.name, right, itemname)",
            "",
            "            # User should have these rights...",
            "            for right in may:",
            "                yield _have_right, u, right, itemname",
            "",
            "            def _not_have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert not can_access, \"{0!r} may not {1} {2!r} (normal)\".format(u.name, right, itemname)",
            "",
            "            # User should NOT have these rights:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            for right in mayNot:",
            "                yield _not_have_right, u, right, itemname",
            "",
            "",
            "class TestItemHierachicalAcls(object):",
            "    \"\"\" security: real-life access control list on items testing",
            "    \"\"\"",
            "    mainitem_name = u'AclTestMainItem'",
            "    subitem1_name = u'AclTestMainItem/SubItem1'",
            "    subitem2_name = u'AclTestMainItem/SubItem2'",
            "    item_rwforall = u'EveryoneMayReadWriteMe'",
            "    subitem_4boss = u'EveryoneMayReadWriteMe/OnlyTheBossMayWMe'",
            "    items = [",
            "        # itemname, acl, content",
            "        (mainitem_name, u'JoeDoe: JaneDoe:read,write', u'Foo!'),",
            "        # acl None means: \"no acl given in item metadata\" - this will trigger",
            "        # usage of default acl (non-hierarchical) or usage of default acl and",
            "        # inheritance (hierarchical):",
            "        (subitem1_name, None, u'FooFoo!'),",
            "        # acl u'' means: \"empty acl (no rights for noone) given\" - this will",
            "        # INHIBIT usage of default acl / inheritance (we DO HAVE an item acl,",
            "        # it is just empty!):",
            "        (subitem2_name, u'', u'BarBar!'),",
            "        (item_rwforall, u'All:read,write', u'May be read from and written to by anyone'),",
            "        (subitem_4boss, u'JoeDoe:read,write', u'Only JoeDoe (the boss) may write'),",
            "    ]",
            "",
            "    from MoinMoin._tests import wikiconfig",
            "    class Config(wikiconfig.Config):",
            "        content_acl = dict(hierarchic=True, before=u\"WikiAdmin:admin,read,write,create,destroy\", default=u\"All:read,write\", after=u\"All:read\")",
            "",
            "    def setup_method(self, method):",
            "        become_trusted(username=u'WikiAdmin')",
            "        for item_name, item_acl, item_content in self.items:",
            "            if item_acl is not None:",
            "                update_item(item_name, {ACL: item_acl}, item_content)",
            "            else:",
            "                update_item(item_name, {}, item_content)",
            "",
            "    def testItemACLs(self):",
            "        \"\"\" security: test item acls \"\"\"",
            "        tests = [",
            "            # itemname, username, expected_rights",
            "            (self.mainitem_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.mainitem_name, u'AnyUser', ['read']), # by after acl",
            "            (self.mainitem_name, u'JaneDoe', ['read', 'write']), # by item acl",
            "            (self.mainitem_name, u'JoeDoe', []), # by item acl",
            "            (self.subitem1_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem1_name, u'AnyUser', ['read', 'write']), # by default acl",
            "            (self.subitem1_name, u'JoeDoe', []), # by inherited acl from main item",
            "            (self.subitem1_name, u'JaneDoe', ['read', 'write']), # by inherited acl from main item",
            "            (self.subitem2_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem2_name, u'AnyUser', ['read']), # by after acl",
            "            (self.subitem2_name, u'JoeDoe', ['read']), # by after acl",
            "            (self.subitem2_name, u'JaneDoe', ['read']), # by after acl",
            "            (self.subitem_4boss, u'AnyUser', ['read']), # by after acl",
            "            (self.subitem_4boss, u'JoeDoe', ['read', 'write']), # by item acl",
            "        ]",
            "",
            "        for itemname, username, may in tests:",
            "            u = User(auth_username=username)",
            "            u.valid = True",
            "",
            "            def _have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert can_access, \"{0!r} may {1} {2!r} (hierarchic)\".format(u.name, right, itemname)",
            "",
            "            # User should have these rights...",
            "            for right in may:",
            "                yield _have_right, u, right, itemname",
            "",
            "            def _not_have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert not can_access, \"{0!r} may not {1} {2!r} (hierarchic)\".format(u.name, right, itemname)",
            "",
            "            # User should NOT have these rights:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            for right in mayNot:",
            "                yield _not_have_right, u, right, itemname",
            "",
            "",
            "coverage_modules = ['MoinMoin.security']"
        ],
        "afterPatchFile": [
            "# Copyright: 2003-2004 by Juergen Hermann <jh@web.de>",
            "# Copyright: 2007 by MoinMoin:ReimarBauer",
            "# Copyright: 2007,2009 by MoinMoin:ThomasWaldmann",
            "# License: GNU GPL v2 (or any later version), see LICENSE.txt for details.",
            "",
            "\"\"\"",
            "    MoinMoin - MoinMoin.security Tests",
            "\"\"\"",
            "",
            "",
            "import pytest",
            "",
            "from flask import current_app as app",
            "",
            "from MoinMoin.security import AccessControlList, ACLStringIterator",
            "",
            "from MoinMoin.user import User",
            "from MoinMoin.config import ACL",
            "from MoinMoin.datastruct import ConfigGroups",
            "",
            "from MoinMoin._tests import update_item",
            "from MoinMoin._tests import become_trusted",
            "",
            "",
            "def acliter(acl):",
            "    \"\"\"",
            "    return a acl string iterator (using cfg.acl_rights_contents as valid acl rights)",
            "    \"\"\"",
            "    return ACLStringIterator(app.cfg.acl_rights_contents, acl)",
            "",
            "",
            "class TestACLStringIterator(object):",
            "",
            "    def testEmpty(self):",
            "        \"\"\" security: empty acl string raise StopIteration \"\"\"",
            "        acl_iter = acliter('')",
            "        pytest.raises(StopIteration, acl_iter.next)",
            "",
            "    def testWhiteSpace(self):",
            "        \"\"\" security: white space acl string raise StopIteration \"\"\"",
            "        acl_iter = acliter('       ')",
            "        pytest.raises(StopIteration, acl_iter.next)",
            "",
            "    def testDefault(self):",
            "        \"\"\" security: default meta acl \"\"\"",
            "        acl_iter = acliter('Default Default')",
            "        for mod, entries, rights in acl_iter:",
            "            assert entries == ['Default']",
            "            assert rights == []",
            "",
            "    def testEmptyRights(self):",
            "        \"\"\" security: empty rights \"\"\"",
            "        acl_iter = acliter('WikiName:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['WikiName']",
            "        assert rights == []",
            "",
            "    def testSingleWikiNameSingleRight(self):",
            "        \"\"\" security: single wiki name, single right \"\"\"",
            "        acl_iter = acliter('WikiName:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['WikiName']",
            "        assert rights == ['read']",
            "",
            "    def testMultipleWikiNameAndRights(self):",
            "        \"\"\" security: multiple wiki names and rights \"\"\"",
            "        acl_iter = acliter('UserOne,UserTwo:read,write')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne', 'UserTwo']",
            "        assert rights == ['read', 'write']",
            "",
            "    def testMultipleWikiNameAndRightsSpaces(self):",
            "        \"\"\" security: multiple names with spaces \"\"\"",
            "        acl_iter = acliter('user one,user two:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user one', 'user two']",
            "        assert rights == ['read']",
            "",
            "    def testMultipleEntries(self):",
            "        \"\"\" security: multiple entries \"\"\"",
            "        acl_iter = acliter('UserOne:read,write UserTwo:read All:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserTwo']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['All']",
            "        assert rights == []",
            "",
            "    def testNameWithSpaces(self):",
            "        \"\"\" security: single name with spaces \"\"\"",
            "        acl_iter = acliter('user one:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user one']",
            "        assert rights == ['read']",
            "",
            "    def testMultipleEntriesWithSpaces(self):",
            "        \"\"\" security: multiple entries with spaces \"\"\"",
            "        acl_iter = acliter('user one:read,write user two:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user one']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user two']",
            "        assert rights == ['read']",
            "",
            "    def testMixedNames(self):",
            "        \"\"\" security: mixed wiki names and names with spaces \"\"\"",
            "        acl_iter = acliter('UserOne,user two:read,write user three,UserFour:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne', 'user two']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user three', 'UserFour']",
            "        assert rights == ['read']",
            "",
            "    def testModifier(self):",
            "        \"\"\" security: acl modifiers \"\"\"",
            "        acl_iter = acliter('+UserOne:read -UserTwo:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert mod == '+'",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert mod == '-'",
            "        assert entries == ['UserTwo']",
            "        assert rights == []",
            "",
            "    def testIgnoreInvalidACL(self):",
            "        \"\"\" security: ignore invalid acl",
            "",
            "        The last part of this acl can not be parsed. If it ends with :",
            "        then it will be parsed as one name with spaces.",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read user two is ignored')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read']",
            "        pytest.raises(StopIteration, acl_iter.next)",
            "",
            "    def testEmptyNamesWithRight(self):",
            "        \"\"\" security: empty names with rights",
            "",
            "        The documents does not talk about this case, may() should ignore",
            "        the rights because there is no entry.",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read :read All:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == []",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['All']",
            "        assert rights == []",
            "",
            "    def testIgnoreInvalidRights(self):",
            "        \"\"\" security: ignore rights not in acl_rights_contents",
            "",
            "        Note: this is also important for ACL regeneration (see also acl",
            "              regeneration test for storage.backends.fs19).",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read,sing,write,drink,sleep')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert rights == ['read', 'write']",
            "",
            "        # we use strange usernames that include invalid rights as substrings",
            "        acls = list(acliter(u\"JimAdelete,JoeArevert:admin,read,delete,write,revert\"))",
            "        # now check that we have lost the invalid rights 'delete' and 'revert',",
            "        # but the usernames should be still intact.",
            "        assert acls == [('', [u'JimAdelete', u'JoeArevert'], ['admin', 'read', 'write', ])]",
            "",
            "    def testBadGuy(self):",
            "        \"\"\" security: bad guy may not allowed anything",
            "",
            "        This test was failing on the apply acl rights test.",
            "        \"\"\"",
            "        acl_iter = acliter('UserOne:read,write BadGuy: All:read')",
            "        mod, entries, rights = acl_iter.next()",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['BadGuy']",
            "        assert rights == []",
            "",
            "    def testAllowExtraWhitespace(self):",
            "        \"\"\" security: allow extra white space between entries \"\"\"",
            "        acl_iter = acliter('UserOne,user two:read,write   user three,UserFour:read  All:')",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['UserOne', 'user two']",
            "        assert rights == ['read', 'write']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['user three', 'UserFour']",
            "        assert rights == ['read']",
            "        mod, entries, rights = acl_iter.next()",
            "        assert entries == ['All']",
            "        assert rights == []",
            "",
            "",
            "class TestAcl(object):",
            "    \"\"\" security: testing access control list",
            "",
            "    TO DO: test unknown user?",
            "    \"\"\"",
            "    def testApplyACLByUser(self):",
            "        \"\"\" security: applying acl by user name\"\"\"",
            "        # This acl string...",
            "        acl_rights = [",
            "            \"-MinusGuy:read \"",
            "            \"+MinusGuy:read \"",
            "            \"+PlusGuy:read \"",
            "            \"-PlusGuy:read \"",
            "            \"Admin1,Admin2:read,write,admin  \"",
            "            \"Admin3:read,write,admin  \"",
            "            \"JoeDoe:read,write  \"",
            "            \"name with spaces,another one:read,write  \"",
            "            \"CamelCase,extended name:read,write  \"",
            "            \"BadGuy:  \"",
            "            \"All:read  \"",
            "            ]",
            "        acl = AccessControlList(acl_rights, valid=app.cfg.acl_rights_contents)",
            "",
            "        # Should apply these rights:",
            "        users = (",
            "            # user,                 rights",
            "            # CamelCase names",
            "            ('Admin1', ('read', 'write', 'admin')),",
            "            ('Admin2', ('read', 'write', 'admin')),",
            "            ('Admin3', ('read', 'write', 'admin')),",
            "            ('JoeDoe', ('read', 'write')),",
            "            ('SomeGuy', ('read', )),",
            "            # Extended names or mix of extended and CamelCase",
            "            ('name with spaces', ('read', 'write', )),",
            "            ('another one', ('read', 'write', )),",
            "            ('CamelCase', ('read', 'write', )),",
            "            ('extended name', ('read', 'write', )),",
            "            # Blocking bad guys",
            "            ('BadGuy', ()),",
            "            # All other users - every one not mentioned in the acl lines",
            "            ('All', ('read', )),",
            "            ('Anonymous', ('read', )),",
            "            # we check whether ACL processing stops for a user/right match",
            "            # with ACL modifiers",
            "            ('MinusGuy', ()),",
            "            ('PlusGuy', ('read', )),",
            "            )",
            "",
            "        # Check rights",
            "        for user, may in users:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            # User should have these rights...",
            "            for right in may:",
            "                assert acl.may(user, right)",
            "            # But NOT these:",
            "            for right in mayNot:",
            "                assert not acl.may(user, right)",
            "",
            "",
            "class TestGroupACL(object):",
            "",
            "    from MoinMoin._tests import wikiconfig",
            "    class Config(wikiconfig.Config):",
            "        def groups(cfg):",
            "            groups = {",
            "                u'PGroup': frozenset([u'Antony', u'Beatrice', ]),",
            "                u'AGroup': frozenset([u'All', ]),",
            "                # note: the next line is a INTENDED misnomer, there is \"All\" in",
            "                # the group NAME, but not in the group members. This makes",
            "                # sure that a bug that erroneously checked \"in groupname\" (instead",
            "                # of \"in groupmembers\") does not reappear.",
            "                u'AllGroup': frozenset([]), # note: intended misnomer",
            "            }",
            "            return ConfigGroups(groups)",
            "",
            "    def testApplyACLByGroup(self):",
            "        \"\"\" security: applying acl by group name\"\"\"",
            "        # This acl string...",
            "        acl_rights = [",
            "            \"PGroup,AllGroup:read,write,admin \"",
            "            \"AGroup:read \"",
            "            ]",
            "        acl = AccessControlList(acl_rights, valid=app.cfg.acl_rights_contents)",
            "",
            "        # Should apply these rights:",
            "        users = (",
            "            # user, rights",
            "            ('Antony', ('read', 'write', 'admin', )),  # in PGroup",
            "            ('Beatrice', ('read', 'write', 'admin', )),  # in PGroup",
            "            ('Charles', ('read', )),  # virtually in AGroup",
            "            )",
            "",
            "        # Check rights",
            "        for user, may in users:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            # User should have these rights...",
            "            for right in may:",
            "                assert acl.may(user, right)",
            "            # But NOT these:",
            "            for right in mayNot:",
            "                assert not acl.may(user, right)",
            "",
            "",
            "class TestItemAcls(object):",
            "    \"\"\" security: real-life access control list on items testing",
            "    \"\"\"",
            "    mainitem_name = u'AclTestMainItem'",
            "    subitem1_name = u'AclTestMainItem/SubItem1'",
            "    subitem2_name = u'AclTestMainItem/SubItem2'",
            "    item_rwforall = u'EveryoneMayReadWriteMe'",
            "    subitem_4boss = u'EveryoneMayReadWriteMe/OnlyTheBossMayWMe'",
            "    items = [",
            "        # itemname, acl, content",
            "        (mainitem_name, u'JoeDoe: JaneDoe:read,write', u'Foo!'),",
            "        # acl None means: \"no acl given in item metadata\" - this will trigger",
            "        # usage of default acl (non-hierarchical) or usage of default acl and",
            "        # inheritance (hierarchical):",
            "        (subitem1_name, None, u'FooFoo!'),",
            "        # acl u'' means: \"empty acl (no rights for noone) given\" - this will",
            "        # INHIBIT usage of default acl / inheritance (we DO HAVE an item acl,",
            "        # it is just empty!):",
            "        (subitem2_name, u'', u'BarBar!'),",
            "        (item_rwforall, u'All:read,write', u'May be read from and written to by anyone'),",
            "        (subitem_4boss, u'JoeDoe:read,write', u'Only JoeDoe (the boss) may write'),",
            "    ]",
            "",
            "    from MoinMoin._tests import wikiconfig",
            "    class Config(wikiconfig.Config):",
            "        content_acl = dict(hierarchic=False, before=u\"WikiAdmin:admin,read,write,create,destroy\", default=u\"All:read,write\", after=u\"All:read\")",
            "",
            "    def setup_method(self, method):",
            "        become_trusted(username=u'WikiAdmin')",
            "        for item_name, item_acl, item_content in self.items:",
            "            if item_acl is not None:",
            "                update_item(item_name, {ACL: item_acl}, item_content)",
            "            else:",
            "                update_item(item_name, {}, item_content)",
            "",
            "    def testItemACLs(self):",
            "        \"\"\" security: test item acls \"\"\"",
            "        tests = [",
            "            # itemname, username, expected_rights",
            "            (self.mainitem_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.mainitem_name, u'AnyUser', ['read']), # by after acl",
            "            (self.mainitem_name, u'JaneDoe', ['read', 'write']), # by item acl",
            "            (self.mainitem_name, u'JoeDoe', []), # by item acl",
            "            (self.subitem1_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem1_name, u'AnyUser', ['read', 'write']), # by default acl",
            "            (self.subitem1_name, u'JoeDoe', ['read', 'write']), # by default acl",
            "            (self.subitem1_name, u'JaneDoe', ['read', 'write']), # by default acl",
            "            (self.subitem2_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem2_name, u'AnyUser', ['read']), # by after acl",
            "            (self.subitem2_name, u'JoeDoe', ['read']), # by after acl",
            "            (self.subitem2_name, u'JaneDoe', ['read']), # by after acl",
            "        ]",
            "",
            "        for itemname, username, may in tests:",
            "            u = User(auth_username=username)",
            "            u.valid = True",
            "",
            "            def _have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert can_access, \"{0!r} may {1} {2!r} (normal)\".format(u.name, right, itemname)",
            "",
            "            # User should have these rights...",
            "            for right in may:",
            "                yield _have_right, u, right, itemname",
            "",
            "            def _not_have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert not can_access, \"{0!r} may not {1} {2!r} (normal)\".format(u.name, right, itemname)",
            "",
            "            # User should NOT have these rights:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            for right in mayNot:",
            "                yield _not_have_right, u, right, itemname",
            "",
            "",
            "class TestItemHierachicalAcls(object):",
            "    \"\"\" security: real-life access control list on items testing",
            "    \"\"\"",
            "    mainitem_name = u'AclTestMainItem'",
            "    subitem1_name = u'AclTestMainItem/SubItem1'",
            "    subitem2_name = u'AclTestMainItem/SubItem2'",
            "    item_rwforall = u'EveryoneMayReadWriteMe'",
            "    subitem_4boss = u'EveryoneMayReadWriteMe/OnlyTheBossMayWMe'",
            "    items = [",
            "        # itemname, acl, content",
            "        (mainitem_name, u'JoeDoe: JaneDoe:read,write', u'Foo!'),",
            "        # acl None means: \"no acl given in item metadata\" - this will trigger",
            "        # usage of default acl (non-hierarchical) or usage of default acl and",
            "        # inheritance (hierarchical):",
            "        (subitem1_name, None, u'FooFoo!'),",
            "        # acl u'' means: \"empty acl (no rights for noone) given\" - this will",
            "        # INHIBIT usage of default acl / inheritance (we DO HAVE an item acl,",
            "        # it is just empty!):",
            "        (subitem2_name, u'', u'BarBar!'),",
            "        (item_rwforall, u'All:read,write', u'May be read from and written to by anyone'),",
            "        (subitem_4boss, u'JoeDoe:read,write', u'Only JoeDoe (the boss) may write'),",
            "    ]",
            "",
            "    from MoinMoin._tests import wikiconfig",
            "    class Config(wikiconfig.Config):",
            "        content_acl = dict(hierarchic=True, before=u\"WikiAdmin:admin,read,write,create,destroy\", default=u\"All:read,write\", after=u\"All:read\")",
            "",
            "    def setup_method(self, method):",
            "        become_trusted(username=u'WikiAdmin')",
            "        for item_name, item_acl, item_content in self.items:",
            "            if item_acl is not None:",
            "                update_item(item_name, {ACL: item_acl}, item_content)",
            "            else:",
            "                update_item(item_name, {}, item_content)",
            "",
            "    def testItemACLs(self):",
            "        \"\"\" security: test item acls \"\"\"",
            "        tests = [",
            "            # itemname, username, expected_rights",
            "            (self.mainitem_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.mainitem_name, u'AnyUser', ['read']), # by after acl",
            "            (self.mainitem_name, u'JaneDoe', ['read', 'write']), # by item acl",
            "            (self.mainitem_name, u'JoeDoe', []), # by item acl",
            "            (self.subitem1_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem1_name, u'AnyUser', ['read', 'write']), # by default acl",
            "            (self.subitem1_name, u'JoeDoe', []), # by inherited acl from main item",
            "            (self.subitem1_name, u'JaneDoe', ['read', 'write']), # by inherited acl from main item",
            "            (self.subitem2_name, u'WikiAdmin', ['read', 'write', 'admin', 'create', 'destroy']),",
            "            (self.subitem2_name, u'AnyUser', ['read']), # by after acl",
            "            (self.subitem2_name, u'JoeDoe', ['read']), # by after acl",
            "            (self.subitem2_name, u'JaneDoe', ['read']), # by after acl",
            "            (self.subitem_4boss, u'AnyUser', ['read']), # by after acl",
            "            (self.subitem_4boss, u'JoeDoe', ['read', 'write']), # by item acl",
            "        ]",
            "",
            "        for itemname, username, may in tests:",
            "            u = User(auth_username=username)",
            "            u.valid = True",
            "",
            "            def _have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert can_access, \"{0!r} may {1} {2!r} (hierarchic)\".format(u.name, right, itemname)",
            "",
            "            # User should have these rights...",
            "            for right in may:",
            "                yield _have_right, u, right, itemname",
            "",
            "            def _not_have_right(u, right, itemname):",
            "                can_access = getattr(u.may, right)(itemname)",
            "                assert not can_access, \"{0!r} may not {1} {2!r} (hierarchic)\".format(u.name, right, itemname)",
            "",
            "            # User should NOT have these rights:",
            "            mayNot = [right for right in app.cfg.acl_rights_contents",
            "                      if right not in may]",
            "            for right in mayNot:",
            "                yield _not_have_right, u, right, itemname",
            "",
            "",
            "coverage_modules = ['MoinMoin.security']"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.jinja2.utils"
        ]
    }
}