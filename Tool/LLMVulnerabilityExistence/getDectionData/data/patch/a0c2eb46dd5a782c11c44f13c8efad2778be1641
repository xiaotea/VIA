{
    "django/core/handlers/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " class BaseHandler(object):"
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     # Changes that are always applied to a response (in this order)."
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     response_fixes = ["
            },
            "3": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        http.fix_location_header,"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         http.conditional_content_removal,"
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     ]"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import logging",
            "import sys",
            "import types",
            "",
            "from django import http",
            "from django.conf import settings",
            "from django.core import signals, urlresolvers",
            "from django.core.exceptions import (",
            "    MiddlewareNotUsed, PermissionDenied, SuspiciousOperation,",
            ")",
            "from django.db import connections, transaction",
            "from django.http.multipartparser import MultiPartParserError",
            "from django.utils import six",
            "from django.utils.encoding import force_text",
            "from django.utils.module_loading import import_string",
            "from django.views import debug",
            "",
            "logger = logging.getLogger('django.request')",
            "",
            "",
            "class BaseHandler(object):",
            "    # Changes that are always applied to a response (in this order).",
            "    response_fixes = [",
            "        http.fix_location_header,",
            "        http.conditional_content_removal,",
            "    ]",
            "",
            "    def __init__(self):",
            "        self._request_middleware = None",
            "        self._view_middleware = None",
            "        self._template_response_middleware = None",
            "        self._response_middleware = None",
            "        self._exception_middleware = None",
            "",
            "    def load_middleware(self):",
            "        \"\"\"",
            "        Populate middleware lists from settings.MIDDLEWARE_CLASSES.",
            "",
            "        Must be called after the environment is fixed (see __call__ in subclasses).",
            "        \"\"\"",
            "        self._view_middleware = []",
            "        self._template_response_middleware = []",
            "        self._response_middleware = []",
            "        self._exception_middleware = []",
            "",
            "        request_middleware = []",
            "        for middleware_path in settings.MIDDLEWARE_CLASSES:",
            "            mw_class = import_string(middleware_path)",
            "            try:",
            "                mw_instance = mw_class()",
            "            except MiddlewareNotUsed as exc:",
            "                if settings.DEBUG:",
            "                    if six.text_type(exc):",
            "                        logger.debug('MiddlewareNotUsed(%r): %s', middleware_path, exc)",
            "                    else:",
            "                        logger.debug('MiddlewareNotUsed: %r', middleware_path)",
            "                continue",
            "",
            "            if hasattr(mw_instance, 'process_request'):",
            "                request_middleware.append(mw_instance.process_request)",
            "            if hasattr(mw_instance, 'process_view'):",
            "                self._view_middleware.append(mw_instance.process_view)",
            "            if hasattr(mw_instance, 'process_template_response'):",
            "                self._template_response_middleware.insert(0, mw_instance.process_template_response)",
            "            if hasattr(mw_instance, 'process_response'):",
            "                self._response_middleware.insert(0, mw_instance.process_response)",
            "            if hasattr(mw_instance, 'process_exception'):",
            "                self._exception_middleware.insert(0, mw_instance.process_exception)",
            "",
            "        # We only assign to this when initialization is complete as it is used",
            "        # as a flag for initialization being complete.",
            "        self._request_middleware = request_middleware",
            "",
            "    def make_view_atomic(self, view):",
            "        non_atomic_requests = getattr(view, '_non_atomic_requests', set())",
            "        for db in connections.all():",
            "            if (db.settings_dict['ATOMIC_REQUESTS']",
            "                    and db.alias not in non_atomic_requests):",
            "                view = transaction.atomic(using=db.alias)(view)",
            "        return view",
            "",
            "    def get_exception_response(self, request, resolver, status_code):",
            "        try:",
            "            callback, param_dict = resolver.resolve_error_handler(status_code)",
            "            response = callback(request, **param_dict)",
            "        except:",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        return response",
            "",
            "    def get_response(self, request):",
            "        \"Returns an HttpResponse object for the given HttpRequest\"",
            "",
            "        # Setup default url resolver for this thread, this code is outside",
            "        # the try/except so we don't get a spurious \"unbound local",
            "        # variable\" exception in the event an exception is raised before",
            "        # resolver is set",
            "        urlconf = settings.ROOT_URLCONF",
            "        urlresolvers.set_urlconf(urlconf)",
            "        resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "        try:",
            "            response = None",
            "            # Apply request middleware",
            "            for middleware_method in self._request_middleware:",
            "                response = middleware_method(request)",
            "                if response:",
            "                    break",
            "",
            "            if response is None:",
            "                if hasattr(request, 'urlconf'):",
            "                    # Reset url resolver with a custom urlconf.",
            "                    urlconf = request.urlconf",
            "                    urlresolvers.set_urlconf(urlconf)",
            "                    resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "",
            "                resolver_match = resolver.resolve(request.path_info)",
            "                callback, callback_args, callback_kwargs = resolver_match",
            "                request.resolver_match = resolver_match",
            "",
            "                # Apply view middleware",
            "                for middleware_method in self._view_middleware:",
            "                    response = middleware_method(request, callback, callback_args, callback_kwargs)",
            "                    if response:",
            "                        break",
            "",
            "            if response is None:",
            "                wrapped_callback = self.make_view_atomic(callback)",
            "                try:",
            "                    response = wrapped_callback(request, *callback_args, **callback_kwargs)",
            "                except Exception as e:",
            "                    # If the view raised an exception, run it through exception",
            "                    # middleware, and if the exception middleware returns a",
            "                    # response, use that. Otherwise, reraise the exception.",
            "                    for middleware_method in self._exception_middleware:",
            "                        response = middleware_method(request, e)",
            "                        if response:",
            "                            break",
            "                    if response is None:",
            "                        raise",
            "",
            "            # Complain if the view returned None (a common error).",
            "            if response is None:",
            "                if isinstance(callback, types.FunctionType):    # FBV",
            "                    view_name = callback.__name__",
            "                else:                                           # CBV",
            "                    view_name = callback.__class__.__name__ + '.__call__'",
            "                raise ValueError(\"The view %s.%s didn't return an HttpResponse object. It returned None instead.\"",
            "                                 % (callback.__module__, view_name))",
            "",
            "            # If the response supports deferred rendering, apply template",
            "            # response middleware and then render the response",
            "            if hasattr(response, 'render') and callable(response.render):",
            "                for middleware_method in self._template_response_middleware:",
            "                    response = middleware_method(request, response)",
            "                    # Complain if the template response middleware returned None (a common error).",
            "                    if response is None:",
            "                        raise ValueError(",
            "                            \"%s.process_template_response didn't return an \"",
            "                            \"HttpResponse object. It returned None instead.\"",
            "                            % (middleware_method.__self__.__class__.__name__))",
            "                response = response.render()",
            "",
            "        except http.Http404 as e:",
            "            logger.warning('Not Found: %s', request.path,",
            "                        extra={",
            "                            'status_code': 404,",
            "                            'request': request",
            "                        })",
            "            if settings.DEBUG:",
            "                response = debug.technical_404_response(request, e)",
            "            else:",
            "                response = self.get_exception_response(request, resolver, 404)",
            "",
            "        except PermissionDenied:",
            "            logger.warning(",
            "                'Forbidden (Permission denied): %s', request.path,",
            "                extra={",
            "                    'status_code': 403,",
            "                    'request': request",
            "                })",
            "            response = self.get_exception_response(request, resolver, 403)",
            "",
            "        except MultiPartParserError:",
            "            logger.warning(",
            "                'Bad request (Unable to parse request body): %s', request.path,",
            "                extra={",
            "                    'status_code': 400,",
            "                    'request': request",
            "                })",
            "            response = self.get_exception_response(request, resolver, 400)",
            "",
            "        except SuspiciousOperation as e:",
            "            # The request logger receives events for any problematic request",
            "            # The security logger receives events for all SuspiciousOperations",
            "            security_logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "            security_logger.error(",
            "                force_text(e),",
            "                extra={",
            "                    'status_code': 400,",
            "                    'request': request",
            "                })",
            "            if settings.DEBUG:",
            "                return debug.technical_500_response(request, *sys.exc_info(), status_code=400)",
            "",
            "            response = self.get_exception_response(request, resolver, 400)",
            "",
            "        except SystemExit:",
            "            # Allow sys.exit() to actually exit. See tickets #1023 and #4701",
            "            raise",
            "",
            "        except:  # Handle everything else.",
            "            # Get the exception info now, in case another exception is thrown later.",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        try:",
            "            # Apply response middleware, regardless of the response",
            "            for middleware_method in self._response_middleware:",
            "                response = middleware_method(request, response)",
            "                # Complain if the response middleware returned None (a common error).",
            "                if response is None:",
            "                    raise ValueError(",
            "                        \"%s.process_response didn't return an \"",
            "                        \"HttpResponse object. It returned None instead.\"",
            "                        % (middleware_method.__self__.__class__.__name__))",
            "            response = self.apply_response_fixes(request, response)",
            "        except:  # Any exception should be gathered and handled",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        response._closable_objects.append(request)",
            "",
            "        return response",
            "",
            "    def handle_uncaught_exception(self, request, resolver, exc_info):",
            "        \"\"\"",
            "        Processing for any otherwise uncaught exceptions (those that will",
            "        generate HTTP 500 responses). Can be overridden by subclasses who want",
            "        customised 500 handling.",
            "",
            "        Be *very* careful when overriding this because the error could be",
            "        caused by anything, so assuming something like the database is always",
            "        available would be an error.",
            "        \"\"\"",
            "        if settings.DEBUG_PROPAGATE_EXCEPTIONS:",
            "            raise",
            "",
            "        logger.error('Internal Server Error: %s', request.path,",
            "            exc_info=exc_info,",
            "            extra={",
            "                'status_code': 500,",
            "                'request': request",
            "            }",
            "        )",
            "",
            "        if settings.DEBUG:",
            "            return debug.technical_500_response(request, *exc_info)",
            "",
            "        # If Http500 handler is not installed, re-raise last exception",
            "        if resolver.urlconf_module is None:",
            "            six.reraise(*exc_info)",
            "        # Return an HttpResponse that displays a friendly error message.",
            "        callback, param_dict = resolver.resolve_error_handler(500)",
            "        return callback(request, **param_dict)",
            "",
            "    def apply_response_fixes(self, request, response):",
            "        \"\"\"",
            "        Applies each of the functions in self.response_fixes to the request and",
            "        response, modifying the response in the process. Returns the new",
            "        response.",
            "        \"\"\"",
            "        for func in self.response_fixes:",
            "            response = func(request, response)",
            "        return response"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import logging",
            "import sys",
            "import types",
            "",
            "from django import http",
            "from django.conf import settings",
            "from django.core import signals, urlresolvers",
            "from django.core.exceptions import (",
            "    MiddlewareNotUsed, PermissionDenied, SuspiciousOperation,",
            ")",
            "from django.db import connections, transaction",
            "from django.http.multipartparser import MultiPartParserError",
            "from django.utils import six",
            "from django.utils.encoding import force_text",
            "from django.utils.module_loading import import_string",
            "from django.views import debug",
            "",
            "logger = logging.getLogger('django.request')",
            "",
            "",
            "class BaseHandler(object):",
            "    # Changes that are always applied to a response (in this order).",
            "    response_fixes = [",
            "        http.conditional_content_removal,",
            "    ]",
            "",
            "    def __init__(self):",
            "        self._request_middleware = None",
            "        self._view_middleware = None",
            "        self._template_response_middleware = None",
            "        self._response_middleware = None",
            "        self._exception_middleware = None",
            "",
            "    def load_middleware(self):",
            "        \"\"\"",
            "        Populate middleware lists from settings.MIDDLEWARE_CLASSES.",
            "",
            "        Must be called after the environment is fixed (see __call__ in subclasses).",
            "        \"\"\"",
            "        self._view_middleware = []",
            "        self._template_response_middleware = []",
            "        self._response_middleware = []",
            "        self._exception_middleware = []",
            "",
            "        request_middleware = []",
            "        for middleware_path in settings.MIDDLEWARE_CLASSES:",
            "            mw_class = import_string(middleware_path)",
            "            try:",
            "                mw_instance = mw_class()",
            "            except MiddlewareNotUsed as exc:",
            "                if settings.DEBUG:",
            "                    if six.text_type(exc):",
            "                        logger.debug('MiddlewareNotUsed(%r): %s', middleware_path, exc)",
            "                    else:",
            "                        logger.debug('MiddlewareNotUsed: %r', middleware_path)",
            "                continue",
            "",
            "            if hasattr(mw_instance, 'process_request'):",
            "                request_middleware.append(mw_instance.process_request)",
            "            if hasattr(mw_instance, 'process_view'):",
            "                self._view_middleware.append(mw_instance.process_view)",
            "            if hasattr(mw_instance, 'process_template_response'):",
            "                self._template_response_middleware.insert(0, mw_instance.process_template_response)",
            "            if hasattr(mw_instance, 'process_response'):",
            "                self._response_middleware.insert(0, mw_instance.process_response)",
            "            if hasattr(mw_instance, 'process_exception'):",
            "                self._exception_middleware.insert(0, mw_instance.process_exception)",
            "",
            "        # We only assign to this when initialization is complete as it is used",
            "        # as a flag for initialization being complete.",
            "        self._request_middleware = request_middleware",
            "",
            "    def make_view_atomic(self, view):",
            "        non_atomic_requests = getattr(view, '_non_atomic_requests', set())",
            "        for db in connections.all():",
            "            if (db.settings_dict['ATOMIC_REQUESTS']",
            "                    and db.alias not in non_atomic_requests):",
            "                view = transaction.atomic(using=db.alias)(view)",
            "        return view",
            "",
            "    def get_exception_response(self, request, resolver, status_code):",
            "        try:",
            "            callback, param_dict = resolver.resolve_error_handler(status_code)",
            "            response = callback(request, **param_dict)",
            "        except:",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        return response",
            "",
            "    def get_response(self, request):",
            "        \"Returns an HttpResponse object for the given HttpRequest\"",
            "",
            "        # Setup default url resolver for this thread, this code is outside",
            "        # the try/except so we don't get a spurious \"unbound local",
            "        # variable\" exception in the event an exception is raised before",
            "        # resolver is set",
            "        urlconf = settings.ROOT_URLCONF",
            "        urlresolvers.set_urlconf(urlconf)",
            "        resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "        try:",
            "            response = None",
            "            # Apply request middleware",
            "            for middleware_method in self._request_middleware:",
            "                response = middleware_method(request)",
            "                if response:",
            "                    break",
            "",
            "            if response is None:",
            "                if hasattr(request, 'urlconf'):",
            "                    # Reset url resolver with a custom urlconf.",
            "                    urlconf = request.urlconf",
            "                    urlresolvers.set_urlconf(urlconf)",
            "                    resolver = urlresolvers.RegexURLResolver(r'^/', urlconf)",
            "",
            "                resolver_match = resolver.resolve(request.path_info)",
            "                callback, callback_args, callback_kwargs = resolver_match",
            "                request.resolver_match = resolver_match",
            "",
            "                # Apply view middleware",
            "                for middleware_method in self._view_middleware:",
            "                    response = middleware_method(request, callback, callback_args, callback_kwargs)",
            "                    if response:",
            "                        break",
            "",
            "            if response is None:",
            "                wrapped_callback = self.make_view_atomic(callback)",
            "                try:",
            "                    response = wrapped_callback(request, *callback_args, **callback_kwargs)",
            "                except Exception as e:",
            "                    # If the view raised an exception, run it through exception",
            "                    # middleware, and if the exception middleware returns a",
            "                    # response, use that. Otherwise, reraise the exception.",
            "                    for middleware_method in self._exception_middleware:",
            "                        response = middleware_method(request, e)",
            "                        if response:",
            "                            break",
            "                    if response is None:",
            "                        raise",
            "",
            "            # Complain if the view returned None (a common error).",
            "            if response is None:",
            "                if isinstance(callback, types.FunctionType):    # FBV",
            "                    view_name = callback.__name__",
            "                else:                                           # CBV",
            "                    view_name = callback.__class__.__name__ + '.__call__'",
            "                raise ValueError(\"The view %s.%s didn't return an HttpResponse object. It returned None instead.\"",
            "                                 % (callback.__module__, view_name))",
            "",
            "            # If the response supports deferred rendering, apply template",
            "            # response middleware and then render the response",
            "            if hasattr(response, 'render') and callable(response.render):",
            "                for middleware_method in self._template_response_middleware:",
            "                    response = middleware_method(request, response)",
            "                    # Complain if the template response middleware returned None (a common error).",
            "                    if response is None:",
            "                        raise ValueError(",
            "                            \"%s.process_template_response didn't return an \"",
            "                            \"HttpResponse object. It returned None instead.\"",
            "                            % (middleware_method.__self__.__class__.__name__))",
            "                response = response.render()",
            "",
            "        except http.Http404 as e:",
            "            logger.warning('Not Found: %s', request.path,",
            "                        extra={",
            "                            'status_code': 404,",
            "                            'request': request",
            "                        })",
            "            if settings.DEBUG:",
            "                response = debug.technical_404_response(request, e)",
            "            else:",
            "                response = self.get_exception_response(request, resolver, 404)",
            "",
            "        except PermissionDenied:",
            "            logger.warning(",
            "                'Forbidden (Permission denied): %s', request.path,",
            "                extra={",
            "                    'status_code': 403,",
            "                    'request': request",
            "                })",
            "            response = self.get_exception_response(request, resolver, 403)",
            "",
            "        except MultiPartParserError:",
            "            logger.warning(",
            "                'Bad request (Unable to parse request body): %s', request.path,",
            "                extra={",
            "                    'status_code': 400,",
            "                    'request': request",
            "                })",
            "            response = self.get_exception_response(request, resolver, 400)",
            "",
            "        except SuspiciousOperation as e:",
            "            # The request logger receives events for any problematic request",
            "            # The security logger receives events for all SuspiciousOperations",
            "            security_logger = logging.getLogger('django.security.%s' %",
            "                            e.__class__.__name__)",
            "            security_logger.error(",
            "                force_text(e),",
            "                extra={",
            "                    'status_code': 400,",
            "                    'request': request",
            "                })",
            "            if settings.DEBUG:",
            "                return debug.technical_500_response(request, *sys.exc_info(), status_code=400)",
            "",
            "            response = self.get_exception_response(request, resolver, 400)",
            "",
            "        except SystemExit:",
            "            # Allow sys.exit() to actually exit. See tickets #1023 and #4701",
            "            raise",
            "",
            "        except:  # Handle everything else.",
            "            # Get the exception info now, in case another exception is thrown later.",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        try:",
            "            # Apply response middleware, regardless of the response",
            "            for middleware_method in self._response_middleware:",
            "                response = middleware_method(request, response)",
            "                # Complain if the response middleware returned None (a common error).",
            "                if response is None:",
            "                    raise ValueError(",
            "                        \"%s.process_response didn't return an \"",
            "                        \"HttpResponse object. It returned None instead.\"",
            "                        % (middleware_method.__self__.__class__.__name__))",
            "            response = self.apply_response_fixes(request, response)",
            "        except:  # Any exception should be gathered and handled",
            "            signals.got_request_exception.send(sender=self.__class__, request=request)",
            "            response = self.handle_uncaught_exception(request, resolver, sys.exc_info())",
            "",
            "        response._closable_objects.append(request)",
            "",
            "        return response",
            "",
            "    def handle_uncaught_exception(self, request, resolver, exc_info):",
            "        \"\"\"",
            "        Processing for any otherwise uncaught exceptions (those that will",
            "        generate HTTP 500 responses). Can be overridden by subclasses who want",
            "        customised 500 handling.",
            "",
            "        Be *very* careful when overriding this because the error could be",
            "        caused by anything, so assuming something like the database is always",
            "        available would be an error.",
            "        \"\"\"",
            "        if settings.DEBUG_PROPAGATE_EXCEPTIONS:",
            "            raise",
            "",
            "        logger.error('Internal Server Error: %s', request.path,",
            "            exc_info=exc_info,",
            "            extra={",
            "                'status_code': 500,",
            "                'request': request",
            "            }",
            "        )",
            "",
            "        if settings.DEBUG:",
            "            return debug.technical_500_response(request, *exc_info)",
            "",
            "        # If Http500 handler is not installed, re-raise last exception",
            "        if resolver.urlconf_module is None:",
            "            six.reraise(*exc_info)",
            "        # Return an HttpResponse that displays a friendly error message.",
            "        callback, param_dict = resolver.resolve_error_handler(500)",
            "        return callback(request, **param_dict)",
            "",
            "    def apply_response_fixes(self, request, response):",
            "        \"\"\"",
            "        Applies each of the functions in self.response_fixes to the request and",
            "        response, modifying the response in the process. Returns the new",
            "        response.",
            "        \"\"\"",
            "        for func in self.response_fixes:",
            "            response = func(request, response)",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [
                "BaseHandler"
            ]
        },
        "addLocation": []
    },
    "django/http/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     HttpResponseNotFound, HttpResponseNotAllowed, HttpResponseGone,"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     HttpResponseServerError, Http404, BadHeaderError, JsonResponse,"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " )"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.http.utils import fix_location_header, conditional_content_removal"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from django.http.utils import conditional_content_removal"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " __all__ = ["
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     'SimpleCookie', 'parse_cookie', 'HttpRequest', 'QueryDict',"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     'HttpResponsePermanentRedirect', 'HttpResponseNotModified',"
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     'HttpResponseBadRequest', 'HttpResponseForbidden', 'HttpResponseNotFound',"
            },
            "10": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     'HttpResponseNotAllowed', 'HttpResponseGone', 'HttpResponseServerError',"
            },
            "11": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    'Http404', 'BadHeaderError', 'fix_location_header', 'JsonResponse',"
            },
            "12": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    'FileResponse', 'conditional_content_removal',"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    'Http404', 'BadHeaderError', 'JsonResponse', 'FileResponse',"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    'conditional_content_removal',"
            },
            "15": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " ]"
            }
        },
        "frontPatchFile": [
            "from django.http.cookie import SimpleCookie, parse_cookie",
            "from django.http.request import (HttpRequest, QueryDict,",
            "    RawPostDataException, UnreadablePostError, build_request_repr)",
            "from django.http.response import (",
            "    HttpResponse, StreamingHttpResponse, FileResponse,",
            "    HttpResponseRedirect, HttpResponsePermanentRedirect,",
            "    HttpResponseNotModified, HttpResponseBadRequest, HttpResponseForbidden,",
            "    HttpResponseNotFound, HttpResponseNotAllowed, HttpResponseGone,",
            "    HttpResponseServerError, Http404, BadHeaderError, JsonResponse,",
            ")",
            "from django.http.utils import fix_location_header, conditional_content_removal",
            "",
            "__all__ = [",
            "    'SimpleCookie', 'parse_cookie', 'HttpRequest', 'QueryDict',",
            "    'RawPostDataException', 'UnreadablePostError', 'build_request_repr',",
            "    'HttpResponse', 'StreamingHttpResponse', 'HttpResponseRedirect',",
            "    'HttpResponsePermanentRedirect', 'HttpResponseNotModified',",
            "    'HttpResponseBadRequest', 'HttpResponseForbidden', 'HttpResponseNotFound',",
            "    'HttpResponseNotAllowed', 'HttpResponseGone', 'HttpResponseServerError',",
            "    'Http404', 'BadHeaderError', 'fix_location_header', 'JsonResponse',",
            "    'FileResponse', 'conditional_content_removal',",
            "]"
        ],
        "afterPatchFile": [
            "from django.http.cookie import SimpleCookie, parse_cookie",
            "from django.http.request import (HttpRequest, QueryDict,",
            "    RawPostDataException, UnreadablePostError, build_request_repr)",
            "from django.http.response import (",
            "    HttpResponse, StreamingHttpResponse, FileResponse,",
            "    HttpResponseRedirect, HttpResponsePermanentRedirect,",
            "    HttpResponseNotModified, HttpResponseBadRequest, HttpResponseForbidden,",
            "    HttpResponseNotFound, HttpResponseNotAllowed, HttpResponseGone,",
            "    HttpResponseServerError, Http404, BadHeaderError, JsonResponse,",
            ")",
            "from django.http.utils import conditional_content_removal",
            "",
            "__all__ = [",
            "    'SimpleCookie', 'parse_cookie', 'HttpRequest', 'QueryDict',",
            "    'RawPostDataException', 'UnreadablePostError', 'build_request_repr',",
            "    'HttpResponse', 'StreamingHttpResponse', 'HttpResponseRedirect',",
            "    'HttpResponsePermanentRedirect', 'HttpResponseNotModified',",
            "    'HttpResponseBadRequest', 'HttpResponseForbidden', 'HttpResponseNotFound',",
            "    'HttpResponseNotAllowed', 'HttpResponseGone', 'HttpResponseServerError',",
            "    'Http404', 'BadHeaderError', 'JsonResponse', 'FileResponse',",
            "    'conditional_content_removal',",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [],
            "20": [],
            "21": []
        },
        "addLocation": []
    },
    "django/http/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " # universally applicable."
            },
            "1": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def fix_location_header(request, response):"
            },
            "4": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Ensures that we always use an absolute URI in any location header in the"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    response. This is required by RFC 2616, section 14.30."
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    Code constructing response objects is free to insert relative paths, as"
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    this function converts them to absolute paths."
            },
            "10": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\""
            },
            "11": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'Location' in response:"
            },
            "12": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        response['Location'] = request.build_absolute_uri(response['Location'])"
            },
            "13": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return response"
            },
            "14": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " def conditional_content_removal(request, response):"
            },
            "17": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     \"\"\""
            },
            "18": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     Removes the content of responses for HEAD requests, 1xx, 204 and 304"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "Functions that modify an HTTP request or response in some way.",
            "\"\"\"",
            "",
            "# This group of functions are run as part of the response handling, after",
            "# everything else, including all response middleware. Think of them as",
            "# \"compulsory response middleware\". Be careful about what goes here, because",
            "# it's a little fiddly to override this behavior, so they should be truly",
            "# universally applicable.",
            "",
            "",
            "def fix_location_header(request, response):",
            "    \"\"\"",
            "    Ensures that we always use an absolute URI in any location header in the",
            "    response. This is required by RFC 2616, section 14.30.",
            "",
            "    Code constructing response objects is free to insert relative paths, as",
            "    this function converts them to absolute paths.",
            "    \"\"\"",
            "    if 'Location' in response:",
            "        response['Location'] = request.build_absolute_uri(response['Location'])",
            "    return response",
            "",
            "",
            "def conditional_content_removal(request, response):",
            "    \"\"\"",
            "    Removes the content of responses for HEAD requests, 1xx, 204 and 304",
            "    responses. Ensures compliance with RFC 2616, section 4.3.",
            "    \"\"\"",
            "    if 100 <= response.status_code < 200 or response.status_code in (204, 304):",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = b''",
            "        response['Content-Length'] = '0'",
            "    if request.method == 'HEAD':",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = b''",
            "    return response"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "Functions that modify an HTTP request or response in some way.",
            "\"\"\"",
            "",
            "# This group of functions are run as part of the response handling, after",
            "# everything else, including all response middleware. Think of them as",
            "# \"compulsory response middleware\". Be careful about what goes here, because",
            "# it's a little fiddly to override this behavior, so they should be truly",
            "# universally applicable.",
            "",
            "",
            "def conditional_content_removal(request, response):",
            "    \"\"\"",
            "    Removes the content of responses for HEAD requests, 1xx, 204 and 304",
            "    responses. Ensures compliance with RFC 2616, section 4.3.",
            "    \"\"\"",
            "    if 100 <= response.status_code < 200 or response.status_code in (204, 304):",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = b''",
            "        response['Content-Length'] = '0'",
            "    if request.method == 'HEAD':",
            "        if response.streaming:",
            "            response.streaming_content = []",
            "        else:",
            "            response.content = b''",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "12": [
                "fix_location_header"
            ],
            "13": [
                "fix_location_header"
            ],
            "14": [
                "fix_location_header"
            ],
            "15": [
                "fix_location_header"
            ],
            "16": [
                "fix_location_header"
            ],
            "17": [
                "fix_location_header"
            ],
            "18": [
                "fix_location_header"
            ],
            "19": [
                "fix_location_header"
            ],
            "20": [
                "fix_location_header"
            ],
            "21": [
                "fix_location_header"
            ],
            "22": [
                "fix_location_header"
            ],
            "23": [],
            "24": []
        },
        "addLocation": []
    },
    "django/middleware/common.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         if new_url == old_url:"
            },
            "1": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             # No redirects required."
            },
            "2": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "             return"
            },
            "3": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if new_url[0]:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        if new_url[0] != old_url[0]:"
            },
            "5": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "             newurl = \"%s://%s%s\" % ("
            },
            "6": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                 request.scheme,"
            },
            "7": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                 new_url[0], urlquote(new_url[1]))"
            }
        },
        "frontPatchFile": [
            "import hashlib",
            "import logging",
            "import re",
            "",
            "from django import http",
            "from django.conf import settings",
            "from django.core import urlresolvers",
            "from django.core.mail import mail_managers",
            "from django.utils import six",
            "from django.utils.encoding import force_text",
            "from django.utils.http import urlquote",
            "",
            "logger = logging.getLogger('django.request')",
            "",
            "",
            "class CommonMiddleware(object):",
            "    \"\"\"",
            "    \"Common\" middleware for taking care of some basic operations:",
            "",
            "        - Forbids access to User-Agents in settings.DISALLOWED_USER_AGENTS",
            "",
            "        - URL rewriting: Based on the APPEND_SLASH and PREPEND_WWW settings,",
            "          this middleware appends missing slashes and/or prepends missing",
            "          \"www.\"s.",
            "",
            "            - If APPEND_SLASH is set and the initial URL doesn't end with a",
            "              slash, and it is not found in urlpatterns, a new URL is formed by",
            "              appending a slash at the end. If this new URL is found in",
            "              urlpatterns, then an HTTP-redirect is returned to this new URL;",
            "              otherwise the initial URL is processed as usual.",
            "",
            "          This behavior can be customized by subclassing CommonMiddleware and",
            "          overriding the response_redirect_class attribute.",
            "",
            "        - ETags: If the USE_ETAGS setting is set, ETags will be calculated from",
            "          the entire page content and Not Modified responses will be returned",
            "          appropriately.",
            "    \"\"\"",
            "",
            "    response_redirect_class = http.HttpResponsePermanentRedirect",
            "",
            "    def process_request(self, request):",
            "        \"\"\"",
            "        Check for denied User-Agents and rewrite the URL based on",
            "        settings.APPEND_SLASH and settings.PREPEND_WWW",
            "        \"\"\"",
            "",
            "        # Check for denied User-Agents",
            "        if 'HTTP_USER_AGENT' in request.META:",
            "            for user_agent_regex in settings.DISALLOWED_USER_AGENTS:",
            "                if user_agent_regex.search(request.META['HTTP_USER_AGENT']):",
            "                    logger.warning('Forbidden (User agent): %s', request.path,",
            "                        extra={",
            "                            'status_code': 403,",
            "                            'request': request",
            "                        }",
            "                    )",
            "                    return http.HttpResponseForbidden('<h1>Forbidden</h1>')",
            "",
            "        # Check for a redirect based on settings.APPEND_SLASH",
            "        # and settings.PREPEND_WWW",
            "        host = request.get_host()",
            "        old_url = [host, request.path]",
            "        new_url = old_url[:]",
            "",
            "        if (settings.PREPEND_WWW and old_url[0] and",
            "                not old_url[0].startswith('www.')):",
            "            new_url[0] = 'www.' + old_url[0]",
            "",
            "        # Append a slash if APPEND_SLASH is set and the URL doesn't have a",
            "        # trailing slash and there is no pattern for the current path",
            "        if settings.APPEND_SLASH and (not old_url[1].endswith('/')):",
            "            urlconf = getattr(request, 'urlconf', None)",
            "            if (not urlresolvers.is_valid_path(request.path_info, urlconf) and",
            "                    urlresolvers.is_valid_path(\"%s/\" % request.path_info, urlconf)):",
            "                new_url[1] = new_url[1] + '/'",
            "                if settings.DEBUG and request.method in ('POST', 'PUT', 'PATCH'):",
            "                    raise RuntimeError((\"\"",
            "                    \"You called this URL via %(method)s, but the URL doesn't end \"",
            "                    \"in a slash and you have APPEND_SLASH set. Django can't \"",
            "                    \"redirect to the slash URL while maintaining %(method)s data. \"",
            "                    \"Change your form to point to %(url)s (note the trailing \"",
            "                    \"slash), or set APPEND_SLASH=False in your Django \"",
            "                    \"settings.\") % {'method': request.method, 'url': ''.join(new_url)})",
            "",
            "        if new_url == old_url:",
            "            # No redirects required.",
            "            return",
            "        if new_url[0]:",
            "            newurl = \"%s://%s%s\" % (",
            "                request.scheme,",
            "                new_url[0], urlquote(new_url[1]))",
            "        else:",
            "            newurl = urlquote(new_url[1])",
            "        if request.META.get('QUERY_STRING', ''):",
            "            if six.PY3:",
            "                newurl += '?' + request.META['QUERY_STRING']",
            "            else:",
            "                # `query_string` is a bytestring. Appending it to the unicode",
            "                # string `newurl` will fail if it isn't ASCII-only. This isn't",
            "                # allowed; only broken software generates such query strings.",
            "                # Better drop the invalid query string than crash (#15152).",
            "                try:",
            "                    newurl += '?' + request.META['QUERY_STRING'].decode()",
            "                except UnicodeDecodeError:",
            "                    pass",
            "        return self.response_redirect_class(newurl)",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        Calculate the ETag, if needed.",
            "        \"\"\"",
            "        if settings.USE_ETAGS:",
            "            if response.has_header('ETag'):",
            "                etag = response['ETag']",
            "            elif response.streaming:",
            "                etag = None",
            "            else:",
            "                etag = '\"%s\"' % hashlib.md5(response.content).hexdigest()",
            "            if etag is not None:",
            "                if (200 <= response.status_code < 300",
            "                        and request.META.get('HTTP_IF_NONE_MATCH') == etag):",
            "                    cookies = response.cookies",
            "                    response = http.HttpResponseNotModified()",
            "                    response.cookies = cookies",
            "                else:",
            "                    response['ETag'] = etag",
            "",
            "        return response",
            "",
            "",
            "class BrokenLinkEmailsMiddleware(object):",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        Send broken link emails for relevant 404 NOT FOUND responses.",
            "        \"\"\"",
            "        if response.status_code == 404 and not settings.DEBUG:",
            "            domain = request.get_host()",
            "            path = request.get_full_path()",
            "            referer = force_text(request.META.get('HTTP_REFERER', ''), errors='replace')",
            "",
            "            if not self.is_ignorable_request(request, path, domain, referer):",
            "                ua = request.META.get('HTTP_USER_AGENT', '<none>')",
            "                ip = request.META.get('REMOTE_ADDR', '<none>')",
            "                mail_managers(",
            "                    \"Broken %slink on %s\" % (",
            "                        ('INTERNAL ' if self.is_internal_request(domain, referer) else ''),",
            "                        domain",
            "                    ),",
            "                    \"Referrer: %s\\nRequested URL: %s\\nUser agent: %s\\n\"",
            "                    \"IP address: %s\\n\" % (referer, path, ua, ip),",
            "                    fail_silently=True)",
            "        return response",
            "",
            "    def is_internal_request(self, domain, referer):",
            "        \"\"\"",
            "        Returns True if the referring URL is the same domain as the current request.",
            "        \"\"\"",
            "        # Different subdomains are treated as different domains.",
            "        return bool(re.match(\"^https?://%s/\" % re.escape(domain), referer))",
            "",
            "    def is_ignorable_request(self, request, uri, domain, referer):",
            "        \"\"\"",
            "        Returns True if the given request *shouldn't* notify the site managers.",
            "        \"\"\"",
            "        # '?' in referer is identified as search engine source",
            "        if (not referer or",
            "                (not self.is_internal_request(domain, referer) and '?' in referer)):",
            "            return True",
            "        return any(pattern.search(uri) for pattern in settings.IGNORABLE_404_URLS)"
        ],
        "afterPatchFile": [
            "import hashlib",
            "import logging",
            "import re",
            "",
            "from django import http",
            "from django.conf import settings",
            "from django.core import urlresolvers",
            "from django.core.mail import mail_managers",
            "from django.utils import six",
            "from django.utils.encoding import force_text",
            "from django.utils.http import urlquote",
            "",
            "logger = logging.getLogger('django.request')",
            "",
            "",
            "class CommonMiddleware(object):",
            "    \"\"\"",
            "    \"Common\" middleware for taking care of some basic operations:",
            "",
            "        - Forbids access to User-Agents in settings.DISALLOWED_USER_AGENTS",
            "",
            "        - URL rewriting: Based on the APPEND_SLASH and PREPEND_WWW settings,",
            "          this middleware appends missing slashes and/or prepends missing",
            "          \"www.\"s.",
            "",
            "            - If APPEND_SLASH is set and the initial URL doesn't end with a",
            "              slash, and it is not found in urlpatterns, a new URL is formed by",
            "              appending a slash at the end. If this new URL is found in",
            "              urlpatterns, then an HTTP-redirect is returned to this new URL;",
            "              otherwise the initial URL is processed as usual.",
            "",
            "          This behavior can be customized by subclassing CommonMiddleware and",
            "          overriding the response_redirect_class attribute.",
            "",
            "        - ETags: If the USE_ETAGS setting is set, ETags will be calculated from",
            "          the entire page content and Not Modified responses will be returned",
            "          appropriately.",
            "    \"\"\"",
            "",
            "    response_redirect_class = http.HttpResponsePermanentRedirect",
            "",
            "    def process_request(self, request):",
            "        \"\"\"",
            "        Check for denied User-Agents and rewrite the URL based on",
            "        settings.APPEND_SLASH and settings.PREPEND_WWW",
            "        \"\"\"",
            "",
            "        # Check for denied User-Agents",
            "        if 'HTTP_USER_AGENT' in request.META:",
            "            for user_agent_regex in settings.DISALLOWED_USER_AGENTS:",
            "                if user_agent_regex.search(request.META['HTTP_USER_AGENT']):",
            "                    logger.warning('Forbidden (User agent): %s', request.path,",
            "                        extra={",
            "                            'status_code': 403,",
            "                            'request': request",
            "                        }",
            "                    )",
            "                    return http.HttpResponseForbidden('<h1>Forbidden</h1>')",
            "",
            "        # Check for a redirect based on settings.APPEND_SLASH",
            "        # and settings.PREPEND_WWW",
            "        host = request.get_host()",
            "        old_url = [host, request.path]",
            "        new_url = old_url[:]",
            "",
            "        if (settings.PREPEND_WWW and old_url[0] and",
            "                not old_url[0].startswith('www.')):",
            "            new_url[0] = 'www.' + old_url[0]",
            "",
            "        # Append a slash if APPEND_SLASH is set and the URL doesn't have a",
            "        # trailing slash and there is no pattern for the current path",
            "        if settings.APPEND_SLASH and (not old_url[1].endswith('/')):",
            "            urlconf = getattr(request, 'urlconf', None)",
            "            if (not urlresolvers.is_valid_path(request.path_info, urlconf) and",
            "                    urlresolvers.is_valid_path(\"%s/\" % request.path_info, urlconf)):",
            "                new_url[1] = new_url[1] + '/'",
            "                if settings.DEBUG and request.method in ('POST', 'PUT', 'PATCH'):",
            "                    raise RuntimeError((\"\"",
            "                    \"You called this URL via %(method)s, but the URL doesn't end \"",
            "                    \"in a slash and you have APPEND_SLASH set. Django can't \"",
            "                    \"redirect to the slash URL while maintaining %(method)s data. \"",
            "                    \"Change your form to point to %(url)s (note the trailing \"",
            "                    \"slash), or set APPEND_SLASH=False in your Django \"",
            "                    \"settings.\") % {'method': request.method, 'url': ''.join(new_url)})",
            "",
            "        if new_url == old_url:",
            "            # No redirects required.",
            "            return",
            "        if new_url[0] != old_url[0]:",
            "            newurl = \"%s://%s%s\" % (",
            "                request.scheme,",
            "                new_url[0], urlquote(new_url[1]))",
            "        else:",
            "            newurl = urlquote(new_url[1])",
            "        if request.META.get('QUERY_STRING', ''):",
            "            if six.PY3:",
            "                newurl += '?' + request.META['QUERY_STRING']",
            "            else:",
            "                # `query_string` is a bytestring. Appending it to the unicode",
            "                # string `newurl` will fail if it isn't ASCII-only. This isn't",
            "                # allowed; only broken software generates such query strings.",
            "                # Better drop the invalid query string than crash (#15152).",
            "                try:",
            "                    newurl += '?' + request.META['QUERY_STRING'].decode()",
            "                except UnicodeDecodeError:",
            "                    pass",
            "        return self.response_redirect_class(newurl)",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        Calculate the ETag, if needed.",
            "        \"\"\"",
            "        if settings.USE_ETAGS:",
            "            if response.has_header('ETag'):",
            "                etag = response['ETag']",
            "            elif response.streaming:",
            "                etag = None",
            "            else:",
            "                etag = '\"%s\"' % hashlib.md5(response.content).hexdigest()",
            "            if etag is not None:",
            "                if (200 <= response.status_code < 300",
            "                        and request.META.get('HTTP_IF_NONE_MATCH') == etag):",
            "                    cookies = response.cookies",
            "                    response = http.HttpResponseNotModified()",
            "                    response.cookies = cookies",
            "                else:",
            "                    response['ETag'] = etag",
            "",
            "        return response",
            "",
            "",
            "class BrokenLinkEmailsMiddleware(object):",
            "",
            "    def process_response(self, request, response):",
            "        \"\"\"",
            "        Send broken link emails for relevant 404 NOT FOUND responses.",
            "        \"\"\"",
            "        if response.status_code == 404 and not settings.DEBUG:",
            "            domain = request.get_host()",
            "            path = request.get_full_path()",
            "            referer = force_text(request.META.get('HTTP_REFERER', ''), errors='replace')",
            "",
            "            if not self.is_ignorable_request(request, path, domain, referer):",
            "                ua = request.META.get('HTTP_USER_AGENT', '<none>')",
            "                ip = request.META.get('REMOTE_ADDR', '<none>')",
            "                mail_managers(",
            "                    \"Broken %slink on %s\" % (",
            "                        ('INTERNAL ' if self.is_internal_request(domain, referer) else ''),",
            "                        domain",
            "                    ),",
            "                    \"Referrer: %s\\nRequested URL: %s\\nUser agent: %s\\n\"",
            "                    \"IP address: %s\\n\" % (referer, path, ua, ip),",
            "                    fail_silently=True)",
            "        return response",
            "",
            "    def is_internal_request(self, domain, referer):",
            "        \"\"\"",
            "        Returns True if the referring URL is the same domain as the current request.",
            "        \"\"\"",
            "        # Different subdomains are treated as different domains.",
            "        return bool(re.match(\"^https?://%s/\" % re.escape(domain), referer))",
            "",
            "    def is_ignorable_request(self, request, uri, domain, referer):",
            "        \"\"\"",
            "        Returns True if the given request *shouldn't* notify the site managers.",
            "        \"\"\"",
            "        # '?' in referer is identified as search engine source",
            "        if (not referer or",
            "                (not self.is_internal_request(domain, referer) and '?' in referer)):",
            "            return True",
            "        return any(pattern.search(uri) for pattern in settings.IGNORABLE_404_URLS)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "89": [
                "CommonMiddleware",
                "process_request"
            ]
        },
        "addLocation": []
    },
    "django/middleware/locale.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "             if path_valid:"
            },
            "2": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "                 script_prefix = get_script_prefix()"
            },
            "3": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                language_url = \"%s://%s%s\" % ("
            },
            "4": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    request.scheme,"
            },
            "5": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    request.get_host(),"
            },
            "6": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # insert language after the script prefix and before the"
            },
            "7": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    # rest of the URL"
            },
            "8": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    request.get_full_path().replace("
            },
            "9": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        script_prefix,"
            },
            "10": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        '%s%s/' % (script_prefix, language),"
            },
            "11": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        1"
            },
            "12": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    )"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+                # Insert language after the script prefix and before the"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+                # rest of the URL"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+                language_url = request.get_full_path().replace("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+                    script_prefix,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+                    '%s%s/' % (script_prefix, language),"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+                    1"
            },
            "19": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "                 )"
            },
            "20": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "                 return self.response_redirect_class(language_url)"
            },
            "21": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"This is the locale selecting middleware that will look at accept headers\"",
            "",
            "from django.conf import settings",
            "from django.core.urlresolvers import (",
            "    LocaleRegexURLResolver, get_resolver, get_script_prefix, is_valid_path,",
            ")",
            "from django.http import HttpResponseRedirect",
            "from django.utils import translation",
            "from django.utils.cache import patch_vary_headers",
            "from django.utils.functional import cached_property",
            "",
            "",
            "class LocaleMiddleware(object):",
            "    \"\"\"",
            "    This is a very simple middleware that parses a request",
            "    and decides what translation object to install in the current",
            "    thread context. This allows pages to be dynamically",
            "    translated to the language the user desires (if the language",
            "    is available, of course).",
            "    \"\"\"",
            "    response_redirect_class = HttpResponseRedirect",
            "",
            "    def process_request(self, request):",
            "        language = translation.get_language_from_request(",
            "            request, check_path=self.is_language_prefix_patterns_used)",
            "        translation.activate(language)",
            "        request.LANGUAGE_CODE = translation.get_language()",
            "",
            "    def process_response(self, request, response):",
            "        language = translation.get_language()",
            "        language_from_path = translation.get_language_from_path(request.path_info)",
            "        if (response.status_code == 404 and not language_from_path",
            "                and self.is_language_prefix_patterns_used):",
            "            urlconf = getattr(request, 'urlconf', None)",
            "            language_path = '/%s%s' % (language, request.path_info)",
            "            path_valid = is_valid_path(language_path, urlconf)",
            "            if (not path_valid and settings.APPEND_SLASH",
            "                    and not language_path.endswith('/')):",
            "                path_valid = is_valid_path(\"%s/\" % language_path, urlconf)",
            "",
            "            if path_valid:",
            "                script_prefix = get_script_prefix()",
            "                language_url = \"%s://%s%s\" % (",
            "                    request.scheme,",
            "                    request.get_host(),",
            "                    # insert language after the script prefix and before the",
            "                    # rest of the URL",
            "                    request.get_full_path().replace(",
            "                        script_prefix,",
            "                        '%s%s/' % (script_prefix, language),",
            "                        1",
            "                    )",
            "                )",
            "                return self.response_redirect_class(language_url)",
            "",
            "        if not (self.is_language_prefix_patterns_used",
            "                and language_from_path):",
            "            patch_vary_headers(response, ('Accept-Language',))",
            "        if 'Content-Language' not in response:",
            "            response['Content-Language'] = language",
            "        return response",
            "",
            "    @cached_property",
            "    def is_language_prefix_patterns_used(self):",
            "        \"\"\"",
            "        Returns `True` if the `LocaleRegexURLResolver` is used",
            "        at root level of the urlpatterns, else it returns `False`.",
            "        \"\"\"",
            "        for url_pattern in get_resolver(None).url_patterns:",
            "            if isinstance(url_pattern, LocaleRegexURLResolver):",
            "                return True",
            "        return False"
        ],
        "afterPatchFile": [
            "\"This is the locale selecting middleware that will look at accept headers\"",
            "",
            "from django.conf import settings",
            "from django.core.urlresolvers import (",
            "    LocaleRegexURLResolver, get_resolver, get_script_prefix, is_valid_path,",
            ")",
            "from django.http import HttpResponseRedirect",
            "from django.utils import translation",
            "from django.utils.cache import patch_vary_headers",
            "from django.utils.functional import cached_property",
            "",
            "",
            "class LocaleMiddleware(object):",
            "    \"\"\"",
            "    This is a very simple middleware that parses a request",
            "    and decides what translation object to install in the current",
            "    thread context. This allows pages to be dynamically",
            "    translated to the language the user desires (if the language",
            "    is available, of course).",
            "    \"\"\"",
            "    response_redirect_class = HttpResponseRedirect",
            "",
            "    def process_request(self, request):",
            "        language = translation.get_language_from_request(",
            "            request, check_path=self.is_language_prefix_patterns_used)",
            "        translation.activate(language)",
            "        request.LANGUAGE_CODE = translation.get_language()",
            "",
            "    def process_response(self, request, response):",
            "        language = translation.get_language()",
            "        language_from_path = translation.get_language_from_path(request.path_info)",
            "        if (response.status_code == 404 and not language_from_path",
            "                and self.is_language_prefix_patterns_used):",
            "            urlconf = getattr(request, 'urlconf', None)",
            "            language_path = '/%s%s' % (language, request.path_info)",
            "            path_valid = is_valid_path(language_path, urlconf)",
            "            if (not path_valid and settings.APPEND_SLASH",
            "                    and not language_path.endswith('/')):",
            "                path_valid = is_valid_path(\"%s/\" % language_path, urlconf)",
            "",
            "            if path_valid:",
            "                script_prefix = get_script_prefix()",
            "                # Insert language after the script prefix and before the",
            "                # rest of the URL",
            "                language_url = request.get_full_path().replace(",
            "                    script_prefix,",
            "                    '%s%s/' % (script_prefix, language),",
            "                    1",
            "                )",
            "                return self.response_redirect_class(language_url)",
            "",
            "        if not (self.is_language_prefix_patterns_used",
            "                and language_from_path):",
            "            patch_vary_headers(response, ('Accept-Language',))",
            "        if 'Content-Language' not in response:",
            "            response['Content-Language'] = language",
            "        return response",
            "",
            "    @cached_property",
            "    def is_language_prefix_patterns_used(self):",
            "        \"\"\"",
            "        Returns `True` if the `LocaleRegexURLResolver` is used",
            "        at root level of the urlpatterns, else it returns `False`.",
            "        \"\"\"",
            "        for url_pattern in get_resolver(None).url_patterns:",
            "            if isinstance(url_pattern, LocaleRegexURLResolver):",
            "                return True",
            "        return False"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "43": [
                "LocaleMiddleware",
                "process_response"
            ],
            "44": [
                "LocaleMiddleware",
                "process_response"
            ],
            "45": [
                "LocaleMiddleware",
                "process_response"
            ],
            "46": [
                "LocaleMiddleware",
                "process_response"
            ],
            "47": [
                "LocaleMiddleware",
                "process_response"
            ],
            "48": [
                "LocaleMiddleware",
                "process_response"
            ],
            "49": [
                "LocaleMiddleware",
                "process_response"
            ],
            "50": [
                "LocaleMiddleware",
                "process_response"
            ],
            "51": [
                "LocaleMiddleware",
                "process_response"
            ],
            "52": [
                "LocaleMiddleware",
                "process_response"
            ]
        },
        "addLocation": []
    },
    "django/test/testcases.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     override_settings,"
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " )"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " from django.utils import six"
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from django.utils.deprecation import RemovedInDjango20Warning"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+from django.utils.deprecation import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    RemovedInDjango20Warning, RemovedInDjango21Warning,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+)"
            },
            "7": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " from django.utils.encoding import force_text"
            },
            "8": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " from django.utils.six.moves.urllib.parse import ("
            },
            "9": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     unquote, urlparse, urlsplit, urlunsplit,"
            },
            "10": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         TestClient to do a request (use fetch_redirect_response=False to check"
            },
            "11": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         such links without fetching them)."
            },
            "12": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         \"\"\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+        if host is not None:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+            warnings.warn("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+                \"The host argument is deprecated and no longer used by assertRedirects\","
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+                RemovedInDjango21Warning, stacklevel=2"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+            )"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 259,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "         if msg_prefix:"
            },
            "20": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "             msg_prefix += \": \""
            },
            "21": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 262,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(expected_url)"
            },
            "23": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "24": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "         if hasattr(response, 'redirect_chain'):"
            },
            "25": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "             # The request was a followed redirect"
            },
            "26": {
                "beforePatchRowNumber": 259,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "             self.assertTrue(len(response.redirect_chain) > 0,"
            },
            "27": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "                     \" response code was %d (expected %d)\" %"
            },
            "28": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "                         (path, redirect_response.status_code, target_status_code))"
            },
            "29": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 303,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        e_scheme = e_scheme if e_scheme else scheme or 'http'"
            },
            "31": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        e_netloc = e_netloc if e_netloc else host or 'testserver'"
            },
            "32": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        expected_url = urlunsplit((e_scheme, e_netloc, e_path, e_query,"
            },
            "33": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            e_fragment))"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        if url != expected_url:"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+            # For temporary backwards compatibility, try to compare with a relative url"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+            e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(expected_url)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+            relative_url = urlunsplit(('', '', e_path, e_query, e_fragment))"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+            if url == relative_url:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+                warnings.warn("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+                    \"assertRedirects had to strip the scheme and domain from the \""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+                    \"expected URL, as it was always added automatically to URLs \""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+                    \"before Django 1.9. Please update your expected URLs by \""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+                    \"removing the scheme and domain.\","
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+                    RemovedInDjango21Warning, stacklevel=2)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+                expected_url = relative_url"
            },
            "46": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 316,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "         self.assertEqual(url, expected_url,"
            },
            "48": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "             msg_prefix + \"Response redirected to '%s', expected '%s'\" %"
            }
        },
        "frontPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import difflib",
            "import errno",
            "import json",
            "import os",
            "import posixpath",
            "import re",
            "import socket",
            "import sys",
            "import threading",
            "import unittest",
            "import warnings",
            "from collections import Counter",
            "from copy import copy",
            "from functools import wraps",
            "from unittest.util import safe_repr",
            "",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.core import mail",
            "from django.core.exceptions import ImproperlyConfigured, ValidationError",
            "from django.core.handlers.wsgi import WSGIHandler, get_path_info",
            "from django.core.management import call_command",
            "from django.core.management.color import no_style",
            "from django.core.management.sql import emit_post_migrate_signal",
            "from django.core.servers.basehttp import WSGIRequestHandler, WSGIServer",
            "from django.core.urlresolvers import clear_url_caches, set_urlconf",
            "from django.db import DEFAULT_DB_ALIAS, connection, connections, transaction",
            "from django.forms.fields import CharField",
            "from django.http import QueryDict",
            "from django.test.client import Client",
            "from django.test.html import HTMLParseError, parse_html",
            "from django.test.signals import setting_changed, template_rendered",
            "from django.test.utils import (",
            "    CaptureQueriesContext, ContextList, compare_xml, modify_settings,",
            "    override_settings,",
            ")",
            "from django.utils import six",
            "from django.utils.deprecation import RemovedInDjango20Warning",
            "from django.utils.encoding import force_text",
            "from django.utils.six.moves.urllib.parse import (",
            "    unquote, urlparse, urlsplit, urlunsplit,",
            ")",
            "from django.utils.six.moves.urllib.request import url2pathname",
            "from django.views.static import serve",
            "",
            "__all__ = ('TestCase', 'TransactionTestCase',",
            "           'SimpleTestCase', 'skipIfDBFeature', 'skipUnlessDBFeature')",
            "",
            "",
            "def to_list(value):",
            "    \"\"\"",
            "    Puts value into a list if it's not already one.",
            "    Returns an empty list if value is None.",
            "    \"\"\"",
            "    if value is None:",
            "        value = []",
            "    elif not isinstance(value, list):",
            "        value = [value]",
            "    return value",
            "",
            "",
            "def assert_and_parse_html(self, html, user_msg, msg):",
            "    try:",
            "        dom = parse_html(html)",
            "    except HTMLParseError as e:",
            "        standardMsg = '%s\\n%s' % (msg, e.msg)",
            "        self.fail(self._formatMessage(user_msg, standardMsg))",
            "    return dom",
            "",
            "",
            "class _AssertNumQueriesContext(CaptureQueriesContext):",
            "    def __init__(self, test_case, num, connection):",
            "        self.test_case = test_case",
            "        self.num = num",
            "        super(_AssertNumQueriesContext, self).__init__(connection)",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        super(_AssertNumQueriesContext, self).__exit__(exc_type, exc_value, traceback)",
            "        if exc_type is not None:",
            "            return",
            "        executed = len(self)",
            "        self.test_case.assertEqual(",
            "            executed, self.num,",
            "            \"%d queries executed, %d expected\\nCaptured queries were:\\n%s\" % (",
            "                executed, self.num,",
            "                '\\n'.join(",
            "                    query['sql'] for query in self.captured_queries",
            "                )",
            "            )",
            "        )",
            "",
            "",
            "class _AssertTemplateUsedContext(object):",
            "    def __init__(self, test_case, template_name):",
            "        self.test_case = test_case",
            "        self.template_name = template_name",
            "        self.rendered_templates = []",
            "        self.rendered_template_names = []",
            "        self.context = ContextList()",
            "",
            "    def on_template_render(self, sender, signal, template, context, **kwargs):",
            "        self.rendered_templates.append(template)",
            "        self.rendered_template_names.append(template.name)",
            "        self.context.append(copy(context))",
            "",
            "    def test(self):",
            "        return self.template_name in self.rendered_template_names",
            "",
            "    def message(self):",
            "        return '%s was not rendered.' % self.template_name",
            "",
            "    def __enter__(self):",
            "        template_rendered.connect(self.on_template_render)",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        template_rendered.disconnect(self.on_template_render)",
            "        if exc_type is not None:",
            "            return",
            "",
            "        if not self.test():",
            "            message = self.message()",
            "            if len(self.rendered_templates) == 0:",
            "                message += ' No template was rendered.'",
            "            else:",
            "                message += ' Following templates were rendered: %s' % (",
            "                    ', '.join(self.rendered_template_names))",
            "            self.test_case.fail(message)",
            "",
            "",
            "class _AssertTemplateNotUsedContext(_AssertTemplateUsedContext):",
            "    def test(self):",
            "        return self.template_name not in self.rendered_template_names",
            "",
            "    def message(self):",
            "        return '%s was rendered.' % self.template_name",
            "",
            "",
            "class SimpleTestCase(unittest.TestCase):",
            "",
            "    # The class we'll use for the test client self.client.",
            "    # Can be overridden in derived classes.",
            "    client_class = Client",
            "    _overridden_settings = None",
            "    _modified_settings = None",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        super(SimpleTestCase, cls).setUpClass()",
            "        if cls._overridden_settings:",
            "            cls._cls_overridden_context = override_settings(**cls._overridden_settings)",
            "            cls._cls_overridden_context.enable()",
            "        if cls._modified_settings:",
            "            cls._cls_modified_context = modify_settings(cls._modified_settings)",
            "            cls._cls_modified_context.enable()",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        if hasattr(cls, '_cls_modified_context'):",
            "            cls._cls_modified_context.disable()",
            "            delattr(cls, '_cls_modified_context')",
            "        if hasattr(cls, '_cls_overridden_context'):",
            "            cls._cls_overridden_context.disable()",
            "            delattr(cls, '_cls_overridden_context')",
            "        super(SimpleTestCase, cls).tearDownClass()",
            "",
            "    def __call__(self, result=None):",
            "        \"\"\"",
            "        Wrapper around default __call__ method to perform common Django test",
            "        set up. This means that user-defined Test Cases aren't required to",
            "        include a call to super().setUp().",
            "        \"\"\"",
            "        testMethod = getattr(self, self._testMethodName)",
            "        skipped = (getattr(self.__class__, \"__unittest_skip__\", False) or",
            "            getattr(testMethod, \"__unittest_skip__\", False))",
            "",
            "        if not skipped:",
            "            try:",
            "                self._pre_setup()",
            "            except Exception:",
            "                result.addError(self, sys.exc_info())",
            "                return",
            "        super(SimpleTestCase, self).__call__(result)",
            "        if not skipped:",
            "            try:",
            "                self._post_teardown()",
            "            except Exception:",
            "                result.addError(self, sys.exc_info())",
            "                return",
            "",
            "    def _pre_setup(self):",
            "        \"\"\"Performs any pre-test setup. This includes:",
            "",
            "        * Creating a test client.",
            "        * If the class has a 'urls' attribute, replace ROOT_URLCONF with it.",
            "        * Clearing the mail test outbox.",
            "        \"\"\"",
            "        self.client = self.client_class()",
            "        self._urlconf_setup()",
            "        mail.outbox = []",
            "",
            "    def _urlconf_setup(self):",
            "        if hasattr(self, 'urls'):",
            "            warnings.warn(",
            "                \"SimpleTestCase.urls is deprecated and will be removed in \"",
            "                \"Django 2.0. Use @override_settings(ROOT_URLCONF=...) \"",
            "                \"in %s instead.\" % self.__class__.__name__,",
            "                RemovedInDjango20Warning, stacklevel=2)",
            "            set_urlconf(None)",
            "            self._old_root_urlconf = settings.ROOT_URLCONF",
            "            settings.ROOT_URLCONF = self.urls",
            "            clear_url_caches()",
            "",
            "    def _post_teardown(self):",
            "        \"\"\"Performs any post-test things. This includes:",
            "",
            "        * Putting back the original ROOT_URLCONF if it was changed.",
            "        \"\"\"",
            "        self._urlconf_teardown()",
            "",
            "    def _urlconf_teardown(self):",
            "        if hasattr(self, '_old_root_urlconf'):",
            "            set_urlconf(None)",
            "            settings.ROOT_URLCONF = self._old_root_urlconf",
            "            clear_url_caches()",
            "",
            "    def settings(self, **kwargs):",
            "        \"\"\"",
            "        A context manager that temporarily sets a setting and reverts to the original value when exiting the context.",
            "        \"\"\"",
            "        return override_settings(**kwargs)",
            "",
            "    def modify_settings(self, **kwargs):",
            "        \"\"\"",
            "        A context manager that temporarily applies changes a list setting and",
            "        reverts back to the original value when exiting the context.",
            "        \"\"\"",
            "        return modify_settings(**kwargs)",
            "",
            "    def assertRedirects(self, response, expected_url, status_code=302,",
            "                        target_status_code=200, host=None, msg_prefix='',",
            "                        fetch_redirect_response=True):",
            "        \"\"\"Asserts that a response redirected to a specific URL, and that the",
            "        redirect URL can be loaded.",
            "",
            "        Note that assertRedirects won't work for external links since it uses",
            "        TestClient to do a request (use fetch_redirect_response=False to check",
            "        such links without fetching them).",
            "        \"\"\"",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(expected_url)",
            "",
            "        if hasattr(response, 'redirect_chain'):",
            "            # The request was a followed redirect",
            "            self.assertTrue(len(response.redirect_chain) > 0,",
            "                msg_prefix + \"Response didn't redirect as expected: Response\"",
            "                \" code was %d (expected %d)\" %",
            "                    (response.status_code, status_code))",
            "",
            "            self.assertEqual(response.redirect_chain[0][1], status_code,",
            "                msg_prefix + \"Initial response didn't redirect as expected:\"",
            "                \" Response code was %d (expected %d)\" %",
            "                    (response.redirect_chain[0][1], status_code))",
            "",
            "            url, status_code = response.redirect_chain[-1]",
            "            scheme, netloc, path, query, fragment = urlsplit(url)",
            "",
            "            self.assertEqual(response.status_code, target_status_code,",
            "                msg_prefix + \"Response didn't redirect as expected: Final\"",
            "                \" Response code was %d (expected %d)\" %",
            "                    (response.status_code, target_status_code))",
            "",
            "        else:",
            "            # Not a followed redirect",
            "            self.assertEqual(response.status_code, status_code,",
            "                msg_prefix + \"Response didn't redirect as expected: Response\"",
            "                \" code was %d (expected %d)\" %",
            "                    (response.status_code, status_code))",
            "",
            "            url = response.url",
            "            scheme, netloc, path, query, fragment = urlsplit(url)",
            "",
            "            if fetch_redirect_response:",
            "                redirect_response = response.client.get(path, QueryDict(query),",
            "                                                        secure=(scheme == 'https'))",
            "",
            "                # Get the redirection page, using the same client that was used",
            "                # to obtain the original response.",
            "                self.assertEqual(redirect_response.status_code, target_status_code,",
            "                    msg_prefix + \"Couldn't retrieve redirection page '%s':\"",
            "                    \" response code was %d (expected %d)\" %",
            "                        (path, redirect_response.status_code, target_status_code))",
            "",
            "        e_scheme = e_scheme if e_scheme else scheme or 'http'",
            "        e_netloc = e_netloc if e_netloc else host or 'testserver'",
            "        expected_url = urlunsplit((e_scheme, e_netloc, e_path, e_query,",
            "            e_fragment))",
            "",
            "        self.assertEqual(url, expected_url,",
            "            msg_prefix + \"Response redirected to '%s', expected '%s'\" %",
            "                (url, expected_url))",
            "",
            "    def _assert_contains(self, response, text, status_code, msg_prefix, html):",
            "        # If the response supports deferred rendering and hasn't been rendered",
            "        # yet, then ensure that it does get rendered before proceeding further.",
            "        if (hasattr(response, 'render') and callable(response.render)",
            "                and not response.is_rendered):",
            "            response.render()",
            "",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        self.assertEqual(response.status_code, status_code,",
            "            msg_prefix + \"Couldn't retrieve content: Response code was %d\"",
            "            \" (expected %d)\" % (response.status_code, status_code))",
            "",
            "        if response.streaming:",
            "            content = b''.join(response.streaming_content)",
            "        else:",
            "            content = response.content",
            "        if not isinstance(text, bytes) or html:",
            "            text = force_text(text, encoding=response.charset)",
            "            content = content.decode(response.charset)",
            "            text_repr = \"'%s'\" % text",
            "        else:",
            "            text_repr = repr(text)",
            "        if html:",
            "            content = assert_and_parse_html(self, content, None,",
            "                \"Response's content is not valid HTML:\")",
            "            text = assert_and_parse_html(self, text, None,",
            "                \"Second argument is not valid HTML:\")",
            "        real_count = content.count(text)",
            "        return (text_repr, real_count, msg_prefix)",
            "",
            "    def assertContains(self, response, text, count=None, status_code=200,",
            "                       msg_prefix='', html=False):",
            "        \"\"\"",
            "        Asserts that a response indicates that some content was retrieved",
            "        successfully, (i.e., the HTTP status code was as expected), and that",
            "        ``text`` occurs ``count`` times in the content of the response.",
            "        If ``count`` is None, the count doesn't matter - the assertion is true",
            "        if the text occurs at least once in the response.",
            "        \"\"\"",
            "        text_repr, real_count, msg_prefix = self._assert_contains(",
            "            response, text, status_code, msg_prefix, html)",
            "",
            "        if count is not None:",
            "            self.assertEqual(real_count, count,",
            "                msg_prefix + \"Found %d instances of %s in response\"",
            "                \" (expected %d)\" % (real_count, text_repr, count))",
            "        else:",
            "            self.assertTrue(real_count != 0,",
            "                msg_prefix + \"Couldn't find %s in response\" % text_repr)",
            "",
            "    def assertNotContains(self, response, text, status_code=200,",
            "                          msg_prefix='', html=False):",
            "        \"\"\"",
            "        Asserts that a response indicates that some content was retrieved",
            "        successfully, (i.e., the HTTP status code was as expected), and that",
            "        ``text`` doesn't occurs in the content of the response.",
            "        \"\"\"",
            "        text_repr, real_count, msg_prefix = self._assert_contains(",
            "            response, text, status_code, msg_prefix, html)",
            "",
            "        self.assertEqual(real_count, 0,",
            "                msg_prefix + \"Response should not contain %s\" % text_repr)",
            "",
            "    def assertFormError(self, response, form, field, errors, msg_prefix=''):",
            "        \"\"\"",
            "        Asserts that a form used to render the response has a specific field",
            "        error.",
            "        \"\"\"",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        # Put context(s) into a list to simplify processing.",
            "        contexts = to_list(response.context)",
            "        if not contexts:",
            "            self.fail(msg_prefix + \"Response did not use any contexts to \"",
            "                      \"render the response\")",
            "",
            "        # Put error(s) into a list to simplify processing.",
            "        errors = to_list(errors)",
            "",
            "        # Search all contexts for the error.",
            "        found_form = False",
            "        for i, context in enumerate(contexts):",
            "            if form not in context:",
            "                continue",
            "            found_form = True",
            "            for err in errors:",
            "                if field:",
            "                    if field in context[form].errors:",
            "                        field_errors = context[form].errors[field]",
            "                        self.assertTrue(err in field_errors,",
            "                            msg_prefix + \"The field '%s' on form '%s' in\"",
            "                            \" context %d does not contain the error '%s'\"",
            "                            \" (actual errors: %s)\" %",
            "                            (field, form, i, err, repr(field_errors)))",
            "                    elif field in context[form].fields:",
            "                        self.fail(msg_prefix + \"The field '%s' on form '%s'\"",
            "                                  \" in context %d contains no errors\" %",
            "                                  (field, form, i))",
            "                    else:",
            "                        self.fail(msg_prefix + \"The form '%s' in context %d\"",
            "                                  \" does not contain the field '%s'\" %",
            "                                  (form, i, field))",
            "                else:",
            "                    non_field_errors = context[form].non_field_errors()",
            "                    self.assertTrue(err in non_field_errors,",
            "                        msg_prefix + \"The form '%s' in context %d does not\"",
            "                        \" contain the non-field error '%s'\"",
            "                        \" (actual errors: %s)\" %",
            "                            (form, i, err, non_field_errors))",
            "        if not found_form:",
            "            self.fail(msg_prefix + \"The form '%s' was not used to render the\"",
            "                      \" response\" % form)",
            "",
            "    def assertFormsetError(self, response, formset, form_index, field, errors,",
            "                           msg_prefix=''):",
            "        \"\"\"",
            "        Asserts that a formset used to render the response has a specific error.",
            "",
            "        For field errors, specify the ``form_index`` and the ``field``.",
            "        For non-field errors, specify the ``form_index`` and the ``field`` as",
            "        None.",
            "        For non-form errors, specify ``form_index`` as None and the ``field``",
            "        as None.",
            "        \"\"\"",
            "        # Add punctuation to msg_prefix",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        # Put context(s) into a list to simplify processing.",
            "        contexts = to_list(response.context)",
            "        if not contexts:",
            "            self.fail(msg_prefix + 'Response did not use any contexts to '",
            "                      'render the response')",
            "",
            "        # Put error(s) into a list to simplify processing.",
            "        errors = to_list(errors)",
            "",
            "        # Search all contexts for the error.",
            "        found_formset = False",
            "        for i, context in enumerate(contexts):",
            "            if formset not in context:",
            "                continue",
            "            found_formset = True",
            "            for err in errors:",
            "                if field is not None:",
            "                    if field in context[formset].forms[form_index].errors:",
            "                        field_errors = context[formset].forms[form_index].errors[field]",
            "                        self.assertTrue(err in field_errors,",
            "                                msg_prefix + \"The field '%s' on formset '%s', \"",
            "                                \"form %d in context %d does not contain the \"",
            "                                \"error '%s' (actual errors: %s)\" %",
            "                                (field, formset, form_index, i, err,",
            "                                 repr(field_errors)))",
            "                    elif field in context[formset].forms[form_index].fields:",
            "                        self.fail(msg_prefix + \"The field '%s' \"",
            "                                  \"on formset '%s', form %d in \"",
            "                                  \"context %d contains no errors\" %",
            "                                  (field, formset, form_index, i))",
            "                    else:",
            "                        self.fail(msg_prefix + \"The formset '%s', form %d in \"",
            "                                  \"context %d does not contain the field '%s'\" %",
            "                                  (formset, form_index, i, field))",
            "                elif form_index is not None:",
            "                    non_field_errors = context[formset].forms[form_index].non_field_errors()",
            "                    self.assertFalse(len(non_field_errors) == 0,",
            "                                     msg_prefix + \"The formset '%s', form %d in \"",
            "                                     \"context %d does not contain any non-field \"",
            "                                     \"errors.\" % (formset, form_index, i))",
            "                    self.assertTrue(err in non_field_errors,",
            "                                    msg_prefix + \"The formset '%s', form %d \"",
            "                                    \"in context %d does not contain the \"",
            "                                    \"non-field error '%s' \"",
            "                                    \"(actual errors: %s)\" %",
            "                                    (formset, form_index, i, err,",
            "                                     repr(non_field_errors)))",
            "                else:",
            "                    non_form_errors = context[formset].non_form_errors()",
            "                    self.assertFalse(len(non_form_errors) == 0,",
            "                                     msg_prefix + \"The formset '%s' in \"",
            "                                     \"context %d does not contain any \"",
            "                                     \"non-form errors.\" % (formset, i))",
            "                    self.assertTrue(err in non_form_errors,",
            "                                    msg_prefix + \"The formset '%s' in context \"",
            "                                    \"%d does not contain the \"",
            "                                    \"non-form error '%s' (actual errors: %s)\" %",
            "                                    (formset, i, err, repr(non_form_errors)))",
            "        if not found_formset:",
            "            self.fail(msg_prefix + \"The formset '%s' was not used to render \"",
            "                      \"the response\" % formset)",
            "",
            "    def _assert_template_used(self, response, template_name, msg_prefix):",
            "",
            "        if response is None and template_name is None:",
            "            raise TypeError('response and/or template_name argument must be provided')",
            "",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        if template_name is not None and response is not None and not hasattr(response, 'templates'):",
            "            raise ValueError(",
            "                \"assertTemplateUsed() and assertTemplateNotUsed() are only \"",
            "                \"usable on responses fetched using the Django test Client.\"",
            "            )",
            "",
            "        if not hasattr(response, 'templates') or (response is None and template_name):",
            "            if response:",
            "                template_name = response",
            "                response = None",
            "            # use this template with context manager",
            "            return template_name, None, msg_prefix",
            "",
            "        template_names = [t.name for t in response.templates if t.name is not",
            "                          None]",
            "        return None, template_names, msg_prefix",
            "",
            "    def assertTemplateUsed(self, response=None, template_name=None, msg_prefix='', count=None):",
            "        \"\"\"",
            "        Asserts that the template with the provided name was used in rendering",
            "        the response. Also usable as context manager.",
            "        \"\"\"",
            "        context_mgr_template, template_names, msg_prefix = self._assert_template_used(",
            "            response, template_name, msg_prefix)",
            "",
            "        if context_mgr_template:",
            "            # Use assertTemplateUsed as context manager.",
            "            return _AssertTemplateUsedContext(self, context_mgr_template)",
            "",
            "        if not template_names:",
            "            self.fail(msg_prefix + \"No templates used to render the response\")",
            "        self.assertTrue(template_name in template_names,",
            "            msg_prefix + \"Template '%s' was not a template used to render\"",
            "            \" the response. Actual template(s) used: %s\" %",
            "                (template_name, ', '.join(template_names)))",
            "",
            "        if count is not None:",
            "            self.assertEqual(template_names.count(template_name), count,",
            "                msg_prefix + \"Template '%s' was expected to be rendered %d \"",
            "                \"time(s) but was actually rendered %d time(s).\" %",
            "                    (template_name, count, template_names.count(template_name)))",
            "",
            "    def assertTemplateNotUsed(self, response=None, template_name=None, msg_prefix=''):",
            "        \"\"\"",
            "        Asserts that the template with the provided name was NOT used in",
            "        rendering the response. Also usable as context manager.",
            "        \"\"\"",
            "",
            "        context_mgr_template, template_names, msg_prefix = self._assert_template_used(",
            "            response, template_name, msg_prefix)",
            "",
            "        if context_mgr_template:",
            "            # Use assertTemplateNotUsed as context manager.",
            "            return _AssertTemplateNotUsedContext(self, context_mgr_template)",
            "",
            "        self.assertFalse(template_name in template_names,",
            "            msg_prefix + \"Template '%s' was used unexpectedly in rendering\"",
            "            \" the response\" % template_name)",
            "",
            "    def assertRaisesMessage(self, expected_exception, expected_message,",
            "                           callable_obj=None, *args, **kwargs):",
            "        \"\"\"",
            "        Asserts that the message in a raised exception matches the passed",
            "        value.",
            "",
            "        Args:",
            "            expected_exception: Exception class expected to be raised.",
            "            expected_message: expected error message string value.",
            "            callable_obj: Function to be called.",
            "            args: Extra args.",
            "            kwargs: Extra kwargs.",
            "        \"\"\"",
            "        return six.assertRaisesRegex(self, expected_exception,",
            "                re.escape(expected_message), callable_obj, *args, **kwargs)",
            "",
            "    def assertFieldOutput(self, fieldclass, valid, invalid, field_args=None,",
            "            field_kwargs=None, empty_value=''):",
            "        \"\"\"",
            "        Asserts that a form field behaves correctly with various inputs.",
            "",
            "        Args:",
            "            fieldclass: the class of the field to be tested.",
            "            valid: a dictionary mapping valid inputs to their expected",
            "                    cleaned values.",
            "            invalid: a dictionary mapping invalid inputs to one or more",
            "                    raised error messages.",
            "            field_args: the args passed to instantiate the field",
            "            field_kwargs: the kwargs passed to instantiate the field",
            "            empty_value: the expected clean output for inputs in empty_values",
            "",
            "        \"\"\"",
            "        if field_args is None:",
            "            field_args = []",
            "        if field_kwargs is None:",
            "            field_kwargs = {}",
            "        required = fieldclass(*field_args, **field_kwargs)",
            "        optional = fieldclass(*field_args,",
            "                              **dict(field_kwargs, required=False))",
            "        # test valid inputs",
            "        for input, output in valid.items():",
            "            self.assertEqual(required.clean(input), output)",
            "            self.assertEqual(optional.clean(input), output)",
            "        # test invalid inputs",
            "        for input, errors in invalid.items():",
            "            with self.assertRaises(ValidationError) as context_manager:",
            "                required.clean(input)",
            "            self.assertEqual(context_manager.exception.messages, errors)",
            "",
            "            with self.assertRaises(ValidationError) as context_manager:",
            "                optional.clean(input)",
            "            self.assertEqual(context_manager.exception.messages, errors)",
            "        # test required inputs",
            "        error_required = [force_text(required.error_messages['required'])]",
            "        for e in required.empty_values:",
            "            with self.assertRaises(ValidationError) as context_manager:",
            "                required.clean(e)",
            "            self.assertEqual(context_manager.exception.messages,",
            "                             error_required)",
            "            self.assertEqual(optional.clean(e), empty_value)",
            "        # test that max_length and min_length are always accepted",
            "        if issubclass(fieldclass, CharField):",
            "            field_kwargs.update({'min_length': 2, 'max_length': 20})",
            "            self.assertIsInstance(fieldclass(*field_args, **field_kwargs),",
            "                                  fieldclass)",
            "",
            "    def assertHTMLEqual(self, html1, html2, msg=None):",
            "        \"\"\"",
            "        Asserts that two HTML snippets are semantically the same.",
            "        Whitespace in most cases is ignored, and attribute ordering is not",
            "        significant. The passed-in arguments must be valid HTML.",
            "        \"\"\"",
            "        dom1 = assert_and_parse_html(self, html1, msg,",
            "            'First argument is not valid HTML:')",
            "        dom2 = assert_and_parse_html(self, html2, msg,",
            "            'Second argument is not valid HTML:')",
            "",
            "        if dom1 != dom2:",
            "            standardMsg = '%s != %s' % (",
            "                safe_repr(dom1, True), safe_repr(dom2, True))",
            "            diff = ('\\n' + '\\n'.join(difflib.ndiff(",
            "                           six.text_type(dom1).splitlines(),",
            "                           six.text_type(dom2).splitlines())))",
            "            standardMsg = self._truncateMessage(standardMsg, diff)",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "    def assertHTMLNotEqual(self, html1, html2, msg=None):",
            "        \"\"\"Asserts that two HTML snippets are not semantically equivalent.\"\"\"",
            "        dom1 = assert_and_parse_html(self, html1, msg,",
            "            'First argument is not valid HTML:')",
            "        dom2 = assert_and_parse_html(self, html2, msg,",
            "            'Second argument is not valid HTML:')",
            "",
            "        if dom1 == dom2:",
            "            standardMsg = '%s == %s' % (",
            "                safe_repr(dom1, True), safe_repr(dom2, True))",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "    def assertInHTML(self, needle, haystack, count=None, msg_prefix=''):",
            "        needle = assert_and_parse_html(self, needle, None,",
            "            'First argument is not valid HTML:')",
            "        haystack = assert_and_parse_html(self, haystack, None,",
            "            'Second argument is not valid HTML:')",
            "        real_count = haystack.count(needle)",
            "        if count is not None:",
            "            self.assertEqual(real_count, count,",
            "                msg_prefix + \"Found %d instances of '%s' in response\"",
            "                \" (expected %d)\" % (real_count, needle, count))",
            "        else:",
            "            self.assertTrue(real_count != 0,",
            "                msg_prefix + \"Couldn't find '%s' in response\" % needle)",
            "",
            "    def assertJSONEqual(self, raw, expected_data, msg=None):",
            "        \"\"\"",
            "        Asserts that the JSON fragments raw and expected_data are equal.",
            "        Usual JSON non-significant whitespace rules apply as the heavyweight",
            "        is delegated to the json library.",
            "        \"\"\"",
            "        try:",
            "            data = json.loads(raw)",
            "        except ValueError:",
            "            self.fail(\"First argument is not valid JSON: %r\" % raw)",
            "        if isinstance(expected_data, six.string_types):",
            "            try:",
            "                expected_data = json.loads(expected_data)",
            "            except ValueError:",
            "                self.fail(\"Second argument is not valid JSON: %r\" % expected_data)",
            "        self.assertEqual(data, expected_data, msg=msg)",
            "",
            "    def assertJSONNotEqual(self, raw, expected_data, msg=None):",
            "        \"\"\"",
            "        Asserts that the JSON fragments raw and expected_data are not equal.",
            "        Usual JSON non-significant whitespace rules apply as the heavyweight",
            "        is delegated to the json library.",
            "        \"\"\"",
            "        try:",
            "            data = json.loads(raw)",
            "        except ValueError:",
            "            self.fail(\"First argument is not valid JSON: %r\" % raw)",
            "        if isinstance(expected_data, six.string_types):",
            "            try:",
            "                expected_data = json.loads(expected_data)",
            "            except ValueError:",
            "                self.fail(\"Second argument is not valid JSON: %r\" % expected_data)",
            "        self.assertNotEqual(data, expected_data, msg=msg)",
            "",
            "    def assertXMLEqual(self, xml1, xml2, msg=None):",
            "        \"\"\"",
            "        Asserts that two XML snippets are semantically the same.",
            "        Whitespace in most cases is ignored, and attribute ordering is not",
            "        significant. The passed-in arguments must be valid XML.",
            "        \"\"\"",
            "        try:",
            "            result = compare_xml(xml1, xml2)",
            "        except Exception as e:",
            "            standardMsg = 'First or second argument is not valid XML\\n%s' % e",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "        else:",
            "            if not result:",
            "                standardMsg = '%s != %s' % (safe_repr(xml1, True), safe_repr(xml2, True))",
            "                self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "    def assertXMLNotEqual(self, xml1, xml2, msg=None):",
            "        \"\"\"",
            "        Asserts that two XML snippets are not semantically equivalent.",
            "        Whitespace in most cases is ignored, and attribute ordering is not",
            "        significant. The passed-in arguments must be valid XML.",
            "        \"\"\"",
            "        try:",
            "            result = compare_xml(xml1, xml2)",
            "        except Exception as e:",
            "            standardMsg = 'First or second argument is not valid XML\\n%s' % e",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "        else:",
            "            if result:",
            "                standardMsg = '%s == %s' % (safe_repr(xml1, True), safe_repr(xml2, True))",
            "                self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "",
            "class TransactionTestCase(SimpleTestCase):",
            "",
            "    # Subclasses can ask for resetting of auto increment sequence before each",
            "    # test case",
            "    reset_sequences = False",
            "",
            "    # Subclasses can enable only a subset of apps for faster tests",
            "    available_apps = None",
            "",
            "    # Subclasses can define fixtures which will be automatically installed.",
            "    fixtures = None",
            "",
            "    # If transactions aren't available, Django will serialize the database",
            "    # contents into a fixture during setup and flush and reload them",
            "    # during teardown (as flush does not restore data from migrations).",
            "    # This can be slow; this flag allows enabling on a per-case basis.",
            "    serialized_rollback = False",
            "",
            "    def _pre_setup(self):",
            "        \"\"\"Performs any pre-test setup. This includes:",
            "",
            "        * If the class has an 'available_apps' attribute, restricting the app",
            "          registry to these applications, then firing post_migrate -- it must",
            "          run with the correct set of applications for the test case.",
            "        * If the class has a 'fixtures' attribute, installing these fixtures.",
            "        \"\"\"",
            "        super(TransactionTestCase, self)._pre_setup()",
            "        if self.available_apps is not None:",
            "            apps.set_available_apps(self.available_apps)",
            "            setting_changed.send(sender=settings._wrapped.__class__,",
            "                                 setting='INSTALLED_APPS',",
            "                                 value=self.available_apps,",
            "                                 enter=True)",
            "            for db_name in self._databases_names(include_mirrors=False):",
            "                emit_post_migrate_signal(verbosity=0, interactive=False, db=db_name)",
            "        try:",
            "            self._fixture_setup()",
            "        except Exception:",
            "            if self.available_apps is not None:",
            "                apps.unset_available_apps()",
            "                setting_changed.send(sender=settings._wrapped.__class__,",
            "                                     setting='INSTALLED_APPS',",
            "                                     value=settings.INSTALLED_APPS,",
            "                                     enter=False)",
            "",
            "            raise",
            "",
            "    @classmethod",
            "    def _databases_names(cls, include_mirrors=True):",
            "        # If the test case has a multi_db=True flag, act on all databases,",
            "        # including mirrors or not. Otherwise, just on the default DB.",
            "        if getattr(cls, 'multi_db', False):",
            "            return [alias for alias in connections",
            "                    if include_mirrors or not connections[alias].settings_dict['TEST']['MIRROR']]",
            "        else:",
            "            return [DEFAULT_DB_ALIAS]",
            "",
            "    def _reset_sequences(self, db_name):",
            "        conn = connections[db_name]",
            "        if conn.features.supports_sequence_reset:",
            "            sql_list = conn.ops.sequence_reset_by_name_sql(",
            "                no_style(), conn.introspection.sequence_list())",
            "            if sql_list:",
            "                with transaction.atomic(using=db_name):",
            "                    cursor = conn.cursor()",
            "                    for sql in sql_list:",
            "                        cursor.execute(sql)",
            "",
            "    def _fixture_setup(self):",
            "        for db_name in self._databases_names(include_mirrors=False):",
            "            # Reset sequences",
            "            if self.reset_sequences:",
            "                self._reset_sequences(db_name)",
            "",
            "            # If we need to provide replica initial data from migrated apps,",
            "            # then do so.",
            "            if self.serialized_rollback and hasattr(connections[db_name], \"_test_serialized_contents\"):",
            "                if self.available_apps is not None:",
            "                    apps.unset_available_apps()",
            "                connections[db_name].creation.deserialize_db_from_string(",
            "                    connections[db_name]._test_serialized_contents",
            "                )",
            "                if self.available_apps is not None:",
            "                    apps.set_available_apps(self.available_apps)",
            "",
            "            if self.fixtures:",
            "                # We have to use this slightly awkward syntax due to the fact",
            "                # that we're using *args and **kwargs together.",
            "                call_command('loaddata', *self.fixtures,",
            "                             **{'verbosity': 0, 'database': db_name})",
            "",
            "    def _should_reload_connections(self):",
            "        return True",
            "",
            "    def _post_teardown(self):",
            "        \"\"\"Performs any post-test things. This includes:",
            "",
            "        * Flushing the contents of the database, to leave a clean slate. If",
            "          the class has an 'available_apps' attribute, post_migrate isn't fired.",
            "        * Force-closing the connection, so the next test gets a clean cursor.",
            "        \"\"\"",
            "        try:",
            "            self._fixture_teardown()",
            "            super(TransactionTestCase, self)._post_teardown()",
            "            if self._should_reload_connections():",
            "                # Some DB cursors include SQL statements as part of cursor",
            "                # creation. If you have a test that does a rollback, the effect",
            "                # of these statements is lost, which can affect the operation of",
            "                # tests (e.g., losing a timezone setting causing objects to be",
            "                # created with the wrong time). To make sure this doesn't",
            "                # happen, get a clean connection at the start of every test.",
            "                for conn in connections.all():",
            "                    conn.close()",
            "        finally:",
            "            if self.available_apps is not None:",
            "                apps.unset_available_apps()",
            "                setting_changed.send(sender=settings._wrapped.__class__,",
            "                                     setting='INSTALLED_APPS',",
            "                                     value=settings.INSTALLED_APPS,",
            "                                     enter=False)",
            "",
            "    def _fixture_teardown(self):",
            "        # Allow TRUNCATE ... CASCADE and don't emit the post_migrate signal",
            "        # when flushing only a subset of the apps",
            "        for db_name in self._databases_names(include_mirrors=False):",
            "            # Flush the database",
            "            call_command('flush', verbosity=0, interactive=False,",
            "                         database=db_name, reset_sequences=False,",
            "                         allow_cascade=self.available_apps is not None,",
            "                         inhibit_post_migrate=self.available_apps is not None)",
            "",
            "    def assertQuerysetEqual(self, qs, values, transform=repr, ordered=True, msg=None):",
            "        items = six.moves.map(transform, qs)",
            "        if not ordered:",
            "            return self.assertEqual(Counter(items), Counter(values), msg=msg)",
            "        values = list(values)",
            "        # For example qs.iterator() could be passed as qs, but it does not",
            "        # have 'ordered' attribute.",
            "        if len(values) > 1 and hasattr(qs, 'ordered') and not qs.ordered:",
            "            raise ValueError(\"Trying to compare non-ordered queryset \"",
            "                             \"against more than one ordered values\")",
            "        return self.assertEqual(list(items), values, msg=msg)",
            "",
            "    def assertNumQueries(self, num, func=None, *args, **kwargs):",
            "        using = kwargs.pop(\"using\", DEFAULT_DB_ALIAS)",
            "        conn = connections[using]",
            "",
            "        context = _AssertNumQueriesContext(self, num, conn)",
            "        if func is None:",
            "            return context",
            "",
            "        with context:",
            "            func(*args, **kwargs)",
            "",
            "",
            "def connections_support_transactions():",
            "    \"\"\"",
            "    Returns True if all connections support transactions.",
            "    \"\"\"",
            "    return all(conn.features.supports_transactions",
            "               for conn in connections.all())",
            "",
            "",
            "class TestCase(TransactionTestCase):",
            "    \"\"\"",
            "    Similar to TransactionTestCase, but uses `transaction.atomic()` to achieve",
            "    test isolation.",
            "",
            "    In most situation, TestCase should be prefered to TransactionTestCase as",
            "    it allows faster execution. However, there are some situations where using",
            "    TransactionTestCase might be necessary (e.g. testing some transactional",
            "    behavior).",
            "",
            "    On database backends with no transaction support, TestCase behaves as",
            "    TransactionTestCase.",
            "    \"\"\"",
            "    @classmethod",
            "    def _enter_atomics(cls):",
            "        \"\"\"Helper method to open atomic blocks for multiple databases\"\"\"",
            "        atomics = {}",
            "        for db_name in cls._databases_names():",
            "            atomics[db_name] = transaction.atomic(using=db_name)",
            "            atomics[db_name].__enter__()",
            "        return atomics",
            "",
            "    @classmethod",
            "    def _rollback_atomics(cls, atomics):",
            "        \"\"\"Rollback atomic blocks opened through the previous method\"\"\"",
            "        for db_name in reversed(cls._databases_names()):",
            "            transaction.set_rollback(True, using=db_name)",
            "            atomics[db_name].__exit__(None, None, None)",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        super(TestCase, cls).setUpClass()",
            "        if not connections_support_transactions():",
            "            return",
            "        cls.cls_atomics = cls._enter_atomics()",
            "",
            "        if cls.fixtures:",
            "            for db_name in cls._databases_names(include_mirrors=False):",
            "                    try:",
            "                        call_command('loaddata', *cls.fixtures, **{",
            "                            'verbosity': 0,",
            "                            'commit': False,",
            "                            'database': db_name,",
            "                        })",
            "                    except Exception:",
            "                        cls._rollback_atomics(cls.cls_atomics)",
            "                        raise",
            "        cls.setUpTestData()",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        if connections_support_transactions():",
            "            cls._rollback_atomics(cls.cls_atomics)",
            "            for conn in connections.all():",
            "                conn.close()",
            "        super(TestCase, cls).tearDownClass()",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        \"\"\"Load initial data for the TestCase\"\"\"",
            "        pass",
            "",
            "    def _should_reload_connections(self):",
            "        if connections_support_transactions():",
            "            return False",
            "        return super(TestCase, self)._should_reload_connections()",
            "",
            "    def _fixture_setup(self):",
            "        if not connections_support_transactions():",
            "            # If the backend does not support transactions, we should reload",
            "            # class data before each test",
            "            self.setUpTestData()",
            "            return super(TestCase, self)._fixture_setup()",
            "",
            "        assert not self.reset_sequences, 'reset_sequences cannot be used on TestCase instances'",
            "        self.atomics = self._enter_atomics()",
            "",
            "    def _fixture_teardown(self):",
            "        if not connections_support_transactions():",
            "            return super(TestCase, self)._fixture_teardown()",
            "        self._rollback_atomics(self.atomics)",
            "",
            "",
            "class CheckCondition(object):",
            "    \"\"\"Descriptor class for deferred condition checking\"\"\"",
            "    def __init__(self, cond_func):",
            "        self.cond_func = cond_func",
            "",
            "    def __get__(self, obj, objtype):",
            "        return self.cond_func()",
            "",
            "",
            "def _deferredSkip(condition, reason):",
            "    def decorator(test_func):",
            "        if not (isinstance(test_func, type) and",
            "                issubclass(test_func, unittest.TestCase)):",
            "            @wraps(test_func)",
            "            def skip_wrapper(*args, **kwargs):",
            "                if condition():",
            "                    raise unittest.SkipTest(reason)",
            "                return test_func(*args, **kwargs)",
            "            test_item = skip_wrapper",
            "        else:",
            "            # Assume a class is decorated",
            "            test_item = test_func",
            "            test_item.__unittest_skip__ = CheckCondition(condition)",
            "        test_item.__unittest_skip_why__ = reason",
            "        return test_item",
            "    return decorator",
            "",
            "",
            "def skipIfDBFeature(*features):",
            "    \"\"\"",
            "    Skip a test if a database has at least one of the named features.",
            "    \"\"\"",
            "    return _deferredSkip(",
            "        lambda: any(getattr(connection.features, feature, False) for feature in features),",
            "        \"Database has feature(s) %s\" % \", \".join(features)",
            "    )",
            "",
            "",
            "def skipUnlessDBFeature(*features):",
            "    \"\"\"",
            "    Skip a test unless a database has all the named features.",
            "    \"\"\"",
            "    return _deferredSkip(",
            "        lambda: not all(getattr(connection.features, feature, False) for feature in features),",
            "        \"Database doesn't support feature(s): %s\" % \", \".join(features)",
            "    )",
            "",
            "",
            "class QuietWSGIRequestHandler(WSGIRequestHandler):",
            "    \"\"\"",
            "    Just a regular WSGIRequestHandler except it doesn't log to the standard",
            "    output any of the requests received, so as to not clutter the output for",
            "    the tests' results.",
            "    \"\"\"",
            "",
            "    def log_message(*args):",
            "        pass",
            "",
            "",
            "class FSFilesHandler(WSGIHandler):",
            "    \"\"\"",
            "    WSGI middleware that intercepts calls to a directory, as defined by one of",
            "    the *_ROOT settings, and serves those files, publishing them under *_URL.",
            "    \"\"\"",
            "    def __init__(self, application):",
            "        self.application = application",
            "        self.base_url = urlparse(self.get_base_url())",
            "        super(FSFilesHandler, self).__init__()",
            "",
            "    def _should_handle(self, path):",
            "        \"\"\"",
            "        Checks if the path should be handled. Ignores the path if:",
            "",
            "        * the host is provided as part of the base_url",
            "        * the request's path isn't under the media path (or equal)",
            "        \"\"\"",
            "        return path.startswith(self.base_url[2]) and not self.base_url[1]",
            "",
            "    def file_path(self, url):",
            "        \"\"\"",
            "        Returns the relative path to the file on disk for the given URL.",
            "        \"\"\"",
            "        relative_url = url[len(self.base_url[2]):]",
            "        return url2pathname(relative_url)",
            "",
            "    def get_response(self, request):",
            "        from django.http import Http404",
            "",
            "        if self._should_handle(request.path):",
            "            try:",
            "                return self.serve(request)",
            "            except Http404:",
            "                pass",
            "        return super(FSFilesHandler, self).get_response(request)",
            "",
            "    def serve(self, request):",
            "        os_rel_path = self.file_path(request.path)",
            "        os_rel_path = posixpath.normpath(unquote(os_rel_path))",
            "        # Emulate behavior of django.contrib.staticfiles.views.serve() when it",
            "        # invokes staticfiles' finders functionality.",
            "        # TODO: Modify if/when that internal API is refactored",
            "        final_rel_path = os_rel_path.replace('\\\\', '/').lstrip('/')",
            "        return serve(request, final_rel_path, document_root=self.get_base_dir())",
            "",
            "    def __call__(self, environ, start_response):",
            "        if not self._should_handle(get_path_info(environ)):",
            "            return self.application(environ, start_response)",
            "        return super(FSFilesHandler, self).__call__(environ, start_response)",
            "",
            "",
            "class _StaticFilesHandler(FSFilesHandler):",
            "    \"\"\"",
            "    Handler for serving static files. A private class that is meant to be used",
            "    solely as a convenience by LiveServerThread.",
            "    \"\"\"",
            "",
            "    def get_base_dir(self):",
            "        return settings.STATIC_ROOT",
            "",
            "    def get_base_url(self):",
            "        return settings.STATIC_URL",
            "",
            "",
            "class _MediaFilesHandler(FSFilesHandler):",
            "    \"\"\"",
            "    Handler for serving the media files. A private class that is meant to be",
            "    used solely as a convenience by LiveServerThread.",
            "    \"\"\"",
            "",
            "    def get_base_dir(self):",
            "        return settings.MEDIA_ROOT",
            "",
            "    def get_base_url(self):",
            "        return settings.MEDIA_URL",
            "",
            "",
            "class LiveServerThread(threading.Thread):",
            "    \"\"\"",
            "    Thread for running a live http server while the tests are running.",
            "    \"\"\"",
            "",
            "    def __init__(self, host, possible_ports, static_handler, connections_override=None):",
            "        self.host = host",
            "        self.port = None",
            "        self.possible_ports = possible_ports",
            "        self.is_ready = threading.Event()",
            "        self.error = None",
            "        self.static_handler = static_handler",
            "        self.connections_override = connections_override",
            "        super(LiveServerThread, self).__init__()",
            "",
            "    def run(self):",
            "        \"\"\"",
            "        Sets up the live server and databases, and then loops over handling",
            "        http requests.",
            "        \"\"\"",
            "        if self.connections_override:",
            "            # Override this thread's database connections with the ones",
            "            # provided by the main thread.",
            "            for alias, conn in self.connections_override.items():",
            "                connections[alias] = conn",
            "        try:",
            "            # Create the handler for serving static and media files",
            "            handler = self.static_handler(_MediaFilesHandler(WSGIHandler()))",
            "",
            "            # Go through the list of possible ports, hoping that we can find",
            "            # one that is free to use for the WSGI server.",
            "            for index, port in enumerate(self.possible_ports):",
            "                try:",
            "                    self.httpd = WSGIServer(",
            "                        (self.host, port), QuietWSGIRequestHandler)",
            "                except socket.error as e:",
            "                    if (index + 1 < len(self.possible_ports) and",
            "                            e.errno == errno.EADDRINUSE):",
            "                        # This port is already in use, so we go on and try with",
            "                        # the next one in the list.",
            "                        continue",
            "                    else:",
            "                        # Either none of the given ports are free or the error",
            "                        # is something else than \"Address already in use\". So",
            "                        # we let that error bubble up to the main thread.",
            "                        raise",
            "                else:",
            "                    # A free port was found.",
            "                    self.port = port",
            "                    break",
            "",
            "            self.httpd.set_app(handler)",
            "            self.is_ready.set()",
            "            self.httpd.serve_forever()",
            "        except Exception as e:",
            "            self.error = e",
            "            self.is_ready.set()",
            "",
            "    def terminate(self):",
            "        if hasattr(self, 'httpd'):",
            "            # Stop the WSGI server",
            "            self.httpd.shutdown()",
            "            self.httpd.server_close()",
            "",
            "",
            "class LiveServerTestCase(TransactionTestCase):",
            "    \"\"\"",
            "    Does basically the same as TransactionTestCase but also launches a live",
            "    http server in a separate thread so that the tests may use another testing",
            "    framework, such as Selenium for example, instead of the built-in dummy",
            "    client.",
            "    Note that it inherits from TransactionTestCase instead of TestCase because",
            "    the threads do not share the same transactions (unless if using in-memory",
            "    sqlite) and each thread needs to commit all their transactions so that the",
            "    other thread can see the changes.",
            "    \"\"\"",
            "",
            "    static_handler = _StaticFilesHandler",
            "",
            "    @property",
            "    def live_server_url(self):",
            "        return 'http://%s:%s' % (",
            "            self.server_thread.host, self.server_thread.port)",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        super(LiveServerTestCase, cls).setUpClass()",
            "        connections_override = {}",
            "        for conn in connections.all():",
            "            # If using in-memory sqlite databases, pass the connections to",
            "            # the server thread.",
            "            if conn.vendor == 'sqlite' and conn.is_in_memory_db(conn.settings_dict['NAME']):",
            "                # Explicitly enable thread-shareability for this connection",
            "                conn.allow_thread_sharing = True",
            "                connections_override[conn.alias] = conn",
            "",
            "        # Launch the live server's thread",
            "        specified_address = os.environ.get(",
            "            'DJANGO_LIVE_TEST_SERVER_ADDRESS', 'localhost:8081')",
            "",
            "        # The specified ports may be of the form '8000-8010,8080,9200-9300'",
            "        # i.e. a comma-separated list of ports or ranges of ports, so we break",
            "        # it down into a detailed list of all possible ports.",
            "        possible_ports = []",
            "        try:",
            "            host, port_ranges = specified_address.split(':')",
            "            for port_range in port_ranges.split(','):",
            "                # A port range can be of either form: '8000' or '8000-8010'.",
            "                extremes = list(map(int, port_range.split('-')))",
            "                assert len(extremes) in [1, 2]",
            "                if len(extremes) == 1:",
            "                    # Port range of the form '8000'",
            "                    possible_ports.append(extremes[0])",
            "                else:",
            "                    # Port range of the form '8000-8010'",
            "                    for port in range(extremes[0], extremes[1] + 1):",
            "                        possible_ports.append(port)",
            "        except Exception:",
            "            msg = 'Invalid address (\"%s\") for live server.' % specified_address",
            "            six.reraise(ImproperlyConfigured, ImproperlyConfigured(msg), sys.exc_info()[2])",
            "        cls.server_thread = LiveServerThread(host, possible_ports,",
            "                                             cls.static_handler,",
            "                                             connections_override=connections_override)",
            "        cls.server_thread.daemon = True",
            "        cls.server_thread.start()",
            "",
            "        # Wait for the live server to be ready",
            "        cls.server_thread.is_ready.wait()",
            "        if cls.server_thread.error:",
            "            # Clean up behind ourselves, since tearDownClass won't get called in",
            "            # case of errors.",
            "            cls._tearDownClassInternal()",
            "            raise cls.server_thread.error",
            "",
            "    @classmethod",
            "    def _tearDownClassInternal(cls):",
            "        # There may not be a 'server_thread' attribute if setUpClass() for some",
            "        # reasons has raised an exception.",
            "        if hasattr(cls, 'server_thread'):",
            "            # Terminate the live server's thread",
            "            cls.server_thread.terminate()",
            "            cls.server_thread.join()",
            "",
            "        # Restore sqlite in-memory database connections' non-shareability",
            "        for conn in connections.all():",
            "            if conn.vendor == 'sqlite' and conn.is_in_memory_db(conn.settings_dict['NAME']):",
            "                conn.allow_thread_sharing = False",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        cls._tearDownClassInternal()",
            "        super(LiveServerTestCase, cls).tearDownClass()"
        ],
        "afterPatchFile": [
            "from __future__ import unicode_literals",
            "",
            "import difflib",
            "import errno",
            "import json",
            "import os",
            "import posixpath",
            "import re",
            "import socket",
            "import sys",
            "import threading",
            "import unittest",
            "import warnings",
            "from collections import Counter",
            "from copy import copy",
            "from functools import wraps",
            "from unittest.util import safe_repr",
            "",
            "from django.apps import apps",
            "from django.conf import settings",
            "from django.core import mail",
            "from django.core.exceptions import ImproperlyConfigured, ValidationError",
            "from django.core.handlers.wsgi import WSGIHandler, get_path_info",
            "from django.core.management import call_command",
            "from django.core.management.color import no_style",
            "from django.core.management.sql import emit_post_migrate_signal",
            "from django.core.servers.basehttp import WSGIRequestHandler, WSGIServer",
            "from django.core.urlresolvers import clear_url_caches, set_urlconf",
            "from django.db import DEFAULT_DB_ALIAS, connection, connections, transaction",
            "from django.forms.fields import CharField",
            "from django.http import QueryDict",
            "from django.test.client import Client",
            "from django.test.html import HTMLParseError, parse_html",
            "from django.test.signals import setting_changed, template_rendered",
            "from django.test.utils import (",
            "    CaptureQueriesContext, ContextList, compare_xml, modify_settings,",
            "    override_settings,",
            ")",
            "from django.utils import six",
            "from django.utils.deprecation import (",
            "    RemovedInDjango20Warning, RemovedInDjango21Warning,",
            ")",
            "from django.utils.encoding import force_text",
            "from django.utils.six.moves.urllib.parse import (",
            "    unquote, urlparse, urlsplit, urlunsplit,",
            ")",
            "from django.utils.six.moves.urllib.request import url2pathname",
            "from django.views.static import serve",
            "",
            "__all__ = ('TestCase', 'TransactionTestCase',",
            "           'SimpleTestCase', 'skipIfDBFeature', 'skipUnlessDBFeature')",
            "",
            "",
            "def to_list(value):",
            "    \"\"\"",
            "    Puts value into a list if it's not already one.",
            "    Returns an empty list if value is None.",
            "    \"\"\"",
            "    if value is None:",
            "        value = []",
            "    elif not isinstance(value, list):",
            "        value = [value]",
            "    return value",
            "",
            "",
            "def assert_and_parse_html(self, html, user_msg, msg):",
            "    try:",
            "        dom = parse_html(html)",
            "    except HTMLParseError as e:",
            "        standardMsg = '%s\\n%s' % (msg, e.msg)",
            "        self.fail(self._formatMessage(user_msg, standardMsg))",
            "    return dom",
            "",
            "",
            "class _AssertNumQueriesContext(CaptureQueriesContext):",
            "    def __init__(self, test_case, num, connection):",
            "        self.test_case = test_case",
            "        self.num = num",
            "        super(_AssertNumQueriesContext, self).__init__(connection)",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        super(_AssertNumQueriesContext, self).__exit__(exc_type, exc_value, traceback)",
            "        if exc_type is not None:",
            "            return",
            "        executed = len(self)",
            "        self.test_case.assertEqual(",
            "            executed, self.num,",
            "            \"%d queries executed, %d expected\\nCaptured queries were:\\n%s\" % (",
            "                executed, self.num,",
            "                '\\n'.join(",
            "                    query['sql'] for query in self.captured_queries",
            "                )",
            "            )",
            "        )",
            "",
            "",
            "class _AssertTemplateUsedContext(object):",
            "    def __init__(self, test_case, template_name):",
            "        self.test_case = test_case",
            "        self.template_name = template_name",
            "        self.rendered_templates = []",
            "        self.rendered_template_names = []",
            "        self.context = ContextList()",
            "",
            "    def on_template_render(self, sender, signal, template, context, **kwargs):",
            "        self.rendered_templates.append(template)",
            "        self.rendered_template_names.append(template.name)",
            "        self.context.append(copy(context))",
            "",
            "    def test(self):",
            "        return self.template_name in self.rendered_template_names",
            "",
            "    def message(self):",
            "        return '%s was not rendered.' % self.template_name",
            "",
            "    def __enter__(self):",
            "        template_rendered.connect(self.on_template_render)",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        template_rendered.disconnect(self.on_template_render)",
            "        if exc_type is not None:",
            "            return",
            "",
            "        if not self.test():",
            "            message = self.message()",
            "            if len(self.rendered_templates) == 0:",
            "                message += ' No template was rendered.'",
            "            else:",
            "                message += ' Following templates were rendered: %s' % (",
            "                    ', '.join(self.rendered_template_names))",
            "            self.test_case.fail(message)",
            "",
            "",
            "class _AssertTemplateNotUsedContext(_AssertTemplateUsedContext):",
            "    def test(self):",
            "        return self.template_name not in self.rendered_template_names",
            "",
            "    def message(self):",
            "        return '%s was rendered.' % self.template_name",
            "",
            "",
            "class SimpleTestCase(unittest.TestCase):",
            "",
            "    # The class we'll use for the test client self.client.",
            "    # Can be overridden in derived classes.",
            "    client_class = Client",
            "    _overridden_settings = None",
            "    _modified_settings = None",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        super(SimpleTestCase, cls).setUpClass()",
            "        if cls._overridden_settings:",
            "            cls._cls_overridden_context = override_settings(**cls._overridden_settings)",
            "            cls._cls_overridden_context.enable()",
            "        if cls._modified_settings:",
            "            cls._cls_modified_context = modify_settings(cls._modified_settings)",
            "            cls._cls_modified_context.enable()",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        if hasattr(cls, '_cls_modified_context'):",
            "            cls._cls_modified_context.disable()",
            "            delattr(cls, '_cls_modified_context')",
            "        if hasattr(cls, '_cls_overridden_context'):",
            "            cls._cls_overridden_context.disable()",
            "            delattr(cls, '_cls_overridden_context')",
            "        super(SimpleTestCase, cls).tearDownClass()",
            "",
            "    def __call__(self, result=None):",
            "        \"\"\"",
            "        Wrapper around default __call__ method to perform common Django test",
            "        set up. This means that user-defined Test Cases aren't required to",
            "        include a call to super().setUp().",
            "        \"\"\"",
            "        testMethod = getattr(self, self._testMethodName)",
            "        skipped = (getattr(self.__class__, \"__unittest_skip__\", False) or",
            "            getattr(testMethod, \"__unittest_skip__\", False))",
            "",
            "        if not skipped:",
            "            try:",
            "                self._pre_setup()",
            "            except Exception:",
            "                result.addError(self, sys.exc_info())",
            "                return",
            "        super(SimpleTestCase, self).__call__(result)",
            "        if not skipped:",
            "            try:",
            "                self._post_teardown()",
            "            except Exception:",
            "                result.addError(self, sys.exc_info())",
            "                return",
            "",
            "    def _pre_setup(self):",
            "        \"\"\"Performs any pre-test setup. This includes:",
            "",
            "        * Creating a test client.",
            "        * If the class has a 'urls' attribute, replace ROOT_URLCONF with it.",
            "        * Clearing the mail test outbox.",
            "        \"\"\"",
            "        self.client = self.client_class()",
            "        self._urlconf_setup()",
            "        mail.outbox = []",
            "",
            "    def _urlconf_setup(self):",
            "        if hasattr(self, 'urls'):",
            "            warnings.warn(",
            "                \"SimpleTestCase.urls is deprecated and will be removed in \"",
            "                \"Django 2.0. Use @override_settings(ROOT_URLCONF=...) \"",
            "                \"in %s instead.\" % self.__class__.__name__,",
            "                RemovedInDjango20Warning, stacklevel=2)",
            "            set_urlconf(None)",
            "            self._old_root_urlconf = settings.ROOT_URLCONF",
            "            settings.ROOT_URLCONF = self.urls",
            "            clear_url_caches()",
            "",
            "    def _post_teardown(self):",
            "        \"\"\"Performs any post-test things. This includes:",
            "",
            "        * Putting back the original ROOT_URLCONF if it was changed.",
            "        \"\"\"",
            "        self._urlconf_teardown()",
            "",
            "    def _urlconf_teardown(self):",
            "        if hasattr(self, '_old_root_urlconf'):",
            "            set_urlconf(None)",
            "            settings.ROOT_URLCONF = self._old_root_urlconf",
            "            clear_url_caches()",
            "",
            "    def settings(self, **kwargs):",
            "        \"\"\"",
            "        A context manager that temporarily sets a setting and reverts to the original value when exiting the context.",
            "        \"\"\"",
            "        return override_settings(**kwargs)",
            "",
            "    def modify_settings(self, **kwargs):",
            "        \"\"\"",
            "        A context manager that temporarily applies changes a list setting and",
            "        reverts back to the original value when exiting the context.",
            "        \"\"\"",
            "        return modify_settings(**kwargs)",
            "",
            "    def assertRedirects(self, response, expected_url, status_code=302,",
            "                        target_status_code=200, host=None, msg_prefix='',",
            "                        fetch_redirect_response=True):",
            "        \"\"\"Asserts that a response redirected to a specific URL, and that the",
            "        redirect URL can be loaded.",
            "",
            "        Note that assertRedirects won't work for external links since it uses",
            "        TestClient to do a request (use fetch_redirect_response=False to check",
            "        such links without fetching them).",
            "        \"\"\"",
            "        if host is not None:",
            "            warnings.warn(",
            "                \"The host argument is deprecated and no longer used by assertRedirects\",",
            "                RemovedInDjango21Warning, stacklevel=2",
            "            )",
            "",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        if hasattr(response, 'redirect_chain'):",
            "            # The request was a followed redirect",
            "            self.assertTrue(len(response.redirect_chain) > 0,",
            "                msg_prefix + \"Response didn't redirect as expected: Response\"",
            "                \" code was %d (expected %d)\" %",
            "                    (response.status_code, status_code))",
            "",
            "            self.assertEqual(response.redirect_chain[0][1], status_code,",
            "                msg_prefix + \"Initial response didn't redirect as expected:\"",
            "                \" Response code was %d (expected %d)\" %",
            "                    (response.redirect_chain[0][1], status_code))",
            "",
            "            url, status_code = response.redirect_chain[-1]",
            "            scheme, netloc, path, query, fragment = urlsplit(url)",
            "",
            "            self.assertEqual(response.status_code, target_status_code,",
            "                msg_prefix + \"Response didn't redirect as expected: Final\"",
            "                \" Response code was %d (expected %d)\" %",
            "                    (response.status_code, target_status_code))",
            "",
            "        else:",
            "            # Not a followed redirect",
            "            self.assertEqual(response.status_code, status_code,",
            "                msg_prefix + \"Response didn't redirect as expected: Response\"",
            "                \" code was %d (expected %d)\" %",
            "                    (response.status_code, status_code))",
            "",
            "            url = response.url",
            "            scheme, netloc, path, query, fragment = urlsplit(url)",
            "",
            "            if fetch_redirect_response:",
            "                redirect_response = response.client.get(path, QueryDict(query),",
            "                                                        secure=(scheme == 'https'))",
            "",
            "                # Get the redirection page, using the same client that was used",
            "                # to obtain the original response.",
            "                self.assertEqual(redirect_response.status_code, target_status_code,",
            "                    msg_prefix + \"Couldn't retrieve redirection page '%s':\"",
            "                    \" response code was %d (expected %d)\" %",
            "                        (path, redirect_response.status_code, target_status_code))",
            "",
            "        if url != expected_url:",
            "            # For temporary backwards compatibility, try to compare with a relative url",
            "            e_scheme, e_netloc, e_path, e_query, e_fragment = urlsplit(expected_url)",
            "            relative_url = urlunsplit(('', '', e_path, e_query, e_fragment))",
            "            if url == relative_url:",
            "                warnings.warn(",
            "                    \"assertRedirects had to strip the scheme and domain from the \"",
            "                    \"expected URL, as it was always added automatically to URLs \"",
            "                    \"before Django 1.9. Please update your expected URLs by \"",
            "                    \"removing the scheme and domain.\",",
            "                    RemovedInDjango21Warning, stacklevel=2)",
            "                expected_url = relative_url",
            "",
            "        self.assertEqual(url, expected_url,",
            "            msg_prefix + \"Response redirected to '%s', expected '%s'\" %",
            "                (url, expected_url))",
            "",
            "    def _assert_contains(self, response, text, status_code, msg_prefix, html):",
            "        # If the response supports deferred rendering and hasn't been rendered",
            "        # yet, then ensure that it does get rendered before proceeding further.",
            "        if (hasattr(response, 'render') and callable(response.render)",
            "                and not response.is_rendered):",
            "            response.render()",
            "",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        self.assertEqual(response.status_code, status_code,",
            "            msg_prefix + \"Couldn't retrieve content: Response code was %d\"",
            "            \" (expected %d)\" % (response.status_code, status_code))",
            "",
            "        if response.streaming:",
            "            content = b''.join(response.streaming_content)",
            "        else:",
            "            content = response.content",
            "        if not isinstance(text, bytes) or html:",
            "            text = force_text(text, encoding=response.charset)",
            "            content = content.decode(response.charset)",
            "            text_repr = \"'%s'\" % text",
            "        else:",
            "            text_repr = repr(text)",
            "        if html:",
            "            content = assert_and_parse_html(self, content, None,",
            "                \"Response's content is not valid HTML:\")",
            "            text = assert_and_parse_html(self, text, None,",
            "                \"Second argument is not valid HTML:\")",
            "        real_count = content.count(text)",
            "        return (text_repr, real_count, msg_prefix)",
            "",
            "    def assertContains(self, response, text, count=None, status_code=200,",
            "                       msg_prefix='', html=False):",
            "        \"\"\"",
            "        Asserts that a response indicates that some content was retrieved",
            "        successfully, (i.e., the HTTP status code was as expected), and that",
            "        ``text`` occurs ``count`` times in the content of the response.",
            "        If ``count`` is None, the count doesn't matter - the assertion is true",
            "        if the text occurs at least once in the response.",
            "        \"\"\"",
            "        text_repr, real_count, msg_prefix = self._assert_contains(",
            "            response, text, status_code, msg_prefix, html)",
            "",
            "        if count is not None:",
            "            self.assertEqual(real_count, count,",
            "                msg_prefix + \"Found %d instances of %s in response\"",
            "                \" (expected %d)\" % (real_count, text_repr, count))",
            "        else:",
            "            self.assertTrue(real_count != 0,",
            "                msg_prefix + \"Couldn't find %s in response\" % text_repr)",
            "",
            "    def assertNotContains(self, response, text, status_code=200,",
            "                          msg_prefix='', html=False):",
            "        \"\"\"",
            "        Asserts that a response indicates that some content was retrieved",
            "        successfully, (i.e., the HTTP status code was as expected), and that",
            "        ``text`` doesn't occurs in the content of the response.",
            "        \"\"\"",
            "        text_repr, real_count, msg_prefix = self._assert_contains(",
            "            response, text, status_code, msg_prefix, html)",
            "",
            "        self.assertEqual(real_count, 0,",
            "                msg_prefix + \"Response should not contain %s\" % text_repr)",
            "",
            "    def assertFormError(self, response, form, field, errors, msg_prefix=''):",
            "        \"\"\"",
            "        Asserts that a form used to render the response has a specific field",
            "        error.",
            "        \"\"\"",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        # Put context(s) into a list to simplify processing.",
            "        contexts = to_list(response.context)",
            "        if not contexts:",
            "            self.fail(msg_prefix + \"Response did not use any contexts to \"",
            "                      \"render the response\")",
            "",
            "        # Put error(s) into a list to simplify processing.",
            "        errors = to_list(errors)",
            "",
            "        # Search all contexts for the error.",
            "        found_form = False",
            "        for i, context in enumerate(contexts):",
            "            if form not in context:",
            "                continue",
            "            found_form = True",
            "            for err in errors:",
            "                if field:",
            "                    if field in context[form].errors:",
            "                        field_errors = context[form].errors[field]",
            "                        self.assertTrue(err in field_errors,",
            "                            msg_prefix + \"The field '%s' on form '%s' in\"",
            "                            \" context %d does not contain the error '%s'\"",
            "                            \" (actual errors: %s)\" %",
            "                            (field, form, i, err, repr(field_errors)))",
            "                    elif field in context[form].fields:",
            "                        self.fail(msg_prefix + \"The field '%s' on form '%s'\"",
            "                                  \" in context %d contains no errors\" %",
            "                                  (field, form, i))",
            "                    else:",
            "                        self.fail(msg_prefix + \"The form '%s' in context %d\"",
            "                                  \" does not contain the field '%s'\" %",
            "                                  (form, i, field))",
            "                else:",
            "                    non_field_errors = context[form].non_field_errors()",
            "                    self.assertTrue(err in non_field_errors,",
            "                        msg_prefix + \"The form '%s' in context %d does not\"",
            "                        \" contain the non-field error '%s'\"",
            "                        \" (actual errors: %s)\" %",
            "                            (form, i, err, non_field_errors))",
            "        if not found_form:",
            "            self.fail(msg_prefix + \"The form '%s' was not used to render the\"",
            "                      \" response\" % form)",
            "",
            "    def assertFormsetError(self, response, formset, form_index, field, errors,",
            "                           msg_prefix=''):",
            "        \"\"\"",
            "        Asserts that a formset used to render the response has a specific error.",
            "",
            "        For field errors, specify the ``form_index`` and the ``field``.",
            "        For non-field errors, specify the ``form_index`` and the ``field`` as",
            "        None.",
            "        For non-form errors, specify ``form_index`` as None and the ``field``",
            "        as None.",
            "        \"\"\"",
            "        # Add punctuation to msg_prefix",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        # Put context(s) into a list to simplify processing.",
            "        contexts = to_list(response.context)",
            "        if not contexts:",
            "            self.fail(msg_prefix + 'Response did not use any contexts to '",
            "                      'render the response')",
            "",
            "        # Put error(s) into a list to simplify processing.",
            "        errors = to_list(errors)",
            "",
            "        # Search all contexts for the error.",
            "        found_formset = False",
            "        for i, context in enumerate(contexts):",
            "            if formset not in context:",
            "                continue",
            "            found_formset = True",
            "            for err in errors:",
            "                if field is not None:",
            "                    if field in context[formset].forms[form_index].errors:",
            "                        field_errors = context[formset].forms[form_index].errors[field]",
            "                        self.assertTrue(err in field_errors,",
            "                                msg_prefix + \"The field '%s' on formset '%s', \"",
            "                                \"form %d in context %d does not contain the \"",
            "                                \"error '%s' (actual errors: %s)\" %",
            "                                (field, formset, form_index, i, err,",
            "                                 repr(field_errors)))",
            "                    elif field in context[formset].forms[form_index].fields:",
            "                        self.fail(msg_prefix + \"The field '%s' \"",
            "                                  \"on formset '%s', form %d in \"",
            "                                  \"context %d contains no errors\" %",
            "                                  (field, formset, form_index, i))",
            "                    else:",
            "                        self.fail(msg_prefix + \"The formset '%s', form %d in \"",
            "                                  \"context %d does not contain the field '%s'\" %",
            "                                  (formset, form_index, i, field))",
            "                elif form_index is not None:",
            "                    non_field_errors = context[formset].forms[form_index].non_field_errors()",
            "                    self.assertFalse(len(non_field_errors) == 0,",
            "                                     msg_prefix + \"The formset '%s', form %d in \"",
            "                                     \"context %d does not contain any non-field \"",
            "                                     \"errors.\" % (formset, form_index, i))",
            "                    self.assertTrue(err in non_field_errors,",
            "                                    msg_prefix + \"The formset '%s', form %d \"",
            "                                    \"in context %d does not contain the \"",
            "                                    \"non-field error '%s' \"",
            "                                    \"(actual errors: %s)\" %",
            "                                    (formset, form_index, i, err,",
            "                                     repr(non_field_errors)))",
            "                else:",
            "                    non_form_errors = context[formset].non_form_errors()",
            "                    self.assertFalse(len(non_form_errors) == 0,",
            "                                     msg_prefix + \"The formset '%s' in \"",
            "                                     \"context %d does not contain any \"",
            "                                     \"non-form errors.\" % (formset, i))",
            "                    self.assertTrue(err in non_form_errors,",
            "                                    msg_prefix + \"The formset '%s' in context \"",
            "                                    \"%d does not contain the \"",
            "                                    \"non-form error '%s' (actual errors: %s)\" %",
            "                                    (formset, i, err, repr(non_form_errors)))",
            "        if not found_formset:",
            "            self.fail(msg_prefix + \"The formset '%s' was not used to render \"",
            "                      \"the response\" % formset)",
            "",
            "    def _assert_template_used(self, response, template_name, msg_prefix):",
            "",
            "        if response is None and template_name is None:",
            "            raise TypeError('response and/or template_name argument must be provided')",
            "",
            "        if msg_prefix:",
            "            msg_prefix += \": \"",
            "",
            "        if template_name is not None and response is not None and not hasattr(response, 'templates'):",
            "            raise ValueError(",
            "                \"assertTemplateUsed() and assertTemplateNotUsed() are only \"",
            "                \"usable on responses fetched using the Django test Client.\"",
            "            )",
            "",
            "        if not hasattr(response, 'templates') or (response is None and template_name):",
            "            if response:",
            "                template_name = response",
            "                response = None",
            "            # use this template with context manager",
            "            return template_name, None, msg_prefix",
            "",
            "        template_names = [t.name for t in response.templates if t.name is not",
            "                          None]",
            "        return None, template_names, msg_prefix",
            "",
            "    def assertTemplateUsed(self, response=None, template_name=None, msg_prefix='', count=None):",
            "        \"\"\"",
            "        Asserts that the template with the provided name was used in rendering",
            "        the response. Also usable as context manager.",
            "        \"\"\"",
            "        context_mgr_template, template_names, msg_prefix = self._assert_template_used(",
            "            response, template_name, msg_prefix)",
            "",
            "        if context_mgr_template:",
            "            # Use assertTemplateUsed as context manager.",
            "            return _AssertTemplateUsedContext(self, context_mgr_template)",
            "",
            "        if not template_names:",
            "            self.fail(msg_prefix + \"No templates used to render the response\")",
            "        self.assertTrue(template_name in template_names,",
            "            msg_prefix + \"Template '%s' was not a template used to render\"",
            "            \" the response. Actual template(s) used: %s\" %",
            "                (template_name, ', '.join(template_names)))",
            "",
            "        if count is not None:",
            "            self.assertEqual(template_names.count(template_name), count,",
            "                msg_prefix + \"Template '%s' was expected to be rendered %d \"",
            "                \"time(s) but was actually rendered %d time(s).\" %",
            "                    (template_name, count, template_names.count(template_name)))",
            "",
            "    def assertTemplateNotUsed(self, response=None, template_name=None, msg_prefix=''):",
            "        \"\"\"",
            "        Asserts that the template with the provided name was NOT used in",
            "        rendering the response. Also usable as context manager.",
            "        \"\"\"",
            "",
            "        context_mgr_template, template_names, msg_prefix = self._assert_template_used(",
            "            response, template_name, msg_prefix)",
            "",
            "        if context_mgr_template:",
            "            # Use assertTemplateNotUsed as context manager.",
            "            return _AssertTemplateNotUsedContext(self, context_mgr_template)",
            "",
            "        self.assertFalse(template_name in template_names,",
            "            msg_prefix + \"Template '%s' was used unexpectedly in rendering\"",
            "            \" the response\" % template_name)",
            "",
            "    def assertRaisesMessage(self, expected_exception, expected_message,",
            "                           callable_obj=None, *args, **kwargs):",
            "        \"\"\"",
            "        Asserts that the message in a raised exception matches the passed",
            "        value.",
            "",
            "        Args:",
            "            expected_exception: Exception class expected to be raised.",
            "            expected_message: expected error message string value.",
            "            callable_obj: Function to be called.",
            "            args: Extra args.",
            "            kwargs: Extra kwargs.",
            "        \"\"\"",
            "        return six.assertRaisesRegex(self, expected_exception,",
            "                re.escape(expected_message), callable_obj, *args, **kwargs)",
            "",
            "    def assertFieldOutput(self, fieldclass, valid, invalid, field_args=None,",
            "            field_kwargs=None, empty_value=''):",
            "        \"\"\"",
            "        Asserts that a form field behaves correctly with various inputs.",
            "",
            "        Args:",
            "            fieldclass: the class of the field to be tested.",
            "            valid: a dictionary mapping valid inputs to their expected",
            "                    cleaned values.",
            "            invalid: a dictionary mapping invalid inputs to one or more",
            "                    raised error messages.",
            "            field_args: the args passed to instantiate the field",
            "            field_kwargs: the kwargs passed to instantiate the field",
            "            empty_value: the expected clean output for inputs in empty_values",
            "",
            "        \"\"\"",
            "        if field_args is None:",
            "            field_args = []",
            "        if field_kwargs is None:",
            "            field_kwargs = {}",
            "        required = fieldclass(*field_args, **field_kwargs)",
            "        optional = fieldclass(*field_args,",
            "                              **dict(field_kwargs, required=False))",
            "        # test valid inputs",
            "        for input, output in valid.items():",
            "            self.assertEqual(required.clean(input), output)",
            "            self.assertEqual(optional.clean(input), output)",
            "        # test invalid inputs",
            "        for input, errors in invalid.items():",
            "            with self.assertRaises(ValidationError) as context_manager:",
            "                required.clean(input)",
            "            self.assertEqual(context_manager.exception.messages, errors)",
            "",
            "            with self.assertRaises(ValidationError) as context_manager:",
            "                optional.clean(input)",
            "            self.assertEqual(context_manager.exception.messages, errors)",
            "        # test required inputs",
            "        error_required = [force_text(required.error_messages['required'])]",
            "        for e in required.empty_values:",
            "            with self.assertRaises(ValidationError) as context_manager:",
            "                required.clean(e)",
            "            self.assertEqual(context_manager.exception.messages,",
            "                             error_required)",
            "            self.assertEqual(optional.clean(e), empty_value)",
            "        # test that max_length and min_length are always accepted",
            "        if issubclass(fieldclass, CharField):",
            "            field_kwargs.update({'min_length': 2, 'max_length': 20})",
            "            self.assertIsInstance(fieldclass(*field_args, **field_kwargs),",
            "                                  fieldclass)",
            "",
            "    def assertHTMLEqual(self, html1, html2, msg=None):",
            "        \"\"\"",
            "        Asserts that two HTML snippets are semantically the same.",
            "        Whitespace in most cases is ignored, and attribute ordering is not",
            "        significant. The passed-in arguments must be valid HTML.",
            "        \"\"\"",
            "        dom1 = assert_and_parse_html(self, html1, msg,",
            "            'First argument is not valid HTML:')",
            "        dom2 = assert_and_parse_html(self, html2, msg,",
            "            'Second argument is not valid HTML:')",
            "",
            "        if dom1 != dom2:",
            "            standardMsg = '%s != %s' % (",
            "                safe_repr(dom1, True), safe_repr(dom2, True))",
            "            diff = ('\\n' + '\\n'.join(difflib.ndiff(",
            "                           six.text_type(dom1).splitlines(),",
            "                           six.text_type(dom2).splitlines())))",
            "            standardMsg = self._truncateMessage(standardMsg, diff)",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "    def assertHTMLNotEqual(self, html1, html2, msg=None):",
            "        \"\"\"Asserts that two HTML snippets are not semantically equivalent.\"\"\"",
            "        dom1 = assert_and_parse_html(self, html1, msg,",
            "            'First argument is not valid HTML:')",
            "        dom2 = assert_and_parse_html(self, html2, msg,",
            "            'Second argument is not valid HTML:')",
            "",
            "        if dom1 == dom2:",
            "            standardMsg = '%s == %s' % (",
            "                safe_repr(dom1, True), safe_repr(dom2, True))",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "    def assertInHTML(self, needle, haystack, count=None, msg_prefix=''):",
            "        needle = assert_and_parse_html(self, needle, None,",
            "            'First argument is not valid HTML:')",
            "        haystack = assert_and_parse_html(self, haystack, None,",
            "            'Second argument is not valid HTML:')",
            "        real_count = haystack.count(needle)",
            "        if count is not None:",
            "            self.assertEqual(real_count, count,",
            "                msg_prefix + \"Found %d instances of '%s' in response\"",
            "                \" (expected %d)\" % (real_count, needle, count))",
            "        else:",
            "            self.assertTrue(real_count != 0,",
            "                msg_prefix + \"Couldn't find '%s' in response\" % needle)",
            "",
            "    def assertJSONEqual(self, raw, expected_data, msg=None):",
            "        \"\"\"",
            "        Asserts that the JSON fragments raw and expected_data are equal.",
            "        Usual JSON non-significant whitespace rules apply as the heavyweight",
            "        is delegated to the json library.",
            "        \"\"\"",
            "        try:",
            "            data = json.loads(raw)",
            "        except ValueError:",
            "            self.fail(\"First argument is not valid JSON: %r\" % raw)",
            "        if isinstance(expected_data, six.string_types):",
            "            try:",
            "                expected_data = json.loads(expected_data)",
            "            except ValueError:",
            "                self.fail(\"Second argument is not valid JSON: %r\" % expected_data)",
            "        self.assertEqual(data, expected_data, msg=msg)",
            "",
            "    def assertJSONNotEqual(self, raw, expected_data, msg=None):",
            "        \"\"\"",
            "        Asserts that the JSON fragments raw and expected_data are not equal.",
            "        Usual JSON non-significant whitespace rules apply as the heavyweight",
            "        is delegated to the json library.",
            "        \"\"\"",
            "        try:",
            "            data = json.loads(raw)",
            "        except ValueError:",
            "            self.fail(\"First argument is not valid JSON: %r\" % raw)",
            "        if isinstance(expected_data, six.string_types):",
            "            try:",
            "                expected_data = json.loads(expected_data)",
            "            except ValueError:",
            "                self.fail(\"Second argument is not valid JSON: %r\" % expected_data)",
            "        self.assertNotEqual(data, expected_data, msg=msg)",
            "",
            "    def assertXMLEqual(self, xml1, xml2, msg=None):",
            "        \"\"\"",
            "        Asserts that two XML snippets are semantically the same.",
            "        Whitespace in most cases is ignored, and attribute ordering is not",
            "        significant. The passed-in arguments must be valid XML.",
            "        \"\"\"",
            "        try:",
            "            result = compare_xml(xml1, xml2)",
            "        except Exception as e:",
            "            standardMsg = 'First or second argument is not valid XML\\n%s' % e",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "        else:",
            "            if not result:",
            "                standardMsg = '%s != %s' % (safe_repr(xml1, True), safe_repr(xml2, True))",
            "                self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "    def assertXMLNotEqual(self, xml1, xml2, msg=None):",
            "        \"\"\"",
            "        Asserts that two XML snippets are not semantically equivalent.",
            "        Whitespace in most cases is ignored, and attribute ordering is not",
            "        significant. The passed-in arguments must be valid XML.",
            "        \"\"\"",
            "        try:",
            "            result = compare_xml(xml1, xml2)",
            "        except Exception as e:",
            "            standardMsg = 'First or second argument is not valid XML\\n%s' % e",
            "            self.fail(self._formatMessage(msg, standardMsg))",
            "        else:",
            "            if result:",
            "                standardMsg = '%s == %s' % (safe_repr(xml1, True), safe_repr(xml2, True))",
            "                self.fail(self._formatMessage(msg, standardMsg))",
            "",
            "",
            "class TransactionTestCase(SimpleTestCase):",
            "",
            "    # Subclasses can ask for resetting of auto increment sequence before each",
            "    # test case",
            "    reset_sequences = False",
            "",
            "    # Subclasses can enable only a subset of apps for faster tests",
            "    available_apps = None",
            "",
            "    # Subclasses can define fixtures which will be automatically installed.",
            "    fixtures = None",
            "",
            "    # If transactions aren't available, Django will serialize the database",
            "    # contents into a fixture during setup and flush and reload them",
            "    # during teardown (as flush does not restore data from migrations).",
            "    # This can be slow; this flag allows enabling on a per-case basis.",
            "    serialized_rollback = False",
            "",
            "    def _pre_setup(self):",
            "        \"\"\"Performs any pre-test setup. This includes:",
            "",
            "        * If the class has an 'available_apps' attribute, restricting the app",
            "          registry to these applications, then firing post_migrate -- it must",
            "          run with the correct set of applications for the test case.",
            "        * If the class has a 'fixtures' attribute, installing these fixtures.",
            "        \"\"\"",
            "        super(TransactionTestCase, self)._pre_setup()",
            "        if self.available_apps is not None:",
            "            apps.set_available_apps(self.available_apps)",
            "            setting_changed.send(sender=settings._wrapped.__class__,",
            "                                 setting='INSTALLED_APPS',",
            "                                 value=self.available_apps,",
            "                                 enter=True)",
            "            for db_name in self._databases_names(include_mirrors=False):",
            "                emit_post_migrate_signal(verbosity=0, interactive=False, db=db_name)",
            "        try:",
            "            self._fixture_setup()",
            "        except Exception:",
            "            if self.available_apps is not None:",
            "                apps.unset_available_apps()",
            "                setting_changed.send(sender=settings._wrapped.__class__,",
            "                                     setting='INSTALLED_APPS',",
            "                                     value=settings.INSTALLED_APPS,",
            "                                     enter=False)",
            "",
            "            raise",
            "",
            "    @classmethod",
            "    def _databases_names(cls, include_mirrors=True):",
            "        # If the test case has a multi_db=True flag, act on all databases,",
            "        # including mirrors or not. Otherwise, just on the default DB.",
            "        if getattr(cls, 'multi_db', False):",
            "            return [alias for alias in connections",
            "                    if include_mirrors or not connections[alias].settings_dict['TEST']['MIRROR']]",
            "        else:",
            "            return [DEFAULT_DB_ALIAS]",
            "",
            "    def _reset_sequences(self, db_name):",
            "        conn = connections[db_name]",
            "        if conn.features.supports_sequence_reset:",
            "            sql_list = conn.ops.sequence_reset_by_name_sql(",
            "                no_style(), conn.introspection.sequence_list())",
            "            if sql_list:",
            "                with transaction.atomic(using=db_name):",
            "                    cursor = conn.cursor()",
            "                    for sql in sql_list:",
            "                        cursor.execute(sql)",
            "",
            "    def _fixture_setup(self):",
            "        for db_name in self._databases_names(include_mirrors=False):",
            "            # Reset sequences",
            "            if self.reset_sequences:",
            "                self._reset_sequences(db_name)",
            "",
            "            # If we need to provide replica initial data from migrated apps,",
            "            # then do so.",
            "            if self.serialized_rollback and hasattr(connections[db_name], \"_test_serialized_contents\"):",
            "                if self.available_apps is not None:",
            "                    apps.unset_available_apps()",
            "                connections[db_name].creation.deserialize_db_from_string(",
            "                    connections[db_name]._test_serialized_contents",
            "                )",
            "                if self.available_apps is not None:",
            "                    apps.set_available_apps(self.available_apps)",
            "",
            "            if self.fixtures:",
            "                # We have to use this slightly awkward syntax due to the fact",
            "                # that we're using *args and **kwargs together.",
            "                call_command('loaddata', *self.fixtures,",
            "                             **{'verbosity': 0, 'database': db_name})",
            "",
            "    def _should_reload_connections(self):",
            "        return True",
            "",
            "    def _post_teardown(self):",
            "        \"\"\"Performs any post-test things. This includes:",
            "",
            "        * Flushing the contents of the database, to leave a clean slate. If",
            "          the class has an 'available_apps' attribute, post_migrate isn't fired.",
            "        * Force-closing the connection, so the next test gets a clean cursor.",
            "        \"\"\"",
            "        try:",
            "            self._fixture_teardown()",
            "            super(TransactionTestCase, self)._post_teardown()",
            "            if self._should_reload_connections():",
            "                # Some DB cursors include SQL statements as part of cursor",
            "                # creation. If you have a test that does a rollback, the effect",
            "                # of these statements is lost, which can affect the operation of",
            "                # tests (e.g., losing a timezone setting causing objects to be",
            "                # created with the wrong time). To make sure this doesn't",
            "                # happen, get a clean connection at the start of every test.",
            "                for conn in connections.all():",
            "                    conn.close()",
            "        finally:",
            "            if self.available_apps is not None:",
            "                apps.unset_available_apps()",
            "                setting_changed.send(sender=settings._wrapped.__class__,",
            "                                     setting='INSTALLED_APPS',",
            "                                     value=settings.INSTALLED_APPS,",
            "                                     enter=False)",
            "",
            "    def _fixture_teardown(self):",
            "        # Allow TRUNCATE ... CASCADE and don't emit the post_migrate signal",
            "        # when flushing only a subset of the apps",
            "        for db_name in self._databases_names(include_mirrors=False):",
            "            # Flush the database",
            "            call_command('flush', verbosity=0, interactive=False,",
            "                         database=db_name, reset_sequences=False,",
            "                         allow_cascade=self.available_apps is not None,",
            "                         inhibit_post_migrate=self.available_apps is not None)",
            "",
            "    def assertQuerysetEqual(self, qs, values, transform=repr, ordered=True, msg=None):",
            "        items = six.moves.map(transform, qs)",
            "        if not ordered:",
            "            return self.assertEqual(Counter(items), Counter(values), msg=msg)",
            "        values = list(values)",
            "        # For example qs.iterator() could be passed as qs, but it does not",
            "        # have 'ordered' attribute.",
            "        if len(values) > 1 and hasattr(qs, 'ordered') and not qs.ordered:",
            "            raise ValueError(\"Trying to compare non-ordered queryset \"",
            "                             \"against more than one ordered values\")",
            "        return self.assertEqual(list(items), values, msg=msg)",
            "",
            "    def assertNumQueries(self, num, func=None, *args, **kwargs):",
            "        using = kwargs.pop(\"using\", DEFAULT_DB_ALIAS)",
            "        conn = connections[using]",
            "",
            "        context = _AssertNumQueriesContext(self, num, conn)",
            "        if func is None:",
            "            return context",
            "",
            "        with context:",
            "            func(*args, **kwargs)",
            "",
            "",
            "def connections_support_transactions():",
            "    \"\"\"",
            "    Returns True if all connections support transactions.",
            "    \"\"\"",
            "    return all(conn.features.supports_transactions",
            "               for conn in connections.all())",
            "",
            "",
            "class TestCase(TransactionTestCase):",
            "    \"\"\"",
            "    Similar to TransactionTestCase, but uses `transaction.atomic()` to achieve",
            "    test isolation.",
            "",
            "    In most situation, TestCase should be prefered to TransactionTestCase as",
            "    it allows faster execution. However, there are some situations where using",
            "    TransactionTestCase might be necessary (e.g. testing some transactional",
            "    behavior).",
            "",
            "    On database backends with no transaction support, TestCase behaves as",
            "    TransactionTestCase.",
            "    \"\"\"",
            "    @classmethod",
            "    def _enter_atomics(cls):",
            "        \"\"\"Helper method to open atomic blocks for multiple databases\"\"\"",
            "        atomics = {}",
            "        for db_name in cls._databases_names():",
            "            atomics[db_name] = transaction.atomic(using=db_name)",
            "            atomics[db_name].__enter__()",
            "        return atomics",
            "",
            "    @classmethod",
            "    def _rollback_atomics(cls, atomics):",
            "        \"\"\"Rollback atomic blocks opened through the previous method\"\"\"",
            "        for db_name in reversed(cls._databases_names()):",
            "            transaction.set_rollback(True, using=db_name)",
            "            atomics[db_name].__exit__(None, None, None)",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        super(TestCase, cls).setUpClass()",
            "        if not connections_support_transactions():",
            "            return",
            "        cls.cls_atomics = cls._enter_atomics()",
            "",
            "        if cls.fixtures:",
            "            for db_name in cls._databases_names(include_mirrors=False):",
            "                    try:",
            "                        call_command('loaddata', *cls.fixtures, **{",
            "                            'verbosity': 0,",
            "                            'commit': False,",
            "                            'database': db_name,",
            "                        })",
            "                    except Exception:",
            "                        cls._rollback_atomics(cls.cls_atomics)",
            "                        raise",
            "        cls.setUpTestData()",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        if connections_support_transactions():",
            "            cls._rollback_atomics(cls.cls_atomics)",
            "            for conn in connections.all():",
            "                conn.close()",
            "        super(TestCase, cls).tearDownClass()",
            "",
            "    @classmethod",
            "    def setUpTestData(cls):",
            "        \"\"\"Load initial data for the TestCase\"\"\"",
            "        pass",
            "",
            "    def _should_reload_connections(self):",
            "        if connections_support_transactions():",
            "            return False",
            "        return super(TestCase, self)._should_reload_connections()",
            "",
            "    def _fixture_setup(self):",
            "        if not connections_support_transactions():",
            "            # If the backend does not support transactions, we should reload",
            "            # class data before each test",
            "            self.setUpTestData()",
            "            return super(TestCase, self)._fixture_setup()",
            "",
            "        assert not self.reset_sequences, 'reset_sequences cannot be used on TestCase instances'",
            "        self.atomics = self._enter_atomics()",
            "",
            "    def _fixture_teardown(self):",
            "        if not connections_support_transactions():",
            "            return super(TestCase, self)._fixture_teardown()",
            "        self._rollback_atomics(self.atomics)",
            "",
            "",
            "class CheckCondition(object):",
            "    \"\"\"Descriptor class for deferred condition checking\"\"\"",
            "    def __init__(self, cond_func):",
            "        self.cond_func = cond_func",
            "",
            "    def __get__(self, obj, objtype):",
            "        return self.cond_func()",
            "",
            "",
            "def _deferredSkip(condition, reason):",
            "    def decorator(test_func):",
            "        if not (isinstance(test_func, type) and",
            "                issubclass(test_func, unittest.TestCase)):",
            "            @wraps(test_func)",
            "            def skip_wrapper(*args, **kwargs):",
            "                if condition():",
            "                    raise unittest.SkipTest(reason)",
            "                return test_func(*args, **kwargs)",
            "            test_item = skip_wrapper",
            "        else:",
            "            # Assume a class is decorated",
            "            test_item = test_func",
            "            test_item.__unittest_skip__ = CheckCondition(condition)",
            "        test_item.__unittest_skip_why__ = reason",
            "        return test_item",
            "    return decorator",
            "",
            "",
            "def skipIfDBFeature(*features):",
            "    \"\"\"",
            "    Skip a test if a database has at least one of the named features.",
            "    \"\"\"",
            "    return _deferredSkip(",
            "        lambda: any(getattr(connection.features, feature, False) for feature in features),",
            "        \"Database has feature(s) %s\" % \", \".join(features)",
            "    )",
            "",
            "",
            "def skipUnlessDBFeature(*features):",
            "    \"\"\"",
            "    Skip a test unless a database has all the named features.",
            "    \"\"\"",
            "    return _deferredSkip(",
            "        lambda: not all(getattr(connection.features, feature, False) for feature in features),",
            "        \"Database doesn't support feature(s): %s\" % \", \".join(features)",
            "    )",
            "",
            "",
            "class QuietWSGIRequestHandler(WSGIRequestHandler):",
            "    \"\"\"",
            "    Just a regular WSGIRequestHandler except it doesn't log to the standard",
            "    output any of the requests received, so as to not clutter the output for",
            "    the tests' results.",
            "    \"\"\"",
            "",
            "    def log_message(*args):",
            "        pass",
            "",
            "",
            "class FSFilesHandler(WSGIHandler):",
            "    \"\"\"",
            "    WSGI middleware that intercepts calls to a directory, as defined by one of",
            "    the *_ROOT settings, and serves those files, publishing them under *_URL.",
            "    \"\"\"",
            "    def __init__(self, application):",
            "        self.application = application",
            "        self.base_url = urlparse(self.get_base_url())",
            "        super(FSFilesHandler, self).__init__()",
            "",
            "    def _should_handle(self, path):",
            "        \"\"\"",
            "        Checks if the path should be handled. Ignores the path if:",
            "",
            "        * the host is provided as part of the base_url",
            "        * the request's path isn't under the media path (or equal)",
            "        \"\"\"",
            "        return path.startswith(self.base_url[2]) and not self.base_url[1]",
            "",
            "    def file_path(self, url):",
            "        \"\"\"",
            "        Returns the relative path to the file on disk for the given URL.",
            "        \"\"\"",
            "        relative_url = url[len(self.base_url[2]):]",
            "        return url2pathname(relative_url)",
            "",
            "    def get_response(self, request):",
            "        from django.http import Http404",
            "",
            "        if self._should_handle(request.path):",
            "            try:",
            "                return self.serve(request)",
            "            except Http404:",
            "                pass",
            "        return super(FSFilesHandler, self).get_response(request)",
            "",
            "    def serve(self, request):",
            "        os_rel_path = self.file_path(request.path)",
            "        os_rel_path = posixpath.normpath(unquote(os_rel_path))",
            "        # Emulate behavior of django.contrib.staticfiles.views.serve() when it",
            "        # invokes staticfiles' finders functionality.",
            "        # TODO: Modify if/when that internal API is refactored",
            "        final_rel_path = os_rel_path.replace('\\\\', '/').lstrip('/')",
            "        return serve(request, final_rel_path, document_root=self.get_base_dir())",
            "",
            "    def __call__(self, environ, start_response):",
            "        if not self._should_handle(get_path_info(environ)):",
            "            return self.application(environ, start_response)",
            "        return super(FSFilesHandler, self).__call__(environ, start_response)",
            "",
            "",
            "class _StaticFilesHandler(FSFilesHandler):",
            "    \"\"\"",
            "    Handler for serving static files. A private class that is meant to be used",
            "    solely as a convenience by LiveServerThread.",
            "    \"\"\"",
            "",
            "    def get_base_dir(self):",
            "        return settings.STATIC_ROOT",
            "",
            "    def get_base_url(self):",
            "        return settings.STATIC_URL",
            "",
            "",
            "class _MediaFilesHandler(FSFilesHandler):",
            "    \"\"\"",
            "    Handler for serving the media files. A private class that is meant to be",
            "    used solely as a convenience by LiveServerThread.",
            "    \"\"\"",
            "",
            "    def get_base_dir(self):",
            "        return settings.MEDIA_ROOT",
            "",
            "    def get_base_url(self):",
            "        return settings.MEDIA_URL",
            "",
            "",
            "class LiveServerThread(threading.Thread):",
            "    \"\"\"",
            "    Thread for running a live http server while the tests are running.",
            "    \"\"\"",
            "",
            "    def __init__(self, host, possible_ports, static_handler, connections_override=None):",
            "        self.host = host",
            "        self.port = None",
            "        self.possible_ports = possible_ports",
            "        self.is_ready = threading.Event()",
            "        self.error = None",
            "        self.static_handler = static_handler",
            "        self.connections_override = connections_override",
            "        super(LiveServerThread, self).__init__()",
            "",
            "    def run(self):",
            "        \"\"\"",
            "        Sets up the live server and databases, and then loops over handling",
            "        http requests.",
            "        \"\"\"",
            "        if self.connections_override:",
            "            # Override this thread's database connections with the ones",
            "            # provided by the main thread.",
            "            for alias, conn in self.connections_override.items():",
            "                connections[alias] = conn",
            "        try:",
            "            # Create the handler for serving static and media files",
            "            handler = self.static_handler(_MediaFilesHandler(WSGIHandler()))",
            "",
            "            # Go through the list of possible ports, hoping that we can find",
            "            # one that is free to use for the WSGI server.",
            "            for index, port in enumerate(self.possible_ports):",
            "                try:",
            "                    self.httpd = WSGIServer(",
            "                        (self.host, port), QuietWSGIRequestHandler)",
            "                except socket.error as e:",
            "                    if (index + 1 < len(self.possible_ports) and",
            "                            e.errno == errno.EADDRINUSE):",
            "                        # This port is already in use, so we go on and try with",
            "                        # the next one in the list.",
            "                        continue",
            "                    else:",
            "                        # Either none of the given ports are free or the error",
            "                        # is something else than \"Address already in use\". So",
            "                        # we let that error bubble up to the main thread.",
            "                        raise",
            "                else:",
            "                    # A free port was found.",
            "                    self.port = port",
            "                    break",
            "",
            "            self.httpd.set_app(handler)",
            "            self.is_ready.set()",
            "            self.httpd.serve_forever()",
            "        except Exception as e:",
            "            self.error = e",
            "            self.is_ready.set()",
            "",
            "    def terminate(self):",
            "        if hasattr(self, 'httpd'):",
            "            # Stop the WSGI server",
            "            self.httpd.shutdown()",
            "            self.httpd.server_close()",
            "",
            "",
            "class LiveServerTestCase(TransactionTestCase):",
            "    \"\"\"",
            "    Does basically the same as TransactionTestCase but also launches a live",
            "    http server in a separate thread so that the tests may use another testing",
            "    framework, such as Selenium for example, instead of the built-in dummy",
            "    client.",
            "    Note that it inherits from TransactionTestCase instead of TestCase because",
            "    the threads do not share the same transactions (unless if using in-memory",
            "    sqlite) and each thread needs to commit all their transactions so that the",
            "    other thread can see the changes.",
            "    \"\"\"",
            "",
            "    static_handler = _StaticFilesHandler",
            "",
            "    @property",
            "    def live_server_url(self):",
            "        return 'http://%s:%s' % (",
            "            self.server_thread.host, self.server_thread.port)",
            "",
            "    @classmethod",
            "    def setUpClass(cls):",
            "        super(LiveServerTestCase, cls).setUpClass()",
            "        connections_override = {}",
            "        for conn in connections.all():",
            "            # If using in-memory sqlite databases, pass the connections to",
            "            # the server thread.",
            "            if conn.vendor == 'sqlite' and conn.is_in_memory_db(conn.settings_dict['NAME']):",
            "                # Explicitly enable thread-shareability for this connection",
            "                conn.allow_thread_sharing = True",
            "                connections_override[conn.alias] = conn",
            "",
            "        # Launch the live server's thread",
            "        specified_address = os.environ.get(",
            "            'DJANGO_LIVE_TEST_SERVER_ADDRESS', 'localhost:8081')",
            "",
            "        # The specified ports may be of the form '8000-8010,8080,9200-9300'",
            "        # i.e. a comma-separated list of ports or ranges of ports, so we break",
            "        # it down into a detailed list of all possible ports.",
            "        possible_ports = []",
            "        try:",
            "            host, port_ranges = specified_address.split(':')",
            "            for port_range in port_ranges.split(','):",
            "                # A port range can be of either form: '8000' or '8000-8010'.",
            "                extremes = list(map(int, port_range.split('-')))",
            "                assert len(extremes) in [1, 2]",
            "                if len(extremes) == 1:",
            "                    # Port range of the form '8000'",
            "                    possible_ports.append(extremes[0])",
            "                else:",
            "                    # Port range of the form '8000-8010'",
            "                    for port in range(extremes[0], extremes[1] + 1):",
            "                        possible_ports.append(port)",
            "        except Exception:",
            "            msg = 'Invalid address (\"%s\") for live server.' % specified_address",
            "            six.reraise(ImproperlyConfigured, ImproperlyConfigured(msg), sys.exc_info()[2])",
            "        cls.server_thread = LiveServerThread(host, possible_ports,",
            "                                             cls.static_handler,",
            "                                             connections_override=connections_override)",
            "        cls.server_thread.daemon = True",
            "        cls.server_thread.start()",
            "",
            "        # Wait for the live server to be ready",
            "        cls.server_thread.is_ready.wait()",
            "        if cls.server_thread.error:",
            "            # Clean up behind ourselves, since tearDownClass won't get called in",
            "            # case of errors.",
            "            cls._tearDownClassInternal()",
            "            raise cls.server_thread.error",
            "",
            "    @classmethod",
            "    def _tearDownClassInternal(cls):",
            "        # There may not be a 'server_thread' attribute if setUpClass() for some",
            "        # reasons has raised an exception.",
            "        if hasattr(cls, 'server_thread'):",
            "            # Terminate the live server's thread",
            "            cls.server_thread.terminate()",
            "            cls.server_thread.join()",
            "",
            "        # Restore sqlite in-memory database connections' non-shareability",
            "        for conn in connections.all():",
            "            if conn.vendor == 'sqlite' and conn.is_in_memory_db(conn.settings_dict['NAME']):",
            "                conn.allow_thread_sharing = False",
            "",
            "    @classmethod",
            "    def tearDownClass(cls):",
            "        cls._tearDownClassInternal()",
            "        super(LiveServerTestCase, cls).tearDownClass()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": [],
            "255": [
                "SimpleTestCase",
                "assertRedirects"
            ],
            "256": [
                "SimpleTestCase",
                "assertRedirects"
            ],
            "298": [
                "SimpleTestCase",
                "assertRedirects"
            ],
            "299": [
                "SimpleTestCase",
                "assertRedirects"
            ],
            "300": [
                "SimpleTestCase",
                "assertRedirects"
            ],
            "301": [
                "SimpleTestCase",
                "assertRedirects"
            ]
        },
        "addLocation": []
    }
}