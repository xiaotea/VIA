{
    "rdiffweb/controller/page_admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         _('Quota Used'), validators=[validators.optional()], description=_(\"Disk spaces (in bytes) used by this user.\")"
            },
            "1": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "     )"
            },
            "2": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def validate_password(self, field):"
            },
            "4": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validator = validators.length("
            },
            "5": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            min=self.app.cfg.password_min_length,"
            },
            "6": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            max=self.app.cfg.password_max_length,"
            },
            "7": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            message=_('Password must have between %(min)d and %(max)d characters.'),"
            },
            "8": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "9": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validator(self, field)"
            },
            "10": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @property"
            },
            "12": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def app(self):"
            },
            "13": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return cherrypy.request.app"
            },
            "14": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "     def validate_role(self, field):"
            },
            "16": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         # Don't allow the user to changes it's \"role\" state."
            },
            "17": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         currentuser = cherrypy.request.currentuser"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import grp",
            "import logging",
            "import os",
            "import platform",
            "import pwd",
            "import subprocess",
            "import sys",
            "from collections import OrderedDict",
            "",
            "import cherrypy",
            "import humanfriendly",
            "import psutil",
            "from wtforms import validators, widgets",
            "from wtforms.fields import Field, PasswordField, SelectField, StringField",
            "from wtforms.fields.html5 import EmailField",
            "",
            "from rdiffweb.controller import Controller, flash",
            "from rdiffweb.controller.cherrypy_wtf import CherryForm",
            "from rdiffweb.core.config import Option",
            "from rdiffweb.core.librdiff import rdiff_backup_version",
            "from rdiffweb.core.store import ADMIN_ROLE, MAINTAINER_ROLE, USER_ROLE",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "# Define the logger",
            "logger = logging.getLogger(__name__)",
            "",
            "# Maximum file path",
            "MAX_PATH = 260",
            "",
            "",
            "def get_pyinfo():",
            "    try:",
            "        import distro",
            "",
            "        yield _('OS Version'), '%s %s (%s %s)' % (",
            "            platform.system(),",
            "            platform.release(),",
            "            distro.name().capitalize(),",
            "            distro.version(),",
            "        )",
            "    except Exception:",
            "        yield _('OS Version'), '%s %s' % (platform.system(), platform.release())",
            "    if hasattr(os, 'path'):",
            "        yield _('OS Path'), os.environ['PATH']",
            "    if hasattr(sys, 'version'):",
            "        yield _('Python Version'), ''.join(sys.version)",
            "    if hasattr(sys, 'subversion'):",
            "        yield _('Python Subversion'), ', '.join(sys.subversion)",
            "    if hasattr(sys, 'prefix'):",
            "        yield _('Python Prefix'), sys.prefix",
            "    if hasattr(sys, 'executable'):",
            "        yield _('Python Executable'), sys.executable",
            "    if hasattr(sys, 'path'):",
            "        yield _('Python Path'), ', '.join(sys.path)",
            "",
            "",
            "def get_osinfo():",
            "    def gr_name(gid):",
            "        try:",
            "            return grp.getgrgid(gid).gr_name",
            "        except Exception:",
            "            return",
            "",
            "    def pw_name(uid):",
            "        try:",
            "            return pwd.getpwuid(os.getuid()).pw_name",
            "        except Exception:",
            "            return",
            "",
            "    if hasattr(sys, 'getfilesystemencoding'):",
            "        yield _('File System Encoding'), sys.getfilesystemencoding()",
            "    if hasattr(os, 'getcwd'):",
            "        yield _('Current Working Directory'), os.getcwd()",
            "    if hasattr(os, 'getegid'):",
            "        yield _('Effective Group'), '%s (%s)' % (os.getegid(), gr_name(os.getegid()))",
            "    if hasattr(os, 'geteuid'):",
            "        yield _('Effective User'), '%s (%s)' % (os.geteuid(), pw_name(os.geteuid))",
            "    if hasattr(os, 'getgid'):",
            "        yield _('Group'), '%s (%s)' % (os.getgid(), gr_name(os.getgid()))",
            "    if hasattr(os, 'getuid'):",
            "        yield _('User'), '%s (%s)' % (os.getuid(), gr_name(os.getuid()))",
            "    if hasattr(os, 'getgroups'):",
            "        yield _('Group Membership'), ', '.join(['%s (%s)' % (gid, gr_name(gid)) for gid in os.getgroups()])",
            "    try:",
            "        if hasattr(os, 'getpid') and hasattr(os, 'getppid'):",
            "            yield _('Process ID'), ('%s (parent: %s)' % (os.getpid(), os.getppid()))",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def get_hwinfo():",
            "    if hasattr(os, 'getloadavg'):",
            "        yield _('Load Average'), ', '.join(map(str, map(lambda x: round(x, 2), os.getloadavg())))",
            "    yield _('CPU Count'), psutil.cpu_count()",
            "    meminfo = psutil.virtual_memory()",
            "    yield _('Memory usage'), '%s / %s' % (",
            "        humanfriendly.format_size(meminfo.used),",
            "        humanfriendly.format_size(meminfo.total),",
            "    )",
            "",
            "",
            "def get_pkginfo():",
            "    yield _('Rdiff-Backup Version'), '.'.join([str(i) for i in rdiff_backup_version()])",
            "    import jinja2",
            "",
            "    yield _('Jinja2 Version'), getattr(jinja2, '__version__')",
            "    yield _('CherryPy Version'), getattr(cherrypy, '__version__')",
            "    import sqlalchemy",
            "",
            "    yield _('SQLAlchemy Version'), getattr(sqlalchemy, '__version__')",
            "    try:",
            "        import ldap",
            "",
            "        yield _('LDAP Version'), getattr(ldap, '__version__')",
            "        yield _('LDAP SASL Support (Cyrus-SASL)'), ldap.SASL_AVAIL  # @UndefinedVariable",
            "        yield _('LDAP TLS Support (OpenSSL)'), ldap.TLS_AVAIL  # @UndefinedVariable",
            "    except Exception:",
            "        pass",
            "",
            "",
            "class SizeField(Field):",
            "    \"\"\"",
            "    A text field which stores a file size as GiB or GB format.",
            "    \"\"\"",
            "",
            "    widget = widgets.TextInput()",
            "",
            "    def __init__(self, label=None, validators=None, **kwargs):",
            "        super(SizeField, self).__init__(label, validators, **kwargs)",
            "",
            "    def _value(self):",
            "        if self.raw_data:",
            "            return ' '.join(self.raw_data)",
            "        else:",
            "            return self.data and humanfriendly.format_size(self.data, binary=True) or ''",
            "",
            "    def process_formdata(self, valuelist):",
            "        if valuelist:",
            "            value_str = ''.join(valuelist)",
            "            # parse_size doesn't handle locales.this mean we need to",
            "            # replace ',' by '.' to get parse and prefix number with 0",
            "            value_str = value_str.replace(',', '.').strip()",
            "            # a value must start with a number.",
            "            if value_str.startswith('.'):",
            "                value_str = '0' + value_str",
            "            try:",
            "                self.data = humanfriendly.parse_size(value_str)",
            "            except humanfriendly.InvalidSize:",
            "                self.data = None",
            "                raise ValueError(self.gettext('Not a valid file size value'))",
            "",
            "",
            "class UserForm(CherryForm):",
            "    userid = StringField(_('UserID'))",
            "    username = StringField(",
            "        _('Username'),",
            "        validators=[",
            "            validators.data_required(),",
            "            validators.length(max=256, message=_('Username too long.')),",
            "        ],",
            "    )",
            "    email = EmailField(",
            "        _('Email'),",
            "        validators=[",
            "            validators.optional(),",
            "            validators.length(max=256, message=_('Email too long.')),",
            "        ],",
            "    )",
            "    password = PasswordField(_('Password'), validators=[validators.optional()])",
            "    user_root = StringField(",
            "        _('Root directory'),",
            "        description=_(\"Absolute path defining the location of the repositories for this user.\"),",
            "        validators=[",
            "            validators.length(max=MAX_PATH, message=_('Root directory too long.')),",
            "        ],",
            "    )",
            "    role = SelectField(",
            "        _('User Role'),",
            "        coerce=int,",
            "        choices=[(ADMIN_ROLE, _(\"Admin\")), (MAINTAINER_ROLE, _(\"Maintainer\")), (USER_ROLE, _(\"User\"))],",
            "        default=USER_ROLE,",
            "        description=_(",
            "            \"Admin: may browse and delete everything. Maintainer: may browse and delete their own repo. User: may only browser their own repo.\"",
            "        ),",
            "    )",
            "    disk_quota = SizeField(",
            "        _('Disk space'),",
            "        validators=[validators.optional()],",
            "        description=_(\"Users disk spaces (in bytes). Set to 0 to remove quota (unlimited).\"),",
            "    )",
            "    disk_usage = SizeField(",
            "        _('Quota Used'), validators=[validators.optional()], description=_(\"Disk spaces (in bytes) used by this user.\")",
            "    )",
            "",
            "    def validate_password(self, field):",
            "        validator = validators.length(",
            "            min=self.app.cfg.password_min_length,",
            "            max=self.app.cfg.password_max_length,",
            "            message=_('Password must have between %(min)d and %(max)d characters.'),",
            "        )",
            "        validator(self, field)",
            "",
            "    @property",
            "    def app(self):",
            "        return cherrypy.request.app",
            "",
            "    def validate_role(self, field):",
            "        # Don't allow the user to changes it's \"role\" state.",
            "        currentuser = cherrypy.request.currentuser",
            "        if self.username.data == currentuser.username and self.role.data != currentuser.role:",
            "            raise ValueError(_('Cannot edit your own role.'))",
            "",
            "    def populate_obj(self, userobj):",
            "        # Save password if defined",
            "        if self.password.data:",
            "            userobj.set_password(self.password.data, old_password=None)",
            "        userobj.role = self.role.data",
            "        userobj.email = self.email.data or ''",
            "        userobj.user_root = self.user_root.data",
            "        if not userobj.valid_user_root():",
            "            flash(_(\"User's root directory %s is not accessible!\") % userobj.user_root, level='error')",
            "            logger.warning(\"user's root directory %s is not accessible\" % userobj.user_root)",
            "        # Try to update disk quota if the human readable value changed.",
            "        # Report error using flash.",
            "        new_quota = self.disk_quota.data or 0",
            "        old_quota = humanfriendly.parse_size(humanfriendly.format_size(self.disk_quota.object_data or 0, binary=True))",
            "        if old_quota != new_quota:",
            "            userobj.disk_quota = new_quota",
            "            # Setting quota will silently fail. Check if quota was updated.",
            "            if userobj.disk_quota != new_quota:",
            "                flash(_(\"Setting user's quota is not supported\"), level='warning')",
            "",
            "",
            "class EditUserForm(UserForm):",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "        # Make username field read-only",
            "        self.username.render_kw = {'readonly': True}",
            "        self.username.populate_obj = lambda *args, **kwargs: None",
            "",
            "",
            "class DeleteUserForm(CherryForm):",
            "    username = StringField(_('Username'), validators=[validators.data_required()])",
            "",
            "",
            "@cherrypy.tools.is_admin()",
            "class AdminPage(Controller):",
            "    \"\"\"Administration pages. Allow to manage users database.\"\"\"",
            "",
            "    logfile = Option('log_file')",
            "    logaccessfile = Option('log_access_file')",
            "",
            "    def _delete_user(self, action, form):",
            "        assert action == 'delete'",
            "        assert form",
            "        # Validate form.",
            "        if not form.validate():",
            "            flash(form.error_message, level='error')",
            "            return",
            "        if form.username.data == self.app.currentuser.username:",
            "            flash(_(\"You cannot remove your own account!\"), level='error')",
            "        else:",
            "            try:",
            "                user = self.app.store.get_user(form.username.data)",
            "                if user:",
            "                    user.delete()",
            "                    flash(_(\"User account removed.\"))",
            "                else:",
            "                    flash(_(\"User doesn't exists!\"), level='warning')",
            "            except ValueError as e:",
            "                flash(e, level='error')",
            "",
            "    def _get_log_files(self):",
            "        \"\"\"",
            "        Return a list of log files to be shown in admin area.",
            "        \"\"\"",
            "        return [fn for fn in [self.logfile, self.logaccessfile] if fn]",
            "",
            "    def _get_log_data(self, fn, num=2000):",
            "        \"\"\"",
            "        Return a list of log files to be shown in admin area.",
            "        \"\"\"",
            "        try:",
            "            return subprocess.check_output(['tail', '-n', str(num), fn], stderr=subprocess.STDOUT).decode('utf-8')",
            "        except Exception:",
            "            logging.exception('fail to get log file content')",
            "            return \"Error getting file content\"",
            "",
            "    @cherrypy.expose",
            "    def default(self):",
            "        params = {\"user_count\": self.app.store.count_users(), \"repo_count\": self.app.store.count_repos()}",
            "",
            "        return self._compile_template(\"admin.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def logs(self, filename=u\"\"):",
            "        # get list of log file available.",
            "        data = \"\"",
            "        logfiles = OrderedDict([(os.path.basename(fn), fn) for fn in self._get_log_files()])",
            "        if logfiles:",
            "            filename = filename or list(logfiles.keys())[0]",
            "            if filename not in logfiles:",
            "                raise cherrypy.HTTPError(404, 'invalid log file: ' + filename)",
            "            data = self._get_log_data(logfiles.get(filename))",
            "",
            "        params = {",
            "            \"filename\": filename,",
            "            \"logfiles\": logfiles.keys(),",
            "            \"data\": data,",
            "        }",
            "        return self._compile_template(\"admin_logs.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def users(self, username=None, criteria=u\"\", search=u\"\", action=u\"\", **kwargs):",
            "",
            "        # If we're just showing the initial page, just do that",
            "        if action == \"add\":",
            "            form = UserForm()",
            "            if form.validate_on_submit():",
            "                try:",
            "                    user = self.app.store.add_user(username)",
            "                    form.populate_obj(user)",
            "                    flash(_(\"User added successfully.\"))",
            "                except Exception as e:",
            "                    flash(str(e), level='error')",
            "            else:",
            "                flash(form.error_message, level='error')",
            "        elif action == \"edit\":",
            "            user = self.app.store.get_user(username)",
            "            if user:",
            "                form = EditUserForm(obj=user)",
            "                if form.validate_on_submit():",
            "                    try:",
            "                        form.populate_obj(user)",
            "                        flash(_(\"User information modified successfully.\"))",
            "                    except Exception as e:",
            "                        flash(str(e), level='error')",
            "                else:",
            "                    flash(form.error_message, level='error')",
            "            else:",
            "                flash(_(\"Cannot edit user `%s`: user doesn't exists\") % username, level='error')",
            "        elif action == 'delete':",
            "            form = DeleteUserForm()",
            "            if form.validate_on_submit():",
            "                self._delete_user(action, form)",
            "",
            "        params = {",
            "            \"add_form\": UserForm(formdata=None),",
            "            \"edit_form\": EditUserForm(formdata=None),",
            "            \"criteria\": criteria,",
            "            \"search\": search,",
            "            \"users\": list(self.app.store.users(search=search, criteria=criteria)),",
            "        }",
            "",
            "        # Build users page",
            "        return self._compile_template(\"admin_users.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def repos(self, criteria=u\"\", search=u\"\"):",
            "        params = {",
            "            \"criteria\": criteria,",
            "            \"search\": search,",
            "            \"repos\": list(self.app.store.repos(search=search, criteria=criteria)),",
            "        }",
            "        return self._compile_template(\"admin_repos.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def sysinfo(self):",
            "",
            "        params = {",
            "            \"version\": self.app.version,",
            "            # Config",
            "            \"cfg\": {k: '********' if 'password' in k else v for k, v in vars(self.app.cfg).items()},",
            "            # System Info entries",
            "            \"pyinfo\": list(get_pyinfo()),",
            "            \"osinfo\": list(get_osinfo()),",
            "            \"hwinfo\": list(get_hwinfo()),",
            "            \"ldapinfo\": list(get_pkginfo()),",
            "        }",
            "",
            "        return self._compile_template(\"admin_sysinfo.html\", **params)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import grp",
            "import logging",
            "import os",
            "import platform",
            "import pwd",
            "import subprocess",
            "import sys",
            "from collections import OrderedDict",
            "",
            "import cherrypy",
            "import humanfriendly",
            "import psutil",
            "from wtforms import validators, widgets",
            "from wtforms.fields import Field, PasswordField, SelectField, StringField",
            "from wtforms.fields.html5 import EmailField",
            "",
            "from rdiffweb.controller import Controller, flash",
            "from rdiffweb.controller.cherrypy_wtf import CherryForm",
            "from rdiffweb.core.config import Option",
            "from rdiffweb.core.librdiff import rdiff_backup_version",
            "from rdiffweb.core.store import ADMIN_ROLE, MAINTAINER_ROLE, USER_ROLE",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "# Define the logger",
            "logger = logging.getLogger(__name__)",
            "",
            "# Maximum file path",
            "MAX_PATH = 260",
            "",
            "",
            "def get_pyinfo():",
            "    try:",
            "        import distro",
            "",
            "        yield _('OS Version'), '%s %s (%s %s)' % (",
            "            platform.system(),",
            "            platform.release(),",
            "            distro.name().capitalize(),",
            "            distro.version(),",
            "        )",
            "    except Exception:",
            "        yield _('OS Version'), '%s %s' % (platform.system(), platform.release())",
            "    if hasattr(os, 'path'):",
            "        yield _('OS Path'), os.environ['PATH']",
            "    if hasattr(sys, 'version'):",
            "        yield _('Python Version'), ''.join(sys.version)",
            "    if hasattr(sys, 'subversion'):",
            "        yield _('Python Subversion'), ', '.join(sys.subversion)",
            "    if hasattr(sys, 'prefix'):",
            "        yield _('Python Prefix'), sys.prefix",
            "    if hasattr(sys, 'executable'):",
            "        yield _('Python Executable'), sys.executable",
            "    if hasattr(sys, 'path'):",
            "        yield _('Python Path'), ', '.join(sys.path)",
            "",
            "",
            "def get_osinfo():",
            "    def gr_name(gid):",
            "        try:",
            "            return grp.getgrgid(gid).gr_name",
            "        except Exception:",
            "            return",
            "",
            "    def pw_name(uid):",
            "        try:",
            "            return pwd.getpwuid(os.getuid()).pw_name",
            "        except Exception:",
            "            return",
            "",
            "    if hasattr(sys, 'getfilesystemencoding'):",
            "        yield _('File System Encoding'), sys.getfilesystemencoding()",
            "    if hasattr(os, 'getcwd'):",
            "        yield _('Current Working Directory'), os.getcwd()",
            "    if hasattr(os, 'getegid'):",
            "        yield _('Effective Group'), '%s (%s)' % (os.getegid(), gr_name(os.getegid()))",
            "    if hasattr(os, 'geteuid'):",
            "        yield _('Effective User'), '%s (%s)' % (os.geteuid(), pw_name(os.geteuid))",
            "    if hasattr(os, 'getgid'):",
            "        yield _('Group'), '%s (%s)' % (os.getgid(), gr_name(os.getgid()))",
            "    if hasattr(os, 'getuid'):",
            "        yield _('User'), '%s (%s)' % (os.getuid(), gr_name(os.getuid()))",
            "    if hasattr(os, 'getgroups'):",
            "        yield _('Group Membership'), ', '.join(['%s (%s)' % (gid, gr_name(gid)) for gid in os.getgroups()])",
            "    try:",
            "        if hasattr(os, 'getpid') and hasattr(os, 'getppid'):",
            "            yield _('Process ID'), ('%s (parent: %s)' % (os.getpid(), os.getppid()))",
            "    except Exception:",
            "        pass",
            "",
            "",
            "def get_hwinfo():",
            "    if hasattr(os, 'getloadavg'):",
            "        yield _('Load Average'), ', '.join(map(str, map(lambda x: round(x, 2), os.getloadavg())))",
            "    yield _('CPU Count'), psutil.cpu_count()",
            "    meminfo = psutil.virtual_memory()",
            "    yield _('Memory usage'), '%s / %s' % (",
            "        humanfriendly.format_size(meminfo.used),",
            "        humanfriendly.format_size(meminfo.total),",
            "    )",
            "",
            "",
            "def get_pkginfo():",
            "    yield _('Rdiff-Backup Version'), '.'.join([str(i) for i in rdiff_backup_version()])",
            "    import jinja2",
            "",
            "    yield _('Jinja2 Version'), getattr(jinja2, '__version__')",
            "    yield _('CherryPy Version'), getattr(cherrypy, '__version__')",
            "    import sqlalchemy",
            "",
            "    yield _('SQLAlchemy Version'), getattr(sqlalchemy, '__version__')",
            "    try:",
            "        import ldap",
            "",
            "        yield _('LDAP Version'), getattr(ldap, '__version__')",
            "        yield _('LDAP SASL Support (Cyrus-SASL)'), ldap.SASL_AVAIL  # @UndefinedVariable",
            "        yield _('LDAP TLS Support (OpenSSL)'), ldap.TLS_AVAIL  # @UndefinedVariable",
            "    except Exception:",
            "        pass",
            "",
            "",
            "class SizeField(Field):",
            "    \"\"\"",
            "    A text field which stores a file size as GiB or GB format.",
            "    \"\"\"",
            "",
            "    widget = widgets.TextInput()",
            "",
            "    def __init__(self, label=None, validators=None, **kwargs):",
            "        super(SizeField, self).__init__(label, validators, **kwargs)",
            "",
            "    def _value(self):",
            "        if self.raw_data:",
            "            return ' '.join(self.raw_data)",
            "        else:",
            "            return self.data and humanfriendly.format_size(self.data, binary=True) or ''",
            "",
            "    def process_formdata(self, valuelist):",
            "        if valuelist:",
            "            value_str = ''.join(valuelist)",
            "            # parse_size doesn't handle locales.this mean we need to",
            "            # replace ',' by '.' to get parse and prefix number with 0",
            "            value_str = value_str.replace(',', '.').strip()",
            "            # a value must start with a number.",
            "            if value_str.startswith('.'):",
            "                value_str = '0' + value_str",
            "            try:",
            "                self.data = humanfriendly.parse_size(value_str)",
            "            except humanfriendly.InvalidSize:",
            "                self.data = None",
            "                raise ValueError(self.gettext('Not a valid file size value'))",
            "",
            "",
            "class UserForm(CherryForm):",
            "    userid = StringField(_('UserID'))",
            "    username = StringField(",
            "        _('Username'),",
            "        validators=[",
            "            validators.data_required(),",
            "            validators.length(max=256, message=_('Username too long.')),",
            "        ],",
            "    )",
            "    email = EmailField(",
            "        _('Email'),",
            "        validators=[",
            "            validators.optional(),",
            "            validators.length(max=256, message=_('Email too long.')),",
            "        ],",
            "    )",
            "    password = PasswordField(_('Password'), validators=[validators.optional()])",
            "    user_root = StringField(",
            "        _('Root directory'),",
            "        description=_(\"Absolute path defining the location of the repositories for this user.\"),",
            "        validators=[",
            "            validators.length(max=MAX_PATH, message=_('Root directory too long.')),",
            "        ],",
            "    )",
            "    role = SelectField(",
            "        _('User Role'),",
            "        coerce=int,",
            "        choices=[(ADMIN_ROLE, _(\"Admin\")), (MAINTAINER_ROLE, _(\"Maintainer\")), (USER_ROLE, _(\"User\"))],",
            "        default=USER_ROLE,",
            "        description=_(",
            "            \"Admin: may browse and delete everything. Maintainer: may browse and delete their own repo. User: may only browser their own repo.\"",
            "        ),",
            "    )",
            "    disk_quota = SizeField(",
            "        _('Disk space'),",
            "        validators=[validators.optional()],",
            "        description=_(\"Users disk spaces (in bytes). Set to 0 to remove quota (unlimited).\"),",
            "    )",
            "    disk_usage = SizeField(",
            "        _('Quota Used'), validators=[validators.optional()], description=_(\"Disk spaces (in bytes) used by this user.\")",
            "    )",
            "",
            "    def validate_role(self, field):",
            "        # Don't allow the user to changes it's \"role\" state.",
            "        currentuser = cherrypy.request.currentuser",
            "        if self.username.data == currentuser.username and self.role.data != currentuser.role:",
            "            raise ValueError(_('Cannot edit your own role.'))",
            "",
            "    def populate_obj(self, userobj):",
            "        # Save password if defined",
            "        if self.password.data:",
            "            userobj.set_password(self.password.data, old_password=None)",
            "        userobj.role = self.role.data",
            "        userobj.email = self.email.data or ''",
            "        userobj.user_root = self.user_root.data",
            "        if not userobj.valid_user_root():",
            "            flash(_(\"User's root directory %s is not accessible!\") % userobj.user_root, level='error')",
            "            logger.warning(\"user's root directory %s is not accessible\" % userobj.user_root)",
            "        # Try to update disk quota if the human readable value changed.",
            "        # Report error using flash.",
            "        new_quota = self.disk_quota.data or 0",
            "        old_quota = humanfriendly.parse_size(humanfriendly.format_size(self.disk_quota.object_data or 0, binary=True))",
            "        if old_quota != new_quota:",
            "            userobj.disk_quota = new_quota",
            "            # Setting quota will silently fail. Check if quota was updated.",
            "            if userobj.disk_quota != new_quota:",
            "                flash(_(\"Setting user's quota is not supported\"), level='warning')",
            "",
            "",
            "class EditUserForm(UserForm):",
            "    def __init__(self, **kwargs):",
            "        super().__init__(**kwargs)",
            "        # Make username field read-only",
            "        self.username.render_kw = {'readonly': True}",
            "        self.username.populate_obj = lambda *args, **kwargs: None",
            "",
            "",
            "class DeleteUserForm(CherryForm):",
            "    username = StringField(_('Username'), validators=[validators.data_required()])",
            "",
            "",
            "@cherrypy.tools.is_admin()",
            "class AdminPage(Controller):",
            "    \"\"\"Administration pages. Allow to manage users database.\"\"\"",
            "",
            "    logfile = Option('log_file')",
            "    logaccessfile = Option('log_access_file')",
            "",
            "    def _delete_user(self, action, form):",
            "        assert action == 'delete'",
            "        assert form",
            "        # Validate form.",
            "        if not form.validate():",
            "            flash(form.error_message, level='error')",
            "            return",
            "        if form.username.data == self.app.currentuser.username:",
            "            flash(_(\"You cannot remove your own account!\"), level='error')",
            "        else:",
            "            try:",
            "                user = self.app.store.get_user(form.username.data)",
            "                if user:",
            "                    user.delete()",
            "                    flash(_(\"User account removed.\"))",
            "                else:",
            "                    flash(_(\"User doesn't exists!\"), level='warning')",
            "            except ValueError as e:",
            "                flash(e, level='error')",
            "",
            "    def _get_log_files(self):",
            "        \"\"\"",
            "        Return a list of log files to be shown in admin area.",
            "        \"\"\"",
            "        return [fn for fn in [self.logfile, self.logaccessfile] if fn]",
            "",
            "    def _get_log_data(self, fn, num=2000):",
            "        \"\"\"",
            "        Return a list of log files to be shown in admin area.",
            "        \"\"\"",
            "        try:",
            "            return subprocess.check_output(['tail', '-n', str(num), fn], stderr=subprocess.STDOUT).decode('utf-8')",
            "        except Exception:",
            "            logging.exception('fail to get log file content')",
            "            return \"Error getting file content\"",
            "",
            "    @cherrypy.expose",
            "    def default(self):",
            "        params = {\"user_count\": self.app.store.count_users(), \"repo_count\": self.app.store.count_repos()}",
            "",
            "        return self._compile_template(\"admin.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def logs(self, filename=u\"\"):",
            "        # get list of log file available.",
            "        data = \"\"",
            "        logfiles = OrderedDict([(os.path.basename(fn), fn) for fn in self._get_log_files()])",
            "        if logfiles:",
            "            filename = filename or list(logfiles.keys())[0]",
            "            if filename not in logfiles:",
            "                raise cherrypy.HTTPError(404, 'invalid log file: ' + filename)",
            "            data = self._get_log_data(logfiles.get(filename))",
            "",
            "        params = {",
            "            \"filename\": filename,",
            "            \"logfiles\": logfiles.keys(),",
            "            \"data\": data,",
            "        }",
            "        return self._compile_template(\"admin_logs.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def users(self, username=None, criteria=u\"\", search=u\"\", action=u\"\", **kwargs):",
            "",
            "        # If we're just showing the initial page, just do that",
            "        if action == \"add\":",
            "            form = UserForm()",
            "            if form.validate_on_submit():",
            "                try:",
            "                    user = self.app.store.add_user(username)",
            "                    form.populate_obj(user)",
            "                    flash(_(\"User added successfully.\"))",
            "                except Exception as e:",
            "                    flash(str(e), level='error')",
            "            else:",
            "                flash(form.error_message, level='error')",
            "        elif action == \"edit\":",
            "            user = self.app.store.get_user(username)",
            "            if user:",
            "                form = EditUserForm(obj=user)",
            "                if form.validate_on_submit():",
            "                    try:",
            "                        form.populate_obj(user)",
            "                        flash(_(\"User information modified successfully.\"))",
            "                    except Exception as e:",
            "                        flash(str(e), level='error')",
            "                else:",
            "                    flash(form.error_message, level='error')",
            "            else:",
            "                flash(_(\"Cannot edit user `%s`: user doesn't exists\") % username, level='error')",
            "        elif action == 'delete':",
            "            form = DeleteUserForm()",
            "            if form.validate_on_submit():",
            "                self._delete_user(action, form)",
            "",
            "        params = {",
            "            \"add_form\": UserForm(formdata=None),",
            "            \"edit_form\": EditUserForm(formdata=None),",
            "            \"criteria\": criteria,",
            "            \"search\": search,",
            "            \"users\": list(self.app.store.users(search=search, criteria=criteria)),",
            "        }",
            "",
            "        # Build users page",
            "        return self._compile_template(\"admin_users.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def repos(self, criteria=u\"\", search=u\"\"):",
            "        params = {",
            "            \"criteria\": criteria,",
            "            \"search\": search,",
            "            \"repos\": list(self.app.store.repos(search=search, criteria=criteria)),",
            "        }",
            "        return self._compile_template(\"admin_repos.html\", **params)",
            "",
            "    @cherrypy.expose",
            "    def sysinfo(self):",
            "",
            "        params = {",
            "            \"version\": self.app.version,",
            "            # Config",
            "            \"cfg\": {k: '********' if 'password' in k else v for k, v in vars(self.app.cfg).items()},",
            "            # System Info entries",
            "            \"pyinfo\": list(get_pyinfo()),",
            "            \"osinfo\": list(get_osinfo()),",
            "            \"hwinfo\": list(get_hwinfo()),",
            "            \"ldapinfo\": list(get_pkginfo()),",
            "        }",
            "",
            "        return self._compile_template(\"admin_sysinfo.html\", **params)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "212": [
                "UserForm",
                "validate_password"
            ],
            "213": [
                "UserForm",
                "validate_password"
            ],
            "214": [
                "UserForm",
                "validate_password"
            ],
            "215": [
                "UserForm",
                "validate_password"
            ],
            "216": [
                "UserForm",
                "validate_password"
            ],
            "217": [
                "UserForm",
                "validate_password"
            ],
            "218": [
                "UserForm",
                "validate_password"
            ],
            "219": [
                "UserForm"
            ],
            "220": [
                "UserForm"
            ],
            "221": [
                "UserForm",
                "app"
            ],
            "222": [
                "UserForm",
                "app"
            ],
            "223": [
                "UserForm"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/controller/pref_general.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         _('Confirm new password'), validators=[InputRequired(_(\"Confirmation password is missing.\"))]"
            },
            "1": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     )"
            },
            "2": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def validate_new(self, field):"
            },
            "4": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validator = Length("
            },
            "5": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            min=self.app.cfg.password_min_length,"
            },
            "6": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            max=self.app.cfg.password_max_length,"
            },
            "7": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            message=_('Password must have between %(min)d and %(max)d characters.'),"
            },
            "8": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        )"
            },
            "9": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        validator(self, field)"
            },
            "10": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "11": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @property"
            },
            "12": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def app(self):"
            },
            "13": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return cherrypy.request.app"
            },
            "14": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "15": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " class PrefsGeneralPanelProvider(Controller):"
            },
            "17": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     \"\"\""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Default preference page to show general user information. It allows user",
            "to change password ans refresh it's repository view.",
            "\"\"\"",
            "",
            "import logging",
            "import re",
            "",
            "import cherrypy",
            "from wtforms.fields.html5 import EmailField",
            "from wtforms.fields.simple import PasswordField",
            "from wtforms.validators import DataRequired, EqualTo, InputRequired, Length, Regexp",
            "",
            "from rdiffweb.controller import Controller, flash",
            "from rdiffweb.controller.cherrypy_wtf import CherryForm",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "# Define the logger",
            "_logger = logging.getLogger(__name__)",
            "",
            "PATTERN_EMAIL = re.compile(r'[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$')",
            "",
            "",
            "class UserProfileForm(CherryForm):",
            "    email = EmailField(",
            "        _('Email'),",
            "        validators=[",
            "            DataRequired(),",
            "            Length(max=256, message=_(\"Invalid email.\")),",
            "            Regexp(PATTERN_EMAIL, message=_(\"Invalid email.\")),",
            "        ],",
            "    )",
            "",
            "",
            "class UserPasswordForm(CherryForm):",
            "    current = PasswordField(_('Current password'), validators=[InputRequired(_(\"Current password is missing.\"))])",
            "    new = PasswordField(",
            "        _('New password'),",
            "        validators=[",
            "            InputRequired(_(\"New password is missing.\")),",
            "            EqualTo('confirm', message=_(\"The new password and its confirmation do not match.\")),",
            "        ],",
            "    )",
            "    confirm = PasswordField(",
            "        _('Confirm new password'), validators=[InputRequired(_(\"Confirmation password is missing.\"))]",
            "    )",
            "",
            "    def validate_new(self, field):",
            "        validator = Length(",
            "            min=self.app.cfg.password_min_length,",
            "            max=self.app.cfg.password_max_length,",
            "            message=_('Password must have between %(min)d and %(max)d characters.'),",
            "        )",
            "        validator(self, field)",
            "",
            "    @property",
            "    def app(self):",
            "        return cherrypy.request.app",
            "",
            "",
            "class PrefsGeneralPanelProvider(Controller):",
            "    \"\"\"",
            "    Plugin to change user profile and password.",
            "    \"\"\"",
            "",
            "    panel_id = 'general'",
            "",
            "    panel_name = _('Profile')",
            "",
            "    def _handle_set_password(self, action, form):",
            "        \"\"\"",
            "        Called when changing user password.",
            "        \"\"\"",
            "        assert self.app.currentuser",
            "        assert action == 'set_password'",
            "        assert form",
            "        # Validate form",
            "        if not form.validate():",
            "            flash(form.error_message, level='error')",
            "            return",
            "        # Update user password",
            "        try:",
            "            self.app.currentuser.set_password(form.new.data, old_password=form.current.data)",
            "            flash(_(\"Password updated successfully.\"), level='success')",
            "        except ValueError as e:",
            "            flash(str(e), level='warning')",
            "",
            "    def _handle_set_profile_info(self, action, form):",
            "        \"\"\"",
            "        Called when changing user profile.",
            "        \"\"\"",
            "        assert self.app.currentuser",
            "        assert action == 'set_profile_info'",
            "        assert form",
            "        # Validate form",
            "        if not form.validate():",
            "            flash(form.error_message, level='error')",
            "            return",
            "        # Update the user's email",
            "        username = self.app.currentuser.username",
            "        _logger.info(\"updating user [%s] email [%s]\", username, form.email.data)",
            "        self.app.currentuser.email = form.email.data",
            "        # Report success",
            "        flash(_(\"Profile updated successfully.\"), level='success')",
            "",
            "    def render_prefs_panel(self, panelid, action=None, **kwargs):  # @UnusedVariable",
            "        # Process the parameters.",
            "        profile_form = UserProfileForm(email=self.app.currentuser.email)",
            "        password_form = UserPasswordForm()",
            "        if cherrypy.request.method == 'POST':",
            "            if action == \"set_profile_info\":",
            "                self._handle_set_profile_info(action, profile_form)",
            "            elif action == \"set_password\":",
            "                self._handle_set_password(action, password_form)",
            "            elif action == \"update_repos\":",
            "                self.app.currentuser.refresh_repos(delete=True)",
            "                flash(_(\"Repositories successfully updated\"), level='success')",
            "            elif action is None:",
            "                pass",
            "            else:",
            "                _logger.warning(\"unknown action: %s\", action)",
            "                raise cherrypy.NotFound(\"Unknown action\")",
            "        params = {",
            "            'profile_form': profile_form,",
            "            'password_form': password_form,",
            "        }",
            "        return \"prefs_general.html\", params"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Default preference page to show general user information. It allows user",
            "to change password ans refresh it's repository view.",
            "\"\"\"",
            "",
            "import logging",
            "import re",
            "",
            "import cherrypy",
            "from wtforms.fields.html5 import EmailField",
            "from wtforms.fields.simple import PasswordField",
            "from wtforms.validators import DataRequired, EqualTo, InputRequired, Length, Regexp",
            "",
            "from rdiffweb.controller import Controller, flash",
            "from rdiffweb.controller.cherrypy_wtf import CherryForm",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "# Define the logger",
            "_logger = logging.getLogger(__name__)",
            "",
            "PATTERN_EMAIL = re.compile(r'[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$')",
            "",
            "",
            "class UserProfileForm(CherryForm):",
            "    email = EmailField(",
            "        _('Email'),",
            "        validators=[",
            "            DataRequired(),",
            "            Length(max=256, message=_(\"Invalid email.\")),",
            "            Regexp(PATTERN_EMAIL, message=_(\"Invalid email.\")),",
            "        ],",
            "    )",
            "",
            "",
            "class UserPasswordForm(CherryForm):",
            "    current = PasswordField(_('Current password'), validators=[InputRequired(_(\"Current password is missing.\"))])",
            "    new = PasswordField(",
            "        _('New password'),",
            "        validators=[",
            "            InputRequired(_(\"New password is missing.\")),",
            "            EqualTo('confirm', message=_(\"The new password and its confirmation do not match.\")),",
            "        ],",
            "    )",
            "    confirm = PasswordField(",
            "        _('Confirm new password'), validators=[InputRequired(_(\"Confirmation password is missing.\"))]",
            "    )",
            "",
            "",
            "class PrefsGeneralPanelProvider(Controller):",
            "    \"\"\"",
            "    Plugin to change user profile and password.",
            "    \"\"\"",
            "",
            "    panel_id = 'general'",
            "",
            "    panel_name = _('Profile')",
            "",
            "    def _handle_set_password(self, action, form):",
            "        \"\"\"",
            "        Called when changing user password.",
            "        \"\"\"",
            "        assert self.app.currentuser",
            "        assert action == 'set_password'",
            "        assert form",
            "        # Validate form",
            "        if not form.validate():",
            "            flash(form.error_message, level='error')",
            "            return",
            "        # Update user password",
            "        try:",
            "            self.app.currentuser.set_password(form.new.data, old_password=form.current.data)",
            "            flash(_(\"Password updated successfully.\"), level='success')",
            "        except ValueError as e:",
            "            flash(str(e), level='warning')",
            "",
            "    def _handle_set_profile_info(self, action, form):",
            "        \"\"\"",
            "        Called when changing user profile.",
            "        \"\"\"",
            "        assert self.app.currentuser",
            "        assert action == 'set_profile_info'",
            "        assert form",
            "        # Validate form",
            "        if not form.validate():",
            "            flash(form.error_message, level='error')",
            "            return",
            "        # Update the user's email",
            "        username = self.app.currentuser.username",
            "        _logger.info(\"updating user [%s] email [%s]\", username, form.email.data)",
            "        self.app.currentuser.email = form.email.data",
            "        # Report success",
            "        flash(_(\"Profile updated successfully.\"), level='success')",
            "",
            "    def render_prefs_panel(self, panelid, action=None, **kwargs):  # @UnusedVariable",
            "        # Process the parameters.",
            "        profile_form = UserProfileForm(email=self.app.currentuser.email)",
            "        password_form = UserPasswordForm()",
            "        if cherrypy.request.method == 'POST':",
            "            if action == \"set_profile_info\":",
            "                self._handle_set_profile_info(action, profile_form)",
            "            elif action == \"set_password\":",
            "                self._handle_set_password(action, password_form)",
            "            elif action == \"update_repos\":",
            "                self.app.currentuser.refresh_repos(delete=True)",
            "                flash(_(\"Repositories successfully updated\"), level='success')",
            "            elif action is None:",
            "                pass",
            "            else:",
            "                _logger.warning(\"unknown action: %s\", action)",
            "                raise cherrypy.NotFound(\"Unknown action\")",
            "        params = {",
            "            'profile_form': profile_form,",
            "            'password_form': password_form,",
            "        }",
            "        return \"prefs_general.html\", params"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "64": [
                "UserPasswordForm",
                "validate_new"
            ],
            "65": [
                "UserPasswordForm",
                "validate_new"
            ],
            "66": [
                "UserPasswordForm",
                "validate_new"
            ],
            "67": [
                "UserPasswordForm",
                "validate_new"
            ],
            "68": [
                "UserPasswordForm",
                "validate_new"
            ],
            "69": [
                "UserPasswordForm",
                "validate_new"
            ],
            "70": [
                "UserPasswordForm",
                "validate_new"
            ],
            "71": [
                "UserPasswordForm"
            ],
            "72": [
                "UserPasswordForm"
            ],
            "73": [
                "UserPasswordForm",
                "app"
            ],
            "74": [
                "UserPasswordForm",
                "app"
            ],
            "75": []
        },
        "addLocation": []
    },
    "rdiffweb/controller/tests/test_page_admin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     def test_add_user_with_role_admin(self):"
            },
            "2": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         # When trying to create a new user with role admin"
            },
            "3": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"admin_role\", \"admin_role@test.com\", \"password\", \"/home/\", ADMIN_ROLE)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        self._add_user(\"admin_role\", \"admin_role@test.com\", \"pr3j5Dwi\", \"/home/\", ADMIN_ROLE)"
            },
            "5": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "         # Then page return success"
            },
            "6": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "7": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         # Then database is updated"
            },
            "8": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "         self.listener.user_added.assert_called_once_with(userobj)"
            },
            "9": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "     def test_add_user_with_role_maintainer(self):"
            },
            "11": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"password\", \"/home/\", MAINTAINER_ROLE)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"pr3j5Dwi\", \"/home/\", MAINTAINER_ROLE)"
            },
            "13": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "14": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.assertEqual(MAINTAINER_ROLE, self.app.store.get_user('maintainer_role').role)"
            },
            "15": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 123,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "     def test_add_user_with_role_user(self):"
            },
            "17": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"user_role\", \"user_role@test.com\", \"password\", \"/home/\", USER_ROLE)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+        self._add_user(\"user_role\", \"user_role@test.com\", \"pr3j5Dwi\", \"/home/\", USER_ROLE)"
            },
            "19": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "20": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "         self.assertEqual(USER_ROLE, self.app.store.get_user('user_role').role)"
            },
            "21": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     def test_add_user_with_invalid_role(self):"
            },
            "23": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         # When trying to create a new user with an invalid role (admin instead of 0)"
            },
            "24": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"invalid\", \"invalid@test.com\", \"test1234\", \"/home/\", 'admin')"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", 'admin')"
            },
            "26": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         # Then an error message is displayed to the user"
            },
            "27": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "28": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "         self.assertInBody('role: Invalid Choice: could not coerce')"
            },
            "29": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         # Then listener are not called"
            },
            "30": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "         self.listener.user_added.assert_not_called()"
            },
            "31": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         # When trying to create a new user with an invalid role (-1)"
            },
            "33": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"invalid\", \"invalid@test.com\", \"test2\", \"/home/\", -1)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", -1)"
            },
            "35": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         # Then an error message is displayed to the user"
            },
            "36": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "37": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         self.assertInBody('role: Not a valid choice')"
            },
            "38": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     def test_add_edit_delete(self):"
            },
            "40": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         #  Add user to be listed"
            },
            "41": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test2\", \"test2@test.com\", \"test1234\", \"/home/\", USER_ROLE)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        self._add_user(\"test2\", \"test2@test.com\", \"pr3j5Dwi\", \"/home/\", USER_ROLE)"
            },
            "43": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "         self.assertInBody(\"User added successfully.\")"
            },
            "44": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "         self.assertInBody(\"test2\")"
            },
            "45": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         self.assertInBody(\"test2@test.com\")"
            },
            "46": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         \"\"\""
            },
            "47": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         Check creation of user with non-ascii char."
            },
            "48": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "         \"\"\""
            },
            "49": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"\u00c9ric\", \"\u00e9ric@test.com\", \"password\", \"/home/\", USER_ROLE)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        self._add_user(\"\u00c9ric\", \"\u00e9ric@test.com\", \"pr3j5Dwi\", \"/home/\", USER_ROLE)"
            },
            "51": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         self.assertInBody(\"User added successfully.\")"
            },
            "52": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "         self.assertInBody(\"\u00c9ric\")"
            },
            "53": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         self.assertInBody(\"\u00e9ric@test.com\")"
            },
            "54": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         \"\"\""
            },
            "55": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "         Verify failure trying to create user without username."
            },
            "56": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "         \"\"\""
            },
            "57": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"\", \"test1@test.com\", \"test1\", \"/tmp/\", USER_ROLE)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        self._add_user(\"\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)"
            },
            "59": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "60": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         self.assertInBody(\"username: This field is required.\")"
            },
            "61": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         Verify failure trying to add the same user."
            },
            "63": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         \"\"\""
            },
            "64": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         # Given a user named `test1`"
            },
            "65": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", USER_ROLE)"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)"
            },
            "67": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         # When trying to create a new user with the same name"
            },
            "68": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", USER_ROLE)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)"
            },
            "70": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         # Then the user list is displayed with an error message."
            },
            "71": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "72": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         self.assertInBody(\"User test1 already exists.\")"
            },
            "73": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "             self._delete_user(\"test5\")"
            },
            "74": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "         except Exception:"
            },
            "75": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "             pass"
            },
            "76": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test5\", \"test1@test.com\", \"password\", \"/var/invalid/\", USER_ROLE)"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+        self._add_user(\"test5\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", USER_ROLE)"
            },
            "78": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "         self.assertInBody(\"User added successfully.\")"
            },
            "79": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "         self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")"
            },
            "80": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "     def test_add_without_email(self):"
            },
            "82": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         #  Add user to be listed"
            },
            "83": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test2\", None, \"password\", \"/tmp/\", USER_ROLE)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        self._add_user(\"test2\", None, \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)"
            },
            "85": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "         self.assertInBody(\"User added successfully.\")"
            },
            "86": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": " "
            },
            "87": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 234,
                "PatchRowcode": "     def test_add_without_user_root(self):"
            },
            "88": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "         #  Add user to be listed"
            },
            "89": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test6\", None, \"password\", None, USER_ROLE)"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+        self._add_user(\"test6\", None, \"pr3j5Dwi\", None, USER_ROLE)"
            },
            "91": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "         self.assertInBody(\"User added successfully.\")"
            },
            "92": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 238,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "         user = self.app.store.get_user('test6')"
            },
            "94": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "         # Given a too long username"
            },
            "95": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "         username = \"test2\" * 52"
            },
            "96": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         # When trying to create the user"
            },
            "97": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(username, None, \"password\", \"/tmp/\", USER_ROLE)"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        self._add_user(username, None, \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)"
            },
            "99": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "         # Then an error is raised"
            },
            "100": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "101": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         self.assertInBody(\"Username too long.\")"
            },
            "102": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "         # Given a too long username"
            },
            "103": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         email = (\"test2\" * 50) + \"@test.com\""
            },
            "104": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         # When trying to create the user"
            },
            "105": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test2\", email, \"password\", \"/tmp/\", USER_ROLE)"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+        self._add_user(\"test2\", email, \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)"
            },
            "107": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "         # Then an error is raised"
            },
            "108": {
                "beforePatchRowNumber": 257,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "109": {
                "beforePatchRowNumber": 258,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         self.assertInBody(\"Email too long.\")"
            },
            "110": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 261,
                "PatchRowcode": "         # Given a too long user root"
            },
            "111": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "         user_root = \"/temp/\" * 50"
            },
            "112": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "         # When trying to create the user"
            },
            "113": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user(\"test2\", \"test@test,com\", \"password\", user_root, USER_ROLE)"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", user_root, USER_ROLE)"
            },
            "115": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "         # Then an error is raised"
            },
            "116": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         self.assertStatus(200)"
            },
            "117": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "         self.assertInBody(\"Root directory too long.\")"
            },
            "118": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "         Verify failure to delete our self."
            },
            "119": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "         \"\"\""
            },
            "120": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         # Create another admin user"
            },
            "121": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._add_user('admin2', '', 'password', '', ADMIN_ROLE)"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+        self._add_user('admin2', '', 'pr3j5Dwi', '', ADMIN_ROLE)"
            },
            "123": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "         self.getPage(\"/logout/\")"
            },
            "124": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._login('admin2', 'password')"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        self._login('admin2', 'pr3j5Dwi')"
            },
            "126": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 291,
                "PatchRowcode": " "
            },
            "127": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         # Try deleting admin user"
            },
            "128": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "         self._delete_user(self.USERNAME)"
            },
            "129": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "         Verify failure trying to update user with invalid path."
            },
            "130": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         \"\"\""
            },
            "131": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "         self.app.store.add_user('test1')"
            },
            "132": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._edit_user(\"test1\", \"test1@test.com\", \"password\", \"/var/invalid/\", USER_ROLE)"
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        self._edit_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", USER_ROLE)"
            },
            "134": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 334,
                "PatchRowcode": "         self.assertNotInBody(\"User added successfully.\")"
            },
            "135": {
                "beforePatchRowNumber": 335,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "         self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")"
            },
            "136": {
                "beforePatchRowNumber": 336,
                "afterPatchRowNumber": 336,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 30, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "import os",
            "from unittest.mock import ANY, MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.store import ADMIN_ROLE, MAINTAINER_ROLE, USER_ROLE",
            "",
            "",
            "class AbstractAdminTest(rdiffweb.test.WebCase):",
            "    \"\"\"Class to regroup command method to test admin page.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self._quota = {}",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        self.listener.get_disk_quota.side_effect = self._load_quota",
            "        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)",
            "        self.listener.get_disk_usage.return_value = 0",
            "        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)",
            "        self.listener.set_disk_quota.side_effect = self._store_quota",
            "        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)",
            "        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)",
            "        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)",
            "        return super().tearDown()",
            "",
            "    def _store_quota(self, userobj, value):",
            "        self._quota[userobj.username] = value",
            "",
            "    def _load_quota(self, userobj):",
            "        return self._quota.get(userobj.username, 0)",
            "",
            "    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None):",
            "        b = {}",
            "        b['action'] = 'add'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _edit_user(self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None):",
            "        b = {}",
            "        b['action'] = 'edit'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        if disk_quota is not None:",
            "            b['disk_quota'] = disk_quota",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _delete_user(self, username='test1'):",
            "        b = {'action': 'delete', 'username': username}",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "",
            "class AdminUsersAsAdminTest(AbstractAdminTest):",
            "    \"\"\"Integration test for page_admin\"\"\"",
            "",
            "    login = True",
            "",
            "    def test_add_user_with_role_admin(self):",
            "        # When trying to create a new user with role admin",
            "        self._add_user(\"admin_role\", \"admin_role@test.com\", \"password\", \"/home/\", ADMIN_ROLE)",
            "        # Then page return success",
            "        self.assertStatus(200)",
            "        # Then database is updated",
            "        userobj = self.app.store.get_user('admin_role')",
            "        self.assertEqual(ADMIN_ROLE, userobj.role)",
            "        # Then notification was raised",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_with_role_maintainer(self):",
            "        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"password\", \"/home/\", MAINTAINER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(MAINTAINER_ROLE, self.app.store.get_user('maintainer_role').role)",
            "",
            "    def test_add_user_with_role_user(self):",
            "        self._add_user(\"user_role\", \"user_role@test.com\", \"password\", \"/home/\", USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(USER_ROLE, self.app.store.get_user('user_role').role)",
            "",
            "    def test_add_user_with_invalid_role(self):",
            "        # When trying to create a new user with an invalid role (admin instead of 0)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"test1234\", \"/home/\", 'admin')",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('role: Invalid Choice: could not coerce')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "        # When trying to create a new user with an invalid role (-1)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"test2\", \"/home/\", -1)",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('role: Not a valid choice')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_edit_delete(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test2\", \"test2@test.com\", \"test1234\", \"/home/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"test2@test.com\")",
            "        self.listener.user_added.assert_called_once()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.listener.user_password_changed.reset_mock()",
            "        #  Update user",
            "        self._edit_user(\"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", ADMIN_ROLE)",
            "        self.listener.user_attr_changed.assert_called()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"chaned@test.com\")",
            "        self.assertNotInBody(\"/home/\")",
            "        self.assertInBody(\"/tmp/\")",
            "        #  Check with filters",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertInBody(\"test2\")",
            "",
            "        self._delete_user(\"test2\")",
            "        self.listener.user_deleted.assert_called()",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User account removed.\")",
            "        self.assertNotInBody(\"test2\")",
            "",
            "    def test_add_edit_delete_user_with_encoding(self):",
            "        \"\"\"",
            "        Check creation of user with non-ascii char.",
            "        \"\"\"",
            "        self._add_user(\"\u00c9ric\", \"\u00e9ric@test.com\", \"password\", \"/home/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"\u00c9ric\")",
            "        self.assertInBody(\"\u00e9ric@test.com\")",
            "        # Update user",
            "        self._edit_user(\"\u00c9ric\", \"eric.l\u00e9tourno@test.com\", \"\u00e9cureuil\", \"/tmp/\", ADMIN_ROLE)",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertInBody(\"\u00c9ric\")",
            "        self.assertInBody(\"eric.l\u00e9tourno@test.com\")",
            "        self.assertNotInBody(\"/home/\")",
            "        self.assertInBody(\"/tmp/\")",
            "        # Check with filter",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertInBody(\"\u00c9ric\")",
            "",
            "        self._delete_user(\"\u00c9ric\")",
            "        self.assertInBody(\"User account removed.\")",
            "        self.assertNotInBody(\"\u00c9ric\")",
            "",
            "    def test_add_user_with_empty_username(self):",
            "        \"\"\"",
            "        Verify failure trying to create user without username.",
            "        \"\"\"",
            "        self._add_user(\"\", \"test1@test.com\", \"test1\", \"/tmp/\", USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"username: This field is required.\")",
            "",
            "    def test_add_user_with_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to add the same user.",
            "        \"\"\"",
            "        # Given a user named `test1`",
            "        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", USER_ROLE)",
            "        # When trying to create a new user with the same name",
            "        self._add_user(\"test1\", \"test1@test.com\", \"password\", \"/tmp/\", USER_ROLE)",
            "        # Then the user list is displayed with an error message.",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User test1 already exists.\")",
            "",
            "    def test_add_user_with_invalid_root_directory(self):",
            "        \"\"\"",
            "        Verify failure to add a user with invalid root directory.",
            "        \"\"\"",
            "        try:",
            "            self._delete_user(\"test5\")",
            "        except Exception:",
            "            pass",
            "        self._add_user(\"test5\", \"test1@test.com\", \"password\", \"/var/invalid/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_add_without_email(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test2\", None, \"password\", \"/tmp/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "    def test_add_without_user_root(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test6\", None, \"password\", None, USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "        user = self.app.store.get_user('test6')",
            "        self.assertEqual('', user.user_root)",
            "",
            "    def test_add_with_username_too_long(self):",
            "        # Given a too long username",
            "        username = \"test2\" * 52",
            "        # When trying to create the user",
            "        self._add_user(username, None, \"password\", \"/tmp/\", USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Username too long.\")",
            "",
            "    def test_add_with_email_too_long(self):",
            "        # Given a too long username",
            "        email = (\"test2\" * 50) + \"@test.com\"",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", email, \"password\", \"/tmp/\", USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Email too long.\")",
            "",
            "    def test_add_with_user_root_too_long(self):",
            "        # Given a too long user root",
            "        user_root = \"/temp/\" * 50",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", \"test@test,com\", \"password\", user_root, USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Root directory too long.\")",
            "",
            "    def test_delete_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure to delete invalid username.",
            "        \"\"\"",
            "        self._delete_user(\"test3\")",
            "        self.assertInBody(\"User doesn&#39;t exists!\")",
            "",
            "    def test_delete_our_self(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        self._delete_user(self.USERNAME)",
            "        self.assertInBody(\"You cannot remove your own account!\")",
            "",
            "    def test_delete_user_admin(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        # Create another admin user",
            "        self._add_user('admin2', '', 'password', '', ADMIN_ROLE)",
            "        self.getPage(\"/logout/\")",
            "        self._login('admin2', 'password')",
            "",
            "        # Try deleting admin user",
            "        self._delete_user(self.USERNAME)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"can&#39;t delete admin user\")",
            "",
            "    def test_delete_user_method_get(self):",
            "        # Given a user",
            "        self.app.store.add_user('newuser')",
            "        # When trying to delete this user using method GET",
            "        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "        # Then user is not deleted",
            "        self.assertIsNotNone(self.app.store.get_user('newuser'))",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._edit_user(self.USERNAME, password='short')",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._edit_user(self.USERNAME, password=new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_admin_password(self):",
            "        # Given rdiffweb is configured with admin-password option",
            "        self.app.cfg.admin_password = 'hardcoded'",
            "        try:",
            "            # When trying to update admin password",
            "            self._edit_user('admin', password='new-password')",
            "            # Then the form is refused with 200 OK with an error message.",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")",
            "        finally:",
            "            self.app.cfg.admin_password = None",
            "",
            "    def test_edit_user_with_invalid_path(self):",
            "        \"\"\"",
            "        Verify failure trying to update user with invalid path.",
            "        \"\"\"",
            "        self.app.store.add_user('test1')",
            "        self._edit_user(\"test1\", \"test1@test.com\", \"password\", \"/var/invalid/\", USER_ROLE)",
            "        self.assertNotInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_list(self):",
            "        self.getPage(\"/admin/users/\")",
            "        self.assertInBody(\"Users\")",
            "        self.assertInBody(\"User management\")",
            "        self.assertInBody(\"Add user\")",
            "",
            "    def test_edit_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to update invalid user.",
            "        \"\"\"",
            "        # Given an invalid username",
            "        username = 'invalid'",
            "        # When trying to edit the user",
            "        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", USER_ROLE)",
            "        # Then the user list is displayed with an error message",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")",
            "",
            "    def test_criteria(self):",
            "        \"\"\"",
            "        Check if admin criteria is working.",
            "        \"\"\"",
            "        self.app.store.add_user('test1')",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertNotInBody(\"test1\")",
            "",
            "    def test_search(self):",
            "        \"\"\"",
            "        Check if user search is working.",
            "        \"\"\"",
            "        self.app.store.add_user('test1')",
            "        self.getPage(\"/admin/users?search=tes\")",
            "        self.assertInBody(\"test1\")",
            "        self.getPage(\"/admin/users?search=coucou\")",
            "        self.assertNotInBody(\"test1\")",
            "",
            "    def test_user_invalid_root(self):",
            "        # Delete all user's",
            "        for user in self.app.store.users():",
            "            if user.username != self.USERNAME:",
            "                user.delete()",
            "        # Change the user's root",
            "        user = self.app.store.get_user('admin')",
            "        user.user_root = \"/invalid\"",
            "        self.getPage(\"/admin/users\")",
            "        self.assertInBody(\"Root directory not accessible!\")",
            "",
            "        # Query the page by default",
            "        user = self.app.store.get_user('admin')",
            "        user.user_root = \"/tmp/\"",
            "        self.getPage(\"/admin/users\")",
            "        self.assertNotInBody(\"Root directory not accessible!\")",
            "",
            "    def test_get_quota(self):",
            "        # Mock a quota.",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 654321",
            "        # When querying the user list",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertStatus(200)",
            "        # Then get_disk_quota listenre is called",
            "        self.listener.get_disk_quota.assert_called()",
            "        # Then the quota value is displayed in human readable format",
            "        self.assertInBody(\"638.99 KiB\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota(self):",
            "        # When updating user quota.",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then listenr get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_gib(self):",
            "        # When updating user quota",
            "        self._edit_user(\"admin\", disk_quota='1GiB')",
            "        # Then listern get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_comma(self):",
            "        # When updating quota with comma value",
            "        self._edit_user(\"admin\", disk_quota='1,5 GiB')",
            "        # Then listner get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_leading_dot(self):",
            "        # When updating quota with leading dot",
            "        self._edit_user(\"admin\", disk_quota='.5 GiB')",
            "        # Then listener get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_empty(self):",
            "        # When quota is not defined",
            "        self._edit_user(\"admin\", disk_quota='')",
            "        # Then listener is not called.",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_same_value(self):",
            "        # Given an exiting quota",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 1234567890",
            "        # When setting the quota value to the same value",
            "        self._edit_user(\"admin\", disk_quota='1.15 GiB')",
            "        #  Then listener is not called",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_unsupported(self):",
            "        # Given setting quota is not supported",
            "        self.listener.set_disk_quota.side_effect = None",
            "        self.listener.set_disk_quota.return_value = None",
            "        # When updating the quota",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        self.assertInBody(\"Setting user&#39;s quota is not supported\")",
            "        self.assertStatus(200)",
            "",
            "",
            "class AdminUsersAsUserTest(AbstractAdminTest):",
            "    \"\"\"Integration test for page_admin\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # Add test user",
            "        self.app.store.add_user('test', 'test123')",
            "        self._login('test', 'test123')",
            "",
            "    def test_add_user(self):",
            "        \"\"\"",
            "        Check if adding user is forbidden.",
            "        \"\"\"",
            "        self._add_user(\"test2\", \"test2@test.com\", \"test2\", \"/tmp/\", USER_ROLE)",
            "        self.assertStatus(403)",
            "",
            "    def test_delete_user(self):",
            "        \"\"\"",
            "        Check if deleting user is forbidden.",
            "        \"\"\"",
            "        self._delete_user(\"test\")",
            "        self.assertStatus(403)",
            "",
            "    def test_edit_user(self):",
            "        \"\"\"",
            "        Check if editing user is forbidden.",
            "        \"\"\"",
            "        self._edit_user(\"test\", \"test1@test.com\", \"test\", \"/var/invalid/\", USER_ROLE)",
            "        self.assertStatus(403)",
            "",
            "    def test_users(self):",
            "        \"\"\"",
            "        Check if listing user is forbidden.",
            "        \"\"\"",
            "        self.getPage(\"/admin/users\")",
            "        self.assertStatus(403)",
            "",
            "    def test_repos(self):",
            "        \"\"\"",
            "        Check if listing user is forbidden.",
            "        \"\"\"",
            "        self.getPage(\"/admin/repos\")",
            "        self.assertStatus(403)",
            "",
            "",
            "class AdminWithNoLogsTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_logs(self):",
            "        self.getPage(\"/admin/logs/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"No log files\")",
            "",
            "",
            "class AdminWithLogsTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "    default_config = {'logfile': '/tmp/rdiffweb.log', 'logaccessfile': '/tmp/rdiffweb-access.log'}",
            "",
            "    def test_logs(self):",
            "        with open('/tmp/rdiffweb.log', 'w') as f:",
            "            f.write(\"content of log file\")",
            "        with open('/tmp/rdiffweb-access.log', 'w') as f:",
            "            f.write(\"content of log file\")",
            "        try:",
            "            self.getPage(\"/admin/logs/\")",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"rdiffweb.log\")",
            "            self.assertInBody(\"content of log file\")",
            "            self.assertInBody(\"rdiffweb-access.log\")",
            "            self.assertNotInBody(\"Error getting file content\")",
            "        finally:",
            "            os.remove('/tmp/rdiffweb.log')",
            "            os.remove('/tmp/rdiffweb-access.log')",
            "",
            "",
            "class AdminWithLogMissingTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "    default_config = {'logfile': './rdiffweb.log', 'logaccessfile': './rdiffweb-access.log'}",
            "",
            "    def test_logs_with_no_file(self):",
            "        self.getPage(\"/admin/logs/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"rdiffweb.log\")",
            "        self.assertInBody(\"Error getting file content\")",
            "",
            "    def test_logs_with_invalid_file(self):",
            "        self.getPage(\"/admin/logs/invalid\")",
            "        self.assertStatus(404)",
            "",
            "",
            "class AdminReposTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_repos(self):",
            "        self.getPage(\"/admin/repos\")",
            "        self.assertStatus(200)",
            "",
            "    def test_repos_with_search(self):",
            "        # Search something that exists",
            "        self.getPage(\"/admin/repos?search=test\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.REPO)",
            "",
            "        # Search something that doesn't exists",
            "        self.getPage(\"/admin/repos?search=coucou\")",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(self.REPO)",
            "        self.assertInBody(\"No repository found\")",
            "",
            "    def test_repos_with_criteria(self):",
            "        # Search something that exists",
            "        self.getPage(\"/admin/repos?criteria=ok\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.REPO)",
            "",
            "        # Search something that exists",
            "        self.getPage(\"/admin/repos?criteria=failed\")",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(self.REPO)",
            "        self.assertInBody(\"No repository found\")",
            "",
            "",
            "class AdminSysinfoTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_sysinfo(self):",
            "        self.getPage(\"/admin/sysinfo\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Operating System Info\")",
            "        self.assertInBody(\"Python Info\")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 30, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "import os",
            "from unittest.mock import ANY, MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.store import ADMIN_ROLE, MAINTAINER_ROLE, USER_ROLE",
            "",
            "",
            "class AbstractAdminTest(rdiffweb.test.WebCase):",
            "    \"\"\"Class to regroup command method to test admin page.\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        self._quota = {}",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_added', self.listener.user_added, priority=50)",
            "        cherrypy.engine.subscribe('user_attr_changed', self.listener.user_attr_changed, priority=50)",
            "        cherrypy.engine.subscribe('user_deleted', self.listener.user_deleted, priority=50)",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        self.listener.get_disk_quota.side_effect = self._load_quota",
            "        cherrypy.engine.subscribe('get_disk_quota', self.listener.get_disk_quota, priority=40)",
            "        self.listener.get_disk_usage.return_value = 0",
            "        cherrypy.engine.subscribe('get_disk_usage', self.listener.get_disk_usage, priority=40)",
            "        self.listener.set_disk_quota.side_effect = self._store_quota",
            "        cherrypy.engine.subscribe('set_disk_quota', self.listener.set_disk_quota, priority=40)",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_added', self.listener.user_added)",
            "        cherrypy.engine.unsubscribe('user_attr_changed', self.listener.user_attr_changed)",
            "        cherrypy.engine.unsubscribe('user_deleted', self.listener.user_deleted)",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        cherrypy.engine.unsubscribe('get_disk_quota', self.listener.get_disk_quota)",
            "        cherrypy.engine.unsubscribe('get_disk_usage', self.listener.get_disk_usage)",
            "        cherrypy.engine.unsubscribe('set_disk_quota', self.listener.set_disk_quota)",
            "        return super().tearDown()",
            "",
            "    def _store_quota(self, userobj, value):",
            "        self._quota[userobj.username] = value",
            "",
            "    def _load_quota(self, userobj):",
            "        return self._quota.get(userobj.username, 0)",
            "",
            "    def _add_user(self, username=None, email=None, password=None, user_root=None, role=None):",
            "        b = {}",
            "        b['action'] = 'add'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _edit_user(self, username=None, email=None, password=None, user_root=None, role=None, disk_quota=None):",
            "        b = {}",
            "        b['action'] = 'edit'",
            "        if username is not None:",
            "            b['username'] = username",
            "        if email is not None:",
            "            b['email'] = email",
            "        if password is not None:",
            "            b['password'] = password",
            "        if user_root is not None:",
            "            b['user_root'] = user_root",
            "        if role is not None:",
            "            b['role'] = str(role)",
            "        if disk_quota is not None:",
            "            b['disk_quota'] = disk_quota",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "    def _delete_user(self, username='test1'):",
            "        b = {'action': 'delete', 'username': username}",
            "        self.getPage(\"/admin/users/\", method='POST', body=b)",
            "",
            "",
            "class AdminUsersAsAdminTest(AbstractAdminTest):",
            "    \"\"\"Integration test for page_admin\"\"\"",
            "",
            "    login = True",
            "",
            "    def test_add_user_with_role_admin(self):",
            "        # When trying to create a new user with role admin",
            "        self._add_user(\"admin_role\", \"admin_role@test.com\", \"pr3j5Dwi\", \"/home/\", ADMIN_ROLE)",
            "        # Then page return success",
            "        self.assertStatus(200)",
            "        # Then database is updated",
            "        userobj = self.app.store.get_user('admin_role')",
            "        self.assertEqual(ADMIN_ROLE, userobj.role)",
            "        # Then notification was raised",
            "        self.listener.user_added.assert_called_once_with(userobj)",
            "",
            "    def test_add_user_with_role_maintainer(self):",
            "        self._add_user(\"maintainer_role\", \"maintainer_role@test.com\", \"pr3j5Dwi\", \"/home/\", MAINTAINER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(MAINTAINER_ROLE, self.app.store.get_user('maintainer_role').role)",
            "",
            "    def test_add_user_with_role_user(self):",
            "        self._add_user(\"user_role\", \"user_role@test.com\", \"pr3j5Dwi\", \"/home/\", USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertEqual(USER_ROLE, self.app.store.get_user('user_role').role)",
            "",
            "    def test_add_user_with_invalid_role(self):",
            "        # When trying to create a new user with an invalid role (admin instead of 0)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", 'admin')",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('role: Invalid Choice: could not coerce')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "        # When trying to create a new user with an invalid role (-1)",
            "        self._add_user(\"invalid\", \"invalid@test.com\", \"pr3j5Dwi\", \"/home/\", -1)",
            "        # Then an error message is displayed to the user",
            "        self.assertStatus(200)",
            "        self.assertInBody('role: Not a valid choice')",
            "        # Then listener are not called",
            "        self.listener.user_added.assert_not_called()",
            "",
            "    def test_add_edit_delete(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test2\", \"test2@test.com\", \"pr3j5Dwi\", \"/home/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"test2@test.com\")",
            "        self.listener.user_added.assert_called_once()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.listener.user_password_changed.reset_mock()",
            "        #  Update user",
            "        self._edit_user(\"test2\", \"chaned@test.com\", \"new-password\", \"/tmp/\", ADMIN_ROLE)",
            "        self.listener.user_attr_changed.assert_called()",
            "        self.listener.user_password_changed.assert_called_once()",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertInBody(\"test2\")",
            "        self.assertInBody(\"chaned@test.com\")",
            "        self.assertNotInBody(\"/home/\")",
            "        self.assertInBody(\"/tmp/\")",
            "        #  Check with filters",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertInBody(\"test2\")",
            "",
            "        self._delete_user(\"test2\")",
            "        self.listener.user_deleted.assert_called()",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User account removed.\")",
            "        self.assertNotInBody(\"test2\")",
            "",
            "    def test_add_edit_delete_user_with_encoding(self):",
            "        \"\"\"",
            "        Check creation of user with non-ascii char.",
            "        \"\"\"",
            "        self._add_user(\"\u00c9ric\", \"\u00e9ric@test.com\", \"pr3j5Dwi\", \"/home/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"\u00c9ric\")",
            "        self.assertInBody(\"\u00e9ric@test.com\")",
            "        # Update user",
            "        self._edit_user(\"\u00c9ric\", \"eric.l\u00e9tourno@test.com\", \"\u00e9cureuil\", \"/tmp/\", ADMIN_ROLE)",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertInBody(\"\u00c9ric\")",
            "        self.assertInBody(\"eric.l\u00e9tourno@test.com\")",
            "        self.assertNotInBody(\"/home/\")",
            "        self.assertInBody(\"/tmp/\")",
            "        # Check with filter",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertInBody(\"\u00c9ric\")",
            "",
            "        self._delete_user(\"\u00c9ric\")",
            "        self.assertInBody(\"User account removed.\")",
            "        self.assertNotInBody(\"\u00c9ric\")",
            "",
            "    def test_add_user_with_empty_username(self):",
            "        \"\"\"",
            "        Verify failure trying to create user without username.",
            "        \"\"\"",
            "        self._add_user(\"\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"username: This field is required.\")",
            "",
            "    def test_add_user_with_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to add the same user.",
            "        \"\"\"",
            "        # Given a user named `test1`",
            "        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)",
            "        # When trying to create a new user with the same name",
            "        self._add_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)",
            "        # Then the user list is displayed with an error message.",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"User test1 already exists.\")",
            "",
            "    def test_add_user_with_invalid_root_directory(self):",
            "        \"\"\"",
            "        Verify failure to add a user with invalid root directory.",
            "        \"\"\"",
            "        try:",
            "            self._delete_user(\"test5\")",
            "        except Exception:",
            "            pass",
            "        self._add_user(\"test5\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_add_without_email(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test2\", None, \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "    def test_add_without_user_root(self):",
            "        #  Add user to be listed",
            "        self._add_user(\"test6\", None, \"pr3j5Dwi\", None, USER_ROLE)",
            "        self.assertInBody(\"User added successfully.\")",
            "",
            "        user = self.app.store.get_user('test6')",
            "        self.assertEqual('', user.user_root)",
            "",
            "    def test_add_with_username_too_long(self):",
            "        # Given a too long username",
            "        username = \"test2\" * 52",
            "        # When trying to create the user",
            "        self._add_user(username, None, \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Username too long.\")",
            "",
            "    def test_add_with_email_too_long(self):",
            "        # Given a too long username",
            "        email = (\"test2\" * 50) + \"@test.com\"",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", email, \"pr3j5Dwi\", \"/tmp/\", USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Email too long.\")",
            "",
            "    def test_add_with_user_root_too_long(self):",
            "        # Given a too long user root",
            "        user_root = \"/temp/\" * 50",
            "        # When trying to create the user",
            "        self._add_user(\"test2\", \"test@test,com\", \"pr3j5Dwi\", user_root, USER_ROLE)",
            "        # Then an error is raised",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Root directory too long.\")",
            "",
            "    def test_delete_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure to delete invalid username.",
            "        \"\"\"",
            "        self._delete_user(\"test3\")",
            "        self.assertInBody(\"User doesn&#39;t exists!\")",
            "",
            "    def test_delete_our_self(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        self._delete_user(self.USERNAME)",
            "        self.assertInBody(\"You cannot remove your own account!\")",
            "",
            "    def test_delete_user_admin(self):",
            "        \"\"\"",
            "        Verify failure to delete our self.",
            "        \"\"\"",
            "        # Create another admin user",
            "        self._add_user('admin2', '', 'pr3j5Dwi', '', ADMIN_ROLE)",
            "        self.getPage(\"/logout/\")",
            "        self._login('admin2', 'pr3j5Dwi')",
            "",
            "        # Try deleting admin user",
            "        self._delete_user(self.USERNAME)",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"can&#39;t delete admin user\")",
            "",
            "    def test_delete_user_method_get(self):",
            "        # Given a user",
            "        self.app.store.add_user('newuser')",
            "        # When trying to delete this user using method GET",
            "        self.getPage(\"/admin/users/?action=delete&username=newuser\", method='GET')",
            "        # Then page return without error",
            "        self.assertStatus(200)",
            "        # Then user is not deleted",
            "        self.assertIsNotNone(self.app.store.get_user('newuser'))",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._edit_user(self.USERNAME, password='short')",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._edit_user(self.USERNAME, password=new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_admin_password(self):",
            "        # Given rdiffweb is configured with admin-password option",
            "        self.app.cfg.admin_password = 'hardcoded'",
            "        try:",
            "            # When trying to update admin password",
            "            self._edit_user('admin', password='new-password')",
            "            # Then the form is refused with 200 OK with an error message.",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"can&#39;t update admin-password defined in configuration file\")",
            "        finally:",
            "            self.app.cfg.admin_password = None",
            "",
            "    def test_edit_user_with_invalid_path(self):",
            "        \"\"\"",
            "        Verify failure trying to update user with invalid path.",
            "        \"\"\"",
            "        self.app.store.add_user('test1')",
            "        self._edit_user(\"test1\", \"test1@test.com\", \"pr3j5Dwi\", \"/var/invalid/\", USER_ROLE)",
            "        self.assertNotInBody(\"User added successfully.\")",
            "        self.assertInBody(\"User&#39;s root directory /var/invalid/ is not accessible!\")",
            "",
            "    def test_list(self):",
            "        self.getPage(\"/admin/users/\")",
            "        self.assertInBody(\"Users\")",
            "        self.assertInBody(\"User management\")",
            "        self.assertInBody(\"Add user\")",
            "",
            "    def test_edit_user_with_not_existing_username(self):",
            "        \"\"\"",
            "        Verify failure trying to update invalid user.",
            "        \"\"\"",
            "        # Given an invalid username",
            "        username = 'invalid'",
            "        # When trying to edit the user",
            "        self._edit_user(username, \"test1@test.com\", \"test\", \"/var/invalid/\", USER_ROLE)",
            "        # Then the user list is displayed with an error message",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Cannot edit user `invalid`: user doesn&#39;t exists\")",
            "",
            "    def test_criteria(self):",
            "        \"\"\"",
            "        Check if admin criteria is working.",
            "        \"\"\"",
            "        self.app.store.add_user('test1')",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertNotInBody(\"test1\")",
            "",
            "    def test_search(self):",
            "        \"\"\"",
            "        Check if user search is working.",
            "        \"\"\"",
            "        self.app.store.add_user('test1')",
            "        self.getPage(\"/admin/users?search=tes\")",
            "        self.assertInBody(\"test1\")",
            "        self.getPage(\"/admin/users?search=coucou\")",
            "        self.assertNotInBody(\"test1\")",
            "",
            "    def test_user_invalid_root(self):",
            "        # Delete all user's",
            "        for user in self.app.store.users():",
            "            if user.username != self.USERNAME:",
            "                user.delete()",
            "        # Change the user's root",
            "        user = self.app.store.get_user('admin')",
            "        user.user_root = \"/invalid\"",
            "        self.getPage(\"/admin/users\")",
            "        self.assertInBody(\"Root directory not accessible!\")",
            "",
            "        # Query the page by default",
            "        user = self.app.store.get_user('admin')",
            "        user.user_root = \"/tmp/\"",
            "        self.getPage(\"/admin/users\")",
            "        self.assertNotInBody(\"Root directory not accessible!\")",
            "",
            "    def test_get_quota(self):",
            "        # Mock a quota.",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 654321",
            "        # When querying the user list",
            "        self.getPage(\"/admin/users/?criteria=admins\")",
            "        self.assertStatus(200)",
            "        # Then get_disk_quota listenre is called",
            "        self.listener.get_disk_quota.assert_called()",
            "        # Then the quota value is displayed in human readable format",
            "        self.assertInBody(\"638.99 KiB\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota(self):",
            "        # When updating user quota.",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then listenr get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_gib(self):",
            "        # When updating user quota",
            "        self._edit_user(\"admin\", disk_quota='1GiB')",
            "        # Then listern get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1073741824)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_comma(self):",
            "        # When updating quota with comma value",
            "        self._edit_user(\"admin\", disk_quota='1,5 GiB')",
            "        # Then listner get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 1610612736)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_as_with_leading_dot(self):",
            "        # When updating quota with leading dot",
            "        self._edit_user(\"admin\", disk_quota='.5 GiB')",
            "        # Then listener get called",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 536870912)",
            "        # Then a success message is displayed",
            "        self.assertInBody(\"User information modified successfully.\")",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_empty(self):",
            "        # When quota is not defined",
            "        self._edit_user(\"admin\", disk_quota='')",
            "        # Then listener is not called.",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_same_value(self):",
            "        # Given an exiting quota",
            "        self.listener.get_disk_quota.side_effect = None",
            "        self.listener.get_disk_quota.return_value = 1234567890",
            "        # When setting the quota value to the same value",
            "        self._edit_user(\"admin\", disk_quota='1.15 GiB')",
            "        #  Then listener is not called",
            "        self.listener.set_disk_quota.assert_not_called()",
            "        # Then message is not displayed",
            "        self.assertStatus(200)",
            "",
            "    def test_set_quota_unsupported(self):",
            "        # Given setting quota is not supported",
            "        self.listener.set_disk_quota.side_effect = None",
            "        self.listener.set_disk_quota.return_value = None",
            "        # When updating the quota",
            "        self._edit_user(\"admin\", disk_quota='8765432')",
            "        # Then",
            "        self.listener.set_disk_quota.assert_called_once_with(ANY, 8765432)",
            "        self.assertInBody(\"Setting user&#39;s quota is not supported\")",
            "        self.assertStatus(200)",
            "",
            "",
            "class AdminUsersAsUserTest(AbstractAdminTest):",
            "    \"\"\"Integration test for page_admin\"\"\"",
            "",
            "    def setUp(self):",
            "        super().setUp()",
            "        # Add test user",
            "        self.app.store.add_user('test', 'test123')",
            "        self._login('test', 'test123')",
            "",
            "    def test_add_user(self):",
            "        \"\"\"",
            "        Check if adding user is forbidden.",
            "        \"\"\"",
            "        self._add_user(\"test2\", \"test2@test.com\", \"test2\", \"/tmp/\", USER_ROLE)",
            "        self.assertStatus(403)",
            "",
            "    def test_delete_user(self):",
            "        \"\"\"",
            "        Check if deleting user is forbidden.",
            "        \"\"\"",
            "        self._delete_user(\"test\")",
            "        self.assertStatus(403)",
            "",
            "    def test_edit_user(self):",
            "        \"\"\"",
            "        Check if editing user is forbidden.",
            "        \"\"\"",
            "        self._edit_user(\"test\", \"test1@test.com\", \"test\", \"/var/invalid/\", USER_ROLE)",
            "        self.assertStatus(403)",
            "",
            "    def test_users(self):",
            "        \"\"\"",
            "        Check if listing user is forbidden.",
            "        \"\"\"",
            "        self.getPage(\"/admin/users\")",
            "        self.assertStatus(403)",
            "",
            "    def test_repos(self):",
            "        \"\"\"",
            "        Check if listing user is forbidden.",
            "        \"\"\"",
            "        self.getPage(\"/admin/repos\")",
            "        self.assertStatus(403)",
            "",
            "",
            "class AdminWithNoLogsTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_logs(self):",
            "        self.getPage(\"/admin/logs/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"No log files\")",
            "",
            "",
            "class AdminWithLogsTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "    default_config = {'logfile': '/tmp/rdiffweb.log', 'logaccessfile': '/tmp/rdiffweb-access.log'}",
            "",
            "    def test_logs(self):",
            "        with open('/tmp/rdiffweb.log', 'w') as f:",
            "            f.write(\"content of log file\")",
            "        with open('/tmp/rdiffweb-access.log', 'w') as f:",
            "            f.write(\"content of log file\")",
            "        try:",
            "            self.getPage(\"/admin/logs/\")",
            "            self.assertStatus(200)",
            "            self.assertInBody(\"rdiffweb.log\")",
            "            self.assertInBody(\"content of log file\")",
            "            self.assertInBody(\"rdiffweb-access.log\")",
            "            self.assertNotInBody(\"Error getting file content\")",
            "        finally:",
            "            os.remove('/tmp/rdiffweb.log')",
            "            os.remove('/tmp/rdiffweb-access.log')",
            "",
            "",
            "class AdminWithLogMissingTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "    default_config = {'logfile': './rdiffweb.log', 'logaccessfile': './rdiffweb-access.log'}",
            "",
            "    def test_logs_with_no_file(self):",
            "        self.getPage(\"/admin/logs/\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"rdiffweb.log\")",
            "        self.assertInBody(\"Error getting file content\")",
            "",
            "    def test_logs_with_invalid_file(self):",
            "        self.getPage(\"/admin/logs/invalid\")",
            "        self.assertStatus(404)",
            "",
            "",
            "class AdminReposTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_repos(self):",
            "        self.getPage(\"/admin/repos\")",
            "        self.assertStatus(200)",
            "",
            "    def test_repos_with_search(self):",
            "        # Search something that exists",
            "        self.getPage(\"/admin/repos?search=test\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.REPO)",
            "",
            "        # Search something that doesn't exists",
            "        self.getPage(\"/admin/repos?search=coucou\")",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(self.REPO)",
            "        self.assertInBody(\"No repository found\")",
            "",
            "    def test_repos_with_criteria(self):",
            "        # Search something that exists",
            "        self.getPage(\"/admin/repos?criteria=ok\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(self.REPO)",
            "",
            "        # Search something that exists",
            "        self.getPage(\"/admin/repos?criteria=failed\")",
            "        self.assertStatus(200)",
            "        self.assertNotInBody(self.REPO)",
            "        self.assertInBody(\"No repository found\")",
            "",
            "",
            "class AdminSysinfoTest(rdiffweb.test.WebCase):",
            "",
            "    login = True",
            "",
            "    def test_sysinfo(self):",
            "        self.getPage(\"/admin/sysinfo\")",
            "        self.assertStatus(200)",
            "        self.assertInBody(\"Operating System Info\")",
            "        self.assertInBody(\"Python Info\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "110": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_role_admin"
            ],
            "120": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_role_maintainer"
            ],
            "125": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_role_user"
            ],
            "131": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_invalid_role"
            ],
            "139": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_invalid_role"
            ],
            "148": [
                "AdminUsersAsAdminTest",
                "test_add_edit_delete"
            ],
            "178": [
                "AdminUsersAsAdminTest",
                "test_add_edit_delete_user_with_encoding"
            ],
            "201": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_empty_username"
            ],
            "210": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_existing_username"
            ],
            "212": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_existing_username"
            ],
            "225": [
                "AdminUsersAsAdminTest",
                "test_add_user_with_invalid_root_directory"
            ],
            "231": [
                "AdminUsersAsAdminTest",
                "test_add_without_email"
            ],
            "236": [
                "AdminUsersAsAdminTest",
                "test_add_without_user_root"
            ],
            "246": [
                "AdminUsersAsAdminTest",
                "test_add_with_username_too_long"
            ],
            "255": [
                "AdminUsersAsAdminTest",
                "test_add_with_email_too_long"
            ],
            "264": [
                "AdminUsersAsAdminTest",
                "test_add_with_user_root_too_long"
            ],
            "288": [
                "AdminUsersAsAdminTest",
                "test_delete_user_admin"
            ],
            "290": [
                "AdminUsersAsAdminTest",
                "test_delete_user_admin"
            ],
            "333": [
                "AdminUsersAsAdminTest",
                "test_edit_user_with_invalid_path"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/controller/tests/test_page_prefs.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     def test_change_password(self):"
            },
            "2": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         # When udating user's password"
            },
            "3": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._set_password(self.PASSWORD, \"newpassword\", \"newpassword\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")"
            },
            "5": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         self.assertInBody(\"Password updated successfully.\")"
            },
            "6": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         # Then a notification is raised"
            },
            "7": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         self.listener.user_password_changed.assert_called_once()"
            },
            "8": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Change it back"
            },
            "9": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._set_password(\"newpassword\", self.PASSWORD, self.PASSWORD)"
            },
            "10": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertInBody(\"Password updated successfully.\")"
            },
            "11": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     def test_change_password_with_wrong_confirmation(self):"
            },
            "13": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "         self._set_password(self.PASSWORD, \"t\", \"a\")"
            },
            "14": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         self.assertInBody(\"The new password and its confirmation do not match.\")"
            },
            "15": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 101,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     def test_change_password_with_wrong_password(self):"
            },
            "17": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._set_password(\"oups\", \"newpassword\", \"newpassword\")"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        self._set_password(\"oups\", \"pr3j5Dwi\", \"pr3j5Dwi\")"
            },
            "19": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "         self.assertInBody(\"Wrong password\")"
            },
            "20": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 105,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     def test_change_password_with_too_short(self):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.store import _REPOS",
            "",
            "",
            "class PrefsTest(rdiffweb.test.WebCase):",
            "",
            "    PREFS = \"/prefs/\"",
            "",
            "    login = True",
            "",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def _set_password(",
            "        self,",
            "        current,",
            "        new_password,",
            "        confirm,",
            "    ):",
            "        b = {",
            "            'action': 'set_password',",
            "            'current': current,",
            "            'new': new_password,",
            "            'confirm': confirm,",
            "        }",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def _set_profile_info(self, email):",
            "        b = {",
            "            'action': 'set_profile_info',",
            "            'email': email,",
            "        }",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def test_change_email(self):",
            "        self._set_profile_info(\"test@test.com\")",
            "        self.assertInBody(\"Profile updated successfully.\")",
            "",
            "    def test_change_email_with_invalid_email(self):",
            "        self._set_profile_info(\"@test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test@te_st.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test@test.com, test2@test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "    def test_change_email_with_too_long(self):",
            "        self._set_profile_info((\"test1\" * 50) + \"@test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "    def test_change_password(self):",
            "        # When udating user's password",
            "        self._set_password(self.PASSWORD, \"newpassword\", \"newpassword\")",
            "        self.assertInBody(\"Password updated successfully.\")",
            "        # Then a notification is raised",
            "        self.listener.user_password_changed.assert_called_once()",
            "        # Change it back",
            "        self._set_password(\"newpassword\", self.PASSWORD, self.PASSWORD)",
            "        self.assertInBody(\"Password updated successfully.\")",
            "",
            "    def test_change_password_with_wrong_confirmation(self):",
            "        self._set_password(self.PASSWORD, \"t\", \"a\")",
            "        self.assertInBody(\"The new password and its confirmation do not match.\")",
            "",
            "    def test_change_password_with_wrong_password(self):",
            "        self._set_password(\"oups\", \"newpassword\", \"newpassword\")",
            "        self.assertInBody(\"Wrong password\")",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._set_password(self.PASSWORD, \"short\", \"short\")",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._set_password(self.PASSWORD, new_password, new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_invalid_pref(self):",
            "        \"\"\"",
            "        Check if invalid prefs url is 404 Not Found.",
            "        \"\"\"",
            "        self.getPage(\"/prefs/invalid/\")",
            "        self.assertStatus(404)",
            "",
            "    def test_update_repos(self):",
            "        # Given a user with invalid repositories",
            "        userobj = self.app.store.get_user(self.USERNAME)",
            "        with self.app.store.engine.connect() as conn:",
            "            conn.execute(_REPOS.insert().values(userid=userobj._userid, repopath='invalid'))",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list",
            "        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})",
            "        self.assertStatus(200)",
            "        # Then a success message is displayed",
            "        self.assertInBody('Repositories successfully updated')",
            "        # Then the list is free of inexisting repos.",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_update_notification(self):",
            "        self.getPage(\"/prefs/notification/\", method='POST', body={'action': 'set_notification_info', 'testcases': '7'})",
            "        self.assertStatus(200)",
            "        # Check database update",
            "        repo_obj = self.app.store.get_user(self.USERNAME).get_repo(self.REPO)",
            "        self.assertEqual(7, repo_obj.maxage)",
            "",
            "    def test_update_notification_method_get(self):",
            "        # Given a user with repositories",
            "        # When trying to update notification with GET method",
            "        self.getPage(\"/prefs/notification?action=set_notification_info&testcases=7\")",
            "        # Then page return with success",
            "        self.assertStatus(200)",
            "        # Then page doesn't update values",
            "        self.assertNotInBody('Notification settings updated successfully.')",
            "        # Then database is not updated",
            "        repo_obj = self.app.store.get_user(self.USERNAME).get_repo(self.REPO)",
            "        self.assertEqual(0, repo_obj.maxage)",
            "",
            "    def test_get_page(self):",
            "        self.getPage(\"/prefs/\", method='GET')",
            "        self.assertInBody(\"SSH\")",
            "",
            "",
            "class PrefsWithSSHKeyDisabled(rdiffweb.test.WebCase):",
            "",
            "    default_config = {",
            "        \"disable_ssh_keys\": \"true\",",
            "    }",
            "",
            "    def test_get_page(self):",
            "        self.getPage(\"/prefs/\", method='GET')",
            "        self.assertNotInBody(\"SSH\")"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "\"\"\"",
            "Created on Dec 26, 2015",
            "",
            "@author: Patrik Dufresne",
            "\"\"\"",
            "",
            "from unittest.mock import MagicMock",
            "",
            "import cherrypy",
            "",
            "import rdiffweb.test",
            "from rdiffweb.core.store import _REPOS",
            "",
            "",
            "class PrefsTest(rdiffweb.test.WebCase):",
            "",
            "    PREFS = \"/prefs/\"",
            "",
            "    login = True",
            "",
            "    def setUp(self):",
            "        self.listener = MagicMock()",
            "        cherrypy.engine.subscribe('user_password_changed', self.listener.user_password_changed, priority=50)",
            "        return super().setUp()",
            "",
            "    def tearDown(self):",
            "        cherrypy.engine.unsubscribe('user_password_changed', self.listener.user_password_changed)",
            "        return super().tearDown()",
            "",
            "    def _set_password(",
            "        self,",
            "        current,",
            "        new_password,",
            "        confirm,",
            "    ):",
            "        b = {",
            "            'action': 'set_password',",
            "            'current': current,",
            "            'new': new_password,",
            "            'confirm': confirm,",
            "        }",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def _set_profile_info(self, email):",
            "        b = {",
            "            'action': 'set_profile_info',",
            "            'email': email,",
            "        }",
            "        return self.getPage(self.PREFS, method='POST', body=b)",
            "",
            "    def test_change_email(self):",
            "        self._set_profile_info(\"test@test.com\")",
            "        self.assertInBody(\"Profile updated successfully.\")",
            "",
            "    def test_change_email_with_invalid_email(self):",
            "        self._set_profile_info(\"@test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test@te_st.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "        self._set_profile_info(\"test@test.com, test2@test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "    def test_change_email_with_too_long(self):",
            "        self._set_profile_info((\"test1\" * 50) + \"@test.com\")",
            "        self.assertInBody(\"Invalid email\")",
            "",
            "    def test_change_password(self):",
            "        # When udating user's password",
            "        self._set_password(self.PASSWORD, \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertInBody(\"Password updated successfully.\")",
            "        # Then a notification is raised",
            "        self.listener.user_password_changed.assert_called_once()",
            "",
            "    def test_change_password_with_wrong_confirmation(self):",
            "        self._set_password(self.PASSWORD, \"t\", \"a\")",
            "        self.assertInBody(\"The new password and its confirmation do not match.\")",
            "",
            "    def test_change_password_with_wrong_password(self):",
            "        self._set_password(\"oups\", \"pr3j5Dwi\", \"pr3j5Dwi\")",
            "        self.assertInBody(\"Wrong password\")",
            "",
            "    def test_change_password_with_too_short(self):",
            "        self._set_password(self.PASSWORD, \"short\", \"short\")",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_change_password_with_too_long(self):",
            "        new_password = 'a' * 129",
            "        self._set_password(self.PASSWORD, new_password, new_password)",
            "        self.assertInBody(\"Password must have between 8 and 128 characters.\")",
            "",
            "    def test_invalid_pref(self):",
            "        \"\"\"",
            "        Check if invalid prefs url is 404 Not Found.",
            "        \"\"\"",
            "        self.getPage(\"/prefs/invalid/\")",
            "        self.assertStatus(404)",
            "",
            "    def test_update_repos(self):",
            "        # Given a user with invalid repositories",
            "        userobj = self.app.store.get_user(self.USERNAME)",
            "        with self.app.store.engine.connect() as conn:",
            "            conn.execute(_REPOS.insert().values(userid=userobj._userid, repopath='invalid'))",
            "        self.assertEqual(['broker-repo', 'invalid', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "        # When updating the repository list",
            "        self.getPage(self.PREFS, method='POST', body={'action': 'update_repos'})",
            "        self.assertStatus(200)",
            "        # Then a success message is displayed",
            "        self.assertInBody('Repositories successfully updated')",
            "        # Then the list is free of inexisting repos.",
            "        self.assertEqual(['broker-repo', 'testcases'], sorted([r.name for r in userobj.repo_objs]))",
            "",
            "    def test_update_notification(self):",
            "        self.getPage(\"/prefs/notification/\", method='POST', body={'action': 'set_notification_info', 'testcases': '7'})",
            "        self.assertStatus(200)",
            "        # Check database update",
            "        repo_obj = self.app.store.get_user(self.USERNAME).get_repo(self.REPO)",
            "        self.assertEqual(7, repo_obj.maxage)",
            "",
            "    def test_update_notification_method_get(self):",
            "        # Given a user with repositories",
            "        # When trying to update notification with GET method",
            "        self.getPage(\"/prefs/notification?action=set_notification_info&testcases=7\")",
            "        # Then page return with success",
            "        self.assertStatus(200)",
            "        # Then page doesn't update values",
            "        self.assertNotInBody('Notification settings updated successfully.')",
            "        # Then database is not updated",
            "        repo_obj = self.app.store.get_user(self.USERNAME).get_repo(self.REPO)",
            "        self.assertEqual(0, repo_obj.maxage)",
            "",
            "    def test_get_page(self):",
            "        self.getPage(\"/prefs/\", method='GET')",
            "        self.assertInBody(\"SSH\")",
            "",
            "",
            "class PrefsWithSSHKeyDisabled(rdiffweb.test.WebCase):",
            "",
            "    default_config = {",
            "        \"disable_ssh_keys\": \"true\",",
            "    }",
            "",
            "    def test_get_page(self):",
            "        self.getPage(\"/prefs/\", method='GET')",
            "        self.assertNotInBody(\"SSH\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "93": [
                "PrefsTest",
                "test_change_password"
            ],
            "97": [
                "PrefsTest",
                "test_change_password"
            ],
            "98": [
                "PrefsTest",
                "test_change_password"
            ],
            "99": [
                "PrefsTest",
                "test_change_password"
            ],
            "106": [
                "PrefsTest",
                "test_change_password_with_wrong_password"
            ]
        },
        "addLocation": []
    },
    "rdiffweb/core/config.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         default=128,"
            },
            "1": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": "     )"
            },
            "2": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 436,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+    parser.add("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 438,
                "PatchRowcode": "+        '--password-score',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 439,
                "PatchRowcode": "+        type=lambda x: max(1, min(int(x), 4)),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 440,
                "PatchRowcode": "+        help=\"Minimum zxcvbn's score for password. Value from 1 to 4. Default value 2. Read more about it here: https://github.com/dropbox/zxcvbn\","
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 441,
                "PatchRowcode": "+        default=2,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 442,
                "PatchRowcode": "+    )"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 443,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "     parser.add_argument('--version', action='version', version='%(prog)s ' + VERSION)"
            },
            "11": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 445,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 446,
                "PatchRowcode": "     # Here we append a list of arguments for each locale."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import argparse",
            "import logging",
            "import re",
            "import sys",
            "from collections import OrderedDict",
            "",
            "import cherrypy",
            "import configargparse",
            "import pkg_resources",
            "from cherrypy import Application",
            "",
            "# Define the logger",
            "logger = logging.getLogger(__name__)",
            "",
            "# Get rdiffweb version.",
            "try:",
            "    VERSION = pkg_resources.get_distribution(\"rdiffweb\").version",
            "except pkg_resources.DistributionNotFound:",
            "    VERSION = \"DEV\"",
            "",
            "",
            "def get_parser():",
            "    # Get global config argument parser",
            "    parser = configargparse.ArgumentParser(",
            "        prog='rdiffweb',",
            "        description='Web interface to browse and restore rdiff-backup repositories.',",
            "        default_config_files=['/etc/rdiffweb/rdw.conf', '/etc/rdiffweb/rdw.conf.d/*.conf'],",
            "        add_env_var_help=True,",
            "        auto_env_var_prefix='RDIFFWEB_',",
            "        config_file_parser_class=ConfigFileParser,",
            "        conflict_handler='resolve',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '-f', '--config', is_config_file=True, metavar='FILE', help='location of Rdiffweb configuration file'",
            "    )",
            "",
            "    parser.add(",
            "        '--database-uri',",
            "        '--sqlitedb-file',",
            "        '--sqlitedbfile',",
            "        metavar='URI',",
            "        help=\"\"\"Location of the database used for persistence. SQLite and PostgreSQL",
            "            database are supported officially. To use a SQLite database you may",
            "            define the location using a file path or a URI.",
            "            e.g.: /srv/rdiffweb/file.db or sqlite:///srv/rdiffweb/file.db`.",
            "            To use PostgreSQL server you must provide",
            "            a URI similar to postgresql://user:pass@10.255.1.34/dbname and you",
            "            must install required dependencies.",
            "            By default, Rdiffweb uses a SQLite embedded database located at",
            "            /etc/rdiffweb/rdw.db.\"\"\",",
            "        default='/etc/rdiffweb/rdw.db',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '-d',",
            "        '--debug',",
            "        action='store_true',",
            "        help='enable rdiffweb debug mode - change the log level to DEBUG, print exception stack trace to the web interface and show SQL query in logs',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--admin-user',",
            "        '--adminuser',",
            "        metavar='USERNAME',",
            "        help='administrator username. The administrator user get created on startup if the database is empty.',",
            "        default='admin',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--admin-password',",
            "        metavar='USERNAME',",
            "        help=\"\"\"administrator encrypted password as SSHA. Read online",
            "            documentation to know more about how to encrypt your password",
            "            into SSHA or use http://projects.marsching.org/weave4j/util/genpassword.php",
            "            When defined, administrator password cannot be updated using the web interface.",
            "            When undefined, default administrator password is `admin123` and",
            "            it can be updated using the web interface.\"\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--default-theme',",
            "        '--defaulttheme',",
            "        help='define the default theme. Either: default, blue or orange. Define the CSS file to be loaded in the web interface. You may manually edit a CSS file to customize it. The location is similar to `/usr/local/lib/python3.9/dist-packages/rdiffweb/static/`',",
            "        choices=['default', 'blue', 'orange'],",
            "        default='default',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--environment',",
            "        choices=['development', 'production'],",
            "        help='define the type of environment: development, production. This is used to limit the information shown to the user when an error occur.',",
            "        default='production',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-encryption',",
            "        '--emailencryption',",
            "        choices=['none', 'ssl', 'starttls'],",
            "        help='type of encryption to be used when establishing communication with SMTP server. Default: none',",
            "        default='none',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-host',",
            "        '--emailhost',",
            "        metavar='HOST',",
            "        help='SMTP server used to send email in the form <host>:<port>. If the port is not provided, default to standard port 25 or 465 is used. e.g.: smtp.gmail.com:587',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-sender',",
            "        '--emailsender',",
            "        metavar='EMAIL',",
            "        help='email addres used for the `from:` field when sending email.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-notification-time',",
            "        '--emailnotificationtime',",
            "        metavar='TIME',",
            "        help='time when the email notifcation should be sent for inactive backups. e.g.: 22:00 Default value: 23:00',",
            "        default='23:00',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-username',",
            "        '--emailusername',",
            "        metavar='USERNAME',",
            "        help='username used for authentication with the SMTP server.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-password',",
            "        '--emailpassword',",
            "        metavar='PASSWORD',",
            "        help='password used for authentication with the SMTP server.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-send-changed-notification',",
            "        '--emailsendchangednotification',",
            "        help='True to send notification when sensitive information get change in user profile.',",
            "        action='store_true',",
            "        default=False,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--favicon',",
            "        help='location of an icon to be used as a favicon displayed in web browser.',",
            "        default=pkg_resources.resource_filename('rdiffweb', 'static/favicon.ico'),",
            "    )  # @UndefinedVariable",
            "",
            "    parser.add_argument(",
            "        '--footer-name', '--footername', help=argparse.SUPPRESS, default='rdiffweb'",
            "    )  # @UndefinedVariable",
            "",
            "    parser.add_argument(",
            "        '--footer-url', '--footerurl', help=argparse.SUPPRESS, default='https://rdiffweb.org/'",
            "    )  # @UndefinedVariable",
            "",
            "    parser.add_argument(",
            "        '--header-logo',",
            "        '--headerlogo',",
            "        help='location of an image (preferably a .png) to be used as a replacement for the rdiffweb logo.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--header-name',",
            "        '--headername',",
            "        help='application name displayed in the title bar and header menu.',",
            "        default='rdiffweb',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-add-missing-user',",
            "        '--addmissinguser',",
            "        action='store_true',",
            "        help='enable creation of users from LDAP when the credential are valid.',",
            "        default=False,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-add-user-default-role',",
            "        help='default role used when creating users from LDAP. This parameter is only useful when `--ldap-add-missing-user` is enabled.',",
            "        default='user',",
            "        choices=['admin', 'maintainer', 'user'],",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-add-user-default-userroot',",
            "        help='default user root directory used when creating users from LDAP. LDAP attributes may be used to define the default location. e.g.: `/backups/{uid[0]}/`. This parameter is only useful when `--ldap-add-missing-user` is enabled.',",
            "        default='',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-uri',",
            "        '--ldapuri',",
            "        help='URL to the LDAP server used to validate user credentials. e.g.: ldap://localhost:389',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-base-dn',",
            "        '--ldapbasedn',",
            "        metavar='DN',",
            "        help='DN of the branch of the directory where all searches should start from. e.g.: dc=my,dc=domain',",
            "        default=\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-scope',",
            "        '--ldapscope',",
            "        help='scope of the search. Can be either base, onelevel or subtree',",
            "        choices=['base', 'onelevel', 'subtree'],",
            "        default=\"subtree\",",
            "    )",
            "",
            "    parser.add_argument('--ldap-tls', '--ldaptls', action='store_true', help='enable TLS')",
            "",
            "    parser.add_argument(",
            "        '--ldap-username-attribute',",
            "        '--ldapattribute',",
            "        metavar='ATTRIBUTE',",
            "        help=\"The attribute to search username. If no attributes are provided, the default is to use `uid`. It's a good idea to choose an attribute that will be unique across all entries in the subtree you will be using.\",",
            "        default='uid',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-filter',",
            "        '--ldapfilter',",
            "        help=\"search filter to limit LDAP lookup. If not provided, defaults to (objectClass=*), which searches for all objects in the tree.\",",
            "        default='(objectClass=*)',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-required-group',",
            "        '--ldaprequiredgroup',",
            "        metavar='GROUPNAME',",
            "        help=\"name of the group of which the user must be a member to access rdiffweb. Should be used with ldap-group-attribute and ldap-group-attribute-is-dn.\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-group-attribute',",
            "        '--ldapgroupattribute',",
            "        metavar='ATTRIBUTE',",
            "        help=\"name of the attribute defining the groups of which the user is a member. Should be used with ldap-required-group and ldap-group-attribute-is-dn.\",",
            "        default='member',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-group-attribute-is-dn',",
            "        '--ldapgroupattributeisdn',",
            "        help=\"True if the content of the attribute `ldap-group-attribute` is a DN.\",",
            "        action='store_true',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-bind-dn',",
            "        '--ldapbinddn',",
            "        metavar='DN',",
            "        help=\"optional DN used to bind to the server when searching for entries. If not provided, will use an anonymous bind.\",",
            "        default=\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-bind-password',",
            "        '--ldapbindpassword',",
            "        metavar='PASSWORD',",
            "        help=\"password to use in conjunction with LdapBindDn. Note that the bind password is probably sensitive data, and should be properly protected. You should only use the LdapBindDn and LdapBindPassword if you absolutely need them to search the directory.\",",
            "        default=\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-version',",
            "        '--ldapversion',",
            "        '--ldapprotocolversion',",
            "        help=\"version of LDAP in use either 2 or 3. Default to 3.\",",
            "        default=3,",
            "        type=int,",
            "        choices=[2, 3],",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-network-timeout',",
            "        '--ldapnetworktimeout',",
            "        metavar='SECONDS',",
            "        help=\"timeout in seconds value used for LDAP connection\",",
            "        default=100,",
            "        type=int,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-timeout',",
            "        '--ldaptimeout',",
            "        metavar='SECONDS',",
            "        help=\"timeout in seconds value used for LDAP request\",",
            "        default=300,",
            "        type=int,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-encoding',",
            "        '--ldapencoding',",
            "        metavar='ENCODING',",
            "        help=\"encoding used by your LDAP server.\",",
            "        default=\"utf-8\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--log-access-file', '--logaccessfile', metavar='FILE', help='location of Rdiffweb log access file.'",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--log-file',",
            "        '--logfile',",
            "        metavar='FILE',",
            "        help='location of Rdiffweb log file. Print log to the console if not define in config file.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--log-level',",
            "        '--loglevel',",
            "        help='Define the log level.',",
            "        choices=['ERROR', 'WARN', 'INFO', 'DEBUG'],",
            "        default='INFO',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--max-depth',",
            "        '--maxdepth',",
            "        metavar='DEPTH',",
            "        help=\"define the maximum folder depthness to search into the user's root directory to find repositories. This is commonly used if you repositories are organised with multiple sub-folder.\",",
            "        type=int,",
            "        default=3,",
            "    )",
            "",
            "    parser.add('--quota-set-cmd', '--quotasetcmd', metavar='COMMAND', help=\"command line to set the user's quota.\")",
            "",
            "    parser.add('--quota-get-cmd', '--quotagetcmd', metavar='COMMAND', help=\"command line to get the user's quota.\")",
            "",
            "    parser.add(",
            "        '--quota-used-cmd', '--quotausedcmd', metavar='COMMAND', help=\"Command line to get user's quota disk usage.\"",
            "    )",
            "",
            "    parser.add(",
            "        '--remove-older-time',",
            "        '--removeoldertime',",
            "        metavar='TIME',",
            "        help=\"Time when to execute the remove older scheduled job. e.g.: 22:30\",",
            "        default='23:00',",
            "    )",
            "",
            "    parser.add('--server-host', '--serverhost', metavar='IP', default='127.0.0.1', help='IP address to listen to')",
            "",
            "    parser.add(",
            "        '--server-port',",
            "        '--serverport',",
            "        metavar='PORT',",
            "        help='port to listen to for HTTP request',",
            "        default='8080',",
            "        type=int,",
            "    )",
            "",
            "    parser.add(",
            "        '--session-dir',",
            "        '--sessiondir',",
            "        metavar='FOLDER',",
            "        help='location where to store user session information. When undefined, the user sessions are kept in memory.',",
            "    )",
            "",
            "    parser.add(",
            "        '--rate-limit',",
            "        metavar='LIMIT',",
            "        type=int,",
            "        default=10,",
            "        help='maximum number of requests per minute that can be made by an IP address for an unauthenticated connection. When this limit is reached, an HTTP 429 message is returned to the user. This security measure is used to limit brute force attacks on the login page and the RESTful API.',",
            "    )",
            "",
            "    parser.add(",
            "        '--ssl-certificate',",
            "        '--sslcertificate',",
            "        metavar='CERT',",
            "        help='location of the SSL Certification to enable HTTPS (not recommended)',",
            "    )",
            "",
            "    parser.add(",
            "        '--ssl-private-key',",
            "        '--sslprivatekey',",
            "        metavar='KEY',",
            "        help='location of the SSL Private Key to enable HTTPS (not recommended)',",
            "    )",
            "",
            "    parser.add(",
            "        '--tempdir',",
            "        metavar='FOLDER',",
            "        help='alternate temporary folder to be used when restoring files. Might be useful if the default location has limited disk space. Default to TEMPDIR environment or `/tmp`.',",
            "    )",
            "",
            "    parser.add(",
            "        '--disable-ssh-keys',",
            "        action='store_true',",
            "        help='used to hide SSH Key management to avoid users to add or remove SSH Key using the web application',",
            "        default=False,",
            "    )",
            "",
            "    parser.add(",
            "        '--password-min-length',",
            "        type=int,",
            "        help=\"Minimum length of the user's password\",",
            "        default=8,",
            "    )",
            "",
            "    parser.add(",
            "        '--password-max-length',",
            "        type=int,",
            "        help=\"Maximum length of the user's password\",",
            "        default=128,",
            "    )",
            "",
            "    parser.add_argument('--version', action='version', version='%(prog)s ' + VERSION)",
            "",
            "    # Here we append a list of arguments for each locale.",
            "    flags = ['--welcome-msg'] + ['--welcome-msg-' + i for i in ['ca', 'en', 'es', 'fr', 'ru']] + ['--welcomemsg']",
            "    parser.add_argument(",
            "        *flags,",
            "        metavar='HTML',",
            "        help='replace the welcome message displayed in the login page for default locale or for a specific locale',",
            "        action=LocaleAction",
            "    )",
            "    return parser",
            "",
            "",
            "def parse_args(args=None, config_file_contents=None):",
            "    args = sys.argv[1:] if args is None else args",
            "    return get_parser().parse_args(args, config_file_contents=config_file_contents)",
            "",
            "",
            "class LocaleAction(argparse.Action):",
            "    \"\"\"",
            "    Custom Action to support defining arguments with locale.",
            "    \"\"\"",
            "",
            "    def __init__(self, option_strings, dest, nargs=None, **kwargs):",
            "        super(LocaleAction, self).__init__(option_strings, dest, **kwargs)",
            "",
            "    def __call__(self, parser, namespace, value, option_string=None):",
            "        if option_string[-3] == '-':",
            "            # When using arguments, we can extract the locale from the argument key",
            "            locale = option_string[-2:]",
            "        elif value[2] == ':':",
            "            # When using config file, the locale could be extract from the value e.g. fr:message",
            "            locale = value[0:2]",
            "            value = value[3:]",
            "        else:",
            "            locale = ''",
            "        # Create a dictionary with locale.",
            "        items = getattr(namespace, self.dest) or {}",
            "        items[locale] = value",
            "        setattr(namespace, self.dest, items)",
            "",
            "",
            "class ConfigFileParser(object):",
            "    \"\"\"",
            "    Custom config file parser to support rdiffweb config file format.",
            "    \"\"\"",
            "",
            "    def get_syntax_description(self):",
            "        msg = \"Configuration file syntax allows: key=value, flag=true.\"",
            "        return msg",
            "",
            "    def parse(self, stream):",
            "        \"\"\"",
            "        Used to read the rdiffweb config file as dict.",
            "        \"\"\"",
            "",
            "        result = OrderedDict()",
            "",
            "        for i, line in enumerate(stream):",
            "            line = re.compile(\"(.*?)#.*\").sub(r'\\1', line).strip()",
            "            if not line:",
            "                continue",
            "            if '=' not in line:",
            "                raise configargparse.ConfigFileParserException(",
            "                    \"Unexpected line {} in {}: {}\".format(i, getattr(stream, 'name', 'stream'), line)",
            "                )",
            "            split_line = line.partition('=')",
            "            if not len(split_line) == 3:",
            "                raise configargparse.ConfigFileParserException(",
            "                    \"Unexpected line {} in {}: {}\".format(i, getattr(stream, 'name', 'stream'), line)",
            "                )",
            "",
            "            # Get key a& value",
            "            key = split_line[0].lower().strip().replace('_', '-')",
            "            value = split_line[2].strip()",
            "",
            "            # Support welcome-msg locale for backward compatibility",
            "            m = re.match(\"welcome-?msg\\\\[(ca|en|es|fr|ru)\\\\]\", key.lower())",
            "            if m:",
            "                key = \"welcome-msg-\" + m.group(1)",
            "                value = m.group(1) + \":\" + value",
            "",
            "            result[key] = value",
            "",
            "        # This dictionary is read by cherrypy. So create appropriate structure.",
            "        return result",
            "",
            "",
            "class Option(object):",
            "    def __init__(self, key):",
            "        assert key",
            "        self.key = key",
            "",
            "    def __get__(self, instance, owner):",
            "        \"\"\"",
            "        Return a property to wrap the given option.",
            "        \"\"\"",
            "        return self.get(instance)",
            "",
            "    def get(self, instance=None):",
            "        \"\"\"",
            "        Return the value of this options.",
            "        \"\"\"",
            "        if isinstance(instance, Application):",
            "            app = instance",
            "        else:",
            "            app = cherrypy.request.app or getattr(instance, 'app', None)",
            "        assert app, \"Option() can't get reference to app\"",
            "        assert app.cfg, \"Option() can't get reference to app.cfg\"",
            "        return getattr(app.cfg, self.key)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import argparse",
            "import logging",
            "import re",
            "import sys",
            "from collections import OrderedDict",
            "",
            "import cherrypy",
            "import configargparse",
            "import pkg_resources",
            "from cherrypy import Application",
            "",
            "# Define the logger",
            "logger = logging.getLogger(__name__)",
            "",
            "# Get rdiffweb version.",
            "try:",
            "    VERSION = pkg_resources.get_distribution(\"rdiffweb\").version",
            "except pkg_resources.DistributionNotFound:",
            "    VERSION = \"DEV\"",
            "",
            "",
            "def get_parser():",
            "    # Get global config argument parser",
            "    parser = configargparse.ArgumentParser(",
            "        prog='rdiffweb',",
            "        description='Web interface to browse and restore rdiff-backup repositories.',",
            "        default_config_files=['/etc/rdiffweb/rdw.conf', '/etc/rdiffweb/rdw.conf.d/*.conf'],",
            "        add_env_var_help=True,",
            "        auto_env_var_prefix='RDIFFWEB_',",
            "        config_file_parser_class=ConfigFileParser,",
            "        conflict_handler='resolve',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '-f', '--config', is_config_file=True, metavar='FILE', help='location of Rdiffweb configuration file'",
            "    )",
            "",
            "    parser.add(",
            "        '--database-uri',",
            "        '--sqlitedb-file',",
            "        '--sqlitedbfile',",
            "        metavar='URI',",
            "        help=\"\"\"Location of the database used for persistence. SQLite and PostgreSQL",
            "            database are supported officially. To use a SQLite database you may",
            "            define the location using a file path or a URI.",
            "            e.g.: /srv/rdiffweb/file.db or sqlite:///srv/rdiffweb/file.db`.",
            "            To use PostgreSQL server you must provide",
            "            a URI similar to postgresql://user:pass@10.255.1.34/dbname and you",
            "            must install required dependencies.",
            "            By default, Rdiffweb uses a SQLite embedded database located at",
            "            /etc/rdiffweb/rdw.db.\"\"\",",
            "        default='/etc/rdiffweb/rdw.db',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '-d',",
            "        '--debug',",
            "        action='store_true',",
            "        help='enable rdiffweb debug mode - change the log level to DEBUG, print exception stack trace to the web interface and show SQL query in logs',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--admin-user',",
            "        '--adminuser',",
            "        metavar='USERNAME',",
            "        help='administrator username. The administrator user get created on startup if the database is empty.',",
            "        default='admin',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--admin-password',",
            "        metavar='USERNAME',",
            "        help=\"\"\"administrator encrypted password as SSHA. Read online",
            "            documentation to know more about how to encrypt your password",
            "            into SSHA or use http://projects.marsching.org/weave4j/util/genpassword.php",
            "            When defined, administrator password cannot be updated using the web interface.",
            "            When undefined, default administrator password is `admin123` and",
            "            it can be updated using the web interface.\"\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--default-theme',",
            "        '--defaulttheme',",
            "        help='define the default theme. Either: default, blue or orange. Define the CSS file to be loaded in the web interface. You may manually edit a CSS file to customize it. The location is similar to `/usr/local/lib/python3.9/dist-packages/rdiffweb/static/`',",
            "        choices=['default', 'blue', 'orange'],",
            "        default='default',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--environment',",
            "        choices=['development', 'production'],",
            "        help='define the type of environment: development, production. This is used to limit the information shown to the user when an error occur.',",
            "        default='production',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-encryption',",
            "        '--emailencryption',",
            "        choices=['none', 'ssl', 'starttls'],",
            "        help='type of encryption to be used when establishing communication with SMTP server. Default: none',",
            "        default='none',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-host',",
            "        '--emailhost',",
            "        metavar='HOST',",
            "        help='SMTP server used to send email in the form <host>:<port>. If the port is not provided, default to standard port 25 or 465 is used. e.g.: smtp.gmail.com:587',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-sender',",
            "        '--emailsender',",
            "        metavar='EMAIL',",
            "        help='email addres used for the `from:` field when sending email.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-notification-time',",
            "        '--emailnotificationtime',",
            "        metavar='TIME',",
            "        help='time when the email notifcation should be sent for inactive backups. e.g.: 22:00 Default value: 23:00',",
            "        default='23:00',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-username',",
            "        '--emailusername',",
            "        metavar='USERNAME',",
            "        help='username used for authentication with the SMTP server.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-password',",
            "        '--emailpassword',",
            "        metavar='PASSWORD',",
            "        help='password used for authentication with the SMTP server.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--email-send-changed-notification',",
            "        '--emailsendchangednotification',",
            "        help='True to send notification when sensitive information get change in user profile.',",
            "        action='store_true',",
            "        default=False,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--favicon',",
            "        help='location of an icon to be used as a favicon displayed in web browser.',",
            "        default=pkg_resources.resource_filename('rdiffweb', 'static/favicon.ico'),",
            "    )  # @UndefinedVariable",
            "",
            "    parser.add_argument(",
            "        '--footer-name', '--footername', help=argparse.SUPPRESS, default='rdiffweb'",
            "    )  # @UndefinedVariable",
            "",
            "    parser.add_argument(",
            "        '--footer-url', '--footerurl', help=argparse.SUPPRESS, default='https://rdiffweb.org/'",
            "    )  # @UndefinedVariable",
            "",
            "    parser.add_argument(",
            "        '--header-logo',",
            "        '--headerlogo',",
            "        help='location of an image (preferably a .png) to be used as a replacement for the rdiffweb logo.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--header-name',",
            "        '--headername',",
            "        help='application name displayed in the title bar and header menu.',",
            "        default='rdiffweb',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-add-missing-user',",
            "        '--addmissinguser',",
            "        action='store_true',",
            "        help='enable creation of users from LDAP when the credential are valid.',",
            "        default=False,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-add-user-default-role',",
            "        help='default role used when creating users from LDAP. This parameter is only useful when `--ldap-add-missing-user` is enabled.',",
            "        default='user',",
            "        choices=['admin', 'maintainer', 'user'],",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-add-user-default-userroot',",
            "        help='default user root directory used when creating users from LDAP. LDAP attributes may be used to define the default location. e.g.: `/backups/{uid[0]}/`. This parameter is only useful when `--ldap-add-missing-user` is enabled.',",
            "        default='',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-uri',",
            "        '--ldapuri',",
            "        help='URL to the LDAP server used to validate user credentials. e.g.: ldap://localhost:389',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-base-dn',",
            "        '--ldapbasedn',",
            "        metavar='DN',",
            "        help='DN of the branch of the directory where all searches should start from. e.g.: dc=my,dc=domain',",
            "        default=\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-scope',",
            "        '--ldapscope',",
            "        help='scope of the search. Can be either base, onelevel or subtree',",
            "        choices=['base', 'onelevel', 'subtree'],",
            "        default=\"subtree\",",
            "    )",
            "",
            "    parser.add_argument('--ldap-tls', '--ldaptls', action='store_true', help='enable TLS')",
            "",
            "    parser.add_argument(",
            "        '--ldap-username-attribute',",
            "        '--ldapattribute',",
            "        metavar='ATTRIBUTE',",
            "        help=\"The attribute to search username. If no attributes are provided, the default is to use `uid`. It's a good idea to choose an attribute that will be unique across all entries in the subtree you will be using.\",",
            "        default='uid',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-filter',",
            "        '--ldapfilter',",
            "        help=\"search filter to limit LDAP lookup. If not provided, defaults to (objectClass=*), which searches for all objects in the tree.\",",
            "        default='(objectClass=*)',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-required-group',",
            "        '--ldaprequiredgroup',",
            "        metavar='GROUPNAME',",
            "        help=\"name of the group of which the user must be a member to access rdiffweb. Should be used with ldap-group-attribute and ldap-group-attribute-is-dn.\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-group-attribute',",
            "        '--ldapgroupattribute',",
            "        metavar='ATTRIBUTE',",
            "        help=\"name of the attribute defining the groups of which the user is a member. Should be used with ldap-required-group and ldap-group-attribute-is-dn.\",",
            "        default='member',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-group-attribute-is-dn',",
            "        '--ldapgroupattributeisdn',",
            "        help=\"True if the content of the attribute `ldap-group-attribute` is a DN.\",",
            "        action='store_true',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-bind-dn',",
            "        '--ldapbinddn',",
            "        metavar='DN',",
            "        help=\"optional DN used to bind to the server when searching for entries. If not provided, will use an anonymous bind.\",",
            "        default=\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-bind-password',",
            "        '--ldapbindpassword',",
            "        metavar='PASSWORD',",
            "        help=\"password to use in conjunction with LdapBindDn. Note that the bind password is probably sensitive data, and should be properly protected. You should only use the LdapBindDn and LdapBindPassword if you absolutely need them to search the directory.\",",
            "        default=\"\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-version',",
            "        '--ldapversion',",
            "        '--ldapprotocolversion',",
            "        help=\"version of LDAP in use either 2 or 3. Default to 3.\",",
            "        default=3,",
            "        type=int,",
            "        choices=[2, 3],",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-network-timeout',",
            "        '--ldapnetworktimeout',",
            "        metavar='SECONDS',",
            "        help=\"timeout in seconds value used for LDAP connection\",",
            "        default=100,",
            "        type=int,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-timeout',",
            "        '--ldaptimeout',",
            "        metavar='SECONDS',",
            "        help=\"timeout in seconds value used for LDAP request\",",
            "        default=300,",
            "        type=int,",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--ldap-encoding',",
            "        '--ldapencoding',",
            "        metavar='ENCODING',",
            "        help=\"encoding used by your LDAP server.\",",
            "        default=\"utf-8\",",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--log-access-file', '--logaccessfile', metavar='FILE', help='location of Rdiffweb log access file.'",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--log-file',",
            "        '--logfile',",
            "        metavar='FILE',",
            "        help='location of Rdiffweb log file. Print log to the console if not define in config file.',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--log-level',",
            "        '--loglevel',",
            "        help='Define the log level.',",
            "        choices=['ERROR', 'WARN', 'INFO', 'DEBUG'],",
            "        default='INFO',",
            "    )",
            "",
            "    parser.add_argument(",
            "        '--max-depth',",
            "        '--maxdepth',",
            "        metavar='DEPTH',",
            "        help=\"define the maximum folder depthness to search into the user's root directory to find repositories. This is commonly used if you repositories are organised with multiple sub-folder.\",",
            "        type=int,",
            "        default=3,",
            "    )",
            "",
            "    parser.add('--quota-set-cmd', '--quotasetcmd', metavar='COMMAND', help=\"command line to set the user's quota.\")",
            "",
            "    parser.add('--quota-get-cmd', '--quotagetcmd', metavar='COMMAND', help=\"command line to get the user's quota.\")",
            "",
            "    parser.add(",
            "        '--quota-used-cmd', '--quotausedcmd', metavar='COMMAND', help=\"Command line to get user's quota disk usage.\"",
            "    )",
            "",
            "    parser.add(",
            "        '--remove-older-time',",
            "        '--removeoldertime',",
            "        metavar='TIME',",
            "        help=\"Time when to execute the remove older scheduled job. e.g.: 22:30\",",
            "        default='23:00',",
            "    )",
            "",
            "    parser.add('--server-host', '--serverhost', metavar='IP', default='127.0.0.1', help='IP address to listen to')",
            "",
            "    parser.add(",
            "        '--server-port',",
            "        '--serverport',",
            "        metavar='PORT',",
            "        help='port to listen to for HTTP request',",
            "        default='8080',",
            "        type=int,",
            "    )",
            "",
            "    parser.add(",
            "        '--session-dir',",
            "        '--sessiondir',",
            "        metavar='FOLDER',",
            "        help='location where to store user session information. When undefined, the user sessions are kept in memory.',",
            "    )",
            "",
            "    parser.add(",
            "        '--rate-limit',",
            "        metavar='LIMIT',",
            "        type=int,",
            "        default=10,",
            "        help='maximum number of requests per minute that can be made by an IP address for an unauthenticated connection. When this limit is reached, an HTTP 429 message is returned to the user. This security measure is used to limit brute force attacks on the login page and the RESTful API.',",
            "    )",
            "",
            "    parser.add(",
            "        '--ssl-certificate',",
            "        '--sslcertificate',",
            "        metavar='CERT',",
            "        help='location of the SSL Certification to enable HTTPS (not recommended)',",
            "    )",
            "",
            "    parser.add(",
            "        '--ssl-private-key',",
            "        '--sslprivatekey',",
            "        metavar='KEY',",
            "        help='location of the SSL Private Key to enable HTTPS (not recommended)',",
            "    )",
            "",
            "    parser.add(",
            "        '--tempdir',",
            "        metavar='FOLDER',",
            "        help='alternate temporary folder to be used when restoring files. Might be useful if the default location has limited disk space. Default to TEMPDIR environment or `/tmp`.',",
            "    )",
            "",
            "    parser.add(",
            "        '--disable-ssh-keys',",
            "        action='store_true',",
            "        help='used to hide SSH Key management to avoid users to add or remove SSH Key using the web application',",
            "        default=False,",
            "    )",
            "",
            "    parser.add(",
            "        '--password-min-length',",
            "        type=int,",
            "        help=\"Minimum length of the user's password\",",
            "        default=8,",
            "    )",
            "",
            "    parser.add(",
            "        '--password-max-length',",
            "        type=int,",
            "        help=\"Maximum length of the user's password\",",
            "        default=128,",
            "    )",
            "",
            "    parser.add(",
            "        '--password-score',",
            "        type=lambda x: max(1, min(int(x), 4)),",
            "        help=\"Minimum zxcvbn's score for password. Value from 1 to 4. Default value 2. Read more about it here: https://github.com/dropbox/zxcvbn\",",
            "        default=2,",
            "    )",
            "",
            "    parser.add_argument('--version', action='version', version='%(prog)s ' + VERSION)",
            "",
            "    # Here we append a list of arguments for each locale.",
            "    flags = ['--welcome-msg'] + ['--welcome-msg-' + i for i in ['ca', 'en', 'es', 'fr', 'ru']] + ['--welcomemsg']",
            "    parser.add_argument(",
            "        *flags,",
            "        metavar='HTML',",
            "        help='replace the welcome message displayed in the login page for default locale or for a specific locale',",
            "        action=LocaleAction",
            "    )",
            "    return parser",
            "",
            "",
            "def parse_args(args=None, config_file_contents=None):",
            "    args = sys.argv[1:] if args is None else args",
            "    return get_parser().parse_args(args, config_file_contents=config_file_contents)",
            "",
            "",
            "class LocaleAction(argparse.Action):",
            "    \"\"\"",
            "    Custom Action to support defining arguments with locale.",
            "    \"\"\"",
            "",
            "    def __init__(self, option_strings, dest, nargs=None, **kwargs):",
            "        super(LocaleAction, self).__init__(option_strings, dest, **kwargs)",
            "",
            "    def __call__(self, parser, namespace, value, option_string=None):",
            "        if option_string[-3] == '-':",
            "            # When using arguments, we can extract the locale from the argument key",
            "            locale = option_string[-2:]",
            "        elif value[2] == ':':",
            "            # When using config file, the locale could be extract from the value e.g. fr:message",
            "            locale = value[0:2]",
            "            value = value[3:]",
            "        else:",
            "            locale = ''",
            "        # Create a dictionary with locale.",
            "        items = getattr(namespace, self.dest) or {}",
            "        items[locale] = value",
            "        setattr(namespace, self.dest, items)",
            "",
            "",
            "class ConfigFileParser(object):",
            "    \"\"\"",
            "    Custom config file parser to support rdiffweb config file format.",
            "    \"\"\"",
            "",
            "    def get_syntax_description(self):",
            "        msg = \"Configuration file syntax allows: key=value, flag=true.\"",
            "        return msg",
            "",
            "    def parse(self, stream):",
            "        \"\"\"",
            "        Used to read the rdiffweb config file as dict.",
            "        \"\"\"",
            "",
            "        result = OrderedDict()",
            "",
            "        for i, line in enumerate(stream):",
            "            line = re.compile(\"(.*?)#.*\").sub(r'\\1', line).strip()",
            "            if not line:",
            "                continue",
            "            if '=' not in line:",
            "                raise configargparse.ConfigFileParserException(",
            "                    \"Unexpected line {} in {}: {}\".format(i, getattr(stream, 'name', 'stream'), line)",
            "                )",
            "            split_line = line.partition('=')",
            "            if not len(split_line) == 3:",
            "                raise configargparse.ConfigFileParserException(",
            "                    \"Unexpected line {} in {}: {}\".format(i, getattr(stream, 'name', 'stream'), line)",
            "                )",
            "",
            "            # Get key a& value",
            "            key = split_line[0].lower().strip().replace('_', '-')",
            "            value = split_line[2].strip()",
            "",
            "            # Support welcome-msg locale for backward compatibility",
            "            m = re.match(\"welcome-?msg\\\\[(ca|en|es|fr|ru)\\\\]\", key.lower())",
            "            if m:",
            "                key = \"welcome-msg-\" + m.group(1)",
            "                value = m.group(1) + \":\" + value",
            "",
            "            result[key] = value",
            "",
            "        # This dictionary is read by cherrypy. So create appropriate structure.",
            "        return result",
            "",
            "",
            "class Option(object):",
            "    def __init__(self, key):",
            "        assert key",
            "        self.key = key",
            "",
            "    def __get__(self, instance, owner):",
            "        \"\"\"",
            "        Return a property to wrap the given option.",
            "        \"\"\"",
            "        return self.get(instance)",
            "",
            "    def get(self, instance=None):",
            "        \"\"\"",
            "        Return the value of this options.",
            "        \"\"\"",
            "        if isinstance(instance, Application):",
            "            app = instance",
            "        else:",
            "            app = cherrypy.request.app or getattr(instance, 'app', None)",
            "        assert app, \"Option() can't get reference to app\"",
            "        assert app.cfg, \"Option() can't get reference to app.cfg\"",
            "        return getattr(app.cfg, self.key)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "rdiffweb.core.config.parse_args",
            "lib.ansible.modules.cloud.google.gcp_compute_region_disk.create",
            "rdiffweb.core.config.get_parser.flags"
        ]
    },
    "rdiffweb/core/store.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from sqlalchemy.exc import IntegrityError"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from sqlalchemy.sql.expression import and_, or_, select"
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from sqlalchemy.sql.functions import count"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+from zxcvbn import zxcvbn"
            },
            "4": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " from rdiffweb.core import RdiffError, authorizedkeys"
            },
            "6": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from rdiffweb.core.config import Option"
            },
            "7": {
                "beforePatchRowNumber": 397,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "         assert old_password is None or isinstance(old_password, str)"
            },
            "8": {
                "beforePatchRowNumber": 398,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "         if not password:"
            },
            "9": {
                "beforePatchRowNumber": 399,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "             raise ValueError(\"password can't be empty\")"
            },
            "10": {
                "beforePatchRowNumber": 400,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cfg = self._store.app.cfg"
            },
            "11": {
                "beforePatchRowNumber": 401,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if cfg.password_min_length > len(password) > cfg.password_max_length:"
            },
            "12": {
                "beforePatchRowNumber": 402,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise ValueError(\"invalid password length\")"
            },
            "13": {
                "beforePatchRowNumber": 403,
                "afterPatchRowNumber": 401,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 404,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "         # Cannot update admin-password if defined"
            },
            "15": {
                "beforePatchRowNumber": 405,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "         if self.username == self._store._admin_user and self._store._admin_password:"
            },
            "16": {
                "beforePatchRowNumber": 406,
                "afterPatchRowNumber": 404,
                "PatchRowcode": "             raise ValueError(_(\"can't update admin-password defined in configuration file\"))"
            },
            "17": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 405,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 406,
                "PatchRowcode": "+        # Check current password"
            },
            "19": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 407,
                "PatchRowcode": "         if old_password and not check_password(old_password, self.hash_password):"
            },
            "20": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "             raise ValueError(_(\"Wrong password\"))"
            },
            "21": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 409,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 410,
                "PatchRowcode": "+        # Check password length"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+        cfg = self._store.app.cfg"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+            raise ValueError("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+                _('Password must have between %(min)d and %(max)d characters.')"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 416,
                "PatchRowcode": "+            )"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 417,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 418,
                "PatchRowcode": "+        # Verify password score using zxcvbn"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 419,
                "PatchRowcode": "+        stats = zxcvbn(password)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 420,
                "PatchRowcode": "+        if stats.get('score') < cfg.password_score:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 421,
                "PatchRowcode": "+            msg = _('Password too weak.')"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 422,
                "PatchRowcode": "+            warning = stats.get('feedback', {}).get('warning')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 423,
                "PatchRowcode": "+            suggestions = stats.get('feedback', {}).get('suggestions')"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 424,
                "PatchRowcode": "+            if warning:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 425,
                "PatchRowcode": "+                msg += ' ' + warning"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+            if suggestions:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+                msg += ' ' + ' '.join(suggestions)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+            raise ValueError(msg)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 429,
                "PatchRowcode": "+"
            },
            "42": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 430,
                "PatchRowcode": "         logger.info(\"updating user password [%s]\", self.username)"
            },
            "43": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 431,
                "PatchRowcode": "         self.hash_password = hash_password(password)"
            },
            "44": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 432,
                "PatchRowcode": "         self._store.bus.publish('user_password_changed', self)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import codecs",
            "import encodings",
            "import logging",
            "import os",
            "import sys",
            "from io import open",
            "",
            "import cherrypy",
            "from cherrypy.process.plugins import SimplePlugin",
            "from sqlalchemy import Column, Integer, MetaData, SmallInteger, String, Table, Text, create_engine",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.sql.expression import and_, or_, select",
            "from sqlalchemy.sql.functions import count",
            "",
            "from rdiffweb.core import RdiffError, authorizedkeys",
            "from rdiffweb.core.config import Option",
            "from rdiffweb.core.librdiff import AccessDeniedError, DoesNotExistError, RdiffRepo",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "# Define the logger",
            "logger = logging.getLogger(__name__)",
            "",
            "SEP = b'/'",
            "",
            "DEFAULT_REPO_ENCODING = codecs.lookup((sys.getfilesystemencoding() or 'utf-8').lower()).name",
            "",
            "# Define roles",
            "ADMIN_ROLE = 0",
            "MAINTAINER_ROLE = 5",
            "USER_ROLE = 10",
            "ROLES = {",
            "    'admin': ADMIN_ROLE,",
            "    'maintainer': MAINTAINER_ROLE,",
            "    'user': USER_ROLE,",
            "}",
            "",
            "# Define SQLAlchemy metadata",
            "_META = MetaData()",
            "_USERS = Table(",
            "    'users',",
            "    _META,",
            "    Column('UserID', Integer, key='userid', primary_key=True),",
            "    Column('Username', String, key='username', nullable=False, unique=True),",
            "    Column('Password', String, key='password', nullable=False, server_default=\"\"),",
            "    Column('UserRoot', String, key='user_root', nullable=False, server_default=\"\"),",
            "    Column(",
            "        'IsAdmin',",
            "        SmallInteger,",
            "        key='is_admin',",
            "        nullable=False,",
            "        server_default=\"0\",",
            "        doc=\"DEPRECATED This column is replaced by 'role'\",",
            "    ),",
            "    Column('UserEmail', String, key='email', nullable=False, server_default=\"\"),",
            "    Column(",
            "        'RestoreFormat',",
            "        SmallInteger,",
            "        nullable=False,",
            "        server_default=\"1\",",
            "        doc=\"DEPRECATED This column is not used anymore\",",
            "    ),",
            "    Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE)),",
            "    sqlite_autoincrement=True,",
            ")",
            "",
            "_REPOS = Table(",
            "    'repos',",
            "    _META,",
            "    Column('RepoID', Integer, key='repoid', primary_key=True, autoincrement=True),",
            "    Column('UserID', Integer, key='userid', nullable=False),",
            "    Column('RepoPath', String, key='repopath', nullable=False),",
            "    Column('MaxAge', SmallInteger, key='maxage', nullable=False, server_default=\"0\"),",
            "    Column('Encoding', String, key='encoding'),",
            "    Column('keepdays', String, nullable=False, server_default=\"\"),",
            "    sqlite_autoincrement=True,",
            ")",
            "",
            "_SSHKEYS = Table(",
            "    'sshkeys',",
            "    _META,",
            "    Column('Fingerprint', Text, key='fingerprint'),",
            "    Column('Key', Text, key='key', unique=True),",
            "    Column('UserID', Integer, key='userid', nullable=False),",
            ")",
            "",
            "",
            "def _split_path(path):",
            "    \"\"\"",
            "    Split the given path into <username as str> / <path as bytes>",
            "    \"\"\"",
            "    # First part is the username",
            "    assert path",
            "    if isinstance(path, str):",
            "        path = os.fsencode(path)",
            "    path = path.strip(b'/')",
            "    if b'/' in path:",
            "        username, path = path.split(b'/', 1)",
            "        return username.decode('utf-8'), path",
            "    else:",
            "        return path.decode('utf-8'), b''",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(object):",
            "    \"\"\"Represent an instance of user.\"\"\"",
            "",
            "    _ATTRS = ['username', 'role', 'email', 'user_root', 'password']",
            "",
            "    def __init__(self, store, data):",
            "        \"\"\"",
            "        Create a new UserObject from a username or a record.",
            "",
            "        `data` a dict or a SQLAlchemy row.",
            "",
            "        \"\"\"",
            "        assert store",
            "        assert 'userid' in data",
            "        self._store = store",
            "        self._record = {k: data[k] for k in self._ATTRS}",
            "        self._userid = data[_USERS.c.userid]",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                with self._store.engine.connect() as conn:",
            "                    conn.execute(",
            "                        _SSHKEYS.insert().values(userid=self._userid, fingerprint=key.fingerprint, key=key.getvalue())",
            "                    )",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        self._store.bus.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self):",
            "        \"\"\"",
            "        Delete the given user from password store.",
            "",
            "        Return True if the user was deleted.",
            "        Return False if the user didn't exists.",
            "        Raise a ValueError when trying to delete the admin user.",
            "        \"\"\"",
            "        # Make sure we are not trying to delete the admin user.",
            "        if self.username == self._store._admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "",
            "        # Delete user from database (required).",
            "        logger.info(\"deleting user [%s] from database\", self.username)",
            "        with self._store.engine.connect() as conn:",
            "            conn.execute(_SSHKEYS.delete(_SSHKEYS.c.userid == self._userid))",
            "            conn.execute(_REPOS.delete(_REPOS.c.userid == self._userid))",
            "            deleted = conn.execute(_USERS.delete(_USERS.c.userid == self._userid))",
            "            assert deleted.rowcount, 'fail to delete user'",
            "        self._store.bus.publish('user_deleted', self.username)",
            "        return True",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            with self._store.engine.connect() as conn:",
            "                conn.execute(",
            "                    _SSHKEYS.delete(and_(_SSHKEYS.c.userid == self._userid, _SSHKEYS.c.fingerprint == fingerprint))",
            "                )",
            "        self._store.bus.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = self._store.bus.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = self._store.bus.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        self._store.bus.publish('set_disk_quota', self, value)",
            "",
            "    def __eq__(self, other):",
            "        return isinstance(other, UserObject) and self._userid == other._userid",
            "",
            "    def __str__(self):",
            "        return 'UserObject(%s)' % self._userid",
            "",
            "    def _get_attr(self, key):",
            "        \"\"\"Return user's attribute\"\"\"",
            "        assert key in self._ATTRS, \"invalid attribute: \" + key",
            "        return self._record[key]",
            "",
            "    def _get_authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        with self._store.engine.connect() as conn:",
            "            result = conn.execute(_SSHKEYS.select(_SSHKEYS.c.userid == self._userid))",
            "            for record in result:",
            "                yield authorizedkeys.check_publickey(record['key'])",
            "",
            "    def get_repo(self, repopath, refresh=False):",
            "        \"\"\"",
            "        Return a repo object.",
            "        \"\"\"",
            "        assert isinstance(repopath, bytes) or isinstance(repopath, str)",
            "        if isinstance(repopath, bytes):",
            "            repopath = os.fsdecode(repopath)",
            "        repopath = repopath.strip('/')",
            "",
            "        if refresh:",
            "            self.refresh_repos()",
            "",
            "        # Search the repo in database",
            "        with self._store.engine.connect() as conn:",
            "            result = conn.execute(_REPOS.select(and_(_REPOS.c.userid == self.userid, _REPOS.c.repopath == repopath)))",
            "            record = result.fetchone()",
            "        if record:",
            "            return RepoObject(self, record)",
            "",
            "        raise DoesNotExistError(self.userid, repopath)",
            "",
            "    def get_repo_objs(self, refresh=False):",
            "        \"\"\"",
            "        Return list of repository object.",
            "        \"\"\"",
            "        if refresh:",
            "            self.refresh_repos()",
            "        with self._store.engine.connect() as conn:",
            "            records = conn.execute(_REPOS.select(_REPOS.c.userid == self._userid).order_by(_REPOS.c.repopath))",
            "            return [RepoObject(self, record) for record in records]",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "",
            "        with self._store.engine.connect() as conn:",
            "",
            "            # Update the repositories by walking in the directory tree.",
            "            def _onerror(unused):",
            "                logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "            dirty = False",
            "            records = list(conn.execute(_REPOS.select(_REPOS.c.userid == self._userid).order_by(_REPOS.c.repopath)))",
            "            user_root = os.fsencode(self.user_root)",
            "            for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "                for name in dirs.copy():",
            "                    if name.startswith(b'.'):",
            "                        dirs.remove(name)",
            "                if b'rdiff-backup-data' in dirs:",
            "                    repopath = os.path.relpath(root, start=user_root)",
            "                    del dirs[:]",
            "                    # Handle special scenario when the repo is the",
            "                    # user_root",
            "                    repopath = b'' if repopath == b'.' else repopath",
            "",
            "                    # Check if repo path exists.",
            "                    record_match = next(",
            "                        (record for record in records if record['repopath'] == os.fsdecode(repopath)), None",
            "                    )",
            "                    if not record_match:",
            "                        # Add repository to database.",
            "                        conn.execute(_REPOS.insert().values(userid=self._userid, repopath=os.fsdecode(repopath)))",
            "                        dirty = True",
            "                    else:",
            "                        records.remove(record_match)",
            "                if root.count(SEP) - user_root.count(SEP) >= self._store._max_depth:",
            "                    del dirs[:]",
            "            # If enabled, remove entried from database",
            "            if delete:",
            "                for record in records:",
            "                    conn.execute(_REPOS.delete(_REPOS.c.repoid == record['repoid']))",
            "        return dirty",
            "",
            "    @property",
            "    def is_ldap(self):",
            "        \"\"\"Return True if this user is an LDAP user. (with a password)\"\"\"",
            "        return not self._get_attr('password')",
            "",
            "    def _is_role(self, role):",
            "        assert role in ROLES.values()",
            "        try:",
            "            return int(self._get_attr('role')) <= role",
            "        except ValueError:",
            "            return False",
            "",
            "    def _set_attr(self, key, new_value, notify=True):",
            "        \"\"\"Used to define an attribute\"\"\"",
            "        assert key in self._ATTRS, \"invalid attribute: \" + key",
            "        # Skip database update if the value is the same",
            "        if self._record[key] == new_value:",
            "            return",
            "        # Update database and object internal state.",
            "        with self._store.engine.connect() as conn:",
            "            updated = conn.execute(_USERS.update().where(_USERS.c.userid == self._userid).values(**{key: new_value}))",
            "            assert updated.rowcount",
            "        old_value = self._record[key]",
            "        self._record[key] = new_value",
            "        # Call notification listener",
            "        if notify:",
            "            self._store.bus.publish('user_attr_changed', self, {key: (old_value, new_value)})",
            "",
            "    def set_password(self, password, old_password=None):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        assert old_password is None or isinstance(old_password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "        cfg = self._store.app.cfg",
            "        if cfg.password_min_length > len(password) > cfg.password_max_length:",
            "            raise ValueError(\"invalid password length\")",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == self._store._admin_user and self._store._admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        if old_password and not check_password(old_password, self.hash_password):",
            "            raise ValueError(_(\"Wrong password\"))",
            "",
            "        logger.info(\"updating user password [%s]\", self.username)",
            "        self.hash_password = hash_password(password)",
            "        self._store.bus.publish('user_password_changed', self)",
            "",
            "    def _set_user_root(self, value):",
            "        \"\"\"",
            "        Used to take care of updating the user_root.",
            "",
            "        When user_root get update, we also want to update the repository list",
            "        to reflect the filesystem.",
            "        \"\"\"",
            "        # Update the value",
            "        self._set_attr('user_root', value)",
            "        # Refresh the list of repository.",
            "        self.refresh_repos()",
            "",
            "    # Declare properties",
            "    userid = property(fget=lambda x: x._userid)",
            "    is_admin = property(fget=lambda x: x._is_role(ADMIN_ROLE))",
            "    is_maintainer = property(fget=lambda x: x._is_role(MAINTAINER_ROLE))",
            "    email = property(fget=lambda x: x._get_attr('email'), fset=lambda x, y: x._set_attr('email', y))",
            "    user_root = property(fget=lambda x: x._get_attr('user_root'), fset=lambda x, y: x._set_user_root(y))",
            "    username = property(fget=lambda x: x._get_attr('username'))",
            "    role = property(fget=lambda x: x._get_attr('role'), fset=lambda x, y: x._set_attr('role', int(y)))",
            "    authorizedkeys = property(fget=lambda x: x._get_authorizedkeys())",
            "    repo_objs = property(fget=lambda x: x.get_repo_objs(refresh=False))",
            "    hash_password = property(",
            "        fget=lambda x: x._get_attr('password'), fset=lambda x, y: x._set_attr('password', y, notify=False)",
            "    )",
            "",
            "",
            "class RepoObject(RdiffRepo):",
            "    \"\"\"Represent a repository.\"\"\"",
            "",
            "    _ATTRS = ['encoding', 'maxage', 'keepdays']",
            "",
            "    def __init__(self, user_obj, data):",
            "        \"\"\"",
            "        Create a new repository object",
            "",
            "        `data` a dict or a SQLAlchemy row.",
            "",
            "        \"\"\"",
            "        assert user_obj",
            "        assert 'repoid' in data",
            "        assert 'repopath' in data",
            "        self._user_obj = user_obj",
            "        self._repoid = data['repoid']",
            "        self._repo = data['repopath']",
            "        self._record = {k: data[k] for k in self._ATTRS}",
            "        RdiffRepo.__init__(self, user_obj.user_root, self._repo, encoding=DEFAULT_REPO_ENCODING)",
            "        self._encoding = self._get_encoding()",
            "",
            "    def __eq__(self, other):",
            "        return (",
            "            isinstance(other, RepoObject)",
            "            and self._user_obj._userid == other._user_obj._userid",
            "            and self._repo == other._repo",
            "        )",
            "",
            "    def __str__(self):",
            "        return 'RepoObject[%s, %s]' % (self._user_obj._userid, self._repo)",
            "",
            "    def _set_attr(self, key, value):",
            "        \"\"\"Used to define an attribute to the repository.\"\"\"",
            "        assert key in self._ATTRS, 'invalid attribute:' + key",
            "        if key in ['maxage', 'keepdays']:",
            "            value = int(value)",
            "        with self._user_obj._store.engine.connect() as conn:",
            "            updated = conn.execute(_REPOS.update().where(_REPOS.c.repoid == self._repoid).values(**{key: value}))",
            "            assert updated.rowcount, 'update failed'",
            "        self._record[key] = value",
            "",
            "    def _get_attr(self, key, default=None):",
            "        assert key in self._ATTRS, 'invalid attribute:' + key",
            "        value = self._record.get(key, default)",
            "        if key in ['maxage', 'keepdays']:",
            "            return int(value) if value else default",
            "        return value",
            "",
            "    @property",
            "    def displayname(self):",
            "        # Repository displayName is the \"repopath\" too.",
            "        return self._repo.strip('/')",
            "",
            "    @property",
            "    def name(self):",
            "        # Repository name is the \"repopath\"",
            "        return self._repo",
            "",
            "    @property",
            "    def owner(self):",
            "        return self._user_obj.username",
            "",
            "    def _get_encoding(self):",
            "        \"\"\"Return the repository encoding in a normalized format (lowercase and replace - by _).\"\"\"",
            "        # For backward compatibility, look into the database and fallback to",
            "        # the rdiffweb config file in the repo.",
            "        encoding = self._get_attr('encoding')",
            "        if encoding:",
            "            return encodings.search_function(encoding.lower())",
            "",
            "        # Fallback to default encoding.",
            "        return encodings.search_function(DEFAULT_REPO_ENCODING)",
            "",
            "    def _set_encoding(self, value):",
            "        \"\"\"Change the repository encoding\"\"\"",
            "        # Validate if the value is a valid encoding before updating the database.",
            "        codec = encodings.search_function(value.lower())",
            "        if not codec:",
            "            raise ValueError(_('invalid encoding %s') % value)",
            "",
            "        logger.info(\"updating repository %s encoding %s\", self, codec.name)",
            "        self._set_attr('encoding', codec.name)",
            "        self._encoding = codec",
            "",
            "    def delete_repo(self):",
            "        \"\"\"Properly remove the given repository by updating the user's repositories.\"\"\"",
            "        logger.info(\"deleting repository %s\", self)",
            "        # Remove data from disk in background",
            "        super().delete_repo()",
            "        # Remove entry from database after deleting files.",
            "        # Otherwise, refresh will add this repo back.",
            "        with self._user_obj._store.engine.connect() as conn:",
            "            conn.execute(_REPOS.delete(_REPOS.c.repoid == self._repoid))",
            "",
            "    encoding = property(lambda x: x._encoding.name, _set_encoding)",
            "    maxage = property(fget=lambda x: x._get_attr('maxage', default=0), fset=lambda x, y: x._set_attr('maxage', y))",
            "    keepdays = property(",
            "        fget=lambda x: x._get_attr('keepdays', default=-1), fset=lambda x, y: x._set_attr('keepdays', y)",
            "    )",
            "",
            "",
            "class Store(SimplePlugin):",
            "    \"\"\"",
            "    This class handle all data storage operations.",
            "    \"\"\"",
            "",
            "    _ldap_add_user = Option(\"ldap_add_missing_user\")",
            "    _ldap_add_user_default_role = Option(\"ldap_add_user_default_role\")",
            "    _ldap_add_user_default_userroot = Option(\"ldap_add_user_default_userroot\")",
            "    _debug = Option('debug')",
            "    _db_uri = Option(\"database_uri\")",
            "    _allow_add_user = Option(\"ldap_add_missing_user\")",
            "    _admin_user = Option(\"admin_user\")",
            "    _admin_password = Option(\"admin_password\")",
            "    _max_depth = Option('max_depth')",
            "",
            "    def __init__(self, app):",
            "        super().__init__(cherrypy.engine)",
            "        self.app = app",
            "        self.app.store = self",
            "        # Connect to database",
            "        uri = self._db_uri if '://' in self._db_uri else \"sqlite:///\" + self._db_uri",
            "        self.engine = create_engine(uri, echo=self._debug)",
            "        # Create tables if missing.",
            "        _META.create_all(self.engine)",
            "        self._update()",
            "        self.bus.subscribe(\"authenticate\", self.authenticate)",
            "        self.bus.subscribe(\"stop\", self.stop)",
            "",
            "    def stop(self):",
            "        self.bus.unsubscribe(\"authenticate\", self.authenticate)",
            "        self.engine.dispose()",
            "",
            "    def create_admin_user(self):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = self.get_user(self._admin_user)",
            "        if not userobj:",
            "            userobj = self.add_user(self._admin_user, 'admin123')",
            "            userobj.role = ADMIN_ROLE",
            "            userobj.user_root = '/backups'",
            "        # Also make sure to update the password with latest value from config file.",
            "        if self._admin_password:",
            "            userobj.hash_password = self._admin_password",
            "            userobj.role = ADMIN_ROLE",
            "",
            "    def add_user(self, user, password=None, attrs=None):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if self.get_user(user):",
            "            raise RdiffError(_(\"User %s already exists.\" % (user,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", user)",
            "        with self.engine.connect() as conn:",
            "            inserted = conn.execute(",
            "                _USERS.insert().values(username=user, password=hash_password(password) if password else '')",
            "            )",
            "            assert inserted.rowcount",
            "            record = conn.execute(_USERS.select(_USERS.c.username == user)).fetchone()",
            "        userobj = UserObject(self, record)",
            "        self.bus.publish('user_added', userobj)",
            "        # Return user object",
            "        return userobj",
            "",
            "    def count_users(self):",
            "        with self.engine.connect() as conn:",
            "            result = conn.execute(select([count('*')]).select_from(_USERS))",
            "            return result.fetchone()[0]",
            "",
            "    def count_repos(self):",
            "        with self.engine.connect() as conn:",
            "            result = conn.execute(select([count('*')]).select_from(_REPOS))",
            "            return result.fetchone()[0]",
            "",
            "    def get_repo(self, name, as_user=None, refresh=False):",
            "        \"\"\"",
            "        Return the repository identified as `name`.",
            "        `name` should be <username>/<repopath>",
            "        \"\"\"",
            "        username, repopath = _split_path(name)",
            "        repopath = os.fsdecode(repopath)",
            "",
            "        # Check permissions",
            "        as_user = as_user or self.app.currentuser",
            "        assert as_user, \"as_user or current user must be defined\"",
            "        if username != as_user.username and not as_user.is_admin:",
            "            raise AccessDeniedError(name)",
            "",
            "        # Get the userid associated to the username.",
            "        user_obj = self.get_user(username)",
            "        if not user_obj:",
            "            raise DoesNotExistError(name)",
            "",
            "        # Get the repo object.",
            "        return user_obj.get_repo(repopath, refresh=refresh)",
            "",
            "    def get_repo_path(self, path, as_user=None, refresh=False):",
            "        \"\"\"",
            "        Return a the repository identified by the given `path`.",
            "        `path` should be <username>/<repopath>/<subdir>",
            "        \"\"\"",
            "        assert isinstance(path, bytes) or isinstance(path, str)",
            "        sep = b'/' if isinstance(path, bytes) else '/'",
            "        path = path.strip(sep) + sep",
            "",
            "        # Since we don't know which part of the \"path\" is the repopath,",
            "        # we need to do multiple search.",
            "        try:",
            "            startpos = 0",
            "            while True:",
            "                pos = path.index(sep, startpos)",
            "                try:",
            "                    # Run refresh only on first run.",
            "                    repo_obj = self.get_repo(path[:pos], as_user, refresh=refresh and startpos == 0)",
            "                    break",
            "                except DoesNotExistError:",
            "                    # Raised when repo doesn't exists",
            "                    startpos = pos + 1",
            "            return repo_obj, path[pos + 1 :]",
            "        except ValueError:",
            "            raise DoesNotExistError(path)",
            "",
            "    def get_user(self, user):",
            "        \"\"\"Return a user object.\"\"\"",
            "        with self.engine.connect() as conn:",
            "            record = conn.execute(_USERS.select(_USERS.c.username == user)).fetchone()",
            "            if record:",
            "                return UserObject(self, record)",
            "        return None",
            "",
            "    def users(self, search=None, criteria=None):",
            "        \"\"\"",
            "        Search users database. Return a generator of user object.",
            "",
            "        search: Define a search term to look into email or username.",
            "        criteria: Define a search filter: admins, ldap",
            "        \"\"\"",
            "        with self.engine.connect() as conn:",
            "            if search:",
            "                term = '%' + search + '%'",
            "                result = conn.execute(",
            "                    _USERS.select().where(or_(_USERS.c.username.like(term), _USERS.c.email.like(term)))",
            "                )",
            "            elif criteria:",
            "                if criteria == 'admins':",
            "                    result = conn.execute(_USERS.select().where(_USERS.c.role == ADMIN_ROLE))",
            "                elif criteria == 'ldap':",
            "                    result = conn.execute(_USERS.select().where(_USERS.c.password == ''))",
            "                else:",
            "                    return []",
            "            else:",
            "                result = conn.execute(_USERS.select())",
            "            # return users",
            "            return [UserObject(self, record) for record in result]",
            "",
            "    def repos(self, search=None, criteria=None):",
            "        \"\"\"",
            "        Quick listing of all the repository object for all user.",
            "",
            "        search: Define a search term to look into path, email or username.",
            "        criteria: Define a search filter: ok, failed, interrupted, in_progress",
            "        \"\"\"",
            "        with self.engine.connect() as conn:",
            "            if search:",
            "                result = conn.execute(",
            "                    select([_REPOS, _USERS])",
            "                    .where(_USERS.c.userid == _REPOS.c.userid)",
            "                    .where(",
            "                        or_(",
            "                            _USERS.c.username.contains(search),",
            "                            _USERS.c.email.contains(search),",
            "                            _REPOS.c.repopath.contains(search),",
            "                        )",
            "                    )",
            "                )",
            "            else:",
            "                result = conn.execute(select([_REPOS, _USERS]).where(_USERS.c.userid == _REPOS.c.userid))",
            "            for record in result:",
            "                user_obj = UserObject(self, record)",
            "                repo_obj = RepoObject(user_obj, record)",
            "                if not criteria or criteria == repo_obj.status[0]:",
            "                    yield repo_obj",
            "",
            "    def login(self, username, password):",
            "        \"\"\"",
            "        Verify the user's crendentials with authentication plugins.",
            "        Then create the user in database if required.",
            "        \"\"\"",
            "        assert isinstance(username, str)",
            "        assert password is None or isinstance(username, str)",
            "        authenticates = self.bus.publish('authenticate', username, password)",
            "        authenticates = [a for a in authenticates if a]",
            "        if not authenticates:",
            "            return None",
            "        real_username = authenticates[0][0]",
            "        extra_attrs = authenticates[0][1]",
            "",
            "        # When enabled, create missing userobj in database.",
            "        userobj = self.get_user(real_username)",
            "        if userobj is None and self._ldap_add_user:",
            "            try:",
            "                # At this point, we need to create a new user in database.",
            "                # In case default values are invalid, let evaluate them",
            "                # before creating the user in database.",
            "                default_user_root = self._ldap_add_user_default_userroot.format(**extra_attrs)",
            "                default_role = ROLES.get(self._ldap_add_user_default_role)",
            "                userobj = self.add_user(real_username, attrs=extra_attrs)",
            "                userobj.user_root = default_user_root",
            "                userobj.role = default_role",
            "                # Populate the email attribute using LDAP mail attribute.",
            "                # Default to empty string to respect database integrity.",
            "                userobj.email = next(iter(extra_attrs.get('mail', [])), '')",
            "            except Exception:",
            "                logger.warning('fail to create new user', exc_info=1)",
            "        self.bus.publish('user_login', userobj)",
            "        return userobj",
            "",
            "    def authenticate(self, user, password):",
            "        \"\"\"",
            "        Called to authenticate the given user.",
            "",
            "        Return False if credentials cannot be validated. Otherwise return a",
            "        tuple with username and user attributes.",
            "        \"\"\"",
            "        assert isinstance(user, str)",
            "        assert password is None or isinstance(user, str)",
            "        # Validate credential using database first.",
            "        logger.debug(\"validating user [%s] credentials\", user)",
            "        userobj = self.get_user(user)",
            "        if userobj and userobj.hash_password:",
            "            if check_password(password, userobj.hash_password):",
            "                return userobj.username, {}",
            "        return False",
            "",
            "    def _update(self):",
            "        \"\"\"",
            "        Called on startup to update database schema.",
            "        \"\"\"",
            "        with self.engine.connect() as conn:",
            "            # Remove preceding and leading slash (/) generated by previous",
            "            # versions. Also rename '.' to ''",
            "            reult = conn.execute(_REPOS.select())",
            "            for row in reult:",
            "                if row['repopath'].startswith('/') or row['repopath'].endswith('/'):",
            "                    conn.execute(",
            "                        _REPOS.update()",
            "                        .where(_REPOS.c.repoid == row['repoid'])",
            "                        .values(repopath=row['repopath'].strip('/'))",
            "                    )",
            "                if row['repopath'] == '.':",
            "                    conn.execute(_REPOS.update().where(_REPOS.c.repoid == row['repoid']).values(repopath=''))",
            "",
            "            # Remove duplicates and nested repositories.",
            "            reult = conn.execute(_REPOS.select().order_by(_REPOS.c.userid, _REPOS.c.repopath))",
            "            prev_repo = (None, None)",
            "            for row in reult:",
            "                if prev_repo[0] == row['userid'] and (",
            "                    prev_repo[1] == row['repopath'] or row['repopath'].startswith(prev_repo[1] + '/')",
            "                ):",
            "                    conn.execute(_REPOS.delete(_REPOS.c.repoid == row['repoid']))",
            "                else:",
            "                    prev_repo = (row['userid'], row['repopath'])"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# rdiffweb, A web interface to rdiff-backup repositories",
            "# Copyright (C) 2012-2021 rdiffweb contributors",
            "#",
            "# This program is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with this program.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "import codecs",
            "import encodings",
            "import logging",
            "import os",
            "import sys",
            "from io import open",
            "",
            "import cherrypy",
            "from cherrypy.process.plugins import SimplePlugin",
            "from sqlalchemy import Column, Integer, MetaData, SmallInteger, String, Table, Text, create_engine",
            "from sqlalchemy.exc import IntegrityError",
            "from sqlalchemy.sql.expression import and_, or_, select",
            "from sqlalchemy.sql.functions import count",
            "from zxcvbn import zxcvbn",
            "",
            "from rdiffweb.core import RdiffError, authorizedkeys",
            "from rdiffweb.core.config import Option",
            "from rdiffweb.core.librdiff import AccessDeniedError, DoesNotExistError, RdiffRepo",
            "from rdiffweb.core.passwd import check_password, hash_password",
            "from rdiffweb.tools.i18n import ugettext as _",
            "",
            "# Define the logger",
            "logger = logging.getLogger(__name__)",
            "",
            "SEP = b'/'",
            "",
            "DEFAULT_REPO_ENCODING = codecs.lookup((sys.getfilesystemencoding() or 'utf-8').lower()).name",
            "",
            "# Define roles",
            "ADMIN_ROLE = 0",
            "MAINTAINER_ROLE = 5",
            "USER_ROLE = 10",
            "ROLES = {",
            "    'admin': ADMIN_ROLE,",
            "    'maintainer': MAINTAINER_ROLE,",
            "    'user': USER_ROLE,",
            "}",
            "",
            "# Define SQLAlchemy metadata",
            "_META = MetaData()",
            "_USERS = Table(",
            "    'users',",
            "    _META,",
            "    Column('UserID', Integer, key='userid', primary_key=True),",
            "    Column('Username', String, key='username', nullable=False, unique=True),",
            "    Column('Password', String, key='password', nullable=False, server_default=\"\"),",
            "    Column('UserRoot', String, key='user_root', nullable=False, server_default=\"\"),",
            "    Column(",
            "        'IsAdmin',",
            "        SmallInteger,",
            "        key='is_admin',",
            "        nullable=False,",
            "        server_default=\"0\",",
            "        doc=\"DEPRECATED This column is replaced by 'role'\",",
            "    ),",
            "    Column('UserEmail', String, key='email', nullable=False, server_default=\"\"),",
            "    Column(",
            "        'RestoreFormat',",
            "        SmallInteger,",
            "        nullable=False,",
            "        server_default=\"1\",",
            "        doc=\"DEPRECATED This column is not used anymore\",",
            "    ),",
            "    Column('role', SmallInteger, nullable=False, server_default=str(USER_ROLE)),",
            "    sqlite_autoincrement=True,",
            ")",
            "",
            "_REPOS = Table(",
            "    'repos',",
            "    _META,",
            "    Column('RepoID', Integer, key='repoid', primary_key=True, autoincrement=True),",
            "    Column('UserID', Integer, key='userid', nullable=False),",
            "    Column('RepoPath', String, key='repopath', nullable=False),",
            "    Column('MaxAge', SmallInteger, key='maxage', nullable=False, server_default=\"0\"),",
            "    Column('Encoding', String, key='encoding'),",
            "    Column('keepdays', String, nullable=False, server_default=\"\"),",
            "    sqlite_autoincrement=True,",
            ")",
            "",
            "_SSHKEYS = Table(",
            "    'sshkeys',",
            "    _META,",
            "    Column('Fingerprint', Text, key='fingerprint'),",
            "    Column('Key', Text, key='key', unique=True),",
            "    Column('UserID', Integer, key='userid', nullable=False),",
            ")",
            "",
            "",
            "def _split_path(path):",
            "    \"\"\"",
            "    Split the given path into <username as str> / <path as bytes>",
            "    \"\"\"",
            "    # First part is the username",
            "    assert path",
            "    if isinstance(path, str):",
            "        path = os.fsencode(path)",
            "    path = path.strip(b'/')",
            "    if b'/' in path:",
            "        username, path = path.split(b'/', 1)",
            "        return username.decode('utf-8'), path",
            "    else:",
            "        return path.decode('utf-8'), b''",
            "",
            "",
            "class DuplicateSSHKeyError(Exception):",
            "    \"\"\"",
            "    Raised by add_authorizedkey when trying to add the same SSH Key twice.",
            "    \"\"\"",
            "",
            "    pass",
            "",
            "",
            "class UserObject(object):",
            "    \"\"\"Represent an instance of user.\"\"\"",
            "",
            "    _ATTRS = ['username', 'role', 'email', 'user_root', 'password']",
            "",
            "    def __init__(self, store, data):",
            "        \"\"\"",
            "        Create a new UserObject from a username or a record.",
            "",
            "        `data` a dict or a SQLAlchemy row.",
            "",
            "        \"\"\"",
            "        assert store",
            "        assert 'userid' in data",
            "        self._store = store",
            "        self._record = {k: data[k] for k in self._ATTRS}",
            "        self._userid = data[_USERS.c.userid]",
            "",
            "    def add_authorizedkey(self, key, comment=None):",
            "        \"\"\"",
            "        Add the given key to the user. Adding the key to his `authorized_keys`",
            "        file if it exists and adding it to database.",
            "        \"\"\"",
            "        # Parse and validate ssh key",
            "        assert key",
            "        key = authorizedkeys.check_publickey(key)",
            "",
            "        # Remove option, replace comments.",
            "        key = authorizedkeys.AuthorizedKey(",
            "            options=None, keytype=key.keytype, key=key.key, comment=comment or key.comment",
            "        )",
            "",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode=\"r+\", encoding='utf-8') as fh:",
            "                if authorizedkeys.exists(fh, key):",
            "                    raise DuplicateSSHKeyError(_(\"SSH key already exists\"))",
            "                logger.info(\"add key [%s] to [%s] authorized_keys\", key, self.username)",
            "                authorizedkeys.add(fh, key)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"add key [%s] to [%s] database\", key, self.username)",
            "            try:",
            "                with self._store.engine.connect() as conn:",
            "                    conn.execute(",
            "                        _SSHKEYS.insert().values(userid=self._userid, fingerprint=key.fingerprint, key=key.getvalue())",
            "                    )",
            "            except IntegrityError:",
            "                raise DuplicateSSHKeyError(",
            "                    _(\"Duplicate key. This key already exists or is associated to another user.\")",
            "                )",
            "        self._store.bus.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    def valid_user_root(self):",
            "        \"\"\"",
            "        Check if the current user_root is valid and readable",
            "        \"\"\"",
            "        try:",
            "            return os.access(self.user_root, os.F_OK) and os.path.isdir(self.user_root)",
            "        except Exception:",
            "            return False",
            "",
            "    def delete(self):",
            "        \"\"\"",
            "        Delete the given user from password store.",
            "",
            "        Return True if the user was deleted.",
            "        Return False if the user didn't exists.",
            "        Raise a ValueError when trying to delete the admin user.",
            "        \"\"\"",
            "        # Make sure we are not trying to delete the admin user.",
            "        if self.username == self._store._admin_user:",
            "            raise ValueError(_(\"can't delete admin user\"))",
            "",
            "        # Delete user from database (required).",
            "        logger.info(\"deleting user [%s] from database\", self.username)",
            "        with self._store.engine.connect() as conn:",
            "            conn.execute(_SSHKEYS.delete(_SSHKEYS.c.userid == self._userid))",
            "            conn.execute(_REPOS.delete(_REPOS.c.userid == self._userid))",
            "            deleted = conn.execute(_USERS.delete(_USERS.c.userid == self._userid))",
            "            assert deleted.rowcount, 'fail to delete user'",
            "        self._store.bus.publish('user_deleted', self.username)",
            "        return True",
            "",
            "    def delete_authorizedkey(self, fingerprint):",
            "        \"\"\"",
            "        Remove the given key from the user. Remove the key from his",
            "        `authorized_keys` file if it exists and from database database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            with open(filename, mode='r+', encoding='utf-8') as fh:",
            "                logger.info(\"removing key [%s] from [%s] authorized_keys\", fingerprint, self.username)",
            "                authorizedkeys.remove(fh, fingerprint)",
            "        else:",
            "            # Also look in database.",
            "            logger.info(\"removing key [%s] from [%s] database\", fingerprint, self.username)",
            "            with self._store.engine.connect() as conn:",
            "                conn.execute(",
            "                    _SSHKEYS.delete(and_(_SSHKEYS.c.userid == self._userid, _SSHKEYS.c.fingerprint == fingerprint))",
            "                )",
            "        self._store.bus.publish('user_attr_changed', self, {'authorizedkeys': True})",
            "",
            "    @property",
            "    def disk_usage(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = self._store.bus.publish('get_disk_usage', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @property",
            "    def disk_quota(self):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return 0",
            "        values = self._store.bus.publish('get_disk_quota', self)",
            "        # Return the first not None value",
            "        return next((v for v in values if v is not None), 0)",
            "",
            "    @disk_quota.setter",
            "    def disk_quota(self, value):",
            "        # Skip if user_root is invalid.",
            "        if not self.user_root or not os.path.exists(self.user_root):",
            "            return",
            "        self._store.bus.publish('set_disk_quota', self, value)",
            "",
            "    def __eq__(self, other):",
            "        return isinstance(other, UserObject) and self._userid == other._userid",
            "",
            "    def __str__(self):",
            "        return 'UserObject(%s)' % self._userid",
            "",
            "    def _get_attr(self, key):",
            "        \"\"\"Return user's attribute\"\"\"",
            "        assert key in self._ATTRS, \"invalid attribute: \" + key",
            "        return self._record[key]",
            "",
            "    def _get_authorizedkeys(self):",
            "        \"\"\"",
            "        Return an iterator on the authorized key. Either from his",
            "        `authorized_keys` file if it exists or from database.",
            "        \"\"\"",
            "        # If a filename exists, use it by default.",
            "        filename = os.path.join(self.user_root, '.ssh', 'authorized_keys')",
            "        if os.path.isfile(filename):",
            "            for k in authorizedkeys.read(filename):",
            "                yield k",
            "",
            "        # Also look in database.",
            "        with self._store.engine.connect() as conn:",
            "            result = conn.execute(_SSHKEYS.select(_SSHKEYS.c.userid == self._userid))",
            "            for record in result:",
            "                yield authorizedkeys.check_publickey(record['key'])",
            "",
            "    def get_repo(self, repopath, refresh=False):",
            "        \"\"\"",
            "        Return a repo object.",
            "        \"\"\"",
            "        assert isinstance(repopath, bytes) or isinstance(repopath, str)",
            "        if isinstance(repopath, bytes):",
            "            repopath = os.fsdecode(repopath)",
            "        repopath = repopath.strip('/')",
            "",
            "        if refresh:",
            "            self.refresh_repos()",
            "",
            "        # Search the repo in database",
            "        with self._store.engine.connect() as conn:",
            "            result = conn.execute(_REPOS.select(and_(_REPOS.c.userid == self.userid, _REPOS.c.repopath == repopath)))",
            "            record = result.fetchone()",
            "        if record:",
            "            return RepoObject(self, record)",
            "",
            "        raise DoesNotExistError(self.userid, repopath)",
            "",
            "    def get_repo_objs(self, refresh=False):",
            "        \"\"\"",
            "        Return list of repository object.",
            "        \"\"\"",
            "        if refresh:",
            "            self.refresh_repos()",
            "        with self._store.engine.connect() as conn:",
            "            records = conn.execute(_REPOS.select(_REPOS.c.userid == self._userid).order_by(_REPOS.c.repopath))",
            "            return [RepoObject(self, record) for record in records]",
            "",
            "    def refresh_repos(self, delete=False):",
            "        \"\"\"",
            "        Return list of repositories object to reflect the filesystem folders.",
            "",
            "        Return a RepoObject for each sub directories under `user_root` with `rdiff-backup-data`.",
            "        \"\"\"",
            "",
            "        with self._store.engine.connect() as conn:",
            "",
            "            # Update the repositories by walking in the directory tree.",
            "            def _onerror(unused):",
            "                logger.error('error updating user [%s] repos' % self.username, exc_info=1)",
            "",
            "            dirty = False",
            "            records = list(conn.execute(_REPOS.select(_REPOS.c.userid == self._userid).order_by(_REPOS.c.repopath)))",
            "            user_root = os.fsencode(self.user_root)",
            "            for root, dirs, unused_files in os.walk(user_root, _onerror):",
            "                for name in dirs.copy():",
            "                    if name.startswith(b'.'):",
            "                        dirs.remove(name)",
            "                if b'rdiff-backup-data' in dirs:",
            "                    repopath = os.path.relpath(root, start=user_root)",
            "                    del dirs[:]",
            "                    # Handle special scenario when the repo is the",
            "                    # user_root",
            "                    repopath = b'' if repopath == b'.' else repopath",
            "",
            "                    # Check if repo path exists.",
            "                    record_match = next(",
            "                        (record for record in records if record['repopath'] == os.fsdecode(repopath)), None",
            "                    )",
            "                    if not record_match:",
            "                        # Add repository to database.",
            "                        conn.execute(_REPOS.insert().values(userid=self._userid, repopath=os.fsdecode(repopath)))",
            "                        dirty = True",
            "                    else:",
            "                        records.remove(record_match)",
            "                if root.count(SEP) - user_root.count(SEP) >= self._store._max_depth:",
            "                    del dirs[:]",
            "            # If enabled, remove entried from database",
            "            if delete:",
            "                for record in records:",
            "                    conn.execute(_REPOS.delete(_REPOS.c.repoid == record['repoid']))",
            "        return dirty",
            "",
            "    @property",
            "    def is_ldap(self):",
            "        \"\"\"Return True if this user is an LDAP user. (with a password)\"\"\"",
            "        return not self._get_attr('password')",
            "",
            "    def _is_role(self, role):",
            "        assert role in ROLES.values()",
            "        try:",
            "            return int(self._get_attr('role')) <= role",
            "        except ValueError:",
            "            return False",
            "",
            "    def _set_attr(self, key, new_value, notify=True):",
            "        \"\"\"Used to define an attribute\"\"\"",
            "        assert key in self._ATTRS, \"invalid attribute: \" + key",
            "        # Skip database update if the value is the same",
            "        if self._record[key] == new_value:",
            "            return",
            "        # Update database and object internal state.",
            "        with self._store.engine.connect() as conn:",
            "            updated = conn.execute(_USERS.update().where(_USERS.c.userid == self._userid).values(**{key: new_value}))",
            "            assert updated.rowcount",
            "        old_value = self._record[key]",
            "        self._record[key] = new_value",
            "        # Call notification listener",
            "        if notify:",
            "            self._store.bus.publish('user_attr_changed', self, {key: (old_value, new_value)})",
            "",
            "    def set_password(self, password, old_password=None):",
            "        \"\"\"",
            "        Change the user's password. Raise a ValueError if the username or",
            "        the password are invalid.",
            "        \"\"\"",
            "        assert isinstance(password, str)",
            "        assert old_password is None or isinstance(old_password, str)",
            "        if not password:",
            "            raise ValueError(\"password can't be empty\")",
            "",
            "        # Cannot update admin-password if defined",
            "        if self.username == self._store._admin_user and self._store._admin_password:",
            "            raise ValueError(_(\"can't update admin-password defined in configuration file\"))",
            "",
            "        # Check current password",
            "        if old_password and not check_password(old_password, self.hash_password):",
            "            raise ValueError(_(\"Wrong password\"))",
            "",
            "        # Check password length",
            "        cfg = self._store.app.cfg",
            "        if cfg.password_min_length > len(password) or len(password) > cfg.password_max_length:",
            "            raise ValueError(",
            "                _('Password must have between %(min)d and %(max)d characters.')",
            "                % {'min': cfg.password_min_length, 'max': cfg.password_max_length}",
            "            )",
            "",
            "        # Verify password score using zxcvbn",
            "        stats = zxcvbn(password)",
            "        if stats.get('score') < cfg.password_score:",
            "            msg = _('Password too weak.')",
            "            warning = stats.get('feedback', {}).get('warning')",
            "            suggestions = stats.get('feedback', {}).get('suggestions')",
            "            if warning:",
            "                msg += ' ' + warning",
            "            if suggestions:",
            "                msg += ' ' + ' '.join(suggestions)",
            "            raise ValueError(msg)",
            "",
            "        logger.info(\"updating user password [%s]\", self.username)",
            "        self.hash_password = hash_password(password)",
            "        self._store.bus.publish('user_password_changed', self)",
            "",
            "    def _set_user_root(self, value):",
            "        \"\"\"",
            "        Used to take care of updating the user_root.",
            "",
            "        When user_root get update, we also want to update the repository list",
            "        to reflect the filesystem.",
            "        \"\"\"",
            "        # Update the value",
            "        self._set_attr('user_root', value)",
            "        # Refresh the list of repository.",
            "        self.refresh_repos()",
            "",
            "    # Declare properties",
            "    userid = property(fget=lambda x: x._userid)",
            "    is_admin = property(fget=lambda x: x._is_role(ADMIN_ROLE))",
            "    is_maintainer = property(fget=lambda x: x._is_role(MAINTAINER_ROLE))",
            "    email = property(fget=lambda x: x._get_attr('email'), fset=lambda x, y: x._set_attr('email', y))",
            "    user_root = property(fget=lambda x: x._get_attr('user_root'), fset=lambda x, y: x._set_user_root(y))",
            "    username = property(fget=lambda x: x._get_attr('username'))",
            "    role = property(fget=lambda x: x._get_attr('role'), fset=lambda x, y: x._set_attr('role', int(y)))",
            "    authorizedkeys = property(fget=lambda x: x._get_authorizedkeys())",
            "    repo_objs = property(fget=lambda x: x.get_repo_objs(refresh=False))",
            "    hash_password = property(",
            "        fget=lambda x: x._get_attr('password'), fset=lambda x, y: x._set_attr('password', y, notify=False)",
            "    )",
            "",
            "",
            "class RepoObject(RdiffRepo):",
            "    \"\"\"Represent a repository.\"\"\"",
            "",
            "    _ATTRS = ['encoding', 'maxage', 'keepdays']",
            "",
            "    def __init__(self, user_obj, data):",
            "        \"\"\"",
            "        Create a new repository object",
            "",
            "        `data` a dict or a SQLAlchemy row.",
            "",
            "        \"\"\"",
            "        assert user_obj",
            "        assert 'repoid' in data",
            "        assert 'repopath' in data",
            "        self._user_obj = user_obj",
            "        self._repoid = data['repoid']",
            "        self._repo = data['repopath']",
            "        self._record = {k: data[k] for k in self._ATTRS}",
            "        RdiffRepo.__init__(self, user_obj.user_root, self._repo, encoding=DEFAULT_REPO_ENCODING)",
            "        self._encoding = self._get_encoding()",
            "",
            "    def __eq__(self, other):",
            "        return (",
            "            isinstance(other, RepoObject)",
            "            and self._user_obj._userid == other._user_obj._userid",
            "            and self._repo == other._repo",
            "        )",
            "",
            "    def __str__(self):",
            "        return 'RepoObject[%s, %s]' % (self._user_obj._userid, self._repo)",
            "",
            "    def _set_attr(self, key, value):",
            "        \"\"\"Used to define an attribute to the repository.\"\"\"",
            "        assert key in self._ATTRS, 'invalid attribute:' + key",
            "        if key in ['maxage', 'keepdays']:",
            "            value = int(value)",
            "        with self._user_obj._store.engine.connect() as conn:",
            "            updated = conn.execute(_REPOS.update().where(_REPOS.c.repoid == self._repoid).values(**{key: value}))",
            "            assert updated.rowcount, 'update failed'",
            "        self._record[key] = value",
            "",
            "    def _get_attr(self, key, default=None):",
            "        assert key in self._ATTRS, 'invalid attribute:' + key",
            "        value = self._record.get(key, default)",
            "        if key in ['maxage', 'keepdays']:",
            "            return int(value) if value else default",
            "        return value",
            "",
            "    @property",
            "    def displayname(self):",
            "        # Repository displayName is the \"repopath\" too.",
            "        return self._repo.strip('/')",
            "",
            "    @property",
            "    def name(self):",
            "        # Repository name is the \"repopath\"",
            "        return self._repo",
            "",
            "    @property",
            "    def owner(self):",
            "        return self._user_obj.username",
            "",
            "    def _get_encoding(self):",
            "        \"\"\"Return the repository encoding in a normalized format (lowercase and replace - by _).\"\"\"",
            "        # For backward compatibility, look into the database and fallback to",
            "        # the rdiffweb config file in the repo.",
            "        encoding = self._get_attr('encoding')",
            "        if encoding:",
            "            return encodings.search_function(encoding.lower())",
            "",
            "        # Fallback to default encoding.",
            "        return encodings.search_function(DEFAULT_REPO_ENCODING)",
            "",
            "    def _set_encoding(self, value):",
            "        \"\"\"Change the repository encoding\"\"\"",
            "        # Validate if the value is a valid encoding before updating the database.",
            "        codec = encodings.search_function(value.lower())",
            "        if not codec:",
            "            raise ValueError(_('invalid encoding %s') % value)",
            "",
            "        logger.info(\"updating repository %s encoding %s\", self, codec.name)",
            "        self._set_attr('encoding', codec.name)",
            "        self._encoding = codec",
            "",
            "    def delete_repo(self):",
            "        \"\"\"Properly remove the given repository by updating the user's repositories.\"\"\"",
            "        logger.info(\"deleting repository %s\", self)",
            "        # Remove data from disk in background",
            "        super().delete_repo()",
            "        # Remove entry from database after deleting files.",
            "        # Otherwise, refresh will add this repo back.",
            "        with self._user_obj._store.engine.connect() as conn:",
            "            conn.execute(_REPOS.delete(_REPOS.c.repoid == self._repoid))",
            "",
            "    encoding = property(lambda x: x._encoding.name, _set_encoding)",
            "    maxage = property(fget=lambda x: x._get_attr('maxage', default=0), fset=lambda x, y: x._set_attr('maxage', y))",
            "    keepdays = property(",
            "        fget=lambda x: x._get_attr('keepdays', default=-1), fset=lambda x, y: x._set_attr('keepdays', y)",
            "    )",
            "",
            "",
            "class Store(SimplePlugin):",
            "    \"\"\"",
            "    This class handle all data storage operations.",
            "    \"\"\"",
            "",
            "    _ldap_add_user = Option(\"ldap_add_missing_user\")",
            "    _ldap_add_user_default_role = Option(\"ldap_add_user_default_role\")",
            "    _ldap_add_user_default_userroot = Option(\"ldap_add_user_default_userroot\")",
            "    _debug = Option('debug')",
            "    _db_uri = Option(\"database_uri\")",
            "    _allow_add_user = Option(\"ldap_add_missing_user\")",
            "    _admin_user = Option(\"admin_user\")",
            "    _admin_password = Option(\"admin_password\")",
            "    _max_depth = Option('max_depth')",
            "",
            "    def __init__(self, app):",
            "        super().__init__(cherrypy.engine)",
            "        self.app = app",
            "        self.app.store = self",
            "        # Connect to database",
            "        uri = self._db_uri if '://' in self._db_uri else \"sqlite:///\" + self._db_uri",
            "        self.engine = create_engine(uri, echo=self._debug)",
            "        # Create tables if missing.",
            "        _META.create_all(self.engine)",
            "        self._update()",
            "        self.bus.subscribe(\"authenticate\", self.authenticate)",
            "        self.bus.subscribe(\"stop\", self.stop)",
            "",
            "    def stop(self):",
            "        self.bus.unsubscribe(\"authenticate\", self.authenticate)",
            "        self.engine.dispose()",
            "",
            "    def create_admin_user(self):",
            "        # Check if admin user exists. If not, created it.",
            "        userobj = self.get_user(self._admin_user)",
            "        if not userobj:",
            "            userobj = self.add_user(self._admin_user, 'admin123')",
            "            userobj.role = ADMIN_ROLE",
            "            userobj.user_root = '/backups'",
            "        # Also make sure to update the password with latest value from config file.",
            "        if self._admin_password:",
            "            userobj.hash_password = self._admin_password",
            "            userobj.role = ADMIN_ROLE",
            "",
            "    def add_user(self, user, password=None, attrs=None):",
            "        \"\"\"",
            "        Used to add a new user with an optional password.",
            "        \"\"\"",
            "        assert password is None or isinstance(password, str)",
            "        # Check if user already exists.",
            "        if self.get_user(user):",
            "            raise RdiffError(_(\"User %s already exists.\" % (user,)))",
            "",
            "        # Find a database where to add the user",
            "        logger.info(\"adding new user [%s]\", user)",
            "        with self.engine.connect() as conn:",
            "            inserted = conn.execute(",
            "                _USERS.insert().values(username=user, password=hash_password(password) if password else '')",
            "            )",
            "            assert inserted.rowcount",
            "            record = conn.execute(_USERS.select(_USERS.c.username == user)).fetchone()",
            "        userobj = UserObject(self, record)",
            "        self.bus.publish('user_added', userobj)",
            "        # Return user object",
            "        return userobj",
            "",
            "    def count_users(self):",
            "        with self.engine.connect() as conn:",
            "            result = conn.execute(select([count('*')]).select_from(_USERS))",
            "            return result.fetchone()[0]",
            "",
            "    def count_repos(self):",
            "        with self.engine.connect() as conn:",
            "            result = conn.execute(select([count('*')]).select_from(_REPOS))",
            "            return result.fetchone()[0]",
            "",
            "    def get_repo(self, name, as_user=None, refresh=False):",
            "        \"\"\"",
            "        Return the repository identified as `name`.",
            "        `name` should be <username>/<repopath>",
            "        \"\"\"",
            "        username, repopath = _split_path(name)",
            "        repopath = os.fsdecode(repopath)",
            "",
            "        # Check permissions",
            "        as_user = as_user or self.app.currentuser",
            "        assert as_user, \"as_user or current user must be defined\"",
            "        if username != as_user.username and not as_user.is_admin:",
            "            raise AccessDeniedError(name)",
            "",
            "        # Get the userid associated to the username.",
            "        user_obj = self.get_user(username)",
            "        if not user_obj:",
            "            raise DoesNotExistError(name)",
            "",
            "        # Get the repo object.",
            "        return user_obj.get_repo(repopath, refresh=refresh)",
            "",
            "    def get_repo_path(self, path, as_user=None, refresh=False):",
            "        \"\"\"",
            "        Return a the repository identified by the given `path`.",
            "        `path` should be <username>/<repopath>/<subdir>",
            "        \"\"\"",
            "        assert isinstance(path, bytes) or isinstance(path, str)",
            "        sep = b'/' if isinstance(path, bytes) else '/'",
            "        path = path.strip(sep) + sep",
            "",
            "        # Since we don't know which part of the \"path\" is the repopath,",
            "        # we need to do multiple search.",
            "        try:",
            "            startpos = 0",
            "            while True:",
            "                pos = path.index(sep, startpos)",
            "                try:",
            "                    # Run refresh only on first run.",
            "                    repo_obj = self.get_repo(path[:pos], as_user, refresh=refresh and startpos == 0)",
            "                    break",
            "                except DoesNotExistError:",
            "                    # Raised when repo doesn't exists",
            "                    startpos = pos + 1",
            "            return repo_obj, path[pos + 1 :]",
            "        except ValueError:",
            "            raise DoesNotExistError(path)",
            "",
            "    def get_user(self, user):",
            "        \"\"\"Return a user object.\"\"\"",
            "        with self.engine.connect() as conn:",
            "            record = conn.execute(_USERS.select(_USERS.c.username == user)).fetchone()",
            "            if record:",
            "                return UserObject(self, record)",
            "        return None",
            "",
            "    def users(self, search=None, criteria=None):",
            "        \"\"\"",
            "        Search users database. Return a generator of user object.",
            "",
            "        search: Define a search term to look into email or username.",
            "        criteria: Define a search filter: admins, ldap",
            "        \"\"\"",
            "        with self.engine.connect() as conn:",
            "            if search:",
            "                term = '%' + search + '%'",
            "                result = conn.execute(",
            "                    _USERS.select().where(or_(_USERS.c.username.like(term), _USERS.c.email.like(term)))",
            "                )",
            "            elif criteria:",
            "                if criteria == 'admins':",
            "                    result = conn.execute(_USERS.select().where(_USERS.c.role == ADMIN_ROLE))",
            "                elif criteria == 'ldap':",
            "                    result = conn.execute(_USERS.select().where(_USERS.c.password == ''))",
            "                else:",
            "                    return []",
            "            else:",
            "                result = conn.execute(_USERS.select())",
            "            # return users",
            "            return [UserObject(self, record) for record in result]",
            "",
            "    def repos(self, search=None, criteria=None):",
            "        \"\"\"",
            "        Quick listing of all the repository object for all user.",
            "",
            "        search: Define a search term to look into path, email or username.",
            "        criteria: Define a search filter: ok, failed, interrupted, in_progress",
            "        \"\"\"",
            "        with self.engine.connect() as conn:",
            "            if search:",
            "                result = conn.execute(",
            "                    select([_REPOS, _USERS])",
            "                    .where(_USERS.c.userid == _REPOS.c.userid)",
            "                    .where(",
            "                        or_(",
            "                            _USERS.c.username.contains(search),",
            "                            _USERS.c.email.contains(search),",
            "                            _REPOS.c.repopath.contains(search),",
            "                        )",
            "                    )",
            "                )",
            "            else:",
            "                result = conn.execute(select([_REPOS, _USERS]).where(_USERS.c.userid == _REPOS.c.userid))",
            "            for record in result:",
            "                user_obj = UserObject(self, record)",
            "                repo_obj = RepoObject(user_obj, record)",
            "                if not criteria or criteria == repo_obj.status[0]:",
            "                    yield repo_obj",
            "",
            "    def login(self, username, password):",
            "        \"\"\"",
            "        Verify the user's crendentials with authentication plugins.",
            "        Then create the user in database if required.",
            "        \"\"\"",
            "        assert isinstance(username, str)",
            "        assert password is None or isinstance(username, str)",
            "        authenticates = self.bus.publish('authenticate', username, password)",
            "        authenticates = [a for a in authenticates if a]",
            "        if not authenticates:",
            "            return None",
            "        real_username = authenticates[0][0]",
            "        extra_attrs = authenticates[0][1]",
            "",
            "        # When enabled, create missing userobj in database.",
            "        userobj = self.get_user(real_username)",
            "        if userobj is None and self._ldap_add_user:",
            "            try:",
            "                # At this point, we need to create a new user in database.",
            "                # In case default values are invalid, let evaluate them",
            "                # before creating the user in database.",
            "                default_user_root = self._ldap_add_user_default_userroot.format(**extra_attrs)",
            "                default_role = ROLES.get(self._ldap_add_user_default_role)",
            "                userobj = self.add_user(real_username, attrs=extra_attrs)",
            "                userobj.user_root = default_user_root",
            "                userobj.role = default_role",
            "                # Populate the email attribute using LDAP mail attribute.",
            "                # Default to empty string to respect database integrity.",
            "                userobj.email = next(iter(extra_attrs.get('mail', [])), '')",
            "            except Exception:",
            "                logger.warning('fail to create new user', exc_info=1)",
            "        self.bus.publish('user_login', userobj)",
            "        return userobj",
            "",
            "    def authenticate(self, user, password):",
            "        \"\"\"",
            "        Called to authenticate the given user.",
            "",
            "        Return False if credentials cannot be validated. Otherwise return a",
            "        tuple with username and user attributes.",
            "        \"\"\"",
            "        assert isinstance(user, str)",
            "        assert password is None or isinstance(user, str)",
            "        # Validate credential using database first.",
            "        logger.debug(\"validating user [%s] credentials\", user)",
            "        userobj = self.get_user(user)",
            "        if userobj and userobj.hash_password:",
            "            if check_password(password, userobj.hash_password):",
            "                return userobj.username, {}",
            "        return False",
            "",
            "    def _update(self):",
            "        \"\"\"",
            "        Called on startup to update database schema.",
            "        \"\"\"",
            "        with self.engine.connect() as conn:",
            "            # Remove preceding and leading slash (/) generated by previous",
            "            # versions. Also rename '.' to ''",
            "            reult = conn.execute(_REPOS.select())",
            "            for row in reult:",
            "                if row['repopath'].startswith('/') or row['repopath'].endswith('/'):",
            "                    conn.execute(",
            "                        _REPOS.update()",
            "                        .where(_REPOS.c.repoid == row['repoid'])",
            "                        .values(repopath=row['repopath'].strip('/'))",
            "                    )",
            "                if row['repopath'] == '.':",
            "                    conn.execute(_REPOS.update().where(_REPOS.c.repoid == row['repoid']).values(repopath=''))",
            "",
            "            # Remove duplicates and nested repositories.",
            "            reult = conn.execute(_REPOS.select().order_by(_REPOS.c.userid, _REPOS.c.repopath))",
            "            prev_repo = (None, None)",
            "            for row in reult:",
            "                if prev_repo[0] == row['userid'] and (",
            "                    prev_repo[1] == row['repopath'] or row['repopath'].startswith(prev_repo[1] + '/')",
            "                ):",
            "                    conn.execute(_REPOS.delete(_REPOS.c.repoid == row['repoid']))",
            "                else:",
            "                    prev_repo = (row['userid'], row['repopath'])"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "400": [
                "UserObject",
                "set_password"
            ],
            "401": [
                "UserObject",
                "set_password"
            ],
            "402": [
                "UserObject",
                "set_password"
            ]
        },
        "addLocation": []
    }
}