{
    "salt/client/ssh/shell.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " # Import python libs"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import re"
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import os"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+import shlex"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+import subprocess"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import sys"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " import time"
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import logging"
            },
            "8": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "     '''"
            },
            "9": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     Generate a key for use with salt-ssh"
            },
            "10": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "     '''"
            },
            "11": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    cmd = 'ssh-keygen -P \"\" -f {0} -t rsa -q'.format(path)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    cmd = [\"ssh-keygen\", \"-P\", '\"\"', \"-f\", path, \"-t\", \"rsa\", \"-q\"]"
            },
            "13": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     if not os.path.isdir(os.path.dirname(path)):"
            },
            "14": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "         os.makedirs(os.path.dirname(path))"
            },
            "15": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    subprocess.call(cmd, shell=True)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    subprocess.call(cmd)"
            },
            "17": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " def gen_shell(opts, **kwargs):"
            },
            "20": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 291,
                "PatchRowcode": "         '''"
            },
            "21": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "         try:"
            },
            "22": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "             proc = salt.utils.nb_popen.NonBlockingPopen("
            },
            "23": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cmd,"
            },
            "24": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                shell=True,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 294,
                "PatchRowcode": "+                self._split_cmd(cmd),"
            },
            "26": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "                 stderr=subprocess.PIPE,"
            },
            "27": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "                 stdout=subprocess.PIPE,"
            },
            "28": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "             )"
            },
            "29": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 370,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 371,
                "PatchRowcode": "         return self._run_cmd(cmd)"
            },
            "31": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 372,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+    def _split_cmd(self, cmd):"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+        \"\"\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+        Split a command string so that it is suitable to pass to Popen without"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        shell=True. This prevents shell injection attacks in the options passed"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+        to ssh or some other command."
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        \"\"\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        try:"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+            ssh_part, cmd_part = cmd.split(\"/bin/sh\")"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+        except ValueError:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+            cmd_lst = shlex.split(cmd)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+        else:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 384,
                "PatchRowcode": "+            cmd_lst = shlex.split(ssh_part)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+            cmd_lst.append(\"/bin/sh {}\".format(cmd_part))"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+        return cmd_lst"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "     def _run_cmd(self, cmd, key_accept=False, passwd_retries=3):"
            },
            "48": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 389,
                "PatchRowcode": "         '''"
            },
            "49": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "         Execute a shell command via VT. This is blocking and assumes that ssh"
            },
            "50": {
                "beforePatchRowNumber": 378,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "             return '', 'No command or passphrase', 245"
            },
            "51": {
                "beforePatchRowNumber": 379,
                "afterPatchRowNumber": 395,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 380,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "         term = salt.utils.vt.Terminal("
            },
            "53": {
                "beforePatchRowNumber": 381,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                cmd,"
            },
            "54": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                shell=True,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+                self._split_cmd(cmd),"
            },
            "56": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 398,
                "PatchRowcode": "                 log_stdout=True,"
            },
            "57": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "                 log_stdout_level='trace',"
            },
            "58": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "                 log_stderr=True,"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Manage transport commands via ssh",
            "'''",
            "from __future__ import absolute_import, print_function, unicode_literals",
            "",
            "# Import python libs",
            "import re",
            "import os",
            "import sys",
            "import time",
            "import logging",
            "import subprocess",
            "",
            "# Import salt libs",
            "import salt.defaults.exitcodes",
            "import salt.utils.json",
            "import salt.utils.nb_popen",
            "import salt.utils.vt",
            "",
            "from salt.ext import six",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "SSH_PASSWORD_PROMPT_RE = re.compile(r'(?:.*)[Pp]assword(?: for .*)?:', re.M)",
            "KEY_VALID_RE = re.compile(r'.*\\(yes\\/no\\).*')",
            "SSH_PRIVATE_KEY_PASSWORD_PROMPT_RE = re.compile(r'Enter passphrase for key', re.M)",
            "",
            "# Keep these in sync with ./__init__.py",
            "RSTR = '_edbc7885e4f9aac9b83b35999b68d015148caf467b78fa39c05f669c0ff89878'",
            "RSTR_RE = re.compile(r'(?:^|\\r?\\n)' + RSTR + r'(?:\\r?\\n|$)')",
            "",
            "",
            "class NoPasswdError(Exception):",
            "    pass",
            "",
            "",
            "class KeyAcceptError(Exception):",
            "    pass",
            "",
            "",
            "def gen_key(path):",
            "    '''",
            "    Generate a key for use with salt-ssh",
            "    '''",
            "    cmd = 'ssh-keygen -P \"\" -f {0} -t rsa -q'.format(path)",
            "    if not os.path.isdir(os.path.dirname(path)):",
            "        os.makedirs(os.path.dirname(path))",
            "    subprocess.call(cmd, shell=True)",
            "",
            "",
            "def gen_shell(opts, **kwargs):",
            "    '''",
            "    Return the correct shell interface for the target system",
            "    '''",
            "    if kwargs['winrm']:",
            "        try:",
            "            import saltwinshell",
            "            shell = saltwinshell.Shell(opts, **kwargs)",
            "        except ImportError:",
            "            log.error('The saltwinshell library is not available')",
            "            sys.exit(salt.defaults.exitcodes.EX_GENERIC)",
            "    else:",
            "        shell = Shell(opts, **kwargs)",
            "    return shell",
            "",
            "",
            "class Shell(object):",
            "    '''",
            "    Create a shell connection object to encapsulate ssh executions",
            "    '''",
            "    def __init__(",
            "            self,",
            "            opts,",
            "            host,",
            "            user=None,",
            "            port=None,",
            "            passwd=None,",
            "            priv=None,",
            "            priv_passwd=None,",
            "            timeout=None,",
            "            sudo=False,",
            "            tty=False,",
            "            mods=None,",
            "            identities_only=False,",
            "            sudo_user=None,",
            "            remote_port_forwards=None,",
            "            winrm=False,",
            "            ssh_options=None):",
            "        self.opts = opts",
            "        # ssh <ipv6>, but scp [<ipv6]:/path",
            "        self.host = host.strip('[]')",
            "        self.user = user",
            "        self.port = port",
            "        self.passwd = six.text_type(passwd) if passwd else passwd",
            "        self.priv = priv",
            "        self.priv_passwd = priv_passwd",
            "        self.timeout = timeout",
            "        self.sudo = sudo",
            "        self.tty = tty",
            "        self.mods = mods",
            "        self.identities_only = identities_only",
            "        self.remote_port_forwards = remote_port_forwards",
            "        self.ssh_options = '' if ssh_options is None else ssh_options",
            "",
            "    def get_error(self, errstr):",
            "        '''",
            "        Parse out an error and return a targeted error string",
            "        '''",
            "        for line in errstr.split('\\n'):",
            "            if line.startswith('ssh:'):",
            "                return line",
            "            if line.startswith('Pseudo-terminal'):",
            "                continue",
            "            if 'to the list of known hosts.' in line:",
            "                continue",
            "            return line",
            "        return errstr",
            "",
            "    def _key_opts(self):",
            "        '''",
            "        Return options for the ssh command base for Salt to call",
            "        '''",
            "        options = [",
            "                   'KbdInteractiveAuthentication=no',",
            "                   ]",
            "        if self.passwd:",
            "            options.append('PasswordAuthentication=yes')",
            "        else:",
            "            options.append('PasswordAuthentication=no')",
            "        if self.opts.get('_ssh_version', (0,)) > (4, 9):",
            "            options.append('GSSAPIAuthentication=no')",
            "        options.append('ConnectTimeout={0}'.format(self.timeout))",
            "        if self.opts.get('ignore_host_keys'):",
            "            options.append('StrictHostKeyChecking=no')",
            "        if self.opts.get('no_host_keys'):",
            "            options.extend(['StrictHostKeyChecking=no',",
            "                            'UserKnownHostsFile=/dev/null'])",
            "        known_hosts = self.opts.get('known_hosts_file')",
            "        if known_hosts and os.path.isfile(known_hosts):",
            "            options.append('UserKnownHostsFile={0}'.format(known_hosts))",
            "        if self.port:",
            "            options.append('Port={0}'.format(self.port))",
            "        if self.priv and self.priv != 'agent-forwarding':",
            "            options.append('IdentityFile={0}'.format(self.priv))",
            "        if self.user:",
            "            options.append('User={0}'.format(self.user))",
            "        if self.identities_only:",
            "            options.append('IdentitiesOnly=yes')",
            "",
            "        ret = []",
            "        for option in options:",
            "            ret.append('-o {0} '.format(option))",
            "        return ''.join(ret)",
            "",
            "    def _passwd_opts(self):",
            "        '''",
            "        Return options to pass to ssh",
            "        '''",
            "        # TODO ControlMaster does not work without ControlPath",
            "        # user could take advantage of it if they set ControlPath in their",
            "        # ssh config.  Also, ControlPersist not widely available.",
            "        options = ['ControlMaster=auto',",
            "                   'StrictHostKeyChecking=no',",
            "                   ]",
            "        if self.opts['_ssh_version'] > (4, 9):",
            "            options.append('GSSAPIAuthentication=no')",
            "        options.append('ConnectTimeout={0}'.format(self.timeout))",
            "        if self.opts.get('ignore_host_keys'):",
            "            options.append('StrictHostKeyChecking=no')",
            "        if self.opts.get('no_host_keys'):",
            "            options.extend(['StrictHostKeyChecking=no',",
            "                            'UserKnownHostsFile=/dev/null'])",
            "",
            "        if self.passwd:",
            "            options.extend(['PasswordAuthentication=yes',",
            "                            'PubkeyAuthentication=yes'])",
            "        else:",
            "            options.extend(['PasswordAuthentication=no',",
            "                            'PubkeyAuthentication=yes',",
            "                            'KbdInteractiveAuthentication=no',",
            "                            'ChallengeResponseAuthentication=no',",
            "                            'BatchMode=yes'])",
            "        if self.port:",
            "            options.append('Port={0}'.format(self.port))",
            "        if self.user:",
            "            options.append('User={0}'.format(self.user))",
            "        if self.identities_only:",
            "            options.append('IdentitiesOnly=yes')",
            "",
            "        ret = []",
            "        for option in options:",
            "            ret.append('-o {0} '.format(option))",
            "        return ''.join(ret)",
            "",
            "    def _ssh_opts(self):",
            "        return ' '.join(['-o {0}'.format(opt)",
            "                          for opt in self.ssh_options])",
            "",
            "    def _copy_id_str_old(self):",
            "        '''",
            "        Return the string to execute ssh-copy-id",
            "        '''",
            "        if self.passwd:",
            "            # Using single quotes prevents shell expansion and",
            "            # passwords containing '$'",
            "            return \"{0} {1} '{2} -p {3} {4} {5}@{6}'\".format(",
            "                    'ssh-copy-id',",
            "                    '-i {0}.pub'.format(self.priv),",
            "                    self._passwd_opts(),",
            "                    self.port,",
            "                    self._ssh_opts(),",
            "                    self.user,",
            "                    self.host)",
            "        return None",
            "",
            "    def _copy_id_str_new(self):",
            "        '''",
            "        Since newer ssh-copy-id commands ingest option differently we need to",
            "        have two commands",
            "        '''",
            "        if self.passwd:",
            "            # Using single quotes prevents shell expansion and",
            "            # passwords containing '$'",
            "            return \"{0} {1} {2} -p {3} {4} {5}@{6}\".format(",
            "                    'ssh-copy-id',",
            "                    '-i {0}.pub'.format(self.priv),",
            "                    self._passwd_opts(),",
            "                    self.port,",
            "                    self._ssh_opts(),",
            "                    self.user,",
            "                    self.host)",
            "        return None",
            "",
            "    def copy_id(self):",
            "        '''",
            "        Execute ssh-copy-id to plant the id file on the target",
            "        '''",
            "        stdout, stderr, retcode = self._run_cmd(self._copy_id_str_old())",
            "        if salt.defaults.exitcodes.EX_OK != retcode and 'Usage' in stderr:",
            "            stdout, stderr, retcode = self._run_cmd(self._copy_id_str_new())",
            "        return stdout, stderr, retcode",
            "",
            "    def _cmd_str(self, cmd, ssh='ssh'):",
            "        '''",
            "        Return the cmd string to execute",
            "        '''",
            "",
            "        # TODO: if tty, then our SSH_SHIM cannot be supplied from STDIN Will",
            "        # need to deliver the SHIM to the remote host and execute it there",
            "",
            "        command = [ssh]",
            "        if ssh != 'scp':",
            "            command.append(self.host)",
            "        if self.tty and ssh == 'ssh':",
            "            command.append('-t -t')",
            "        if self.passwd or self.priv:",
            "            command.append(self.priv and self._key_opts() or self._passwd_opts())",
            "        if ssh != 'scp' and self.remote_port_forwards:",
            "            command.append(' '.join(['-R {0}'.format(item)",
            "                                      for item in self.remote_port_forwards.split(',')]))",
            "        if self.ssh_options:",
            "            command.append(self._ssh_opts())",
            "",
            "        command.append(cmd)",
            "",
            "        return ' '.join(command)",
            "",
            "    def _old_run_cmd(self, cmd):",
            "        '''",
            "        Cleanly execute the command string",
            "        '''",
            "        try:",
            "            proc = subprocess.Popen(",
            "                cmd,",
            "                shell=True,",
            "                stderr=subprocess.PIPE,",
            "                stdout=subprocess.PIPE,",
            "            )",
            "",
            "            data = proc.communicate()",
            "            return data[0], data[1], proc.returncode",
            "        except Exception:  # pylint: disable=broad-except",
            "            return ('local', 'Unknown Error', None)",
            "",
            "    def _run_nb_cmd(self, cmd):",
            "        '''",
            "        cmd iterator",
            "        '''",
            "        try:",
            "            proc = salt.utils.nb_popen.NonBlockingPopen(",
            "                cmd,",
            "                shell=True,",
            "                stderr=subprocess.PIPE,",
            "                stdout=subprocess.PIPE,",
            "            )",
            "            while True:",
            "                time.sleep(0.1)",
            "                out = proc.recv()",
            "                err = proc.recv_err()",
            "                rcode = proc.returncode",
            "                if out is None and err is None:",
            "                    break",
            "                if err:",
            "                    err = self.get_error(err)",
            "                yield out, err, rcode",
            "        except Exception:  # pylint: disable=broad-except",
            "            yield ('', 'Unknown Error', None)",
            "",
            "    def exec_nb_cmd(self, cmd):",
            "        '''",
            "        Yield None until cmd finished",
            "        '''",
            "        r_out = []",
            "        r_err = []",
            "        rcode = None",
            "        cmd = self._cmd_str(cmd)",
            "",
            "        logmsg = 'Executing non-blocking command: {0}'.format(cmd)",
            "        if self.passwd:",
            "            logmsg = logmsg.replace(self.passwd, ('*' * 6))",
            "        log.debug(logmsg)",
            "",
            "        for out, err, rcode in self._run_nb_cmd(cmd):",
            "            if out is not None:",
            "                r_out.append(out)",
            "            if err is not None:",
            "                r_err.append(err)",
            "            yield None, None, None",
            "        yield ''.join(r_out), ''.join(r_err), rcode",
            "",
            "    def exec_cmd(self, cmd):",
            "        '''",
            "        Execute a remote command",
            "        '''",
            "        cmd = self._cmd_str(cmd)",
            "",
            "        logmsg = 'Executing command: {0}'.format(cmd)",
            "        if self.passwd:",
            "            logmsg = logmsg.replace(self.passwd, ('*' * 6))",
            "        if 'decode(\"base64\")' in logmsg or 'base64.b64decode(' in logmsg:",
            "            log.debug('Executed SHIM command. Command logged to TRACE')",
            "            log.trace(logmsg)",
            "        else:",
            "            log.debug(logmsg)",
            "",
            "        ret = self._run_cmd(cmd)",
            "        return ret",
            "",
            "    def send(self, local, remote, makedirs=False):",
            "        '''",
            "        scp a file or files to a remote system",
            "        '''",
            "        if makedirs:",
            "            self.exec_cmd('mkdir -p {0}'.format(os.path.dirname(remote)))",
            "",
            "        # scp needs [<ipv6}",
            "        host = self.host",
            "        if ':' in host:",
            "            host = '[{0}]'.format(host)",
            "",
            "        cmd = '{0} {1}:{2}'.format(local, host, remote)",
            "        cmd = self._cmd_str(cmd, ssh='scp')",
            "",
            "        logmsg = 'Executing command: {0}'.format(cmd)",
            "        if self.passwd:",
            "            logmsg = logmsg.replace(self.passwd, ('*' * 6))",
            "        log.debug(logmsg)",
            "",
            "        return self._run_cmd(cmd)",
            "",
            "    def _run_cmd(self, cmd, key_accept=False, passwd_retries=3):",
            "        '''",
            "        Execute a shell command via VT. This is blocking and assumes that ssh",
            "        is being run",
            "        '''",
            "        if not cmd:",
            "            return '', 'No command or passphrase', 245",
            "",
            "        term = salt.utils.vt.Terminal(",
            "                cmd,",
            "                shell=True,",
            "                log_stdout=True,",
            "                log_stdout_level='trace',",
            "                log_stderr=True,",
            "                log_stderr_level='trace',",
            "                stream_stdout=False,",
            "                stream_stderr=False)",
            "        sent_passwd = 0",
            "        send_password = True",
            "        ret_stdout = ''",
            "        ret_stderr = ''",
            "        old_stdout = ''",
            "",
            "        try:",
            "            while term.has_unread_data:",
            "                stdout, stderr = term.recv()",
            "                if stdout:",
            "                    ret_stdout += stdout",
            "                    buff = old_stdout + stdout",
            "                else:",
            "                    buff = stdout",
            "                if stderr:",
            "                    ret_stderr += stderr",
            "                if buff and RSTR_RE.search(buff):",
            "                    # We're getting results back, don't try to send passwords",
            "                    send_password = False",
            "                if buff and SSH_PRIVATE_KEY_PASSWORD_PROMPT_RE.search(buff):",
            "                    if not self.priv_passwd:",
            "                        return '', 'Private key file need passphrase', 254",
            "                    term.sendline(self.priv_passwd)",
            "                    continue",
            "                if buff and SSH_PASSWORD_PROMPT_RE.search(buff) and send_password:",
            "                    if not self.passwd:",
            "                        return '', 'Permission denied, no authentication information', 254",
            "                    if sent_passwd < passwd_retries:",
            "                        term.sendline(self.passwd)",
            "                        sent_passwd += 1",
            "                        continue",
            "                    else:",
            "                        # asking for a password, and we can't seem to send it",
            "                        return '', 'Password authentication failed', 254",
            "                elif buff and KEY_VALID_RE.search(buff):",
            "                    if key_accept:",
            "                        term.sendline('yes')",
            "                        continue",
            "                    else:",
            "                        term.sendline('no')",
            "                        ret_stdout = ('The host key needs to be accepted, to '",
            "                                      'auto accept run salt-ssh with the -i '",
            "                                      'flag:\\n{0}').format(stdout)",
            "                        return ret_stdout, '', 254",
            "                elif buff and buff.endswith('_||ext_mods||_'):",
            "                    mods_raw = salt.utils.json.dumps(self.mods, separators=(',', ':')) + '|_E|0|'",
            "                    term.sendline(mods_raw)",
            "                if stdout:",
            "                    old_stdout = stdout",
            "                time.sleep(0.01)",
            "            return ret_stdout, ret_stderr, term.exitstatus",
            "        finally:",
            "            term.close(terminate=True, kill=True)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "'''",
            "Manage transport commands via ssh",
            "'''",
            "from __future__ import absolute_import, print_function, unicode_literals",
            "",
            "# Import python libs",
            "import re",
            "import os",
            "import shlex",
            "import subprocess",
            "import sys",
            "import time",
            "import logging",
            "import subprocess",
            "",
            "# Import salt libs",
            "import salt.defaults.exitcodes",
            "import salt.utils.json",
            "import salt.utils.nb_popen",
            "import salt.utils.vt",
            "",
            "from salt.ext import six",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "SSH_PASSWORD_PROMPT_RE = re.compile(r'(?:.*)[Pp]assword(?: for .*)?:', re.M)",
            "KEY_VALID_RE = re.compile(r'.*\\(yes\\/no\\).*')",
            "SSH_PRIVATE_KEY_PASSWORD_PROMPT_RE = re.compile(r'Enter passphrase for key', re.M)",
            "",
            "# Keep these in sync with ./__init__.py",
            "RSTR = '_edbc7885e4f9aac9b83b35999b68d015148caf467b78fa39c05f669c0ff89878'",
            "RSTR_RE = re.compile(r'(?:^|\\r?\\n)' + RSTR + r'(?:\\r?\\n|$)')",
            "",
            "",
            "class NoPasswdError(Exception):",
            "    pass",
            "",
            "",
            "class KeyAcceptError(Exception):",
            "    pass",
            "",
            "",
            "def gen_key(path):",
            "    '''",
            "    Generate a key for use with salt-ssh",
            "    '''",
            "    cmd = [\"ssh-keygen\", \"-P\", '\"\"', \"-f\", path, \"-t\", \"rsa\", \"-q\"]",
            "    if not os.path.isdir(os.path.dirname(path)):",
            "        os.makedirs(os.path.dirname(path))",
            "    subprocess.call(cmd)",
            "",
            "",
            "def gen_shell(opts, **kwargs):",
            "    '''",
            "    Return the correct shell interface for the target system",
            "    '''",
            "    if kwargs['winrm']:",
            "        try:",
            "            import saltwinshell",
            "            shell = saltwinshell.Shell(opts, **kwargs)",
            "        except ImportError:",
            "            log.error('The saltwinshell library is not available')",
            "            sys.exit(salt.defaults.exitcodes.EX_GENERIC)",
            "    else:",
            "        shell = Shell(opts, **kwargs)",
            "    return shell",
            "",
            "",
            "class Shell(object):",
            "    '''",
            "    Create a shell connection object to encapsulate ssh executions",
            "    '''",
            "    def __init__(",
            "            self,",
            "            opts,",
            "            host,",
            "            user=None,",
            "            port=None,",
            "            passwd=None,",
            "            priv=None,",
            "            priv_passwd=None,",
            "            timeout=None,",
            "            sudo=False,",
            "            tty=False,",
            "            mods=None,",
            "            identities_only=False,",
            "            sudo_user=None,",
            "            remote_port_forwards=None,",
            "            winrm=False,",
            "            ssh_options=None):",
            "        self.opts = opts",
            "        # ssh <ipv6>, but scp [<ipv6]:/path",
            "        self.host = host.strip('[]')",
            "        self.user = user",
            "        self.port = port",
            "        self.passwd = six.text_type(passwd) if passwd else passwd",
            "        self.priv = priv",
            "        self.priv_passwd = priv_passwd",
            "        self.timeout = timeout",
            "        self.sudo = sudo",
            "        self.tty = tty",
            "        self.mods = mods",
            "        self.identities_only = identities_only",
            "        self.remote_port_forwards = remote_port_forwards",
            "        self.ssh_options = '' if ssh_options is None else ssh_options",
            "",
            "    def get_error(self, errstr):",
            "        '''",
            "        Parse out an error and return a targeted error string",
            "        '''",
            "        for line in errstr.split('\\n'):",
            "            if line.startswith('ssh:'):",
            "                return line",
            "            if line.startswith('Pseudo-terminal'):",
            "                continue",
            "            if 'to the list of known hosts.' in line:",
            "                continue",
            "            return line",
            "        return errstr",
            "",
            "    def _key_opts(self):",
            "        '''",
            "        Return options for the ssh command base for Salt to call",
            "        '''",
            "        options = [",
            "                   'KbdInteractiveAuthentication=no',",
            "                   ]",
            "        if self.passwd:",
            "            options.append('PasswordAuthentication=yes')",
            "        else:",
            "            options.append('PasswordAuthentication=no')",
            "        if self.opts.get('_ssh_version', (0,)) > (4, 9):",
            "            options.append('GSSAPIAuthentication=no')",
            "        options.append('ConnectTimeout={0}'.format(self.timeout))",
            "        if self.opts.get('ignore_host_keys'):",
            "            options.append('StrictHostKeyChecking=no')",
            "        if self.opts.get('no_host_keys'):",
            "            options.extend(['StrictHostKeyChecking=no',",
            "                            'UserKnownHostsFile=/dev/null'])",
            "        known_hosts = self.opts.get('known_hosts_file')",
            "        if known_hosts and os.path.isfile(known_hosts):",
            "            options.append('UserKnownHostsFile={0}'.format(known_hosts))",
            "        if self.port:",
            "            options.append('Port={0}'.format(self.port))",
            "        if self.priv and self.priv != 'agent-forwarding':",
            "            options.append('IdentityFile={0}'.format(self.priv))",
            "        if self.user:",
            "            options.append('User={0}'.format(self.user))",
            "        if self.identities_only:",
            "            options.append('IdentitiesOnly=yes')",
            "",
            "        ret = []",
            "        for option in options:",
            "            ret.append('-o {0} '.format(option))",
            "        return ''.join(ret)",
            "",
            "    def _passwd_opts(self):",
            "        '''",
            "        Return options to pass to ssh",
            "        '''",
            "        # TODO ControlMaster does not work without ControlPath",
            "        # user could take advantage of it if they set ControlPath in their",
            "        # ssh config.  Also, ControlPersist not widely available.",
            "        options = ['ControlMaster=auto',",
            "                   'StrictHostKeyChecking=no',",
            "                   ]",
            "        if self.opts['_ssh_version'] > (4, 9):",
            "            options.append('GSSAPIAuthentication=no')",
            "        options.append('ConnectTimeout={0}'.format(self.timeout))",
            "        if self.opts.get('ignore_host_keys'):",
            "            options.append('StrictHostKeyChecking=no')",
            "        if self.opts.get('no_host_keys'):",
            "            options.extend(['StrictHostKeyChecking=no',",
            "                            'UserKnownHostsFile=/dev/null'])",
            "",
            "        if self.passwd:",
            "            options.extend(['PasswordAuthentication=yes',",
            "                            'PubkeyAuthentication=yes'])",
            "        else:",
            "            options.extend(['PasswordAuthentication=no',",
            "                            'PubkeyAuthentication=yes',",
            "                            'KbdInteractiveAuthentication=no',",
            "                            'ChallengeResponseAuthentication=no',",
            "                            'BatchMode=yes'])",
            "        if self.port:",
            "            options.append('Port={0}'.format(self.port))",
            "        if self.user:",
            "            options.append('User={0}'.format(self.user))",
            "        if self.identities_only:",
            "            options.append('IdentitiesOnly=yes')",
            "",
            "        ret = []",
            "        for option in options:",
            "            ret.append('-o {0} '.format(option))",
            "        return ''.join(ret)",
            "",
            "    def _ssh_opts(self):",
            "        return ' '.join(['-o {0}'.format(opt)",
            "                          for opt in self.ssh_options])",
            "",
            "    def _copy_id_str_old(self):",
            "        '''",
            "        Return the string to execute ssh-copy-id",
            "        '''",
            "        if self.passwd:",
            "            # Using single quotes prevents shell expansion and",
            "            # passwords containing '$'",
            "            return \"{0} {1} '{2} -p {3} {4} {5}@{6}'\".format(",
            "                    'ssh-copy-id',",
            "                    '-i {0}.pub'.format(self.priv),",
            "                    self._passwd_opts(),",
            "                    self.port,",
            "                    self._ssh_opts(),",
            "                    self.user,",
            "                    self.host)",
            "        return None",
            "",
            "    def _copy_id_str_new(self):",
            "        '''",
            "        Since newer ssh-copy-id commands ingest option differently we need to",
            "        have two commands",
            "        '''",
            "        if self.passwd:",
            "            # Using single quotes prevents shell expansion and",
            "            # passwords containing '$'",
            "            return \"{0} {1} {2} -p {3} {4} {5}@{6}\".format(",
            "                    'ssh-copy-id',",
            "                    '-i {0}.pub'.format(self.priv),",
            "                    self._passwd_opts(),",
            "                    self.port,",
            "                    self._ssh_opts(),",
            "                    self.user,",
            "                    self.host)",
            "        return None",
            "",
            "    def copy_id(self):",
            "        '''",
            "        Execute ssh-copy-id to plant the id file on the target",
            "        '''",
            "        stdout, stderr, retcode = self._run_cmd(self._copy_id_str_old())",
            "        if salt.defaults.exitcodes.EX_OK != retcode and 'Usage' in stderr:",
            "            stdout, stderr, retcode = self._run_cmd(self._copy_id_str_new())",
            "        return stdout, stderr, retcode",
            "",
            "    def _cmd_str(self, cmd, ssh='ssh'):",
            "        '''",
            "        Return the cmd string to execute",
            "        '''",
            "",
            "        # TODO: if tty, then our SSH_SHIM cannot be supplied from STDIN Will",
            "        # need to deliver the SHIM to the remote host and execute it there",
            "",
            "        command = [ssh]",
            "        if ssh != 'scp':",
            "            command.append(self.host)",
            "        if self.tty and ssh == 'ssh':",
            "            command.append('-t -t')",
            "        if self.passwd or self.priv:",
            "            command.append(self.priv and self._key_opts() or self._passwd_opts())",
            "        if ssh != 'scp' and self.remote_port_forwards:",
            "            command.append(' '.join(['-R {0}'.format(item)",
            "                                      for item in self.remote_port_forwards.split(',')]))",
            "        if self.ssh_options:",
            "            command.append(self._ssh_opts())",
            "",
            "        command.append(cmd)",
            "",
            "        return ' '.join(command)",
            "",
            "    def _old_run_cmd(self, cmd):",
            "        '''",
            "        Cleanly execute the command string",
            "        '''",
            "        try:",
            "            proc = subprocess.Popen(",
            "                cmd,",
            "                shell=True,",
            "                stderr=subprocess.PIPE,",
            "                stdout=subprocess.PIPE,",
            "            )",
            "",
            "            data = proc.communicate()",
            "            return data[0], data[1], proc.returncode",
            "        except Exception:  # pylint: disable=broad-except",
            "            return ('local', 'Unknown Error', None)",
            "",
            "    def _run_nb_cmd(self, cmd):",
            "        '''",
            "        cmd iterator",
            "        '''",
            "        try:",
            "            proc = salt.utils.nb_popen.NonBlockingPopen(",
            "                self._split_cmd(cmd),",
            "                stderr=subprocess.PIPE,",
            "                stdout=subprocess.PIPE,",
            "            )",
            "            while True:",
            "                time.sleep(0.1)",
            "                out = proc.recv()",
            "                err = proc.recv_err()",
            "                rcode = proc.returncode",
            "                if out is None and err is None:",
            "                    break",
            "                if err:",
            "                    err = self.get_error(err)",
            "                yield out, err, rcode",
            "        except Exception:  # pylint: disable=broad-except",
            "            yield ('', 'Unknown Error', None)",
            "",
            "    def exec_nb_cmd(self, cmd):",
            "        '''",
            "        Yield None until cmd finished",
            "        '''",
            "        r_out = []",
            "        r_err = []",
            "        rcode = None",
            "        cmd = self._cmd_str(cmd)",
            "",
            "        logmsg = 'Executing non-blocking command: {0}'.format(cmd)",
            "        if self.passwd:",
            "            logmsg = logmsg.replace(self.passwd, ('*' * 6))",
            "        log.debug(logmsg)",
            "",
            "        for out, err, rcode in self._run_nb_cmd(cmd):",
            "            if out is not None:",
            "                r_out.append(out)",
            "            if err is not None:",
            "                r_err.append(err)",
            "            yield None, None, None",
            "        yield ''.join(r_out), ''.join(r_err), rcode",
            "",
            "    def exec_cmd(self, cmd):",
            "        '''",
            "        Execute a remote command",
            "        '''",
            "        cmd = self._cmd_str(cmd)",
            "",
            "        logmsg = 'Executing command: {0}'.format(cmd)",
            "        if self.passwd:",
            "            logmsg = logmsg.replace(self.passwd, ('*' * 6))",
            "        if 'decode(\"base64\")' in logmsg or 'base64.b64decode(' in logmsg:",
            "            log.debug('Executed SHIM command. Command logged to TRACE')",
            "            log.trace(logmsg)",
            "        else:",
            "            log.debug(logmsg)",
            "",
            "        ret = self._run_cmd(cmd)",
            "        return ret",
            "",
            "    def send(self, local, remote, makedirs=False):",
            "        '''",
            "        scp a file or files to a remote system",
            "        '''",
            "        if makedirs:",
            "            self.exec_cmd('mkdir -p {0}'.format(os.path.dirname(remote)))",
            "",
            "        # scp needs [<ipv6}",
            "        host = self.host",
            "        if ':' in host:",
            "            host = '[{0}]'.format(host)",
            "",
            "        cmd = '{0} {1}:{2}'.format(local, host, remote)",
            "        cmd = self._cmd_str(cmd, ssh='scp')",
            "",
            "        logmsg = 'Executing command: {0}'.format(cmd)",
            "        if self.passwd:",
            "            logmsg = logmsg.replace(self.passwd, ('*' * 6))",
            "        log.debug(logmsg)",
            "",
            "        return self._run_cmd(cmd)",
            "",
            "    def _split_cmd(self, cmd):",
            "        \"\"\"",
            "        Split a command string so that it is suitable to pass to Popen without",
            "        shell=True. This prevents shell injection attacks in the options passed",
            "        to ssh or some other command.",
            "        \"\"\"",
            "        try:",
            "            ssh_part, cmd_part = cmd.split(\"/bin/sh\")",
            "        except ValueError:",
            "            cmd_lst = shlex.split(cmd)",
            "        else:",
            "            cmd_lst = shlex.split(ssh_part)",
            "            cmd_lst.append(\"/bin/sh {}\".format(cmd_part))",
            "        return cmd_lst",
            "",
            "    def _run_cmd(self, cmd, key_accept=False, passwd_retries=3):",
            "        '''",
            "        Execute a shell command via VT. This is blocking and assumes that ssh",
            "        is being run",
            "        '''",
            "        if not cmd:",
            "            return '', 'No command or passphrase', 245",
            "",
            "        term = salt.utils.vt.Terminal(",
            "                self._split_cmd(cmd),",
            "                log_stdout=True,",
            "                log_stdout_level='trace',",
            "                log_stderr=True,",
            "                log_stderr_level='trace',",
            "                stream_stdout=False,",
            "                stream_stderr=False)",
            "        sent_passwd = 0",
            "        send_password = True",
            "        ret_stdout = ''",
            "        ret_stderr = ''",
            "        old_stdout = ''",
            "",
            "        try:",
            "            while term.has_unread_data:",
            "                stdout, stderr = term.recv()",
            "                if stdout:",
            "                    ret_stdout += stdout",
            "                    buff = old_stdout + stdout",
            "                else:",
            "                    buff = stdout",
            "                if stderr:",
            "                    ret_stderr += stderr",
            "                if buff and RSTR_RE.search(buff):",
            "                    # We're getting results back, don't try to send passwords",
            "                    send_password = False",
            "                if buff and SSH_PRIVATE_KEY_PASSWORD_PROMPT_RE.search(buff):",
            "                    if not self.priv_passwd:",
            "                        return '', 'Private key file need passphrase', 254",
            "                    term.sendline(self.priv_passwd)",
            "                    continue",
            "                if buff and SSH_PASSWORD_PROMPT_RE.search(buff) and send_password:",
            "                    if not self.passwd:",
            "                        return '', 'Permission denied, no authentication information', 254",
            "                    if sent_passwd < passwd_retries:",
            "                        term.sendline(self.passwd)",
            "                        sent_passwd += 1",
            "                        continue",
            "                    else:",
            "                        # asking for a password, and we can't seem to send it",
            "                        return '', 'Password authentication failed', 254",
            "                elif buff and KEY_VALID_RE.search(buff):",
            "                    if key_accept:",
            "                        term.sendline('yes')",
            "                        continue",
            "                    else:",
            "                        term.sendline('no')",
            "                        ret_stdout = ('The host key needs to be accepted, to '",
            "                                      'auto accept run salt-ssh with the -i '",
            "                                      'flag:\\n{0}').format(stdout)",
            "                        return ret_stdout, '', 254",
            "                elif buff and buff.endswith('_||ext_mods||_'):",
            "                    mods_raw = salt.utils.json.dumps(self.mods, separators=(',', ':')) + '|_E|0|'",
            "                    term.sendline(mods_raw)",
            "                if stdout:",
            "                    old_stdout = stdout",
            "                time.sleep(0.01)",
            "            return ret_stdout, ret_stderr, term.exitstatus",
            "        finally:",
            "            term.close(terminate=True, kill=True)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "46": [
                "gen_key"
            ],
            "49": [
                "gen_key"
            ],
            "292": [
                "Shell",
                "_run_nb_cmd"
            ],
            "293": [
                "Shell",
                "_run_nb_cmd"
            ],
            "381": [
                "Shell",
                "_run_cmd"
            ],
            "382": [
                "Shell",
                "_run_cmd"
            ]
        },
        "addLocation": []
    }
}