{
    "mkdocs/livereload/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         if path == \"/js/livereload.js\":"
            },
            "1": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "             file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")"
            },
            "2": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "         elif path.startswith(self.mount_path):"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            rel_file_path = path[len(self.mount_path):].lstrip(\"/\")"
            },
            "4": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "             if path.endswith(\"/\"):"
            },
            "5": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                path += \"index.html\""
            },
            "6": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path = path[len(self.mount_path):]"
            },
            "7": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            file_path = os.path.join(self.root, path.lstrip(\"/\"))"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+                rel_file_path += \"index.html\""
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            file_path = os.path.join(self.root, rel_file_path)"
            },
            "10": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         elif path == \"/\":"
            },
            "11": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "             start_response(\"302 Found\", [(\"Location\", self.mount_path)])"
            },
            "12": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 192,
                "PatchRowcode": "             return []"
            },
            "13": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 201,
                "PatchRowcode": "         try:"
            },
            "14": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "             file = open(file_path, \"rb\")"
            },
            "15": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         except OSError:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+            if not path.endswith(\"/\") and os.path.isfile(os.path.join(file_path, \"index.html\")):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+                start_response(\"302 Found\", [(\"Location\", path + \"/\")])"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+                return []"
            },
            "19": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "             return None  # Not found"
            },
            "20": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 208,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if path.endswith(\".html\"):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+        if file_path.endswith(\".html\"):"
            },
            "23": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "             with file:"
            },
            "24": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "                 content = file.read()"
            },
            "25": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "             content = self._inject_js_into_html(content, epoch)"
            }
        },
        "frontPatchFile": [
            "import functools",
            "import io",
            "import logging",
            "import mimetypes",
            "import os",
            "import os.path",
            "import re",
            "import socketserver",
            "import threading",
            "import time",
            "import warnings",
            "import wsgiref.simple_server",
            "",
            "import watchdog.events",
            "import watchdog.observers.polling",
            "",
            "",
            "class _LoggerAdapter(logging.LoggerAdapter):",
            "    def process(self, msg, kwargs):",
            "        return time.strftime(\"[%H:%M:%S] \") + msg, kwargs",
            "",
            "",
            "log = _LoggerAdapter(logging.getLogger(__name__), {})",
            "",
            "",
            "class LiveReloadServer(socketserver.ThreadingMixIn, wsgiref.simple_server.WSGIServer):",
            "    daemon_threads = True",
            "    poll_response_timeout = 60",
            "",
            "    def __init__(",
            "        self,",
            "        builder,",
            "        host,",
            "        port,",
            "        root,",
            "        mount_path=\"/\",",
            "        polling_interval=0.5,",
            "        shutdown_delay=0.25,",
            "        **kwargs,",
            "    ):",
            "        self.builder = builder",
            "        self.server_name = host",
            "        self.server_port = port",
            "        self.root = os.path.abspath(root)",
            "        self.mount_path = (\"/\" + mount_path.lstrip(\"/\")).rstrip(\"/\") + \"/\"",
            "        self.url = f\"http://{self.server_name}:{self.server_port}{self.mount_path}\"",
            "        self.build_delay = 0.1",
            "        self.shutdown_delay = shutdown_delay",
            "        # To allow custom error pages.",
            "        self.error_handler = lambda code: None",
            "",
            "        super().__init__((host, port), _Handler, **kwargs)",
            "        self.set_app(self.serve_request)",
            "",
            "        self._wanted_epoch = _timestamp()  # The version of the site that started building.",
            "        self._visible_epoch = self._wanted_epoch  # Latest fully built version of the site.",
            "        self._epoch_cond = threading.Condition()  # Must be held when accessing _visible_epoch.",
            "",
            "        self._to_rebuild = {}  # Used as an ordered set of functions to call.",
            "        self._rebuild_cond = threading.Condition()  # Must be held when accessing _to_rebuild.",
            "",
            "        self._shutdown = False",
            "        self.serve_thread = threading.Thread(target=lambda: self.serve_forever(shutdown_delay))",
            "        self.observer = watchdog.observers.polling.PollingObserver(timeout=polling_interval)",
            "",
            "    def watch(self, path, func=None, recursive=True):",
            "        \"\"\"Add the 'path' to watched paths, call the function and reload when any file changes under it.\"\"\"",
            "        path = os.path.abspath(path)",
            "        if func in (None, self.builder):",
            "            func = self.builder",
            "        else:",
            "            warnings.warn(",
            "                \"Plugins should not pass the 'func' parameter of watch(). \"",
            "                \"The ability to execute custom callbacks will be removed soon.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        def callback(event):",
            "            if event.is_directory:",
            "                return",
            "            log.debug(str(event))",
            "            with self._rebuild_cond:",
            "                self._to_rebuild[func] = True",
            "                self._rebuild_cond.notify_all()",
            "",
            "        handler = watchdog.events.FileSystemEventHandler()",
            "        handler.on_any_event = callback",
            "        log.debug(f\"Watching '{path}'\")",
            "        self.observer.schedule(handler, path, recursive=recursive)",
            "",
            "    def serve(self):",
            "        self.observer.start()",
            "",
            "        log.info(f\"Serving on {self.url}\")",
            "        self.serve_thread.start()",
            "",
            "        self._build_loop()",
            "",
            "    def _build_loop(self):",
            "        while True:",
            "            with self._rebuild_cond:",
            "                while not self._rebuild_cond.wait_for(",
            "                    lambda: self._to_rebuild or self._shutdown, timeout=self.shutdown_delay",
            "                ):",
            "                    # We could have used just one wait instead of a loop + timeout, but we need",
            "                    # occasional breaks, otherwise on Windows we can't receive KeyboardInterrupt.",
            "                    pass",
            "                if self._shutdown:",
            "                    break",
            "                log.info(\"Detected file changes\")",
            "                while self._rebuild_cond.wait(timeout=self.build_delay):",
            "                    log.debug(\"Waiting for file changes to stop happening\")",
            "",
            "                self._wanted_epoch = _timestamp()",
            "                funcs = list(self._to_rebuild)",
            "                self._to_rebuild.clear()",
            "",
            "            for func in funcs:",
            "                func()",
            "",
            "            with self._epoch_cond:",
            "                log.info(\"Reloading browsers\")",
            "                self._visible_epoch = self._wanted_epoch",
            "                self._epoch_cond.notify_all()",
            "",
            "    def shutdown(self):",
            "        self.observer.stop()",
            "        with self._rebuild_cond:",
            "            self._shutdown = True",
            "            self._rebuild_cond.notify_all()",
            "",
            "        if self.serve_thread.is_alive():",
            "            super().shutdown()",
            "            self.serve_thread.join()",
            "            self.observer.join()",
            "",
            "    def serve_request(self, environ, start_response):",
            "        try:",
            "            result = self._serve_request(environ, start_response)",
            "        except Exception:",
            "            code = 500",
            "            msg = \"500 Internal Server Error\"",
            "            log.exception(msg)",
            "        else:",
            "            if result is not None:",
            "                return result",
            "            code = 404",
            "            msg = \"404 Not Found\"",
            "",
            "        error_content = None",
            "        try:",
            "            error_content = self.error_handler(code)",
            "        except Exception:",
            "            log.exception(\"Failed to render an error message!\")",
            "        if error_content is None:",
            "            error_content = msg.encode()",
            "",
            "        start_response(msg, [(\"Content-Type\", \"text/html\")])",
            "        return [error_content]",
            "",
            "    def _serve_request(self, environ, start_response):",
            "        # https://bugs.python.org/issue16679",
            "        # https://github.com/bottlepy/bottle/blob/f9b1849db4/bottle.py#L984",
            "        path = environ[\"PATH_INFO\"].encode(\"latin-1\").decode(\"utf-8\", \"ignore\")",
            "",
            "        m = re.fullmatch(r\"/livereload/([0-9]+)/[0-9]+\", path)",
            "        if m:",
            "            epoch = int(m[1])",
            "            start_response(\"200 OK\", [(\"Content-Type\", \"text/plain\")])",
            "",
            "            def condition():",
            "                return self._visible_epoch > epoch",
            "",
            "            with self._epoch_cond:",
            "                if not condition():",
            "                    # Stall the browser, respond as soon as there's something new.",
            "                    # If there's not, respond anyway after a minute.",
            "                    self._log_poll_request(environ.get(\"HTTP_REFERER\"), request_id=path)",
            "                    self._epoch_cond.wait_for(condition, timeout=self.poll_response_timeout)",
            "                return [b\"%d\" % self._visible_epoch]",
            "",
            "        if path == \"/js/livereload.js\":",
            "            file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")",
            "        elif path.startswith(self.mount_path):",
            "            if path.endswith(\"/\"):",
            "                path += \"index.html\"",
            "            path = path[len(self.mount_path):]",
            "            file_path = os.path.join(self.root, path.lstrip(\"/\"))",
            "        elif path == \"/\":",
            "            start_response(\"302 Found\", [(\"Location\", self.mount_path)])",
            "            return []",
            "        else:",
            "            return None  # Not found",
            "",
            "        # Wait until the ongoing rebuild (if any) finishes, so we're not serving a half-built site.",
            "        with self._epoch_cond:",
            "            self._epoch_cond.wait_for(lambda: self._visible_epoch == self._wanted_epoch)",
            "            epoch = self._visible_epoch",
            "",
            "        try:",
            "            file = open(file_path, \"rb\")",
            "        except OSError:",
            "            return None  # Not found",
            "",
            "        if path.endswith(\".html\"):",
            "            with file:",
            "                content = file.read()",
            "            content = self._inject_js_into_html(content, epoch)",
            "            file = io.BytesIO(content)",
            "            content_length = len(content)",
            "        else:",
            "            content_length = os.path.getsize(file_path)",
            "",
            "        content_type = self._guess_type(file_path)",
            "        start_response(",
            "            \"200 OK\", [(\"Content-Type\", content_type), (\"Content-Length\", str(content_length))]",
            "        )",
            "        return wsgiref.util.FileWrapper(file)",
            "",
            "    @classmethod",
            "    def _inject_js_into_html(cls, content, epoch):",
            "        try:",
            "            body_end = content.rindex(b\"</body>\")",
            "        except ValueError:",
            "            body_end = len(content)",
            "        # The page will reload if the livereload poller returns a newer epoch than what it knows.",
            "        # The other timestamp becomes just a unique identifier for the initiating page.",
            "        return (",
            "            b'%b<script src=\"/js/livereload.js\"></script><script>livereload(%d, %d);</script>%b'",
            "            % (content[:body_end], epoch, _timestamp(), content[body_end:])",
            "        )",
            "",
            "    @classmethod",
            "    @functools.lru_cache()  # \"Cache\" to not repeat the same message for the same browser tab.",
            "    def _log_poll_request(cls, url, request_id):",
            "        log.info(f\"Browser connected: {url}\")",
            "",
            "    def _guess_type(cls, path):",
            "        # MkDocs only ensures a few common types (as seen in livereload_tests.py::test_mime_types).",
            "        # Other uncommon types will not be accepted.",
            "        if path.endswith((\".js\", \".JS\")):",
            "            return \"application/javascript\"",
            "        if path.endswith(\".gz\"):",
            "            return \"application/gzip\"",
            "",
            "        guess, _ = mimetypes.guess_type(path)",
            "        if guess:",
            "            return guess",
            "        return \"application/octet-stream\"",
            "",
            "",
            "class _Handler(wsgiref.simple_server.WSGIRequestHandler):",
            "    def log_request(self, code=\"-\", size=\"-\"):",
            "        level = logging.DEBUG if str(code) == \"200\" else logging.WARNING",
            "        log.log(level, f'\"{self.requestline}\" code {code}')",
            "",
            "    def log_message(self, format, *args):",
            "        log.debug(format, *args)",
            "",
            "",
            "def _timestamp():",
            "    return round(time.monotonic() * 1000)"
        ],
        "afterPatchFile": [
            "import functools",
            "import io",
            "import logging",
            "import mimetypes",
            "import os",
            "import os.path",
            "import re",
            "import socketserver",
            "import threading",
            "import time",
            "import warnings",
            "import wsgiref.simple_server",
            "",
            "import watchdog.events",
            "import watchdog.observers.polling",
            "",
            "",
            "class _LoggerAdapter(logging.LoggerAdapter):",
            "    def process(self, msg, kwargs):",
            "        return time.strftime(\"[%H:%M:%S] \") + msg, kwargs",
            "",
            "",
            "log = _LoggerAdapter(logging.getLogger(__name__), {})",
            "",
            "",
            "class LiveReloadServer(socketserver.ThreadingMixIn, wsgiref.simple_server.WSGIServer):",
            "    daemon_threads = True",
            "    poll_response_timeout = 60",
            "",
            "    def __init__(",
            "        self,",
            "        builder,",
            "        host,",
            "        port,",
            "        root,",
            "        mount_path=\"/\",",
            "        polling_interval=0.5,",
            "        shutdown_delay=0.25,",
            "        **kwargs,",
            "    ):",
            "        self.builder = builder",
            "        self.server_name = host",
            "        self.server_port = port",
            "        self.root = os.path.abspath(root)",
            "        self.mount_path = (\"/\" + mount_path.lstrip(\"/\")).rstrip(\"/\") + \"/\"",
            "        self.url = f\"http://{self.server_name}:{self.server_port}{self.mount_path}\"",
            "        self.build_delay = 0.1",
            "        self.shutdown_delay = shutdown_delay",
            "        # To allow custom error pages.",
            "        self.error_handler = lambda code: None",
            "",
            "        super().__init__((host, port), _Handler, **kwargs)",
            "        self.set_app(self.serve_request)",
            "",
            "        self._wanted_epoch = _timestamp()  # The version of the site that started building.",
            "        self._visible_epoch = self._wanted_epoch  # Latest fully built version of the site.",
            "        self._epoch_cond = threading.Condition()  # Must be held when accessing _visible_epoch.",
            "",
            "        self._to_rebuild = {}  # Used as an ordered set of functions to call.",
            "        self._rebuild_cond = threading.Condition()  # Must be held when accessing _to_rebuild.",
            "",
            "        self._shutdown = False",
            "        self.serve_thread = threading.Thread(target=lambda: self.serve_forever(shutdown_delay))",
            "        self.observer = watchdog.observers.polling.PollingObserver(timeout=polling_interval)",
            "",
            "    def watch(self, path, func=None, recursive=True):",
            "        \"\"\"Add the 'path' to watched paths, call the function and reload when any file changes under it.\"\"\"",
            "        path = os.path.abspath(path)",
            "        if func in (None, self.builder):",
            "            func = self.builder",
            "        else:",
            "            warnings.warn(",
            "                \"Plugins should not pass the 'func' parameter of watch(). \"",
            "                \"The ability to execute custom callbacks will be removed soon.\",",
            "                DeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        def callback(event):",
            "            if event.is_directory:",
            "                return",
            "            log.debug(str(event))",
            "            with self._rebuild_cond:",
            "                self._to_rebuild[func] = True",
            "                self._rebuild_cond.notify_all()",
            "",
            "        handler = watchdog.events.FileSystemEventHandler()",
            "        handler.on_any_event = callback",
            "        log.debug(f\"Watching '{path}'\")",
            "        self.observer.schedule(handler, path, recursive=recursive)",
            "",
            "    def serve(self):",
            "        self.observer.start()",
            "",
            "        log.info(f\"Serving on {self.url}\")",
            "        self.serve_thread.start()",
            "",
            "        self._build_loop()",
            "",
            "    def _build_loop(self):",
            "        while True:",
            "            with self._rebuild_cond:",
            "                while not self._rebuild_cond.wait_for(",
            "                    lambda: self._to_rebuild or self._shutdown, timeout=self.shutdown_delay",
            "                ):",
            "                    # We could have used just one wait instead of a loop + timeout, but we need",
            "                    # occasional breaks, otherwise on Windows we can't receive KeyboardInterrupt.",
            "                    pass",
            "                if self._shutdown:",
            "                    break",
            "                log.info(\"Detected file changes\")",
            "                while self._rebuild_cond.wait(timeout=self.build_delay):",
            "                    log.debug(\"Waiting for file changes to stop happening\")",
            "",
            "                self._wanted_epoch = _timestamp()",
            "                funcs = list(self._to_rebuild)",
            "                self._to_rebuild.clear()",
            "",
            "            for func in funcs:",
            "                func()",
            "",
            "            with self._epoch_cond:",
            "                log.info(\"Reloading browsers\")",
            "                self._visible_epoch = self._wanted_epoch",
            "                self._epoch_cond.notify_all()",
            "",
            "    def shutdown(self):",
            "        self.observer.stop()",
            "        with self._rebuild_cond:",
            "            self._shutdown = True",
            "            self._rebuild_cond.notify_all()",
            "",
            "        if self.serve_thread.is_alive():",
            "            super().shutdown()",
            "            self.serve_thread.join()",
            "            self.observer.join()",
            "",
            "    def serve_request(self, environ, start_response):",
            "        try:",
            "            result = self._serve_request(environ, start_response)",
            "        except Exception:",
            "            code = 500",
            "            msg = \"500 Internal Server Error\"",
            "            log.exception(msg)",
            "        else:",
            "            if result is not None:",
            "                return result",
            "            code = 404",
            "            msg = \"404 Not Found\"",
            "",
            "        error_content = None",
            "        try:",
            "            error_content = self.error_handler(code)",
            "        except Exception:",
            "            log.exception(\"Failed to render an error message!\")",
            "        if error_content is None:",
            "            error_content = msg.encode()",
            "",
            "        start_response(msg, [(\"Content-Type\", \"text/html\")])",
            "        return [error_content]",
            "",
            "    def _serve_request(self, environ, start_response):",
            "        # https://bugs.python.org/issue16679",
            "        # https://github.com/bottlepy/bottle/blob/f9b1849db4/bottle.py#L984",
            "        path = environ[\"PATH_INFO\"].encode(\"latin-1\").decode(\"utf-8\", \"ignore\")",
            "",
            "        m = re.fullmatch(r\"/livereload/([0-9]+)/[0-9]+\", path)",
            "        if m:",
            "            epoch = int(m[1])",
            "            start_response(\"200 OK\", [(\"Content-Type\", \"text/plain\")])",
            "",
            "            def condition():",
            "                return self._visible_epoch > epoch",
            "",
            "            with self._epoch_cond:",
            "                if not condition():",
            "                    # Stall the browser, respond as soon as there's something new.",
            "                    # If there's not, respond anyway after a minute.",
            "                    self._log_poll_request(environ.get(\"HTTP_REFERER\"), request_id=path)",
            "                    self._epoch_cond.wait_for(condition, timeout=self.poll_response_timeout)",
            "                return [b\"%d\" % self._visible_epoch]",
            "",
            "        if path == \"/js/livereload.js\":",
            "            file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"livereload.js\")",
            "        elif path.startswith(self.mount_path):",
            "            rel_file_path = path[len(self.mount_path):].lstrip(\"/\")",
            "            if path.endswith(\"/\"):",
            "                rel_file_path += \"index.html\"",
            "            file_path = os.path.join(self.root, rel_file_path)",
            "        elif path == \"/\":",
            "            start_response(\"302 Found\", [(\"Location\", self.mount_path)])",
            "            return []",
            "        else:",
            "            return None  # Not found",
            "",
            "        # Wait until the ongoing rebuild (if any) finishes, so we're not serving a half-built site.",
            "        with self._epoch_cond:",
            "            self._epoch_cond.wait_for(lambda: self._visible_epoch == self._wanted_epoch)",
            "            epoch = self._visible_epoch",
            "",
            "        try:",
            "            file = open(file_path, \"rb\")",
            "        except OSError:",
            "            if not path.endswith(\"/\") and os.path.isfile(os.path.join(file_path, \"index.html\")):",
            "                start_response(\"302 Found\", [(\"Location\", path + \"/\")])",
            "                return []",
            "            return None  # Not found",
            "",
            "        if file_path.endswith(\".html\"):",
            "            with file:",
            "                content = file.read()",
            "            content = self._inject_js_into_html(content, epoch)",
            "            file = io.BytesIO(content)",
            "            content_length = len(content)",
            "        else:",
            "            content_length = os.path.getsize(file_path)",
            "",
            "        content_type = self._guess_type(file_path)",
            "        start_response(",
            "            \"200 OK\", [(\"Content-Type\", content_type), (\"Content-Length\", str(content_length))]",
            "        )",
            "        return wsgiref.util.FileWrapper(file)",
            "",
            "    @classmethod",
            "    def _inject_js_into_html(cls, content, epoch):",
            "        try:",
            "            body_end = content.rindex(b\"</body>\")",
            "        except ValueError:",
            "            body_end = len(content)",
            "        # The page will reload if the livereload poller returns a newer epoch than what it knows.",
            "        # The other timestamp becomes just a unique identifier for the initiating page.",
            "        return (",
            "            b'%b<script src=\"/js/livereload.js\"></script><script>livereload(%d, %d);</script>%b'",
            "            % (content[:body_end], epoch, _timestamp(), content[body_end:])",
            "        )",
            "",
            "    @classmethod",
            "    @functools.lru_cache()  # \"Cache\" to not repeat the same message for the same browser tab.",
            "    def _log_poll_request(cls, url, request_id):",
            "        log.info(f\"Browser connected: {url}\")",
            "",
            "    def _guess_type(cls, path):",
            "        # MkDocs only ensures a few common types (as seen in livereload_tests.py::test_mime_types).",
            "        # Other uncommon types will not be accepted.",
            "        if path.endswith((\".js\", \".JS\")):",
            "            return \"application/javascript\"",
            "        if path.endswith(\".gz\"):",
            "            return \"application/gzip\"",
            "",
            "        guess, _ = mimetypes.guess_type(path)",
            "        if guess:",
            "            return guess",
            "        return \"application/octet-stream\"",
            "",
            "",
            "class _Handler(wsgiref.simple_server.WSGIRequestHandler):",
            "    def log_request(self, code=\"-\", size=\"-\"):",
            "        level = logging.DEBUG if str(code) == \"200\" else logging.WARNING",
            "        log.log(level, f'\"{self.requestline}\" code {code}')",
            "",
            "    def log_message(self, format, *args):",
            "        log.debug(format, *args)",
            "",
            "",
            "def _timestamp():",
            "    return round(time.monotonic() * 1000)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "187": [
                "LiveReloadServer",
                "_serve_request"
            ],
            "188": [
                "LiveReloadServer",
                "_serve_request"
            ],
            "189": [
                "LiveReloadServer",
                "_serve_request"
            ],
            "206": [
                "LiveReloadServer",
                "_serve_request"
            ]
        },
        "addLocation": [
            "asyncua.common.connection",
            "mkdocs.livereload.LiveReloadServer.serve_request"
        ]
    },
    "mkdocs/tests/livereload_tests.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "             self.assertRegex(output, fr\"^<body>foo</body><body>bar{SCRIPT_REGEX}</body>$\")"
            },
            "1": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 294,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "     @tempdir({\"index.html\": \"<body>aaa</body>\", \"foo/index.html\": \"<body>bbb</body>\"})"
            },
            "3": {
                "beforePatchRowNumber": 296,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_serves_modified_index(self, site_dir):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 296,
                "PatchRowcode": "+    def test_serves_directory_index(self, site_dir):"
            },
            "5": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "         with testing_server(site_dir) as server:"
            },
            "6": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "             headers, output = do_request(server, \"GET /\")"
            },
            "7": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 299,
                "PatchRowcode": "             self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")"
            },
            "8": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "             self.assertEqual(headers[\"_status\"], \"200 OK\")"
            },
            "9": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             self.assertEqual(headers.get(\"content-type\"), \"text/html\")"
            },
            "10": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "             self.assertEqual(headers.get(\"content-length\"), str(len(output)))"
            },
            "11": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 303,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            _, output = do_request(server, \"GET /foo/\")"
            },
            "13": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+            for path in \"/foo/\", \"/foo/index.html\":"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+                _, output = do_request(server, \"GET /foo/\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+                self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+            with self.assertLogs(\"mkdocs.livereload\"):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+                headers, _ = do_request(server, \"GET /foo/index.html/\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+            self.assertEqual(headers[\"_status\"], \"404 Not Found\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 311,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+    @tempdir({\"foo/bar/index.html\": \"<body>aaa</body>\"})"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+    def test_redirects_to_directory(self, site_dir):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 314,
                "PatchRowcode": "+        with testing_server(site_dir, mount_path=\"/sub\") as server:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+            with self.assertLogs(\"mkdocs.livereload\"):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+                headers, _ = do_request(server, \"GET /sub/foo/bar\")"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+            self.assertEqual(headers[\"_status\"], \"302 Found\")"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+            self.assertEqual(headers.get(\"location\"), \"/sub/foo/bar/\")"
            },
            "29": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 319,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": 320,
                "PatchRowcode": "     @tempdir({\"\u044f.html\": \"<body>aaa</body>\", \"\u6d4b\u8bd52/index.html\": \"<body>bbb</body>\"})"
            },
            "31": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 321,
                "PatchRowcode": "     def test_serves_with_unicode_characters(self, site_dir):"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "",
            "import contextlib",
            "import email",
            "import io",
            "import os",
            "import sys",
            "import threading",
            "import time",
            "import unittest",
            "from pathlib import Path",
            "from unittest import mock",
            "",
            "from mkdocs.livereload import LiveReloadServer",
            "from mkdocs.tests.base import tempdir",
            "",
            "",
            "class FakeRequest:",
            "    def __init__(self, content):",
            "        self.in_file = io.BytesIO(content.encode())",
            "        self.out_file = io.BytesIO()",
            "        self.out_file.close = lambda: None",
            "",
            "    def makefile(self, *args, **kwargs):",
            "        return self.in_file",
            "",
            "    def sendall(self, data):",
            "        self.out_file.write(data)",
            "",
            "",
            "@contextlib.contextmanager",
            "def testing_server(root, builder=lambda: None, mount_path=\"/\"):",
            "    \"\"\"Create the server and start most of its parts, but don't listen on a socket.\"\"\"",
            "    with mock.patch(\"socket.socket\"):",
            "        server = LiveReloadServer(",
            "            builder,",
            "            host=\"localhost\",",
            "            port=0,",
            "            root=root,",
            "            mount_path=mount_path,",
            "            polling_interval=0.2,",
            "            bind_and_activate=False,",
            "        )",
            "        server.setup_environ()",
            "    server.observer.start()",
            "    thread = threading.Thread(target=server._build_loop, daemon=True)",
            "    thread.start()",
            "    yield server",
            "    server.shutdown()",
            "    thread.join()",
            "",
            "",
            "def do_request(server, content):",
            "    request = FakeRequest(content + \" HTTP/1.1\")",
            "    server.RequestHandlerClass(request, (\"127.0.0.1\", 0), server)",
            "    response = request.out_file.getvalue()",
            "",
            "    headers, _, content = response.partition(b\"\\r\\n\\r\\n\")",
            "    status, _, headers = headers.partition(b\"\\r\\n\")",
            "    status = status.split(None, 1)[1].decode()",
            "",
            "    headers = email.message_from_bytes(headers)",
            "    headers[\"_status\"] = status",
            "    return headers, content.decode()",
            "",
            "",
            "SCRIPT_REGEX = (",
            "    r'<script src=\"/js/livereload.js\"></script><script>livereload\\([0-9]+, [0-9]+\\);</script>'",
            ")",
            "",
            "",
            "class BuildTests(unittest.TestCase):",
            "    @tempdir({\"test.css\": \"div { color: red; }\"})",
            "    def test_serves_normal_file(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, output = do_request(server, \"GET /test.css\")",
            "            self.assertEqual(output, \"div { color: red; }\")",
            "            self.assertEqual(headers[\"_status\"], \"200 OK\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "    @tempdir({\"docs/foo.docs\": \"docs1\", \"mkdocs.yml\": \"yml1\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_basic_rebuild(self, site_dir, origin_dir):",
            "        docs_dir = Path(origin_dir, \"docs\")",
            "",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            started_building.set()",
            "            Path(site_dir, \"foo.site\").write_text(",
            "                Path(docs_dir, \"foo.docs\").read_text() + Path(origin_dir, \"mkdocs.yml\").read_text()",
            "            )",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir, rebuild)",
            "            server.watch(Path(origin_dir, \"mkdocs.yml\"), rebuild)",
            "            time.sleep(0.01)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"original\")",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"docs2\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "            started_building.clear()",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2yml1\")",
            "",
            "            Path(origin_dir, \"mkdocs.yml\").write_text(\"yml2\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "            started_building.clear()",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2yml2\")",
            "",
            "    @tempdir({\"foo.docs\": \"a\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_rebuild_after_delete(self, site_dir, docs_dir):",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            started_building.set()",
            "            Path(site_dir, \"foo.site\").unlink()",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir, rebuild)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                _, output = do_request(server, \"GET /foo.site\")",
            "",
            "            self.assertIn(\"404\", output)",
            "",
            "    @tempdir({\"aaa\": \"something\"})",
            "    def test_rebuild_after_rename(self, site_dir):",
            "        started_building = threading.Event()",
            "",
            "        with testing_server(site_dir, started_building.set) as server:",
            "            server.watch(site_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(site_dir, \"aaa\").rename(Path(site_dir, \"bbb\"))",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "    @tempdir()",
            "    def test_rebuild_on_edit(self, site_dir):",
            "        started_building = threading.Event()",
            "",
            "        with open(Path(site_dir, \"test\"), \"wb\") as f:",
            "            time.sleep(0.01)",
            "",
            "            with testing_server(site_dir, started_building.set) as server:",
            "                server.watch(site_dir)",
            "                time.sleep(0.01)",
            "",
            "                f.write(b\"hi\\n\")",
            "                f.flush()",
            "",
            "                self.assertTrue(started_building.wait(timeout=10))",
            "",
            "    @tempdir({\"foo.docs\": \"a\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_custom_action_warns(self, site_dir, docs_dir):",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            started_building.set()",
            "            content = Path(docs_dir, \"foo.docs\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content * 5)",
            "",
            "        with testing_server(site_dir) as server:",
            "            with self.assertWarnsRegex(DeprecationWarning, \"func\") as cm:",
            "                server.watch(docs_dir, rebuild)",
            "                time.sleep(0.01)",
            "            self.assertIn(\"livereload_tests.py\", cm.filename)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"bbbbb\")",
            "",
            "    @tempdir({\"foo.docs\": \"docs1\"})",
            "    @tempdir({\"foo.extra\": \"extra1\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_multiple_dirs_can_cause_rebuild(self, site_dir, extra_dir, docs_dir):",
            "        started_building = threading.Barrier(2)",
            "",
            "        def rebuild():",
            "            started_building.wait(timeout=10)",
            "            content1 = Path(docs_dir, \"foo.docs\").read_text()",
            "            content2 = Path(extra_dir, \"foo.extra\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content1 + content2)",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir)",
            "            server.watch(extra_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"docs2\")",
            "            started_building.wait(timeout=10)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2extra1\")",
            "",
            "            Path(extra_dir, \"foo.extra\").write_text(\"extra2\")",
            "            started_building.wait(timeout=10)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2extra2\")",
            "",
            "    @tempdir({\"foo.docs\": \"docs1\"})",
            "    @tempdir({\"foo.extra\": \"extra1\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_multiple_dirs_changes_rebuild_only_once(self, site_dir, extra_dir, docs_dir):",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            self.assertFalse(started_building.is_set())",
            "            started_building.set()",
            "            content1 = Path(docs_dir, \"foo.docs\").read_text()",
            "            content2 = Path(extra_dir, \"foo.extra\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content1 + content2)",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir)",
            "            server.watch(extra_dir)",
            "            time.sleep(0.01)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            Path(docs_dir, \"foo.docs\").write_text(\"docs2\")",
            "            Path(extra_dir, \"foo.extra\").write_text(\"extra2\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2extra2\")",
            "",
            "    @tempdir({\"foo.docs\": \"a\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_change_is_detected_while_building(self, site_dir, docs_dir):",
            "        before_finished_building = threading.Barrier(2)",
            "        can_finish_building = threading.Event()",
            "",
            "        def rebuild():",
            "            content = Path(docs_dir, \"foo.docs\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content * 5)",
            "            before_finished_building.wait(timeout=10)",
            "            self.assertTrue(can_finish_building.wait(timeout=10))",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "            before_finished_building.wait(timeout=10)",
            "            Path(docs_dir, \"foo.docs\").write_text(\"c\")",
            "            can_finish_building.set()",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"bbbbb\")",
            "",
            "            before_finished_building.wait(timeout=10)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"ccccc\")",
            "",
            "    @tempdir(",
            "        {",
            "            \"normal.html\": \"<html><body>hello</body></html>\",",
            "            \"no_body.html\": \"<p>hi\",",
            "            \"empty.html\": \"\",",
            "            \"multi_body.html\": \"<body>foo</body><body>bar</body>\",",
            "        }",
            "    )",
            "    def test_serves_modified_html(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, output = do_request(server, \"GET /normal.html\")",
            "            self.assertRegex(output, fr\"^<html><body>hello{SCRIPT_REGEX}</body></html>$\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "            _, output = do_request(server, \"GET /no_body.html\")",
            "            self.assertRegex(output, fr\"^<p>hi{SCRIPT_REGEX}$\")",
            "",
            "            headers, output = do_request(server, \"GET /empty.html\")",
            "            self.assertRegex(output, fr\"^{SCRIPT_REGEX}$\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "            _, output = do_request(server, \"GET /multi_body.html\")",
            "            self.assertRegex(output, fr\"^<body>foo</body><body>bar{SCRIPT_REGEX}</body>$\")",
            "",
            "    @tempdir({\"index.html\": \"<body>aaa</body>\", \"foo/index.html\": \"<body>bbb</body>\"})",
            "    def test_serves_modified_index(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, output = do_request(server, \"GET /\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "            self.assertEqual(headers[\"_status\"], \"200 OK\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "            _, output = do_request(server, \"GET /foo/\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "",
            "    @tempdir({\"\u044f.html\": \"<body>aaa</body>\", \"\u6d4b\u8bd52/index.html\": \"<body>bbb</body>\"})",
            "    def test_serves_with_unicode_characters(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            _, output = do_request(server, \"GET /\u044f.html\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "            _, output = do_request(server, \"GET /%D1%8F.html\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /%D1.html\")",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "",
            "            _, output = do_request(server, \"GET /\u6d4b\u8bd52/\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "            _, output = do_request(server, \"GET /%E6%B5%8B%E8%AF%952/index.html\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "",
            "    @tempdir()",
            "    def test_serves_js(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            for mount_path in \"/\", \"/sub/\":",
            "                server.mount_path = mount_path",
            "",
            "                headers, output = do_request(server, \"GET /js/livereload.js\")",
            "                self.assertIn(\"function livereload\", output)",
            "                self.assertEqual(headers[\"_status\"], \"200 OK\")",
            "                self.assertEqual(headers.get(\"content-type\"), \"application/javascript\")",
            "",
            "    @tempdir()",
            "    def test_serves_polling_instantly(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            _, output = do_request(server, \"GET /livereload/0/0\")",
            "            self.assertTrue(output.isdigit())",
            "",
            "    @tempdir()",
            "    @tempdir()",
            "    def test_serves_polling_after_event(self, site_dir, docs_dir):",
            "        with testing_server(site_dir) as server:",
            "            initial_epoch = server._visible_epoch",
            "",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "",
            "            _, output = do_request(server, f\"GET /livereload/{initial_epoch}/0\")",
            "",
            "            self.assertNotEqual(server._visible_epoch, initial_epoch)",
            "            self.assertEqual(output, str(server._visible_epoch))",
            "",
            "    @tempdir()",
            "    def test_serves_polling_with_timeout(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            server.poll_response_timeout = 0.2",
            "            initial_epoch = server._visible_epoch",
            "",
            "            start_time = time.monotonic()",
            "            _, output = do_request(server, f\"GET /livereload/{initial_epoch}/0\")",
            "            self.assertGreaterEqual(time.monotonic(), start_time + 0.2)",
            "            self.assertEqual(output, str(initial_epoch))",
            "",
            "    @tempdir()",
            "    def test_error_handler(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            server.error_handler = lambda code: b\"[%d]\" % code",
            "            with self.assertLogs(\"mkdocs.livereload\") as cm:",
            "                headers, output = do_request(server, \"GET /missing\")",
            "",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "            self.assertEqual(output, \"[404]\")",
            "            self.assertRegex(",
            "                \"\\n\".join(cm.output),",
            "                r'^WARNING:mkdocs.livereload:.*\"GET /missing HTTP/1.1\" code 404',",
            "            )",
            "",
            "    @tempdir()",
            "    def test_bad_error_handler(self, site_dir):",
            "        self.maxDiff = None",
            "        with testing_server(site_dir) as server:",
            "            server.error_handler = lambda code: 0 / 0",
            "            with self.assertLogs(\"mkdocs.livereload\") as cm:",
            "                headers, output = do_request(server, \"GET /missing\")",
            "",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "            self.assertIn(\"404\", output)",
            "            self.assertRegex(",
            "                \"\\n\".join(cm.output), r\"Failed to render an error message[\\s\\S]+/missing.+code 404\"",
            "            )",
            "",
            "    @tempdir(",
            "        {",
            "            \"test.html\": \"<!DOCTYPE html>\\nhi\",",
            "            \"test.xml\": '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<foo></foo>',",
            "            \"test.css\": \"div { color: red; }\",",
            "            \"test.js\": \"use strict;\",",
            "            \"test.json\": '{\"a\": \"b\"}',",
            "        }",
            "    )",
            "    def test_mime_types(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, _ = do_request(server, \"GET /test.html\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "",
            "            headers, _ = do_request(server, \"GET /test.xml\")",
            "            self.assertIn(headers.get(\"content-type\"), [\"text/xml\", \"application/xml\"])",
            "",
            "            headers, _ = do_request(server, \"GET /test.css\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/css\")",
            "",
            "            headers, _ = do_request(server, \"GET /test.js\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"application/javascript\")",
            "",
            "            headers, _ = do_request(server, \"GET /test.json\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"application/json\")",
            "",
            "    @tempdir({\"index.html\": \"<body>aaa</body>\", \"sub/sub.html\": \"<body>bbb</body>\"})",
            "    def test_serves_from_mount_path(self, site_dir):",
            "        with testing_server(site_dir, mount_path=\"/sub\") as server:",
            "            headers, output = do_request(server, \"GET /sub/\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "",
            "            _, output = do_request(server, \"GET /sub/sub/sub.html\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /sub/sub.html\")",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "",
            "    @tempdir()",
            "    def test_redirects_to_mount_path(self, site_dir):",
            "        with testing_server(site_dir, mount_path=\"/mount/path\") as server:",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /\")",
            "            self.assertEqual(headers[\"_status\"], \"302 Found\")",
            "            self.assertEqual(headers.get(\"location\"), \"/mount/path/\")",
            "",
            "    @tempdir({\"mkdocs.yml\": \"original\", \"mkdocs2.yml\": \"original\"}, prefix=\"tmp_dir\")",
            "    @tempdir(prefix=\"origin_dir\")",
            "    @tempdir({\"subdir/foo.md\": \"original\"}, prefix=\"dest_docs_dir\")",
            "    def test_watches_direct_symlinks(self, dest_docs_dir, origin_dir, tmp_dir):",
            "        try:",
            "            Path(origin_dir, \"docs\").symlink_to(dest_docs_dir, target_is_directory=True)",
            "            Path(origin_dir, \"mkdocs.yml\").symlink_to(Path(tmp_dir, \"mkdocs.yml\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "",
            "        started_building = threading.Event()",
            "",
            "        def wait_for_build():",
            "            result = started_building.wait(timeout=10)",
            "            started_building.clear()",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                do_request(server, \"GET /\")",
            "            return result",
            "",
            "        with testing_server(tmp_dir, started_building.set) as server:",
            "            server.watch(Path(origin_dir, \"docs\"))",
            "            server.watch(Path(origin_dir, \"mkdocs.yml\"))",
            "            time.sleep(0.01)",
            "",
            "            Path(origin_dir, \"unrelated.md\").write_text(\"foo\")",
            "            self.assertFalse(started_building.wait(timeout=0.5))",
            "",
            "            Path(tmp_dir, \"mkdocs.yml\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(dest_docs_dir, \"subdir\", \"foo.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "    @tempdir([\"file_dest_1.md\", \"file_dest_2.md\", \"file_dest_unused.md\"], prefix=\"tmp_dir\")",
            "    @tempdir([\"file_under.md\"], prefix=\"dir_to_link_to\")",
            "    @tempdir()",
            "    def test_watches_through_symlinks(self, docs_dir, dir_to_link_to, tmp_dir):",
            "        try:",
            "            Path(docs_dir, \"link1.md\").symlink_to(Path(tmp_dir, \"file_dest_1.md\"))",
            "            Path(docs_dir, \"linked_dir\").symlink_to(dir_to_link_to, target_is_directory=True)",
            "",
            "            Path(dir_to_link_to, \"sublink.md\").symlink_to(Path(tmp_dir, \"file_dest_2.md\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "",
            "        started_building = threading.Event()",
            "",
            "        def wait_for_build():",
            "            result = started_building.wait(timeout=10)",
            "            started_building.clear()",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                do_request(server, \"GET /\")",
            "            return result",
            "",
            "        with testing_server(docs_dir, started_building.set) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(tmp_dir, \"file_dest_1.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(dir_to_link_to, \"file_under.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(tmp_dir, \"file_dest_2.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(docs_dir, \"link1.md\").unlink()",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(tmp_dir, \"file_dest_unused.md\").write_text(\"edited\")",
            "            self.assertFalse(started_building.wait(timeout=0.5))",
            "",
            "    @tempdir(prefix=\"site_dir\")",
            "    @tempdir([\"docs/unused.md\", \"README.md\"], prefix=\"origin_dir\")",
            "    def test_watches_through_relative_symlinks(self, origin_dir, site_dir):",
            "        docs_dir = Path(origin_dir, \"docs\")",
            "        old_cwd = os.getcwd()",
            "        os.chdir(docs_dir)",
            "        try:",
            "            Path(docs_dir, \"README.md\").symlink_to(Path(\"..\", \"README.md\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "        finally:",
            "            os.chdir(old_cwd)",
            "",
            "        started_building = threading.Event()",
            "",
            "        with testing_server(docs_dir, started_building.set) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(origin_dir, \"README.md\").write_text(\"edited\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "    @tempdir()",
            "    def test_watch_with_broken_symlinks(self, docs_dir):",
            "        Path(docs_dir, \"subdir\").mkdir()",
            "",
            "        try:",
            "            if sys.platform != \"win32\":",
            "                Path(docs_dir, \"subdir\", \"circular\").symlink_to(Path(docs_dir))",
            "",
            "            Path(docs_dir, \"broken_1\").symlink_to(Path(docs_dir, \"oh no\"))",
            "            Path(docs_dir, \"broken_2\").symlink_to(Path(docs_dir, \"oh no\"), target_is_directory=True)",
            "            Path(docs_dir, \"broken_3\").symlink_to(Path(docs_dir, \"broken_2\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "",
            "        started_building = threading.Event()",
            "        with testing_server(docs_dir, started_building.set) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"subdir\", \"test\").write_text(\"test\")",
            "            self.assertTrue(started_building.wait(timeout=10))"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "",
            "import contextlib",
            "import email",
            "import io",
            "import os",
            "import sys",
            "import threading",
            "import time",
            "import unittest",
            "from pathlib import Path",
            "from unittest import mock",
            "",
            "from mkdocs.livereload import LiveReloadServer",
            "from mkdocs.tests.base import tempdir",
            "",
            "",
            "class FakeRequest:",
            "    def __init__(self, content):",
            "        self.in_file = io.BytesIO(content.encode())",
            "        self.out_file = io.BytesIO()",
            "        self.out_file.close = lambda: None",
            "",
            "    def makefile(self, *args, **kwargs):",
            "        return self.in_file",
            "",
            "    def sendall(self, data):",
            "        self.out_file.write(data)",
            "",
            "",
            "@contextlib.contextmanager",
            "def testing_server(root, builder=lambda: None, mount_path=\"/\"):",
            "    \"\"\"Create the server and start most of its parts, but don't listen on a socket.\"\"\"",
            "    with mock.patch(\"socket.socket\"):",
            "        server = LiveReloadServer(",
            "            builder,",
            "            host=\"localhost\",",
            "            port=0,",
            "            root=root,",
            "            mount_path=mount_path,",
            "            polling_interval=0.2,",
            "            bind_and_activate=False,",
            "        )",
            "        server.setup_environ()",
            "    server.observer.start()",
            "    thread = threading.Thread(target=server._build_loop, daemon=True)",
            "    thread.start()",
            "    yield server",
            "    server.shutdown()",
            "    thread.join()",
            "",
            "",
            "def do_request(server, content):",
            "    request = FakeRequest(content + \" HTTP/1.1\")",
            "    server.RequestHandlerClass(request, (\"127.0.0.1\", 0), server)",
            "    response = request.out_file.getvalue()",
            "",
            "    headers, _, content = response.partition(b\"\\r\\n\\r\\n\")",
            "    status, _, headers = headers.partition(b\"\\r\\n\")",
            "    status = status.split(None, 1)[1].decode()",
            "",
            "    headers = email.message_from_bytes(headers)",
            "    headers[\"_status\"] = status",
            "    return headers, content.decode()",
            "",
            "",
            "SCRIPT_REGEX = (",
            "    r'<script src=\"/js/livereload.js\"></script><script>livereload\\([0-9]+, [0-9]+\\);</script>'",
            ")",
            "",
            "",
            "class BuildTests(unittest.TestCase):",
            "    @tempdir({\"test.css\": \"div { color: red; }\"})",
            "    def test_serves_normal_file(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, output = do_request(server, \"GET /test.css\")",
            "            self.assertEqual(output, \"div { color: red; }\")",
            "            self.assertEqual(headers[\"_status\"], \"200 OK\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "    @tempdir({\"docs/foo.docs\": \"docs1\", \"mkdocs.yml\": \"yml1\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_basic_rebuild(self, site_dir, origin_dir):",
            "        docs_dir = Path(origin_dir, \"docs\")",
            "",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            started_building.set()",
            "            Path(site_dir, \"foo.site\").write_text(",
            "                Path(docs_dir, \"foo.docs\").read_text() + Path(origin_dir, \"mkdocs.yml\").read_text()",
            "            )",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir, rebuild)",
            "            server.watch(Path(origin_dir, \"mkdocs.yml\"), rebuild)",
            "            time.sleep(0.01)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"original\")",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"docs2\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "            started_building.clear()",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2yml1\")",
            "",
            "            Path(origin_dir, \"mkdocs.yml\").write_text(\"yml2\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "            started_building.clear()",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2yml2\")",
            "",
            "    @tempdir({\"foo.docs\": \"a\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_rebuild_after_delete(self, site_dir, docs_dir):",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            started_building.set()",
            "            Path(site_dir, \"foo.site\").unlink()",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir, rebuild)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                _, output = do_request(server, \"GET /foo.site\")",
            "",
            "            self.assertIn(\"404\", output)",
            "",
            "    @tempdir({\"aaa\": \"something\"})",
            "    def test_rebuild_after_rename(self, site_dir):",
            "        started_building = threading.Event()",
            "",
            "        with testing_server(site_dir, started_building.set) as server:",
            "            server.watch(site_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(site_dir, \"aaa\").rename(Path(site_dir, \"bbb\"))",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "    @tempdir()",
            "    def test_rebuild_on_edit(self, site_dir):",
            "        started_building = threading.Event()",
            "",
            "        with open(Path(site_dir, \"test\"), \"wb\") as f:",
            "            time.sleep(0.01)",
            "",
            "            with testing_server(site_dir, started_building.set) as server:",
            "                server.watch(site_dir)",
            "                time.sleep(0.01)",
            "",
            "                f.write(b\"hi\\n\")",
            "                f.flush()",
            "",
            "                self.assertTrue(started_building.wait(timeout=10))",
            "",
            "    @tempdir({\"foo.docs\": \"a\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_custom_action_warns(self, site_dir, docs_dir):",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            started_building.set()",
            "            content = Path(docs_dir, \"foo.docs\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content * 5)",
            "",
            "        with testing_server(site_dir) as server:",
            "            with self.assertWarnsRegex(DeprecationWarning, \"func\") as cm:",
            "                server.watch(docs_dir, rebuild)",
            "                time.sleep(0.01)",
            "            self.assertIn(\"livereload_tests.py\", cm.filename)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"bbbbb\")",
            "",
            "    @tempdir({\"foo.docs\": \"docs1\"})",
            "    @tempdir({\"foo.extra\": \"extra1\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_multiple_dirs_can_cause_rebuild(self, site_dir, extra_dir, docs_dir):",
            "        started_building = threading.Barrier(2)",
            "",
            "        def rebuild():",
            "            started_building.wait(timeout=10)",
            "            content1 = Path(docs_dir, \"foo.docs\").read_text()",
            "            content2 = Path(extra_dir, \"foo.extra\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content1 + content2)",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir)",
            "            server.watch(extra_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"docs2\")",
            "            started_building.wait(timeout=10)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2extra1\")",
            "",
            "            Path(extra_dir, \"foo.extra\").write_text(\"extra2\")",
            "            started_building.wait(timeout=10)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2extra2\")",
            "",
            "    @tempdir({\"foo.docs\": \"docs1\"})",
            "    @tempdir({\"foo.extra\": \"extra1\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_multiple_dirs_changes_rebuild_only_once(self, site_dir, extra_dir, docs_dir):",
            "        started_building = threading.Event()",
            "",
            "        def rebuild():",
            "            self.assertFalse(started_building.is_set())",
            "            started_building.set()",
            "            content1 = Path(docs_dir, \"foo.docs\").read_text()",
            "            content2 = Path(extra_dir, \"foo.extra\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content1 + content2)",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir)",
            "            server.watch(extra_dir)",
            "            time.sleep(0.01)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            Path(docs_dir, \"foo.docs\").write_text(\"docs2\")",
            "            Path(extra_dir, \"foo.extra\").write_text(\"extra2\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"docs2extra2\")",
            "",
            "    @tempdir({\"foo.docs\": \"a\"})",
            "    @tempdir({\"foo.site\": \"original\"})",
            "    def test_change_is_detected_while_building(self, site_dir, docs_dir):",
            "        before_finished_building = threading.Barrier(2)",
            "        can_finish_building = threading.Event()",
            "",
            "        def rebuild():",
            "            content = Path(docs_dir, \"foo.docs\").read_text()",
            "            Path(site_dir, \"foo.site\").write_text(content * 5)",
            "            before_finished_building.wait(timeout=10)",
            "            self.assertTrue(can_finish_building.wait(timeout=10))",
            "",
            "        with testing_server(site_dir, rebuild) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "            before_finished_building.wait(timeout=10)",
            "            Path(docs_dir, \"foo.docs\").write_text(\"c\")",
            "            can_finish_building.set()",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"bbbbb\")",
            "",
            "            before_finished_building.wait(timeout=10)",
            "",
            "            _, output = do_request(server, \"GET /foo.site\")",
            "            self.assertEqual(output, \"ccccc\")",
            "",
            "    @tempdir(",
            "        {",
            "            \"normal.html\": \"<html><body>hello</body></html>\",",
            "            \"no_body.html\": \"<p>hi\",",
            "            \"empty.html\": \"\",",
            "            \"multi_body.html\": \"<body>foo</body><body>bar</body>\",",
            "        }",
            "    )",
            "    def test_serves_modified_html(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, output = do_request(server, \"GET /normal.html\")",
            "            self.assertRegex(output, fr\"^<html><body>hello{SCRIPT_REGEX}</body></html>$\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "            _, output = do_request(server, \"GET /no_body.html\")",
            "            self.assertRegex(output, fr\"^<p>hi{SCRIPT_REGEX}$\")",
            "",
            "            headers, output = do_request(server, \"GET /empty.html\")",
            "            self.assertRegex(output, fr\"^{SCRIPT_REGEX}$\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "            _, output = do_request(server, \"GET /multi_body.html\")",
            "            self.assertRegex(output, fr\"^<body>foo</body><body>bar{SCRIPT_REGEX}</body>$\")",
            "",
            "    @tempdir({\"index.html\": \"<body>aaa</body>\", \"foo/index.html\": \"<body>bbb</body>\"})",
            "    def test_serves_directory_index(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, output = do_request(server, \"GET /\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "            self.assertEqual(headers[\"_status\"], \"200 OK\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "            self.assertEqual(headers.get(\"content-length\"), str(len(output)))",
            "",
            "            for path in \"/foo/\", \"/foo/index.html\":",
            "                _, output = do_request(server, \"GET /foo/\")",
            "                self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /foo/index.html/\")",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "",
            "    @tempdir({\"foo/bar/index.html\": \"<body>aaa</body>\"})",
            "    def test_redirects_to_directory(self, site_dir):",
            "        with testing_server(site_dir, mount_path=\"/sub\") as server:",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /sub/foo/bar\")",
            "            self.assertEqual(headers[\"_status\"], \"302 Found\")",
            "            self.assertEqual(headers.get(\"location\"), \"/sub/foo/bar/\")",
            "",
            "    @tempdir({\"\u044f.html\": \"<body>aaa</body>\", \"\u6d4b\u8bd52/index.html\": \"<body>bbb</body>\"})",
            "    def test_serves_with_unicode_characters(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            _, output = do_request(server, \"GET /\u044f.html\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "            _, output = do_request(server, \"GET /%D1%8F.html\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /%D1.html\")",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "",
            "            _, output = do_request(server, \"GET /\u6d4b\u8bd52/\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "            _, output = do_request(server, \"GET /%E6%B5%8B%E8%AF%952/index.html\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "",
            "    @tempdir()",
            "    def test_serves_js(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            for mount_path in \"/\", \"/sub/\":",
            "                server.mount_path = mount_path",
            "",
            "                headers, output = do_request(server, \"GET /js/livereload.js\")",
            "                self.assertIn(\"function livereload\", output)",
            "                self.assertEqual(headers[\"_status\"], \"200 OK\")",
            "                self.assertEqual(headers.get(\"content-type\"), \"application/javascript\")",
            "",
            "    @tempdir()",
            "    def test_serves_polling_instantly(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            _, output = do_request(server, \"GET /livereload/0/0\")",
            "            self.assertTrue(output.isdigit())",
            "",
            "    @tempdir()",
            "    @tempdir()",
            "    def test_serves_polling_after_event(self, site_dir, docs_dir):",
            "        with testing_server(site_dir) as server:",
            "            initial_epoch = server._visible_epoch",
            "",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"foo.docs\").write_text(\"b\")",
            "",
            "            _, output = do_request(server, f\"GET /livereload/{initial_epoch}/0\")",
            "",
            "            self.assertNotEqual(server._visible_epoch, initial_epoch)",
            "            self.assertEqual(output, str(server._visible_epoch))",
            "",
            "    @tempdir()",
            "    def test_serves_polling_with_timeout(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            server.poll_response_timeout = 0.2",
            "            initial_epoch = server._visible_epoch",
            "",
            "            start_time = time.monotonic()",
            "            _, output = do_request(server, f\"GET /livereload/{initial_epoch}/0\")",
            "            self.assertGreaterEqual(time.monotonic(), start_time + 0.2)",
            "            self.assertEqual(output, str(initial_epoch))",
            "",
            "    @tempdir()",
            "    def test_error_handler(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            server.error_handler = lambda code: b\"[%d]\" % code",
            "            with self.assertLogs(\"mkdocs.livereload\") as cm:",
            "                headers, output = do_request(server, \"GET /missing\")",
            "",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "            self.assertEqual(output, \"[404]\")",
            "            self.assertRegex(",
            "                \"\\n\".join(cm.output),",
            "                r'^WARNING:mkdocs.livereload:.*\"GET /missing HTTP/1.1\" code 404',",
            "            )",
            "",
            "    @tempdir()",
            "    def test_bad_error_handler(self, site_dir):",
            "        self.maxDiff = None",
            "        with testing_server(site_dir) as server:",
            "            server.error_handler = lambda code: 0 / 0",
            "            with self.assertLogs(\"mkdocs.livereload\") as cm:",
            "                headers, output = do_request(server, \"GET /missing\")",
            "",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "            self.assertIn(\"404\", output)",
            "            self.assertRegex(",
            "                \"\\n\".join(cm.output), r\"Failed to render an error message[\\s\\S]+/missing.+code 404\"",
            "            )",
            "",
            "    @tempdir(",
            "        {",
            "            \"test.html\": \"<!DOCTYPE html>\\nhi\",",
            "            \"test.xml\": '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<foo></foo>',",
            "            \"test.css\": \"div { color: red; }\",",
            "            \"test.js\": \"use strict;\",",
            "            \"test.json\": '{\"a\": \"b\"}',",
            "        }",
            "    )",
            "    def test_mime_types(self, site_dir):",
            "        with testing_server(site_dir) as server:",
            "            headers, _ = do_request(server, \"GET /test.html\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "",
            "            headers, _ = do_request(server, \"GET /test.xml\")",
            "            self.assertIn(headers.get(\"content-type\"), [\"text/xml\", \"application/xml\"])",
            "",
            "            headers, _ = do_request(server, \"GET /test.css\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/css\")",
            "",
            "            headers, _ = do_request(server, \"GET /test.js\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"application/javascript\")",
            "",
            "            headers, _ = do_request(server, \"GET /test.json\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"application/json\")",
            "",
            "    @tempdir({\"index.html\": \"<body>aaa</body>\", \"sub/sub.html\": \"<body>bbb</body>\"})",
            "    def test_serves_from_mount_path(self, site_dir):",
            "        with testing_server(site_dir, mount_path=\"/sub\") as server:",
            "            headers, output = do_request(server, \"GET /sub/\")",
            "            self.assertRegex(output, fr\"^<body>aaa{SCRIPT_REGEX}</body>$\")",
            "            self.assertEqual(headers.get(\"content-type\"), \"text/html\")",
            "",
            "            _, output = do_request(server, \"GET /sub/sub/sub.html\")",
            "            self.assertRegex(output, fr\"^<body>bbb{SCRIPT_REGEX}</body>$\")",
            "",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /sub/sub.html\")",
            "            self.assertEqual(headers[\"_status\"], \"404 Not Found\")",
            "",
            "    @tempdir()",
            "    def test_redirects_to_mount_path(self, site_dir):",
            "        with testing_server(site_dir, mount_path=\"/mount/path\") as server:",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                headers, _ = do_request(server, \"GET /\")",
            "            self.assertEqual(headers[\"_status\"], \"302 Found\")",
            "            self.assertEqual(headers.get(\"location\"), \"/mount/path/\")",
            "",
            "    @tempdir({\"mkdocs.yml\": \"original\", \"mkdocs2.yml\": \"original\"}, prefix=\"tmp_dir\")",
            "    @tempdir(prefix=\"origin_dir\")",
            "    @tempdir({\"subdir/foo.md\": \"original\"}, prefix=\"dest_docs_dir\")",
            "    def test_watches_direct_symlinks(self, dest_docs_dir, origin_dir, tmp_dir):",
            "        try:",
            "            Path(origin_dir, \"docs\").symlink_to(dest_docs_dir, target_is_directory=True)",
            "            Path(origin_dir, \"mkdocs.yml\").symlink_to(Path(tmp_dir, \"mkdocs.yml\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "",
            "        started_building = threading.Event()",
            "",
            "        def wait_for_build():",
            "            result = started_building.wait(timeout=10)",
            "            started_building.clear()",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                do_request(server, \"GET /\")",
            "            return result",
            "",
            "        with testing_server(tmp_dir, started_building.set) as server:",
            "            server.watch(Path(origin_dir, \"docs\"))",
            "            server.watch(Path(origin_dir, \"mkdocs.yml\"))",
            "            time.sleep(0.01)",
            "",
            "            Path(origin_dir, \"unrelated.md\").write_text(\"foo\")",
            "            self.assertFalse(started_building.wait(timeout=0.5))",
            "",
            "            Path(tmp_dir, \"mkdocs.yml\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(dest_docs_dir, \"subdir\", \"foo.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "    @tempdir([\"file_dest_1.md\", \"file_dest_2.md\", \"file_dest_unused.md\"], prefix=\"tmp_dir\")",
            "    @tempdir([\"file_under.md\"], prefix=\"dir_to_link_to\")",
            "    @tempdir()",
            "    def test_watches_through_symlinks(self, docs_dir, dir_to_link_to, tmp_dir):",
            "        try:",
            "            Path(docs_dir, \"link1.md\").symlink_to(Path(tmp_dir, \"file_dest_1.md\"))",
            "            Path(docs_dir, \"linked_dir\").symlink_to(dir_to_link_to, target_is_directory=True)",
            "",
            "            Path(dir_to_link_to, \"sublink.md\").symlink_to(Path(tmp_dir, \"file_dest_2.md\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "",
            "        started_building = threading.Event()",
            "",
            "        def wait_for_build():",
            "            result = started_building.wait(timeout=10)",
            "            started_building.clear()",
            "            with self.assertLogs(\"mkdocs.livereload\"):",
            "                do_request(server, \"GET /\")",
            "            return result",
            "",
            "        with testing_server(docs_dir, started_building.set) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(tmp_dir, \"file_dest_1.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(dir_to_link_to, \"file_under.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(tmp_dir, \"file_dest_2.md\").write_text(\"edited\")",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(docs_dir, \"link1.md\").unlink()",
            "            self.assertTrue(wait_for_build())",
            "",
            "            Path(tmp_dir, \"file_dest_unused.md\").write_text(\"edited\")",
            "            self.assertFalse(started_building.wait(timeout=0.5))",
            "",
            "    @tempdir(prefix=\"site_dir\")",
            "    @tempdir([\"docs/unused.md\", \"README.md\"], prefix=\"origin_dir\")",
            "    def test_watches_through_relative_symlinks(self, origin_dir, site_dir):",
            "        docs_dir = Path(origin_dir, \"docs\")",
            "        old_cwd = os.getcwd()",
            "        os.chdir(docs_dir)",
            "        try:",
            "            Path(docs_dir, \"README.md\").symlink_to(Path(\"..\", \"README.md\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "        finally:",
            "            os.chdir(old_cwd)",
            "",
            "        started_building = threading.Event()",
            "",
            "        with testing_server(docs_dir, started_building.set) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(origin_dir, \"README.md\").write_text(\"edited\")",
            "            self.assertTrue(started_building.wait(timeout=10))",
            "",
            "    @tempdir()",
            "    def test_watch_with_broken_symlinks(self, docs_dir):",
            "        Path(docs_dir, \"subdir\").mkdir()",
            "",
            "        try:",
            "            if sys.platform != \"win32\":",
            "                Path(docs_dir, \"subdir\", \"circular\").symlink_to(Path(docs_dir))",
            "",
            "            Path(docs_dir, \"broken_1\").symlink_to(Path(docs_dir, \"oh no\"))",
            "            Path(docs_dir, \"broken_2\").symlink_to(Path(docs_dir, \"oh no\"), target_is_directory=True)",
            "            Path(docs_dir, \"broken_3\").symlink_to(Path(docs_dir, \"broken_2\"))",
            "        except NotImplementedError:  # PyPy on Windows",
            "            self.skipTest(\"Creating symlinks not supported\")",
            "",
            "        started_building = threading.Event()",
            "        with testing_server(docs_dir, started_building.set) as server:",
            "            server.watch(docs_dir)",
            "            time.sleep(0.01)",
            "",
            "            Path(docs_dir, \"subdir\", \"test\").write_text(\"test\")",
            "            self.assertTrue(started_building.wait(timeout=10))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "296": [
                "BuildTests",
                "test_serves_modified_index"
            ],
            "304": [
                "BuildTests",
                "test_serves_modified_index"
            ],
            "305": [
                "BuildTests",
                "test_serves_modified_index"
            ]
        },
        "addLocation": []
    }
}