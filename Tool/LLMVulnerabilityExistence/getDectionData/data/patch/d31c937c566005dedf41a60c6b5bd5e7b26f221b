{
    "cinder/image/image_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 312,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "     with fileutils.remove_path_on_error(tmp):"
            },
            "1": {
                "beforePatchRowNumber": 313,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "         LOG.debug(\"%s was %s, converting to %s\" %"
            },
            "2": {
                "beforePatchRowNumber": 314,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "                   (image_id, volume_format, image_meta['disk_format']))"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 316,
                "PatchRowcode": "+        data = qemu_img_info(volume_path)"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 317,
                "PatchRowcode": "+        backing_file = data.backing_file"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 318,
                "PatchRowcode": "+        fmt = data.file_format"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 319,
                "PatchRowcode": "+        if backing_file is not None:"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 320,
                "PatchRowcode": "+            # Disallow backing files as a security measure."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 321,
                "PatchRowcode": "+            # This prevents a user from writing an image header into a raw"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 322,
                "PatchRowcode": "+            # volume with a backing file pointing to data they wish to"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 323,
                "PatchRowcode": "+            # access."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 324,
                "PatchRowcode": "+            raise exception.ImageUnacceptable("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 325,
                "PatchRowcode": "+                image_id=image_id,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 326,
                "PatchRowcode": "+                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 327,
                "PatchRowcode": "+                % {'fmt': fmt, 'backing_file': backing_file})"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 328,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 315,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "         convert_image(volume_path, tmp, image_meta['disk_format'],"
            },
            "18": {
                "beforePatchRowNumber": 316,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "                       bps_limit=CONF.volume_copy_bps_limit)"
            },
            "19": {
                "beforePatchRowNumber": 317,
                "afterPatchRowNumber": 331,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Helper methods to deal with images.",
            "",
            "This is essentially a copy from nova.virt.images.py",
            "Some slight modifications, but at some point",
            "we should look at maybe pushing this up to Oslo",
            "\"\"\"",
            "",
            "",
            "import contextlib",
            "import os",
            "import tempfile",
            "",
            "from oslo.config import cfg",
            "",
            "from cinder import exception",
            "from cinder.i18n import _",
            "from cinder.openstack.common import fileutils",
            "from cinder.openstack.common import imageutils",
            "from cinder.openstack.common import log as logging",
            "from cinder.openstack.common import processutils",
            "from cinder.openstack.common import timeutils",
            "from cinder.openstack.common import units",
            "from cinder import utils",
            "from cinder.volume import utils as volume_utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "image_helper_opt = [cfg.StrOpt('image_conversion_dir',",
            "                               default='$state_path/conversion',",
            "                               help='Directory used for temporary storage '",
            "                                    'during image conversion'), ]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(image_helper_opt)",
            "",
            "",
            "def qemu_img_info(path):",
            "    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"",
            "    cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)",
            "    if os.name == 'nt':",
            "        cmd = cmd[2:]",
            "    out, err = utils.execute(*cmd, run_as_root=True)",
            "    return imageutils.QemuImgInfo(out)",
            "",
            "",
            "def convert_image(source, dest, out_format, bps_limit=None):",
            "    \"\"\"Convert image to other format.\"\"\"",
            "",
            "    cmd = ('qemu-img', 'convert',",
            "           '-O', out_format, source, dest)",
            "",
            "    # Check whether O_DIRECT is supported and set '-t none' if it is",
            "    # This is needed to ensure that all data hit the device before",
            "    # it gets unmapped remotely from the host for some backends",
            "    # Reference Bug: #1363016",
            "",
            "    # NOTE(jdg): In the case of file devices qemu does the",
            "    # flush properly and more efficiently than would be done",
            "    # setting O_DIRECT, so check for that and skip the",
            "    # setting for non BLK devs",
            "    if (utils.is_blk_device(dest) and",
            "            volume_utils.check_for_odirect_support(source,",
            "                                                   dest,",
            "                                                   'oflag=direct')):",
            "        cmd = ('qemu-img', 'convert',",
            "               '-t', 'none',",
            "               '-O', out_format, source, dest)",
            "",
            "    start_time = timeutils.utcnow()",
            "    cgcmd = volume_utils.setup_blkio_cgroup(source, dest, bps_limit)",
            "    if cgcmd:",
            "        cmd = tuple(cgcmd) + cmd",
            "    utils.execute(*cmd, run_as_root=True)",
            "",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(source).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image conversion details: src %(src)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec, destination %(dest)s\")",
            "    LOG.debug(msg % {\"src\": source,",
            "                     \"sz\": fsz_mb,",
            "                     \"duration\": duration,",
            "                     \"dest\": dest})",
            "",
            "    msg = _(\"Converted %(sz).2f MB image at %(mbps).2f MB/s\")",
            "    LOG.info(msg % {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def resize_image(source, size, run_as_root=False):",
            "    \"\"\"Changes the virtual size of the image.\"\"\"",
            "    cmd = ('qemu-img', 'resize', source, '%sG' % size)",
            "    utils.execute(*cmd, run_as_root=run_as_root)",
            "",
            "",
            "def fetch(context, image_service, image_id, path, _user_id, _project_id):",
            "    # TODO(vish): Improve context handling and add owner and auth data",
            "    #             when it is added to glance.  Right now there is no",
            "    #             auth checking in glance, so we assume that access was",
            "    #             checked before we got here.",
            "    start_time = timeutils.utcnow()",
            "    with fileutils.remove_path_on_error(path):",
            "        with open(path, \"wb\") as image_file:",
            "            image_service.download(context, image_id, image_file)",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(image_file.name).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image fetch details: dest %(dest)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec\")",
            "    LOG.debug(msg % {\"dest\": image_file.name,",
            "                     \"sz\": fsz_mb,",
            "                     \"duration\": duration})",
            "    msg = _(\"Image download %(sz).2f MB at %(mbps).2f MB/s\")",
            "    LOG.info(msg % {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def fetch_verify_image(context, image_service, image_id, dest,",
            "                       user_id=None, project_id=None, size=None):",
            "    fetch(context, image_service, image_id, dest,",
            "          None, None)",
            "",
            "    with fileutils.remove_path_on_error(dest):",
            "        data = qemu_img_info(dest)",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %",
            "                        {'fmt': fmt, 'backing_file': backing_file}))",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and data.virtual_size > size:",
            "            params = {'image_size': data.virtual_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "",
            "def fetch_to_vhd(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'vpc',",
            "                           blocksize, user_id, project_id)",
            "",
            "",
            "def fetch_to_raw(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None, size=None):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'raw',",
            "                           blocksize, user_id, project_id, size)",
            "",
            "",
            "def fetch_to_volume_format(context, image_service,",
            "                           image_id, dest, volume_format, blocksize,",
            "                           user_id=None, project_id=None, size=None):",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    qemu_img = True",
            "    image_meta = image_service.show(context, image_id)",
            "",
            "    # NOTE(avishay): I'm not crazy about creating temp files which may be",
            "    # large and cause disk full errors which would confuse users.",
            "    # Unfortunately it seems that you can't pipe to 'qemu-img convert' because",
            "    # it seeks. Maybe we can think of something for a future version.",
            "    with temporary_file() as tmp:",
            "        # We may be on a system that doesn't have qemu-img installed.  That",
            "        # is ok if we are working with a RAW image.  This logic checks to see",
            "        # if qemu-img is installed.  If not we make sure the image is RAW and",
            "        # throw an exception if not.  Otherwise we stop before needing",
            "        # qemu-img.  Systems with qemu-img will always progress through the",
            "        # whole function.",
            "        try:",
            "            # Use the empty tmp file to make sure qemu_img_info works.",
            "            qemu_img_info(tmp)",
            "        except processutils.ProcessExecutionError:",
            "            qemu_img = False",
            "            if image_meta:",
            "                if image_meta['disk_format'] != 'raw':",
            "                    raise exception.ImageUnacceptable(",
            "                        reason=_(\"qemu-img is not installed and image is of \"",
            "                                 \"type %s.  Only RAW images can be used if \"",
            "                                 \"qemu-img is not installed.\") %",
            "                        image_meta['disk_format'],",
            "                        image_id=image_id)",
            "            else:",
            "                raise exception.ImageUnacceptable(",
            "                    reason=_(\"qemu-img is not installed and the disk \"",
            "                             \"format is not specified.  Only RAW images \"",
            "                             \"can be used if qemu-img is not installed.\"),",
            "                    image_id=image_id)",
            "",
            "        fetch(context, image_service, image_id, tmp, user_id, project_id)",
            "",
            "        if is_xenserver_image(context, image_service, image_id):",
            "            replace_xenserver_image_with_coalesced_vhd(tmp)",
            "",
            "        if not qemu_img:",
            "            # qemu-img is not installed but we do have a RAW image.  As a",
            "            # result we only need to copy the image to the destination and then",
            "            # return.",
            "            LOG.debug('Copying image from %(tmp)s to volume %(dest)s - '",
            "                      'size: %(size)s' % {'tmp': tmp, 'dest': dest,",
            "                                          'size': image_meta['size']})",
            "            volume_utils.copy_volume(tmp, dest, image_meta['size'], blocksize)",
            "            return",
            "",
            "        data = qemu_img_info(tmp)",
            "        virt_size = data.virtual_size / units.Gi",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and virt_size > size:",
            "            params = {'image_size': virt_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file, })",
            "",
            "        # NOTE(jdg): I'm using qemu-img convert to write",
            "        # to the volume regardless if it *needs* conversion or not",
            "        # TODO(avishay): We can speed this up by checking if the image is raw",
            "        # and if so, writing directly to the device. However, we need to keep",
            "        # check via 'qemu-img info' that what we copied was in fact a raw",
            "        # image and not a different format with a backing file, which may be",
            "        # malicious.",
            "        LOG.debug(\"%s was %s, converting to %s \" % (image_id, fmt,",
            "                                                    volume_format))",
            "        convert_image(tmp, dest, volume_format,",
            "                      bps_limit=CONF.volume_copy_bps_limit)",
            "",
            "        data = qemu_img_info(dest)",
            "        if data.file_format != volume_format:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(vol_format)s, but format is \"",
            "                         \"now %(file_format)s\") % {'vol_format': volume_format,",
            "                                                   'file_format': data.",
            "                                                   file_format})",
            "",
            "",
            "def upload_volume(context, image_service, image_meta, volume_path,",
            "                  volume_format='raw'):",
            "    image_id = image_meta['id']",
            "    if (image_meta['disk_format'] == volume_format):",
            "        LOG.debug(\"%s was %s, no need to convert to %s\" %",
            "                  (image_id, volume_format, image_meta['disk_format']))",
            "        if os.name == 'nt' or os.access(volume_path, os.R_OK):",
            "            with fileutils.file_open(volume_path, 'rb') as image_file:",
            "                image_service.update(context, image_id, {}, image_file)",
            "        else:",
            "            with utils.temporary_chown(volume_path):",
            "                with fileutils.file_open(volume_path) as image_file:",
            "                    image_service.update(context, image_id, {}, image_file)",
            "        return",
            "",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    fd, tmp = tempfile.mkstemp(dir=CONF.image_conversion_dir)",
            "    os.close(fd)",
            "    with fileutils.remove_path_on_error(tmp):",
            "        LOG.debug(\"%s was %s, converting to %s\" %",
            "                  (image_id, volume_format, image_meta['disk_format']))",
            "        convert_image(volume_path, tmp, image_meta['disk_format'],",
            "                      bps_limit=CONF.volume_copy_bps_limit)",
            "",
            "        data = qemu_img_info(tmp)",
            "        if data.file_format != image_meta['disk_format']:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(f1)s, but format is now %(f2)s\") %",
            "                {'f1': image_meta['disk_format'], 'f2': data.file_format})",
            "",
            "        with fileutils.file_open(tmp, 'rb') as image_file:",
            "            image_service.update(context, image_id, {}, image_file)",
            "        fileutils.delete_if_exists(tmp)",
            "",
            "",
            "def is_xenserver_image(context, image_service, image_id):",
            "    image_meta = image_service.show(context, image_id)",
            "    return is_xenserver_format(image_meta)",
            "",
            "",
            "def is_xenserver_format(image_meta):",
            "    return (",
            "        image_meta['disk_format'] == 'vhd'",
            "        and image_meta['container_format'] == 'ovf'",
            "    )",
            "",
            "",
            "def file_exist(fpath):",
            "    return os.path.exists(fpath)",
            "",
            "",
            "def set_vhd_parent(vhd_path, parentpath):",
            "    utils.execute('vhd-util', 'modify', '-n', vhd_path, '-p', parentpath)",
            "",
            "",
            "def extract_targz(archive_name, target):",
            "    utils.execute('tar', '-xzf', archive_name, '-C', target)",
            "",
            "",
            "def fix_vhd_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        set_vhd_parent(child, parent)",
            "",
            "",
            "def get_vhd_size(vhd_path):",
            "    out, err = utils.execute('vhd-util', 'query', '-n', vhd_path, '-v')",
            "    return int(out)",
            "",
            "",
            "def resize_vhd(vhd_path, size, journal):",
            "    utils.execute(",
            "        'vhd-util', 'resize', '-n', vhd_path, '-s', '%d' % size, '-j', journal)",
            "",
            "",
            "def coalesce_vhd(vhd_path):",
            "    utils.execute(",
            "        'vhd-util', 'coalesce', '-n', vhd_path)",
            "",
            "",
            "def create_temporary_file(*args, **kwargs):",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    fd, tmp = tempfile.mkstemp(dir=CONF.image_conversion_dir, *args, **kwargs)",
            "    os.close(fd)",
            "    return tmp",
            "",
            "",
            "def rename_file(src, dst):",
            "    os.rename(src, dst)",
            "",
            "",
            "@contextlib.contextmanager",
            "def temporary_file(*args, **kwargs):",
            "    tmp = None",
            "    try:",
            "        tmp = create_temporary_file(*args, **kwargs)",
            "        yield tmp",
            "    finally:",
            "        if tmp:",
            "            fileutils.delete_if_exists(tmp)",
            "",
            "",
            "def temporary_dir():",
            "    return utils.tempdir(dir=CONF.image_conversion_dir)",
            "",
            "",
            "def coalesce_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        with temporary_dir() as directory_for_journal:",
            "            size = get_vhd_size(child)",
            "            journal_file = os.path.join(",
            "                directory_for_journal, 'vhd-util-resize-journal')",
            "            resize_vhd(parent, size, journal_file)",
            "            coalesce_vhd(child)",
            "",
            "    return vhd_chain[-1]",
            "",
            "",
            "def discover_vhd_chain(directory):",
            "    counter = 0",
            "    chain = []",
            "",
            "    while True:",
            "        fpath = os.path.join(directory, '%d.vhd' % counter)",
            "        if file_exist(fpath):",
            "            chain.append(fpath)",
            "        else:",
            "            break",
            "        counter += 1",
            "",
            "    return chain",
            "",
            "",
            "def replace_xenserver_image_with_coalesced_vhd(image_file):",
            "    with temporary_dir() as tempdir:",
            "        extract_targz(image_file, tempdir)",
            "        chain = discover_vhd_chain(tempdir)",
            "        fix_vhd_chain(chain)",
            "        coalesced = coalesce_chain(chain)",
            "        fileutils.delete_if_exists(image_file)",
            "        rename_file(coalesced, image_file)"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "Helper methods to deal with images.",
            "",
            "This is essentially a copy from nova.virt.images.py",
            "Some slight modifications, but at some point",
            "we should look at maybe pushing this up to Oslo",
            "\"\"\"",
            "",
            "",
            "import contextlib",
            "import os",
            "import tempfile",
            "",
            "from oslo.config import cfg",
            "",
            "from cinder import exception",
            "from cinder.i18n import _",
            "from cinder.openstack.common import fileutils",
            "from cinder.openstack.common import imageutils",
            "from cinder.openstack.common import log as logging",
            "from cinder.openstack.common import processutils",
            "from cinder.openstack.common import timeutils",
            "from cinder.openstack.common import units",
            "from cinder import utils",
            "from cinder.volume import utils as volume_utils",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "image_helper_opt = [cfg.StrOpt('image_conversion_dir',",
            "                               default='$state_path/conversion',",
            "                               help='Directory used for temporary storage '",
            "                                    'during image conversion'), ]",
            "",
            "CONF = cfg.CONF",
            "CONF.register_opts(image_helper_opt)",
            "",
            "",
            "def qemu_img_info(path):",
            "    \"\"\"Return an object containing the parsed output from qemu-img info.\"\"\"",
            "    cmd = ('env', 'LC_ALL=C', 'qemu-img', 'info', path)",
            "    if os.name == 'nt':",
            "        cmd = cmd[2:]",
            "    out, err = utils.execute(*cmd, run_as_root=True)",
            "    return imageutils.QemuImgInfo(out)",
            "",
            "",
            "def convert_image(source, dest, out_format, bps_limit=None):",
            "    \"\"\"Convert image to other format.\"\"\"",
            "",
            "    cmd = ('qemu-img', 'convert',",
            "           '-O', out_format, source, dest)",
            "",
            "    # Check whether O_DIRECT is supported and set '-t none' if it is",
            "    # This is needed to ensure that all data hit the device before",
            "    # it gets unmapped remotely from the host for some backends",
            "    # Reference Bug: #1363016",
            "",
            "    # NOTE(jdg): In the case of file devices qemu does the",
            "    # flush properly and more efficiently than would be done",
            "    # setting O_DIRECT, so check for that and skip the",
            "    # setting for non BLK devs",
            "    if (utils.is_blk_device(dest) and",
            "            volume_utils.check_for_odirect_support(source,",
            "                                                   dest,",
            "                                                   'oflag=direct')):",
            "        cmd = ('qemu-img', 'convert',",
            "               '-t', 'none',",
            "               '-O', out_format, source, dest)",
            "",
            "    start_time = timeutils.utcnow()",
            "    cgcmd = volume_utils.setup_blkio_cgroup(source, dest, bps_limit)",
            "    if cgcmd:",
            "        cmd = tuple(cgcmd) + cmd",
            "    utils.execute(*cmd, run_as_root=True)",
            "",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(source).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image conversion details: src %(src)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec, destination %(dest)s\")",
            "    LOG.debug(msg % {\"src\": source,",
            "                     \"sz\": fsz_mb,",
            "                     \"duration\": duration,",
            "                     \"dest\": dest})",
            "",
            "    msg = _(\"Converted %(sz).2f MB image at %(mbps).2f MB/s\")",
            "    LOG.info(msg % {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def resize_image(source, size, run_as_root=False):",
            "    \"\"\"Changes the virtual size of the image.\"\"\"",
            "    cmd = ('qemu-img', 'resize', source, '%sG' % size)",
            "    utils.execute(*cmd, run_as_root=run_as_root)",
            "",
            "",
            "def fetch(context, image_service, image_id, path, _user_id, _project_id):",
            "    # TODO(vish): Improve context handling and add owner and auth data",
            "    #             when it is added to glance.  Right now there is no",
            "    #             auth checking in glance, so we assume that access was",
            "    #             checked before we got here.",
            "    start_time = timeutils.utcnow()",
            "    with fileutils.remove_path_on_error(path):",
            "        with open(path, \"wb\") as image_file:",
            "            image_service.download(context, image_id, image_file)",
            "    duration = timeutils.delta_seconds(start_time, timeutils.utcnow())",
            "",
            "    # NOTE(jdg): use a default of 1, mostly for unit test, but in",
            "    # some incredible event this is 0 (cirros image?) don't barf",
            "    if duration < 1:",
            "        duration = 1",
            "    fsz_mb = os.stat(image_file.name).st_size / units.Mi",
            "    mbps = (fsz_mb / duration)",
            "    msg = (\"Image fetch details: dest %(dest)s, size %(sz).2f MB, \"",
            "           \"duration %(duration).2f sec\")",
            "    LOG.debug(msg % {\"dest\": image_file.name,",
            "                     \"sz\": fsz_mb,",
            "                     \"duration\": duration})",
            "    msg = _(\"Image download %(sz).2f MB at %(mbps).2f MB/s\")",
            "    LOG.info(msg % {\"sz\": fsz_mb, \"mbps\": mbps})",
            "",
            "",
            "def fetch_verify_image(context, image_service, image_id, dest,",
            "                       user_id=None, project_id=None, size=None):",
            "    fetch(context, image_service, image_id, dest,",
            "          None, None)",
            "",
            "    with fileutils.remove_path_on_error(dest):",
            "        data = qemu_img_info(dest)",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=(_(\"fmt=%(fmt)s backed by: %(backing_file)s\") %",
            "                        {'fmt': fmt, 'backing_file': backing_file}))",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and data.virtual_size > size:",
            "            params = {'image_size': data.virtual_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "",
            "def fetch_to_vhd(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'vpc',",
            "                           blocksize, user_id, project_id)",
            "",
            "",
            "def fetch_to_raw(context, image_service,",
            "                 image_id, dest, blocksize,",
            "                 user_id=None, project_id=None, size=None):",
            "    fetch_to_volume_format(context, image_service, image_id, dest, 'raw',",
            "                           blocksize, user_id, project_id, size)",
            "",
            "",
            "def fetch_to_volume_format(context, image_service,",
            "                           image_id, dest, volume_format, blocksize,",
            "                           user_id=None, project_id=None, size=None):",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    qemu_img = True",
            "    image_meta = image_service.show(context, image_id)",
            "",
            "    # NOTE(avishay): I'm not crazy about creating temp files which may be",
            "    # large and cause disk full errors which would confuse users.",
            "    # Unfortunately it seems that you can't pipe to 'qemu-img convert' because",
            "    # it seeks. Maybe we can think of something for a future version.",
            "    with temporary_file() as tmp:",
            "        # We may be on a system that doesn't have qemu-img installed.  That",
            "        # is ok if we are working with a RAW image.  This logic checks to see",
            "        # if qemu-img is installed.  If not we make sure the image is RAW and",
            "        # throw an exception if not.  Otherwise we stop before needing",
            "        # qemu-img.  Systems with qemu-img will always progress through the",
            "        # whole function.",
            "        try:",
            "            # Use the empty tmp file to make sure qemu_img_info works.",
            "            qemu_img_info(tmp)",
            "        except processutils.ProcessExecutionError:",
            "            qemu_img = False",
            "            if image_meta:",
            "                if image_meta['disk_format'] != 'raw':",
            "                    raise exception.ImageUnacceptable(",
            "                        reason=_(\"qemu-img is not installed and image is of \"",
            "                                 \"type %s.  Only RAW images can be used if \"",
            "                                 \"qemu-img is not installed.\") %",
            "                        image_meta['disk_format'],",
            "                        image_id=image_id)",
            "            else:",
            "                raise exception.ImageUnacceptable(",
            "                    reason=_(\"qemu-img is not installed and the disk \"",
            "                             \"format is not specified.  Only RAW images \"",
            "                             \"can be used if qemu-img is not installed.\"),",
            "                    image_id=image_id)",
            "",
            "        fetch(context, image_service, image_id, tmp, user_id, project_id)",
            "",
            "        if is_xenserver_image(context, image_service, image_id):",
            "            replace_xenserver_image_with_coalesced_vhd(tmp)",
            "",
            "        if not qemu_img:",
            "            # qemu-img is not installed but we do have a RAW image.  As a",
            "            # result we only need to copy the image to the destination and then",
            "            # return.",
            "            LOG.debug('Copying image from %(tmp)s to volume %(dest)s - '",
            "                      'size: %(size)s' % {'tmp': tmp, 'dest': dest,",
            "                                          'size': image_meta['size']})",
            "            volume_utils.copy_volume(tmp, dest, image_meta['size'], blocksize)",
            "            return",
            "",
            "        data = qemu_img_info(tmp)",
            "        virt_size = data.virtual_size / units.Gi",
            "",
            "        # NOTE(xqueralt): If the image virtual size doesn't fit in the",
            "        # requested volume there is no point on resizing it because it will",
            "        # generate an unusable image.",
            "        if size is not None and virt_size > size:",
            "            params = {'image_size': virt_size, 'volume_size': size}",
            "            reason = _(\"Size is %(image_size)dGB and doesn't fit in a \"",
            "                       \"volume of size %(volume_size)dGB.\") % params",
            "            raise exception.ImageUnacceptable(image_id=image_id, reason=reason)",
            "",
            "        fmt = data.file_format",
            "        if fmt is None:",
            "            raise exception.ImageUnacceptable(",
            "                reason=_(\"'qemu-img info' parsing failed.\"),",
            "                image_id=image_id)",
            "",
            "        backing_file = data.backing_file",
            "        if backing_file is not None:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file, })",
            "",
            "        # NOTE(jdg): I'm using qemu-img convert to write",
            "        # to the volume regardless if it *needs* conversion or not",
            "        # TODO(avishay): We can speed this up by checking if the image is raw",
            "        # and if so, writing directly to the device. However, we need to keep",
            "        # check via 'qemu-img info' that what we copied was in fact a raw",
            "        # image and not a different format with a backing file, which may be",
            "        # malicious.",
            "        LOG.debug(\"%s was %s, converting to %s \" % (image_id, fmt,",
            "                                                    volume_format))",
            "        convert_image(tmp, dest, volume_format,",
            "                      bps_limit=CONF.volume_copy_bps_limit)",
            "",
            "        data = qemu_img_info(dest)",
            "        if data.file_format != volume_format:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(vol_format)s, but format is \"",
            "                         \"now %(file_format)s\") % {'vol_format': volume_format,",
            "                                                   'file_format': data.",
            "                                                   file_format})",
            "",
            "",
            "def upload_volume(context, image_service, image_meta, volume_path,",
            "                  volume_format='raw'):",
            "    image_id = image_meta['id']",
            "    if (image_meta['disk_format'] == volume_format):",
            "        LOG.debug(\"%s was %s, no need to convert to %s\" %",
            "                  (image_id, volume_format, image_meta['disk_format']))",
            "        if os.name == 'nt' or os.access(volume_path, os.R_OK):",
            "            with fileutils.file_open(volume_path, 'rb') as image_file:",
            "                image_service.update(context, image_id, {}, image_file)",
            "        else:",
            "            with utils.temporary_chown(volume_path):",
            "                with fileutils.file_open(volume_path) as image_file:",
            "                    image_service.update(context, image_id, {}, image_file)",
            "        return",
            "",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    fd, tmp = tempfile.mkstemp(dir=CONF.image_conversion_dir)",
            "    os.close(fd)",
            "    with fileutils.remove_path_on_error(tmp):",
            "        LOG.debug(\"%s was %s, converting to %s\" %",
            "                  (image_id, volume_format, image_meta['disk_format']))",
            "",
            "        data = qemu_img_info(volume_path)",
            "        backing_file = data.backing_file",
            "        fmt = data.file_format",
            "        if backing_file is not None:",
            "            # Disallow backing files as a security measure.",
            "            # This prevents a user from writing an image header into a raw",
            "            # volume with a backing file pointing to data they wish to",
            "            # access.",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"fmt=%(fmt)s backed by:%(backing_file)s\")",
            "                % {'fmt': fmt, 'backing_file': backing_file})",
            "",
            "        convert_image(volume_path, tmp, image_meta['disk_format'],",
            "                      bps_limit=CONF.volume_copy_bps_limit)",
            "",
            "        data = qemu_img_info(tmp)",
            "        if data.file_format != image_meta['disk_format']:",
            "            raise exception.ImageUnacceptable(",
            "                image_id=image_id,",
            "                reason=_(\"Converted to %(f1)s, but format is now %(f2)s\") %",
            "                {'f1': image_meta['disk_format'], 'f2': data.file_format})",
            "",
            "        with fileutils.file_open(tmp, 'rb') as image_file:",
            "            image_service.update(context, image_id, {}, image_file)",
            "        fileutils.delete_if_exists(tmp)",
            "",
            "",
            "def is_xenserver_image(context, image_service, image_id):",
            "    image_meta = image_service.show(context, image_id)",
            "    return is_xenserver_format(image_meta)",
            "",
            "",
            "def is_xenserver_format(image_meta):",
            "    return (",
            "        image_meta['disk_format'] == 'vhd'",
            "        and image_meta['container_format'] == 'ovf'",
            "    )",
            "",
            "",
            "def file_exist(fpath):",
            "    return os.path.exists(fpath)",
            "",
            "",
            "def set_vhd_parent(vhd_path, parentpath):",
            "    utils.execute('vhd-util', 'modify', '-n', vhd_path, '-p', parentpath)",
            "",
            "",
            "def extract_targz(archive_name, target):",
            "    utils.execute('tar', '-xzf', archive_name, '-C', target)",
            "",
            "",
            "def fix_vhd_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        set_vhd_parent(child, parent)",
            "",
            "",
            "def get_vhd_size(vhd_path):",
            "    out, err = utils.execute('vhd-util', 'query', '-n', vhd_path, '-v')",
            "    return int(out)",
            "",
            "",
            "def resize_vhd(vhd_path, size, journal):",
            "    utils.execute(",
            "        'vhd-util', 'resize', '-n', vhd_path, '-s', '%d' % size, '-j', journal)",
            "",
            "",
            "def coalesce_vhd(vhd_path):",
            "    utils.execute(",
            "        'vhd-util', 'coalesce', '-n', vhd_path)",
            "",
            "",
            "def create_temporary_file(*args, **kwargs):",
            "    if (CONF.image_conversion_dir and not",
            "            os.path.exists(CONF.image_conversion_dir)):",
            "        os.makedirs(CONF.image_conversion_dir)",
            "",
            "    fd, tmp = tempfile.mkstemp(dir=CONF.image_conversion_dir, *args, **kwargs)",
            "    os.close(fd)",
            "    return tmp",
            "",
            "",
            "def rename_file(src, dst):",
            "    os.rename(src, dst)",
            "",
            "",
            "@contextlib.contextmanager",
            "def temporary_file(*args, **kwargs):",
            "    tmp = None",
            "    try:",
            "        tmp = create_temporary_file(*args, **kwargs)",
            "        yield tmp",
            "    finally:",
            "        if tmp:",
            "            fileutils.delete_if_exists(tmp)",
            "",
            "",
            "def temporary_dir():",
            "    return utils.tempdir(dir=CONF.image_conversion_dir)",
            "",
            "",
            "def coalesce_chain(vhd_chain):",
            "    for child, parent in zip(vhd_chain[:-1], vhd_chain[1:]):",
            "        with temporary_dir() as directory_for_journal:",
            "            size = get_vhd_size(child)",
            "            journal_file = os.path.join(",
            "                directory_for_journal, 'vhd-util-resize-journal')",
            "            resize_vhd(parent, size, journal_file)",
            "            coalesce_vhd(child)",
            "",
            "    return vhd_chain[-1]",
            "",
            "",
            "def discover_vhd_chain(directory):",
            "    counter = 0",
            "    chain = []",
            "",
            "    while True:",
            "        fpath = os.path.join(directory, '%d.vhd' % counter)",
            "        if file_exist(fpath):",
            "            chain.append(fpath)",
            "        else:",
            "            break",
            "        counter += 1",
            "",
            "    return chain",
            "",
            "",
            "def replace_xenserver_image_with_coalesced_vhd(image_file):",
            "    with temporary_dir() as tempdir:",
            "        extract_targz(image_file, tempdir)",
            "        chain = discover_vhd_chain(tempdir)",
            "        fix_vhd_chain(chain)",
            "        coalesced = coalesce_chain(chain)",
            "        fileutils.delete_if_exists(image_file)",
            "        rename_file(coalesced, image_file)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "web.pgadmin.tools.import_export.create_import_export_job"
        ]
    },
    "cinder/tests/test_image_utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 462,
                "PatchRowcode": "         volume_utils.setup_blkio_cgroup(mox.IgnoreArg(), mox.IgnoreArg(),"
            },
            "1": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 463,
                "PatchRowcode": "                                         bps_limit).AndReturn(prefix)"
            },
            "2": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 464,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 465,
                "PatchRowcode": "+        utils.execute("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 466,
                "PatchRowcode": "+            'env', 'LC_ALL=C', 'qemu-img', 'info',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 467,
                "PatchRowcode": "+            mox.IgnoreArg(), run_as_root=True).AndReturn("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 468,
                "PatchRowcode": "+                (TEST_RET, 'ignored'))"
            },
            "7": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "         utils.execute(*cmd, run_as_root=True)"
            },
            "8": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "         utils.execute("
            },
            "9": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 471,
                "PatchRowcode": "             'env', 'LC_ALL=C', 'qemu-img', 'info',"
            },
            "10": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": 501,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "         volume_utils.setup_blkio_cgroup(mox.IgnoreArg(), mox.IgnoreArg(),"
            },
            "12": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "                                         bps_limit).AndReturn(prefix)"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 504,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 505,
                "PatchRowcode": "+        utils.execute("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 506,
                "PatchRowcode": "+            'env', 'LC_ALL=C', 'qemu-img', 'info',"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 507,
                "PatchRowcode": "+            mox.IgnoreArg(), run_as_root=True).AndReturn("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 508,
                "PatchRowcode": "+                (TEST_RET, 'ignored'))"
            },
            "18": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 509,
                "PatchRowcode": "         utils.execute(*cmd, run_as_root=True)"
            },
            "19": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": 510,
                "PatchRowcode": "         utils.execute("
            },
            "20": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "             'env', 'LC_ALL=C', 'qemu-img', 'info',"
            },
            "21": {
                "beforePatchRowNumber": 534,
                "afterPatchRowNumber": 543,
                "PatchRowcode": "         m.StubOutWithMock(utils, 'execute')"
            },
            "22": {
                "beforePatchRowNumber": 535,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "         m.StubOutWithMock(volume_utils, 'check_for_odirect_support')"
            },
            "23": {
                "beforePatchRowNumber": 536,
                "afterPatchRowNumber": 545,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 546,
                "PatchRowcode": "+        utils.execute("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 547,
                "PatchRowcode": "+            'env', 'LC_ALL=C', 'qemu-img', 'info',"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 548,
                "PatchRowcode": "+            mox.IgnoreArg(), run_as_root=True).AndReturn("
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 549,
                "PatchRowcode": "+                (TEST_RET, 'ignored'))"
            },
            "28": {
                "beforePatchRowNumber": 537,
                "afterPatchRowNumber": 550,
                "PatchRowcode": "         utils.execute('qemu-img', 'convert', '-O', 'qcow2',"
            },
            "29": {
                "beforePatchRowNumber": 538,
                "afterPatchRowNumber": 551,
                "PatchRowcode": "                       mox.IgnoreArg(), mox.IgnoreArg(), run_as_root=True)"
            },
            "30": {
                "beforePatchRowNumber": 539,
                "afterPatchRowNumber": 552,
                "PatchRowcode": "         utils.execute("
            }
        },
        "frontPatchFile": [
            "",
            "# Copyright (c) 2013 eNovance , Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"Unit tests for image utils.\"\"\"",
            "",
            "import contextlib",
            "import tempfile",
            "",
            "import mock",
            "import mox",
            "from oslo.config import cfg",
            "",
            "from cinder import context",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder.openstack.common import fileutils",
            "from cinder.openstack.common import processutils",
            "from cinder.openstack.common import units",
            "from cinder import test",
            "from cinder import utils",
            "from cinder.volume import utils as volume_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "class FakeImageService:",
            "    def __init__(self):",
            "        self._imagedata = {}",
            "",
            "    def download(self, context, image_id, data):",
            "        self.show(context, image_id)",
            "        data.write(self._imagedata.get(image_id, ''))",
            "",
            "    def show(self, context, image_id):",
            "        return {'size': 2 * units.Gi,",
            "                'disk_format': 'qcow2',",
            "                'container_format': 'bare'}",
            "",
            "    def update(self, context, image_id, metadata, path):",
            "        pass",
            "",
            "",
            "class TestUtils(test.TestCase):",
            "    TEST_IMAGE_ID = 321",
            "    TEST_DEV_PATH = \"/dev/ether/fake_dev\"",
            "",
            "    def setUp(self):",
            "        super(TestUtils, self).setUp()",
            "        self._mox = mox.Mox()",
            "        self._image_service = FakeImageService()",
            "",
            "        self.addCleanup(self._mox.UnsetStubs)",
            "",
            "    def test_resize_image(self):",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        TEST_IMG_SOURCE = 'boobar.img'",
            "        TEST_IMG_SIZE_IN_GB = 1",
            "",
            "        utils.execute('qemu-img', 'resize', TEST_IMG_SOURCE,",
            "                      '%sG' % TEST_IMG_SIZE_IN_GB, run_as_root=False)",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.resize_image(TEST_IMG_SOURCE, TEST_IMG_SIZE_IN_GB)",
            "",
            "        mox.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_convert_image(self, mock_stat):",
            "",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "        mox.StubOutWithMock(utils, 'is_blk_device')",
            "",
            "        TEST_OUT_FORMAT = 'vmdk'",
            "        TEST_SOURCE = 'img/qemu.img'",
            "        TEST_DEST = '/img/vmware.vmdk'",
            "",
            "        utils.is_blk_device(TEST_DEST).AndReturn(True)",
            "        utils.execute('dd', 'count=0', 'if=img/qemu.img',",
            "                      'of=/img/vmware.vmdk', 'oflag=direct',",
            "                      run_as_root=True)",
            "        utils.execute(",
            "            'qemu-img', 'convert', '-t', 'none', '-O', TEST_OUT_FORMAT,",
            "            TEST_SOURCE, TEST_DEST, run_as_root=True)",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.convert_image(TEST_SOURCE, TEST_DEST, TEST_OUT_FORMAT)",
            "",
            "        mox.VerifyAll()",
            "",
            "    def test_qemu_img_info(self):",
            "        TEST_PATH = \"img/qemu.qcow2\"",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"backing_file: qemu.qcow2 (actual path: qemu.qcow2)\\n\"\\",
            "                      \"file_format: qcow2\\n\"\\",
            "                      \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "        TEST_STR = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2\\n\"\\",
            "                   \"virtual_size: 52428800\\n\"\\",
            "                   \"disk_size: 200704\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"backing_file: qemu.qcow2\\n\"\\",
            "                   \"snapshots: [{'date': '2011-10-04', \"\\",
            "                   \"'vm_clock': '19:04:00 32:06:34.974', \"\\",
            "                   \"'vm_size': '1.7G', 'tag': 'snap1', 'id': '1'}]\"",
            "",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            TEST_PATH, run_as_root=True).AndReturn(",
            "                (TEST_RETURN, 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        inf = image_utils.qemu_img_info(TEST_PATH)",
            "",
            "        self.assertEqual(inf.image, 'qemu.qcow2')",
            "        self.assertEqual(inf.backing_file, 'qemu.qcow2')",
            "        self.assertEqual(inf.file_format, 'qcow2')",
            "        self.assertEqual(inf.virtual_size, 52428800)",
            "        self.assertEqual(inf.cluster_size, 65536)",
            "        self.assertEqual(inf.disk_size, 200704)",
            "",
            "        self.assertEqual(inf.snapshots[0]['id'], '1')",
            "        self.assertEqual(inf.snapshots[0]['tag'], 'snap1')",
            "        self.assertEqual(inf.snapshots[0]['vm_size'], '1.7G')",
            "        self.assertEqual(inf.snapshots[0]['date'], '2011-10-04')",
            "        self.assertEqual(inf.snapshots[0]['vm_clock'], '19:04:00 32:06:34.974')",
            "",
            "        self.assertEqual(str(inf), TEST_STR)",
            "",
            "    def test_qemu_img_info_alt(self):",
            "        \"\"\"Test a slightly different variation of qemu-img output.",
            "",
            "           (Based on Fedora 19's qemu-img 1.4.2.)",
            "        \"\"\"",
            "",
            "        TEST_PATH = \"img/qemu.qcow2\"",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"backing file: qemu.qcow2 (actual path: qemu.qcow2)\\n\"\\",
            "                      \"file format: qcow2\\n\"\\",
            "                      \"virtual size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "        TEST_STR = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2\\n\"\\",
            "                   \"virtual_size: 52428800\\n\"\\",
            "                   \"disk_size: 200704\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"backing_file: qemu.qcow2\\n\"\\",
            "                   \"snapshots: [{'date': '2011-10-04', \"\\",
            "                   \"'vm_clock': '19:04:00 32:06:34.974', \"\\",
            "                   \"'vm_size': '1.7G', 'tag': 'snap1', 'id': '1'}]\"",
            "",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        cmd = ['env', 'LC_ALL=C', 'qemu-img', 'info', TEST_PATH]",
            "        utils.execute(*cmd, run_as_root=True).AndReturn(",
            "            (TEST_RETURN, 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        inf = image_utils.qemu_img_info(TEST_PATH)",
            "",
            "        self.assertEqual(inf.image, 'qemu.qcow2')",
            "        self.assertEqual(inf.backing_file, 'qemu.qcow2')",
            "        self.assertEqual(inf.file_format, 'qcow2')",
            "        self.assertEqual(inf.virtual_size, 52428800)",
            "        self.assertEqual(inf.cluster_size, 65536)",
            "        self.assertEqual(inf.disk_size, 200704)",
            "",
            "        self.assertEqual(inf.snapshots[0]['id'], '1')",
            "        self.assertEqual(inf.snapshots[0]['tag'], 'snap1')",
            "        self.assertEqual(inf.snapshots[0]['vm_size'], '1.7G')",
            "        self.assertEqual(inf.snapshots[0]['date'], '2011-10-04')",
            "        self.assertEqual(inf.snapshots[0]['vm_clock'],",
            "                         '19:04:00 32:06:34.974')",
            "",
            "        self.assertEqual(str(inf), TEST_STR)",
            "",
            "    def _test_fetch_to_raw(self, has_qemu=True, src_inf=None, dest_inf=None,",
            "                           bps_limit=0):",
            "        mox = self._mox",
            "        mox.StubOutWithMock(image_utils, 'create_temporary_file')",
            "        mox.StubOutWithMock(utils, 'execute')",
            "        mox.StubOutWithMock(image_utils, 'fetch')",
            "        mox.StubOutWithMock(volume_utils, 'setup_blkio_cgroup')",
            "        mox.StubOutWithMock(utils, 'is_blk_device')",
            "",
            "        TEST_INFO = (\"image: qemu.qcow2\\n\"",
            "                     \"file format: raw\\n\"",
            "                     \"virtual size: 0 (0 bytes)\\n\"",
            "                     \"disk size: 0\")",
            "",
            "        utils.is_blk_device(self.TEST_DEV_PATH).AndReturn(True)",
            "        CONF.set_override('volume_copy_bps_limit', bps_limit)",
            "",
            "        image_utils.create_temporary_file().AndReturn(self.TEST_DEV_PATH)",
            "",
            "        test_qemu_img = utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info', self.TEST_DEV_PATH,",
            "            run_as_root=True)",
            "",
            "        if has_qemu:",
            "            test_qemu_img.AndReturn((TEST_INFO, 'ignored'))",
            "            image_utils.fetch(context, self._image_service, self.TEST_IMAGE_ID,",
            "                              self.TEST_DEV_PATH, None, None)",
            "        else:",
            "            test_qemu_img.AndRaise(processutils.ProcessExecutionError())",
            "",
            "        if has_qemu and src_inf:",
            "            utils.execute(",
            "                'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "                self.TEST_DEV_PATH, run_as_root=True).AndReturn(",
            "                    (src_inf, 'ignored'))",
            "",
            "        if has_qemu and dest_inf:",
            "            if bps_limit:",
            "                prefix = ('cgexec', '-g', 'blkio:test')",
            "            else:",
            "                prefix = ()",
            "",
            "            utils.execute('dd', 'count=0', 'if=/dev/ether/fake_dev',",
            "                          'of=/dev/ether/fake_dev', 'oflag=direct',",
            "                          run_as_root=True)",
            "",
            "            cmd = prefix + ('qemu-img', 'convert', '-t', 'none', '-O', 'raw',",
            "                            self.TEST_DEV_PATH, self.TEST_DEV_PATH)",
            "",
            "            volume_utils.setup_blkio_cgroup(",
            "                self.TEST_DEV_PATH, self.TEST_DEV_PATH,",
            "                bps_limit).AndReturn(prefix)",
            "",
            "            utils.execute(*cmd, run_as_root=True)",
            "",
            "            utils.execute(",
            "                'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "                self.TEST_DEV_PATH, run_as_root=True).AndReturn(",
            "                    (dest_inf, 'ignored'))",
            "",
            "        self._mox.ReplayAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_fetch_to_raw(self, mock_stat):",
            "",
            "        SRC_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "        DST_INFO = (\"image: qemu.raw\\n\"",
            "                    \"file_format: raw\\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\\n\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO, dest_inf=DST_INFO)",
            "",
            "        image_utils.fetch_to_raw(context, self._image_service,",
            "                                 self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                                 mox.IgnoreArg())",
            "        self._mox.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_fetch_to_raw_with_bps_limit(self, mock_stat):",
            "        SRC_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "        DST_INFO = (\"image: qemu.raw\\n\"",
            "                    \"file_format: raw\\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\\n\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO, dest_inf=DST_INFO,",
            "                                bps_limit=1048576)",
            "",
            "        image_utils.fetch_to_raw(context, self._image_service,",
            "                                 self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                                 mox.IgnoreArg())",
            "        self._mox.VerifyAll()",
            "",
            "    def test_fetch_to_raw_no_qemu_img(self):",
            "        self._test_fetch_to_raw(has_qemu=False)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    def test_fetch_to_raw_on_error_parsing_failed(self):",
            "        SRC_INFO_NO_FORMAT = (\"image: qemu.qcow2\\n\"",
            "                              \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                              \"cluster_size: 65536\\n\"",
            "                              \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO_NO_FORMAT)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    def test_fetch_to_raw_on_error_backing_file(self):",
            "        SRC_INFO_BACKING_FILE = (\"image: qemu.qcow2\\n\"",
            "                                 \"backing_file: qemu.qcow2\\n\"",
            "                                 \"file_format: qcow2 \\n\"",
            "                                 \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                                 \"cluster_size: 65536\\n\"",
            "                                 \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO_BACKING_FILE)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    @mock.patch('os.stat')",
            "    def test_fetch_to_raw_on_error_not_convert_to_raw(self, mock_stat):",
            "",
            "        IMG_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=IMG_INFO, dest_inf=IMG_INFO)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    def test_fetch_to_raw_on_error_image_size(self):",
            "        TEST_VOLUME_SIZE = 1",
            "        SRC_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 2G (2147483648 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg(), size=TEST_VOLUME_SIZE)",
            "",
            "    def _test_fetch_verify_image(self, qemu_info, volume_size=1):",
            "        fake_image_service = FakeImageService()",
            "        mox = self._mox",
            "        mox.StubOutWithMock(image_utils, 'fetch')",
            "        mox.StubOutWithMock(utils, 'execute')",
            "        image_utils.fetch(context, fake_image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH, None, None)",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            self.TEST_DEV_PATH, run_as_root=True).AndReturn(",
            "                (qemu_info, 'ignored'))",
            "",
            "        self._mox.ReplayAll()",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          context, fake_image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          size=volume_size)",
            "",
            "    def test_fetch_verify_image_with_backing_file(self):",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"backing_file: qemu.qcow2 (actual path: qemu.qcow2)\\n\"\\",
            "                      \"file_format: qcow2\\n\"\\",
            "                      \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "",
            "        self._test_fetch_verify_image(TEST_RETURN)",
            "",
            "    def test_fetch_verify_image_without_file_format(self):",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "",
            "        self._test_fetch_verify_image(TEST_RETURN)",
            "",
            "    def test_fetch_verify_image_image_size(self):",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"file_format: qcow2\\n\"\\",
            "                      \"virtual_size: 2G (2147483648 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "",
            "        self._test_fetch_verify_image(TEST_RETURN)",
            "",
            "    @mock.patch('os.stat')",
            "    def test_upload_volume(self, mock_stat, bps_limit=0):",
            "        image_meta = {'id': 1, 'disk_format': 'qcow2'}",
            "        TEST_RET = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2 \\n\"\\",
            "                   \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"disk_size: 196K (200704 bytes)\"",
            "",
            "        if bps_limit:",
            "            CONF.set_override('volume_copy_bps_limit', bps_limit)",
            "            prefix = ('cgexec', '-g', 'blkio:test')",
            "        else:",
            "            prefix = ()",
            "",
            "        cmd = prefix + ('qemu-img', 'convert', '-O', 'qcow2',",
            "                        mox.IgnoreArg(), mox.IgnoreArg())",
            "",
            "        m = self._mox",
            "        m.StubOutWithMock(utils, 'execute')",
            "        m.StubOutWithMock(volume_utils, 'setup_blkio_cgroup')",
            "",
            "        volume_utils.setup_blkio_cgroup(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                                        bps_limit).AndReturn(prefix)",
            "",
            "        utils.execute(*cmd, run_as_root=True)",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "",
            "        m.ReplayAll()",
            "",
            "        image_utils.upload_volume(context, FakeImageService(),",
            "                                  image_meta, '/dev/loop1')",
            "        m.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_upload_volume_with_bps_limit(self, mock_stat):",
            "        bps_limit = 1048576",
            "        image_meta = {'id': 1, 'disk_format': 'qcow2'}",
            "        TEST_RET = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2 \\n\"\\",
            "                   \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"disk_size: 196K (200704 bytes)\"",
            "",
            "        CONF.set_override('volume_copy_bps_limit', bps_limit)",
            "        prefix = ('cgexec', '-g', 'blkio:test')",
            "",
            "        cmd = prefix + ('qemu-img', 'convert', '-O', 'qcow2',",
            "                        mox.IgnoreArg(), mox.IgnoreArg())",
            "",
            "        m = self._mox",
            "        m.StubOutWithMock(utils, 'execute')",
            "        m.StubOutWithMock(volume_utils, 'setup_blkio_cgroup')",
            "        m.StubOutWithMock(volume_utils, 'check_for_odirect_support')",
            "",
            "        volume_utils.setup_blkio_cgroup(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                                        bps_limit).AndReturn(prefix)",
            "        utils.execute(*cmd, run_as_root=True)",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "",
            "        m.ReplayAll()",
            "        image_utils.upload_volume(context, FakeImageService(),",
            "                                  image_meta, '/dev/loop1')",
            "        m.VerifyAll()",
            "",
            "    def test_upload_volume_with_raw_image(self):",
            "        image_meta = {'id': 1, 'disk_format': 'raw'}",
            "        mox = self._mox",
            "",
            "        mox.StubOutWithMock(image_utils, 'convert_image')",
            "",
            "        mox.ReplayAll()",
            "",
            "        with tempfile.NamedTemporaryFile() as f:",
            "            image_utils.upload_volume(context, FakeImageService(),",
            "                                      image_meta, f.name)",
            "        mox.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_upload_volume_on_error(self, mock_stat):",
            "        image_meta = {'id': 1, 'disk_format': 'qcow2'}",
            "        TEST_RET = \"image: qemu.vhd\\n\"\\",
            "                   \"file_format: vhd \\n\"\\",
            "                   \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"disk_size: 196K (200704 bytes)\"",
            "",
            "        m = self._mox",
            "        m.StubOutWithMock(utils, 'execute')",
            "        m.StubOutWithMock(volume_utils, 'check_for_odirect_support')",
            "",
            "        utils.execute('qemu-img', 'convert', '-O', 'qcow2',",
            "                      mox.IgnoreArg(), mox.IgnoreArg(), run_as_root=True)",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "",
            "        m.ReplayAll()",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.upload_volume,",
            "                          context, FakeImageService(),",
            "                          image_meta, '/dev/loop1')",
            "        m.VerifyAll()",
            "",
            "",
            "class TestExtractTo(test.TestCase):",
            "    def test_extract_to_calls_tar(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'tar', '-xzf', 'archive.tgz', '-C', 'targetpath').AndReturn(",
            "                ('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.extract_targz('archive.tgz', 'targetpath')",
            "        mox.VerifyAll()",
            "",
            "",
            "class TestSetVhdParent(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'modify', '-n', 'child', '-p', 'parent').AndReturn(",
            "                ('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.set_vhd_parent('child', 'parent')",
            "        mox.VerifyAll()",
            "",
            "",
            "class TestFixVhdChain(test.TestCase):",
            "    def test_empty_chain(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'set_vhd_parent')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.fix_vhd_chain([])",
            "",
            "    def test_single_vhd_file_chain(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'set_vhd_parent')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.fix_vhd_chain(['0.vhd'])",
            "",
            "    def test_chain_with_two_elements(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'set_vhd_parent')",
            "",
            "        image_utils.set_vhd_parent('0.vhd', '1.vhd')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.fix_vhd_chain(['0.vhd', '1.vhd'])",
            "",
            "",
            "class TestGetSize(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'query', '-n', 'vhdfile', '-v').AndReturn(",
            "                ('1024', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        result = image_utils.get_vhd_size('vhdfile')",
            "        mox.VerifyAll()",
            "",
            "        self.assertEqual(1024, result)",
            "",
            "",
            "class TestResize(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'resize', '-n', 'vhdfile', '-s', '1024',",
            "            '-j', 'journal').AndReturn(('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.resize_vhd('vhdfile', 1024, 'journal')",
            "        mox.VerifyAll()",
            "",
            "",
            "class TestCoalesce(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'coalesce', '-n', 'vhdfile'",
            "        ).AndReturn(('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.coalesce_vhd('vhdfile')",
            "        mox.VerifyAll()",
            "",
            "",
            "@contextlib.contextmanager",
            "def fake_context(return_value):",
            "    yield return_value",
            "",
            "",
            "class TestTemporaryFile(test.TestCase):",
            "    def test_file_unlinked(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'create_temporary_file')",
            "        mox.StubOutWithMock(fileutils, 'delete_if_exists')",
            "",
            "        image_utils.create_temporary_file().AndReturn('somefile')",
            "        fileutils.delete_if_exists('somefile')",
            "",
            "        mox.ReplayAll()",
            "",
            "        with image_utils.temporary_file():",
            "            pass",
            "",
            "    def test_file_unlinked_on_error(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'create_temporary_file')",
            "        mox.StubOutWithMock(fileutils, 'delete_if_exists')",
            "",
            "        image_utils.create_temporary_file().AndReturn('somefile')",
            "        fileutils.delete_if_exists('somefile')",
            "",
            "        mox.ReplayAll()",
            "",
            "        def sut():",
            "            with image_utils.temporary_file():",
            "                raise test.TestingException()",
            "",
            "        self.assertRaises(test.TestingException, sut)",
            "",
            "",
            "class TestCoalesceChain(test.TestCase):",
            "    def test_single_vhd(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'get_vhd_size')",
            "        mox.StubOutWithMock(image_utils, 'resize_vhd')",
            "        mox.StubOutWithMock(image_utils, 'coalesce_vhd')",
            "",
            "        mox.ReplayAll()",
            "",
            "        result = image_utils.coalesce_chain(['0.vhd'])",
            "        mox.VerifyAll()",
            "",
            "        self.assertEqual('0.vhd', result)",
            "",
            "    def test_chain_of_two_vhds(self):",
            "        self.mox.StubOutWithMock(image_utils, 'get_vhd_size')",
            "        self.mox.StubOutWithMock(image_utils, 'temporary_dir')",
            "        self.mox.StubOutWithMock(image_utils, 'resize_vhd')",
            "        self.mox.StubOutWithMock(image_utils, 'coalesce_vhd')",
            "        self.mox.StubOutWithMock(image_utils, 'temporary_file')",
            "",
            "        image_utils.get_vhd_size('0.vhd').AndReturn(1024)",
            "        image_utils.temporary_dir().AndReturn(fake_context('tdir'))",
            "        image_utils.resize_vhd('1.vhd', 1024, 'tdir/vhd-util-resize-journal')",
            "        image_utils.coalesce_vhd('0.vhd')",
            "        self.mox.ReplayAll()",
            "",
            "        result = image_utils.coalesce_chain(['0.vhd', '1.vhd'])",
            "        self.mox.VerifyAll()",
            "        self.assertEqual('1.vhd', result)",
            "",
            "",
            "class TestDiscoverChain(test.TestCase):",
            "    def test_discovery_calls(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'file_exist')",
            "",
            "        image_utils.file_exist('some/path/0.vhd').AndReturn(True)",
            "        image_utils.file_exist('some/path/1.vhd').AndReturn(True)",
            "        image_utils.file_exist('some/path/2.vhd').AndReturn(False)",
            "",
            "        mox.ReplayAll()",
            "        result = image_utils.discover_vhd_chain('some/path')",
            "        mox.VerifyAll()",
            "",
            "        self.assertEqual(",
            "            ['some/path/0.vhd', 'some/path/1.vhd'], result)",
            "",
            "",
            "class TestXenServerImageToCoalescedVhd(test.TestCase):",
            "    def test_calls(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'temporary_dir')",
            "        mox.StubOutWithMock(image_utils, 'extract_targz')",
            "        mox.StubOutWithMock(image_utils, 'discover_vhd_chain')",
            "        mox.StubOutWithMock(image_utils, 'fix_vhd_chain')",
            "        mox.StubOutWithMock(image_utils, 'coalesce_chain')",
            "        mox.StubOutWithMock(image_utils.os, 'unlink')",
            "        mox.StubOutWithMock(fileutils, 'delete_if_exists')",
            "        mox.StubOutWithMock(image_utils, 'rename_file')",
            "",
            "        image_utils.temporary_dir().AndReturn(fake_context('somedir'))",
            "        image_utils.extract_targz('image', 'somedir')",
            "        image_utils.discover_vhd_chain('somedir').AndReturn(",
            "            ['somedir/0.vhd', 'somedir/1.vhd'])",
            "        image_utils.fix_vhd_chain(['somedir/0.vhd', 'somedir/1.vhd'])",
            "        image_utils.coalesce_chain(",
            "            ['somedir/0.vhd', 'somedir/1.vhd']).AndReturn('somedir/1.vhd')",
            "        fileutils.delete_if_exists('image')",
            "        image_utils.rename_file('somedir/1.vhd', 'image')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.replace_xenserver_image_with_coalesced_vhd('image')",
            "        mox.VerifyAll()"
        ],
        "afterPatchFile": [
            "",
            "# Copyright (c) 2013 eNovance , Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "\"\"\"Unit tests for image utils.\"\"\"",
            "",
            "import contextlib",
            "import tempfile",
            "",
            "import mock",
            "import mox",
            "from oslo.config import cfg",
            "",
            "from cinder import context",
            "from cinder import exception",
            "from cinder.image import image_utils",
            "from cinder.openstack.common import fileutils",
            "from cinder.openstack.common import processutils",
            "from cinder.openstack.common import units",
            "from cinder import test",
            "from cinder import utils",
            "from cinder.volume import utils as volume_utils",
            "",
            "CONF = cfg.CONF",
            "",
            "",
            "class FakeImageService:",
            "    def __init__(self):",
            "        self._imagedata = {}",
            "",
            "    def download(self, context, image_id, data):",
            "        self.show(context, image_id)",
            "        data.write(self._imagedata.get(image_id, ''))",
            "",
            "    def show(self, context, image_id):",
            "        return {'size': 2 * units.Gi,",
            "                'disk_format': 'qcow2',",
            "                'container_format': 'bare'}",
            "",
            "    def update(self, context, image_id, metadata, path):",
            "        pass",
            "",
            "",
            "class TestUtils(test.TestCase):",
            "    TEST_IMAGE_ID = 321",
            "    TEST_DEV_PATH = \"/dev/ether/fake_dev\"",
            "",
            "    def setUp(self):",
            "        super(TestUtils, self).setUp()",
            "        self._mox = mox.Mox()",
            "        self._image_service = FakeImageService()",
            "",
            "        self.addCleanup(self._mox.UnsetStubs)",
            "",
            "    def test_resize_image(self):",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        TEST_IMG_SOURCE = 'boobar.img'",
            "        TEST_IMG_SIZE_IN_GB = 1",
            "",
            "        utils.execute('qemu-img', 'resize', TEST_IMG_SOURCE,",
            "                      '%sG' % TEST_IMG_SIZE_IN_GB, run_as_root=False)",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.resize_image(TEST_IMG_SOURCE, TEST_IMG_SIZE_IN_GB)",
            "",
            "        mox.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_convert_image(self, mock_stat):",
            "",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "        mox.StubOutWithMock(utils, 'is_blk_device')",
            "",
            "        TEST_OUT_FORMAT = 'vmdk'",
            "        TEST_SOURCE = 'img/qemu.img'",
            "        TEST_DEST = '/img/vmware.vmdk'",
            "",
            "        utils.is_blk_device(TEST_DEST).AndReturn(True)",
            "        utils.execute('dd', 'count=0', 'if=img/qemu.img',",
            "                      'of=/img/vmware.vmdk', 'oflag=direct',",
            "                      run_as_root=True)",
            "        utils.execute(",
            "            'qemu-img', 'convert', '-t', 'none', '-O', TEST_OUT_FORMAT,",
            "            TEST_SOURCE, TEST_DEST, run_as_root=True)",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.convert_image(TEST_SOURCE, TEST_DEST, TEST_OUT_FORMAT)",
            "",
            "        mox.VerifyAll()",
            "",
            "    def test_qemu_img_info(self):",
            "        TEST_PATH = \"img/qemu.qcow2\"",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"backing_file: qemu.qcow2 (actual path: qemu.qcow2)\\n\"\\",
            "                      \"file_format: qcow2\\n\"\\",
            "                      \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "        TEST_STR = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2\\n\"\\",
            "                   \"virtual_size: 52428800\\n\"\\",
            "                   \"disk_size: 200704\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"backing_file: qemu.qcow2\\n\"\\",
            "                   \"snapshots: [{'date': '2011-10-04', \"\\",
            "                   \"'vm_clock': '19:04:00 32:06:34.974', \"\\",
            "                   \"'vm_size': '1.7G', 'tag': 'snap1', 'id': '1'}]\"",
            "",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            TEST_PATH, run_as_root=True).AndReturn(",
            "                (TEST_RETURN, 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        inf = image_utils.qemu_img_info(TEST_PATH)",
            "",
            "        self.assertEqual(inf.image, 'qemu.qcow2')",
            "        self.assertEqual(inf.backing_file, 'qemu.qcow2')",
            "        self.assertEqual(inf.file_format, 'qcow2')",
            "        self.assertEqual(inf.virtual_size, 52428800)",
            "        self.assertEqual(inf.cluster_size, 65536)",
            "        self.assertEqual(inf.disk_size, 200704)",
            "",
            "        self.assertEqual(inf.snapshots[0]['id'], '1')",
            "        self.assertEqual(inf.snapshots[0]['tag'], 'snap1')",
            "        self.assertEqual(inf.snapshots[0]['vm_size'], '1.7G')",
            "        self.assertEqual(inf.snapshots[0]['date'], '2011-10-04')",
            "        self.assertEqual(inf.snapshots[0]['vm_clock'], '19:04:00 32:06:34.974')",
            "",
            "        self.assertEqual(str(inf), TEST_STR)",
            "",
            "    def test_qemu_img_info_alt(self):",
            "        \"\"\"Test a slightly different variation of qemu-img output.",
            "",
            "           (Based on Fedora 19's qemu-img 1.4.2.)",
            "        \"\"\"",
            "",
            "        TEST_PATH = \"img/qemu.qcow2\"",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"backing file: qemu.qcow2 (actual path: qemu.qcow2)\\n\"\\",
            "                      \"file format: qcow2\\n\"\\",
            "                      \"virtual size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "        TEST_STR = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2\\n\"\\",
            "                   \"virtual_size: 52428800\\n\"\\",
            "                   \"disk_size: 200704\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"backing_file: qemu.qcow2\\n\"\\",
            "                   \"snapshots: [{'date': '2011-10-04', \"\\",
            "                   \"'vm_clock': '19:04:00 32:06:34.974', \"\\",
            "                   \"'vm_size': '1.7G', 'tag': 'snap1', 'id': '1'}]\"",
            "",
            "        mox = self._mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        cmd = ['env', 'LC_ALL=C', 'qemu-img', 'info', TEST_PATH]",
            "        utils.execute(*cmd, run_as_root=True).AndReturn(",
            "            (TEST_RETURN, 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        inf = image_utils.qemu_img_info(TEST_PATH)",
            "",
            "        self.assertEqual(inf.image, 'qemu.qcow2')",
            "        self.assertEqual(inf.backing_file, 'qemu.qcow2')",
            "        self.assertEqual(inf.file_format, 'qcow2')",
            "        self.assertEqual(inf.virtual_size, 52428800)",
            "        self.assertEqual(inf.cluster_size, 65536)",
            "        self.assertEqual(inf.disk_size, 200704)",
            "",
            "        self.assertEqual(inf.snapshots[0]['id'], '1')",
            "        self.assertEqual(inf.snapshots[0]['tag'], 'snap1')",
            "        self.assertEqual(inf.snapshots[0]['vm_size'], '1.7G')",
            "        self.assertEqual(inf.snapshots[0]['date'], '2011-10-04')",
            "        self.assertEqual(inf.snapshots[0]['vm_clock'],",
            "                         '19:04:00 32:06:34.974')",
            "",
            "        self.assertEqual(str(inf), TEST_STR)",
            "",
            "    def _test_fetch_to_raw(self, has_qemu=True, src_inf=None, dest_inf=None,",
            "                           bps_limit=0):",
            "        mox = self._mox",
            "        mox.StubOutWithMock(image_utils, 'create_temporary_file')",
            "        mox.StubOutWithMock(utils, 'execute')",
            "        mox.StubOutWithMock(image_utils, 'fetch')",
            "        mox.StubOutWithMock(volume_utils, 'setup_blkio_cgroup')",
            "        mox.StubOutWithMock(utils, 'is_blk_device')",
            "",
            "        TEST_INFO = (\"image: qemu.qcow2\\n\"",
            "                     \"file format: raw\\n\"",
            "                     \"virtual size: 0 (0 bytes)\\n\"",
            "                     \"disk size: 0\")",
            "",
            "        utils.is_blk_device(self.TEST_DEV_PATH).AndReturn(True)",
            "        CONF.set_override('volume_copy_bps_limit', bps_limit)",
            "",
            "        image_utils.create_temporary_file().AndReturn(self.TEST_DEV_PATH)",
            "",
            "        test_qemu_img = utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info', self.TEST_DEV_PATH,",
            "            run_as_root=True)",
            "",
            "        if has_qemu:",
            "            test_qemu_img.AndReturn((TEST_INFO, 'ignored'))",
            "            image_utils.fetch(context, self._image_service, self.TEST_IMAGE_ID,",
            "                              self.TEST_DEV_PATH, None, None)",
            "        else:",
            "            test_qemu_img.AndRaise(processutils.ProcessExecutionError())",
            "",
            "        if has_qemu and src_inf:",
            "            utils.execute(",
            "                'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "                self.TEST_DEV_PATH, run_as_root=True).AndReturn(",
            "                    (src_inf, 'ignored'))",
            "",
            "        if has_qemu and dest_inf:",
            "            if bps_limit:",
            "                prefix = ('cgexec', '-g', 'blkio:test')",
            "            else:",
            "                prefix = ()",
            "",
            "            utils.execute('dd', 'count=0', 'if=/dev/ether/fake_dev',",
            "                          'of=/dev/ether/fake_dev', 'oflag=direct',",
            "                          run_as_root=True)",
            "",
            "            cmd = prefix + ('qemu-img', 'convert', '-t', 'none', '-O', 'raw',",
            "                            self.TEST_DEV_PATH, self.TEST_DEV_PATH)",
            "",
            "            volume_utils.setup_blkio_cgroup(",
            "                self.TEST_DEV_PATH, self.TEST_DEV_PATH,",
            "                bps_limit).AndReturn(prefix)",
            "",
            "            utils.execute(*cmd, run_as_root=True)",
            "",
            "            utils.execute(",
            "                'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "                self.TEST_DEV_PATH, run_as_root=True).AndReturn(",
            "                    (dest_inf, 'ignored'))",
            "",
            "        self._mox.ReplayAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_fetch_to_raw(self, mock_stat):",
            "",
            "        SRC_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "        DST_INFO = (\"image: qemu.raw\\n\"",
            "                    \"file_format: raw\\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\\n\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO, dest_inf=DST_INFO)",
            "",
            "        image_utils.fetch_to_raw(context, self._image_service,",
            "                                 self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                                 mox.IgnoreArg())",
            "        self._mox.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_fetch_to_raw_with_bps_limit(self, mock_stat):",
            "        SRC_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "        DST_INFO = (\"image: qemu.raw\\n\"",
            "                    \"file_format: raw\\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\\n\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO, dest_inf=DST_INFO,",
            "                                bps_limit=1048576)",
            "",
            "        image_utils.fetch_to_raw(context, self._image_service,",
            "                                 self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                                 mox.IgnoreArg())",
            "        self._mox.VerifyAll()",
            "",
            "    def test_fetch_to_raw_no_qemu_img(self):",
            "        self._test_fetch_to_raw(has_qemu=False)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    def test_fetch_to_raw_on_error_parsing_failed(self):",
            "        SRC_INFO_NO_FORMAT = (\"image: qemu.qcow2\\n\"",
            "                              \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                              \"cluster_size: 65536\\n\"",
            "                              \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO_NO_FORMAT)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    def test_fetch_to_raw_on_error_backing_file(self):",
            "        SRC_INFO_BACKING_FILE = (\"image: qemu.qcow2\\n\"",
            "                                 \"backing_file: qemu.qcow2\\n\"",
            "                                 \"file_format: qcow2 \\n\"",
            "                                 \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                                 \"cluster_size: 65536\\n\"",
            "                                 \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO_BACKING_FILE)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    @mock.patch('os.stat')",
            "    def test_fetch_to_raw_on_error_not_convert_to_raw(self, mock_stat):",
            "",
            "        IMG_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 50M (52428800 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=IMG_INFO, dest_inf=IMG_INFO)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg())",
            "",
            "    def test_fetch_to_raw_on_error_image_size(self):",
            "        TEST_VOLUME_SIZE = 1",
            "        SRC_INFO = (\"image: qemu.qcow2\\n\"",
            "                    \"file_format: qcow2 \\n\"",
            "                    \"virtual_size: 2G (2147483648 bytes)\\n\"",
            "                    \"cluster_size: 65536\\n\"",
            "                    \"disk_size: 196K (200704 bytes)\")",
            "",
            "        self._test_fetch_to_raw(src_inf=SRC_INFO)",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_to_raw,",
            "                          context, self._image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          mox.IgnoreArg(), size=TEST_VOLUME_SIZE)",
            "",
            "    def _test_fetch_verify_image(self, qemu_info, volume_size=1):",
            "        fake_image_service = FakeImageService()",
            "        mox = self._mox",
            "        mox.StubOutWithMock(image_utils, 'fetch')",
            "        mox.StubOutWithMock(utils, 'execute')",
            "        image_utils.fetch(context, fake_image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH, None, None)",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            self.TEST_DEV_PATH, run_as_root=True).AndReturn(",
            "                (qemu_info, 'ignored'))",
            "",
            "        self._mox.ReplayAll()",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.fetch_verify_image,",
            "                          context, fake_image_service,",
            "                          self.TEST_IMAGE_ID, self.TEST_DEV_PATH,",
            "                          size=volume_size)",
            "",
            "    def test_fetch_verify_image_with_backing_file(self):",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"backing_file: qemu.qcow2 (actual path: qemu.qcow2)\\n\"\\",
            "                      \"file_format: qcow2\\n\"\\",
            "                      \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "",
            "        self._test_fetch_verify_image(TEST_RETURN)",
            "",
            "    def test_fetch_verify_image_without_file_format(self):",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "",
            "        self._test_fetch_verify_image(TEST_RETURN)",
            "",
            "    def test_fetch_verify_image_image_size(self):",
            "        TEST_RETURN = \"image: qemu.qcow2\\n\"\\",
            "                      \"file_format: qcow2\\n\"\\",
            "                      \"virtual_size: 2G (2147483648 bytes)\\n\"\\",
            "                      \"cluster_size: 65536\\n\"\\",
            "                      \"disk_size: 196K (200704 bytes)\\n\"\\",
            "                      \"Snapshot list:\\n\"\\",
            "                      \"ID TAG  VM SIZE DATE VM CLOCK\\n\"\\",
            "                      \"1  snap1 1.7G 2011-10-04 19:04:00 32:06:34.974\"",
            "",
            "        self._test_fetch_verify_image(TEST_RETURN)",
            "",
            "    @mock.patch('os.stat')",
            "    def test_upload_volume(self, mock_stat, bps_limit=0):",
            "        image_meta = {'id': 1, 'disk_format': 'qcow2'}",
            "        TEST_RET = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2 \\n\"\\",
            "                   \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"disk_size: 196K (200704 bytes)\"",
            "",
            "        if bps_limit:",
            "            CONF.set_override('volume_copy_bps_limit', bps_limit)",
            "            prefix = ('cgexec', '-g', 'blkio:test')",
            "        else:",
            "            prefix = ()",
            "",
            "        cmd = prefix + ('qemu-img', 'convert', '-O', 'qcow2',",
            "                        mox.IgnoreArg(), mox.IgnoreArg())",
            "",
            "        m = self._mox",
            "        m.StubOutWithMock(utils, 'execute')",
            "        m.StubOutWithMock(volume_utils, 'setup_blkio_cgroup')",
            "",
            "        volume_utils.setup_blkio_cgroup(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                                        bps_limit).AndReturn(prefix)",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "        utils.execute(*cmd, run_as_root=True)",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "",
            "        m.ReplayAll()",
            "",
            "        image_utils.upload_volume(context, FakeImageService(),",
            "                                  image_meta, '/dev/loop1')",
            "        m.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_upload_volume_with_bps_limit(self, mock_stat):",
            "        bps_limit = 1048576",
            "        image_meta = {'id': 1, 'disk_format': 'qcow2'}",
            "        TEST_RET = \"image: qemu.qcow2\\n\"\\",
            "                   \"file_format: qcow2 \\n\"\\",
            "                   \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"disk_size: 196K (200704 bytes)\"",
            "",
            "        CONF.set_override('volume_copy_bps_limit', bps_limit)",
            "        prefix = ('cgexec', '-g', 'blkio:test')",
            "",
            "        cmd = prefix + ('qemu-img', 'convert', '-O', 'qcow2',",
            "                        mox.IgnoreArg(), mox.IgnoreArg())",
            "",
            "        m = self._mox",
            "        m.StubOutWithMock(utils, 'execute')",
            "        m.StubOutWithMock(volume_utils, 'setup_blkio_cgroup')",
            "        m.StubOutWithMock(volume_utils, 'check_for_odirect_support')",
            "",
            "        volume_utils.setup_blkio_cgroup(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                                        bps_limit).AndReturn(prefix)",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "        utils.execute(*cmd, run_as_root=True)",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "",
            "        m.ReplayAll()",
            "        image_utils.upload_volume(context, FakeImageService(),",
            "                                  image_meta, '/dev/loop1')",
            "        m.VerifyAll()",
            "",
            "    def test_upload_volume_with_raw_image(self):",
            "        image_meta = {'id': 1, 'disk_format': 'raw'}",
            "        mox = self._mox",
            "",
            "        mox.StubOutWithMock(image_utils, 'convert_image')",
            "",
            "        mox.ReplayAll()",
            "",
            "        with tempfile.NamedTemporaryFile() as f:",
            "            image_utils.upload_volume(context, FakeImageService(),",
            "                                      image_meta, f.name)",
            "        mox.VerifyAll()",
            "",
            "    @mock.patch('os.stat')",
            "    def test_upload_volume_on_error(self, mock_stat):",
            "        image_meta = {'id': 1, 'disk_format': 'qcow2'}",
            "        TEST_RET = \"image: qemu.vhd\\n\"\\",
            "                   \"file_format: vhd \\n\"\\",
            "                   \"virtual_size: 50M (52428800 bytes)\\n\"\\",
            "                   \"cluster_size: 65536\\n\"\\",
            "                   \"disk_size: 196K (200704 bytes)\"",
            "",
            "        m = self._mox",
            "        m.StubOutWithMock(utils, 'execute')",
            "        m.StubOutWithMock(volume_utils, 'check_for_odirect_support')",
            "",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "        utils.execute('qemu-img', 'convert', '-O', 'qcow2',",
            "                      mox.IgnoreArg(), mox.IgnoreArg(), run_as_root=True)",
            "        utils.execute(",
            "            'env', 'LC_ALL=C', 'qemu-img', 'info',",
            "            mox.IgnoreArg(), run_as_root=True).AndReturn(",
            "                (TEST_RET, 'ignored'))",
            "",
            "        m.ReplayAll()",
            "",
            "        self.assertRaises(exception.ImageUnacceptable,",
            "                          image_utils.upload_volume,",
            "                          context, FakeImageService(),",
            "                          image_meta, '/dev/loop1')",
            "        m.VerifyAll()",
            "",
            "",
            "class TestExtractTo(test.TestCase):",
            "    def test_extract_to_calls_tar(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'tar', '-xzf', 'archive.tgz', '-C', 'targetpath').AndReturn(",
            "                ('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.extract_targz('archive.tgz', 'targetpath')",
            "        mox.VerifyAll()",
            "",
            "",
            "class TestSetVhdParent(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'modify', '-n', 'child', '-p', 'parent').AndReturn(",
            "                ('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.set_vhd_parent('child', 'parent')",
            "        mox.VerifyAll()",
            "",
            "",
            "class TestFixVhdChain(test.TestCase):",
            "    def test_empty_chain(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'set_vhd_parent')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.fix_vhd_chain([])",
            "",
            "    def test_single_vhd_file_chain(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'set_vhd_parent')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.fix_vhd_chain(['0.vhd'])",
            "",
            "    def test_chain_with_two_elements(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'set_vhd_parent')",
            "",
            "        image_utils.set_vhd_parent('0.vhd', '1.vhd')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.fix_vhd_chain(['0.vhd', '1.vhd'])",
            "",
            "",
            "class TestGetSize(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'query', '-n', 'vhdfile', '-v').AndReturn(",
            "                ('1024', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        result = image_utils.get_vhd_size('vhdfile')",
            "        mox.VerifyAll()",
            "",
            "        self.assertEqual(1024, result)",
            "",
            "",
            "class TestResize(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'resize', '-n', 'vhdfile', '-s', '1024',",
            "            '-j', 'journal').AndReturn(('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.resize_vhd('vhdfile', 1024, 'journal')",
            "        mox.VerifyAll()",
            "",
            "",
            "class TestCoalesce(test.TestCase):",
            "    def test_vhd_util_call(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(utils, 'execute')",
            "",
            "        utils.execute(",
            "            'vhd-util', 'coalesce', '-n', 'vhdfile'",
            "        ).AndReturn(('ignored', 'ignored'))",
            "",
            "        mox.ReplayAll()",
            "",
            "        image_utils.coalesce_vhd('vhdfile')",
            "        mox.VerifyAll()",
            "",
            "",
            "@contextlib.contextmanager",
            "def fake_context(return_value):",
            "    yield return_value",
            "",
            "",
            "class TestTemporaryFile(test.TestCase):",
            "    def test_file_unlinked(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'create_temporary_file')",
            "        mox.StubOutWithMock(fileutils, 'delete_if_exists')",
            "",
            "        image_utils.create_temporary_file().AndReturn('somefile')",
            "        fileutils.delete_if_exists('somefile')",
            "",
            "        mox.ReplayAll()",
            "",
            "        with image_utils.temporary_file():",
            "            pass",
            "",
            "    def test_file_unlinked_on_error(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'create_temporary_file')",
            "        mox.StubOutWithMock(fileutils, 'delete_if_exists')",
            "",
            "        image_utils.create_temporary_file().AndReturn('somefile')",
            "        fileutils.delete_if_exists('somefile')",
            "",
            "        mox.ReplayAll()",
            "",
            "        def sut():",
            "            with image_utils.temporary_file():",
            "                raise test.TestingException()",
            "",
            "        self.assertRaises(test.TestingException, sut)",
            "",
            "",
            "class TestCoalesceChain(test.TestCase):",
            "    def test_single_vhd(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'get_vhd_size')",
            "        mox.StubOutWithMock(image_utils, 'resize_vhd')",
            "        mox.StubOutWithMock(image_utils, 'coalesce_vhd')",
            "",
            "        mox.ReplayAll()",
            "",
            "        result = image_utils.coalesce_chain(['0.vhd'])",
            "        mox.VerifyAll()",
            "",
            "        self.assertEqual('0.vhd', result)",
            "",
            "    def test_chain_of_two_vhds(self):",
            "        self.mox.StubOutWithMock(image_utils, 'get_vhd_size')",
            "        self.mox.StubOutWithMock(image_utils, 'temporary_dir')",
            "        self.mox.StubOutWithMock(image_utils, 'resize_vhd')",
            "        self.mox.StubOutWithMock(image_utils, 'coalesce_vhd')",
            "        self.mox.StubOutWithMock(image_utils, 'temporary_file')",
            "",
            "        image_utils.get_vhd_size('0.vhd').AndReturn(1024)",
            "        image_utils.temporary_dir().AndReturn(fake_context('tdir'))",
            "        image_utils.resize_vhd('1.vhd', 1024, 'tdir/vhd-util-resize-journal')",
            "        image_utils.coalesce_vhd('0.vhd')",
            "        self.mox.ReplayAll()",
            "",
            "        result = image_utils.coalesce_chain(['0.vhd', '1.vhd'])",
            "        self.mox.VerifyAll()",
            "        self.assertEqual('1.vhd', result)",
            "",
            "",
            "class TestDiscoverChain(test.TestCase):",
            "    def test_discovery_calls(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'file_exist')",
            "",
            "        image_utils.file_exist('some/path/0.vhd').AndReturn(True)",
            "        image_utils.file_exist('some/path/1.vhd').AndReturn(True)",
            "        image_utils.file_exist('some/path/2.vhd').AndReturn(False)",
            "",
            "        mox.ReplayAll()",
            "        result = image_utils.discover_vhd_chain('some/path')",
            "        mox.VerifyAll()",
            "",
            "        self.assertEqual(",
            "            ['some/path/0.vhd', 'some/path/1.vhd'], result)",
            "",
            "",
            "class TestXenServerImageToCoalescedVhd(test.TestCase):",
            "    def test_calls(self):",
            "        mox = self.mox",
            "        mox.StubOutWithMock(image_utils, 'temporary_dir')",
            "        mox.StubOutWithMock(image_utils, 'extract_targz')",
            "        mox.StubOutWithMock(image_utils, 'discover_vhd_chain')",
            "        mox.StubOutWithMock(image_utils, 'fix_vhd_chain')",
            "        mox.StubOutWithMock(image_utils, 'coalesce_chain')",
            "        mox.StubOutWithMock(image_utils.os, 'unlink')",
            "        mox.StubOutWithMock(fileutils, 'delete_if_exists')",
            "        mox.StubOutWithMock(image_utils, 'rename_file')",
            "",
            "        image_utils.temporary_dir().AndReturn(fake_context('somedir'))",
            "        image_utils.extract_targz('image', 'somedir')",
            "        image_utils.discover_vhd_chain('somedir').AndReturn(",
            "            ['somedir/0.vhd', 'somedir/1.vhd'])",
            "        image_utils.fix_vhd_chain(['somedir/0.vhd', 'somedir/1.vhd'])",
            "        image_utils.coalesce_chain(",
            "            ['somedir/0.vhd', 'somedir/1.vhd']).AndReturn('somedir/1.vhd')",
            "        fileutils.delete_if_exists('image')",
            "        image_utils.rename_file('somedir/1.vhd', 'image')",
            "",
            "        mox.ReplayAll()",
            "        image_utils.replace_xenserver_image_with_coalesced_vhd('image')",
            "        mox.VerifyAll()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    }
}