{
    "Tests/test_file_eps.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " import io"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import pytest"
            },
            "3": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from PIL import EpsImagePlugin, Image, features"
            },
            "5": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 263,
                "PatchRowcode": "     assert image.mode == \"RGB\""
            },
            "6": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "     assert image.size == (460, 352)"
            },
            "7": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "     assert image.format == \"EPS\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+@pytest.mark.timeout(timeout=5)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 269,
                "PatchRowcode": "+@pytest.mark.parametrize("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+    \"test_file\","
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+    ["
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 272,
                "PatchRowcode": "+        (\"Tests/images/timeout-d675703545fee17acab56e5fec644c19979175de.eps\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    ],"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+def test_timeout(test_file):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 276,
                "PatchRowcode": "+    with open(test_file, \"rb\") as f:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 277,
                "PatchRowcode": "+        with pytest.raises(Image.UnidentifiedImageError):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 278,
                "PatchRowcode": "+            with Image.open(f):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 279,
                "PatchRowcode": "+                pass"
            }
        },
        "frontPatchFile": [
            "import io",
            "",
            "import pytest",
            "",
            "from PIL import EpsImagePlugin, Image, features",
            "",
            "from .helper import (",
            "    assert_image_similar,",
            "    assert_image_similar_tofile,",
            "    hopper,",
            "    skip_unless_feature,",
            ")",
            "",
            "HAS_GHOSTSCRIPT = EpsImagePlugin.has_ghostscript()",
            "",
            "# Our two EPS test files (they are identical except for their bounding boxes)",
            "FILE1 = \"Tests/images/zero_bb.eps\"",
            "FILE2 = \"Tests/images/non_zero_bb.eps\"",
            "",
            "# Due to palletization, we'll need to convert these to RGB after load",
            "FILE1_COMPARE = \"Tests/images/zero_bb.png\"",
            "FILE1_COMPARE_SCALE2 = \"Tests/images/zero_bb_scale2.png\"",
            "",
            "FILE2_COMPARE = \"Tests/images/non_zero_bb.png\"",
            "FILE2_COMPARE_SCALE2 = \"Tests/images/non_zero_bb_scale2.png\"",
            "",
            "# EPS test files with binary preview",
            "FILE3 = \"Tests/images/binary_preview_map.eps\"",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_sanity():",
            "    # Regular scale",
            "    with Image.open(FILE1) as image1:",
            "        image1.load()",
            "        assert image1.mode == \"RGB\"",
            "        assert image1.size == (460, 352)",
            "        assert image1.format == \"EPS\"",
            "",
            "    with Image.open(FILE2) as image2:",
            "        image2.load()",
            "        assert image2.mode == \"RGB\"",
            "        assert image2.size == (360, 252)",
            "        assert image2.format == \"EPS\"",
            "",
            "    # Double scale",
            "    with Image.open(FILE1) as image1_scale2:",
            "        image1_scale2.load(scale=2)",
            "        assert image1_scale2.mode == \"RGB\"",
            "        assert image1_scale2.size == (920, 704)",
            "        assert image1_scale2.format == \"EPS\"",
            "",
            "    with Image.open(FILE2) as image2_scale2:",
            "        image2_scale2.load(scale=2)",
            "        assert image2_scale2.mode == \"RGB\"",
            "        assert image2_scale2.size == (720, 504)",
            "        assert image2_scale2.format == \"EPS\"",
            "",
            "",
            "def test_invalid_file():",
            "    invalid_file = \"Tests/images/flower.jpg\"",
            "",
            "    with pytest.raises(SyntaxError):",
            "        EpsImagePlugin.EpsImageFile(invalid_file)",
            "",
            "",
            "@pytest.mark.valgrind_known_error(reason=\"Known Failing\")",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_cmyk():",
            "    with Image.open(\"Tests/images/pil_sample_cmyk.eps\") as cmyk_image:",
            "",
            "        assert cmyk_image.mode == \"CMYK\"",
            "        assert cmyk_image.size == (100, 100)",
            "        assert cmyk_image.format == \"EPS\"",
            "",
            "        cmyk_image.load()",
            "        assert cmyk_image.mode == \"RGB\"",
            "",
            "        if features.check(\"jpg\"):",
            "            assert_image_similar_tofile(",
            "                cmyk_image, \"Tests/images/pil_sample_rgb.jpg\", 10",
            "            )",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_showpage():",
            "    # See https://github.com/python-pillow/Pillow/issues/2615",
            "    with Image.open(\"Tests/images/reqd_showpage.eps\") as plot_image:",
            "        with Image.open(\"Tests/images/reqd_showpage.png\") as target:",
            "            # should not crash/hang",
            "            plot_image.load()",
            "            #  fonts could be slightly different",
            "            assert_image_similar(plot_image, target, 6)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_file_object(tmp_path):",
            "    # issue 479",
            "    with Image.open(FILE1) as image1:",
            "        with open(str(tmp_path / \"temp.eps\"), \"wb\") as fh:",
            "            image1.save(fh, \"EPS\")",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_iobase_object(tmp_path):",
            "    # issue 479",
            "    with Image.open(FILE1) as image1:",
            "        with open(str(tmp_path / \"temp_iobase.eps\"), \"wb\") as fh:",
            "            image1.save(fh, \"EPS\")",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_bytesio_object():",
            "    with open(FILE1, \"rb\") as f:",
            "        img_bytes = io.BytesIO(f.read())",
            "",
            "    with Image.open(img_bytes) as img:",
            "        img.load()",
            "",
            "        with Image.open(FILE1_COMPARE) as image1_scale1_compare:",
            "            image1_scale1_compare = image1_scale1_compare.convert(\"RGB\")",
            "        image1_scale1_compare.load()",
            "        assert_image_similar(img, image1_scale1_compare, 5)",
            "",
            "",
            "def test_image_mode_not_supported(tmp_path):",
            "    im = hopper(\"RGBA\")",
            "    tmpfile = str(tmp_path / \"temp.eps\")",
            "    with pytest.raises(ValueError):",
            "        im.save(tmpfile)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "@skip_unless_feature(\"zlib\")",
            "def test_render_scale1():",
            "    # We need png support for these render test",
            "",
            "    # Zero bounding box",
            "    with Image.open(FILE1) as image1_scale1:",
            "        image1_scale1.load()",
            "        with Image.open(FILE1_COMPARE) as image1_scale1_compare:",
            "            image1_scale1_compare = image1_scale1_compare.convert(\"RGB\")",
            "        image1_scale1_compare.load()",
            "        assert_image_similar(image1_scale1, image1_scale1_compare, 5)",
            "",
            "    # Non-Zero bounding box",
            "    with Image.open(FILE2) as image2_scale1:",
            "        image2_scale1.load()",
            "        with Image.open(FILE2_COMPARE) as image2_scale1_compare:",
            "            image2_scale1_compare = image2_scale1_compare.convert(\"RGB\")",
            "        image2_scale1_compare.load()",
            "        assert_image_similar(image2_scale1, image2_scale1_compare, 10)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "@skip_unless_feature(\"zlib\")",
            "def test_render_scale2():",
            "    # We need png support for these render test",
            "",
            "    # Zero bounding box",
            "    with Image.open(FILE1) as image1_scale2:",
            "        image1_scale2.load(scale=2)",
            "        with Image.open(FILE1_COMPARE_SCALE2) as image1_scale2_compare:",
            "            image1_scale2_compare = image1_scale2_compare.convert(\"RGB\")",
            "        image1_scale2_compare.load()",
            "        assert_image_similar(image1_scale2, image1_scale2_compare, 5)",
            "",
            "    # Non-Zero bounding box",
            "    with Image.open(FILE2) as image2_scale2:",
            "        image2_scale2.load(scale=2)",
            "        with Image.open(FILE2_COMPARE_SCALE2) as image2_scale2_compare:",
            "            image2_scale2_compare = image2_scale2_compare.convert(\"RGB\")",
            "        image2_scale2_compare.load()",
            "        assert_image_similar(image2_scale2, image2_scale2_compare, 10)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_resize():",
            "    files = [FILE1, FILE2, \"Tests/images/illu10_preview.eps\"]",
            "    for fn in files:",
            "        with Image.open(fn) as im:",
            "            new_size = (100, 100)",
            "            im = im.resize(new_size)",
            "            assert im.size == new_size",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_thumbnail():",
            "    # Issue #619",
            "    # Arrange",
            "    files = [FILE1, FILE2]",
            "    for fn in files:",
            "        with Image.open(FILE1) as im:",
            "            new_size = (100, 100)",
            "            im.thumbnail(new_size)",
            "            assert max(im.size) == max(new_size)",
            "",
            "",
            "def test_read_binary_preview():",
            "    # Issue 302",
            "    # open image with binary preview",
            "    with Image.open(FILE3):",
            "        pass",
            "",
            "",
            "def test_readline(tmp_path):",
            "    # check all the freaking line endings possible from the spec",
            "    # test_string = u'something\\r\\nelse\\n\\rbaz\\rbif\\n'",
            "    line_endings = [\"\\r\\n\", \"\\n\", \"\\n\\r\", \"\\r\"]",
            "    strings = [\"something\", \"else\", \"baz\", \"bif\"]",
            "",
            "    def _test_readline(t, ending):",
            "        ending = \"Failure with line ending: %s\" % (",
            "            \"\".join(\"%s\" % ord(s) for s in ending)",
            "        )",
            "        assert t.readline().strip(\"\\r\\n\") == \"something\", ending",
            "        assert t.readline().strip(\"\\r\\n\") == \"else\", ending",
            "        assert t.readline().strip(\"\\r\\n\") == \"baz\", ending",
            "        assert t.readline().strip(\"\\r\\n\") == \"bif\", ending",
            "",
            "    def _test_readline_io_psfile(test_string, ending):",
            "        f = io.BytesIO(test_string.encode(\"latin-1\"))",
            "        t = EpsImagePlugin.PSFile(f)",
            "        _test_readline(t, ending)",
            "",
            "    def _test_readline_file_psfile(test_string, ending):",
            "        f = str(tmp_path / \"temp.txt\")",
            "        with open(f, \"wb\") as w:",
            "            w.write(test_string.encode(\"latin-1\"))",
            "",
            "        with open(f, \"rb\") as r:",
            "            t = EpsImagePlugin.PSFile(r)",
            "            _test_readline(t, ending)",
            "",
            "    for ending in line_endings:",
            "        s = ending.join(strings)",
            "        _test_readline_io_psfile(s, ending)",
            "        _test_readline_file_psfile(s, ending)",
            "",
            "",
            "def test_open_eps():",
            "    # https://github.com/python-pillow/Pillow/issues/1104",
            "    # Arrange",
            "    FILES = [",
            "        \"Tests/images/illu10_no_preview.eps\",",
            "        \"Tests/images/illu10_preview.eps\",",
            "        \"Tests/images/illuCS6_no_preview.eps\",",
            "        \"Tests/images/illuCS6_preview.eps\",",
            "    ]",
            "",
            "    # Act / Assert",
            "    for filename in FILES:",
            "        with Image.open(filename) as img:",
            "            assert img.mode == \"RGB\"",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_emptyline():",
            "    # Test file includes an empty line in the header data",
            "    emptyline_file = \"Tests/images/zero_bb_emptyline.eps\"",
            "",
            "    with Image.open(emptyline_file) as image:",
            "        image.load()",
            "    assert image.mode == \"RGB\"",
            "    assert image.size == (460, 352)",
            "    assert image.format == \"EPS\""
        ],
        "afterPatchFile": [
            "import io",
            "import pytest",
            "",
            "from PIL import EpsImagePlugin, Image, features",
            "",
            "from .helper import (",
            "    assert_image_similar,",
            "    assert_image_similar_tofile,",
            "    hopper,",
            "    skip_unless_feature,",
            ")",
            "",
            "HAS_GHOSTSCRIPT = EpsImagePlugin.has_ghostscript()",
            "",
            "# Our two EPS test files (they are identical except for their bounding boxes)",
            "FILE1 = \"Tests/images/zero_bb.eps\"",
            "FILE2 = \"Tests/images/non_zero_bb.eps\"",
            "",
            "# Due to palletization, we'll need to convert these to RGB after load",
            "FILE1_COMPARE = \"Tests/images/zero_bb.png\"",
            "FILE1_COMPARE_SCALE2 = \"Tests/images/zero_bb_scale2.png\"",
            "",
            "FILE2_COMPARE = \"Tests/images/non_zero_bb.png\"",
            "FILE2_COMPARE_SCALE2 = \"Tests/images/non_zero_bb_scale2.png\"",
            "",
            "# EPS test files with binary preview",
            "FILE3 = \"Tests/images/binary_preview_map.eps\"",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_sanity():",
            "    # Regular scale",
            "    with Image.open(FILE1) as image1:",
            "        image1.load()",
            "        assert image1.mode == \"RGB\"",
            "        assert image1.size == (460, 352)",
            "        assert image1.format == \"EPS\"",
            "",
            "    with Image.open(FILE2) as image2:",
            "        image2.load()",
            "        assert image2.mode == \"RGB\"",
            "        assert image2.size == (360, 252)",
            "        assert image2.format == \"EPS\"",
            "",
            "    # Double scale",
            "    with Image.open(FILE1) as image1_scale2:",
            "        image1_scale2.load(scale=2)",
            "        assert image1_scale2.mode == \"RGB\"",
            "        assert image1_scale2.size == (920, 704)",
            "        assert image1_scale2.format == \"EPS\"",
            "",
            "    with Image.open(FILE2) as image2_scale2:",
            "        image2_scale2.load(scale=2)",
            "        assert image2_scale2.mode == \"RGB\"",
            "        assert image2_scale2.size == (720, 504)",
            "        assert image2_scale2.format == \"EPS\"",
            "",
            "",
            "def test_invalid_file():",
            "    invalid_file = \"Tests/images/flower.jpg\"",
            "",
            "    with pytest.raises(SyntaxError):",
            "        EpsImagePlugin.EpsImageFile(invalid_file)",
            "",
            "",
            "@pytest.mark.valgrind_known_error(reason=\"Known Failing\")",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_cmyk():",
            "    with Image.open(\"Tests/images/pil_sample_cmyk.eps\") as cmyk_image:",
            "",
            "        assert cmyk_image.mode == \"CMYK\"",
            "        assert cmyk_image.size == (100, 100)",
            "        assert cmyk_image.format == \"EPS\"",
            "",
            "        cmyk_image.load()",
            "        assert cmyk_image.mode == \"RGB\"",
            "",
            "        if features.check(\"jpg\"):",
            "            assert_image_similar_tofile(",
            "                cmyk_image, \"Tests/images/pil_sample_rgb.jpg\", 10",
            "            )",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_showpage():",
            "    # See https://github.com/python-pillow/Pillow/issues/2615",
            "    with Image.open(\"Tests/images/reqd_showpage.eps\") as plot_image:",
            "        with Image.open(\"Tests/images/reqd_showpage.png\") as target:",
            "            # should not crash/hang",
            "            plot_image.load()",
            "            #  fonts could be slightly different",
            "            assert_image_similar(plot_image, target, 6)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_file_object(tmp_path):",
            "    # issue 479",
            "    with Image.open(FILE1) as image1:",
            "        with open(str(tmp_path / \"temp.eps\"), \"wb\") as fh:",
            "            image1.save(fh, \"EPS\")",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_iobase_object(tmp_path):",
            "    # issue 479",
            "    with Image.open(FILE1) as image1:",
            "        with open(str(tmp_path / \"temp_iobase.eps\"), \"wb\") as fh:",
            "            image1.save(fh, \"EPS\")",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_bytesio_object():",
            "    with open(FILE1, \"rb\") as f:",
            "        img_bytes = io.BytesIO(f.read())",
            "",
            "    with Image.open(img_bytes) as img:",
            "        img.load()",
            "",
            "        with Image.open(FILE1_COMPARE) as image1_scale1_compare:",
            "            image1_scale1_compare = image1_scale1_compare.convert(\"RGB\")",
            "        image1_scale1_compare.load()",
            "        assert_image_similar(img, image1_scale1_compare, 5)",
            "",
            "",
            "def test_image_mode_not_supported(tmp_path):",
            "    im = hopper(\"RGBA\")",
            "    tmpfile = str(tmp_path / \"temp.eps\")",
            "    with pytest.raises(ValueError):",
            "        im.save(tmpfile)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "@skip_unless_feature(\"zlib\")",
            "def test_render_scale1():",
            "    # We need png support for these render test",
            "",
            "    # Zero bounding box",
            "    with Image.open(FILE1) as image1_scale1:",
            "        image1_scale1.load()",
            "        with Image.open(FILE1_COMPARE) as image1_scale1_compare:",
            "            image1_scale1_compare = image1_scale1_compare.convert(\"RGB\")",
            "        image1_scale1_compare.load()",
            "        assert_image_similar(image1_scale1, image1_scale1_compare, 5)",
            "",
            "    # Non-Zero bounding box",
            "    with Image.open(FILE2) as image2_scale1:",
            "        image2_scale1.load()",
            "        with Image.open(FILE2_COMPARE) as image2_scale1_compare:",
            "            image2_scale1_compare = image2_scale1_compare.convert(\"RGB\")",
            "        image2_scale1_compare.load()",
            "        assert_image_similar(image2_scale1, image2_scale1_compare, 10)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "@skip_unless_feature(\"zlib\")",
            "def test_render_scale2():",
            "    # We need png support for these render test",
            "",
            "    # Zero bounding box",
            "    with Image.open(FILE1) as image1_scale2:",
            "        image1_scale2.load(scale=2)",
            "        with Image.open(FILE1_COMPARE_SCALE2) as image1_scale2_compare:",
            "            image1_scale2_compare = image1_scale2_compare.convert(\"RGB\")",
            "        image1_scale2_compare.load()",
            "        assert_image_similar(image1_scale2, image1_scale2_compare, 5)",
            "",
            "    # Non-Zero bounding box",
            "    with Image.open(FILE2) as image2_scale2:",
            "        image2_scale2.load(scale=2)",
            "        with Image.open(FILE2_COMPARE_SCALE2) as image2_scale2_compare:",
            "            image2_scale2_compare = image2_scale2_compare.convert(\"RGB\")",
            "        image2_scale2_compare.load()",
            "        assert_image_similar(image2_scale2, image2_scale2_compare, 10)",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_resize():",
            "    files = [FILE1, FILE2, \"Tests/images/illu10_preview.eps\"]",
            "    for fn in files:",
            "        with Image.open(fn) as im:",
            "            new_size = (100, 100)",
            "            im = im.resize(new_size)",
            "            assert im.size == new_size",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_thumbnail():",
            "    # Issue #619",
            "    # Arrange",
            "    files = [FILE1, FILE2]",
            "    for fn in files:",
            "        with Image.open(FILE1) as im:",
            "            new_size = (100, 100)",
            "            im.thumbnail(new_size)",
            "            assert max(im.size) == max(new_size)",
            "",
            "",
            "def test_read_binary_preview():",
            "    # Issue 302",
            "    # open image with binary preview",
            "    with Image.open(FILE3):",
            "        pass",
            "",
            "",
            "def test_readline(tmp_path):",
            "    # check all the freaking line endings possible from the spec",
            "    # test_string = u'something\\r\\nelse\\n\\rbaz\\rbif\\n'",
            "    line_endings = [\"\\r\\n\", \"\\n\", \"\\n\\r\", \"\\r\"]",
            "    strings = [\"something\", \"else\", \"baz\", \"bif\"]",
            "",
            "    def _test_readline(t, ending):",
            "        ending = \"Failure with line ending: %s\" % (",
            "            \"\".join(\"%s\" % ord(s) for s in ending)",
            "        )",
            "        assert t.readline().strip(\"\\r\\n\") == \"something\", ending",
            "        assert t.readline().strip(\"\\r\\n\") == \"else\", ending",
            "        assert t.readline().strip(\"\\r\\n\") == \"baz\", ending",
            "        assert t.readline().strip(\"\\r\\n\") == \"bif\", ending",
            "",
            "    def _test_readline_io_psfile(test_string, ending):",
            "        f = io.BytesIO(test_string.encode(\"latin-1\"))",
            "        t = EpsImagePlugin.PSFile(f)",
            "        _test_readline(t, ending)",
            "",
            "    def _test_readline_file_psfile(test_string, ending):",
            "        f = str(tmp_path / \"temp.txt\")",
            "        with open(f, \"wb\") as w:",
            "            w.write(test_string.encode(\"latin-1\"))",
            "",
            "        with open(f, \"rb\") as r:",
            "            t = EpsImagePlugin.PSFile(r)",
            "            _test_readline(t, ending)",
            "",
            "    for ending in line_endings:",
            "        s = ending.join(strings)",
            "        _test_readline_io_psfile(s, ending)",
            "        _test_readline_file_psfile(s, ending)",
            "",
            "",
            "def test_open_eps():",
            "    # https://github.com/python-pillow/Pillow/issues/1104",
            "    # Arrange",
            "    FILES = [",
            "        \"Tests/images/illu10_no_preview.eps\",",
            "        \"Tests/images/illu10_preview.eps\",",
            "        \"Tests/images/illuCS6_no_preview.eps\",",
            "        \"Tests/images/illuCS6_preview.eps\",",
            "    ]",
            "",
            "    # Act / Assert",
            "    for filename in FILES:",
            "        with Image.open(filename) as img:",
            "            assert img.mode == \"RGB\"",
            "",
            "",
            "@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")",
            "def test_emptyline():",
            "    # Test file includes an empty line in the header data",
            "    emptyline_file = \"Tests/images/zero_bb_emptyline.eps\"",
            "",
            "    with Image.open(emptyline_file) as image:",
            "        image.load()",
            "    assert image.mode == \"RGB\"",
            "    assert image.size == (460, 352)",
            "    assert image.format == \"EPS\"",
            "",
            "",
            "@pytest.mark.timeout(timeout=5)",
            "@pytest.mark.parametrize(",
            "    \"test_file\",",
            "    [",
            "        (\"Tests/images/timeout-d675703545fee17acab56e5fec644c19979175de.eps\")",
            "    ],",
            ")",
            "def test_timeout(test_file):",
            "    with open(test_file, \"rb\") as f:",
            "        with pytest.raises(Image.UnidentifiedImageError):",
            "            with Image.open(f):",
            "                pass"
        ],
        "action": [
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "2": []
        },
        "addLocation": []
    },
    "src/PIL/EpsImagePlugin.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "         self.fp.seek(offset, whence)"
            },
            "1": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "     def readline(self):"
            },
            "3": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        s = self.char or b\"\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        s = [self.char or b\"\"]"
            },
            "5": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         self.char = None"
            },
            "6": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         c = self.fp.read(1)"
            },
            "8": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        while c not in b\"\\r\\n\":"
            },
            "9": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            s = s + c"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        while (c not in b\"\\r\\n\") and len(c):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            s.append(c)"
            },
            "12": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "             c = self.fp.read(1)"
            },
            "13": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "         self.char = self.fp.read(1)"
            },
            "15": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         # line endings can be 1 or 2 of \\r \\n, in either order"
            },
            "16": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         if self.char in b\"\\r\\n\":"
            },
            "17": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "             self.char = None"
            },
            "18": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return s.decode(\"latin-1\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        return b\"\".join(s).decode(\"latin-1\")"
            },
            "21": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": 187,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": " def _accept(prefix):"
            }
        },
        "frontPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# EPS file handling",
            "#",
            "# History:",
            "# 1995-09-01 fl   Created (0.1)",
            "# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)",
            "# 1996-08-22 fl   Don't choke on floating point BoundingBox values",
            "# 1996-08-23 fl   Handle files from Macintosh (0.3)",
            "# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)",
            "# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)",
            "# 2014-05-07 e    Handling of EPS with binary preview and fixed resolution",
            "#                 resizing",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-2003 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import os",
            "import re",
            "import subprocess",
            "import sys",
            "import tempfile",
            "",
            "from . import Image, ImageFile",
            "from ._binary import i32le as i32",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "split = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")",
            "field = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")",
            "",
            "gs_windows_binary = None",
            "if sys.platform.startswith(\"win\"):",
            "    import shutil",
            "",
            "    for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):",
            "        if shutil.which(binary) is not None:",
            "            gs_windows_binary = binary",
            "            break",
            "    else:",
            "        gs_windows_binary = False",
            "",
            "",
            "def has_ghostscript():",
            "    if gs_windows_binary:",
            "        return True",
            "    if not sys.platform.startswith(\"win\"):",
            "        try:",
            "            subprocess.check_call([\"gs\", \"--version\"], stdout=subprocess.DEVNULL)",
            "            return True",
            "        except OSError:",
            "            # No Ghostscript",
            "            pass",
            "    return False",
            "",
            "",
            "def Ghostscript(tile, size, fp, scale=1):",
            "    \"\"\"Render an image using Ghostscript\"\"\"",
            "",
            "    # Unpack decoder tile",
            "    decoder, tile, offset, data = tile[0]",
            "    length, bbox = data",
            "",
            "    # Hack to support hi-res rendering",
            "    scale = int(scale) or 1",
            "    # orig_size = size",
            "    # orig_bbox = bbox",
            "    size = (size[0] * scale, size[1] * scale)",
            "    # resolution is dependent on bbox and size",
            "    res = (",
            "        72.0 * size[0] / (bbox[2] - bbox[0]),",
            "        72.0 * size[1] / (bbox[3] - bbox[1]),",
            "    )",
            "",
            "    out_fd, outfile = tempfile.mkstemp()",
            "    os.close(out_fd)",
            "",
            "    infile_temp = None",
            "    if hasattr(fp, \"name\") and os.path.exists(fp.name):",
            "        infile = fp.name",
            "    else:",
            "        in_fd, infile_temp = tempfile.mkstemp()",
            "        os.close(in_fd)",
            "        infile = infile_temp",
            "",
            "        # Ignore length and offset!",
            "        # Ghostscript can read it",
            "        # Copy whole file to read in Ghostscript",
            "        with open(infile_temp, \"wb\") as f:",
            "            # fetch length of fp",
            "            fp.seek(0, io.SEEK_END)",
            "            fsize = fp.tell()",
            "            # ensure start position",
            "            # go back",
            "            fp.seek(0)",
            "            lengthfile = fsize",
            "            while lengthfile > 0:",
            "                s = fp.read(min(lengthfile, 100 * 1024))",
            "                if not s:",
            "                    break",
            "                lengthfile -= len(s)",
            "                f.write(s)",
            "",
            "    # Build Ghostscript command",
            "    command = [",
            "        \"gs\",",
            "        \"-q\",  # quiet mode",
            "        \"-g%dx%d\" % size,  # set output geometry (pixels)",
            "        \"-r%fx%f\" % res,  # set input DPI (dots per inch)",
            "        \"-dBATCH\",  # exit after processing",
            "        \"-dNOPAUSE\",  # don't pause between pages",
            "        \"-dSAFER\",  # safe mode",
            "        \"-sDEVICE=ppmraw\",  # ppm driver",
            "        f\"-sOutputFile={outfile}\",  # output file",
            "        # adjust for image origin",
            "        \"-c\",",
            "        f\"{-bbox[0]} {-bbox[1]} translate\",",
            "        \"-f\",",
            "        infile,  # input file",
            "        # showpage (see https://bugs.ghostscript.com/show_bug.cgi?id=698272)",
            "        \"-c\",",
            "        \"showpage\",",
            "    ]",
            "",
            "    if gs_windows_binary is not None:",
            "        if not gs_windows_binary:",
            "            raise OSError(\"Unable to locate Ghostscript on paths\")",
            "        command[0] = gs_windows_binary",
            "",
            "    # push data through Ghostscript",
            "    try:",
            "        startupinfo = None",
            "        if sys.platform.startswith(\"win\"):",
            "            startupinfo = subprocess.STARTUPINFO()",
            "            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW",
            "        subprocess.check_call(command, startupinfo=startupinfo)",
            "        out_im = Image.open(outfile)",
            "        out_im.load()",
            "    finally:",
            "        try:",
            "            os.unlink(outfile)",
            "            if infile_temp:",
            "                os.unlink(infile_temp)",
            "        except OSError:",
            "            pass",
            "",
            "    im = out_im.im.copy()",
            "    out_im.close()",
            "    return im",
            "",
            "",
            "class PSFile:",
            "    \"\"\"",
            "    Wrapper for bytesio object that treats either CR or LF as end of line.",
            "    \"\"\"",
            "",
            "    def __init__(self, fp):",
            "        self.fp = fp",
            "        self.char = None",
            "",
            "    def seek(self, offset, whence=io.SEEK_SET):",
            "        self.char = None",
            "        self.fp.seek(offset, whence)",
            "",
            "    def readline(self):",
            "        s = self.char or b\"\"",
            "        self.char = None",
            "",
            "        c = self.fp.read(1)",
            "        while c not in b\"\\r\\n\":",
            "            s = s + c",
            "            c = self.fp.read(1)",
            "",
            "        self.char = self.fp.read(1)",
            "        # line endings can be 1 or 2 of \\r \\n, in either order",
            "        if self.char in b\"\\r\\n\":",
            "            self.char = None",
            "",
            "        return s.decode(\"latin-1\")",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == b\"%!PS\" or (len(prefix) >= 4 and i32(prefix) == 0xC6D3D0C5)",
            "",
            "",
            "##",
            "# Image plugin for Encapsulated PostScript.  This plugin supports only",
            "# a few variants of this format.",
            "",
            "",
            "class EpsImageFile(ImageFile.ImageFile):",
            "    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"",
            "",
            "    format = \"EPS\"",
            "    format_description = \"Encapsulated Postscript\"",
            "",
            "    mode_map = {1: \"L\", 2: \"LAB\", 3: \"RGB\", 4: \"CMYK\"}",
            "",
            "    def _open(self):",
            "        (length, offset) = self._find_offset(self.fp)",
            "",
            "        # Rewrap the open file pointer in something that will",
            "        # convert line endings and decode to latin-1.",
            "        fp = PSFile(self.fp)",
            "",
            "        # go to offset - start of \"%!PS\"",
            "        fp.seek(offset)",
            "",
            "        box = None",
            "",
            "        self.mode = \"RGB\"",
            "        self._size = 1, 1  # FIXME: huh?",
            "",
            "        #",
            "        # Load EPS header",
            "",
            "        s_raw = fp.readline()",
            "        s = s_raw.strip(\"\\r\\n\")",
            "",
            "        while s_raw:",
            "            if s:",
            "                if len(s) > 255:",
            "                    raise SyntaxError(\"not an EPS file\")",
            "",
            "                try:",
            "                    m = split.match(s)",
            "                except re.error as e:",
            "                    raise SyntaxError(\"not an EPS file\") from e",
            "",
            "                if m:",
            "                    k, v = m.group(1, 2)",
            "                    self.info[k] = v",
            "                    if k == \"BoundingBox\":",
            "                        try:",
            "                            # Note: The DSC spec says that BoundingBox",
            "                            # fields should be integers, but some drivers",
            "                            # put floating point values there anyway.",
            "                            box = [int(float(i)) for i in v.split()]",
            "                            self._size = box[2] - box[0], box[3] - box[1]",
            "                            self.tile = [",
            "                                (\"eps\", (0, 0) + self.size, offset, (length, box))",
            "                            ]",
            "                        except Exception:",
            "                            pass",
            "",
            "                else:",
            "                    m = field.match(s)",
            "                    if m:",
            "                        k = m.group(1)",
            "",
            "                        if k == \"EndComments\":",
            "                            break",
            "                        if k[:8] == \"PS-Adobe\":",
            "                            self.info[k[:8]] = k[9:]",
            "                        else:",
            "                            self.info[k] = \"\"",
            "                    elif s[0] == \"%\":",
            "                        # handle non-DSC PostScript comments that some",
            "                        # tools mistakenly put in the Comments section",
            "                        pass",
            "                    else:",
            "                        raise OSError(\"bad EPS header\")",
            "",
            "            s_raw = fp.readline()",
            "            s = s_raw.strip(\"\\r\\n\")",
            "",
            "            if s and s[:1] != \"%\":",
            "                break",
            "",
            "        #",
            "        # Scan for an \"ImageData\" descriptor",
            "",
            "        while s[:1] == \"%\":",
            "",
            "            if len(s) > 255:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if s[:11] == \"%ImageData:\":",
            "                # Encoded bitmapped image.",
            "                x, y, bi, mo = s[11:].split(None, 7)[:4]",
            "",
            "                if int(bi) != 8:",
            "                    break",
            "                try:",
            "                    self.mode = self.mode_map[int(mo)]",
            "                except ValueError:",
            "                    break",
            "",
            "                self._size = int(x), int(y)",
            "                return",
            "",
            "            s = fp.readline().strip(\"\\r\\n\")",
            "            if not s:",
            "                break",
            "",
            "        if not box:",
            "            raise OSError(\"cannot determine EPS bounding box\")",
            "",
            "    def _find_offset(self, fp):",
            "",
            "        s = fp.read(160)",
            "",
            "        if s[:4] == b\"%!PS\":",
            "            # for HEAD without binary preview",
            "            fp.seek(0, io.SEEK_END)",
            "            length = fp.tell()",
            "            offset = 0",
            "        elif i32(s, 0) == 0xC6D3D0C5:",
            "            # FIX for: Some EPS file not handled correctly / issue #302",
            "            # EPS can contain binary data",
            "            # or start directly with latin coding",
            "            # more info see:",
            "            # https://web.archive.org/web/20160528181353/http://partners.adobe.com/public/developer/en/ps/5002.EPSF_Spec.pdf",
            "            offset = i32(s, 4)",
            "            length = i32(s, 8)",
            "        else:",
            "            raise SyntaxError(\"not an EPS file\")",
            "",
            "        return (length, offset)",
            "",
            "    def load(self, scale=1):",
            "        # Load EPS via Ghostscript",
            "        if not self.tile:",
            "            return",
            "        self.im = Ghostscript(self.tile, self.size, self.fp, scale)",
            "        self.mode = self.im.mode",
            "        self._size = self.im.size",
            "        self.tile = []",
            "",
            "    def load_seek(self, *args, **kwargs):",
            "        # we can't incrementally load, so force ImageFile.parser to",
            "        # use our custom load method by defining this method.",
            "        pass",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "def _save(im, fp, filename, eps=1):",
            "    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"",
            "",
            "    #",
            "    # make sure image data is available",
            "    im.load()",
            "",
            "    #",
            "    # determine PostScript image mode",
            "    if im.mode == \"L\":",
            "        operator = (8, 1, \"image\")",
            "    elif im.mode == \"RGB\":",
            "        operator = (8, 3, \"false 3 colorimage\")",
            "    elif im.mode == \"CMYK\":",
            "        operator = (8, 4, \"false 4 colorimage\")",
            "    else:",
            "        raise ValueError(\"image mode is not supported\")",
            "",
            "    base_fp = fp",
            "    wrapped_fp = False",
            "    if fp != sys.stdout:",
            "        fp = io.TextIOWrapper(fp, encoding=\"latin-1\")",
            "        wrapped_fp = True",
            "",
            "    try:",
            "        if eps:",
            "            #",
            "            # write EPS header",
            "            fp.write(\"%!PS-Adobe-3.0 EPSF-3.0\\n\")",
            "            fp.write(\"%%Creator: PIL 0.1 EpsEncode\\n\")",
            "            # fp.write(\"%%CreationDate: %s\"...)",
            "            fp.write(\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)",
            "            fp.write(\"%%Pages: 1\\n\")",
            "            fp.write(\"%%EndComments\\n\")",
            "            fp.write(\"%%Page: 1 1\\n\")",
            "            fp.write(\"%%ImageData: %d %d \" % im.size)",
            "            fp.write('%d %d 0 1 1 \"%s\"\\n' % operator)",
            "",
            "        #",
            "        # image header",
            "        fp.write(\"gsave\\n\")",
            "        fp.write(\"10 dict begin\\n\")",
            "        fp.write(f\"/buf {im.size[0] * operator[1]} string def\\n\")",
            "        fp.write(\"%d %d scale\\n\" % im.size)",
            "        fp.write(\"%d %d 8\\n\" % im.size)  # <= bits",
            "        fp.write(f\"[{im.size[0]} 0 0 -{im.size[1]} 0 {im.size[1]}]\\n\")",
            "        fp.write(\"{ currentfile buf readhexstring pop } bind\\n\")",
            "        fp.write(operator[2] + \"\\n\")",
            "        if hasattr(fp, \"flush\"):",
            "            fp.flush()",
            "",
            "        ImageFile._save(im, base_fp, [(\"eps\", (0, 0) + im.size, 0, None)])",
            "",
            "        fp.write(\"\\n%%%%EndBinary\\n\")",
            "        fp.write(\"grestore end\\n\")",
            "        if hasattr(fp, \"flush\"):",
            "            fp.flush()",
            "    finally:",
            "        if wrapped_fp:",
            "            fp.detach()",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "Image.register_open(EpsImageFile.format, EpsImageFile, _accept)",
            "",
            "Image.register_save(EpsImageFile.format, _save)",
            "",
            "Image.register_extensions(EpsImageFile.format, [\".ps\", \".eps\"])",
            "",
            "Image.register_mime(EpsImageFile.format, \"application/postscript\")"
        ],
        "afterPatchFile": [
            "#",
            "# The Python Imaging Library.",
            "# $Id$",
            "#",
            "# EPS file handling",
            "#",
            "# History:",
            "# 1995-09-01 fl   Created (0.1)",
            "# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)",
            "# 1996-08-22 fl   Don't choke on floating point BoundingBox values",
            "# 1996-08-23 fl   Handle files from Macintosh (0.3)",
            "# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)",
            "# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)",
            "# 2014-05-07 e    Handling of EPS with binary preview and fixed resolution",
            "#                 resizing",
            "#",
            "# Copyright (c) 1997-2003 by Secret Labs AB.",
            "# Copyright (c) 1995-2003 by Fredrik Lundh",
            "#",
            "# See the README file for information on usage and redistribution.",
            "#",
            "",
            "import io",
            "import os",
            "import re",
            "import subprocess",
            "import sys",
            "import tempfile",
            "",
            "from . import Image, ImageFile",
            "from ._binary import i32le as i32",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "split = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")",
            "field = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")",
            "",
            "gs_windows_binary = None",
            "if sys.platform.startswith(\"win\"):",
            "    import shutil",
            "",
            "    for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):",
            "        if shutil.which(binary) is not None:",
            "            gs_windows_binary = binary",
            "            break",
            "    else:",
            "        gs_windows_binary = False",
            "",
            "",
            "def has_ghostscript():",
            "    if gs_windows_binary:",
            "        return True",
            "    if not sys.platform.startswith(\"win\"):",
            "        try:",
            "            subprocess.check_call([\"gs\", \"--version\"], stdout=subprocess.DEVNULL)",
            "            return True",
            "        except OSError:",
            "            # No Ghostscript",
            "            pass",
            "    return False",
            "",
            "",
            "def Ghostscript(tile, size, fp, scale=1):",
            "    \"\"\"Render an image using Ghostscript\"\"\"",
            "",
            "    # Unpack decoder tile",
            "    decoder, tile, offset, data = tile[0]",
            "    length, bbox = data",
            "",
            "    # Hack to support hi-res rendering",
            "    scale = int(scale) or 1",
            "    # orig_size = size",
            "    # orig_bbox = bbox",
            "    size = (size[0] * scale, size[1] * scale)",
            "    # resolution is dependent on bbox and size",
            "    res = (",
            "        72.0 * size[0] / (bbox[2] - bbox[0]),",
            "        72.0 * size[1] / (bbox[3] - bbox[1]),",
            "    )",
            "",
            "    out_fd, outfile = tempfile.mkstemp()",
            "    os.close(out_fd)",
            "",
            "    infile_temp = None",
            "    if hasattr(fp, \"name\") and os.path.exists(fp.name):",
            "        infile = fp.name",
            "    else:",
            "        in_fd, infile_temp = tempfile.mkstemp()",
            "        os.close(in_fd)",
            "        infile = infile_temp",
            "",
            "        # Ignore length and offset!",
            "        # Ghostscript can read it",
            "        # Copy whole file to read in Ghostscript",
            "        with open(infile_temp, \"wb\") as f:",
            "            # fetch length of fp",
            "            fp.seek(0, io.SEEK_END)",
            "            fsize = fp.tell()",
            "            # ensure start position",
            "            # go back",
            "            fp.seek(0)",
            "            lengthfile = fsize",
            "            while lengthfile > 0:",
            "                s = fp.read(min(lengthfile, 100 * 1024))",
            "                if not s:",
            "                    break",
            "                lengthfile -= len(s)",
            "                f.write(s)",
            "",
            "    # Build Ghostscript command",
            "    command = [",
            "        \"gs\",",
            "        \"-q\",  # quiet mode",
            "        \"-g%dx%d\" % size,  # set output geometry (pixels)",
            "        \"-r%fx%f\" % res,  # set input DPI (dots per inch)",
            "        \"-dBATCH\",  # exit after processing",
            "        \"-dNOPAUSE\",  # don't pause between pages",
            "        \"-dSAFER\",  # safe mode",
            "        \"-sDEVICE=ppmraw\",  # ppm driver",
            "        f\"-sOutputFile={outfile}\",  # output file",
            "        # adjust for image origin",
            "        \"-c\",",
            "        f\"{-bbox[0]} {-bbox[1]} translate\",",
            "        \"-f\",",
            "        infile,  # input file",
            "        # showpage (see https://bugs.ghostscript.com/show_bug.cgi?id=698272)",
            "        \"-c\",",
            "        \"showpage\",",
            "    ]",
            "",
            "    if gs_windows_binary is not None:",
            "        if not gs_windows_binary:",
            "            raise OSError(\"Unable to locate Ghostscript on paths\")",
            "        command[0] = gs_windows_binary",
            "",
            "    # push data through Ghostscript",
            "    try:",
            "        startupinfo = None",
            "        if sys.platform.startswith(\"win\"):",
            "            startupinfo = subprocess.STARTUPINFO()",
            "            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW",
            "        subprocess.check_call(command, startupinfo=startupinfo)",
            "        out_im = Image.open(outfile)",
            "        out_im.load()",
            "    finally:",
            "        try:",
            "            os.unlink(outfile)",
            "            if infile_temp:",
            "                os.unlink(infile_temp)",
            "        except OSError:",
            "            pass",
            "",
            "    im = out_im.im.copy()",
            "    out_im.close()",
            "    return im",
            "",
            "",
            "class PSFile:",
            "    \"\"\"",
            "    Wrapper for bytesio object that treats either CR or LF as end of line.",
            "    \"\"\"",
            "",
            "    def __init__(self, fp):",
            "        self.fp = fp",
            "        self.char = None",
            "",
            "    def seek(self, offset, whence=io.SEEK_SET):",
            "        self.char = None",
            "        self.fp.seek(offset, whence)",
            "",
            "    def readline(self):",
            "        s = [self.char or b\"\"]",
            "        self.char = None",
            "",
            "        c = self.fp.read(1)",
            "        while (c not in b\"\\r\\n\") and len(c):",
            "            s.append(c)",
            "            c = self.fp.read(1)",
            "",
            "        self.char = self.fp.read(1)",
            "        # line endings can be 1 or 2 of \\r \\n, in either order",
            "        if self.char in b\"\\r\\n\":",
            "            self.char = None",
            "",
            "        return b\"\".join(s).decode(\"latin-1\")",
            "",
            "",
            "def _accept(prefix):",
            "    return prefix[:4] == b\"%!PS\" or (len(prefix) >= 4 and i32(prefix) == 0xC6D3D0C5)",
            "",
            "",
            "##",
            "# Image plugin for Encapsulated PostScript.  This plugin supports only",
            "# a few variants of this format.",
            "",
            "",
            "class EpsImageFile(ImageFile.ImageFile):",
            "    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"",
            "",
            "    format = \"EPS\"",
            "    format_description = \"Encapsulated Postscript\"",
            "",
            "    mode_map = {1: \"L\", 2: \"LAB\", 3: \"RGB\", 4: \"CMYK\"}",
            "",
            "    def _open(self):",
            "        (length, offset) = self._find_offset(self.fp)",
            "",
            "        # Rewrap the open file pointer in something that will",
            "        # convert line endings and decode to latin-1.",
            "        fp = PSFile(self.fp)",
            "",
            "        # go to offset - start of \"%!PS\"",
            "        fp.seek(offset)",
            "",
            "        box = None",
            "",
            "        self.mode = \"RGB\"",
            "        self._size = 1, 1  # FIXME: huh?",
            "",
            "        #",
            "        # Load EPS header",
            "",
            "        s_raw = fp.readline()",
            "        s = s_raw.strip(\"\\r\\n\")",
            "",
            "        while s_raw:",
            "            if s:",
            "                if len(s) > 255:",
            "                    raise SyntaxError(\"not an EPS file\")",
            "",
            "                try:",
            "                    m = split.match(s)",
            "                except re.error as e:",
            "                    raise SyntaxError(\"not an EPS file\") from e",
            "",
            "                if m:",
            "                    k, v = m.group(1, 2)",
            "                    self.info[k] = v",
            "                    if k == \"BoundingBox\":",
            "                        try:",
            "                            # Note: The DSC spec says that BoundingBox",
            "                            # fields should be integers, but some drivers",
            "                            # put floating point values there anyway.",
            "                            box = [int(float(i)) for i in v.split()]",
            "                            self._size = box[2] - box[0], box[3] - box[1]",
            "                            self.tile = [",
            "                                (\"eps\", (0, 0) + self.size, offset, (length, box))",
            "                            ]",
            "                        except Exception:",
            "                            pass",
            "",
            "                else:",
            "                    m = field.match(s)",
            "                    if m:",
            "                        k = m.group(1)",
            "",
            "                        if k == \"EndComments\":",
            "                            break",
            "                        if k[:8] == \"PS-Adobe\":",
            "                            self.info[k[:8]] = k[9:]",
            "                        else:",
            "                            self.info[k] = \"\"",
            "                    elif s[0] == \"%\":",
            "                        # handle non-DSC PostScript comments that some",
            "                        # tools mistakenly put in the Comments section",
            "                        pass",
            "                    else:",
            "                        raise OSError(\"bad EPS header\")",
            "",
            "            s_raw = fp.readline()",
            "            s = s_raw.strip(\"\\r\\n\")",
            "",
            "            if s and s[:1] != \"%\":",
            "                break",
            "",
            "        #",
            "        # Scan for an \"ImageData\" descriptor",
            "",
            "        while s[:1] == \"%\":",
            "",
            "            if len(s) > 255:",
            "                raise SyntaxError(\"not an EPS file\")",
            "",
            "            if s[:11] == \"%ImageData:\":",
            "                # Encoded bitmapped image.",
            "                x, y, bi, mo = s[11:].split(None, 7)[:4]",
            "",
            "                if int(bi) != 8:",
            "                    break",
            "                try:",
            "                    self.mode = self.mode_map[int(mo)]",
            "                except ValueError:",
            "                    break",
            "",
            "                self._size = int(x), int(y)",
            "                return",
            "",
            "            s = fp.readline().strip(\"\\r\\n\")",
            "            if not s:",
            "                break",
            "",
            "        if not box:",
            "            raise OSError(\"cannot determine EPS bounding box\")",
            "",
            "    def _find_offset(self, fp):",
            "",
            "        s = fp.read(160)",
            "",
            "        if s[:4] == b\"%!PS\":",
            "            # for HEAD without binary preview",
            "            fp.seek(0, io.SEEK_END)",
            "            length = fp.tell()",
            "            offset = 0",
            "        elif i32(s, 0) == 0xC6D3D0C5:",
            "            # FIX for: Some EPS file not handled correctly / issue #302",
            "            # EPS can contain binary data",
            "            # or start directly with latin coding",
            "            # more info see:",
            "            # https://web.archive.org/web/20160528181353/http://partners.adobe.com/public/developer/en/ps/5002.EPSF_Spec.pdf",
            "            offset = i32(s, 4)",
            "            length = i32(s, 8)",
            "        else:",
            "            raise SyntaxError(\"not an EPS file\")",
            "",
            "        return (length, offset)",
            "",
            "    def load(self, scale=1):",
            "        # Load EPS via Ghostscript",
            "        if not self.tile:",
            "            return",
            "        self.im = Ghostscript(self.tile, self.size, self.fp, scale)",
            "        self.mode = self.im.mode",
            "        self._size = self.im.size",
            "        self.tile = []",
            "",
            "    def load_seek(self, *args, **kwargs):",
            "        # we can't incrementally load, so force ImageFile.parser to",
            "        # use our custom load method by defining this method.",
            "        pass",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "def _save(im, fp, filename, eps=1):",
            "    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"",
            "",
            "    #",
            "    # make sure image data is available",
            "    im.load()",
            "",
            "    #",
            "    # determine PostScript image mode",
            "    if im.mode == \"L\":",
            "        operator = (8, 1, \"image\")",
            "    elif im.mode == \"RGB\":",
            "        operator = (8, 3, \"false 3 colorimage\")",
            "    elif im.mode == \"CMYK\":",
            "        operator = (8, 4, \"false 4 colorimage\")",
            "    else:",
            "        raise ValueError(\"image mode is not supported\")",
            "",
            "    base_fp = fp",
            "    wrapped_fp = False",
            "    if fp != sys.stdout:",
            "        fp = io.TextIOWrapper(fp, encoding=\"latin-1\")",
            "        wrapped_fp = True",
            "",
            "    try:",
            "        if eps:",
            "            #",
            "            # write EPS header",
            "            fp.write(\"%!PS-Adobe-3.0 EPSF-3.0\\n\")",
            "            fp.write(\"%%Creator: PIL 0.1 EpsEncode\\n\")",
            "            # fp.write(\"%%CreationDate: %s\"...)",
            "            fp.write(\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)",
            "            fp.write(\"%%Pages: 1\\n\")",
            "            fp.write(\"%%EndComments\\n\")",
            "            fp.write(\"%%Page: 1 1\\n\")",
            "            fp.write(\"%%ImageData: %d %d \" % im.size)",
            "            fp.write('%d %d 0 1 1 \"%s\"\\n' % operator)",
            "",
            "        #",
            "        # image header",
            "        fp.write(\"gsave\\n\")",
            "        fp.write(\"10 dict begin\\n\")",
            "        fp.write(f\"/buf {im.size[0] * operator[1]} string def\\n\")",
            "        fp.write(\"%d %d scale\\n\" % im.size)",
            "        fp.write(\"%d %d 8\\n\" % im.size)  # <= bits",
            "        fp.write(f\"[{im.size[0]} 0 0 -{im.size[1]} 0 {im.size[1]}]\\n\")",
            "        fp.write(\"{ currentfile buf readhexstring pop } bind\\n\")",
            "        fp.write(operator[2] + \"\\n\")",
            "        if hasattr(fp, \"flush\"):",
            "            fp.flush()",
            "",
            "        ImageFile._save(im, base_fp, [(\"eps\", (0, 0) + im.size, 0, None)])",
            "",
            "        fp.write(\"\\n%%%%EndBinary\\n\")",
            "        fp.write(\"grestore end\\n\")",
            "        if hasattr(fp, \"flush\"):",
            "            fp.flush()",
            "    finally:",
            "        if wrapped_fp:",
            "            fp.detach()",
            "",
            "",
            "#",
            "# --------------------------------------------------------------------",
            "",
            "",
            "Image.register_open(EpsImageFile.format, EpsImageFile, _accept)",
            "",
            "Image.register_save(EpsImageFile.format, _save)",
            "",
            "Image.register_extensions(EpsImageFile.format, [\".ps\", \".eps\"])",
            "",
            "Image.register_mime(EpsImageFile.format, \"application/postscript\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "173": [
                "PSFile",
                "readline"
            ],
            "177": [
                "PSFile",
                "readline"
            ],
            "178": [
                "PSFile",
                "readline"
            ],
            "186": [
                "PSFile",
                "readline"
            ]
        },
        "addLocation": []
    }
}